
FreeRTOS.elf:     file format elf32-littlenios2
FreeRTOS.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x02000248

Program Header:
    LOAD off    0x00001000 vaddr 0x02000000 paddr 0x02000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x02000020 paddr 0x02000020 align 2**12
         filesz 0x00048f7c memsz 0x00048f7c flags r-x
    LOAD off    0x00049f9c vaddr 0x02048f9c paddr 0x0204ad80 align 2**12
         filesz 0x00001de4 memsz 0x00001de4 flags rw-
    LOAD off    0x0004cb64 vaddr 0x0204cb64 paddr 0x0204cb64 align 2**12
         filesz 0x00000000 memsz 0x00122dbc flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  02000000  02000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000228  02000020  02000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000462b4  02000248  02000248  00001248  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00002aa0  020464fc  020464fc  000474fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001de4  02048f9c  0204ad80  00049f9c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00122e42  0204cb64  0204cb64  0004cb64  2**2
                  ALLOC, SMALL_DATA
  6 .sdram_controller_0 00000000  0216f920  0216f920  0004bd80  2**0
                  CONTENTS
  7 .tse_descriptor_memory_0 00000000  04000000  04000000  0004bd80  2**0
                  CONTENTS
  8 .mem_0        00000000  05020000  05020000  0004bd80  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  0004bd80  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000016e0  00000000  00000000  0004bda8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00053246  00000000  00000000  0004d488  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000109ac  00000000  00000000  000a06ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001ae3b  00000000  00000000  000b107a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00009b8c  00000000  00000000  000cbeb8  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000ccaa  00000000  00000000  000d5a44  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001d00f  00000000  00000000  000e26ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  000ff700  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001cd8  00000000  00000000  000ff750  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000008  00000000  00000000  0010cb26  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  0010cb2e  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0010cb33  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0010cb34  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000006  00000000  00000000  0010cb35  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000006  00000000  00000000  0010cb3b  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000006  00000000  00000000  0010cb41  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000004  00000000  00000000  0010cb47  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001c  00000000  00000000  0010cb4b  2**0
                  CONTENTS, READONLY
 28 .jdi          0000495a  00000000  00000000  0010cb67  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     0009cd38  00000000  00000000  001114c1  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
02000000 l    d  .entry	00000000 .entry
02000020 l    d  .exceptions	00000000 .exceptions
02000248 l    d  .text	00000000 .text
020464fc l    d  .rodata	00000000 .rodata
02048f9c l    d  .rwdata	00000000 .rwdata
0204cb64 l    d  .bss	00000000 .bss
0216f920 l    d  .sdram_controller_0	00000000 .sdram_controller_0
04000000 l    d  .tse_descriptor_memory_0	00000000 .tse_descriptor_memory_0
05020000 l    d  .mem_0	00000000 .mem_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../FreeRTOS_bsp//obj/HAL/src/crt0.o
02000280 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 port_asm.o
02000020 l       .exceptions	00000000 save_context
0200009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
020000ac l       .exceptions	00000000 hw_irq_test
02000150 l       .exceptions	00000000 soft_exceptions
020000c0 l       .exceptions	00000000 hw_irq_handler
020000d4 l       .exceptions	00000000 restore_context
0200016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
0204cb64 l     O .bss	00000004 nw_ready
0204cb68 l     O .bss	00000004 main_thread_handle
020002dc l     F .text	000000b0 StatusCallback
0200038c l     F .text	00000044 LinkCallback
02000418 l     F .text	000001cc WaitOnPHY
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 vfprintf.c
02046a32 l     O .rodata	00000010 zeroes.4404
02002c34 l     F .text	000000bc __sbprintf
02046a42 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
02002e44 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
02004974 l     F .text	00000008 __fp_unlock
02004988 l     F .text	0000019c __sinit.part.1
02004b24 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
02048f9c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 locale.c
020493e0 l     O .rwdata	00000020 lc_ctype_charset
020493c0 l     O .rwdata	00000020 lc_message_charset
02049400 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mprec.c
02046a74 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
0200743c l     F .text	000000fc __sprint_r.part.0
02046ba8 l     O .rodata	00000010 blanks.4348
02046b98 l     O .rodata	00000010 zeroes.4349
020089c8 l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 queue.c
0200d578 l     F .text	00000090 prvInitialiseNewQueue
0200d608 l     F .text	00000060 prvInitialiseMutex
0200e570 l     F .text	0000018c prvCopyDataToQueue
0200e954 l     F .text	00000068 prvIsQueueFull
0200e798 l     F .text	00000114 prvUnlockQueue
0200e6fc l     F .text	0000009c prvCopyDataFromQueue
0200e8ac l     F .text	00000060 prvIsQueueEmpty
0200e520 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 tasks.c
0204cd34 l     O .bss	00000064 pxReadyTasksLists
0204cd98 l     O .bss	00000014 xDelayedTaskList1
0204cdac l     O .bss	00000014 xDelayedTaskList2
0204cba4 l     O .bss	00000004 pxDelayedTaskList
0204cba8 l     O .bss	00000004 pxOverflowDelayedTaskList
0204cdc0 l     O .bss	00000014 xPendingReadyList
0204cdd4 l     O .bss	00000014 xTasksWaitingTermination
0204cbac l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0204cde8 l     O .bss	00000014 xSuspendedTaskList
0204cbb0 l     O .bss	00000004 uxCurrentNumberOfTasks
0204cbb4 l     O .bss	00000004 xTickCount
0204cbb8 l     O .bss	00000004 uxTopReadyPriority
0204cbbc l     O .bss	00000004 xSchedulerRunning
0204cbc0 l     O .bss	00000004 xPendedTicks
0204cbc4 l     O .bss	00000004 xYieldPending
0204cbc8 l     O .bss	00000004 xNumOfOverflows
0204cbcc l     O .bss	00000004 uxTaskNumber
0204cbd0 l     O .bss	00000004 xNextTaskUnblockTime
0204cbd4 l     O .bss	00000004 xIdleTaskHandle
0204cbd8 l     O .bss	00000004 uxSchedulerSuspended
0200ebb4 l     F .text	000001e4 prvInitialiseNewTask
0200ed98 l     F .text	00000118 prvAddNewTaskToReadyList
020104d8 l     F .text	000000b8 prvInitialiseTaskLists
02010960 l     F .text	00000044 prvDeleteTCB
020109a4 l     F .text	00000054 prvResetNextTaskUnblockTime
020116bc l     F .text	000000e8 prvAddCurrentTaskToDelayedList
0200f598 l     F .text	0000006c prvTaskIsTaskSuspended
020104bc l     F .text	0000001c prvIdleTask
02010778 l     F .text	00000128 prvListTasksWithinSingleList
02010590 l     F .text	00000090 prvCheckTasksWaitingTermination
020108a0 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
0204cdfc l     O .bss	00000014 xActiveTimerList1
0204ce10 l     O .bss	00000014 xActiveTimerList2
0204cbdc l     O .bss	00000004 pxCurrentTimerList
0204cbe0 l     O .bss	00000004 pxOverflowTimerList
0204cbe4 l     O .bss	00000004 xTimerQueue
0204cbe8 l     O .bss	00000004 xTimerTaskHandle
0201226c l     F .text	0000008c prvCheckForValidListAndQueue
02011c94 l     F .text	0000003c prvTimerTask
02011884 l     F .text	000000a4 prvInitialiseNewTimer
02011bbc l     F .text	000000d8 prvProcessExpiredTimer
02011e64 l     F .text	000000dc prvInsertTimerInActiveList
02011d98 l     F .text	00000068 prvGetNextExpireTime
02011cd0 l     F .text	000000c8 prvProcessTimerOrBlockTask
02011f40 l     F .text	00000218 prvProcessReceivedCommands
02011e00 l     F .text	00000064 prvSampleTimeNow
0204cbec l     O .bss	00000004 xLastTime.2917
02012158 l     F .text	00000114 prvSwitchTimerLists
00000000 l    df *ABS*	00000000 alt_dev.c
02012478 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_fstat.c
02012564 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_io_redirect.c
02012650 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_isatty.c
02012790 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
02012870 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0201295c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_open.c
02012a6c l     F .text	0000003c alt_get_errno
02012aa8 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0204ad28 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_lwip_close.c
00000000 l    df *ABS*	00000000 alt_lwip_read.c
00000000 l    df *ABS*	00000000 alt_lwip_write.c
00000000 l    df *ABS*	00000000 altera_tse_ethernetif.c
02013154 l     F .text	00000074 low_level_init
020131c8 l     F .text	00000154 low_level_input
00000000 l    df *ABS*	00000000 lwip_main.c
0204cbf4 l     O .bss	00000004 status_callback
0204cbf8 l     O .bss	00000004 link_callback
02013768 l     F .text	0000024c lwip_handle_interfaces
02013d6c l     F .text	00000040 lwip_status_callback
02013bc4 l     F .text	000000f0 lwip_handle_ethernet_input
02013b10 l     F .text	000000b4 lwip_check_link_status
00000000 l    df *ABS*	00000000 lwip_tse_mac.c
00000000 l    df *ABS*	00000000 sys_arch.c
00000000 l    df *ABS*	00000000 dhcp.c
0204ad2c l     O .rwdata	00000003 dhcp_discover_request_options
0204cc0c l     O .bss	00000004 dhcp_pcb
0204cc10 l     O .bss	00000001 dhcp_pcb_refcount
02015594 l     F .text	000000ac dhcp_inc_pcb_refcount
02018070 l     F .text	00000310 dhcp_recv
02015640 l     F .text	00000050 dhcp_dec_pcb_refcount
02015690 l     F .text	00000060 dhcp_handle_nak
020175e4 l     F .text	0000005c dhcp_set_state
02016758 l     F .text	00000224 dhcp_discover
020156f0 l     F .text	000000bc dhcp_conflict_callback
0201697c l     F .text	000002cc dhcp_bind
02016618 l     F .text	00000140 dhcp_decline
020157ac l     F .text	00000060 dhcp_check
0201580c l     F .text	000000b0 dhcp_handle_offer
020158bc l     F .text	00000334 dhcp_select
02018380 l     F .text	00000368 dhcp_create_msg
02017640 l     F .text	00000078 dhcp_option
0201770c l     F .text	00000078 dhcp_option_short
02017784 l     F .text	000000c4 dhcp_option_long
020176b8 l     F .text	00000054 dhcp_option_byte
02017848 l     F .text	000000f0 dhcp_option_hostname
020186e8 l     F .text	000000b4 dhcp_option_trailer
02015fb4 l     F .text	000000e8 dhcp_t2_timeout
02015ee0 l     F .text	000000d4 dhcp_t1_timeout
02015df0 l     F .text	000000f0 dhcp_timeout
020170c8 l     F .text	0000029c dhcp_reboot
02016e8c l     F .text	0000023c dhcp_rebind
0201609c l     F .text	00000188 dhcp_handle_ack
02017938 l     F .text	00000738 dhcp_parse_reply
0204ad30 l     O .rwdata	00000004 xid.4539
00000000 l    df *ABS*	00000000 etharp.c
0204ce24 l     O .bss	00000258 arp_table
0201882c l     F .text	00000068 free_etharp_q
02018894 l     F .text	0000009c etharp_free_entry
02018b60 l     F .text	00000368 etharp_find_entry
02018ec8 l     F .text	000001d4 etharp_update_arp_entry
02019e98 l     F .text	000001e4 etharp_raw
02019560 l     F .text	000001b0 etharp_output_to_arp_index
0201a07c l     F .text	00000078 etharp_request_dst
00000000 l    df *ABS*	00000000 ip4_addr.c
0204d07c l     O .bss	00000010 str.3820
00000000 l    df *ABS*	00000000 mem.c
0204cc1c l     O .bss	00000004 ram
0204cc20 l     O .bss	00000004 ram_end
0204cc24 l     O .bss	00000004 mem_mutex
0204cc28 l     O .bss	00000004 lfree
0201a9ac l     F .text	00000030 ptr_to_mem
0201a9dc l     F .text	0000002c mem_to_ptr
0201aa08 l     F .text	00000160 plug_holes
0201ac1c l     F .text	000000e0 mem_link_valid
00000000 l    df *ABS*	00000000 memp.c
0204d08c l     O .bss	00000010 memp_stats_RAW_PCB
0204cc2c l     O .bss	00000004 memp_tab_RAW_PCB
0204d09c l     O .bss	00000010 memp_stats_UDP_PCB
0204cc30 l     O .bss	00000004 memp_tab_UDP_PCB
0204d0ac l     O .bss	00000010 memp_stats_TCP_PCB
0204cc34 l     O .bss	00000004 memp_tab_TCP_PCB
0204d0bc l     O .bss	00000010 memp_stats_TCP_PCB_LISTEN
0204cc38 l     O .bss	00000004 memp_tab_TCP_PCB_LISTEN
0204d0cc l     O .bss	00000010 memp_stats_TCP_SEG
0204cc3c l     O .bss	00000004 memp_tab_TCP_SEG
0204d0dc l     O .bss	00000010 memp_stats_REASSDATA
0204cc40 l     O .bss	00000004 memp_tab_REASSDATA
0204d0ec l     O .bss	00000010 memp_stats_FRAG_PBUF
0204cc44 l     O .bss	00000004 memp_tab_FRAG_PBUF
0204d0fc l     O .bss	00000010 memp_stats_NETBUF
0204cc48 l     O .bss	00000004 memp_tab_NETBUF
0204d10c l     O .bss	00000010 memp_stats_NETCONN
0204cc4c l     O .bss	00000004 memp_tab_NETCONN
0204d11c l     O .bss	00000010 memp_stats_TCPIP_MSG_API
0204cc50 l     O .bss	00000004 memp_tab_TCPIP_MSG_API
0204d12c l     O .bss	00000010 memp_stats_TCPIP_MSG_INPKT
0204cc54 l     O .bss	00000004 memp_tab_TCPIP_MSG_INPKT
0204d13c l     O .bss	00000010 memp_stats_ARP_QUEUE
0204cc58 l     O .bss	00000004 memp_tab_ARP_QUEUE
0204d14c l     O .bss	00000010 memp_stats_SYS_TIMEOUT
0204cc5c l     O .bss	00000004 memp_tab_SYS_TIMEOUT
0204d15c l     O .bss	00000010 memp_stats_PBUF
0204cc60 l     O .bss	00000004 memp_tab_PBUF
0204d16c l     O .bss	00000010 memp_stats_PBUF_POOL
0204cc64 l     O .bss	00000004 memp_tab_PBUF_POOL
0201b710 l     F .text	000000dc do_memp_malloc_pool
0201b894 l     F .text	00000080 do_memp_free_pool
00000000 l    df *ABS*	00000000 netif.c
0204cc68 l     O .bss	00000001 netif_num
0201c518 l     F .text	0000002c netif_null_output_ip4
0201bcd8 l     F .text	00000054 netif_do_ip_addr_changed
0201bd2c l     F .text	000000d8 netif_do_set_ipaddr
0201c288 l     F .text	00000058 netif_issue_reports
0201be60 l     F .text	0000006c netif_do_set_netmask
0201bf2c l     F .text	0000006c netif_do_set_gw
00000000 l    df *ABS*	00000000 pbuf.c
0201c7b4 l     F .text	00000070 pbuf_free_ooseq
0201c824 l     F .text	00000030 pbuf_free_ooseq_callback
0201c854 l     F .text	00000084 pbuf_pool_is_empty
0201c8d8 l     F .text	0000009c pbuf_init_alloced_pbuf
0201ceb0 l     F .text	00000144 pbuf_add_header_impl
0201d140 l     F .text	00000070 pbuf_header_impl
0201daac l     F .text	00000094 pbuf_skip_const
00000000 l    df *ABS*	00000000 raw.c
0204cc78 l     O .bss	00000004 raw_pcbs
0201e418 l     F .text	000000c4 raw_input_local_match
00000000 l    df *ABS*	00000000 stats.c
00000000 l    df *ABS*	00000000 tcp.c
02046f90 l     O .rodata	0000002c tcp_state_str
0204ad3c l     O .rwdata	00000002 tcp_port
02046fbc l     O .rodata	0000000d tcp_backoff
0204ad3e l     O .rwdata	00000007 tcp_persist_backoff
0204cc7c l     O .bss	00000001 tcp_timer
0204cc7d l     O .bss	00000001 tcp_timer_ctr
0201edd8 l     F .text	00000038 tcp_free_listen
0201ee5c l     F .text	00000060 tcp_remove_listener
0201eebc l     F .text	0000007c tcp_listen_closed
0201f01c l     F .text	00000250 tcp_close_shutdown
0201f26c l     F .text	0000011c tcp_close_shutdown_fin
0201fe40 l     F .text	000000dc tcp_new_port
0201f97c l     F .text	00000040 tcp_accept_null
02021074 l     F .text	0000010c tcp_kill_prio
02021180 l     F .text	000000ac tcp_kill_state
0202122c l     F .text	00000094 tcp_kill_timewait
020212c0 l     F .text	00000088 tcp_handle_closepend
0204ad48 l     O .rwdata	00000004 iss.4544
02021a40 l     F .text	00000084 tcp_netif_ip_addr_changed_pcblist
00000000 l    df *ABS*	00000000 tcp_in.c
0204d17c l     O .bss	00000014 inseg
0204cc94 l     O .bss	00000004 tcphdr
0204cc98 l     O .bss	00000002 tcphdr_optlen
0204cc9a l     O .bss	00000002 tcphdr_opt1len
0204cc9c l     O .bss	00000004 tcphdr_opt2
0204cca0 l     O .bss	00000002 tcp_optidx
0204cca4 l     O .bss	00000004 seqno
0204cca8 l     O .bss	00000004 ackno
0204ccac l     O .bss	00000002 recv_acked
0204ccae l     O .bss	00000002 tcplen
0204ccb0 l     O .bss	00000001 flags
0204ccb1 l     O .bss	00000001 recv_flags
0204ccb4 l     O .bss	00000004 recv_data
02022f70 l     F .text	00000148 tcp_timewait_input
02022be0 l     F .text	00000390 tcp_listen_input
020230b8 l     F .text	00000b48 tcp_process
02022b4c l     F .text	00000094 tcp_input_delayed_close
02025a4c l     F .text	0000012c tcp_parseopt
02023fc0 l     F .text	00001a04 tcp_receive
02023c00 l     F .text	00000274 tcp_oos_insert_segment
02023e74 l     F .text	0000014c tcp_free_acked_segments
020259c4 l     F .text	00000088 tcp_get_next_optbyte
00000000 l    df *ABS*	00000000 tcp_out.c
02025ba4 l     F .text	00000068 tcp_route
02025c0c l     F .text	00000318 tcp_create_segment
02025f24 l     F .text	00000120 tcp_pbuf_prealloc
02026044 l     F .text	000000b8 tcp_seg_add_chksum
020260fc l     F .text	00000108 tcp_write_checks
02027d24 l     F .text	00000508 tcp_output_segment
02027ce0 l     F .text	00000044 tcp_output_segment_busy
02028700 l     F .text	00000360 tcp_output_alloc_header_common
02028a60 l     F .text	000000c0 tcp_output_alloc_header
02028b20 l     F .text	00000054 tcp_output_fill_options
02028b74 l     F .text	00000180 tcp_output_control_segment
00000000 l    df *ABS*	00000000 timeouts.c
0204ccbc l     O .bss	00000004 next_timeout
0204ccc0 l     O .bss	00000004 current_timeout_due_time
0204ccc4 l     O .bss	00000004 tcpip_tcp_timer_active
0202925c l     F .text	0000005c tcpip_tcp_timer
02029314 l     F .text	00000124 sys_timeout_abs
02029438 l     F .text	000000a8 lwip_cyclic_timer
00000000 l    df *ABS*	00000000 udp.c
0204ad50 l     O .rwdata	00000002 udp_port
0202984c l     F .text	0000009c udp_new_port
020298e8 l     F .text	00000108 udp_input_local_match
00000000 l    df *ABS*	00000000 ethernet.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0202b0c4 l     F .text	00000034 alt_dev_reg
02049928 l     O .rwdata	00001068 jtag_uart_0
0204a990 l     O .rwdata	00000030 sgdma_tse_rx_0
0204a9c0 l     O .rwdata	00000030 sgdma_tse_tx_0
0204a9f0 l     O .rwdata	000000cc uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0202b488 l     F .text	0000020c altera_avalon_jtag_uart_irq
0202b694 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0202bd44 l     F .text	0000003c alt_get_errno
0202c974 l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0202cad8 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
0202ce38 l     F .text	0000009c altera_avalon_uart_irq
0202ced4 l     F .text	000000e4 altera_avalon_uart_rxirq
0202cfb8 l     F .text	00000148 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
0202d154 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0202d3a8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
00000000 l    df *ABS*	00000000 heap_1.c
0204d190 l     O .bss	00100000 ucHeap
0204ccd0 l     O .bss	00000004 xNextFreeByte
0204ccd4 l     O .bss	00000004 pucAlignedHeap.2611
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
0202da34 l     F .text	0000002c prvReadGp
0204ccd8 l     O .bss	00000004 lastContext
0202dc24 l     F .text	0000009c prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 tse_ethernet_phys.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0202dfa8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0202e0fc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_read.c
0202e728 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0202ea64 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 sockets.c
0214d190 l     O .bss	000002a0 sockets
0204cce8 l     O .bss	00000004 select_cb_ctr
0204ccec l     O .bss	00000004 select_cb_list
0202ebfc l     F .text	0000005c tryget_socket_unconn_nouse
0202ec88 l     F .text	00000038 tryget_socket_unconn
0202ecc0 l     F .text	00000038 tryget_socket_unconn_locked
0202ecf8 l     F .text	00000054 tryget_socket
0202ed4c l     F .text	00000058 get_socket
0202eda4 l     F .text	00000148 alloc_socket
0202eeec l     F .text	00000060 free_socket_locked
0202ef4c l     F .text	0000007c free_socket_free_elements
0202efc8 l     F .text	00000080 free_socket
0202f788 l     F .text	00000260 lwip_recv_tcp
0202f9e8 l     F .text	000000fc lwip_sock_make_addr
0202fae4 l     F .text	000000bc lwip_recv_tcp_from
0202fba0 l     F .text	0000027c lwip_recvfrom_udp_raw
02031dd4 l     F .text	0000024c event_callback
02030d84 l     F .text	00000070 lwip_link_select_cb
02030df4 l     F .text	00000098 lwip_unlink_select_cb
02030e8c l     F .text	00000428 lwip_selscan
0203184c l     F .text	00000300 lwip_pollscan
02031d00 l     F .text	000000d4 lwip_poll_should_wake
02032020 l     F .text	000001fc select_check_waiters
02032390 l     F .text	00000158 lwip_getaddrname
020326d4 l     F .text	00000090 lwip_getsockopt_callback
020327c0 l     F .text	000006b0 lwip_getsockopt_impl
02032764 l     F .text	0000005c lwip_sockopt_to_ipopt
02032fc0 l     F .text	00000090 lwip_setsockopt_callback
02033050 l     F .text	00000664 lwip_setsockopt_impl
00000000 l    df *ABS*	00000000 tcpip.c
0204ccf0 l     O .bss	00000004 tcpip_init_done
0204ccf4 l     O .bss	00000004 tcpip_init_done_arg
0204ccf8 l     O .bss	00000004 tcpip_mbox
02033a9c l     F .text	0000008c tcpip_timeouts_mbox_fetch
02033b28 l     F .text	00000058 tcpip_thread
02033b80 l     F .text	000001f8 tcpip_thread_handle_msg
020343ec l     F .text	0000003c pbuf_free_int
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
0204ccfe l     O .bss	00000001 tse_system_count.4134
0204ccff l     O .bss	00000001 is_init.4216
00000000 l    df *ABS*	00000000 def.c
00000000 l    df *ABS*	00000000 inet_chksum.c
02039bd8 l     F .text	00000184 inet_cksum_pseudo_base
02039ea4 l     F .text	000001b8 inet_cksum_pseudo_partial_base
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 ip.c
00000000 l    df *ABS*	00000000 acd.c
0203a89c l     F .text	000000a8 acd_restart
0203aad4 l     F .text	000000a0 acd_handle_arp_conflict
0203ab74 l     F .text	000000ac acd_put_in_passive_mode
00000000 l    df *ABS*	00000000 icmp.c
0203b3c8 l     F .text	000001fc icmp_send_response
00000000 l    df *ABS*	00000000 ip4.c
0204cd00 l     O .bss	00000002 ip_id
0203b720 l     F .text	00000094 ip4_input_accept
00000000 l    df *ABS*	00000000 ip4_frag.c
0204cd04 l     O .bss	00000004 reassdatagrams
0204cd08 l     O .bss	00000002 ip_reass_pbufcount
0203c780 l     F .text	00000190 ip_reass_free_complete_datagram
0203cb90 l     F .text	00000068 ip_reass_dequeue_datagram
0203c910 l     F .text	000001a4 ip_reass_remove_oldest_datagram
0203cab4 l     F .text	000000dc ip_reass_enqueue_new_datagram
0203cbf8 l     F .text	00000790 ip_reass_chain_frag_into_datagram_and_validate
0203d9d8 l     F .text	0000002c ip_frag_alloc_pbuf_custom_ref
0203da04 l     F .text	00000038 ip_frag_free_pbuf_custom_ref
0203da3c l     F .text	00000058 ipfrag_free_pbuf_custom
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 api_lib.c
0203e104 l     F .text	00000064 netconn_apimsg
0203e778 l     F .text	00000228 netconn_recv_data
0203e9a0 l     F .text	0000007c netconn_tcp_recvd_msg
0203ea88 l     F .text	000001a0 netconn_recv_data_tcp
0203f1d8 l     F .text	00000074 netconn_close_shutdown
00000000 l    df *ABS*	00000000 api_msg.c
0203f354 l     F .text	00000060 lwip_netconn_err_to_msg
0203f43c l     F .text	00000148 recv_raw
0203f584 l     F .text	00000140 recv_udp
0203f6c4 l     F .text	0000011c recv_tcp
0203f7e0 l     F .text	00000130 poll_tcp
020415ac l     F .text	00000480 lwip_netconn_do_writemore
0204043c l     F .text	00000338 lwip_netconn_do_close_internal
0203f910 l     F .text	000000fc sent_tcp
0203fa0c l     F .text	00000214 err_tcp
0203fc20 l     F .text	00000088 setup_tcp
0203fca8 l     F .text	00000238 accept_function
0203fee0 l     F .text	000001c8 pcb_new
020402cc l     F .text	00000170 netconn_drain
02040be4 l     F .text	00000124 lwip_netconn_do_connected
00000000 l    df *ABS*	00000000 err.c
02048c90 l     O .rodata	00000044 err_to_errno_table
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
02048dd5 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 snprintf.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
02048f5c l     O .rodata	00000010 zeroes.4389
02048f6c l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 vfprintf.c
02048f8c l     O .rodata	00000010 blanks.4332
02048f7c l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 alt_exit.c
0203a1c4 g     F .text	00000044 inet_chksum
0201e650 g     F .text	00000060 raw_bind
02006f4c g     F .text	00000074 _mprec_log10
02035710 g     F .text	000000d8 alt_tse_get_mac_info
0201cd3c g     F .text	00000174 pbuf_realloc
0201e6b0 g     F .text	00000054 raw_bind_netif
02007038 g     F .text	0000008c __any_on
02009420 g     F .text	00000054 _isatty_r
02046a80 g     O .rodata	00000028 __mprec_tinytens
0200d240 g     F .text	000000d8 alt_main
0204289c g     F .text	00000090 strcpy
02021970 g     F .text	00000034 tcp_next_iss
0204260c g     F .text	000000c0 _puts_r
02034270 g     F .text	00000034 tcpip_callbackmsg_trycallback
0216f7c8 g     O .bss	00000100 alt_irq
0201fc88 g     F .text	000000f0 tcp_update_rcv_ann_wnd
02046e5c g     O .rodata	00000010 memp_NETBUF
02009474 g     F .text	00000060 _lseek_r
020000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
0200fffc g     F .text	00000064 vTaskPlaceOnUnorderedEventList
0202d778 g     F .text	0000002c xPortGetFreeHeapSize
0204cc6c g     O .bss	00000004 netif_list
02016270 g     F .text	00000050 dhcp_cleanup
02020cc0 g     F .text	00000064 tcp_txnow
0201de80 g     F .text	00000074 pbuf_clone
0203930c g     F .text	000000f0 marvell_cfg_rgmii
0201d030 g     F .text	0000003c pbuf_add_header_force
0204ad80 g       *ABS*	00000000 __flash_rwdata_start
0202dab0 g     F .text	0000003c enh_alt_irq_enable_all
02013cb4 g     F .text	000000b8 print_ipad
0200bd2c g     F .text	00000088 .hidden __eqdf2
02028cf4 g     F .text	000000dc tcp_rst
0201e2b0 g     F .text	000000c4 pbuf_memfind
02036900 g     F .text	00000210 alt_tse_phy_print_profile
02033a2c g     F .text	00000070 lwip_inet_pton
02021ac4 g     F .text	000000bc tcp_netif_ip_addr_changed
0216f920 g       *ABS*	00000000 __alt_heap_start
02040984 g     F .text	00000140 lwip_netconn_do_bind
020390ac g     F .text	00000098 marvell_phy_cfg
0200f214 g     F .text	00000068 uxTaskPriorityGet
02041228 g     F .text	00000224 lwip_netconn_do_send
0201180c g     F .text	00000078 xTimerCreate
0201a0f4 g     F .text	0000003c etharp_request
02029f2c g     F .text	00000094 udp_send_chksum
0204027c g     F .text	00000050 netconn_free
020009e4 g     F .text	0000003c printf
020162c0 g     F .text	00000168 dhcp_start
0201b5a4 g     F .text	000000c0 memp_init_pool
0202bea4 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
02009d4c g     F .text	0000009c _wcrtomb_r
02039e44 g     F .text	00000060 ip_chksum_pseudo
02021688 g     F .text	0000003c tcp_err
0204ad34 g     O .rwdata	00000004 ip_addr_any
02039d5c g     F .text	000000e8 inet_chksum_pseudo
0203a3b8 g     F .text	0000008c acd_add
02007264 g     F .text	0000005c __sseek
0202ab34 g     F .text	000000b0 udp_remove
02004cc4 g     F .text	00000010 __sinit
02010620 g     F .text	00000158 vTaskGetInfo
02009bf4 g     F .text	00000140 __swbuf_r
0202a30c g     F .text	00000450 udp_sendto_if_src_chksum
0200ea0c g     F .text	000000c8 vQueueWaitForMessageRestricted
0202a2a4 g     F .text	00000068 udp_sendto_if_src
020052d0 g     F .text	0000007c _setlocale_r
02004b2c g     F .text	00000068 __sfmoreglue
02039820 g     F .text	00000184 lwip_itoa
0201b964 g     F .text	00000078 memp_free
0200d378 g     F .text	00000044 __malloc_unlock
02031b4c g     F .text	000001b4 lwip_poll
02013a68 g     F .text	00000034 lwip_set_status_callback
0201d2f4 g     F .text	00000138 pbuf_free
02021610 g     F .text	0000003c tcp_recv
02035954 g     F .text	00000a7c getPHYSpeed
02046dfc g     O .rodata	00000010 memp_UDP_PCB
0201d4d4 g     F .text	000000ac pbuf_cat
02000774 g     F .text	000000b8 get_ip_addr
0202c5bc g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
0203a5a0 g     F .text	000002fc acd_tmr
0202fe1c g     F .text	000001ac lwip_recvfrom
020094d4 g     F .text	0000015c memmove
0201909c g     F .text	000000a0 etharp_cleanup_netif
020340b8 g     F .text	00000060 tcpip_send_msg_wait_sem
02029fc0 g     F .text	00000058 udp_sendto
02010de8 g     F .text	00000048 vTaskEnterCritical
020136dc g     F .text	0000008c lwip_wait_for_an
02004cac g     F .text	00000018 _cleanup
020427b8 g     F .text	000000e4 snprintf
0200da2c g     F .text	000000f4 xQueueGenericSendFromISR
0200fa8c g     F .text	00000040 pcTaskGetName
0216f908 g     O .bss	00000018 ip_data
020060c8 g     F .text	000000a8 _Balloc
0201a390 g     F .text	00000044 ipaddr_addr
0201a130 g     F .text	00000070 etharp_acd_probe
02028efc g     F .text	000000b4 tcp_keepalive
0201b9fc g     F .text	0000005c netif_input
02018930 g     F .text	00000230 etharp_tmr
02038310 g     F .text	000001c4 alt_tse_phy_set_adv_1000
02041f40 g     F .text	00000074 netbuf_delete
0204ad78 g     O .rwdata	00000001 max_mac_system
02021348 g     F .text	00000224 tcp_alloc
020349c4 g     F .text	000009fc alt_tse_system_add_sys
0200bdb4 g     F .text	000000dc .hidden __gtdf2
0202eb98 g     F .text	00000024 altera_nios2_gen2_irq_init
020423b8 g     F .text	00000010 __errno
02041fb4 g     F .text	000000ac netbuf_alloc
020341c8 g     F .text	00000070 tcpip_callbackmsg_new
0203053c g     F .text	0000045c lwip_sendmsg
0202a124 g     F .text	00000060 udp_sendto_if
02000000 g     F .entry	0000001c __reset
0200d6c4 g     F .text	00000090 xQueueGiveMutexRecursive
021554d3 g     O .bss	0000034b memp_memory_NETBUF_base
0203f2e0 g     F .text	00000074 netconn_shutdown
0201e77c g     F .text	00000050 raw_disconnect
020215d4 g     F .text	0000003c tcp_arg
0204cba0 g     O .bss	00000004 pxCurrentTCB
020294e0 g     F .text	00000088 sys_timeouts_init
0204cc7e g     O .bss	00000001 tcp_active_pcbs_changed
02013ad0  w    F .text	00000040 lwip_is_interface_up
02014ed8 g     F .text	00000060 sys_mutex_free
0204cc80 g     O .bss	00000004 tcp_active_pcbs
0202c10c g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
0201c4dc g     F .text	0000003c netif_set_link_callback
02000020 g       *ABS*	00000000 __flash_exceptions_start
0204ccc8 g     O .bss	00000004 udp_pcbs
02008f08 g     F .text	0000005c _fstat_r
0204aabc g     O .rwdata	00000240 tse_mac_device
0204cb8c g     O .bss	00000004 errno
0201f3f4 g     F .text	00000100 tcp_shutdown
0202ad08 g     F .text	0000029c ethernet_input
020071e0 g     F .text	00000008 __seofread
02045290 g     F .text	0000123c ___svfiprintf_internal_r
02038bf8 g     F .text	000004b4 alt_tse_phy_set_common_speed
0201d478 g     F .text	0000005c pbuf_ref
0200d200  w    F .text	00000020 pre_constructors
0216f8c8 g     O .bss	00000020 pmac_groups
0201becc g     F .text	00000060 netif_set_netmask
02015288 g     F .text	00000084 sys_mbox_trypost
0204cb94 g     O .bss	00000004 alt_argv
02052cfc g       *ABS*	00000000 _gp
02020fe8 g     F .text	0000008c tcp_recv_null
0202ea34 g     F .text	00000030 usleep
020192d0 g     F .text	00000290 etharp_input
0203f24c g     F .text	00000034 netconn_close
0201a3d4 g     F .text	00000408 ip4addr_aton
020273a8 g     F .text	0000020c tcp_enqueue_flags
02041ef4 g     F .text	0000004c netbuf_new
02040d08 g     F .text	00000234 lwip_netconn_do_connect
0200f2c8 g     F .text	000001b4 vTaskPrioritySet
0204cb9c g     O .bss	00000004 alt_heapsem
020102dc g     F .text	0000003c vTaskInternalSetTimeOutState
02040fc8 g     F .text	00000260 lwip_netconn_do_listen
0201f388 g     F .text	0000006c tcp_close
0201cbf0 g     F .text	0000007c pbuf_alloc_reference
0201fd78 g     F .text	000000c8 tcp_recved
0202ea04 g     F .text	00000030 alt_uncached_malloc
0202176c g     F .text	000000f0 tcp_pcb_purge
020344c8 g     F .text	00000060 tse_mac_initTransInfo2
0201c544 g     F .text	00000050 netif_name_to_index
020135c8 g     F .text	00000114 lwip_initialize
02049868 g     O .rwdata	000000c0 alt_fd_list
0202ebdc g     F .text	00000020 lwip_socket_thread_cleanup
0215581e g     O .bss	00000203 memp_memory_TCPIP_MSG_INPKT_base
0203e508 g     F .text	0000005c netconn_disconnect
02155a21 g     O .bss	0000007b memp_memory_ARP_QUEUE_base
02000864 g     F .text	00000048 get_iface_name
02046fec g     O .rodata	00000030 lwip_cyclic_timers
0203f3b4 g     F .text	00000088 lwip_netconn_is_err_msg
0202dbcc g     F .text	00000038 xPortStartScheduler
02011634 g     F .text	00000088 ulTaskNotifyValueClear
0200f850 g     F .text	00000034 vTaskEndScheduler
0202e1dc g     F .text	00000090 alt_find_dev
02005e58 g     F .text	00000148 memcpy
0201acfc g     F .text	000001c8 mem_free
0203473c g     F .text	00000054 tse_mac_setMIImode
0200ffac g     F .text	00000050 vTaskPlaceOnEventList
0201def4 g     F .text	0000010c pbuf_fill_chksum
020101b8 g     F .text	000000c8 vTaskRemoveFromUnorderedEventList
0204cc84 g     O .bss	00000004 tcp_ticks
0204cc88 g     O .bss	00000004 tcp_listen_pcbs
020363d0 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
0202a184 g     F .text	00000120 udp_sendto_if_chksum
02028408 g     F .text	0000004c tcp_rexmit_rto
0200497c g     F .text	0000000c _cleanup_r
0200d018 g     F .text	000000dc .hidden __floatsidf
0203a548 g     F .text	00000058 acd_network_changed_link_down
02034528 g     F .text	000000e4 tse_mac_sTxWrite
02012714 g     F .text	0000007c alt_io_redirect
0202156c g     F .text	0000002c tcp_new
0200be90 g     F .text	000000f4 .hidden __ltdf2
02046e2c g     O .rodata	00000010 memp_TCP_SEG
0200e2f8 g     F .text	0000007c xQueuePeekFromISR
0202aa80 g     F .text	00000064 udp_disconnect
0201d850 g     F .text	0000014c pbuf_copy_partial
02014c7c g     F .text	00000020 sys_init
02015034 g     F .text	0000004c sys_sem_signal
02046e0c g     O .rodata	00000010 memp_TCP_PCB
020464fc g       *ABS*	00000000 __DTOR_END__
02155a9c g     O .bss	00000043 memp_memory_RAW_PCB_base
0200d220  w    F .text	00000020 post_constructors
0202dfe4 g     F .text	000000d0 alt_close
02155adf g     O .bss	00000143 memp_memory_TCP_SEG_base
020400a8 g     F .text	00000068 lwip_netconn_do_newconn
02029568 g     F .text	00000058 sys_timeout
020426cc g     F .text	00000014 puts
0202d730 g     F .text	00000024 vPortFree
0201a210 g     F .text	000000e0 ip4_addr_isbroadcast_u32
02011b8c g     F .text	00000030 pcTimerGetName
0201757c g     F .text	00000034 dhcp_release
0204ad7b g     O .rwdata	00000001 netconn_closed
020070c4 g     F .text	00000074 __fpclassifyd
02046e6c g     O .rodata	00000010 memp_NETCONN
02006ea8 g     F .text	000000a4 __ratio
0201eb1c g     F .text	00000044 raw_send
0203a208 g     F .text	0000010c inet_chksum_pbuf
020089ac g     F .text	0000001c __vfiprintf_internal
0201db90 g     F .text	00000138 pbuf_take
0200ddd4 g     F .text	00000260 xQueueSemaphoreTake
0202c204 g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
0200e49c g     F .text	00000028 uxQueueGetQueueNumber
0202b88c g     F .text	00000258 altera_avalon_jtag_uart_read
02042400 g     F .text	00000014 malloc
0201db40 g     F .text	00000050 pbuf_skip
020009b4 g     F .text	00000030 _printf_r
0200aadc g     F .text	00000064 .hidden __udivsi3
0214d47c g     O .bss	00000024 tse
020127cc g     F .text	000000a4 isatty
020353c0 g     F .text	00000168 alt_tse_sys_enable_mdio_sharing
0203acec g     F .text	0000064c icmp_input
02046ad0 g     O .rodata	000000c8 __mprec_tens
02035690 g     F .text	00000080 alt_tse_get_mac_info_index
02010904 g     F .text	0000005c uxTaskGetStackHighWaterMark
0201bab8 g     F .text	00000220 netif_add
0200534c g     F .text	0000000c __locale_charset
02014d94 g     F .text	000000c0 sys_mutex_new
02020e8c g     F .text	00000054 tcp_segs_free
02026cd0 g     F .text	00000598 tcp_split_unsent_seg
0202d838 g     F .text	0000008c vListInsertEnd
0203e074 g     F .text	00000090 alt_icache_flush
02030404 g     F .text	00000138 lwip_send
0204cb88 g     O .bss	00000004 __malloc_top_pad
02021c68 g     F .text	00000050 tcp_free_ooseq
02041520 g     F .text	0000008c lwip_netconn_do_accepted
0204cbf0 g     O .bss	00000004 alt_fd_list_lock
0204cb6c g     O .bss	00000004 PingIp
0204ad04 g     O .rwdata	00000004 __mb_cur_max
0200537c g     F .text	0000000c _localeconv_r
02034238 g     F .text	00000038 tcpip_callbackmsg_delete
0201be04 g     F .text	0000005c netif_set_ipaddr
02008f64 g     F .text	000004bc __sfvwrite_r
020064d4 g     F .text	0000003c __i2b
020219a4 g     F .text	0000009c tcp_eff_send_mss_netif
0202c33c g     F .text	0000005c alt_avalon_sgdma_stop
02046e1c g     O .rodata	00000010 memp_TCP_PCB_LISTEN
02036470 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
02007138 g     F .text	00000054 _sbrk_r
02036b10 g     F .text	000006a4 alt_tse_mac_group_init
02026204 g     F .text	00000acc tcp_write
02013f9c g     F .text	00000878 tse_mac_init
020283a8 g     F .text	00000060 tcp_rexmit_rto_commit
0200f6e0 g     F .text	000000e0 xTaskResumeFromISR
0201913c g     F .text	000000c4 etharp_find_addr
020153ac g     F .text	000000a8 sys_arch_mbox_fetch
0203221c g     F .text	00000174 lwip_shutdown
02013a20 g     F .text	00000048 get_netif
02009630 g     F .text	00000060 _read_r
0202d80c g     F .text	0000002c vListInitialiseItem
0202e0b4 g     F .text	00000028 alt_dcache_flush
0204ad24 g     O .rwdata	00000004 alt_max_fd
0202dcc0 g     F .text	0000004c vPortSysTickHandler
02008bfc g     F .text	000000f0 _fclose_r
0200dbfc g     F .text	000001d8 xQueueReceive
0201f744 g     F .text	000001e4 tcp_bind
0201fa00 g     F .text	00000288 tcp_listen_with_backlog_and_err
02004944 g     F .text	00000030 fflush
0204cb84 g     O .bss	00000004 __malloc_max_sbrked_mem
0203b380 g     F .text	00000048 icmp_time_exceeded
0201f70c g     F .text	00000038 tcp_abort
0200f27c g     F .text	0000004c uxTaskPriorityGetFromISR
0203e5d0 g     F .text	000001a8 netconn_accept
0202dd0c g     F .text	00000170 alt_irq_register
02155c22 g     O .bss	00017f03 memp_memory_PBUF_POOL_base
0200ab98 g     F .text	000008ac .hidden __adddf3
0202f68c g     F .text	000000fc lwip_listen
02011ae4 g     F .text	00000070 uxTimerGetReloadMode
02006c50 g     F .text	0000010c __b2d
0200a4ac g     F .text	00000538 .hidden __umoddi3
02012998 g     F .text	000000d4 lseek
0201e810 g     F .text	000000fc raw_sendto
02036664 g     F .text	0000029c alt_tse_phy_add_profile_default
02041a2c g     F .text	000000f8 lwip_netconn_do_write
02037d7c g     F .text	00000594 alt_tse_phy_get_cap
02030d20 g     F .text	00000064 lwip_writev
02000000 g       *ABS*	00000000 __alt_mem_sdram_controller_0
02011a24 g     F .text	00000030 xTimerGetPeriod
0204acfc g     O .rwdata	00000004 _global_impure_ptr
0201ba58 g     F .text	00000060 netif_add_noaddr
02040774 g     F .text	00000210 lwip_netconn_do_delconn
0202e764 g     F .text	000000fc alt_read
02009690 g     F .text	00000564 _realloc_r
0216f920 g       *ABS*	00000000 __bss_end
0202e638 g     F .text	000000f0 alt_iic_isr_register
0202bd80 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
020300c8 g     F .text	0000033c lwip_recvmsg
0202e8fc g     F .text	00000108 alt_tick
0202f328 g     F .text	0000012c lwip_bind
02009f34 g     F .text	00000578 .hidden __udivdi3
020175b0 g     F .text	00000034 dhcp_stop
02008e64 g     F .text	00000024 _fputwc_r
02037c1c g     F .text	00000160 alt_tse_phy_check_link
02046aa8 g     O .rodata	00000028 __mprec_bigtens
020062b8 g     F .text	00000104 __s2b
020324e8 g     F .text	00000044 lwip_getpeername
02041b24 g     F .text	00000234 lwip_netconn_do_getaddr
0202afa4 g     F .text	00000120 ethernet_output
0200d0f4 g     F .text	000000a8 .hidden __floatunsidf
02039228 g     F .text	000000e4 marvell_cfg_sgmii
0201d660 g     F .text	000001f0 pbuf_copy
02037a60 g     F .text	000001bc alt_tse_phy_restart_an
02028454 g     F .text	00000184 tcp_rexmit
02006990 g     F .text	00000060 __mcmp
0202d670 g     F .text	000000c0 pvPortMalloc
0202ccdc g     F .text	0000015c altera_avalon_uart_init
0204223c g     F .text	00000098 netbuf_data
02030014 g     F .text	00000064 lwip_readv
02004ce4 g     F .text	00000018 __fp_lock_all
0203e2e8 g     F .text	000000a4 netconn_getaddr
0202e5ec g     F .text	0000004c alt_ic_irq_enabled
0216f8e8 g     O .bss	00000020 pphy_profiles
0200e460 g     F .text	0000003c vQueueDelete
0202dc04 g     F .text	00000020 vPortEndScheduler
0216db25 g     O .bss	0000016b memp_memory_FRAG_PBUF_base
0201c1fc g     F .text	0000008c netif_set_up
0202d7a4 g     F .text	00000068 vListInitialise
0216dc90 g     O .bss	00000083 memp_memory_TCPIP_MSG_API_base
0202e860 g     F .text	0000009c alt_alarm_stop
02042c34 g     F .text	0000001c strtol
02013a9c g     F .text	00000034 lwip_set_link_callback
0204ccdc g     O .bss	00000004 alt_irq_active
02030b94 g     F .text	00000148 lwip_socket
02046fcc g     O .rodata	00000010 tcp_pcb_lists
02034378 g     F .text	00000074 tcpip_init
02046e7c g     O .rodata	00000010 memp_TCPIP_MSG_API
02046e3c g     O .rodata	00000010 memp_REASSDATA
0200017c g     F .exceptions	000000cc alt_irq_handler
02049840 g     O .rwdata	00000028 alt_dev_null
0200fa18 g     F .text	00000028 xTaskGetTickCount
0200d848 g     F .text	000001e4 xQueueGenericSend
020008ac g     F .text	00000024 is_interface_active
02046eac g     O .rodata	00000010 memp_SYS_TIMEOUT
0201a2f0 g     F .text	000000a0 ip4_addr_netmask_valid
0203e480 g     F .text	00000088 netconn_connect
02037948 g     F .text	00000118 alt_tse_phy_init
0201efa8 g     F .text	00000074 tcp_backlog_accepted
0201c62c g     F .text	00000070 netif_get_by_index
0202c398 g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
0201d238 g     F .text	000000bc pbuf_free_header
0201d06c g     F .text	000000d4 pbuf_remove_header
0203eecc g     F .text	00000080 netconn_sendto
0202e0dc g     F .text	00000020 alt_dcache_flush_all
020063bc g     F .text	00000068 __hi0bits
0203da94 g     F .text	00000488 ip4_frag
0200facc g     F .text	00000188 uxTaskGetSystemState
0201494c g     F .text	00000160 tse_mac_raw_send
0200cf98 g     F .text	00000080 .hidden __fixdfsi
020148b8 g     F .text	00000094 tse_sgdma_rx_isr
02010bac g     F .text	000000fc xTaskPriorityDisinherit
0201ab68 g     F .text	000000b4 mem_init
02046dec g     O .rodata	00000010 memp_RAW_PCB
0202eaa0 g     F .text	000000f8 alt_write
0202f528 g     F .text	00000164 lwip_connect
02027268 g     F .text	00000140 tcp_send_fin
0204ad80 g       *ABS*	00000000 __ram_rwdata_end
020275b4 g     F .text	0000072c tcp_output
0204cbfc g     O .bss	00000004 tx_counter
0204ad1c g     O .rwdata	00000008 alt_dev_list
0201d99c g     F .text	00000110 pbuf_get_contiguous
0201aec4 g     F .text	00000310 mem_trim
020130f0 g     F .text	00000064 write
0202c4dc g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
020424a4 g     F .text	000000a0 _putc_r
020100c4 g     F .text	000000f4 xTaskRemoveFromEventList
02000284 g     F .text	00000028 vApplicationMallocFailedHook
02048f9c g       *ABS*	00000000 __ram_rodata_end
02042060 g     F .text	0000007c netbuf_free
020125a0 g     F .text	000000b0 fstat
0203e564 g     F .text	0000006c netconn_listen_with_backlog
0204ccb8 g     O .bss	00000004 tcp_input_pcb
0201e4dc g     F .text	00000174 raw_input
0200be90 g     F .text	000000f4 .hidden __ledf2
020393fc g     F .text	00000078 DP83848C_link_status_read
02028dd0 g     F .text	0000012c tcp_send_empty_ack
0200e034 g     F .text	000001e0 xQueuePeek
020285d8 g     F .text	00000128 tcp_rexmit_fast
02014f38 g     F .text	000000fc sys_sem_new
02006708 g     F .text	00000140 __pow5mult
0201e058 g     F .text	00000090 pbuf_try_get_at
02007550 g     F .text	0000145c ___vfiprintf_internal_r
0204cb7c g     O .bss	00000004 __nlocale_changed
0203403c g     F .text	0000007c tcpip_untimeout
0200ab40 g     F .text	00000058 .hidden __umodsi3
0201c1d0 g     F .text	0000002c netif_set_default
0202aae4 g     F .text	00000050 udp_recv
0202c184 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
0201ef38 g     F .text	00000070 tcp_backlog_delayed
0202c290 g     F .text	00000054 alt_avalon_sgdma_register_callback
0216f920 g       *ABS*	00000000 end
0200eeb0 g     F .text	000000f8 vTaskDelete
0201c2e0 g     F .text	000000a0 netif_set_down
0204cc00 g     O .bss	00000004 rx_counter
0201c974 g     F .text	0000027c pbuf_alloc
0201c3bc g     F .text	00000094 netif_set_link_up
020154c8 g     F .text	00000058 sys_mbox_free
020423ac g     F .text	0000000c _atoi_r
0202d3e4 g     F .text	000001e8 altera_avalon_uart_write
020347e0 g     F .text	000001e4 alt_tse_phy_add_profile
0202b340 g     F .text	00000148 altera_avalon_jtag_uart_init
0203f280 g     F .text	00000060 netconn_err
02010ed0 g     F .text	00000038 pvTaskIncrementMutexHeldCount
020464fc g       *ABS*	00000000 __CTOR_LIST__
04000000 g       *ABS*	00000000 __alt_stack_pointer
0203e290 g     F .text	00000058 netconn_delete
0202c55c g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
02046ebc g     O .rodata	00000010 memp_PBUF
0202cb50 g     F .text	0000007c alt_avalon_timer_sc_init
0202cc2c g     F .text	00000060 altera_avalon_uart_write_fd
0200d19c g     F .text	00000064 .hidden __clzsi2
020426e0 g     F .text	000000d8 _snprintf_r
0202cc8c g     F .text	00000050 altera_avalon_uart_close_fd
020422d4 g     F .text	00000078 netbuf_next
0202bae4 g     F .text	00000260 altera_avalon_jtag_uart_write
0202bfb4 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0204234c g     F .text	00000040 netbuf_first
02004cd4 g     F .text	00000004 __sfp_lock_acquire
02005d74 g     F .text	000000e4 memchr
0204ad38 g     O .rwdata	00000004 ip_addr_broadcast
02000a20 g     F .text	000021f8 ___vfprintf_internal_r
02030998 g     F .text	000001fc lwip_sendto
0203c6e0 g     F .text	000000a0 ip_reass_tmr
02010318 g     F .text	000000f0 xTaskCheckForTimeOut
0202c0ac g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
02014cec g     F .text	00000034 sys_arch_protect
02004e38 g     F .text	00000310 _free_r
02012cc0 g     F .text	0000022c alt_printf
02010a6c g     F .text	00000140 xTaskPriorityInherit
0201241c g     F .text	00000028 uxTimerGetTimerNumber
02005358 g     F .text	00000010 __locale_mb_cur_max
0202a958 g     F .text	00000128 udp_connect
02044f40 g     F .text	00000180 __call_exitprocs
02040110 g     F .text	0000016c netconn_alloc
0203c564 g     F .text	000000b0 ip4_output
020312b4 g     F .text	00000598 lwip_select
0202ffc8 g     F .text	0000004c lwip_read
0204cc08 g     O .bss	00000004 rx_faulty_packets
0204cb78 g     O .bss	00000004 __mlocale_changed
02014aac g     F .text	000001d0 tse_mac_rcv
02010f08 g     F .text	000000d0 ulTaskNotifyTake
0201bff8 g     F .text	000000ec netif_set_addr
0204ad08 g     O .rwdata	00000004 __malloc_sbrk_base
02000248 g     F .text	0000003c _start
0204cce0 g     O .bss	00000004 _alt_tick_rate
0200f884 g     F .text	0000002c vTaskSuspendAll
0200f0f4 g     F .text	00000120 eTaskGetState
0201e374 g     F .text	000000a4 pbuf_strstr
02014d58 g     F .text	0000003c sys_arch_msleep
0201dcc8 g     F .text	00000148 pbuf_take_at
0202c3fc g     F .text	00000054 alt_avalon_sgdma_open
0200fa40 g     F .text	0000002c xTaskGetTickCountFromISR
0201eda0 g     F .text	00000038 tcp_free
02000658 g     F .text	0000011c get_mac_addr
0201b82c g     F .text	00000068 memp_malloc
02006848 g     F .text	00000148 __lshift
02028fb0 g     F .text	000002ac tcp_zero_window_probe
0203c614 g     F .text	000000cc ip4_output_hinted
0204cce4 g     O .bss	00000004 _alt_nticks
02036598 g     F .text	000000cc alt_tse_phy_rd_mdio_reg
02013084 g     F .text	0000006c read
0202b130 g     F .text	000000ac alt_sys_init
020450c0 g     F .text	000001d0 __ssprint_r
02015d30 g     F .text	000000c0 dhcp_fine_tmr
0204cc11 g     O .bss	00000008 dhcp_rx_options_given
0202d99c g     F .text	00000098 uxListRemove
02044e28 g     F .text	00000118 __register_exitproc
02033f10 g     F .text	000000a0 tcpip_try_callback
0216dd13 g     O .bss	00000203 memp_memory_PBUF_base
0201cff4 g     F .text	0000003c pbuf_add_header
0204ccfc g     O .bss	00000001 phy_profile_count
02039474 g     F .text	0000003c lwip_htons
0204292c g     F .text	000000d0 strncmp
0203561c g     F .text	00000074 alt_tse_get_mac_group_index
02006510 g     F .text	000001f8 __multiply
0202b734 g     F .text	00000068 altera_avalon_jtag_uart_close
0203be1c g     F .text	000000a8 ip4_output_if
02033e94 g     F .text	0000007c tcpip_callback
02048f9c g       *ABS*	00000000 __ram_rwdata_start
020464fc g       *ABS*	00000000 __ram_rodata_start
0204cd0c g     O .bss	00000028 __malloc_current_mallinfo
020115ac g     F .text	00000088 xTaskNotifyStateClear
0204cc8c g     O .bss	00000004 tcp_bound_pcbs
0200f604 g     F .text	000000dc vTaskResume
02006d5c g     F .text	0000014c __d2b
02015104 g     F .text	00000060 sys_sem_free
02020ee0 g     F .text	0000005c tcp_seg_free
0200fe50 g     F .text	0000015c vTaskSwitchContext
0202ec58 g     F .text	00000030 lwip_socket_dbg_get_socket
0201e17c g     F .text	00000134 pbuf_memcmp
02046e4c g     O .rodata	00000010 memp_FRAG_PBUF
02011a54 g     F .text	00000090 vTimerSetReloadMode
02034460 g     F .text	00000038 mem_free_callback
02036418 g     F .text	00000058 alt_tse_phy_wr_mdio_addr
02041e90 g     F .text	00000064 err_to_errno
0202b1dc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0202e374 g     F .text	000000e0 alt_get_fd
02010060 g     F .text	00000064 vTaskPlaceOnEventListRestricted
0216df16 g     O .bss	00000193 memp_memory_TCP_PCB_LISTEN_base
0203df1c g     F .text	00000158 alt_busy_sleep
020421b8 g     F .text	00000084 netbuf_chain
02016578 g     F .text	000000a0 dhcp_network_changed_link_up
0201ed80 g     F .text	00000020 tcp_init
0201ff1c g     F .text	000003f0 tcp_connect
0203a05c g     F .text	000000f8 inet_chksum_pseudo_partial
02008ae4 g     F .text	00000054 _close_r
0201b1d4 g     F .text	00000344 mem_malloc
0216e0a9 g     O .bss	000000a3 memp_memory_REASSDATA_base
02010fd8 g     F .text	00000114 xTaskNotifyWait
020388d0 g     F .text	00000328 alt_tse_phy_get_common_speed
02042428 g     F .text	0000007c memcmp
0202b29c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0216f920 g       *ABS*	00000000 __alt_stack_base
0202b2ec g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0204ccfd g     O .bss	00000001 mac_group_count
0201c450 g     F .text	0000008c netif_set_link_down
02016c48 g     F .text	00000244 dhcp_renew
02011928 g     F .text	000000dc xTimerGenericCommand
02010478 g     F .text	00000044 vTaskSetTaskNumber
02002cf0 g     F .text	00000154 __swsetup_r
020002ac g     F .text	00000030 vApplicationStackOverflowHook
0203a444 g     F .text	000000d0 acd_start
02014814 g     F .text	000000a4 tse_sgdma_read_init
0200f47c g     F .text	0000011c vTaskSuspend
0200b444 g     F .text	000008e8 .hidden __divdf3
02004b94 g     F .text	00000118 __sfp
0200fc54 g     F .text	0000004c xTaskCatchUpTicks
02006fc0 g     F .text	00000078 __copybits
0200fa6c g     F .text	00000020 uxTaskGetNumberOfTasks
02049438 g     O .rwdata	00000408 __malloc_av_
02004ce0 g     F .text	00000004 __sinit_lock_release
0203ecf4 g     F .text	00000060 netconn_recv_udp_raw_netbuf
0203b5c4 g     F .text	0000015c ip4_route
0200bf84 g     F .text	00000718 .hidden __muldf3
0214d430 g     O .bss	0000004c eth_tse
0200718c g     F .text	00000054 __sread
0201a1a0 g     F .text	00000070 etharp_acd_announce
0202a904 g     F .text	00000054 udp_bind_netif
020371b4 g     F .text	00000424 alt_tse_mac_get_phy
0202e26c g     F .text	00000108 alt_find_file
02029734 g     F .text	00000088 sys_restart_timeouts
0203f01c g     F .text	000001bc netconn_write_vectors_partly
02032e70 g     F .text	00000150 lwip_setsockopt
0202e138 g     F .text	000000a4 alt_dev_llist_insert
0200d318 g     F .text	00000060 __malloc_lock
02012f8c g     F .text	000000b0 sbrk
02042c50 g     F .text	000021d8 ___svfprintf_internal_r
0200d754 g     F .text	0000009c xQueueTakeMutexRecursive
0202c2e4 g     F .text	00000058 alt_avalon_sgdma_start
02016428 g     F .text	00000150 dhcp_inform
0203ac20 g     F .text	000000cc acd_netif_ip_addr_changed
02033fb0 g     F .text	0000008c tcpip_timeout
020048e8 g     F .text	0000005c _fflush_r
020358c8 g     F .text	0000008c alt_tse_mac_set_duplex
02008b38 g     F .text	000000c4 _calloc_r
0201e704 g     F .text	00000078 raw_connect
02019200 g     F .text	000000d0 etharp_get_entry
0203ec28 g     F .text	00000060 netconn_recv_tcp_pbuf
020110ec g     F .text	000001bc xTaskGenericNotify
02015164 g     F .text	000000d0 sys_mbox_new
02013dac g     F .text	000001f0 lwip_initialize_phys
0204cb64 g       *ABS*	00000000 __bss_start
02010430 g     F .text	00000048 uxTaskGetTaskNumber
02005fa0 g     F .text	00000128 memset
02021bbc g     F .text	000000ac tcp_tcp_get_tcp_addrinfo
02046ecc g     O .rodata	00000010 memp_PBUF_POOL
020008d0 g     F .text	00000040 main
02033974 g     F .text	000000b8 lwip_inet_ntop
0204cb98 g     O .bss	00000004 alt_envp
0204cb80 g     O .bss	00000004 __malloc_max_total_mem
0202b23c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0203bec4 g     F .text	000006a0 ip4_output_if_src
02009d34 g     F .text	00000018 __swbuf
0201d1f4 g     F .text	00000044 pbuf_header_force
0204ad7a g     O .rwdata	00000001 netconn_reset
0202d8c4 g     F .text	000000d8 vListInsert
0203b338 g     F .text	00000048 icmp_dest_unreach
0204ad60 g     O .rwdata	00000008 alt_sgdma_list
0202164c g     F .text	0000003c tcp_sent
020072c0 g     F .text	00000008 __sclose
0201e000 g     F .text	00000058 pbuf_get_at
04000000 g       *ABS*	00000000 __alt_heap_limit
020394b0 g     F .text	00000054 lwip_htonl
05020000 g       *ABS*	00000000 __alt_mem_mem_0
02008cec g     F .text	00000014 fclose
020117a4 g     F .text	00000068 xTimerCreateTimerTask
020429fc g     F .text	00000238 _strtol_r
0202ac3c g     F .text	00000038 udp_new_ip_type
02003044 g     F .text	00001688 _dtoa_r
0201ec04 g     F .text	00000080 raw_new
02005568 g     F .text	0000080c _malloc_r
020346b4 g     F .text	00000088 tse_mac_SwReset
02009ea8 g     F .text	00000030 __ascii_wctomb
0203252c g     F .text	00000044 lwip_getsockname
0200e4f8 g     F .text	00000028 ucQueueGetQueueType
0201331c g     F .text	000000fc ethernetif_input
0204ad68 g     O .rwdata	00000004 alt_errno
0201b7ec g     F .text	00000040 memp_malloc_pool
0200efa8 g     F .text	000000f0 vTaskDelayUntil
020399a4 g     F .text	00000234 lwip_standard_chksum
02034428 g     F .text	00000038 pbuf_free_callback
0202d62c g     F .text	00000044 __env_unlock
0201c380 g     F .text	0000003c netif_set_status_callback
02005148 g     F .text	000000c4 _fwalk
0201f928 g     F .text	00000054 tcp_bind_netif
0203ef4c g     F .text	00000068 netconn_send
020342a4 g     F .text	00000034 tcpip_callbackmsg_trycallback_fromisr
0200e214 g     F .text	000000e4 xQueueReceiveFromISR
0203e168 g     F .text	000000b4 netconn_new_with_proto_and_callback
020109f8 g     F .text	00000028 xTaskGetCurrentTaskHandle
0203efb4 g     F .text	00000068 netconn_write_partly
0216e14c g     O .bss	0000021f memp_memory_UDP_PCB_base
02042544 g     F .text	000000c8 putc
020396a0 g     F .text	000000b4 lwip_stricmp
0200a9e4 g     F .text	00000084 .hidden __divsi3
02035568 g     F .text	00000048 alt_tse_mac_set_common_speed
0201eb60 g     F .text	000000a4 raw_remove
0200d4e0 g     F .text	00000098 xQueueGenericCreate
02004d14 g     F .text	00000124 _malloc_trim_r
020464fc g       *ABS*	00000000 __CTOR_END__
020139d4 g     F .text	0000004c get_mac_base
0204cc74 g     O .bss	00000001 pbuf_free_ooseq_pending
0202a75c g     F .text	000001a8 udp_bind
0201ee10 g     F .text	0000004c tcp_tmr
02019a18 g     F .text	00000480 etharp_query
020297bc g     F .text	00000070 sys_timeouts_sleeptime
020072c8 g     F .text	000000dc strcmp
0203a36c g     F .text	0000004c lwip_init
0200d7f0 g     F .text	00000058 xQueueCreateCountingSemaphore
020464fc g       *ABS*	00000000 __flash_rodata_start
02034118 g     F .text	000000b0 tcpip_api_call
02015520 g     F .text	00000074 sys_thread_new
02014cc4 g     F .text	00000028 sys_jiffies
02033d78 g     F .text	000000b0 tcpip_inpkt
020464fc g       *ABS*	00000000 __DTOR_LIST__
02019710 g     F .text	00000308 etharp_output
0201eccc g     F .text	00000094 raw_netif_ip_addr_changed
0202a018 g     F .text	0000010c udp_sendto_chksum
020112a8 g     F .text	000001e4 xTaskGenericNotifyFromISR
0202ac74 g     F .text	00000094 udp_netif_ip_addr_changed
0200bd2c g     F .text	00000088 .hidden __nedf2
02025b78 g     F .text	0000002c tcp_trigger_input_pcb_close
0200e4c4 g     F .text	00000034 vQueueSetQueueNumber
0202b0f8 g     F .text	00000038 alt_irq_init
02040ac4 g     F .text	00000120 lwip_netconn_do_bind_if
02035528 g     F .text	00000040 alt_tse_mac_get_common_speed
0203ea1c g     F .text	0000006c netconn_tcp_recvd
02012f28 g     F .text	00000064 alt_release_fd
0200f8b0 g     F .text	00000168 xTaskResumeAll
0201cc6c g     F .text	000000d0 pbuf_alloced_custom
0200e3c4 g     F .text	00000064 uxQueueSpacesAvailable
0201bf98 g     F .text	00000060 netif_set_gw
02046bb8 g     O .rodata	00000100 .hidden __clz_tab
0200f7c0 g     F .text	00000090 vTaskStartScheduler
0201d42c g     F .text	0000004c pbuf_clen
0204cb74 g     O .bss	00000004 _PathLocale
0204238c g     F .text	00000014 atexit
020139b4 g     F .text	00000020 get_mac_count
02008a84 g     F .text	00000060 _write_r
02020f3c g     F .text	00000044 tcp_setprio
02029eb8 g     F .text	00000074 udp_send
02032570 g     F .text	00000164 lwip_getsockopt
02005388 g     F .text	00000018 setlocale
0200e9bc g     F .text	00000050 xQueueIsQueueFullFromISR
0201de10 g     F .text	00000070 pbuf_coalesce
0201e7cc g     F .text	00000044 raw_recv
02012368 g     F .text	00000058 pvTimerGetTimerID
0204ad79 g     O .rwdata	00000001 netconn_aborted
02014e98 g     F .text	00000040 sys_mutex_unlock
02000910 g     F .text	000000a4 main_thread
0201c0e4 g     F .text	000000ec netif_remove
02014e54 g     F .text	00000044 sys_mutex_lock
02015080 g     F .text	00000084 sys_arch_sem_wait
0204ad00 g     O .rwdata	00000004 _impure_ptr
0204cb90 g     O .bss	00000004 alt_argc
0202030c g     F .text	00000874 tcp_slowtmr
02011b54 g     F .text	00000038 xTimerGetExpiryTime
020046cc g     F .text	0000021c __sflush_r
02012504 g     F .text	00000060 _do_dtors
02005374 g     F .text	00000008 __locale_cjk_lang
0201c594 g     F .text	00000098 netif_index_to_name
02041d58 g     F .text	00000138 lwip_netconn_do_close
02006bec g     F .text	00000064 __ulp
020216c4 g     F .text	00000054 tcp_accept
02004cfc g     F .text	00000018 __fp_unlock_all
02010408 g     F .text	00000028 vTaskMissedYield
02013418 g     F .text	000001b0 ethernetif_init
0204ad14 g     O .rwdata	00000008 alt_fs_list
0200e374 g     F .text	00000050 uxQueueMessagesWaiting
0200fca0 g     F .text	000001b0 xTaskIncrementTick
02000020 g       *ABS*	00000000 __ram_exceptions_start
020053a0 g     F .text	0000000c localeconv
0202822c g     F .text	0000017c tcp_rexmit_rto_prepare
02033e28 g     F .text	0000006c tcpip_input
0204cc90 g     O .bss	00000004 tcp_tw_pcbs
02038728 g     F .text	000001a8 alt_tse_phy_set_adv_10
020003d0 g     F .text	00000048 InitNetwork
0202e488 g     F .text	00000050 alt_ic_isr_register
02014c9c g     F .text	00000028 sys_now
020299f0 g     F .text	000004c8 udp_input
0216e36b g     O .bss	000007e3 memp_memory_NETCONN_base
0200d3bc g     F .text	00000124 xQueueGenericReset
020123c0 g     F .text	0000005c vTimerSetTimerID
0204ad80 g       *ABS*	00000000 _edata
0202cbcc g     F .text	00000060 altera_avalon_uart_read_fd
02017364 g     F .text	00000218 dhcp_release_and_stop
0201a7dc g     F .text	0000003c ip4addr_ntoa
0216f920 g       *ABS*	00000000 _end
0201a818 g     F .text	00000194 ip4addr_ntoa_r
020375d8 g     F .text	00000248 alt_tse_mac_associate_phy
0201b9dc g     F .text	00000020 netif_init
02008d00 g     F .text	00000164 __fputwc
02000248 g       *ABS*	00000000 __ram_exceptions_end
0202b79c g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0201f9bc g     F .text	00000044 tcp_listen_with_backlog
0216f608 g     O .bss	000001c0 lwip_stats
0200ead4 g     F .text	000000e0 xTaskCreate
0202d754 g     F .text	00000024 vPortInitialiseBlocks
0201530c g     F .text	000000a0 sys_mbox_trypost_fromisr
0201d1b0 g     F .text	00000044 pbuf_header
020122f8 g     F .text	00000070 xTimerIsTimerActive
0204cc70 g     O .bss	00000004 netif_default
0202e560 g     F .text	0000008c alt_ic_irq_disable
0202185c g     F .text	00000114 tcp_pcb_remove
0204cb70 g     O .bss	00000004 lwipStaticIp
0204cc04 g     O .bss	00000004 rx_missed_packets
0202c450 g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
020071e8 g     F .text	0000007c __swrite
0203a314 g     F .text	00000058 lwip_chksum_copy
0204ad0c g     O .rwdata	00000004 __malloc_trim_threshold
0201d580 g     F .text	00000044 pbuf_chain
02005368 g     F .text	0000000c __locale_msgcharset
0201f4f4 g     F .text	00000218 tcp_abandon
020423c8 g     F .text	00000038 exit
02021b80 g     F .text	0000003c tcp_debug_state_str
020292b8 g     F .text	0000005c tcp_timer_needed
0200520c g     F .text	000000c4 _fwalk_reent
0201b664 g     F .text	000000ac memp_init
02016224 g     F .text	0000004c dhcp_set_struct
0201b518 g     F .text	0000008c mem_calloc
020069f0 g     F .text	000001fc __mdiff
02020b80 g     F .text	00000140 tcp_fasttmr
0200aa68 g     F .text	00000074 .hidden __modsi3
02020d24 g     F .text	00000168 tcp_process_refused_data
0204ad7c g     O .rwdata	00000004 __ctype_ptr__
02034790 g     F .text	00000050 tse_mac_setGMIImode
0200f098 g     F .text	0000005c vTaskDelay
02039144 g     F .text	000000e4 marvell_cfg_gmii
04000000 g       *ABS*	00000000 __alt_data_end
02004cd8 g     F .text	00000004 __sfp_lock_release
02014d20 g     F .text	00000038 sys_arch_unprotect
0203e38c g     F .text	00000088 netconn_bind
02030cdc g     F .text	00000044 lwip_write
02037820 g     F .text	00000128 alt_tse_phy_cfg_pcs
0214d4a0 g     O .bss	00000020 dhcp_rx_options_val
020423a0 g     F .text	0000000c atoi
02046e9c g     O .rodata	00000010 memp_ARP_QUEUE
04000000 g       *ABS*	00000000 __alt_mem_tse_descriptor_memory_0
02010a20 g     F .text	0000004c xTaskGetSchedulerState
0216eb4e g     O .bss	00000a17 memp_memory_TCP_PCB_base
02048cd4 g     O .rodata	00000101 _ctype_
02030078 g     F .text	00000050 lwip_recv
02010ca8 g     F .text	00000140 vTaskPriorityDisinheritAfterTimeout
0216f565 g     O .bss	000000a3 memp_memory_SYS_TIMEOUT_base
020342d8 g     F .text	000000a0 tcpip_callback_wait
0202d100 g     F .text	00000054 altera_avalon_uart_close
0201ec84 g     F .text	00000048 raw_new_ip_type
020336b4 g     F .text	000000e4 lwip_ioctl
02021598 g     F .text	0000003c tcp_new_ip_type
020464cc g     F .text	00000030 _exit
02015bf0 g     F .text	00000140 dhcp_coarse_tmr
0202de7c g     F .text	0000012c alt_alarm_start
02020f80 g     F .text	00000068 tcp_seg_copy
020053ac g     F .text	000001bc __smakebuf_r
02010e30 g     F .text	0000005c vTaskExitCritical
02021718 g     F .text	00000054 tcp_poll
0202ebbc g     F .text	00000020 lwip_socket_thread_init
020073a4 g     F .text	00000098 strlen
0202daec g     F .text	000000e0 pxPortInitialiseStack
02033798 g     F .text	000001dc lwip_fcntl
02012b6c g     F .text	00000154 open
0202982c g     F .text	00000020 udp_init
0214d4c0 g     O .bss	00008013 ram_heap
0200bdb4 g     F .text	000000dc .hidden __gedf2
0202abe4 g     F .text	00000058 udp_new
02012eec g     F .text	0000003c alt_putchar
0203ec88 g     F .text	0000006c netconn_recv_tcp_pbuf_flags
0204ad10 g     O .rwdata	00000004 __wctomb
0202f454 g     F .text	000000d4 lwip_close
0202da60 g     F .text	00000050 enh_alt_irq_disable_all
02007538 g     F .text	00000018 __sprint_r
0203460c g     F .text	000000a8 tse_mac_aRxRead
0202e454 g     F .text	00000034 alt_icache_flush_all
020420dc g     F .text	000000dc netbuf_ref
0204ad52 g     O .rwdata	00000006 ethbroadcast
02010280 g     F .text	0000005c vTaskSetTimeOutState
02011a04 g     F .text	00000020 xTimerGetTimerDaemonTaskHandle
0201e0e8 g     F .text	00000094 pbuf_put_at
02012444 g     F .text	00000034 vTimerSetTimerNumber
0204ad6c g     O .rwdata	00000004 alt_priority_mask
02015454 g     F .text	00000074 sys_arch_mbox_tryfetch
0203e21c g     F .text	00000074 netconn_prepare_delete
0202e4d8 g     F .text	00000088 alt_ic_irq_enable
02002c18 g     F .text	0000001c __vfprintf_internal
0204144c g     F .text	000000d4 lwip_netconn_do_recv
0202f048 g     F .text	000002e0 lwip_accept
0202d190 g     F .text	00000218 altera_avalon_uart_read
0200e428 g     F .text	00000038 uxQueueMessagesWaitingFromISR
02009ed8 g     F .text	0000005c _wctomb_r
0202d5cc g     F .text	00000060 __env_lock
0203edc0 g     F .text	0000010c netconn_recv
0203a944 g     F .text	00000190 acd_arp_reply
0200e90c g     F .text	00000048 xQueueIsQueueEmptyFromISR
020357e8 g     F .text	000000e0 alt_tse_mac_set_speed
02015234 g     F .text	00000054 sys_mbox_post
0202c028 g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0200c69c g     F .text	000008fc .hidden __subdf3
020395e8 g     F .text	000000b8 lwip_strnistr
0201e90c g     F .text	00000210 raw_sendto_if_src
02039504 g     F .text	000000e4 lwip_strnstr
0201b914 g     F .text	00000050 memp_free_pool
02006424 g     F .text	000000b0 __lo0bits
0203d388 g     F .text	00000650 ip4_reass
0204ad4c g     O .rwdata	00000004 lwip_num_cyclic_timers
0204ad70 g     O .rwdata	00000008 alt_alarm_list
0203a514 g     F .text	00000034 acd_stop
020124a4 g     F .text	00000060 _do_ctors
02039754 g     F .text	000000cc lwip_strnicmp
020384d4 g     F .text	00000254 alt_tse_phy_set_adv_100
02010e8c g     F .text	00000044 uxTaskResetEventItemValue
020295c0 g     F .text	000000c4 sys_untimeout
02009de8 g     F .text	000000c0 wcrtomb
02021cb8 g     F .text	00000e94 tcp_input
0203b7b4 g     F .text	00000668 ip4_input
02046edc g     O .rodata	0000003c memp_pools
0200d668 g     F .text	0000005c xQueueCreateMutex
02046e8c g     O .rodata	00000010 memp_TCPIP_MSG_INPKT
0201303c g     F .text	00000048 close
0204cccc g     O .bss	00000004 alt_envsem
0203ed54 g     F .text	0000006c netconn_recv_udp_raw_netbuf_flags
0201148c g     F .text	00000120 vTaskNotifyGiveFromISR
0200082c g     F .text	00000038 get_hostname
0201879c g     F .text	00000090 dhcp_supplied_address
020128d8 g     F .text	00000084 alt_load
0204ad58 g     O .rwdata	00000006 ethzero
0201ed60 g     F .text	00000020 stats_init
020355b0 g     F .text	0000006c alt_tse_get_system_index
02029684 g     F .text	000000b0 sys_check_timeouts
0202ca30 g     F .text	000000a8 alt_avalon_sgdma_init
0200db20 g     F .text	000000dc xQueueGiveFromISR
02008e88 g     F .text	00000080 fputwc
02040f3c g     F .text	0000008c lwip_netconn_do_disconnect
02042414 g     F .text	00000014 free
0201c69c g     F .text	00000118 netif_find
02004cdc g     F .text	00000004 __sinit_lock_acquire
020005e4 g     F .text	00000074 xEthernetRun
02006198 g     F .text	00000120 __multadd
02006170 g     F .text	00000028 _Bfree
02034498 g     F .text	00000030 no_printf
0203e414 g     F .text	0000006c netconn_bind_if
0203a154 g     F .text	00000070 ip_chksum_pseudo_partial
0201d5c4 g     F .text	0000009c pbuf_dechain



Disassembly of section .entry:

02000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 2000000:	00900014 	movui	r2,16384
#endif

0:
    initi r2
 2000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 2000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 200000c:	00bffd16 	blt	zero,r2,2000004 <__alt_mem_mem_0+0xfcfe0004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 2000010:	00408034 	movhi	at,512
    ori r1, r1, %lo(_start)
 2000014:	08409214 	ori	at,at,584
    jmp r1
 2000018:	0800683a 	jmp	at
 200001c:	00000000 	call	0 <__alt_mem_sdram_controller_0-0x2000000>

Disassembly of section .exceptions:

02000020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
 2000020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
 2000024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 2000028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
 200002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 2000030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 2000034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 2000038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
 200003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
 2000040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
 2000044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
 2000048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
 200004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 2000050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 2000054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 2000058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 200005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 2000060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 2000064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 2000068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 200006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
 2000070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 2000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 2000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 200007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 2000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 2000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 2000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 200008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 2000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 2000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 2000098:	df001c15 	stw	fp,112(sp)

0200009c <save_sp_to_pxCurrentTCB>:
 200009c:	06008174 	movhi	et,517

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 20000a0:	c632e804 	addi	et,et,-13408
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 20000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 20000a8:	c6c00015 	stw	sp,0(et)

020000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
 20000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
 20000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
 20000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
 20000b8:	10002526 	beq	r2,zero,2000150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
 20000bc:	20002426 	beq	r4,zero,2000150 <soft_exceptions>

020000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
 20000c0:	200017c0 	call	200017c <alt_irq_handler>

020000c4 <restore_sp_from_pxCurrentTCB>:
 20000c4:	06008174 	movhi	et,517

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 20000c8:	c632e804 	addi	et,et,-13408
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 20000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 20000d0:	c6c00017 	ldw	sp,0(et)

020000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
 20000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 20000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 20000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 20000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 20000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
 20000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
 20000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
 20000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
 20000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
 20000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 20000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 2000100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 2000104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 2000108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 200010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 2000110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 2000114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 2000118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 200011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 2000120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 2000124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 2000128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 200012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 2000130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 2000134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 2000138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 200013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 2000140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 2000144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 2000148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
 200014c:	ef80083a 	eret

02000150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
 2000150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
 2000154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
 2000158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
 200015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
 2000160:	c0000226 	beq	et,zero,200016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
 2000164:	003da03a 	break	0
  	br		restore_context			# its something else
 2000168:	003fda06 	br	20000d4 <__alt_mem_mem_0+0xfcfe00d4>

0200016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
 200016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
 2000170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
 2000174:	200fe500 	call	200fe50 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
 2000178:	003fd206 	br	20000c4 <__alt_mem_mem_0+0xfcfe00c4>

0200017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 200017c:	defff904 	addi	sp,sp,-28
 2000180:	dfc00615 	stw	ra,24(sp)
 2000184:	df000515 	stw	fp,20(sp)
 2000188:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 200018c:	0005313a 	rdctl	r2,ipending
 2000190:	e0bffe15 	stw	r2,-8(fp)

  return active;
 2000194:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 2000198:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 200019c:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 20001a0:	00800044 	movi	r2,1
 20001a4:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 20001a8:	e0fffb17 	ldw	r3,-20(fp)
 20001ac:	e0bffc17 	ldw	r2,-16(fp)
 20001b0:	1884703a 	and	r2,r3,r2
 20001b4:	10001426 	beq	r2,zero,2000208 <alt_irq_handler+0x8c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 20001b8:	008085f4 	movhi	r2,535
 20001bc:	10bdf204 	addi	r2,r2,-2104
 20001c0:	e0fffd17 	ldw	r3,-12(fp)
 20001c4:	180690fa 	slli	r3,r3,3
 20001c8:	10c5883a 	add	r2,r2,r3
 20001cc:	10c00017 	ldw	r3,0(r2)
 20001d0:	008085f4 	movhi	r2,535
 20001d4:	10bdf204 	addi	r2,r2,-2104
 20001d8:	e13ffd17 	ldw	r4,-12(fp)
 20001dc:	200890fa 	slli	r4,r4,3
 20001e0:	1105883a 	add	r2,r2,r4
 20001e4:	10800104 	addi	r2,r2,4
 20001e8:	10800017 	ldw	r2,0(r2)
 20001ec:	1009883a 	mov	r4,r2
 20001f0:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 20001f4:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 20001f8:	0005313a 	rdctl	r2,ipending
 20001fc:	e0bfff15 	stw	r2,-4(fp)

  return active;
 2000200:	e0bfff17 	ldw	r2,-4(fp)
 2000204:	00000706 	br	2000224 <alt_irq_handler+0xa8>
      }
      mask <<= 1;
 2000208:	e0bffc17 	ldw	r2,-16(fp)
 200020c:	1085883a 	add	r2,r2,r2
 2000210:	e0bffc15 	stw	r2,-16(fp)
      i++;
 2000214:	e0bffd17 	ldw	r2,-12(fp)
 2000218:	10800044 	addi	r2,r2,1
 200021c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 2000220:	003fe106 	br	20001a8 <__alt_mem_mem_0+0xfcfe01a8>

    active = alt_irq_pending ();
 2000224:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 2000228:	e0bffb17 	ldw	r2,-20(fp)
 200022c:	103fdb1e 	bne	r2,zero,200019c <__alt_mem_mem_0+0xfcfe019c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 2000230:	0001883a 	nop
 2000234:	e037883a 	mov	sp,fp
 2000238:	dfc00117 	ldw	ra,4(sp)
 200023c:	df000017 	ldw	fp,0(sp)
 2000240:	dec00204 	addi	sp,sp,8
 2000244:	f800283a 	ret

Disassembly of section .text:

02000248 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 2000248:	06c10034 	movhi	sp,1024
    ori sp, sp, %lo(__alt_stack_pointer)
 200024c:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 2000250:	06808174 	movhi	gp,517
    ori gp, gp, %lo(_gp)
 2000254:	d68b3f14 	ori	gp,gp,11516
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 2000258:	00808134 	movhi	r2,516
    ori r2, r2, %lo(__bss_start)
 200025c:	10b2d914 	ori	r2,r2,52068

    movhi r3, %hi(__bss_end)
 2000260:	00c085b4 	movhi	r3,534
    ori r3, r3, %lo(__bss_end)
 2000264:	18fe4814 	ori	r3,r3,63776

    beq r2, r3, 1f
 2000268:	10c00326 	beq	r2,r3,2000278 <_start+0x30>

0:
    stw zero, (r2)
 200026c:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 2000270:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 2000274:	10fffd36 	bltu	r2,r3,200026c <__alt_mem_mem_0+0xfcfe026c>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 2000278:	20128d80 	call	20128d8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 200027c:	200d2400 	call	200d240 <alt_main>

02000280 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 2000280:	003fff06 	br	2000280 <__alt_mem_mem_0+0xfcfe0280>

02000284 <vApplicationMallocFailedHook>:

static int nw_ready;
static sys_thread_t main_thread_handle;

// hook functions
void vApplicationMallocFailedHook(){
 2000284:	defffe04 	addi	sp,sp,-8
 2000288:	dfc00115 	stw	ra,4(sp)
 200028c:	df000015 	stw	fp,0(sp)
 2000290:	d839883a 	mov	fp,sp
    for(;;){
        vTaskDelay(pdMS_TO_TICKS(1000));
 2000294:	0100fa04 	movi	r4,1000
 2000298:	200f0980 	call	200f098 <vTaskDelay>
        alt_printf("vApplicationMallocFailedHook \r\n");
 200029c:	01008134 	movhi	r4,516
 20002a0:	21193f04 	addi	r4,r4,25852
 20002a4:	2012cc00 	call	2012cc0 <alt_printf>
    }
 20002a8:	003ffa06 	br	2000294 <__alt_mem_mem_0+0xfcfe0294>

020002ac <vApplicationStackOverflowHook>:
}

void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ){
 20002ac:	defffc04 	addi	sp,sp,-16
 20002b0:	dfc00315 	stw	ra,12(sp)
 20002b4:	df000215 	stw	fp,8(sp)
 20002b8:	df000204 	addi	fp,sp,8
 20002bc:	e13ffe15 	stw	r4,-8(fp)
 20002c0:	e17fff15 	stw	r5,-4(fp)
    for(;;){
        vTaskDelay(pdMS_TO_TICKS(1000));
 20002c4:	0100fa04 	movi	r4,1000
 20002c8:	200f0980 	call	200f098 <vTaskDelay>
        alt_printf("vApplicationStackOverflowHook \r\n");
 20002cc:	01008134 	movhi	r4,516
 20002d0:	21194704 	addi	r4,r4,25884
 20002d4:	2012cc00 	call	2012cc0 <alt_printf>
    }
 20002d8:	003ffa06 	br	20002c4 <__alt_mem_mem_0+0xfcfe02c4>

020002dc <StatusCallback>:
}

// callback function for when the DHCP subsystem acquires an IP address.
static void StatusCallback(struct netif* netif)
{
 20002dc:	deffbd04 	addi	sp,sp,-268
 20002e0:	dfc04215 	stw	ra,264(sp)
 20002e4:	df004115 	stw	fp,260(sp)
 20002e8:	df004104 	addi	fp,sp,260
 20002ec:	e13fff15 	stw	r4,-4(fp)
	// get IP and stuff
	printf("[ethernet] Acquired IP address via DHCP client for interface: %s\n", netif->name);
 20002f0:	e0bfff17 	ldw	r2,-4(fp)
 20002f4:	10800f84 	addi	r2,r2,62
 20002f8:	100b883a 	mov	r5,r2
 20002fc:	01008134 	movhi	r4,516
 2000300:	21195004 	addi	r4,r4,25920
 2000304:	20009e40 	call	20009e4 <printf>

	char buf[255];

	print_ipad(netif->ip_addr.addr, buf);
 2000308:	e0bfff17 	ldw	r2,-4(fp)
 200030c:	10800117 	ldw	r2,4(r2)
 2000310:	e17fbf04 	addi	r5,fp,-260
 2000314:	1009883a 	mov	r4,r2
 2000318:	2013cb40 	call	2013cb4 <print_ipad>
	printf("[ethernet] IP address : %s\n", buf);
 200031c:	e17fbf04 	addi	r5,fp,-260
 2000320:	01008134 	movhi	r4,516
 2000324:	21196104 	addi	r4,r4,25988
 2000328:	20009e40 	call	20009e4 <printf>

	print_ipad(netif->netmask.addr, buf);
 200032c:	e0bfff17 	ldw	r2,-4(fp)
 2000330:	10800217 	ldw	r2,8(r2)
 2000334:	e17fbf04 	addi	r5,fp,-260
 2000338:	1009883a 	mov	r4,r2
 200033c:	2013cb40 	call	2013cb4 <print_ipad>
	printf("[ethernet] Subnet     : %s\n", buf);
 2000340:	e17fbf04 	addi	r5,fp,-260
 2000344:	01008134 	movhi	r4,516
 2000348:	21196804 	addi	r4,r4,26016
 200034c:	20009e40 	call	20009e4 <printf>

    print_ipad(netif->gw.addr, buf);
 2000350:	e0bfff17 	ldw	r2,-4(fp)
 2000354:	10800317 	ldw	r2,12(r2)
 2000358:	e17fbf04 	addi	r5,fp,-260
 200035c:	1009883a 	mov	r4,r2
 2000360:	2013cb40 	call	2013cb4 <print_ipad>
	printf("[ethernet] Gateway    : %s\n", buf);
 2000364:	e17fbf04 	addi	r5,fp,-260
 2000368:	01008134 	movhi	r4,516
 200036c:	21196f04 	addi	r4,r4,26044
 2000370:	20009e40 	call	20009e4 <printf>
}
 2000374:	0001883a 	nop
 2000378:	e037883a 	mov	sp,fp
 200037c:	dfc00117 	ldw	ra,4(sp)
 2000380:	df000017 	ldw	fp,0(sp)
 2000384:	dec00204 	addi	sp,sp,8
 2000388:	f800283a 	ret

0200038c <LinkCallback>:

static void LinkCallback(struct netif* netif)
{
 200038c:	defffd04 	addi	sp,sp,-12
 2000390:	dfc00215 	stw	ra,8(sp)
 2000394:	df000115 	stw	fp,4(sp)
 2000398:	df000104 	addi	fp,sp,4
 200039c:	e13fff15 	stw	r4,-4(fp)
	// link change callback
	// TODO release semaphore
	// TODO switch context

	alt_printf("[ethernet] Link Callback for interface: %s\n", netif->name);
 20003a0:	e0bfff17 	ldw	r2,-4(fp)
 20003a4:	10800f84 	addi	r2,r2,62
 20003a8:	100b883a 	mov	r5,r2
 20003ac:	01008134 	movhi	r4,516
 20003b0:	21197604 	addi	r4,r4,26072
 20003b4:	2012cc00 	call	2012cc0 <alt_printf>
}
 20003b8:	0001883a 	nop
 20003bc:	e037883a 	mov	sp,fp
 20003c0:	dfc00117 	ldw	ra,4(sp)
 20003c4:	df000017 	ldw	fp,0(sp)
 20003c8:	dec00204 	addi	sp,sp,8
 20003cc:	f800283a 	ret

020003d0 <InitNetwork>:

int InitNetwork(void)
{
 20003d0:	defffe04 	addi	sp,sp,-8
 20003d4:	dfc00115 	stw	ra,4(sp)
 20003d8:	df000015 	stw	fp,0(sp)
 20003dc:	d839883a 	mov	fp,sp
	// register new DHCP "IP attained" callback function.
	// if DHCP is acquired, ws_ipset will be called instead of dhc_main_ipset().
	lwip_set_status_callback(StatusCallback);
 20003e0:	01008034 	movhi	r4,512
 20003e4:	2100b704 	addi	r4,r4,732
 20003e8:	2013a680 	call	2013a68 <lwip_set_status_callback>
	lwip_set_link_callback(LinkCallback);
 20003ec:	01008034 	movhi	r4,512
 20003f0:	2100e304 	addi	r4,r4,908
 20003f4:	2013a9c0 	call	2013a9c <lwip_set_link_callback>

	// Initialize LwIP TCP/IP stack.
	// This function is blocking till the the interface is up.
	lwip_initialize(1);
 20003f8:	01000044 	movi	r4,1
 20003fc:	20135c80 	call	20135c8 <lwip_initialize>

	return EXIT_SUCCESS;
 2000400:	0005883a 	mov	r2,zero
}
 2000404:	e037883a 	mov	sp,fp
 2000408:	dfc00117 	ldw	ra,4(sp)
 200040c:	df000017 	ldw	fp,0(sp)
 2000410:	dec00204 	addi	sp,sp,8
 2000414:	f800283a 	ret

02000418 <WaitOnPHY>:

static int WaitOnPHY(void)
{
 2000418:	defff904 	addi	sp,sp,-28
 200041c:	dfc00615 	stw	ra,24(sp)
 2000420:	df000515 	stw	fp,20(sp)
 2000424:	df000504 	addi	fp,sp,20
	int phyadd;
	int phyid;
	int phyid2 = 0;
 2000428:	e03ffd15 	stw	zero,-12(fp)

	np_tse_mac* pmac;
	bool bInitialized = false;
 200042c:	e03fff05 	stb	zero,-4(fp)

	while (!bInitialized) {
 2000430:	00003606 	br	200050c <WaitOnPHY+0xf4>
		alt_printf("[ethernet] PHY INFO: Interface: %d Waiting for PHY\n", 0);
 2000434:	000b883a 	mov	r5,zero
 2000438:	01008134 	movhi	r4,516
 200043c:	21198104 	addi	r4,r4,26116
 2000440:	2012cc00 	call	2012cc0 <alt_printf>

		// initialize the structure necessary for "pmac" to function.
		pmac = (np_tse_mac*)TSE_MAC_0_BASE;
 2000444:	00810034 	movhi	r2,1024
 2000448:	10880004 	addi	r2,r2,8192
 200044c:	e0bffe15 	stw	r2,-8(fp)


		for (phyadd = 0x00; phyadd < 0xff; phyadd++) {
 2000450:	e03ffb15 	stw	zero,-20(fp)
 2000454:	00001a06 	br	20004c0 <WaitOnPHY+0xa8>
			IOWR(&pmac->MDIO_ADDR0, 0, phyadd);
 2000458:	e0bffe17 	ldw	r2,-8(fp)
 200045c:	10800f04 	addi	r2,r2,60
 2000460:	e0fffb17 	ldw	r3,-20(fp)
 2000464:	10c00035 	stwio	r3,0(r2)

			phyid = IORD(&pmac->MDIO_IFACE.PHY_ID1, 0);
 2000468:	e0bffe17 	ldw	r2,-8(fp)
 200046c:	1080a204 	addi	r2,r2,648
 2000470:	10800037 	ldwio	r2,0(r2)
 2000474:	e0bffc15 	stw	r2,-16(fp)
			phyid2 = IORD(&pmac->MDIO_IFACE.PHY_ID2, 0);
 2000478:	e0bffe17 	ldw	r2,-8(fp)
 200047c:	1080a304 	addi	r2,r2,652
 2000480:	10800037 	ldwio	r2,0(r2)
 2000484:	e0bffd15 	stw	r2,-12(fp)

			if (phyid != phyid2) {
 2000488:	e0fffc17 	ldw	r3,-16(fp)
 200048c:	e0bffd17 	ldw	r2,-12(fp)
 2000490:	18800826 	beq	r3,r2,20004b4 <WaitOnPHY+0x9c>
				alt_printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
 2000494:	e1fffd17 	ldw	r7,-12(fp)
 2000498:	e1bffc17 	ldw	r6,-16(fp)
 200049c:	e17ffb17 	ldw	r5,-20(fp)
 20004a0:	01008134 	movhi	r4,516
 20004a4:	21198e04 	addi	r4,r4,26168
 20004a8:	2012cc00 	call	2012cc0 <alt_printf>
				phyadd = 0xff;
 20004ac:	00803fc4 	movi	r2,255
 20004b0:	e0bffb15 	stw	r2,-20(fp)

		// initialize the structure necessary for "pmac" to function.
		pmac = (np_tse_mac*)TSE_MAC_0_BASE;


		for (phyadd = 0x00; phyadd < 0xff; phyadd++) {
 20004b4:	e0bffb17 	ldw	r2,-20(fp)
 20004b8:	10800044 	addi	r2,r2,1
 20004bc:	e0bffb15 	stw	r2,-20(fp)
 20004c0:	e0bffb17 	ldw	r2,-20(fp)
 20004c4:	10803fd0 	cmplti	r2,r2,255
 20004c8:	103fe31e 	bne	r2,zero,2000458 <__alt_mem_mem_0+0xfcfe0458>
				alt_printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
				phyadd = 0xff;
			}
		}

		if ((phyadd == 0xff) && (phyid == phyid2)) {
 20004cc:	e0bffb17 	ldw	r2,-20(fp)
 20004d0:	10803fd8 	cmpnei	r2,r2,255
 20004d4:	10000b1e 	bne	r2,zero,2000504 <WaitOnPHY+0xec>
 20004d8:	e0fffc17 	ldw	r3,-16(fp)
 20004dc:	e0bffd17 	ldw	r2,-12(fp)
 20004e0:	1880081e 	bne	r3,r2,2000504 <WaitOnPHY+0xec>
			alt_printf("[ethernet] PHY INFO: No PHY found... restart detect\n");
 20004e4:	01008134 	movhi	r4,516
 20004e8:	21199904 	addi	r4,r4,26212
 20004ec:	2012cc00 	call	2012cc0 <alt_printf>
			bInitialized = true;
 20004f0:	00800044 	movi	r2,1
 20004f4:	e0bfff05 	stb	r2,-4(fp)
			mssleep(1000);
 20004f8:	0100fa04 	movi	r4,1000
 20004fc:	200f0980 	call	200f098 <vTaskDelay>
 2000500:	00000206 	br	200050c <WaitOnPHY+0xf4>
		}
		else
			bInitialized = true;
 2000504:	00800044 	movi	r2,1
 2000508:	e0bfff05 	stb	r2,-4(fp)
	int phyid2 = 0;

	np_tse_mac* pmac;
	bool bInitialized = false;

	while (!bInitialized) {
 200050c:	e0bfff03 	ldbu	r2,-4(fp)
 2000510:	1080005c 	xori	r2,r2,1
 2000514:	10803fcc 	andi	r2,r2,255
 2000518:	103fc61e 	bne	r2,zero,2000434 <__alt_mem_mem_0+0xfcfe0434>
		else
			bInitialized = true;
	}

	// issue a PHY reset.
	IOWR(&pmac->MDIO_IFACE.CONTROL, 0, PCS_CTL_an_enable | PCS_CTL_sw_reset);
 200051c:	e0bffe17 	ldw	r2,-8(fp)
 2000520:	1080a004 	addi	r2,r2,640
 2000524:	00e40014 	movui	r3,36864
 2000528:	10c00035 	stwio	r3,0(r2)
	if (((IORD(&pmac->MDIO_IFACE.CONTROL, 0) & PCS_CTL_rx_slpbk) != 0) || ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)) {
 200052c:	e0bffe17 	ldw	r2,-8(fp)
 2000530:	1080a004 	addi	r2,r2,640
 2000534:	10800037 	ldwio	r2,0(r2)
 2000538:	1090000c 	andi	r2,r2,16384
 200053c:	1000051e 	bne	r2,zero,2000554 <WaitOnPHY+0x13c>
 2000540:	e0bffe17 	ldw	r2,-8(fp)
 2000544:	1080a104 	addi	r2,r2,644
 2000548:	10800037 	ldwio	r2,0(r2)
 200054c:	1080080c 	andi	r2,r2,32
 2000550:	1000071e 	bne	r2,zero,2000570 <WaitOnPHY+0x158>
		IOWR(&pmac->MDIO_IFACE.CONTROL, 0, PCS_CTL_an_enable | PCS_CTL_sw_reset);
 2000554:	e0bffe17 	ldw	r2,-8(fp)
 2000558:	1080a004 	addi	r2,r2,640
 200055c:	00e40014 	movui	r3,36864
 2000560:	10c00035 	stwio	r3,0(r2)
		alt_printf("[ethernet] PHY INFO: Issuing PHY Reset\n");
 2000564:	01008134 	movhi	r4,516
 2000568:	2119a704 	addi	r4,r4,26268
 200056c:	2012cc00 	call	2012cc0 <alt_printf>
	}

	// holding pattern until autonegotiation completes.
	if ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0) {
 2000570:	e0bffe17 	ldw	r2,-8(fp)
 2000574:	1080a104 	addi	r2,r2,644
 2000578:	10800037 	ldwio	r2,0(r2)
 200057c:	1080080c 	andi	r2,r2,32
 2000580:	1000101e 	bne	r2,zero,20005c4 <WaitOnPHY+0x1ac>
		alt_printf("[ethernet] PHY INFO: Waiting on PHY link...\n");
 2000584:	01008134 	movhi	r4,516
 2000588:	2119b104 	addi	r4,r4,26308
 200058c:	2012cc00 	call	2012cc0 <alt_printf>

		while ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)
 2000590:	00000206 	br	200059c <WaitOnPHY+0x184>
			mssleep(10);
 2000594:	01000284 	movi	r4,10
 2000598:	200f0980 	call	200f098 <vTaskDelay>

	// holding pattern until autonegotiation completes.
	if ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0) {
		alt_printf("[ethernet] PHY INFO: Waiting on PHY link...\n");

		while ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)
 200059c:	e0bffe17 	ldw	r2,-8(fp)
 20005a0:	1080a104 	addi	r2,r2,644
 20005a4:	10800037 	ldwio	r2,0(r2)
 20005a8:	1080080c 	andi	r2,r2,32
 20005ac:	103ff926 	beq	r2,zero,2000594 <__alt_mem_mem_0+0xfcfe0594>
			mssleep(10);

		alt_printf("[ethernet] PHY INFO: PHY link detected, allowing network to start.\n");
 20005b0:	01008134 	movhi	r4,516
 20005b4:	2119bd04 	addi	r4,r4,26356
 20005b8:	2012cc00 	call	2012cc0 <alt_printf>
		
		mssleep(1000);
 20005bc:	0100fa04 	movi	r4,1000
 20005c0:	200f0980 	call	200f098 <vTaskDelay>
	}

	mssleep(10);
 20005c4:	01000284 	movi	r4,10
 20005c8:	200f0980 	call	200f098 <vTaskDelay>

	return 0;
 20005cc:	0005883a 	mov	r2,zero
}
 20005d0:	e037883a 	mov	sp,fp
 20005d4:	dfc00117 	ldw	ra,4(sp)
 20005d8:	df000017 	ldw	fp,0(sp)
 20005dc:	dec00204 	addi	sp,sp,8
 20005e0:	f800283a 	ret

020005e4 <xEthernetRun>:


void xEthernetRun()
{
 20005e4:	defffd04 	addi	sp,sp,-12
 20005e8:	dfc00215 	stw	ra,8(sp)
 20005ec:	df000115 	stw	fp,4(sp)
 20005f0:	df000104 	addi	fp,sp,4
    alt_printf("--------- Init Network ---------\r\n");
 20005f4:	01008134 	movhi	r4,516
 20005f8:	2119ce04 	addi	r4,r4,26424
 20005fc:	2012cc00 	call	2012cc0 <alt_printf>

	// initialize PHY
	WaitOnPHY();
 2000600:	20004180 	call	2000418 <WaitOnPHY>

	if (InitNetwork() != EXIT_SUCCESS) {
 2000604:	20003d00 	call	20003d0 <InitNetwork>
 2000608:	10000326 	beq	r2,zero,2000618 <xEthernetRun+0x34>
		// the network initialization has failed.
		alt_printf("[ethernet] Network initialize failed!\n");
 200060c:	01008134 	movhi	r4,516
 2000610:	2119d704 	addi	r4,r4,26460
 2000614:	2012cc00 	call	2012cc0 <alt_printf>
	}

    nw_ready = 1;
 2000618:	00800044 	movi	r2,1
 200061c:	d0a79a15 	stw	r2,-24984(gp)
	alt_printf("--------- Init Done ---------\r\n");
 2000620:	01008134 	movhi	r4,516
 2000624:	2119e104 	addi	r4,r4,26500
 2000628:	2012cc00 	call	2012cc0 <alt_printf>
    /*sys_thread_new("ping", PingThread, NULL,
    		THREAD_STACKSIZE,
            DEFAULT_THREAD_PRIO);*/

	struct netif* ethif;
	ethif = get_netif(0);
 200062c:	0009883a 	mov	r4,zero
 2000630:	2013a200 	call	2013a20 <get_netif>
 2000634:	e0bfff15 	stw	r2,-4(fp)

	IP4_ADDR(&PingIp, 192, 168, 1, 100);
 2000638:	009900b4 	movhi	r2,25602
 200063c:	10aa3004 	addi	r2,r2,-22336
 2000640:	d0a79c15 	stw	r2,-24976(gp)
	while(1) {

        //lwip_ping_target(PingIp.addr, 1, 0, 100);
		// sleep for 1 second
		//lwip_ping_target(PingIp.addr, 10, 0, 100);
        ethernetif_input(ethif);
 2000644:	e13fff17 	ldw	r4,-4(fp)
 2000648:	201331c0 	call	201331c <ethernetif_input>
        vTaskDelay(10);
 200064c:	01000284 	movi	r4,10
 2000650:	200f0980 	call	200f098 <vTaskDelay>
	}
 2000654:	003ffb06 	br	2000644 <__alt_mem_mem_0+0xfcfe0644>

02000658 <get_mac_addr>:
    //vTaskDelete(NULL);
}

// callback wrapper for lwip to get the interface configurations
int get_mac_addr(int iface, struct netif* ethif, unsigned char mac_addr[6])
{
 2000658:	defff704 	addi	sp,sp,-36
 200065c:	dfc00815 	stw	ra,32(sp)
 2000660:	df000715 	stw	fp,28(sp)
 2000664:	df000704 	addi	fp,sp,28
 2000668:	e13ffd15 	stw	r4,-12(fp)
 200066c:	e17ffe15 	stw	r5,-8(fp)
 2000670:	e1bfff15 	stw	r6,-4(fp)
	mac_addr[0] = 0x12;
 2000674:	e0bfff17 	ldw	r2,-4(fp)
 2000678:	00c00484 	movi	r3,18
 200067c:	10c00005 	stb	r3,0(r2)
	mac_addr[1] = 0x23;
 2000680:	e0bfff17 	ldw	r2,-4(fp)
 2000684:	10800044 	addi	r2,r2,1
 2000688:	00c008c4 	movi	r3,35
 200068c:	10c00005 	stb	r3,0(r2)
	mac_addr[2] = 0x45;
 2000690:	e0bfff17 	ldw	r2,-4(fp)
 2000694:	10800084 	addi	r2,r2,2
 2000698:	00c01144 	movi	r3,69
 200069c:	10c00005 	stb	r3,0(r2)
	mac_addr[3] = 0xFF;
 20006a0:	e0bfff17 	ldw	r2,-4(fp)
 20006a4:	108000c4 	addi	r2,r2,3
 20006a8:	00ffffc4 	movi	r3,-1
 20006ac:	10c00005 	stb	r3,0(r2)
	mac_addr[4] = 0xFF;
 20006b0:	e0bfff17 	ldw	r2,-4(fp)
 20006b4:	10800104 	addi	r2,r2,4
 20006b8:	00ffffc4 	movi	r3,-1
 20006bc:	10c00005 	stb	r3,0(r2)
	mac_addr[5] = 0xF0 + iface;
 20006c0:	e0bfff17 	ldw	r2,-4(fp)
 20006c4:	10800144 	addi	r2,r2,5
 20006c8:	e0fffd17 	ldw	r3,-12(fp)
 20006cc:	18fffc04 	addi	r3,r3,-16
 20006d0:	10c00005 	stb	r3,0(r2)

	// only show info if net is not NULL
	if (ethif)
 20006d4:	e0bffe17 	ldw	r2,-8(fp)
 20006d8:	10002026 	beq	r2,zero,200075c <get_mac_addr+0x104>
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20006dc:	e0bfff17 	ldw	r2,-4(fp)
 20006e0:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 20006e4:	12003fcc 	andi	r8,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20006e8:	e0bfff17 	ldw	r2,-4(fp)
 20006ec:	10800044 	addi	r2,r2,1
 20006f0:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 20006f4:	11803fcc 	andi	r6,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20006f8:	e0bfff17 	ldw	r2,-4(fp)
 20006fc:	10800084 	addi	r2,r2,2
 2000700:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 2000704:	11c03fcc 	andi	r7,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 2000708:	e0bfff17 	ldw	r2,-4(fp)
 200070c:	108000c4 	addi	r2,r2,3
 2000710:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 2000714:	10803fcc 	andi	r2,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 2000718:	e0ffff17 	ldw	r3,-4(fp)
 200071c:	18c00104 	addi	r3,r3,4
 2000720:	18c00003 	ldbu	r3,0(r3)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 2000724:	18c03fcc 	andi	r3,r3,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 2000728:	e13fff17 	ldw	r4,-4(fp)
 200072c:	21000144 	addi	r4,r4,5
 2000730:	21000003 	ldbu	r4,0(r4)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 2000734:	21003fcc 	andi	r4,r4,255
 2000738:	e17ffd17 	ldw	r5,-12(fp)
 200073c:	d9400315 	stw	r5,12(sp)
 2000740:	d9000215 	stw	r4,8(sp)
 2000744:	d8c00115 	stw	r3,4(sp)
 2000748:	d8800015 	stw	r2,0(sp)
 200074c:	400b883a 	mov	r5,r8
 2000750:	01008134 	movhi	r4,516
 2000754:	2119e904 	addi	r4,r4,26532
 2000758:	20009e40 	call	20009e4 <printf>
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);

	return EXIT_SUCCESS;
 200075c:	0005883a 	mov	r2,zero
}
 2000760:	e037883a 	mov	sp,fp
 2000764:	dfc00117 	ldw	ra,4(sp)
 2000768:	df000017 	ldw	fp,0(sp)
 200076c:	dec00204 	addi	sp,sp,8
 2000770:	f800283a 	ret

02000774 <get_ip_addr>:

// callback wrapper for lwip to get the IP configurations
int get_ip_addr(int iface, ip_addr_t* ipaddr, ip_addr_t* netmask, ip_addr_t* gw, int* use_dhcp)
{
 2000774:	deffba04 	addi	sp,sp,-280
 2000778:	dfc04515 	stw	ra,276(sp)
 200077c:	df004415 	stw	fp,272(sp)
 2000780:	df004404 	addi	fp,sp,272
 2000784:	e13ffc15 	stw	r4,-16(fp)
 2000788:	e17ffd15 	stw	r5,-12(fp)
 200078c:	e1bffe15 	stw	r6,-8(fp)
 2000790:	e1ffff15 	stw	r7,-4(fp)
	// set configuration
	IP4_ADDR(ipaddr, 192, 168, 1, 218);
 2000794:	e0fffd17 	ldw	r3,-12(fp)
 2000798:	00b680b4 	movhi	r2,55810
 200079c:	10aa3004 	addi	r2,r2,-22336
 20007a0:	18800015 	stw	r2,0(r3)
	IP4_ADDR(netmask, 255, 255, 255, 0);
 20007a4:	e0fffe17 	ldw	r3,-8(fp)
 20007a8:	00804034 	movhi	r2,256
 20007ac:	10bfffc4 	addi	r2,r2,-1
 20007b0:	18800015 	stw	r2,0(r3)
	IP4_ADDR(gw, 192, 168, 1, 1);
 20007b4:	e0ffff17 	ldw	r3,-4(fp)
 20007b8:	008040b4 	movhi	r2,258
 20007bc:	10aa3004 	addi	r2,r2,-22336
 20007c0:	18800015 	stw	r2,0(r3)
	*use_dhcp = 0;
 20007c4:	e0800217 	ldw	r2,8(fp)
 20007c8:	10000015 	stw	zero,0(r2)

	if (*use_dhcp == 0){
 20007cc:	e0800217 	ldw	r2,8(fp)
 20007d0:	10800017 	ldw	r2,0(r2)
 20007d4:	10000b1e 	bne	r2,zero,2000804 <get_ip_addr+0x90>
		char buf[255];
		print_ipad(ipaddr->addr, buf);
 20007d8:	e0bffd17 	ldw	r2,-12(fp)
 20007dc:	10800017 	ldw	r2,0(r2)
 20007e0:	e17fbc04 	addi	r5,fp,-272
 20007e4:	1009883a 	mov	r4,r2
 20007e8:	2013cb40 	call	2013cb4 <print_ipad>
		printf("[ethernet] Static IP Address for interface %d %s\n", iface, buf);
 20007ec:	e1bfbc04 	addi	r6,fp,-272
 20007f0:	e17ffc17 	ldw	r5,-16(fp)
 20007f4:	01008134 	movhi	r4,516
 20007f8:	2119ff04 	addi	r4,r4,26620
 20007fc:	20009e40 	call	20009e4 <printf>
 2000800:	00000406 	br	2000814 <get_ip_addr+0xa0>
	}
	else
		printf("[ethernet] Starting get IP via DHCP for interface %d\n", iface);
 2000804:	e17ffc17 	ldw	r5,-16(fp)
 2000808:	01008134 	movhi	r4,516
 200080c:	211a0c04 	addi	r4,r4,26672
 2000810:	20009e40 	call	20009e4 <printf>

	return EXIT_SUCCESS;
 2000814:	0005883a 	mov	r2,zero
}
 2000818:	e037883a 	mov	sp,fp
 200081c:	dfc00117 	ldw	ra,4(sp)
 2000820:	df000017 	ldw	fp,0(sp)
 2000824:	dec00204 	addi	sp,sp,8
 2000828:	f800283a 	ret

0200082c <get_hostname>:

int get_hostname(int iface, const char **hostname)
{
 200082c:	defffd04 	addi	sp,sp,-12
 2000830:	df000215 	stw	fp,8(sp)
 2000834:	df000204 	addi	fp,sp,8
 2000838:	e13ffe15 	stw	r4,-8(fp)
 200083c:	e17fff15 	stw	r5,-4(fp)
	*hostname = "LwIP";
 2000840:	e0ffff17 	ldw	r3,-4(fp)
 2000844:	00808134 	movhi	r2,516
 2000848:	109a1a04 	addi	r2,r2,26728
 200084c:	18800015 	stw	r2,0(r3)

	return ERR_OK;
 2000850:	0005883a 	mov	r2,zero
}
 2000854:	e037883a 	mov	sp,fp
 2000858:	df000017 	ldw	fp,0(sp)
 200085c:	dec00104 	addi	sp,sp,4
 2000860:	f800283a 	ret

02000864 <get_iface_name>:

int get_iface_name(int iface, char name[ETH_IFACE_NAME_LENGTH])
{
 2000864:	defffd04 	addi	sp,sp,-12
 2000868:	df000215 	stw	fp,8(sp)
 200086c:	df000204 	addi	fp,sp,8
 2000870:	e13ffe15 	stw	r4,-8(fp)
 2000874:	e17fff15 	stw	r5,-4(fp)
	name[0] = 'e';
 2000878:	e0bfff17 	ldw	r2,-4(fp)
 200087c:	00c01944 	movi	r3,101
 2000880:	10c00005 	stb	r3,0(r2)
	name[1] = (iface + 0x30);
 2000884:	e0bfff17 	ldw	r2,-4(fp)
 2000888:	10800044 	addi	r2,r2,1
 200088c:	e0fffe17 	ldw	r3,-8(fp)
 2000890:	18c00c04 	addi	r3,r3,48
 2000894:	10c00005 	stb	r3,0(r2)

	return ERR_OK;
 2000898:	0005883a 	mov	r2,zero
}
 200089c:	e037883a 	mov	sp,fp
 20008a0:	df000017 	ldw	fp,0(sp)
 20008a4:	dec00104 	addi	sp,sp,4
 20008a8:	f800283a 	ret

020008ac <is_interface_active>:

int is_interface_active(int iface)
{
 20008ac:	defffe04 	addi	sp,sp,-8
 20008b0:	df000115 	stw	fp,4(sp)
 20008b4:	df000104 	addi	fp,sp,4
 20008b8:	e13fff15 	stw	r4,-4(fp)
	return 1;
 20008bc:	00800044 	movi	r2,1
}
 20008c0:	e037883a 	mov	sp,fp
 20008c4:	df000017 	ldw	fp,0(sp)
 20008c8:	dec00104 	addi	sp,sp,4
 20008cc:	f800283a 	ret

020008d0 <main>:


int main(){
 20008d0:	defffd04 	addi	sp,sp,-12
 20008d4:	dfc00215 	stw	ra,8(sp)
 20008d8:	df000115 	stw	fp,4(sp)
 20008dc:	df000104 	addi	fp,sp,4
    main_thread_handle = sys_thread_new("main_thrd", (void(*)(void*))main_thread, 0,
 20008e0:	008000c4 	movi	r2,3
 20008e4:	d8800015 	stw	r2,0(sp)
 20008e8:	01c40004 	movi	r7,4096
 20008ec:	000d883a 	mov	r6,zero
 20008f0:	01408034 	movhi	r5,512
 20008f4:	29424404 	addi	r5,r5,2320
 20008f8:	01008134 	movhi	r4,516
 20008fc:	211a1c04 	addi	r4,r4,26736
 2000900:	20155200 	call	2015520 <sys_thread_new>
 2000904:	d0a79b15 	stw	r2,-24980(gp)
                    THREAD_STACKSIZE,
					DEFAULT_THREAD_PRIO);
    vTaskStartScheduler();
 2000908:	200f7c00 	call	200f7c0 <vTaskStartScheduler>
    while(1);
 200090c:	003fff06 	br	200090c <__alt_mem_mem_0+0xfcfe090c>

02000910 <main_thread>:
    return 0;
}


int main_thread(){
 2000910:	defffd04 	addi	sp,sp,-12
 2000914:	dfc00215 	stw	ra,8(sp)
 2000918:	df000115 	stw	fp,4(sp)
 200091c:	df000104 	addi	fp,sp,4
	alt_printf("------------------------------------------------------\r\n");
 2000920:	01008134 	movhi	r4,516
 2000924:	211a1f04 	addi	r4,r4,26748
 2000928:	2012cc00 	call	2012cc0 <alt_printf>
	alt_printf("--------- Starting OPC UA Server application ---------\r\n");
 200092c:	01008134 	movhi	r4,516
 2000930:	211a2e04 	addi	r4,r4,26808
 2000934:	2012cc00 	call	2012cc0 <alt_printf>
	alt_printf("------------------------------------------------------\r\n");
 2000938:	01008134 	movhi	r4,516
 200093c:	211a1f04 	addi	r4,r4,26748
 2000940:	2012cc00 	call	2012cc0 <alt_printf>
	alt_printf("--------- open62541 example created for a    ---------\r\n");
 2000944:	01008134 	movhi	r4,516
 2000948:	211a3d04 	addi	r4,r4,26868
 200094c:	2012cc00 	call	2012cc0 <alt_printf>
    alt_printf("--------- MicroBlaze design on a Artix7 FPGA ---------\r\n");
 2000950:	01008134 	movhi	r4,516
 2000954:	211a4c04 	addi	r4,r4,26928
 2000958:	2012cc00 	call	2012cc0 <alt_printf>
    alt_printf("------------------------------------------------------\r\n");
 200095c:	01008134 	movhi	r4,516
 2000960:	211a1f04 	addi	r4,r4,26748
 2000964:	2012cc00 	call	2012cc0 <alt_printf>
    alt_printf("--------- NetTImeLogic GmbH, Switzerland     ---------\r\n");
 2000968:	01008134 	movhi	r4,516
 200096c:	211a5b04 	addi	r4,r4,26988
 2000970:	2012cc00 	call	2012cc0 <alt_printf>
    alt_printf("--------- contact@nettimelogic.com           ---------\r\n");
 2000974:	01008134 	movhi	r4,516
 2000978:	211a6a04 	addi	r4,r4,27048
 200097c:	2012cc00 	call	2012cc0 <alt_printf>
    alt_printf("------------------------------------------------------\r\n");
 2000980:	01008134 	movhi	r4,516
 2000984:	211a1f04 	addi	r4,r4,26748
 2000988:	2012cc00 	call	2012cc0 <alt_printf>

	//xTaskCreate(xEthernetRun, "eth0", KB(4), NULL, tskIDLE_PRIORITY + 2, NULL);

	sys_thread_new("NetworkInit", xEthernetRun, NULL,
 200098c:	008000c4 	movi	r2,3
 2000990:	d8800015 	stw	r2,0(sp)
 2000994:	01c40004 	movi	r7,4096
 2000998:	000d883a 	mov	r6,zero
 200099c:	01408034 	movhi	r5,512
 20009a0:	29417904 	addi	r5,r5,1508
 20009a4:	01008134 	movhi	r4,516
 20009a8:	211a7904 	addi	r4,r4,27108
 20009ac:	20155200 	call	2015520 <sys_thread_new>
            DEFAULT_THREAD_PRIO);



    //vTaskStartScheduler();
    while(1);
 20009b0:	003fff06 	br	20009b0 <__alt_mem_mem_0+0xfcfe09b0>

020009b4 <_printf_r>:
 20009b4:	defffd04 	addi	sp,sp,-12
 20009b8:	2805883a 	mov	r2,r5
 20009bc:	dfc00015 	stw	ra,0(sp)
 20009c0:	d9800115 	stw	r6,4(sp)
 20009c4:	d9c00215 	stw	r7,8(sp)
 20009c8:	21400217 	ldw	r5,8(r4)
 20009cc:	d9c00104 	addi	r7,sp,4
 20009d0:	100d883a 	mov	r6,r2
 20009d4:	2000a200 	call	2000a20 <___vfprintf_internal_r>
 20009d8:	dfc00017 	ldw	ra,0(sp)
 20009dc:	dec00304 	addi	sp,sp,12
 20009e0:	f800283a 	ret

020009e4 <printf>:
 20009e4:	defffc04 	addi	sp,sp,-16
 20009e8:	dfc00015 	stw	ra,0(sp)
 20009ec:	d9400115 	stw	r5,4(sp)
 20009f0:	d9800215 	stw	r6,8(sp)
 20009f4:	d9c00315 	stw	r7,12(sp)
 20009f8:	00808174 	movhi	r2,517
 20009fc:	10ab4004 	addi	r2,r2,-21248
 2000a00:	10800017 	ldw	r2,0(r2)
 2000a04:	200b883a 	mov	r5,r4
 2000a08:	d9800104 	addi	r6,sp,4
 2000a0c:	11000217 	ldw	r4,8(r2)
 2000a10:	2002c180 	call	2002c18 <__vfprintf_internal>
 2000a14:	dfc00017 	ldw	ra,0(sp)
 2000a18:	dec00404 	addi	sp,sp,16
 2000a1c:	f800283a 	ret

02000a20 <___vfprintf_internal_r>:
 2000a20:	deffb804 	addi	sp,sp,-288
 2000a24:	dfc04715 	stw	ra,284(sp)
 2000a28:	ddc04515 	stw	r23,276(sp)
 2000a2c:	dd404315 	stw	r21,268(sp)
 2000a30:	d9002c15 	stw	r4,176(sp)
 2000a34:	282f883a 	mov	r23,r5
 2000a38:	302b883a 	mov	r21,r6
 2000a3c:	d9c02d15 	stw	r7,180(sp)
 2000a40:	df004615 	stw	fp,280(sp)
 2000a44:	dd804415 	stw	r22,272(sp)
 2000a48:	dd004215 	stw	r20,264(sp)
 2000a4c:	dcc04115 	stw	r19,260(sp)
 2000a50:	dc804015 	stw	r18,256(sp)
 2000a54:	dc403f15 	stw	r17,252(sp)
 2000a58:	dc003e15 	stw	r16,248(sp)
 2000a5c:	200537c0 	call	200537c <_localeconv_r>
 2000a60:	10800017 	ldw	r2,0(r2)
 2000a64:	1009883a 	mov	r4,r2
 2000a68:	d8803415 	stw	r2,208(sp)
 2000a6c:	20073a40 	call	20073a4 <strlen>
 2000a70:	d8803715 	stw	r2,220(sp)
 2000a74:	d8802c17 	ldw	r2,176(sp)
 2000a78:	10000226 	beq	r2,zero,2000a84 <___vfprintf_internal_r+0x64>
 2000a7c:	10800e17 	ldw	r2,56(r2)
 2000a80:	1000f926 	beq	r2,zero,2000e68 <___vfprintf_internal_r+0x448>
 2000a84:	b880030b 	ldhu	r2,12(r23)
 2000a88:	10c8000c 	andi	r3,r2,8192
 2000a8c:	1800061e 	bne	r3,zero,2000aa8 <___vfprintf_internal_r+0x88>
 2000a90:	b9001917 	ldw	r4,100(r23)
 2000a94:	00f7ffc4 	movi	r3,-8193
 2000a98:	10880014 	ori	r2,r2,8192
 2000a9c:	20c6703a 	and	r3,r4,r3
 2000aa0:	b880030d 	sth	r2,12(r23)
 2000aa4:	b8c01915 	stw	r3,100(r23)
 2000aa8:	10c0020c 	andi	r3,r2,8
 2000aac:	1800c126 	beq	r3,zero,2000db4 <___vfprintf_internal_r+0x394>
 2000ab0:	b8c00417 	ldw	r3,16(r23)
 2000ab4:	1800bf26 	beq	r3,zero,2000db4 <___vfprintf_internal_r+0x394>
 2000ab8:	1080068c 	andi	r2,r2,26
 2000abc:	00c00284 	movi	r3,10
 2000ac0:	10c0c426 	beq	r2,r3,2000dd4 <___vfprintf_internal_r+0x3b4>
 2000ac4:	d8c00404 	addi	r3,sp,16
 2000ac8:	05008134 	movhi	r20,516
 2000acc:	d9001e04 	addi	r4,sp,120
 2000ad0:	a51a8c84 	addi	r20,r20,27186
 2000ad4:	d8c01e15 	stw	r3,120(sp)
 2000ad8:	d8002015 	stw	zero,128(sp)
 2000adc:	d8001f15 	stw	zero,124(sp)
 2000ae0:	d8003315 	stw	zero,204(sp)
 2000ae4:	d8003615 	stw	zero,216(sp)
 2000ae8:	d8003815 	stw	zero,224(sp)
 2000aec:	1811883a 	mov	r8,r3
 2000af0:	d8003915 	stw	zero,228(sp)
 2000af4:	d8003a15 	stw	zero,232(sp)
 2000af8:	d8002f15 	stw	zero,188(sp)
 2000afc:	d9002815 	stw	r4,160(sp)
 2000b00:	a8800007 	ldb	r2,0(r21)
 2000b04:	10027b26 	beq	r2,zero,20014f4 <___vfprintf_internal_r+0xad4>
 2000b08:	00c00944 	movi	r3,37
 2000b0c:	a821883a 	mov	r16,r21
 2000b10:	10c0021e 	bne	r2,r3,2000b1c <___vfprintf_internal_r+0xfc>
 2000b14:	00001406 	br	2000b68 <___vfprintf_internal_r+0x148>
 2000b18:	10c00326 	beq	r2,r3,2000b28 <___vfprintf_internal_r+0x108>
 2000b1c:	84000044 	addi	r16,r16,1
 2000b20:	80800007 	ldb	r2,0(r16)
 2000b24:	103ffc1e 	bne	r2,zero,2000b18 <__alt_mem_mem_0+0xfcfe0b18>
 2000b28:	8563c83a 	sub	r17,r16,r21
 2000b2c:	88000e26 	beq	r17,zero,2000b68 <___vfprintf_internal_r+0x148>
 2000b30:	d8c02017 	ldw	r3,128(sp)
 2000b34:	d8801f17 	ldw	r2,124(sp)
 2000b38:	45400015 	stw	r21,0(r8)
 2000b3c:	1c47883a 	add	r3,r3,r17
 2000b40:	10800044 	addi	r2,r2,1
 2000b44:	d8c02015 	stw	r3,128(sp)
 2000b48:	44400115 	stw	r17,4(r8)
 2000b4c:	d8801f15 	stw	r2,124(sp)
 2000b50:	00c001c4 	movi	r3,7
 2000b54:	1880a716 	blt	r3,r2,2000df4 <___vfprintf_internal_r+0x3d4>
 2000b58:	42000204 	addi	r8,r8,8
 2000b5c:	d9402f17 	ldw	r5,188(sp)
 2000b60:	2c4b883a 	add	r5,r5,r17
 2000b64:	d9402f15 	stw	r5,188(sp)
 2000b68:	80800007 	ldb	r2,0(r16)
 2000b6c:	1000a826 	beq	r2,zero,2000e10 <___vfprintf_internal_r+0x3f0>
 2000b70:	84400047 	ldb	r17,1(r16)
 2000b74:	00bfffc4 	movi	r2,-1
 2000b78:	85400044 	addi	r21,r16,1
 2000b7c:	d8002785 	stb	zero,158(sp)
 2000b80:	0007883a 	mov	r3,zero
 2000b84:	000f883a 	mov	r7,zero
 2000b88:	d8802915 	stw	r2,164(sp)
 2000b8c:	d8003115 	stw	zero,196(sp)
 2000b90:	0025883a 	mov	r18,zero
 2000b94:	01401604 	movi	r5,88
 2000b98:	01800244 	movi	r6,9
 2000b9c:	02800a84 	movi	r10,42
 2000ba0:	02401b04 	movi	r9,108
 2000ba4:	ad400044 	addi	r21,r21,1
 2000ba8:	88bff804 	addi	r2,r17,-32
 2000bac:	28830436 	bltu	r5,r2,20017c0 <___vfprintf_internal_r+0xda0>
 2000bb0:	100490ba 	slli	r2,r2,2
 2000bb4:	01008034 	movhi	r4,512
 2000bb8:	2102f204 	addi	r4,r4,3016
 2000bbc:	1105883a 	add	r2,r2,r4
 2000bc0:	10800017 	ldw	r2,0(r2)
 2000bc4:	1000683a 	jmp	r2
 2000bc8:	020016e0 	cmpeqi	r8,zero,91
 2000bcc:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000bd0:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000bd4:	02001700 	call	200170 <__alt_mem_sdram_controller_0-0x1dffe90>
 2000bd8:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000bdc:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000be0:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000be4:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000be8:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000bec:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000bf0:	02000e74 	movhi	r8,57
 2000bf4:	0200161c 	xori	r8,zero,88
 2000bf8:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000bfc:	02000d3c 	xorhi	r8,zero,52
 2000c00:	02000e9c 	xori	r8,zero,58
 2000c04:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c08:	02000edc 	xori	r8,zero,59
 2000c0c:	02000ee8 	cmpgeui	r8,zero,59
 2000c10:	02000ee8 	cmpgeui	r8,zero,59
 2000c14:	02000ee8 	cmpgeui	r8,zero,59
 2000c18:	02000ee8 	cmpgeui	r8,zero,59
 2000c1c:	02000ee8 	cmpgeui	r8,zero,59
 2000c20:	02000ee8 	cmpgeui	r8,zero,59
 2000c24:	02000ee8 	cmpgeui	r8,zero,59
 2000c28:	02000ee8 	cmpgeui	r8,zero,59
 2000c2c:	02000ee8 	cmpgeui	r8,zero,59
 2000c30:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c34:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c38:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c3c:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c40:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c44:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c48:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c4c:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c50:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c54:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c58:	02000f1c 	xori	r8,zero,60
 2000c5c:	02000fd8 	cmpnei	r8,zero,63
 2000c60:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c64:	02000fd8 	cmpnei	r8,zero,63
 2000c68:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c6c:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c70:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c74:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c78:	02001078 	rdprs	r8,zero,65
 2000c7c:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c80:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c84:	02001084 	movi	r8,66
 2000c88:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c8c:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c90:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c94:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c98:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000c9c:	020014fc 	xorhi	r8,zero,83
 2000ca0:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000ca4:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000ca8:	0200155c 	xori	r8,zero,85
 2000cac:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cb0:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cb4:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cb8:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cbc:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cc0:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cc4:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cc8:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000ccc:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cd0:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cd4:	0200176c 	andhi	r8,zero,93
 2000cd8:	0200170c 	andi	r8,zero,92
 2000cdc:	02000fd8 	cmpnei	r8,zero,63
 2000ce0:	02000fd8 	cmpnei	r8,zero,63
 2000ce4:	02000fd8 	cmpnei	r8,zero,63
 2000ce8:	0200171c 	xori	r8,zero,92
 2000cec:	0200170c 	andi	r8,zero,92
 2000cf0:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cf4:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000cf8:	02001728 	cmpgeui	r8,zero,92
 2000cfc:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000d00:	02001738 	rdprs	r8,zero,92
 2000d04:	0200160c 	andi	r8,zero,88
 2000d08:	02000d48 	cmpgei	r8,zero,53
 2000d0c:	0200162c 	andhi	r8,zero,88
 2000d10:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000d14:	02001638 	rdprs	r8,zero,88
 2000d18:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000d1c:	02001694 	movui	r8,90
 2000d20:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000d24:	020017c0 	call	20017c <__alt_mem_sdram_controller_0-0x1dffe84>
 2000d28:	020016a4 	muli	r8,zero,90
 2000d2c:	d9003117 	ldw	r4,196(sp)
 2000d30:	d8802d15 	stw	r2,180(sp)
 2000d34:	0109c83a 	sub	r4,zero,r4
 2000d38:	d9003115 	stw	r4,196(sp)
 2000d3c:	94800114 	ori	r18,r18,4
 2000d40:	ac400007 	ldb	r17,0(r21)
 2000d44:	003f9706 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2000d48:	00800c04 	movi	r2,48
 2000d4c:	d9002d17 	ldw	r4,180(sp)
 2000d50:	d9402917 	ldw	r5,164(sp)
 2000d54:	d8802705 	stb	r2,156(sp)
 2000d58:	00801e04 	movi	r2,120
 2000d5c:	d8802745 	stb	r2,157(sp)
 2000d60:	d8002785 	stb	zero,158(sp)
 2000d64:	20c00104 	addi	r3,r4,4
 2000d68:	24c00017 	ldw	r19,0(r4)
 2000d6c:	002d883a 	mov	r22,zero
 2000d70:	90800094 	ori	r2,r18,2
 2000d74:	28029a16 	blt	r5,zero,20017e0 <___vfprintf_internal_r+0xdc0>
 2000d78:	00bfdfc4 	movi	r2,-129
 2000d7c:	90a4703a 	and	r18,r18,r2
 2000d80:	d8c02d15 	stw	r3,180(sp)
 2000d84:	94800094 	ori	r18,r18,2
 2000d88:	9802871e 	bne	r19,zero,20017a8 <___vfprintf_internal_r+0xd88>
 2000d8c:	00808134 	movhi	r2,516
 2000d90:	109a8504 	addi	r2,r2,27156
 2000d94:	d8803915 	stw	r2,228(sp)
 2000d98:	04401e04 	movi	r17,120
 2000d9c:	d8802917 	ldw	r2,164(sp)
 2000da0:	0039883a 	mov	fp,zero
 2000da4:	1001e926 	beq	r2,zero,200154c <___vfprintf_internal_r+0xb2c>
 2000da8:	0027883a 	mov	r19,zero
 2000dac:	002d883a 	mov	r22,zero
 2000db0:	00020506 	br	20015c8 <___vfprintf_internal_r+0xba8>
 2000db4:	d9002c17 	ldw	r4,176(sp)
 2000db8:	b80b883a 	mov	r5,r23
 2000dbc:	2002cf00 	call	2002cf0 <__swsetup_r>
 2000dc0:	1005ac1e 	bne	r2,zero,2002474 <___vfprintf_internal_r+0x1a54>
 2000dc4:	b880030b 	ldhu	r2,12(r23)
 2000dc8:	00c00284 	movi	r3,10
 2000dcc:	1080068c 	andi	r2,r2,26
 2000dd0:	10ff3c1e 	bne	r2,r3,2000ac4 <__alt_mem_mem_0+0xfcfe0ac4>
 2000dd4:	b880038f 	ldh	r2,14(r23)
 2000dd8:	103f3a16 	blt	r2,zero,2000ac4 <__alt_mem_mem_0+0xfcfe0ac4>
 2000ddc:	d9c02d17 	ldw	r7,180(sp)
 2000de0:	d9002c17 	ldw	r4,176(sp)
 2000de4:	a80d883a 	mov	r6,r21
 2000de8:	b80b883a 	mov	r5,r23
 2000dec:	2002c340 	call	2002c34 <__sbprintf>
 2000df0:	00001106 	br	2000e38 <___vfprintf_internal_r+0x418>
 2000df4:	d9002c17 	ldw	r4,176(sp)
 2000df8:	d9801e04 	addi	r6,sp,120
 2000dfc:	b80b883a 	mov	r5,r23
 2000e00:	20075380 	call	2007538 <__sprint_r>
 2000e04:	1000081e 	bne	r2,zero,2000e28 <___vfprintf_internal_r+0x408>
 2000e08:	da000404 	addi	r8,sp,16
 2000e0c:	003f5306 	br	2000b5c <__alt_mem_mem_0+0xfcfe0b5c>
 2000e10:	d8802017 	ldw	r2,128(sp)
 2000e14:	10000426 	beq	r2,zero,2000e28 <___vfprintf_internal_r+0x408>
 2000e18:	d9002c17 	ldw	r4,176(sp)
 2000e1c:	d9801e04 	addi	r6,sp,120
 2000e20:	b80b883a 	mov	r5,r23
 2000e24:	20075380 	call	2007538 <__sprint_r>
 2000e28:	b880030b 	ldhu	r2,12(r23)
 2000e2c:	1080100c 	andi	r2,r2,64
 2000e30:	1005901e 	bne	r2,zero,2002474 <___vfprintf_internal_r+0x1a54>
 2000e34:	d8802f17 	ldw	r2,188(sp)
 2000e38:	dfc04717 	ldw	ra,284(sp)
 2000e3c:	df004617 	ldw	fp,280(sp)
 2000e40:	ddc04517 	ldw	r23,276(sp)
 2000e44:	dd804417 	ldw	r22,272(sp)
 2000e48:	dd404317 	ldw	r21,268(sp)
 2000e4c:	dd004217 	ldw	r20,264(sp)
 2000e50:	dcc04117 	ldw	r19,260(sp)
 2000e54:	dc804017 	ldw	r18,256(sp)
 2000e58:	dc403f17 	ldw	r17,252(sp)
 2000e5c:	dc003e17 	ldw	r16,248(sp)
 2000e60:	dec04804 	addi	sp,sp,288
 2000e64:	f800283a 	ret
 2000e68:	d9002c17 	ldw	r4,176(sp)
 2000e6c:	2004cc40 	call	2004cc4 <__sinit>
 2000e70:	003f0406 	br	2000a84 <__alt_mem_mem_0+0xfcfe0a84>
 2000e74:	d8802d17 	ldw	r2,180(sp)
 2000e78:	d9002d17 	ldw	r4,180(sp)
 2000e7c:	10800017 	ldw	r2,0(r2)
 2000e80:	d8803115 	stw	r2,196(sp)
 2000e84:	20800104 	addi	r2,r4,4
 2000e88:	d9003117 	ldw	r4,196(sp)
 2000e8c:	203fa716 	blt	r4,zero,2000d2c <__alt_mem_mem_0+0xfcfe0d2c>
 2000e90:	d8802d15 	stw	r2,180(sp)
 2000e94:	ac400007 	ldb	r17,0(r21)
 2000e98:	003f4206 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2000e9c:	ac400007 	ldb	r17,0(r21)
 2000ea0:	aac00044 	addi	r11,r21,1
 2000ea4:	8a872826 	beq	r17,r10,2002b48 <___vfprintf_internal_r+0x2128>
 2000ea8:	88bff404 	addi	r2,r17,-48
 2000eac:	0009883a 	mov	r4,zero
 2000eb0:	30867d36 	bltu	r6,r2,20028a8 <___vfprintf_internal_r+0x1e88>
 2000eb4:	5c400007 	ldb	r17,0(r11)
 2000eb8:	210002a4 	muli	r4,r4,10
 2000ebc:	5d400044 	addi	r21,r11,1
 2000ec0:	a817883a 	mov	r11,r21
 2000ec4:	2089883a 	add	r4,r4,r2
 2000ec8:	88bff404 	addi	r2,r17,-48
 2000ecc:	30bff92e 	bgeu	r6,r2,2000eb4 <__alt_mem_mem_0+0xfcfe0eb4>
 2000ed0:	2005c916 	blt	r4,zero,20025f8 <___vfprintf_internal_r+0x1bd8>
 2000ed4:	d9002915 	stw	r4,164(sp)
 2000ed8:	003f3306 	br	2000ba8 <__alt_mem_mem_0+0xfcfe0ba8>
 2000edc:	94802014 	ori	r18,r18,128
 2000ee0:	ac400007 	ldb	r17,0(r21)
 2000ee4:	003f2f06 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2000ee8:	a809883a 	mov	r4,r21
 2000eec:	d8003115 	stw	zero,196(sp)
 2000ef0:	88bff404 	addi	r2,r17,-48
 2000ef4:	0017883a 	mov	r11,zero
 2000ef8:	24400007 	ldb	r17,0(r4)
 2000efc:	5ac002a4 	muli	r11,r11,10
 2000f00:	ad400044 	addi	r21,r21,1
 2000f04:	a809883a 	mov	r4,r21
 2000f08:	12d7883a 	add	r11,r2,r11
 2000f0c:	88bff404 	addi	r2,r17,-48
 2000f10:	30bff92e 	bgeu	r6,r2,2000ef8 <__alt_mem_mem_0+0xfcfe0ef8>
 2000f14:	dac03115 	stw	r11,196(sp)
 2000f18:	003f2306 	br	2000ba8 <__alt_mem_mem_0+0xfcfe0ba8>
 2000f1c:	18c03fcc 	andi	r3,r3,255
 2000f20:	18072b1e 	bne	r3,zero,2002bd0 <___vfprintf_internal_r+0x21b0>
 2000f24:	94800414 	ori	r18,r18,16
 2000f28:	9080080c 	andi	r2,r18,32
 2000f2c:	10037b26 	beq	r2,zero,2001d1c <___vfprintf_internal_r+0x12fc>
 2000f30:	d9402d17 	ldw	r5,180(sp)
 2000f34:	28800117 	ldw	r2,4(r5)
 2000f38:	2cc00017 	ldw	r19,0(r5)
 2000f3c:	29400204 	addi	r5,r5,8
 2000f40:	d9402d15 	stw	r5,180(sp)
 2000f44:	102d883a 	mov	r22,r2
 2000f48:	10044b16 	blt	r2,zero,2002078 <___vfprintf_internal_r+0x1658>
 2000f4c:	d9402917 	ldw	r5,164(sp)
 2000f50:	df002783 	ldbu	fp,158(sp)
 2000f54:	2803bc16 	blt	r5,zero,2001e48 <___vfprintf_internal_r+0x1428>
 2000f58:	00ffdfc4 	movi	r3,-129
 2000f5c:	9d84b03a 	or	r2,r19,r22
 2000f60:	90e4703a 	and	r18,r18,r3
 2000f64:	10017726 	beq	r2,zero,2001544 <___vfprintf_internal_r+0xb24>
 2000f68:	b0038326 	beq	r22,zero,2001d78 <___vfprintf_internal_r+0x1358>
 2000f6c:	dc402a15 	stw	r17,168(sp)
 2000f70:	dc001e04 	addi	r16,sp,120
 2000f74:	b023883a 	mov	r17,r22
 2000f78:	402d883a 	mov	r22,r8
 2000f7c:	9809883a 	mov	r4,r19
 2000f80:	880b883a 	mov	r5,r17
 2000f84:	01800284 	movi	r6,10
 2000f88:	000f883a 	mov	r7,zero
 2000f8c:	200a4ac0 	call	200a4ac <__umoddi3>
 2000f90:	10800c04 	addi	r2,r2,48
 2000f94:	843fffc4 	addi	r16,r16,-1
 2000f98:	9809883a 	mov	r4,r19
 2000f9c:	880b883a 	mov	r5,r17
 2000fa0:	80800005 	stb	r2,0(r16)
 2000fa4:	01800284 	movi	r6,10
 2000fa8:	000f883a 	mov	r7,zero
 2000fac:	2009f340 	call	2009f34 <__udivdi3>
 2000fb0:	1027883a 	mov	r19,r2
 2000fb4:	10c4b03a 	or	r2,r2,r3
 2000fb8:	1823883a 	mov	r17,r3
 2000fbc:	103fef1e 	bne	r2,zero,2000f7c <__alt_mem_mem_0+0xfcfe0f7c>
 2000fc0:	d8c02817 	ldw	r3,160(sp)
 2000fc4:	dc402a17 	ldw	r17,168(sp)
 2000fc8:	b011883a 	mov	r8,r22
 2000fcc:	1c07c83a 	sub	r3,r3,r16
 2000fd0:	d8c02e15 	stw	r3,184(sp)
 2000fd4:	00005906 	br	200113c <___vfprintf_internal_r+0x71c>
 2000fd8:	18c03fcc 	andi	r3,r3,255
 2000fdc:	1806fa1e 	bne	r3,zero,2002bc8 <___vfprintf_internal_r+0x21a8>
 2000fe0:	9080020c 	andi	r2,r18,8
 2000fe4:	10048a26 	beq	r2,zero,2002210 <___vfprintf_internal_r+0x17f0>
 2000fe8:	d8c02d17 	ldw	r3,180(sp)
 2000fec:	d9002d17 	ldw	r4,180(sp)
 2000ff0:	d9402d17 	ldw	r5,180(sp)
 2000ff4:	18c00017 	ldw	r3,0(r3)
 2000ff8:	21000117 	ldw	r4,4(r4)
 2000ffc:	29400204 	addi	r5,r5,8
 2001000:	d8c03615 	stw	r3,216(sp)
 2001004:	d9003815 	stw	r4,224(sp)
 2001008:	d9402d15 	stw	r5,180(sp)
 200100c:	d9003617 	ldw	r4,216(sp)
 2001010:	d9403817 	ldw	r5,224(sp)
 2001014:	da003d15 	stw	r8,244(sp)
 2001018:	04000044 	movi	r16,1
 200101c:	20070c40 	call	20070c4 <__fpclassifyd>
 2001020:	da003d17 	ldw	r8,244(sp)
 2001024:	14041f1e 	bne	r2,r16,20020a4 <___vfprintf_internal_r+0x1684>
 2001028:	d9003617 	ldw	r4,216(sp)
 200102c:	d9403817 	ldw	r5,224(sp)
 2001030:	000d883a 	mov	r6,zero
 2001034:	000f883a 	mov	r7,zero
 2001038:	200be900 	call	200be90 <__ledf2>
 200103c:	da003d17 	ldw	r8,244(sp)
 2001040:	1005be16 	blt	r2,zero,200273c <___vfprintf_internal_r+0x1d1c>
 2001044:	df002783 	ldbu	fp,158(sp)
 2001048:	008011c4 	movi	r2,71
 200104c:	1445330e 	bge	r2,r17,200251c <___vfprintf_internal_r+0x1afc>
 2001050:	04008134 	movhi	r16,516
 2001054:	841a7d04 	addi	r16,r16,27124
 2001058:	00c000c4 	movi	r3,3
 200105c:	00bfdfc4 	movi	r2,-129
 2001060:	d8c02a15 	stw	r3,168(sp)
 2001064:	90a4703a 	and	r18,r18,r2
 2001068:	d8c02e15 	stw	r3,184(sp)
 200106c:	d8002915 	stw	zero,164(sp)
 2001070:	d8003215 	stw	zero,200(sp)
 2001074:	00003706 	br	2001154 <___vfprintf_internal_r+0x734>
 2001078:	94800214 	ori	r18,r18,8
 200107c:	ac400007 	ldb	r17,0(r21)
 2001080:	003ec806 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2001084:	18c03fcc 	andi	r3,r3,255
 2001088:	1806db1e 	bne	r3,zero,2002bf8 <___vfprintf_internal_r+0x21d8>
 200108c:	94800414 	ori	r18,r18,16
 2001090:	9080080c 	andi	r2,r18,32
 2001094:	1002d826 	beq	r2,zero,2001bf8 <___vfprintf_internal_r+0x11d8>
 2001098:	d9402d17 	ldw	r5,180(sp)
 200109c:	d8c02917 	ldw	r3,164(sp)
 20010a0:	d8002785 	stb	zero,158(sp)
 20010a4:	28800204 	addi	r2,r5,8
 20010a8:	2cc00017 	ldw	r19,0(r5)
 20010ac:	2d800117 	ldw	r22,4(r5)
 20010b0:	18048f16 	blt	r3,zero,20022f0 <___vfprintf_internal_r+0x18d0>
 20010b4:	013fdfc4 	movi	r4,-129
 20010b8:	9d86b03a 	or	r3,r19,r22
 20010bc:	d8802d15 	stw	r2,180(sp)
 20010c0:	9124703a 	and	r18,r18,r4
 20010c4:	1802d91e 	bne	r3,zero,2001c2c <___vfprintf_internal_r+0x120c>
 20010c8:	d8c02917 	ldw	r3,164(sp)
 20010cc:	0039883a 	mov	fp,zero
 20010d0:	1805c326 	beq	r3,zero,20027e0 <___vfprintf_internal_r+0x1dc0>
 20010d4:	0027883a 	mov	r19,zero
 20010d8:	002d883a 	mov	r22,zero
 20010dc:	dc001e04 	addi	r16,sp,120
 20010e0:	9806d0fa 	srli	r3,r19,3
 20010e4:	b008977a 	slli	r4,r22,29
 20010e8:	b02cd0fa 	srli	r22,r22,3
 20010ec:	9cc001cc 	andi	r19,r19,7
 20010f0:	98800c04 	addi	r2,r19,48
 20010f4:	843fffc4 	addi	r16,r16,-1
 20010f8:	20e6b03a 	or	r19,r4,r3
 20010fc:	80800005 	stb	r2,0(r16)
 2001100:	9d86b03a 	or	r3,r19,r22
 2001104:	183ff61e 	bne	r3,zero,20010e0 <__alt_mem_mem_0+0xfcfe10e0>
 2001108:	90c0004c 	andi	r3,r18,1
 200110c:	18013b26 	beq	r3,zero,20015fc <___vfprintf_internal_r+0xbdc>
 2001110:	10803fcc 	andi	r2,r2,255
 2001114:	1080201c 	xori	r2,r2,128
 2001118:	10bfe004 	addi	r2,r2,-128
 200111c:	00c00c04 	movi	r3,48
 2001120:	10c13626 	beq	r2,r3,20015fc <___vfprintf_internal_r+0xbdc>
 2001124:	80ffffc5 	stb	r3,-1(r16)
 2001128:	d8c02817 	ldw	r3,160(sp)
 200112c:	80bfffc4 	addi	r2,r16,-1
 2001130:	1021883a 	mov	r16,r2
 2001134:	1887c83a 	sub	r3,r3,r2
 2001138:	d8c02e15 	stw	r3,184(sp)
 200113c:	d8802e17 	ldw	r2,184(sp)
 2001140:	d9002917 	ldw	r4,164(sp)
 2001144:	1100010e 	bge	r2,r4,200114c <___vfprintf_internal_r+0x72c>
 2001148:	2005883a 	mov	r2,r4
 200114c:	d8802a15 	stw	r2,168(sp)
 2001150:	d8003215 	stw	zero,200(sp)
 2001154:	e7003fcc 	andi	fp,fp,255
 2001158:	e700201c 	xori	fp,fp,128
 200115c:	e73fe004 	addi	fp,fp,-128
 2001160:	e0000326 	beq	fp,zero,2001170 <___vfprintf_internal_r+0x750>
 2001164:	d8c02a17 	ldw	r3,168(sp)
 2001168:	18c00044 	addi	r3,r3,1
 200116c:	d8c02a15 	stw	r3,168(sp)
 2001170:	90c0008c 	andi	r3,r18,2
 2001174:	d8c02b15 	stw	r3,172(sp)
 2001178:	18000326 	beq	r3,zero,2001188 <___vfprintf_internal_r+0x768>
 200117c:	d8c02a17 	ldw	r3,168(sp)
 2001180:	18c00084 	addi	r3,r3,2
 2001184:	d8c02a15 	stw	r3,168(sp)
 2001188:	90c0210c 	andi	r3,r18,132
 200118c:	d8c03015 	stw	r3,192(sp)
 2001190:	1801a31e 	bne	r3,zero,2001820 <___vfprintf_internal_r+0xe00>
 2001194:	d9003117 	ldw	r4,196(sp)
 2001198:	d8c02a17 	ldw	r3,168(sp)
 200119c:	20e7c83a 	sub	r19,r4,r3
 20011a0:	04c19f0e 	bge	zero,r19,2001820 <___vfprintf_internal_r+0xe00>
 20011a4:	02400404 	movi	r9,16
 20011a8:	d8c02017 	ldw	r3,128(sp)
 20011ac:	d8801f17 	ldw	r2,124(sp)
 20011b0:	4cc50d0e 	bge	r9,r19,20025e8 <___vfprintf_internal_r+0x1bc8>
 20011b4:	01408134 	movhi	r5,516
 20011b8:	295a9084 	addi	r5,r5,27202
 20011bc:	dc403b15 	stw	r17,236(sp)
 20011c0:	d9403515 	stw	r5,212(sp)
 20011c4:	9823883a 	mov	r17,r19
 20011c8:	482d883a 	mov	r22,r9
 20011cc:	9027883a 	mov	r19,r18
 20011d0:	070001c4 	movi	fp,7
 20011d4:	8025883a 	mov	r18,r16
 20011d8:	dc002c17 	ldw	r16,176(sp)
 20011dc:	00000306 	br	20011ec <___vfprintf_internal_r+0x7cc>
 20011e0:	8c7ffc04 	addi	r17,r17,-16
 20011e4:	42000204 	addi	r8,r8,8
 20011e8:	b440130e 	bge	r22,r17,2001238 <___vfprintf_internal_r+0x818>
 20011ec:	01008134 	movhi	r4,516
 20011f0:	18c00404 	addi	r3,r3,16
 20011f4:	10800044 	addi	r2,r2,1
 20011f8:	211a9084 	addi	r4,r4,27202
 20011fc:	41000015 	stw	r4,0(r8)
 2001200:	45800115 	stw	r22,4(r8)
 2001204:	d8c02015 	stw	r3,128(sp)
 2001208:	d8801f15 	stw	r2,124(sp)
 200120c:	e0bff40e 	bge	fp,r2,20011e0 <__alt_mem_mem_0+0xfcfe11e0>
 2001210:	d9801e04 	addi	r6,sp,120
 2001214:	b80b883a 	mov	r5,r23
 2001218:	8009883a 	mov	r4,r16
 200121c:	20075380 	call	2007538 <__sprint_r>
 2001220:	103f011e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001224:	8c7ffc04 	addi	r17,r17,-16
 2001228:	d8c02017 	ldw	r3,128(sp)
 200122c:	d8801f17 	ldw	r2,124(sp)
 2001230:	da000404 	addi	r8,sp,16
 2001234:	b47fed16 	blt	r22,r17,20011ec <__alt_mem_mem_0+0xfcfe11ec>
 2001238:	9021883a 	mov	r16,r18
 200123c:	9825883a 	mov	r18,r19
 2001240:	8827883a 	mov	r19,r17
 2001244:	dc403b17 	ldw	r17,236(sp)
 2001248:	d9403517 	ldw	r5,212(sp)
 200124c:	98c7883a 	add	r3,r19,r3
 2001250:	10800044 	addi	r2,r2,1
 2001254:	41400015 	stw	r5,0(r8)
 2001258:	44c00115 	stw	r19,4(r8)
 200125c:	d8c02015 	stw	r3,128(sp)
 2001260:	d8801f15 	stw	r2,124(sp)
 2001264:	010001c4 	movi	r4,7
 2001268:	2082a316 	blt	r4,r2,2001cf8 <___vfprintf_internal_r+0x12d8>
 200126c:	df002787 	ldb	fp,158(sp)
 2001270:	42000204 	addi	r8,r8,8
 2001274:	e0000c26 	beq	fp,zero,20012a8 <___vfprintf_internal_r+0x888>
 2001278:	d8801f17 	ldw	r2,124(sp)
 200127c:	d9002784 	addi	r4,sp,158
 2001280:	18c00044 	addi	r3,r3,1
 2001284:	10800044 	addi	r2,r2,1
 2001288:	41000015 	stw	r4,0(r8)
 200128c:	01000044 	movi	r4,1
 2001290:	41000115 	stw	r4,4(r8)
 2001294:	d8c02015 	stw	r3,128(sp)
 2001298:	d8801f15 	stw	r2,124(sp)
 200129c:	010001c4 	movi	r4,7
 20012a0:	20823c16 	blt	r4,r2,2001b94 <___vfprintf_internal_r+0x1174>
 20012a4:	42000204 	addi	r8,r8,8
 20012a8:	d8802b17 	ldw	r2,172(sp)
 20012ac:	10000c26 	beq	r2,zero,20012e0 <___vfprintf_internal_r+0x8c0>
 20012b0:	d8801f17 	ldw	r2,124(sp)
 20012b4:	d9002704 	addi	r4,sp,156
 20012b8:	18c00084 	addi	r3,r3,2
 20012bc:	10800044 	addi	r2,r2,1
 20012c0:	41000015 	stw	r4,0(r8)
 20012c4:	01000084 	movi	r4,2
 20012c8:	41000115 	stw	r4,4(r8)
 20012cc:	d8c02015 	stw	r3,128(sp)
 20012d0:	d8801f15 	stw	r2,124(sp)
 20012d4:	010001c4 	movi	r4,7
 20012d8:	20823616 	blt	r4,r2,2001bb4 <___vfprintf_internal_r+0x1194>
 20012dc:	42000204 	addi	r8,r8,8
 20012e0:	d9003017 	ldw	r4,192(sp)
 20012e4:	00802004 	movi	r2,128
 20012e8:	20819926 	beq	r4,r2,2001950 <___vfprintf_internal_r+0xf30>
 20012ec:	d9402917 	ldw	r5,164(sp)
 20012f0:	d8802e17 	ldw	r2,184(sp)
 20012f4:	28adc83a 	sub	r22,r5,r2
 20012f8:	0580310e 	bge	zero,r22,20013c0 <___vfprintf_internal_r+0x9a0>
 20012fc:	07000404 	movi	fp,16
 2001300:	d8801f17 	ldw	r2,124(sp)
 2001304:	e584140e 	bge	fp,r22,2002358 <___vfprintf_internal_r+0x1938>
 2001308:	01408134 	movhi	r5,516
 200130c:	295a8c84 	addi	r5,r5,27186
 2001310:	dc402915 	stw	r17,164(sp)
 2001314:	d9402b15 	stw	r5,172(sp)
 2001318:	b023883a 	mov	r17,r22
 200131c:	04c001c4 	movi	r19,7
 2001320:	a82d883a 	mov	r22,r21
 2001324:	902b883a 	mov	r21,r18
 2001328:	8025883a 	mov	r18,r16
 200132c:	dc002c17 	ldw	r16,176(sp)
 2001330:	00000306 	br	2001340 <___vfprintf_internal_r+0x920>
 2001334:	8c7ffc04 	addi	r17,r17,-16
 2001338:	42000204 	addi	r8,r8,8
 200133c:	e440110e 	bge	fp,r17,2001384 <___vfprintf_internal_r+0x964>
 2001340:	18c00404 	addi	r3,r3,16
 2001344:	10800044 	addi	r2,r2,1
 2001348:	45000015 	stw	r20,0(r8)
 200134c:	47000115 	stw	fp,4(r8)
 2001350:	d8c02015 	stw	r3,128(sp)
 2001354:	d8801f15 	stw	r2,124(sp)
 2001358:	98bff60e 	bge	r19,r2,2001334 <__alt_mem_mem_0+0xfcfe1334>
 200135c:	d9801e04 	addi	r6,sp,120
 2001360:	b80b883a 	mov	r5,r23
 2001364:	8009883a 	mov	r4,r16
 2001368:	20075380 	call	2007538 <__sprint_r>
 200136c:	103eae1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001370:	8c7ffc04 	addi	r17,r17,-16
 2001374:	d8c02017 	ldw	r3,128(sp)
 2001378:	d8801f17 	ldw	r2,124(sp)
 200137c:	da000404 	addi	r8,sp,16
 2001380:	e47fef16 	blt	fp,r17,2001340 <__alt_mem_mem_0+0xfcfe1340>
 2001384:	9021883a 	mov	r16,r18
 2001388:	a825883a 	mov	r18,r21
 200138c:	b02b883a 	mov	r21,r22
 2001390:	882d883a 	mov	r22,r17
 2001394:	dc402917 	ldw	r17,164(sp)
 2001398:	d9002b17 	ldw	r4,172(sp)
 200139c:	1d87883a 	add	r3,r3,r22
 20013a0:	10800044 	addi	r2,r2,1
 20013a4:	41000015 	stw	r4,0(r8)
 20013a8:	45800115 	stw	r22,4(r8)
 20013ac:	d8c02015 	stw	r3,128(sp)
 20013b0:	d8801f15 	stw	r2,124(sp)
 20013b4:	010001c4 	movi	r4,7
 20013b8:	2081ee16 	blt	r4,r2,2001b74 <___vfprintf_internal_r+0x1154>
 20013bc:	42000204 	addi	r8,r8,8
 20013c0:	9080400c 	andi	r2,r18,256
 20013c4:	1001181e 	bne	r2,zero,2001828 <___vfprintf_internal_r+0xe08>
 20013c8:	d9402e17 	ldw	r5,184(sp)
 20013cc:	d8801f17 	ldw	r2,124(sp)
 20013d0:	44000015 	stw	r16,0(r8)
 20013d4:	1947883a 	add	r3,r3,r5
 20013d8:	10800044 	addi	r2,r2,1
 20013dc:	41400115 	stw	r5,4(r8)
 20013e0:	d8c02015 	stw	r3,128(sp)
 20013e4:	d8801f15 	stw	r2,124(sp)
 20013e8:	010001c4 	movi	r4,7
 20013ec:	2081d316 	blt	r4,r2,2001b3c <___vfprintf_internal_r+0x111c>
 20013f0:	42000204 	addi	r8,r8,8
 20013f4:	9480010c 	andi	r18,r18,4
 20013f8:	90003226 	beq	r18,zero,20014c4 <___vfprintf_internal_r+0xaa4>
 20013fc:	d9403117 	ldw	r5,196(sp)
 2001400:	d8802a17 	ldw	r2,168(sp)
 2001404:	28a1c83a 	sub	r16,r5,r2
 2001408:	04002e0e 	bge	zero,r16,20014c4 <___vfprintf_internal_r+0xaa4>
 200140c:	04400404 	movi	r17,16
 2001410:	d8801f17 	ldw	r2,124(sp)
 2001414:	8c04a20e 	bge	r17,r16,20026a0 <___vfprintf_internal_r+0x1c80>
 2001418:	01408134 	movhi	r5,516
 200141c:	295a9084 	addi	r5,r5,27202
 2001420:	d9403515 	stw	r5,212(sp)
 2001424:	048001c4 	movi	r18,7
 2001428:	dcc02c17 	ldw	r19,176(sp)
 200142c:	00000306 	br	200143c <___vfprintf_internal_r+0xa1c>
 2001430:	843ffc04 	addi	r16,r16,-16
 2001434:	42000204 	addi	r8,r8,8
 2001438:	8c00130e 	bge	r17,r16,2001488 <___vfprintf_internal_r+0xa68>
 200143c:	01008134 	movhi	r4,516
 2001440:	18c00404 	addi	r3,r3,16
 2001444:	10800044 	addi	r2,r2,1
 2001448:	211a9084 	addi	r4,r4,27202
 200144c:	41000015 	stw	r4,0(r8)
 2001450:	44400115 	stw	r17,4(r8)
 2001454:	d8c02015 	stw	r3,128(sp)
 2001458:	d8801f15 	stw	r2,124(sp)
 200145c:	90bff40e 	bge	r18,r2,2001430 <__alt_mem_mem_0+0xfcfe1430>
 2001460:	d9801e04 	addi	r6,sp,120
 2001464:	b80b883a 	mov	r5,r23
 2001468:	9809883a 	mov	r4,r19
 200146c:	20075380 	call	2007538 <__sprint_r>
 2001470:	103e6d1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001474:	843ffc04 	addi	r16,r16,-16
 2001478:	d8c02017 	ldw	r3,128(sp)
 200147c:	d8801f17 	ldw	r2,124(sp)
 2001480:	da000404 	addi	r8,sp,16
 2001484:	8c3fed16 	blt	r17,r16,200143c <__alt_mem_mem_0+0xfcfe143c>
 2001488:	d9403517 	ldw	r5,212(sp)
 200148c:	1c07883a 	add	r3,r3,r16
 2001490:	10800044 	addi	r2,r2,1
 2001494:	41400015 	stw	r5,0(r8)
 2001498:	44000115 	stw	r16,4(r8)
 200149c:	d8c02015 	stw	r3,128(sp)
 20014a0:	d8801f15 	stw	r2,124(sp)
 20014a4:	010001c4 	movi	r4,7
 20014a8:	2080060e 	bge	r4,r2,20014c4 <___vfprintf_internal_r+0xaa4>
 20014ac:	d9002c17 	ldw	r4,176(sp)
 20014b0:	d9801e04 	addi	r6,sp,120
 20014b4:	b80b883a 	mov	r5,r23
 20014b8:	20075380 	call	2007538 <__sprint_r>
 20014bc:	103e5a1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 20014c0:	d8c02017 	ldw	r3,128(sp)
 20014c4:	d8803117 	ldw	r2,196(sp)
 20014c8:	d9002a17 	ldw	r4,168(sp)
 20014cc:	1100010e 	bge	r2,r4,20014d4 <___vfprintf_internal_r+0xab4>
 20014d0:	2005883a 	mov	r2,r4
 20014d4:	d9402f17 	ldw	r5,188(sp)
 20014d8:	288b883a 	add	r5,r5,r2
 20014dc:	d9402f15 	stw	r5,188(sp)
 20014e0:	18019e1e 	bne	r3,zero,2001b5c <___vfprintf_internal_r+0x113c>
 20014e4:	a8800007 	ldb	r2,0(r21)
 20014e8:	d8001f15 	stw	zero,124(sp)
 20014ec:	da000404 	addi	r8,sp,16
 20014f0:	103d851e 	bne	r2,zero,2000b08 <__alt_mem_mem_0+0xfcfe0b08>
 20014f4:	a821883a 	mov	r16,r21
 20014f8:	003d9b06 	br	2000b68 <__alt_mem_mem_0+0xfcfe0b68>
 20014fc:	18c03fcc 	andi	r3,r3,255
 2001500:	1805c11e 	bne	r3,zero,2002c08 <___vfprintf_internal_r+0x21e8>
 2001504:	94800414 	ori	r18,r18,16
 2001508:	9080080c 	andi	r2,r18,32
 200150c:	10020c26 	beq	r2,zero,2001d40 <___vfprintf_internal_r+0x1320>
 2001510:	d8802d17 	ldw	r2,180(sp)
 2001514:	d9002917 	ldw	r4,164(sp)
 2001518:	d8002785 	stb	zero,158(sp)
 200151c:	10c00204 	addi	r3,r2,8
 2001520:	14c00017 	ldw	r19,0(r2)
 2001524:	15800117 	ldw	r22,4(r2)
 2001528:	20040f16 	blt	r4,zero,2002568 <___vfprintf_internal_r+0x1b48>
 200152c:	013fdfc4 	movi	r4,-129
 2001530:	9d84b03a 	or	r2,r19,r22
 2001534:	d8c02d15 	stw	r3,180(sp)
 2001538:	9124703a 	and	r18,r18,r4
 200153c:	0039883a 	mov	fp,zero
 2001540:	103e891e 	bne	r2,zero,2000f68 <__alt_mem_mem_0+0xfcfe0f68>
 2001544:	d9002917 	ldw	r4,164(sp)
 2001548:	2002c11e 	bne	r4,zero,2002050 <___vfprintf_internal_r+0x1630>
 200154c:	d8002915 	stw	zero,164(sp)
 2001550:	d8002e15 	stw	zero,184(sp)
 2001554:	dc001e04 	addi	r16,sp,120
 2001558:	003ef806 	br	200113c <__alt_mem_mem_0+0xfcfe113c>
 200155c:	18c03fcc 	andi	r3,r3,255
 2001560:	18059d1e 	bne	r3,zero,2002bd8 <___vfprintf_internal_r+0x21b8>
 2001564:	01408134 	movhi	r5,516
 2001568:	295a8004 	addi	r5,r5,27136
 200156c:	d9403915 	stw	r5,228(sp)
 2001570:	9080080c 	andi	r2,r18,32
 2001574:	10005226 	beq	r2,zero,20016c0 <___vfprintf_internal_r+0xca0>
 2001578:	d8802d17 	ldw	r2,180(sp)
 200157c:	14c00017 	ldw	r19,0(r2)
 2001580:	15800117 	ldw	r22,4(r2)
 2001584:	10800204 	addi	r2,r2,8
 2001588:	d8802d15 	stw	r2,180(sp)
 200158c:	9080004c 	andi	r2,r18,1
 2001590:	10019026 	beq	r2,zero,2001bd4 <___vfprintf_internal_r+0x11b4>
 2001594:	9d84b03a 	or	r2,r19,r22
 2001598:	10036926 	beq	r2,zero,2002340 <___vfprintf_internal_r+0x1920>
 200159c:	d8c02917 	ldw	r3,164(sp)
 20015a0:	00800c04 	movi	r2,48
 20015a4:	d8802705 	stb	r2,156(sp)
 20015a8:	dc402745 	stb	r17,157(sp)
 20015ac:	d8002785 	stb	zero,158(sp)
 20015b0:	90800094 	ori	r2,r18,2
 20015b4:	18045d16 	blt	r3,zero,200272c <___vfprintf_internal_r+0x1d0c>
 20015b8:	00bfdfc4 	movi	r2,-129
 20015bc:	90a4703a 	and	r18,r18,r2
 20015c0:	94800094 	ori	r18,r18,2
 20015c4:	0039883a 	mov	fp,zero
 20015c8:	d9003917 	ldw	r4,228(sp)
 20015cc:	dc001e04 	addi	r16,sp,120
 20015d0:	988003cc 	andi	r2,r19,15
 20015d4:	b006973a 	slli	r3,r22,28
 20015d8:	2085883a 	add	r2,r4,r2
 20015dc:	9826d13a 	srli	r19,r19,4
 20015e0:	10800003 	ldbu	r2,0(r2)
 20015e4:	b02cd13a 	srli	r22,r22,4
 20015e8:	843fffc4 	addi	r16,r16,-1
 20015ec:	1ce6b03a 	or	r19,r3,r19
 20015f0:	80800005 	stb	r2,0(r16)
 20015f4:	9d84b03a 	or	r2,r19,r22
 20015f8:	103ff51e 	bne	r2,zero,20015d0 <__alt_mem_mem_0+0xfcfe15d0>
 20015fc:	d8c02817 	ldw	r3,160(sp)
 2001600:	1c07c83a 	sub	r3,r3,r16
 2001604:	d8c02e15 	stw	r3,184(sp)
 2001608:	003ecc06 	br	200113c <__alt_mem_mem_0+0xfcfe113c>
 200160c:	18c03fcc 	andi	r3,r3,255
 2001610:	183e9f26 	beq	r3,zero,2001090 <__alt_mem_mem_0+0xfcfe1090>
 2001614:	d9c02785 	stb	r7,158(sp)
 2001618:	003e9d06 	br	2001090 <__alt_mem_mem_0+0xfcfe1090>
 200161c:	00c00044 	movi	r3,1
 2001620:	01c00ac4 	movi	r7,43
 2001624:	ac400007 	ldb	r17,0(r21)
 2001628:	003d5e06 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 200162c:	94800814 	ori	r18,r18,32
 2001630:	ac400007 	ldb	r17,0(r21)
 2001634:	003d5b06 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2001638:	d8c02d17 	ldw	r3,180(sp)
 200163c:	d8002785 	stb	zero,158(sp)
 2001640:	1c000017 	ldw	r16,0(r3)
 2001644:	1cc00104 	addi	r19,r3,4
 2001648:	80041926 	beq	r16,zero,20026b0 <___vfprintf_internal_r+0x1c90>
 200164c:	d9002917 	ldw	r4,164(sp)
 2001650:	2003d016 	blt	r4,zero,2002594 <___vfprintf_internal_r+0x1b74>
 2001654:	200d883a 	mov	r6,r4
 2001658:	000b883a 	mov	r5,zero
 200165c:	8009883a 	mov	r4,r16
 2001660:	da003d15 	stw	r8,244(sp)
 2001664:	2005d740 	call	2005d74 <memchr>
 2001668:	da003d17 	ldw	r8,244(sp)
 200166c:	10045426 	beq	r2,zero,20027c0 <___vfprintf_internal_r+0x1da0>
 2001670:	1405c83a 	sub	r2,r2,r16
 2001674:	d8802e15 	stw	r2,184(sp)
 2001678:	1003cc16 	blt	r2,zero,20025ac <___vfprintf_internal_r+0x1b8c>
 200167c:	df002783 	ldbu	fp,158(sp)
 2001680:	d8802a15 	stw	r2,168(sp)
 2001684:	dcc02d15 	stw	r19,180(sp)
 2001688:	d8002915 	stw	zero,164(sp)
 200168c:	d8003215 	stw	zero,200(sp)
 2001690:	003eb006 	br	2001154 <__alt_mem_mem_0+0xfcfe1154>
 2001694:	18c03fcc 	andi	r3,r3,255
 2001698:	183f9b26 	beq	r3,zero,2001508 <__alt_mem_mem_0+0xfcfe1508>
 200169c:	d9c02785 	stb	r7,158(sp)
 20016a0:	003f9906 	br	2001508 <__alt_mem_mem_0+0xfcfe1508>
 20016a4:	18c03fcc 	andi	r3,r3,255
 20016a8:	1805551e 	bne	r3,zero,2002c00 <___vfprintf_internal_r+0x21e0>
 20016ac:	01408134 	movhi	r5,516
 20016b0:	295a8504 	addi	r5,r5,27156
 20016b4:	d9403915 	stw	r5,228(sp)
 20016b8:	9080080c 	andi	r2,r18,32
 20016bc:	103fae1e 	bne	r2,zero,2001578 <__alt_mem_mem_0+0xfcfe1578>
 20016c0:	9080040c 	andi	r2,r18,16
 20016c4:	1002de26 	beq	r2,zero,2002240 <___vfprintf_internal_r+0x1820>
 20016c8:	d8c02d17 	ldw	r3,180(sp)
 20016cc:	002d883a 	mov	r22,zero
 20016d0:	1cc00017 	ldw	r19,0(r3)
 20016d4:	18c00104 	addi	r3,r3,4
 20016d8:	d8c02d15 	stw	r3,180(sp)
 20016dc:	003fab06 	br	200158c <__alt_mem_mem_0+0xfcfe158c>
 20016e0:	38803fcc 	andi	r2,r7,255
 20016e4:	1080201c 	xori	r2,r2,128
 20016e8:	10bfe004 	addi	r2,r2,-128
 20016ec:	1002d21e 	bne	r2,zero,2002238 <___vfprintf_internal_r+0x1818>
 20016f0:	00c00044 	movi	r3,1
 20016f4:	01c00804 	movi	r7,32
 20016f8:	ac400007 	ldb	r17,0(r21)
 20016fc:	003d2906 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2001700:	94800054 	ori	r18,r18,1
 2001704:	ac400007 	ldb	r17,0(r21)
 2001708:	003d2606 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 200170c:	18c03fcc 	andi	r3,r3,255
 2001710:	183e0526 	beq	r3,zero,2000f28 <__alt_mem_mem_0+0xfcfe0f28>
 2001714:	d9c02785 	stb	r7,158(sp)
 2001718:	003e0306 	br	2000f28 <__alt_mem_mem_0+0xfcfe0f28>
 200171c:	94801014 	ori	r18,r18,64
 2001720:	ac400007 	ldb	r17,0(r21)
 2001724:	003d1f06 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2001728:	ac400007 	ldb	r17,0(r21)
 200172c:	8a438726 	beq	r17,r9,200254c <___vfprintf_internal_r+0x1b2c>
 2001730:	94800414 	ori	r18,r18,16
 2001734:	003d1b06 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2001738:	18c03fcc 	andi	r3,r3,255
 200173c:	1805341e 	bne	r3,zero,2002c10 <___vfprintf_internal_r+0x21f0>
 2001740:	9080080c 	andi	r2,r18,32
 2001744:	1002cd26 	beq	r2,zero,200227c <___vfprintf_internal_r+0x185c>
 2001748:	d9402d17 	ldw	r5,180(sp)
 200174c:	d9002f17 	ldw	r4,188(sp)
 2001750:	28800017 	ldw	r2,0(r5)
 2001754:	2007d7fa 	srai	r3,r4,31
 2001758:	29400104 	addi	r5,r5,4
 200175c:	d9402d15 	stw	r5,180(sp)
 2001760:	11000015 	stw	r4,0(r2)
 2001764:	10c00115 	stw	r3,4(r2)
 2001768:	003ce506 	br	2000b00 <__alt_mem_mem_0+0xfcfe0b00>
 200176c:	d8c02d17 	ldw	r3,180(sp)
 2001770:	d9002d17 	ldw	r4,180(sp)
 2001774:	d8002785 	stb	zero,158(sp)
 2001778:	18800017 	ldw	r2,0(r3)
 200177c:	21000104 	addi	r4,r4,4
 2001780:	00c00044 	movi	r3,1
 2001784:	d8c02a15 	stw	r3,168(sp)
 2001788:	d8801405 	stb	r2,80(sp)
 200178c:	d9002d15 	stw	r4,180(sp)
 2001790:	d8c02e15 	stw	r3,184(sp)
 2001794:	d8002915 	stw	zero,164(sp)
 2001798:	d8003215 	stw	zero,200(sp)
 200179c:	dc001404 	addi	r16,sp,80
 20017a0:	0039883a 	mov	fp,zero
 20017a4:	003e7206 	br	2001170 <__alt_mem_mem_0+0xfcfe1170>
 20017a8:	01008134 	movhi	r4,516
 20017ac:	211a8504 	addi	r4,r4,27156
 20017b0:	0039883a 	mov	fp,zero
 20017b4:	d9003915 	stw	r4,228(sp)
 20017b8:	04401e04 	movi	r17,120
 20017bc:	003f8206 	br	20015c8 <__alt_mem_mem_0+0xfcfe15c8>
 20017c0:	18c03fcc 	andi	r3,r3,255
 20017c4:	1805061e 	bne	r3,zero,2002be0 <___vfprintf_internal_r+0x21c0>
 20017c8:	883d9126 	beq	r17,zero,2000e10 <__alt_mem_mem_0+0xfcfe0e10>
 20017cc:	00c00044 	movi	r3,1
 20017d0:	d8c02a15 	stw	r3,168(sp)
 20017d4:	dc401405 	stb	r17,80(sp)
 20017d8:	d8002785 	stb	zero,158(sp)
 20017dc:	003fec06 	br	2001790 <__alt_mem_mem_0+0xfcfe1790>
 20017e0:	01408134 	movhi	r5,516
 20017e4:	295a8504 	addi	r5,r5,27156
 20017e8:	d9403915 	stw	r5,228(sp)
 20017ec:	d8c02d15 	stw	r3,180(sp)
 20017f0:	1025883a 	mov	r18,r2
 20017f4:	04401e04 	movi	r17,120
 20017f8:	9d84b03a 	or	r2,r19,r22
 20017fc:	1000fc1e 	bne	r2,zero,2001bf0 <___vfprintf_internal_r+0x11d0>
 2001800:	0039883a 	mov	fp,zero
 2001804:	00800084 	movi	r2,2
 2001808:	10803fcc 	andi	r2,r2,255
 200180c:	00c00044 	movi	r3,1
 2001810:	10c20f26 	beq	r2,r3,2002050 <___vfprintf_internal_r+0x1630>
 2001814:	00c00084 	movi	r3,2
 2001818:	10fd6326 	beq	r2,r3,2000da8 <__alt_mem_mem_0+0xfcfe0da8>
 200181c:	003e2d06 	br	20010d4 <__alt_mem_mem_0+0xfcfe10d4>
 2001820:	d8c02017 	ldw	r3,128(sp)
 2001824:	003e9306 	br	2001274 <__alt_mem_mem_0+0xfcfe1274>
 2001828:	00801944 	movi	r2,101
 200182c:	14407e0e 	bge	r2,r17,2001a28 <___vfprintf_internal_r+0x1008>
 2001830:	d9003617 	ldw	r4,216(sp)
 2001834:	d9403817 	ldw	r5,224(sp)
 2001838:	000d883a 	mov	r6,zero
 200183c:	000f883a 	mov	r7,zero
 2001840:	d8c03c15 	stw	r3,240(sp)
 2001844:	da003d15 	stw	r8,244(sp)
 2001848:	200bd2c0 	call	200bd2c <__eqdf2>
 200184c:	d8c03c17 	ldw	r3,240(sp)
 2001850:	da003d17 	ldw	r8,244(sp)
 2001854:	1000f71e 	bne	r2,zero,2001c34 <___vfprintf_internal_r+0x1214>
 2001858:	d8801f17 	ldw	r2,124(sp)
 200185c:	01008134 	movhi	r4,516
 2001860:	211a8c04 	addi	r4,r4,27184
 2001864:	18c00044 	addi	r3,r3,1
 2001868:	10800044 	addi	r2,r2,1
 200186c:	41000015 	stw	r4,0(r8)
 2001870:	01000044 	movi	r4,1
 2001874:	41000115 	stw	r4,4(r8)
 2001878:	d8c02015 	stw	r3,128(sp)
 200187c:	d8801f15 	stw	r2,124(sp)
 2001880:	010001c4 	movi	r4,7
 2001884:	2082b816 	blt	r4,r2,2002368 <___vfprintf_internal_r+0x1948>
 2001888:	42000204 	addi	r8,r8,8
 200188c:	d8802617 	ldw	r2,152(sp)
 2001890:	d9403317 	ldw	r5,204(sp)
 2001894:	11400216 	blt	r2,r5,20018a0 <___vfprintf_internal_r+0xe80>
 2001898:	9080004c 	andi	r2,r18,1
 200189c:	103ed526 	beq	r2,zero,20013f4 <__alt_mem_mem_0+0xfcfe13f4>
 20018a0:	d8803717 	ldw	r2,220(sp)
 20018a4:	d9003417 	ldw	r4,208(sp)
 20018a8:	d9403717 	ldw	r5,220(sp)
 20018ac:	1887883a 	add	r3,r3,r2
 20018b0:	d8801f17 	ldw	r2,124(sp)
 20018b4:	41000015 	stw	r4,0(r8)
 20018b8:	41400115 	stw	r5,4(r8)
 20018bc:	10800044 	addi	r2,r2,1
 20018c0:	d8c02015 	stw	r3,128(sp)
 20018c4:	d8801f15 	stw	r2,124(sp)
 20018c8:	010001c4 	movi	r4,7
 20018cc:	20832916 	blt	r4,r2,2002574 <___vfprintf_internal_r+0x1b54>
 20018d0:	42000204 	addi	r8,r8,8
 20018d4:	d8803317 	ldw	r2,204(sp)
 20018d8:	143fffc4 	addi	r16,r2,-1
 20018dc:	043ec50e 	bge	zero,r16,20013f4 <__alt_mem_mem_0+0xfcfe13f4>
 20018e0:	04400404 	movi	r17,16
 20018e4:	d8801f17 	ldw	r2,124(sp)
 20018e8:	8c00880e 	bge	r17,r16,2001b0c <___vfprintf_internal_r+0x10ec>
 20018ec:	01408134 	movhi	r5,516
 20018f0:	295a8c84 	addi	r5,r5,27186
 20018f4:	d9402b15 	stw	r5,172(sp)
 20018f8:	058001c4 	movi	r22,7
 20018fc:	dcc02c17 	ldw	r19,176(sp)
 2001900:	00000306 	br	2001910 <___vfprintf_internal_r+0xef0>
 2001904:	42000204 	addi	r8,r8,8
 2001908:	843ffc04 	addi	r16,r16,-16
 200190c:	8c00820e 	bge	r17,r16,2001b18 <___vfprintf_internal_r+0x10f8>
 2001910:	18c00404 	addi	r3,r3,16
 2001914:	10800044 	addi	r2,r2,1
 2001918:	45000015 	stw	r20,0(r8)
 200191c:	44400115 	stw	r17,4(r8)
 2001920:	d8c02015 	stw	r3,128(sp)
 2001924:	d8801f15 	stw	r2,124(sp)
 2001928:	b0bff60e 	bge	r22,r2,2001904 <__alt_mem_mem_0+0xfcfe1904>
 200192c:	d9801e04 	addi	r6,sp,120
 2001930:	b80b883a 	mov	r5,r23
 2001934:	9809883a 	mov	r4,r19
 2001938:	20075380 	call	2007538 <__sprint_r>
 200193c:	103d3a1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001940:	d8c02017 	ldw	r3,128(sp)
 2001944:	d8801f17 	ldw	r2,124(sp)
 2001948:	da000404 	addi	r8,sp,16
 200194c:	003fee06 	br	2001908 <__alt_mem_mem_0+0xfcfe1908>
 2001950:	d9403117 	ldw	r5,196(sp)
 2001954:	d8802a17 	ldw	r2,168(sp)
 2001958:	28adc83a 	sub	r22,r5,r2
 200195c:	05be630e 	bge	zero,r22,20012ec <__alt_mem_mem_0+0xfcfe12ec>
 2001960:	07000404 	movi	fp,16
 2001964:	d8801f17 	ldw	r2,124(sp)
 2001968:	e5838f0e 	bge	fp,r22,20027a8 <___vfprintf_internal_r+0x1d88>
 200196c:	01408134 	movhi	r5,516
 2001970:	295a8c84 	addi	r5,r5,27186
 2001974:	dc403015 	stw	r17,192(sp)
 2001978:	d9402b15 	stw	r5,172(sp)
 200197c:	b023883a 	mov	r17,r22
 2001980:	04c001c4 	movi	r19,7
 2001984:	a82d883a 	mov	r22,r21
 2001988:	902b883a 	mov	r21,r18
 200198c:	8025883a 	mov	r18,r16
 2001990:	dc002c17 	ldw	r16,176(sp)
 2001994:	00000306 	br	20019a4 <___vfprintf_internal_r+0xf84>
 2001998:	8c7ffc04 	addi	r17,r17,-16
 200199c:	42000204 	addi	r8,r8,8
 20019a0:	e440110e 	bge	fp,r17,20019e8 <___vfprintf_internal_r+0xfc8>
 20019a4:	18c00404 	addi	r3,r3,16
 20019a8:	10800044 	addi	r2,r2,1
 20019ac:	45000015 	stw	r20,0(r8)
 20019b0:	47000115 	stw	fp,4(r8)
 20019b4:	d8c02015 	stw	r3,128(sp)
 20019b8:	d8801f15 	stw	r2,124(sp)
 20019bc:	98bff60e 	bge	r19,r2,2001998 <__alt_mem_mem_0+0xfcfe1998>
 20019c0:	d9801e04 	addi	r6,sp,120
 20019c4:	b80b883a 	mov	r5,r23
 20019c8:	8009883a 	mov	r4,r16
 20019cc:	20075380 	call	2007538 <__sprint_r>
 20019d0:	103d151e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 20019d4:	8c7ffc04 	addi	r17,r17,-16
 20019d8:	d8c02017 	ldw	r3,128(sp)
 20019dc:	d8801f17 	ldw	r2,124(sp)
 20019e0:	da000404 	addi	r8,sp,16
 20019e4:	e47fef16 	blt	fp,r17,20019a4 <__alt_mem_mem_0+0xfcfe19a4>
 20019e8:	9021883a 	mov	r16,r18
 20019ec:	a825883a 	mov	r18,r21
 20019f0:	b02b883a 	mov	r21,r22
 20019f4:	882d883a 	mov	r22,r17
 20019f8:	dc403017 	ldw	r17,192(sp)
 20019fc:	d9002b17 	ldw	r4,172(sp)
 2001a00:	1d87883a 	add	r3,r3,r22
 2001a04:	10800044 	addi	r2,r2,1
 2001a08:	41000015 	stw	r4,0(r8)
 2001a0c:	45800115 	stw	r22,4(r8)
 2001a10:	d8c02015 	stw	r3,128(sp)
 2001a14:	d8801f15 	stw	r2,124(sp)
 2001a18:	010001c4 	movi	r4,7
 2001a1c:	20818e16 	blt	r4,r2,2002058 <___vfprintf_internal_r+0x1638>
 2001a20:	42000204 	addi	r8,r8,8
 2001a24:	003e3106 	br	20012ec <__alt_mem_mem_0+0xfcfe12ec>
 2001a28:	d9403317 	ldw	r5,204(sp)
 2001a2c:	00800044 	movi	r2,1
 2001a30:	18c00044 	addi	r3,r3,1
 2001a34:	1141530e 	bge	r2,r5,2001f84 <___vfprintf_internal_r+0x1564>
 2001a38:	dc401f17 	ldw	r17,124(sp)
 2001a3c:	00800044 	movi	r2,1
 2001a40:	40800115 	stw	r2,4(r8)
 2001a44:	8c400044 	addi	r17,r17,1
 2001a48:	44000015 	stw	r16,0(r8)
 2001a4c:	d8c02015 	stw	r3,128(sp)
 2001a50:	dc401f15 	stw	r17,124(sp)
 2001a54:	008001c4 	movi	r2,7
 2001a58:	14416b16 	blt	r2,r17,2002008 <___vfprintf_internal_r+0x15e8>
 2001a5c:	42000204 	addi	r8,r8,8
 2001a60:	d8803717 	ldw	r2,220(sp)
 2001a64:	d9003417 	ldw	r4,208(sp)
 2001a68:	8c400044 	addi	r17,r17,1
 2001a6c:	10c7883a 	add	r3,r2,r3
 2001a70:	40800115 	stw	r2,4(r8)
 2001a74:	41000015 	stw	r4,0(r8)
 2001a78:	d8c02015 	stw	r3,128(sp)
 2001a7c:	dc401f15 	stw	r17,124(sp)
 2001a80:	008001c4 	movi	r2,7
 2001a84:	14416916 	blt	r2,r17,200202c <___vfprintf_internal_r+0x160c>
 2001a88:	45800204 	addi	r22,r8,8
 2001a8c:	d9003617 	ldw	r4,216(sp)
 2001a90:	d9403817 	ldw	r5,224(sp)
 2001a94:	000d883a 	mov	r6,zero
 2001a98:	000f883a 	mov	r7,zero
 2001a9c:	d8c03c15 	stw	r3,240(sp)
 2001aa0:	200bd2c0 	call	200bd2c <__eqdf2>
 2001aa4:	d8c03c17 	ldw	r3,240(sp)
 2001aa8:	1000bc26 	beq	r2,zero,2001d9c <___vfprintf_internal_r+0x137c>
 2001aac:	d9403317 	ldw	r5,204(sp)
 2001ab0:	84000044 	addi	r16,r16,1
 2001ab4:	8c400044 	addi	r17,r17,1
 2001ab8:	28bfffc4 	addi	r2,r5,-1
 2001abc:	1887883a 	add	r3,r3,r2
 2001ac0:	b0800115 	stw	r2,4(r22)
 2001ac4:	b4000015 	stw	r16,0(r22)
 2001ac8:	d8c02015 	stw	r3,128(sp)
 2001acc:	dc401f15 	stw	r17,124(sp)
 2001ad0:	008001c4 	movi	r2,7
 2001ad4:	14414316 	blt	r2,r17,2001fe4 <___vfprintf_internal_r+0x15c4>
 2001ad8:	b5800204 	addi	r22,r22,8
 2001adc:	d9003a17 	ldw	r4,232(sp)
 2001ae0:	df0022c4 	addi	fp,sp,139
 2001ae4:	8c400044 	addi	r17,r17,1
 2001ae8:	20c7883a 	add	r3,r4,r3
 2001aec:	b7000015 	stw	fp,0(r22)
 2001af0:	b1000115 	stw	r4,4(r22)
 2001af4:	d8c02015 	stw	r3,128(sp)
 2001af8:	dc401f15 	stw	r17,124(sp)
 2001afc:	008001c4 	movi	r2,7
 2001b00:	14400e16 	blt	r2,r17,2001b3c <___vfprintf_internal_r+0x111c>
 2001b04:	b2000204 	addi	r8,r22,8
 2001b08:	003e3a06 	br	20013f4 <__alt_mem_mem_0+0xfcfe13f4>
 2001b0c:	01008134 	movhi	r4,516
 2001b10:	211a8c84 	addi	r4,r4,27186
 2001b14:	d9002b15 	stw	r4,172(sp)
 2001b18:	d9002b17 	ldw	r4,172(sp)
 2001b1c:	1c07883a 	add	r3,r3,r16
 2001b20:	44000115 	stw	r16,4(r8)
 2001b24:	41000015 	stw	r4,0(r8)
 2001b28:	10800044 	addi	r2,r2,1
 2001b2c:	d8c02015 	stw	r3,128(sp)
 2001b30:	d8801f15 	stw	r2,124(sp)
 2001b34:	010001c4 	movi	r4,7
 2001b38:	20be2d0e 	bge	r4,r2,20013f0 <__alt_mem_mem_0+0xfcfe13f0>
 2001b3c:	d9002c17 	ldw	r4,176(sp)
 2001b40:	d9801e04 	addi	r6,sp,120
 2001b44:	b80b883a 	mov	r5,r23
 2001b48:	20075380 	call	2007538 <__sprint_r>
 2001b4c:	103cb61e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001b50:	d8c02017 	ldw	r3,128(sp)
 2001b54:	da000404 	addi	r8,sp,16
 2001b58:	003e2606 	br	20013f4 <__alt_mem_mem_0+0xfcfe13f4>
 2001b5c:	d9002c17 	ldw	r4,176(sp)
 2001b60:	d9801e04 	addi	r6,sp,120
 2001b64:	b80b883a 	mov	r5,r23
 2001b68:	20075380 	call	2007538 <__sprint_r>
 2001b6c:	103e5d26 	beq	r2,zero,20014e4 <__alt_mem_mem_0+0xfcfe14e4>
 2001b70:	003cad06 	br	2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001b74:	d9002c17 	ldw	r4,176(sp)
 2001b78:	d9801e04 	addi	r6,sp,120
 2001b7c:	b80b883a 	mov	r5,r23
 2001b80:	20075380 	call	2007538 <__sprint_r>
 2001b84:	103ca81e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001b88:	d8c02017 	ldw	r3,128(sp)
 2001b8c:	da000404 	addi	r8,sp,16
 2001b90:	003e0b06 	br	20013c0 <__alt_mem_mem_0+0xfcfe13c0>
 2001b94:	d9002c17 	ldw	r4,176(sp)
 2001b98:	d9801e04 	addi	r6,sp,120
 2001b9c:	b80b883a 	mov	r5,r23
 2001ba0:	20075380 	call	2007538 <__sprint_r>
 2001ba4:	103ca01e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001ba8:	d8c02017 	ldw	r3,128(sp)
 2001bac:	da000404 	addi	r8,sp,16
 2001bb0:	003dbd06 	br	20012a8 <__alt_mem_mem_0+0xfcfe12a8>
 2001bb4:	d9002c17 	ldw	r4,176(sp)
 2001bb8:	d9801e04 	addi	r6,sp,120
 2001bbc:	b80b883a 	mov	r5,r23
 2001bc0:	20075380 	call	2007538 <__sprint_r>
 2001bc4:	103c981e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001bc8:	d8c02017 	ldw	r3,128(sp)
 2001bcc:	da000404 	addi	r8,sp,16
 2001bd0:	003dc306 	br	20012e0 <__alt_mem_mem_0+0xfcfe12e0>
 2001bd4:	d8802917 	ldw	r2,164(sp)
 2001bd8:	d8002785 	stb	zero,158(sp)
 2001bdc:	103f0616 	blt	r2,zero,20017f8 <__alt_mem_mem_0+0xfcfe17f8>
 2001be0:	00ffdfc4 	movi	r3,-129
 2001be4:	9d84b03a 	or	r2,r19,r22
 2001be8:	90e4703a 	and	r18,r18,r3
 2001bec:	103c6b26 	beq	r2,zero,2000d9c <__alt_mem_mem_0+0xfcfe0d9c>
 2001bf0:	0039883a 	mov	fp,zero
 2001bf4:	003e7406 	br	20015c8 <__alt_mem_mem_0+0xfcfe15c8>
 2001bf8:	9080040c 	andi	r2,r18,16
 2001bfc:	1001b326 	beq	r2,zero,20022cc <___vfprintf_internal_r+0x18ac>
 2001c00:	d9002d17 	ldw	r4,180(sp)
 2001c04:	d9402917 	ldw	r5,164(sp)
 2001c08:	d8002785 	stb	zero,158(sp)
 2001c0c:	20800104 	addi	r2,r4,4
 2001c10:	24c00017 	ldw	r19,0(r4)
 2001c14:	002d883a 	mov	r22,zero
 2001c18:	2801b516 	blt	r5,zero,20022f0 <___vfprintf_internal_r+0x18d0>
 2001c1c:	00ffdfc4 	movi	r3,-129
 2001c20:	d8802d15 	stw	r2,180(sp)
 2001c24:	90e4703a 	and	r18,r18,r3
 2001c28:	983d2726 	beq	r19,zero,20010c8 <__alt_mem_mem_0+0xfcfe10c8>
 2001c2c:	0039883a 	mov	fp,zero
 2001c30:	003d2a06 	br	20010dc <__alt_mem_mem_0+0xfcfe10dc>
 2001c34:	dc402617 	ldw	r17,152(sp)
 2001c38:	0441d30e 	bge	zero,r17,2002388 <___vfprintf_internal_r+0x1968>
 2001c3c:	dc403217 	ldw	r17,200(sp)
 2001c40:	d8803317 	ldw	r2,204(sp)
 2001c44:	1440010e 	bge	r2,r17,2001c4c <___vfprintf_internal_r+0x122c>
 2001c48:	1023883a 	mov	r17,r2
 2001c4c:	04400a0e 	bge	zero,r17,2001c78 <___vfprintf_internal_r+0x1258>
 2001c50:	d8801f17 	ldw	r2,124(sp)
 2001c54:	1c47883a 	add	r3,r3,r17
 2001c58:	44000015 	stw	r16,0(r8)
 2001c5c:	10800044 	addi	r2,r2,1
 2001c60:	44400115 	stw	r17,4(r8)
 2001c64:	d8c02015 	stw	r3,128(sp)
 2001c68:	d8801f15 	stw	r2,124(sp)
 2001c6c:	010001c4 	movi	r4,7
 2001c70:	20826516 	blt	r4,r2,2002608 <___vfprintf_internal_r+0x1be8>
 2001c74:	42000204 	addi	r8,r8,8
 2001c78:	88026116 	blt	r17,zero,2002600 <___vfprintf_internal_r+0x1be0>
 2001c7c:	d9003217 	ldw	r4,200(sp)
 2001c80:	2463c83a 	sub	r17,r4,r17
 2001c84:	04407b0e 	bge	zero,r17,2001e74 <___vfprintf_internal_r+0x1454>
 2001c88:	05800404 	movi	r22,16
 2001c8c:	d8801f17 	ldw	r2,124(sp)
 2001c90:	b4419d0e 	bge	r22,r17,2002308 <___vfprintf_internal_r+0x18e8>
 2001c94:	01008134 	movhi	r4,516
 2001c98:	211a8c84 	addi	r4,r4,27186
 2001c9c:	d9002b15 	stw	r4,172(sp)
 2001ca0:	070001c4 	movi	fp,7
 2001ca4:	dcc02c17 	ldw	r19,176(sp)
 2001ca8:	00000306 	br	2001cb8 <___vfprintf_internal_r+0x1298>
 2001cac:	42000204 	addi	r8,r8,8
 2001cb0:	8c7ffc04 	addi	r17,r17,-16
 2001cb4:	b441970e 	bge	r22,r17,2002314 <___vfprintf_internal_r+0x18f4>
 2001cb8:	18c00404 	addi	r3,r3,16
 2001cbc:	10800044 	addi	r2,r2,1
 2001cc0:	45000015 	stw	r20,0(r8)
 2001cc4:	45800115 	stw	r22,4(r8)
 2001cc8:	d8c02015 	stw	r3,128(sp)
 2001ccc:	d8801f15 	stw	r2,124(sp)
 2001cd0:	e0bff60e 	bge	fp,r2,2001cac <__alt_mem_mem_0+0xfcfe1cac>
 2001cd4:	d9801e04 	addi	r6,sp,120
 2001cd8:	b80b883a 	mov	r5,r23
 2001cdc:	9809883a 	mov	r4,r19
 2001ce0:	20075380 	call	2007538 <__sprint_r>
 2001ce4:	103c501e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001ce8:	d8c02017 	ldw	r3,128(sp)
 2001cec:	d8801f17 	ldw	r2,124(sp)
 2001cf0:	da000404 	addi	r8,sp,16
 2001cf4:	003fee06 	br	2001cb0 <__alt_mem_mem_0+0xfcfe1cb0>
 2001cf8:	d9002c17 	ldw	r4,176(sp)
 2001cfc:	d9801e04 	addi	r6,sp,120
 2001d00:	b80b883a 	mov	r5,r23
 2001d04:	20075380 	call	2007538 <__sprint_r>
 2001d08:	103c471e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001d0c:	d8c02017 	ldw	r3,128(sp)
 2001d10:	df002787 	ldb	fp,158(sp)
 2001d14:	da000404 	addi	r8,sp,16
 2001d18:	003d5606 	br	2001274 <__alt_mem_mem_0+0xfcfe1274>
 2001d1c:	9080040c 	andi	r2,r18,16
 2001d20:	10016126 	beq	r2,zero,20022a8 <___vfprintf_internal_r+0x1888>
 2001d24:	d8802d17 	ldw	r2,180(sp)
 2001d28:	14c00017 	ldw	r19,0(r2)
 2001d2c:	10800104 	addi	r2,r2,4
 2001d30:	d8802d15 	stw	r2,180(sp)
 2001d34:	982dd7fa 	srai	r22,r19,31
 2001d38:	b005883a 	mov	r2,r22
 2001d3c:	003c8206 	br	2000f48 <__alt_mem_mem_0+0xfcfe0f48>
 2001d40:	9080040c 	andi	r2,r18,16
 2001d44:	10003526 	beq	r2,zero,2001e1c <___vfprintf_internal_r+0x13fc>
 2001d48:	d9402d17 	ldw	r5,180(sp)
 2001d4c:	d8c02917 	ldw	r3,164(sp)
 2001d50:	d8002785 	stb	zero,158(sp)
 2001d54:	28800104 	addi	r2,r5,4
 2001d58:	2cc00017 	ldw	r19,0(r5)
 2001d5c:	002d883a 	mov	r22,zero
 2001d60:	18003716 	blt	r3,zero,2001e40 <___vfprintf_internal_r+0x1420>
 2001d64:	00ffdfc4 	movi	r3,-129
 2001d68:	d8802d15 	stw	r2,180(sp)
 2001d6c:	90e4703a 	and	r18,r18,r3
 2001d70:	0039883a 	mov	fp,zero
 2001d74:	983df326 	beq	r19,zero,2001544 <__alt_mem_mem_0+0xfcfe1544>
 2001d78:	00800244 	movi	r2,9
 2001d7c:	14fc7b36 	bltu	r2,r19,2000f6c <__alt_mem_mem_0+0xfcfe0f6c>
 2001d80:	d8c02817 	ldw	r3,160(sp)
 2001d84:	dc001dc4 	addi	r16,sp,119
 2001d88:	9cc00c04 	addi	r19,r19,48
 2001d8c:	1c07c83a 	sub	r3,r3,r16
 2001d90:	dcc01dc5 	stb	r19,119(sp)
 2001d94:	d8c02e15 	stw	r3,184(sp)
 2001d98:	003ce806 	br	200113c <__alt_mem_mem_0+0xfcfe113c>
 2001d9c:	d8803317 	ldw	r2,204(sp)
 2001da0:	143fffc4 	addi	r16,r2,-1
 2001da4:	043f4d0e 	bge	zero,r16,2001adc <__alt_mem_mem_0+0xfcfe1adc>
 2001da8:	07000404 	movi	fp,16
 2001dac:	e400810e 	bge	fp,r16,2001fb4 <___vfprintf_internal_r+0x1594>
 2001db0:	01408134 	movhi	r5,516
 2001db4:	295a8c84 	addi	r5,r5,27186
 2001db8:	d9402b15 	stw	r5,172(sp)
 2001dbc:	01c001c4 	movi	r7,7
 2001dc0:	dcc02c17 	ldw	r19,176(sp)
 2001dc4:	00000306 	br	2001dd4 <___vfprintf_internal_r+0x13b4>
 2001dc8:	b5800204 	addi	r22,r22,8
 2001dcc:	843ffc04 	addi	r16,r16,-16
 2001dd0:	e4007b0e 	bge	fp,r16,2001fc0 <___vfprintf_internal_r+0x15a0>
 2001dd4:	18c00404 	addi	r3,r3,16
 2001dd8:	8c400044 	addi	r17,r17,1
 2001ddc:	b5000015 	stw	r20,0(r22)
 2001de0:	b7000115 	stw	fp,4(r22)
 2001de4:	d8c02015 	stw	r3,128(sp)
 2001de8:	dc401f15 	stw	r17,124(sp)
 2001dec:	3c7ff60e 	bge	r7,r17,2001dc8 <__alt_mem_mem_0+0xfcfe1dc8>
 2001df0:	d9801e04 	addi	r6,sp,120
 2001df4:	b80b883a 	mov	r5,r23
 2001df8:	9809883a 	mov	r4,r19
 2001dfc:	d9c03c15 	stw	r7,240(sp)
 2001e00:	20075380 	call	2007538 <__sprint_r>
 2001e04:	d9c03c17 	ldw	r7,240(sp)
 2001e08:	103c071e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001e0c:	d8c02017 	ldw	r3,128(sp)
 2001e10:	dc401f17 	ldw	r17,124(sp)
 2001e14:	dd800404 	addi	r22,sp,16
 2001e18:	003fec06 	br	2001dcc <__alt_mem_mem_0+0xfcfe1dcc>
 2001e1c:	9080100c 	andi	r2,r18,64
 2001e20:	d8002785 	stb	zero,158(sp)
 2001e24:	10010e26 	beq	r2,zero,2002260 <___vfprintf_internal_r+0x1840>
 2001e28:	d9002d17 	ldw	r4,180(sp)
 2001e2c:	d9402917 	ldw	r5,164(sp)
 2001e30:	002d883a 	mov	r22,zero
 2001e34:	20800104 	addi	r2,r4,4
 2001e38:	24c0000b 	ldhu	r19,0(r4)
 2001e3c:	283fc90e 	bge	r5,zero,2001d64 <__alt_mem_mem_0+0xfcfe1d64>
 2001e40:	d8802d15 	stw	r2,180(sp)
 2001e44:	0039883a 	mov	fp,zero
 2001e48:	9d84b03a 	or	r2,r19,r22
 2001e4c:	103c461e 	bne	r2,zero,2000f68 <__alt_mem_mem_0+0xfcfe0f68>
 2001e50:	00800044 	movi	r2,1
 2001e54:	003e6c06 	br	2001808 <__alt_mem_mem_0+0xfcfe1808>
 2001e58:	d9002c17 	ldw	r4,176(sp)
 2001e5c:	d9801e04 	addi	r6,sp,120
 2001e60:	b80b883a 	mov	r5,r23
 2001e64:	20075380 	call	2007538 <__sprint_r>
 2001e68:	103bef1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001e6c:	d8c02017 	ldw	r3,128(sp)
 2001e70:	da000404 	addi	r8,sp,16
 2001e74:	d9003217 	ldw	r4,200(sp)
 2001e78:	d8802617 	ldw	r2,152(sp)
 2001e7c:	d9403317 	ldw	r5,204(sp)
 2001e80:	8123883a 	add	r17,r16,r4
 2001e84:	11400216 	blt	r2,r5,2001e90 <___vfprintf_internal_r+0x1470>
 2001e88:	9100004c 	andi	r4,r18,1
 2001e8c:	20000d26 	beq	r4,zero,2001ec4 <___vfprintf_internal_r+0x14a4>
 2001e90:	d9003717 	ldw	r4,220(sp)
 2001e94:	d9403417 	ldw	r5,208(sp)
 2001e98:	1907883a 	add	r3,r3,r4
 2001e9c:	d9001f17 	ldw	r4,124(sp)
 2001ea0:	41400015 	stw	r5,0(r8)
 2001ea4:	d9403717 	ldw	r5,220(sp)
 2001ea8:	21000044 	addi	r4,r4,1
 2001eac:	d8c02015 	stw	r3,128(sp)
 2001eb0:	41400115 	stw	r5,4(r8)
 2001eb4:	d9001f15 	stw	r4,124(sp)
 2001eb8:	014001c4 	movi	r5,7
 2001ebc:	2901e816 	blt	r5,r4,2002660 <___vfprintf_internal_r+0x1c40>
 2001ec0:	42000204 	addi	r8,r8,8
 2001ec4:	d9003317 	ldw	r4,204(sp)
 2001ec8:	8121883a 	add	r16,r16,r4
 2001ecc:	2085c83a 	sub	r2,r4,r2
 2001ed0:	8461c83a 	sub	r16,r16,r17
 2001ed4:	1400010e 	bge	r2,r16,2001edc <___vfprintf_internal_r+0x14bc>
 2001ed8:	1021883a 	mov	r16,r2
 2001edc:	04000a0e 	bge	zero,r16,2001f08 <___vfprintf_internal_r+0x14e8>
 2001ee0:	d9001f17 	ldw	r4,124(sp)
 2001ee4:	1c07883a 	add	r3,r3,r16
 2001ee8:	44400015 	stw	r17,0(r8)
 2001eec:	21000044 	addi	r4,r4,1
 2001ef0:	44000115 	stw	r16,4(r8)
 2001ef4:	d8c02015 	stw	r3,128(sp)
 2001ef8:	d9001f15 	stw	r4,124(sp)
 2001efc:	014001c4 	movi	r5,7
 2001f00:	2901fb16 	blt	r5,r4,20026f0 <___vfprintf_internal_r+0x1cd0>
 2001f04:	42000204 	addi	r8,r8,8
 2001f08:	8001f716 	blt	r16,zero,20026e8 <___vfprintf_internal_r+0x1cc8>
 2001f0c:	1421c83a 	sub	r16,r2,r16
 2001f10:	043d380e 	bge	zero,r16,20013f4 <__alt_mem_mem_0+0xfcfe13f4>
 2001f14:	04400404 	movi	r17,16
 2001f18:	d8801f17 	ldw	r2,124(sp)
 2001f1c:	8c3efb0e 	bge	r17,r16,2001b0c <__alt_mem_mem_0+0xfcfe1b0c>
 2001f20:	01408134 	movhi	r5,516
 2001f24:	295a8c84 	addi	r5,r5,27186
 2001f28:	d9402b15 	stw	r5,172(sp)
 2001f2c:	058001c4 	movi	r22,7
 2001f30:	dcc02c17 	ldw	r19,176(sp)
 2001f34:	00000306 	br	2001f44 <___vfprintf_internal_r+0x1524>
 2001f38:	42000204 	addi	r8,r8,8
 2001f3c:	843ffc04 	addi	r16,r16,-16
 2001f40:	8c3ef50e 	bge	r17,r16,2001b18 <__alt_mem_mem_0+0xfcfe1b18>
 2001f44:	18c00404 	addi	r3,r3,16
 2001f48:	10800044 	addi	r2,r2,1
 2001f4c:	45000015 	stw	r20,0(r8)
 2001f50:	44400115 	stw	r17,4(r8)
 2001f54:	d8c02015 	stw	r3,128(sp)
 2001f58:	d8801f15 	stw	r2,124(sp)
 2001f5c:	b0bff60e 	bge	r22,r2,2001f38 <__alt_mem_mem_0+0xfcfe1f38>
 2001f60:	d9801e04 	addi	r6,sp,120
 2001f64:	b80b883a 	mov	r5,r23
 2001f68:	9809883a 	mov	r4,r19
 2001f6c:	20075380 	call	2007538 <__sprint_r>
 2001f70:	103bad1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001f74:	d8c02017 	ldw	r3,128(sp)
 2001f78:	d8801f17 	ldw	r2,124(sp)
 2001f7c:	da000404 	addi	r8,sp,16
 2001f80:	003fee06 	br	2001f3c <__alt_mem_mem_0+0xfcfe1f3c>
 2001f84:	9088703a 	and	r4,r18,r2
 2001f88:	203eab1e 	bne	r4,zero,2001a38 <__alt_mem_mem_0+0xfcfe1a38>
 2001f8c:	dc401f17 	ldw	r17,124(sp)
 2001f90:	40800115 	stw	r2,4(r8)
 2001f94:	44000015 	stw	r16,0(r8)
 2001f98:	8c400044 	addi	r17,r17,1
 2001f9c:	d8c02015 	stw	r3,128(sp)
 2001fa0:	dc401f15 	stw	r17,124(sp)
 2001fa4:	008001c4 	movi	r2,7
 2001fa8:	14400e16 	blt	r2,r17,2001fe4 <___vfprintf_internal_r+0x15c4>
 2001fac:	45800204 	addi	r22,r8,8
 2001fb0:	003eca06 	br	2001adc <__alt_mem_mem_0+0xfcfe1adc>
 2001fb4:	01008134 	movhi	r4,516
 2001fb8:	211a8c84 	addi	r4,r4,27186
 2001fbc:	d9002b15 	stw	r4,172(sp)
 2001fc0:	d8802b17 	ldw	r2,172(sp)
 2001fc4:	1c07883a 	add	r3,r3,r16
 2001fc8:	8c400044 	addi	r17,r17,1
 2001fcc:	b0800015 	stw	r2,0(r22)
 2001fd0:	b4000115 	stw	r16,4(r22)
 2001fd4:	d8c02015 	stw	r3,128(sp)
 2001fd8:	dc401f15 	stw	r17,124(sp)
 2001fdc:	008001c4 	movi	r2,7
 2001fe0:	147ebd0e 	bge	r2,r17,2001ad8 <__alt_mem_mem_0+0xfcfe1ad8>
 2001fe4:	d9002c17 	ldw	r4,176(sp)
 2001fe8:	d9801e04 	addi	r6,sp,120
 2001fec:	b80b883a 	mov	r5,r23
 2001ff0:	20075380 	call	2007538 <__sprint_r>
 2001ff4:	103b8c1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2001ff8:	d8c02017 	ldw	r3,128(sp)
 2001ffc:	dc401f17 	ldw	r17,124(sp)
 2002000:	dd800404 	addi	r22,sp,16
 2002004:	003eb506 	br	2001adc <__alt_mem_mem_0+0xfcfe1adc>
 2002008:	d9002c17 	ldw	r4,176(sp)
 200200c:	d9801e04 	addi	r6,sp,120
 2002010:	b80b883a 	mov	r5,r23
 2002014:	20075380 	call	2007538 <__sprint_r>
 2002018:	103b831e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 200201c:	d8c02017 	ldw	r3,128(sp)
 2002020:	dc401f17 	ldw	r17,124(sp)
 2002024:	da000404 	addi	r8,sp,16
 2002028:	003e8d06 	br	2001a60 <__alt_mem_mem_0+0xfcfe1a60>
 200202c:	d9002c17 	ldw	r4,176(sp)
 2002030:	d9801e04 	addi	r6,sp,120
 2002034:	b80b883a 	mov	r5,r23
 2002038:	20075380 	call	2007538 <__sprint_r>
 200203c:	103b7a1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2002040:	d8c02017 	ldw	r3,128(sp)
 2002044:	dc401f17 	ldw	r17,124(sp)
 2002048:	dd800404 	addi	r22,sp,16
 200204c:	003e8f06 	br	2001a8c <__alt_mem_mem_0+0xfcfe1a8c>
 2002050:	0027883a 	mov	r19,zero
 2002054:	003f4a06 	br	2001d80 <__alt_mem_mem_0+0xfcfe1d80>
 2002058:	d9002c17 	ldw	r4,176(sp)
 200205c:	d9801e04 	addi	r6,sp,120
 2002060:	b80b883a 	mov	r5,r23
 2002064:	20075380 	call	2007538 <__sprint_r>
 2002068:	103b6f1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 200206c:	d8c02017 	ldw	r3,128(sp)
 2002070:	da000404 	addi	r8,sp,16
 2002074:	003c9d06 	br	20012ec <__alt_mem_mem_0+0xfcfe12ec>
 2002078:	04e7c83a 	sub	r19,zero,r19
 200207c:	9804c03a 	cmpne	r2,r19,zero
 2002080:	05adc83a 	sub	r22,zero,r22
 2002084:	b0adc83a 	sub	r22,r22,r2
 2002088:	d8802917 	ldw	r2,164(sp)
 200208c:	07000b44 	movi	fp,45
 2002090:	df002785 	stb	fp,158(sp)
 2002094:	10017b16 	blt	r2,zero,2002684 <___vfprintf_internal_r+0x1c64>
 2002098:	00bfdfc4 	movi	r2,-129
 200209c:	90a4703a 	and	r18,r18,r2
 20020a0:	003bb106 	br	2000f68 <__alt_mem_mem_0+0xfcfe0f68>
 20020a4:	d9003617 	ldw	r4,216(sp)
 20020a8:	d9403817 	ldw	r5,224(sp)
 20020ac:	da003d15 	stw	r8,244(sp)
 20020b0:	20070c40 	call	20070c4 <__fpclassifyd>
 20020b4:	da003d17 	ldw	r8,244(sp)
 20020b8:	1000f026 	beq	r2,zero,200247c <___vfprintf_internal_r+0x1a5c>
 20020bc:	d9002917 	ldw	r4,164(sp)
 20020c0:	05bff7c4 	movi	r22,-33
 20020c4:	00bfffc4 	movi	r2,-1
 20020c8:	8dac703a 	and	r22,r17,r22
 20020cc:	20820026 	beq	r4,r2,20028d0 <___vfprintf_internal_r+0x1eb0>
 20020d0:	008011c4 	movi	r2,71
 20020d4:	b081f726 	beq	r22,r2,20028b4 <___vfprintf_internal_r+0x1e94>
 20020d8:	d9003817 	ldw	r4,224(sp)
 20020dc:	90c04014 	ori	r3,r18,256
 20020e0:	d8c02b15 	stw	r3,172(sp)
 20020e4:	20021516 	blt	r4,zero,200293c <___vfprintf_internal_r+0x1f1c>
 20020e8:	dcc03817 	ldw	r19,224(sp)
 20020ec:	d8002a05 	stb	zero,168(sp)
 20020f0:	00801984 	movi	r2,102
 20020f4:	8881f926 	beq	r17,r2,20028dc <___vfprintf_internal_r+0x1ebc>
 20020f8:	00801184 	movi	r2,70
 20020fc:	88821c26 	beq	r17,r2,2002970 <___vfprintf_internal_r+0x1f50>
 2002100:	00801144 	movi	r2,69
 2002104:	b081ef26 	beq	r22,r2,20028c4 <___vfprintf_internal_r+0x1ea4>
 2002108:	d8c02917 	ldw	r3,164(sp)
 200210c:	d8802104 	addi	r2,sp,132
 2002110:	d8800315 	stw	r2,12(sp)
 2002114:	d9403617 	ldw	r5,216(sp)
 2002118:	d8802504 	addi	r2,sp,148
 200211c:	d9002c17 	ldw	r4,176(sp)
 2002120:	d8800215 	stw	r2,8(sp)
 2002124:	d8802604 	addi	r2,sp,152
 2002128:	d8c00015 	stw	r3,0(sp)
 200212c:	d8800115 	stw	r2,4(sp)
 2002130:	01c00084 	movi	r7,2
 2002134:	980d883a 	mov	r6,r19
 2002138:	d8c03c15 	stw	r3,240(sp)
 200213c:	da003d15 	stw	r8,244(sp)
 2002140:	20030440 	call	2003044 <_dtoa_r>
 2002144:	1021883a 	mov	r16,r2
 2002148:	008019c4 	movi	r2,103
 200214c:	d8c03c17 	ldw	r3,240(sp)
 2002150:	da003d17 	ldw	r8,244(sp)
 2002154:	88817126 	beq	r17,r2,200271c <___vfprintf_internal_r+0x1cfc>
 2002158:	008011c4 	movi	r2,71
 200215c:	88829226 	beq	r17,r2,2002ba8 <___vfprintf_internal_r+0x2188>
 2002160:	80f9883a 	add	fp,r16,r3
 2002164:	d9003617 	ldw	r4,216(sp)
 2002168:	000d883a 	mov	r6,zero
 200216c:	000f883a 	mov	r7,zero
 2002170:	980b883a 	mov	r5,r19
 2002174:	da003d15 	stw	r8,244(sp)
 2002178:	200bd2c0 	call	200bd2c <__eqdf2>
 200217c:	da003d17 	ldw	r8,244(sp)
 2002180:	10018d26 	beq	r2,zero,20027b8 <___vfprintf_internal_r+0x1d98>
 2002184:	d8802117 	ldw	r2,132(sp)
 2002188:	1700062e 	bgeu	r2,fp,20021a4 <___vfprintf_internal_r+0x1784>
 200218c:	01000c04 	movi	r4,48
 2002190:	10c00044 	addi	r3,r2,1
 2002194:	d8c02115 	stw	r3,132(sp)
 2002198:	11000005 	stb	r4,0(r2)
 200219c:	d8802117 	ldw	r2,132(sp)
 20021a0:	173ffb36 	bltu	r2,fp,2002190 <__alt_mem_mem_0+0xfcfe2190>
 20021a4:	1405c83a 	sub	r2,r2,r16
 20021a8:	d8803315 	stw	r2,204(sp)
 20021ac:	008011c4 	movi	r2,71
 20021b0:	b0817626 	beq	r22,r2,200278c <___vfprintf_internal_r+0x1d6c>
 20021b4:	00801944 	movi	r2,101
 20021b8:	1442810e 	bge	r2,r17,2002bc0 <___vfprintf_internal_r+0x21a0>
 20021bc:	d8c02617 	ldw	r3,152(sp)
 20021c0:	00801984 	movi	r2,102
 20021c4:	d8c03215 	stw	r3,200(sp)
 20021c8:	8881fe26 	beq	r17,r2,20029c4 <___vfprintf_internal_r+0x1fa4>
 20021cc:	d8c03217 	ldw	r3,200(sp)
 20021d0:	d9003317 	ldw	r4,204(sp)
 20021d4:	1901dd16 	blt	r3,r4,200294c <___vfprintf_internal_r+0x1f2c>
 20021d8:	9480004c 	andi	r18,r18,1
 20021dc:	90022b1e 	bne	r18,zero,2002a8c <___vfprintf_internal_r+0x206c>
 20021e0:	1805883a 	mov	r2,r3
 20021e4:	18028016 	blt	r3,zero,2002be8 <___vfprintf_internal_r+0x21c8>
 20021e8:	d8c03217 	ldw	r3,200(sp)
 20021ec:	044019c4 	movi	r17,103
 20021f0:	d8c02e15 	stw	r3,184(sp)
 20021f4:	df002a07 	ldb	fp,168(sp)
 20021f8:	e001531e 	bne	fp,zero,2002748 <___vfprintf_internal_r+0x1d28>
 20021fc:	df002783 	ldbu	fp,158(sp)
 2002200:	d8802a15 	stw	r2,168(sp)
 2002204:	dc802b17 	ldw	r18,172(sp)
 2002208:	d8002915 	stw	zero,164(sp)
 200220c:	003bd106 	br	2001154 <__alt_mem_mem_0+0xfcfe1154>
 2002210:	d8802d17 	ldw	r2,180(sp)
 2002214:	d8c02d17 	ldw	r3,180(sp)
 2002218:	d9002d17 	ldw	r4,180(sp)
 200221c:	10800017 	ldw	r2,0(r2)
 2002220:	18c00117 	ldw	r3,4(r3)
 2002224:	21000204 	addi	r4,r4,8
 2002228:	d8803615 	stw	r2,216(sp)
 200222c:	d8c03815 	stw	r3,224(sp)
 2002230:	d9002d15 	stw	r4,180(sp)
 2002234:	003b7506 	br	200100c <__alt_mem_mem_0+0xfcfe100c>
 2002238:	ac400007 	ldb	r17,0(r21)
 200223c:	003a5906 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2002240:	9080100c 	andi	r2,r18,64
 2002244:	1000a826 	beq	r2,zero,20024e8 <___vfprintf_internal_r+0x1ac8>
 2002248:	d9002d17 	ldw	r4,180(sp)
 200224c:	002d883a 	mov	r22,zero
 2002250:	24c0000b 	ldhu	r19,0(r4)
 2002254:	21000104 	addi	r4,r4,4
 2002258:	d9002d15 	stw	r4,180(sp)
 200225c:	003ccb06 	br	200158c <__alt_mem_mem_0+0xfcfe158c>
 2002260:	d8c02d17 	ldw	r3,180(sp)
 2002264:	d9002917 	ldw	r4,164(sp)
 2002268:	002d883a 	mov	r22,zero
 200226c:	18800104 	addi	r2,r3,4
 2002270:	1cc00017 	ldw	r19,0(r3)
 2002274:	203ebb0e 	bge	r4,zero,2001d64 <__alt_mem_mem_0+0xfcfe1d64>
 2002278:	003ef106 	br	2001e40 <__alt_mem_mem_0+0xfcfe1e40>
 200227c:	9080040c 	andi	r2,r18,16
 2002280:	1000921e 	bne	r2,zero,20024cc <___vfprintf_internal_r+0x1aac>
 2002284:	9480100c 	andi	r18,r18,64
 2002288:	90013926 	beq	r18,zero,2002770 <___vfprintf_internal_r+0x1d50>
 200228c:	d9002d17 	ldw	r4,180(sp)
 2002290:	d9402f17 	ldw	r5,188(sp)
 2002294:	20800017 	ldw	r2,0(r4)
 2002298:	21000104 	addi	r4,r4,4
 200229c:	d9002d15 	stw	r4,180(sp)
 20022a0:	1140000d 	sth	r5,0(r2)
 20022a4:	003a1606 	br	2000b00 <__alt_mem_mem_0+0xfcfe0b00>
 20022a8:	9080100c 	andi	r2,r18,64
 20022ac:	10008026 	beq	r2,zero,20024b0 <___vfprintf_internal_r+0x1a90>
 20022b0:	d8c02d17 	ldw	r3,180(sp)
 20022b4:	1cc0000f 	ldh	r19,0(r3)
 20022b8:	18c00104 	addi	r3,r3,4
 20022bc:	d8c02d15 	stw	r3,180(sp)
 20022c0:	982dd7fa 	srai	r22,r19,31
 20022c4:	b005883a 	mov	r2,r22
 20022c8:	003b1f06 	br	2000f48 <__alt_mem_mem_0+0xfcfe0f48>
 20022cc:	9080100c 	andi	r2,r18,64
 20022d0:	d8002785 	stb	zero,158(sp)
 20022d4:	10008a1e 	bne	r2,zero,2002500 <___vfprintf_internal_r+0x1ae0>
 20022d8:	d9402d17 	ldw	r5,180(sp)
 20022dc:	d8c02917 	ldw	r3,164(sp)
 20022e0:	002d883a 	mov	r22,zero
 20022e4:	28800104 	addi	r2,r5,4
 20022e8:	2cc00017 	ldw	r19,0(r5)
 20022ec:	183e4b0e 	bge	r3,zero,2001c1c <__alt_mem_mem_0+0xfcfe1c1c>
 20022f0:	9d86b03a 	or	r3,r19,r22
 20022f4:	d8802d15 	stw	r2,180(sp)
 20022f8:	183e4c1e 	bne	r3,zero,2001c2c <__alt_mem_mem_0+0xfcfe1c2c>
 20022fc:	0039883a 	mov	fp,zero
 2002300:	0005883a 	mov	r2,zero
 2002304:	003d4006 	br	2001808 <__alt_mem_mem_0+0xfcfe1808>
 2002308:	01408134 	movhi	r5,516
 200230c:	295a8c84 	addi	r5,r5,27186
 2002310:	d9402b15 	stw	r5,172(sp)
 2002314:	d9402b17 	ldw	r5,172(sp)
 2002318:	1c47883a 	add	r3,r3,r17
 200231c:	10800044 	addi	r2,r2,1
 2002320:	41400015 	stw	r5,0(r8)
 2002324:	44400115 	stw	r17,4(r8)
 2002328:	d8c02015 	stw	r3,128(sp)
 200232c:	d8801f15 	stw	r2,124(sp)
 2002330:	010001c4 	movi	r4,7
 2002334:	20bec816 	blt	r4,r2,2001e58 <__alt_mem_mem_0+0xfcfe1e58>
 2002338:	42000204 	addi	r8,r8,8
 200233c:	003ecd06 	br	2001e74 <__alt_mem_mem_0+0xfcfe1e74>
 2002340:	d9002917 	ldw	r4,164(sp)
 2002344:	d8002785 	stb	zero,158(sp)
 2002348:	203d2d16 	blt	r4,zero,2001800 <__alt_mem_mem_0+0xfcfe1800>
 200234c:	00bfdfc4 	movi	r2,-129
 2002350:	90a4703a 	and	r18,r18,r2
 2002354:	003a9106 	br	2000d9c <__alt_mem_mem_0+0xfcfe0d9c>
 2002358:	01008134 	movhi	r4,516
 200235c:	211a8c84 	addi	r4,r4,27186
 2002360:	d9002b15 	stw	r4,172(sp)
 2002364:	003c0c06 	br	2001398 <__alt_mem_mem_0+0xfcfe1398>
 2002368:	d9002c17 	ldw	r4,176(sp)
 200236c:	d9801e04 	addi	r6,sp,120
 2002370:	b80b883a 	mov	r5,r23
 2002374:	20075380 	call	2007538 <__sprint_r>
 2002378:	103aab1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 200237c:	d8c02017 	ldw	r3,128(sp)
 2002380:	da000404 	addi	r8,sp,16
 2002384:	003d4106 	br	200188c <__alt_mem_mem_0+0xfcfe188c>
 2002388:	d8801f17 	ldw	r2,124(sp)
 200238c:	01408134 	movhi	r5,516
 2002390:	01000044 	movi	r4,1
 2002394:	18c00044 	addi	r3,r3,1
 2002398:	10800044 	addi	r2,r2,1
 200239c:	295a8c04 	addi	r5,r5,27184
 20023a0:	41000115 	stw	r4,4(r8)
 20023a4:	41400015 	stw	r5,0(r8)
 20023a8:	d8c02015 	stw	r3,128(sp)
 20023ac:	d8801f15 	stw	r2,124(sp)
 20023b0:	010001c4 	movi	r4,7
 20023b4:	20805c16 	blt	r4,r2,2002528 <___vfprintf_internal_r+0x1b08>
 20023b8:	42000204 	addi	r8,r8,8
 20023bc:	8800041e 	bne	r17,zero,20023d0 <___vfprintf_internal_r+0x19b0>
 20023c0:	d8803317 	ldw	r2,204(sp)
 20023c4:	1000021e 	bne	r2,zero,20023d0 <___vfprintf_internal_r+0x19b0>
 20023c8:	9080004c 	andi	r2,r18,1
 20023cc:	103c0926 	beq	r2,zero,20013f4 <__alt_mem_mem_0+0xfcfe13f4>
 20023d0:	d9003717 	ldw	r4,220(sp)
 20023d4:	d8801f17 	ldw	r2,124(sp)
 20023d8:	d9403417 	ldw	r5,208(sp)
 20023dc:	20c7883a 	add	r3,r4,r3
 20023e0:	10800044 	addi	r2,r2,1
 20023e4:	41000115 	stw	r4,4(r8)
 20023e8:	41400015 	stw	r5,0(r8)
 20023ec:	d8c02015 	stw	r3,128(sp)
 20023f0:	d8801f15 	stw	r2,124(sp)
 20023f4:	010001c4 	movi	r4,7
 20023f8:	20812116 	blt	r4,r2,2002880 <___vfprintf_internal_r+0x1e60>
 20023fc:	42000204 	addi	r8,r8,8
 2002400:	0463c83a 	sub	r17,zero,r17
 2002404:	0440730e 	bge	zero,r17,20025d4 <___vfprintf_internal_r+0x1bb4>
 2002408:	05800404 	movi	r22,16
 200240c:	b440860e 	bge	r22,r17,2002628 <___vfprintf_internal_r+0x1c08>
 2002410:	01408134 	movhi	r5,516
 2002414:	295a8c84 	addi	r5,r5,27186
 2002418:	d9402b15 	stw	r5,172(sp)
 200241c:	070001c4 	movi	fp,7
 2002420:	dcc02c17 	ldw	r19,176(sp)
 2002424:	00000306 	br	2002434 <___vfprintf_internal_r+0x1a14>
 2002428:	42000204 	addi	r8,r8,8
 200242c:	8c7ffc04 	addi	r17,r17,-16
 2002430:	b440800e 	bge	r22,r17,2002634 <___vfprintf_internal_r+0x1c14>
 2002434:	18c00404 	addi	r3,r3,16
 2002438:	10800044 	addi	r2,r2,1
 200243c:	45000015 	stw	r20,0(r8)
 2002440:	45800115 	stw	r22,4(r8)
 2002444:	d8c02015 	stw	r3,128(sp)
 2002448:	d8801f15 	stw	r2,124(sp)
 200244c:	e0bff60e 	bge	fp,r2,2002428 <__alt_mem_mem_0+0xfcfe2428>
 2002450:	d9801e04 	addi	r6,sp,120
 2002454:	b80b883a 	mov	r5,r23
 2002458:	9809883a 	mov	r4,r19
 200245c:	20075380 	call	2007538 <__sprint_r>
 2002460:	103a711e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2002464:	d8c02017 	ldw	r3,128(sp)
 2002468:	d8801f17 	ldw	r2,124(sp)
 200246c:	da000404 	addi	r8,sp,16
 2002470:	003fee06 	br	200242c <__alt_mem_mem_0+0xfcfe242c>
 2002474:	00bfffc4 	movi	r2,-1
 2002478:	003a6f06 	br	2000e38 <__alt_mem_mem_0+0xfcfe0e38>
 200247c:	008011c4 	movi	r2,71
 2002480:	1440b816 	blt	r2,r17,2002764 <___vfprintf_internal_r+0x1d44>
 2002484:	04008134 	movhi	r16,516
 2002488:	841a7e04 	addi	r16,r16,27128
 200248c:	00c000c4 	movi	r3,3
 2002490:	00bfdfc4 	movi	r2,-129
 2002494:	d8c02a15 	stw	r3,168(sp)
 2002498:	90a4703a 	and	r18,r18,r2
 200249c:	df002783 	ldbu	fp,158(sp)
 20024a0:	d8c02e15 	stw	r3,184(sp)
 20024a4:	d8002915 	stw	zero,164(sp)
 20024a8:	d8003215 	stw	zero,200(sp)
 20024ac:	003b2906 	br	2001154 <__alt_mem_mem_0+0xfcfe1154>
 20024b0:	d9002d17 	ldw	r4,180(sp)
 20024b4:	24c00017 	ldw	r19,0(r4)
 20024b8:	21000104 	addi	r4,r4,4
 20024bc:	d9002d15 	stw	r4,180(sp)
 20024c0:	982dd7fa 	srai	r22,r19,31
 20024c4:	b005883a 	mov	r2,r22
 20024c8:	003a9f06 	br	2000f48 <__alt_mem_mem_0+0xfcfe0f48>
 20024cc:	d9402d17 	ldw	r5,180(sp)
 20024d0:	d8c02f17 	ldw	r3,188(sp)
 20024d4:	28800017 	ldw	r2,0(r5)
 20024d8:	29400104 	addi	r5,r5,4
 20024dc:	d9402d15 	stw	r5,180(sp)
 20024e0:	10c00015 	stw	r3,0(r2)
 20024e4:	00398606 	br	2000b00 <__alt_mem_mem_0+0xfcfe0b00>
 20024e8:	d9402d17 	ldw	r5,180(sp)
 20024ec:	002d883a 	mov	r22,zero
 20024f0:	2cc00017 	ldw	r19,0(r5)
 20024f4:	29400104 	addi	r5,r5,4
 20024f8:	d9402d15 	stw	r5,180(sp)
 20024fc:	003c2306 	br	200158c <__alt_mem_mem_0+0xfcfe158c>
 2002500:	d8c02d17 	ldw	r3,180(sp)
 2002504:	d9002917 	ldw	r4,164(sp)
 2002508:	002d883a 	mov	r22,zero
 200250c:	18800104 	addi	r2,r3,4
 2002510:	1cc0000b 	ldhu	r19,0(r3)
 2002514:	203dc10e 	bge	r4,zero,2001c1c <__alt_mem_mem_0+0xfcfe1c1c>
 2002518:	003f7506 	br	20022f0 <__alt_mem_mem_0+0xfcfe22f0>
 200251c:	04008134 	movhi	r16,516
 2002520:	841a7c04 	addi	r16,r16,27120
 2002524:	003acc06 	br	2001058 <__alt_mem_mem_0+0xfcfe1058>
 2002528:	d9002c17 	ldw	r4,176(sp)
 200252c:	d9801e04 	addi	r6,sp,120
 2002530:	b80b883a 	mov	r5,r23
 2002534:	20075380 	call	2007538 <__sprint_r>
 2002538:	103a3b1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 200253c:	dc402617 	ldw	r17,152(sp)
 2002540:	d8c02017 	ldw	r3,128(sp)
 2002544:	da000404 	addi	r8,sp,16
 2002548:	003f9c06 	br	20023bc <__alt_mem_mem_0+0xfcfe23bc>
 200254c:	ac400043 	ldbu	r17,1(r21)
 2002550:	94800814 	ori	r18,r18,32
 2002554:	ad400044 	addi	r21,r21,1
 2002558:	8c403fcc 	andi	r17,r17,255
 200255c:	8c40201c 	xori	r17,r17,128
 2002560:	8c7fe004 	addi	r17,r17,-128
 2002564:	00398f06 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2002568:	d8c02d15 	stw	r3,180(sp)
 200256c:	0039883a 	mov	fp,zero
 2002570:	003e3506 	br	2001e48 <__alt_mem_mem_0+0xfcfe1e48>
 2002574:	d9002c17 	ldw	r4,176(sp)
 2002578:	d9801e04 	addi	r6,sp,120
 200257c:	b80b883a 	mov	r5,r23
 2002580:	20075380 	call	2007538 <__sprint_r>
 2002584:	103a281e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2002588:	d8c02017 	ldw	r3,128(sp)
 200258c:	da000404 	addi	r8,sp,16
 2002590:	003cd006 	br	20018d4 <__alt_mem_mem_0+0xfcfe18d4>
 2002594:	8009883a 	mov	r4,r16
 2002598:	da003d15 	stw	r8,244(sp)
 200259c:	20073a40 	call	20073a4 <strlen>
 20025a0:	d8802e15 	stw	r2,184(sp)
 20025a4:	da003d17 	ldw	r8,244(sp)
 20025a8:	103c340e 	bge	r2,zero,200167c <__alt_mem_mem_0+0xfcfe167c>
 20025ac:	0005883a 	mov	r2,zero
 20025b0:	003c3206 	br	200167c <__alt_mem_mem_0+0xfcfe167c>
 20025b4:	d9002c17 	ldw	r4,176(sp)
 20025b8:	d9801e04 	addi	r6,sp,120
 20025bc:	b80b883a 	mov	r5,r23
 20025c0:	20075380 	call	2007538 <__sprint_r>
 20025c4:	103a181e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 20025c8:	d8c02017 	ldw	r3,128(sp)
 20025cc:	d8801f17 	ldw	r2,124(sp)
 20025d0:	da000404 	addi	r8,sp,16
 20025d4:	d9403317 	ldw	r5,204(sp)
 20025d8:	10800044 	addi	r2,r2,1
 20025dc:	44000015 	stw	r16,0(r8)
 20025e0:	28c7883a 	add	r3,r5,r3
 20025e4:	003b7d06 	br	20013dc <__alt_mem_mem_0+0xfcfe13dc>
 20025e8:	01008134 	movhi	r4,516
 20025ec:	211a9084 	addi	r4,r4,27202
 20025f0:	d9003515 	stw	r4,212(sp)
 20025f4:	003b1406 	br	2001248 <__alt_mem_mem_0+0xfcfe1248>
 20025f8:	013fffc4 	movi	r4,-1
 20025fc:	003a3506 	br	2000ed4 <__alt_mem_mem_0+0xfcfe0ed4>
 2002600:	0023883a 	mov	r17,zero
 2002604:	003d9d06 	br	2001c7c <__alt_mem_mem_0+0xfcfe1c7c>
 2002608:	d9002c17 	ldw	r4,176(sp)
 200260c:	d9801e04 	addi	r6,sp,120
 2002610:	b80b883a 	mov	r5,r23
 2002614:	20075380 	call	2007538 <__sprint_r>
 2002618:	103a031e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 200261c:	d8c02017 	ldw	r3,128(sp)
 2002620:	da000404 	addi	r8,sp,16
 2002624:	003d9406 	br	2001c78 <__alt_mem_mem_0+0xfcfe1c78>
 2002628:	01008134 	movhi	r4,516
 200262c:	211a8c84 	addi	r4,r4,27186
 2002630:	d9002b15 	stw	r4,172(sp)
 2002634:	d9002b17 	ldw	r4,172(sp)
 2002638:	1c47883a 	add	r3,r3,r17
 200263c:	10800044 	addi	r2,r2,1
 2002640:	41000015 	stw	r4,0(r8)
 2002644:	44400115 	stw	r17,4(r8)
 2002648:	d8c02015 	stw	r3,128(sp)
 200264c:	d8801f15 	stw	r2,124(sp)
 2002650:	010001c4 	movi	r4,7
 2002654:	20bfd716 	blt	r4,r2,20025b4 <__alt_mem_mem_0+0xfcfe25b4>
 2002658:	42000204 	addi	r8,r8,8
 200265c:	003fdd06 	br	20025d4 <__alt_mem_mem_0+0xfcfe25d4>
 2002660:	d9002c17 	ldw	r4,176(sp)
 2002664:	d9801e04 	addi	r6,sp,120
 2002668:	b80b883a 	mov	r5,r23
 200266c:	20075380 	call	2007538 <__sprint_r>
 2002670:	1039ed1e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2002674:	d8802617 	ldw	r2,152(sp)
 2002678:	d8c02017 	ldw	r3,128(sp)
 200267c:	da000404 	addi	r8,sp,16
 2002680:	003e1006 	br	2001ec4 <__alt_mem_mem_0+0xfcfe1ec4>
 2002684:	00800044 	movi	r2,1
 2002688:	10803fcc 	andi	r2,r2,255
 200268c:	00c00044 	movi	r3,1
 2002690:	10fa3526 	beq	r2,r3,2000f68 <__alt_mem_mem_0+0xfcfe0f68>
 2002694:	00c00084 	movi	r3,2
 2002698:	10fbcb26 	beq	r2,r3,20015c8 <__alt_mem_mem_0+0xfcfe15c8>
 200269c:	003a8f06 	br	20010dc <__alt_mem_mem_0+0xfcfe10dc>
 20026a0:	01008134 	movhi	r4,516
 20026a4:	211a9084 	addi	r4,r4,27202
 20026a8:	d9003515 	stw	r4,212(sp)
 20026ac:	003b7606 	br	2001488 <__alt_mem_mem_0+0xfcfe1488>
 20026b0:	d8802917 	ldw	r2,164(sp)
 20026b4:	00c00184 	movi	r3,6
 20026b8:	1880012e 	bgeu	r3,r2,20026c0 <___vfprintf_internal_r+0x1ca0>
 20026bc:	1805883a 	mov	r2,r3
 20026c0:	d8802e15 	stw	r2,184(sp)
 20026c4:	1000ef16 	blt	r2,zero,2002a84 <___vfprintf_internal_r+0x2064>
 20026c8:	04008134 	movhi	r16,516
 20026cc:	d8802a15 	stw	r2,168(sp)
 20026d0:	dcc02d15 	stw	r19,180(sp)
 20026d4:	d8002915 	stw	zero,164(sp)
 20026d8:	d8003215 	stw	zero,200(sp)
 20026dc:	841a8a04 	addi	r16,r16,27176
 20026e0:	0039883a 	mov	fp,zero
 20026e4:	003aa206 	br	2001170 <__alt_mem_mem_0+0xfcfe1170>
 20026e8:	0021883a 	mov	r16,zero
 20026ec:	003e0706 	br	2001f0c <__alt_mem_mem_0+0xfcfe1f0c>
 20026f0:	d9002c17 	ldw	r4,176(sp)
 20026f4:	d9801e04 	addi	r6,sp,120
 20026f8:	b80b883a 	mov	r5,r23
 20026fc:	20075380 	call	2007538 <__sprint_r>
 2002700:	1039c91e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2002704:	d8802617 	ldw	r2,152(sp)
 2002708:	d9403317 	ldw	r5,204(sp)
 200270c:	d8c02017 	ldw	r3,128(sp)
 2002710:	da000404 	addi	r8,sp,16
 2002714:	2885c83a 	sub	r2,r5,r2
 2002718:	003dfb06 	br	2001f08 <__alt_mem_mem_0+0xfcfe1f08>
 200271c:	9080004c 	andi	r2,r18,1
 2002720:	103e8f1e 	bne	r2,zero,2002160 <__alt_mem_mem_0+0xfcfe2160>
 2002724:	d8802117 	ldw	r2,132(sp)
 2002728:	003e9e06 	br	20021a4 <__alt_mem_mem_0+0xfcfe21a4>
 200272c:	1025883a 	mov	r18,r2
 2002730:	0039883a 	mov	fp,zero
 2002734:	00800084 	movi	r2,2
 2002738:	003fd306 	br	2002688 <__alt_mem_mem_0+0xfcfe2688>
 200273c:	07000b44 	movi	fp,45
 2002740:	df002785 	stb	fp,158(sp)
 2002744:	003a4006 	br	2001048 <__alt_mem_mem_0+0xfcfe1048>
 2002748:	00c00b44 	movi	r3,45
 200274c:	d8c02785 	stb	r3,158(sp)
 2002750:	d8802a15 	stw	r2,168(sp)
 2002754:	dc802b17 	ldw	r18,172(sp)
 2002758:	d8002915 	stw	zero,164(sp)
 200275c:	07000b44 	movi	fp,45
 2002760:	003a8006 	br	2001164 <__alt_mem_mem_0+0xfcfe1164>
 2002764:	04008134 	movhi	r16,516
 2002768:	841a7f04 	addi	r16,r16,27132
 200276c:	003f4706 	br	200248c <__alt_mem_mem_0+0xfcfe248c>
 2002770:	d8c02d17 	ldw	r3,180(sp)
 2002774:	d9002f17 	ldw	r4,188(sp)
 2002778:	18800017 	ldw	r2,0(r3)
 200277c:	18c00104 	addi	r3,r3,4
 2002780:	d8c02d15 	stw	r3,180(sp)
 2002784:	11000015 	stw	r4,0(r2)
 2002788:	0038dd06 	br	2000b00 <__alt_mem_mem_0+0xfcfe0b00>
 200278c:	dd802617 	ldw	r22,152(sp)
 2002790:	00bfff44 	movi	r2,-3
 2002794:	b0801c16 	blt	r22,r2,2002808 <___vfprintf_internal_r+0x1de8>
 2002798:	d9402917 	ldw	r5,164(sp)
 200279c:	2d801a16 	blt	r5,r22,2002808 <___vfprintf_internal_r+0x1de8>
 20027a0:	dd803215 	stw	r22,200(sp)
 20027a4:	003e8906 	br	20021cc <__alt_mem_mem_0+0xfcfe21cc>
 20027a8:	01008134 	movhi	r4,516
 20027ac:	211a8c84 	addi	r4,r4,27186
 20027b0:	d9002b15 	stw	r4,172(sp)
 20027b4:	003c9106 	br	20019fc <__alt_mem_mem_0+0xfcfe19fc>
 20027b8:	e005883a 	mov	r2,fp
 20027bc:	003e7906 	br	20021a4 <__alt_mem_mem_0+0xfcfe21a4>
 20027c0:	d9402917 	ldw	r5,164(sp)
 20027c4:	df002783 	ldbu	fp,158(sp)
 20027c8:	dcc02d15 	stw	r19,180(sp)
 20027cc:	d9402a15 	stw	r5,168(sp)
 20027d0:	d9402e15 	stw	r5,184(sp)
 20027d4:	d8002915 	stw	zero,164(sp)
 20027d8:	d8003215 	stw	zero,200(sp)
 20027dc:	003a5d06 	br	2001154 <__alt_mem_mem_0+0xfcfe1154>
 20027e0:	9080004c 	andi	r2,r18,1
 20027e4:	0039883a 	mov	fp,zero
 20027e8:	10000426 	beq	r2,zero,20027fc <___vfprintf_internal_r+0x1ddc>
 20027ec:	00800c04 	movi	r2,48
 20027f0:	dc001dc4 	addi	r16,sp,119
 20027f4:	d8801dc5 	stb	r2,119(sp)
 20027f8:	003b8006 	br	20015fc <__alt_mem_mem_0+0xfcfe15fc>
 20027fc:	d8002e15 	stw	zero,184(sp)
 2002800:	dc001e04 	addi	r16,sp,120
 2002804:	003a4d06 	br	200113c <__alt_mem_mem_0+0xfcfe113c>
 2002808:	8c7fff84 	addi	r17,r17,-2
 200280c:	b5bfffc4 	addi	r22,r22,-1
 2002810:	dd802615 	stw	r22,152(sp)
 2002814:	dc4022c5 	stb	r17,139(sp)
 2002818:	b000bf16 	blt	r22,zero,2002b18 <___vfprintf_internal_r+0x20f8>
 200281c:	00800ac4 	movi	r2,43
 2002820:	d8802305 	stb	r2,140(sp)
 2002824:	00800244 	movi	r2,9
 2002828:	15807016 	blt	r2,r22,20029ec <___vfprintf_internal_r+0x1fcc>
 200282c:	00800c04 	movi	r2,48
 2002830:	b5800c04 	addi	r22,r22,48
 2002834:	d8802345 	stb	r2,141(sp)
 2002838:	dd802385 	stb	r22,142(sp)
 200283c:	d88023c4 	addi	r2,sp,143
 2002840:	df0022c4 	addi	fp,sp,139
 2002844:	d8c03317 	ldw	r3,204(sp)
 2002848:	1739c83a 	sub	fp,r2,fp
 200284c:	d9003317 	ldw	r4,204(sp)
 2002850:	e0c7883a 	add	r3,fp,r3
 2002854:	df003a15 	stw	fp,232(sp)
 2002858:	d8c02e15 	stw	r3,184(sp)
 200285c:	00800044 	movi	r2,1
 2002860:	1100b30e 	bge	r2,r4,2002b30 <___vfprintf_internal_r+0x2110>
 2002864:	d8c02e17 	ldw	r3,184(sp)
 2002868:	18c00044 	addi	r3,r3,1
 200286c:	d8c02e15 	stw	r3,184(sp)
 2002870:	1805883a 	mov	r2,r3
 2002874:	1800ac16 	blt	r3,zero,2002b28 <___vfprintf_internal_r+0x2108>
 2002878:	d8003215 	stw	zero,200(sp)
 200287c:	003e5d06 	br	20021f4 <__alt_mem_mem_0+0xfcfe21f4>
 2002880:	d9002c17 	ldw	r4,176(sp)
 2002884:	d9801e04 	addi	r6,sp,120
 2002888:	b80b883a 	mov	r5,r23
 200288c:	20075380 	call	2007538 <__sprint_r>
 2002890:	1039651e 	bne	r2,zero,2000e28 <__alt_mem_mem_0+0xfcfe0e28>
 2002894:	dc402617 	ldw	r17,152(sp)
 2002898:	d8c02017 	ldw	r3,128(sp)
 200289c:	d8801f17 	ldw	r2,124(sp)
 20028a0:	da000404 	addi	r8,sp,16
 20028a4:	003ed606 	br	2002400 <__alt_mem_mem_0+0xfcfe2400>
 20028a8:	582b883a 	mov	r21,r11
 20028ac:	d8002915 	stw	zero,164(sp)
 20028b0:	0038bd06 	br	2000ba8 <__alt_mem_mem_0+0xfcfe0ba8>
 20028b4:	d8802917 	ldw	r2,164(sp)
 20028b8:	103e071e 	bne	r2,zero,20020d8 <__alt_mem_mem_0+0xfcfe20d8>
 20028bc:	dc002915 	stw	r16,164(sp)
 20028c0:	003e0506 	br	20020d8 <__alt_mem_mem_0+0xfcfe20d8>
 20028c4:	d9002917 	ldw	r4,164(sp)
 20028c8:	20c00044 	addi	r3,r4,1
 20028cc:	003e0f06 	br	200210c <__alt_mem_mem_0+0xfcfe210c>
 20028d0:	01400184 	movi	r5,6
 20028d4:	d9402915 	stw	r5,164(sp)
 20028d8:	003dff06 	br	20020d8 <__alt_mem_mem_0+0xfcfe20d8>
 20028dc:	d8802104 	addi	r2,sp,132
 20028e0:	d8800315 	stw	r2,12(sp)
 20028e4:	d8802504 	addi	r2,sp,148
 20028e8:	d8800215 	stw	r2,8(sp)
 20028ec:	d8802604 	addi	r2,sp,152
 20028f0:	d8800115 	stw	r2,4(sp)
 20028f4:	d8802917 	ldw	r2,164(sp)
 20028f8:	d9403617 	ldw	r5,216(sp)
 20028fc:	d9002c17 	ldw	r4,176(sp)
 2002900:	d8800015 	stw	r2,0(sp)
 2002904:	01c000c4 	movi	r7,3
 2002908:	980d883a 	mov	r6,r19
 200290c:	da003d15 	stw	r8,244(sp)
 2002910:	20030440 	call	2003044 <_dtoa_r>
 2002914:	d8c02917 	ldw	r3,164(sp)
 2002918:	da003d17 	ldw	r8,244(sp)
 200291c:	1021883a 	mov	r16,r2
 2002920:	10f9883a 	add	fp,r2,r3
 2002924:	81000007 	ldb	r4,0(r16)
 2002928:	00800c04 	movi	r2,48
 200292c:	20805e26 	beq	r4,r2,2002aa8 <___vfprintf_internal_r+0x2088>
 2002930:	d8c02617 	ldw	r3,152(sp)
 2002934:	e0f9883a 	add	fp,fp,r3
 2002938:	003e0a06 	br	2002164 <__alt_mem_mem_0+0xfcfe2164>
 200293c:	00c00b44 	movi	r3,45
 2002940:	24e0003c 	xorhi	r19,r4,32768
 2002944:	d8c02a05 	stb	r3,168(sp)
 2002948:	003de906 	br	20020f0 <__alt_mem_mem_0+0xfcfe20f0>
 200294c:	d8c03217 	ldw	r3,200(sp)
 2002950:	00c07a0e 	bge	zero,r3,2002b3c <___vfprintf_internal_r+0x211c>
 2002954:	00800044 	movi	r2,1
 2002958:	d9003317 	ldw	r4,204(sp)
 200295c:	1105883a 	add	r2,r2,r4
 2002960:	d8802e15 	stw	r2,184(sp)
 2002964:	10004e16 	blt	r2,zero,2002aa0 <___vfprintf_internal_r+0x2080>
 2002968:	044019c4 	movi	r17,103
 200296c:	003e2106 	br	20021f4 <__alt_mem_mem_0+0xfcfe21f4>
 2002970:	d9002917 	ldw	r4,164(sp)
 2002974:	d8802104 	addi	r2,sp,132
 2002978:	d8800315 	stw	r2,12(sp)
 200297c:	d9000015 	stw	r4,0(sp)
 2002980:	d8802504 	addi	r2,sp,148
 2002984:	d9403617 	ldw	r5,216(sp)
 2002988:	d9002c17 	ldw	r4,176(sp)
 200298c:	d8800215 	stw	r2,8(sp)
 2002990:	d8802604 	addi	r2,sp,152
 2002994:	d8800115 	stw	r2,4(sp)
 2002998:	01c000c4 	movi	r7,3
 200299c:	980d883a 	mov	r6,r19
 20029a0:	da003d15 	stw	r8,244(sp)
 20029a4:	20030440 	call	2003044 <_dtoa_r>
 20029a8:	d8c02917 	ldw	r3,164(sp)
 20029ac:	da003d17 	ldw	r8,244(sp)
 20029b0:	1021883a 	mov	r16,r2
 20029b4:	00801184 	movi	r2,70
 20029b8:	80f9883a 	add	fp,r16,r3
 20029bc:	88bfd926 	beq	r17,r2,2002924 <__alt_mem_mem_0+0xfcfe2924>
 20029c0:	003de806 	br	2002164 <__alt_mem_mem_0+0xfcfe2164>
 20029c4:	d9002917 	ldw	r4,164(sp)
 20029c8:	00c04d0e 	bge	zero,r3,2002b00 <___vfprintf_internal_r+0x20e0>
 20029cc:	2000441e 	bne	r4,zero,2002ae0 <___vfprintf_internal_r+0x20c0>
 20029d0:	9480004c 	andi	r18,r18,1
 20029d4:	9000421e 	bne	r18,zero,2002ae0 <___vfprintf_internal_r+0x20c0>
 20029d8:	1805883a 	mov	r2,r3
 20029dc:	18007016 	blt	r3,zero,2002ba0 <___vfprintf_internal_r+0x2180>
 20029e0:	d8c03217 	ldw	r3,200(sp)
 20029e4:	d8c02e15 	stw	r3,184(sp)
 20029e8:	003e0206 	br	20021f4 <__alt_mem_mem_0+0xfcfe21f4>
 20029ec:	df0022c4 	addi	fp,sp,139
 20029f0:	dc002915 	stw	r16,164(sp)
 20029f4:	4027883a 	mov	r19,r8
 20029f8:	e021883a 	mov	r16,fp
 20029fc:	b009883a 	mov	r4,r22
 2002a00:	01400284 	movi	r5,10
 2002a04:	200aa680 	call	200aa68 <__modsi3>
 2002a08:	10800c04 	addi	r2,r2,48
 2002a0c:	843fffc4 	addi	r16,r16,-1
 2002a10:	b009883a 	mov	r4,r22
 2002a14:	01400284 	movi	r5,10
 2002a18:	80800005 	stb	r2,0(r16)
 2002a1c:	200a9e40 	call	200a9e4 <__divsi3>
 2002a20:	102d883a 	mov	r22,r2
 2002a24:	00800244 	movi	r2,9
 2002a28:	15bff416 	blt	r2,r22,20029fc <__alt_mem_mem_0+0xfcfe29fc>
 2002a2c:	9811883a 	mov	r8,r19
 2002a30:	b0800c04 	addi	r2,r22,48
 2002a34:	8027883a 	mov	r19,r16
 2002a38:	997fffc4 	addi	r5,r19,-1
 2002a3c:	98bfffc5 	stb	r2,-1(r19)
 2002a40:	dc002917 	ldw	r16,164(sp)
 2002a44:	2f006a2e 	bgeu	r5,fp,2002bf0 <___vfprintf_internal_r+0x21d0>
 2002a48:	d9c02384 	addi	r7,sp,142
 2002a4c:	3ccfc83a 	sub	r7,r7,r19
 2002a50:	d9002344 	addi	r4,sp,141
 2002a54:	e1cf883a 	add	r7,fp,r7
 2002a58:	00000106 	br	2002a60 <___vfprintf_internal_r+0x2040>
 2002a5c:	28800003 	ldbu	r2,0(r5)
 2002a60:	20800005 	stb	r2,0(r4)
 2002a64:	21000044 	addi	r4,r4,1
 2002a68:	29400044 	addi	r5,r5,1
 2002a6c:	393ffb1e 	bne	r7,r4,2002a5c <__alt_mem_mem_0+0xfcfe2a5c>
 2002a70:	d8802304 	addi	r2,sp,140
 2002a74:	14c5c83a 	sub	r2,r2,r19
 2002a78:	d8c02344 	addi	r3,sp,141
 2002a7c:	1885883a 	add	r2,r3,r2
 2002a80:	003f7006 	br	2002844 <__alt_mem_mem_0+0xfcfe2844>
 2002a84:	0005883a 	mov	r2,zero
 2002a88:	003f0f06 	br	20026c8 <__alt_mem_mem_0+0xfcfe26c8>
 2002a8c:	d8c03217 	ldw	r3,200(sp)
 2002a90:	18c00044 	addi	r3,r3,1
 2002a94:	d8c02e15 	stw	r3,184(sp)
 2002a98:	1805883a 	mov	r2,r3
 2002a9c:	183fb20e 	bge	r3,zero,2002968 <__alt_mem_mem_0+0xfcfe2968>
 2002aa0:	0005883a 	mov	r2,zero
 2002aa4:	003fb006 	br	2002968 <__alt_mem_mem_0+0xfcfe2968>
 2002aa8:	d9003617 	ldw	r4,216(sp)
 2002aac:	000d883a 	mov	r6,zero
 2002ab0:	000f883a 	mov	r7,zero
 2002ab4:	980b883a 	mov	r5,r19
 2002ab8:	d8c03c15 	stw	r3,240(sp)
 2002abc:	da003d15 	stw	r8,244(sp)
 2002ac0:	200bd2c0 	call	200bd2c <__eqdf2>
 2002ac4:	d8c03c17 	ldw	r3,240(sp)
 2002ac8:	da003d17 	ldw	r8,244(sp)
 2002acc:	103f9826 	beq	r2,zero,2002930 <__alt_mem_mem_0+0xfcfe2930>
 2002ad0:	00800044 	movi	r2,1
 2002ad4:	10c7c83a 	sub	r3,r2,r3
 2002ad8:	d8c02615 	stw	r3,152(sp)
 2002adc:	003f9506 	br	2002934 <__alt_mem_mem_0+0xfcfe2934>
 2002ae0:	d9002917 	ldw	r4,164(sp)
 2002ae4:	d8c03217 	ldw	r3,200(sp)
 2002ae8:	20800044 	addi	r2,r4,1
 2002aec:	1885883a 	add	r2,r3,r2
 2002af0:	d8802e15 	stw	r2,184(sp)
 2002af4:	103dbf0e 	bge	r2,zero,20021f4 <__alt_mem_mem_0+0xfcfe21f4>
 2002af8:	0005883a 	mov	r2,zero
 2002afc:	003dbd06 	br	20021f4 <__alt_mem_mem_0+0xfcfe21f4>
 2002b00:	2000211e 	bne	r4,zero,2002b88 <___vfprintf_internal_r+0x2168>
 2002b04:	9480004c 	andi	r18,r18,1
 2002b08:	90001f1e 	bne	r18,zero,2002b88 <___vfprintf_internal_r+0x2168>
 2002b0c:	00800044 	movi	r2,1
 2002b10:	d8802e15 	stw	r2,184(sp)
 2002b14:	003db706 	br	20021f4 <__alt_mem_mem_0+0xfcfe21f4>
 2002b18:	00800b44 	movi	r2,45
 2002b1c:	05adc83a 	sub	r22,zero,r22
 2002b20:	d8802305 	stb	r2,140(sp)
 2002b24:	003f3f06 	br	2002824 <__alt_mem_mem_0+0xfcfe2824>
 2002b28:	0005883a 	mov	r2,zero
 2002b2c:	003f5206 	br	2002878 <__alt_mem_mem_0+0xfcfe2878>
 2002b30:	90a4703a 	and	r18,r18,r2
 2002b34:	903f4e26 	beq	r18,zero,2002870 <__alt_mem_mem_0+0xfcfe2870>
 2002b38:	003f4a06 	br	2002864 <__alt_mem_mem_0+0xfcfe2864>
 2002b3c:	00800084 	movi	r2,2
 2002b40:	10c5c83a 	sub	r2,r2,r3
 2002b44:	003f8406 	br	2002958 <__alt_mem_mem_0+0xfcfe2958>
 2002b48:	d8802d17 	ldw	r2,180(sp)
 2002b4c:	d9002d17 	ldw	r4,180(sp)
 2002b50:	ac400043 	ldbu	r17,1(r21)
 2002b54:	10800017 	ldw	r2,0(r2)
 2002b58:	582b883a 	mov	r21,r11
 2002b5c:	d8802915 	stw	r2,164(sp)
 2002b60:	20800104 	addi	r2,r4,4
 2002b64:	d9002917 	ldw	r4,164(sp)
 2002b68:	d8802d15 	stw	r2,180(sp)
 2002b6c:	203e7a0e 	bge	r4,zero,2002558 <__alt_mem_mem_0+0xfcfe2558>
 2002b70:	8c403fcc 	andi	r17,r17,255
 2002b74:	00bfffc4 	movi	r2,-1
 2002b78:	8c40201c 	xori	r17,r17,128
 2002b7c:	d8802915 	stw	r2,164(sp)
 2002b80:	8c7fe004 	addi	r17,r17,-128
 2002b84:	00380706 	br	2000ba4 <__alt_mem_mem_0+0xfcfe0ba4>
 2002b88:	d8c02917 	ldw	r3,164(sp)
 2002b8c:	18c00084 	addi	r3,r3,2
 2002b90:	d8c02e15 	stw	r3,184(sp)
 2002b94:	1805883a 	mov	r2,r3
 2002b98:	183d960e 	bge	r3,zero,20021f4 <__alt_mem_mem_0+0xfcfe21f4>
 2002b9c:	003fd606 	br	2002af8 <__alt_mem_mem_0+0xfcfe2af8>
 2002ba0:	0005883a 	mov	r2,zero
 2002ba4:	003f8e06 	br	20029e0 <__alt_mem_mem_0+0xfcfe29e0>
 2002ba8:	9080004c 	andi	r2,r18,1
 2002bac:	103f811e 	bne	r2,zero,20029b4 <__alt_mem_mem_0+0xfcfe29b4>
 2002bb0:	d8802117 	ldw	r2,132(sp)
 2002bb4:	1405c83a 	sub	r2,r2,r16
 2002bb8:	d8803315 	stw	r2,204(sp)
 2002bbc:	b47ef326 	beq	r22,r17,200278c <__alt_mem_mem_0+0xfcfe278c>
 2002bc0:	dd802617 	ldw	r22,152(sp)
 2002bc4:	003f1106 	br	200280c <__alt_mem_mem_0+0xfcfe280c>
 2002bc8:	d9c02785 	stb	r7,158(sp)
 2002bcc:	00390406 	br	2000fe0 <__alt_mem_mem_0+0xfcfe0fe0>
 2002bd0:	d9c02785 	stb	r7,158(sp)
 2002bd4:	0038d306 	br	2000f24 <__alt_mem_mem_0+0xfcfe0f24>
 2002bd8:	d9c02785 	stb	r7,158(sp)
 2002bdc:	003a6106 	br	2001564 <__alt_mem_mem_0+0xfcfe1564>
 2002be0:	d9c02785 	stb	r7,158(sp)
 2002be4:	003af806 	br	20017c8 <__alt_mem_mem_0+0xfcfe17c8>
 2002be8:	0005883a 	mov	r2,zero
 2002bec:	003d7e06 	br	20021e8 <__alt_mem_mem_0+0xfcfe21e8>
 2002bf0:	d8802344 	addi	r2,sp,141
 2002bf4:	003f1306 	br	2002844 <__alt_mem_mem_0+0xfcfe2844>
 2002bf8:	d9c02785 	stb	r7,158(sp)
 2002bfc:	00392306 	br	200108c <__alt_mem_mem_0+0xfcfe108c>
 2002c00:	d9c02785 	stb	r7,158(sp)
 2002c04:	003aa906 	br	20016ac <__alt_mem_mem_0+0xfcfe16ac>
 2002c08:	d9c02785 	stb	r7,158(sp)
 2002c0c:	003a3d06 	br	2001504 <__alt_mem_mem_0+0xfcfe1504>
 2002c10:	d9c02785 	stb	r7,158(sp)
 2002c14:	003aca06 	br	2001740 <__alt_mem_mem_0+0xfcfe1740>

02002c18 <__vfprintf_internal>:
 2002c18:	00808174 	movhi	r2,517
 2002c1c:	10ab4004 	addi	r2,r2,-21248
 2002c20:	300f883a 	mov	r7,r6
 2002c24:	280d883a 	mov	r6,r5
 2002c28:	200b883a 	mov	r5,r4
 2002c2c:	11000017 	ldw	r4,0(r2)
 2002c30:	2000a201 	jmpi	2000a20 <___vfprintf_internal_r>

02002c34 <__sbprintf>:
 2002c34:	2880030b 	ldhu	r2,12(r5)
 2002c38:	2ac01917 	ldw	r11,100(r5)
 2002c3c:	2a80038b 	ldhu	r10,14(r5)
 2002c40:	2a400717 	ldw	r9,28(r5)
 2002c44:	2a000917 	ldw	r8,36(r5)
 2002c48:	defee204 	addi	sp,sp,-1144
 2002c4c:	00c10004 	movi	r3,1024
 2002c50:	dc011a15 	stw	r16,1128(sp)
 2002c54:	10bfff4c 	andi	r2,r2,65533
 2002c58:	2821883a 	mov	r16,r5
 2002c5c:	d8cb883a 	add	r5,sp,r3
 2002c60:	dc811c15 	stw	r18,1136(sp)
 2002c64:	dc411b15 	stw	r17,1132(sp)
 2002c68:	dfc11d15 	stw	ra,1140(sp)
 2002c6c:	2025883a 	mov	r18,r4
 2002c70:	d881030d 	sth	r2,1036(sp)
 2002c74:	dac11915 	stw	r11,1124(sp)
 2002c78:	da81038d 	sth	r10,1038(sp)
 2002c7c:	da410715 	stw	r9,1052(sp)
 2002c80:	da010915 	stw	r8,1060(sp)
 2002c84:	dec10015 	stw	sp,1024(sp)
 2002c88:	dec10415 	stw	sp,1040(sp)
 2002c8c:	d8c10215 	stw	r3,1032(sp)
 2002c90:	d8c10515 	stw	r3,1044(sp)
 2002c94:	d8010615 	stw	zero,1048(sp)
 2002c98:	2000a200 	call	2000a20 <___vfprintf_internal_r>
 2002c9c:	1023883a 	mov	r17,r2
 2002ca0:	10000416 	blt	r2,zero,2002cb4 <__sbprintf+0x80>
 2002ca4:	d9410004 	addi	r5,sp,1024
 2002ca8:	9009883a 	mov	r4,r18
 2002cac:	20048e80 	call	20048e8 <_fflush_r>
 2002cb0:	10000d1e 	bne	r2,zero,2002ce8 <__sbprintf+0xb4>
 2002cb4:	d881030b 	ldhu	r2,1036(sp)
 2002cb8:	1080100c 	andi	r2,r2,64
 2002cbc:	10000326 	beq	r2,zero,2002ccc <__sbprintf+0x98>
 2002cc0:	8080030b 	ldhu	r2,12(r16)
 2002cc4:	10801014 	ori	r2,r2,64
 2002cc8:	8080030d 	sth	r2,12(r16)
 2002ccc:	8805883a 	mov	r2,r17
 2002cd0:	dfc11d17 	ldw	ra,1140(sp)
 2002cd4:	dc811c17 	ldw	r18,1136(sp)
 2002cd8:	dc411b17 	ldw	r17,1132(sp)
 2002cdc:	dc011a17 	ldw	r16,1128(sp)
 2002ce0:	dec11e04 	addi	sp,sp,1144
 2002ce4:	f800283a 	ret
 2002ce8:	047fffc4 	movi	r17,-1
 2002cec:	003ff106 	br	2002cb4 <__alt_mem_mem_0+0xfcfe2cb4>

02002cf0 <__swsetup_r>:
 2002cf0:	00808174 	movhi	r2,517
 2002cf4:	defffd04 	addi	sp,sp,-12
 2002cf8:	10ab4004 	addi	r2,r2,-21248
 2002cfc:	dc400115 	stw	r17,4(sp)
 2002d00:	2023883a 	mov	r17,r4
 2002d04:	11000017 	ldw	r4,0(r2)
 2002d08:	dc000015 	stw	r16,0(sp)
 2002d0c:	dfc00215 	stw	ra,8(sp)
 2002d10:	2821883a 	mov	r16,r5
 2002d14:	20000226 	beq	r4,zero,2002d20 <__swsetup_r+0x30>
 2002d18:	20800e17 	ldw	r2,56(r4)
 2002d1c:	10003126 	beq	r2,zero,2002de4 <__swsetup_r+0xf4>
 2002d20:	8080030b 	ldhu	r2,12(r16)
 2002d24:	10c0020c 	andi	r3,r2,8
 2002d28:	1009883a 	mov	r4,r2
 2002d2c:	18000f26 	beq	r3,zero,2002d6c <__swsetup_r+0x7c>
 2002d30:	80c00417 	ldw	r3,16(r16)
 2002d34:	18001526 	beq	r3,zero,2002d8c <__swsetup_r+0x9c>
 2002d38:	1100004c 	andi	r4,r2,1
 2002d3c:	20001c1e 	bne	r4,zero,2002db0 <__swsetup_r+0xc0>
 2002d40:	1080008c 	andi	r2,r2,2
 2002d44:	1000291e 	bne	r2,zero,2002dec <__swsetup_r+0xfc>
 2002d48:	80800517 	ldw	r2,20(r16)
 2002d4c:	80800215 	stw	r2,8(r16)
 2002d50:	18001c26 	beq	r3,zero,2002dc4 <__swsetup_r+0xd4>
 2002d54:	0005883a 	mov	r2,zero
 2002d58:	dfc00217 	ldw	ra,8(sp)
 2002d5c:	dc400117 	ldw	r17,4(sp)
 2002d60:	dc000017 	ldw	r16,0(sp)
 2002d64:	dec00304 	addi	sp,sp,12
 2002d68:	f800283a 	ret
 2002d6c:	2080040c 	andi	r2,r4,16
 2002d70:	10002e26 	beq	r2,zero,2002e2c <__swsetup_r+0x13c>
 2002d74:	2080010c 	andi	r2,r4,4
 2002d78:	10001e1e 	bne	r2,zero,2002df4 <__swsetup_r+0x104>
 2002d7c:	80c00417 	ldw	r3,16(r16)
 2002d80:	20800214 	ori	r2,r4,8
 2002d84:	8080030d 	sth	r2,12(r16)
 2002d88:	183feb1e 	bne	r3,zero,2002d38 <__alt_mem_mem_0+0xfcfe2d38>
 2002d8c:	1100a00c 	andi	r4,r2,640
 2002d90:	01408004 	movi	r5,512
 2002d94:	217fe826 	beq	r4,r5,2002d38 <__alt_mem_mem_0+0xfcfe2d38>
 2002d98:	800b883a 	mov	r5,r16
 2002d9c:	8809883a 	mov	r4,r17
 2002da0:	20053ac0 	call	20053ac <__smakebuf_r>
 2002da4:	8080030b 	ldhu	r2,12(r16)
 2002da8:	80c00417 	ldw	r3,16(r16)
 2002dac:	003fe206 	br	2002d38 <__alt_mem_mem_0+0xfcfe2d38>
 2002db0:	80800517 	ldw	r2,20(r16)
 2002db4:	80000215 	stw	zero,8(r16)
 2002db8:	0085c83a 	sub	r2,zero,r2
 2002dbc:	80800615 	stw	r2,24(r16)
 2002dc0:	183fe41e 	bne	r3,zero,2002d54 <__alt_mem_mem_0+0xfcfe2d54>
 2002dc4:	80c0030b 	ldhu	r3,12(r16)
 2002dc8:	0005883a 	mov	r2,zero
 2002dcc:	1900200c 	andi	r4,r3,128
 2002dd0:	203fe126 	beq	r4,zero,2002d58 <__alt_mem_mem_0+0xfcfe2d58>
 2002dd4:	18c01014 	ori	r3,r3,64
 2002dd8:	80c0030d 	sth	r3,12(r16)
 2002ddc:	00bfffc4 	movi	r2,-1
 2002de0:	003fdd06 	br	2002d58 <__alt_mem_mem_0+0xfcfe2d58>
 2002de4:	2004cc40 	call	2004cc4 <__sinit>
 2002de8:	003fcd06 	br	2002d20 <__alt_mem_mem_0+0xfcfe2d20>
 2002dec:	0005883a 	mov	r2,zero
 2002df0:	003fd606 	br	2002d4c <__alt_mem_mem_0+0xfcfe2d4c>
 2002df4:	81400c17 	ldw	r5,48(r16)
 2002df8:	28000626 	beq	r5,zero,2002e14 <__swsetup_r+0x124>
 2002dfc:	80801004 	addi	r2,r16,64
 2002e00:	28800326 	beq	r5,r2,2002e10 <__swsetup_r+0x120>
 2002e04:	8809883a 	mov	r4,r17
 2002e08:	2004e380 	call	2004e38 <_free_r>
 2002e0c:	8100030b 	ldhu	r4,12(r16)
 2002e10:	80000c15 	stw	zero,48(r16)
 2002e14:	80c00417 	ldw	r3,16(r16)
 2002e18:	00bff6c4 	movi	r2,-37
 2002e1c:	1108703a 	and	r4,r2,r4
 2002e20:	80000115 	stw	zero,4(r16)
 2002e24:	80c00015 	stw	r3,0(r16)
 2002e28:	003fd506 	br	2002d80 <__alt_mem_mem_0+0xfcfe2d80>
 2002e2c:	00800244 	movi	r2,9
 2002e30:	88800015 	stw	r2,0(r17)
 2002e34:	20801014 	ori	r2,r4,64
 2002e38:	8080030d 	sth	r2,12(r16)
 2002e3c:	00bfffc4 	movi	r2,-1
 2002e40:	003fc506 	br	2002d58 <__alt_mem_mem_0+0xfcfe2d58>

02002e44 <quorem>:
 2002e44:	defff704 	addi	sp,sp,-36
 2002e48:	dc800215 	stw	r18,8(sp)
 2002e4c:	20800417 	ldw	r2,16(r4)
 2002e50:	2c800417 	ldw	r18,16(r5)
 2002e54:	dfc00815 	stw	ra,32(sp)
 2002e58:	ddc00715 	stw	r23,28(sp)
 2002e5c:	dd800615 	stw	r22,24(sp)
 2002e60:	dd400515 	stw	r21,20(sp)
 2002e64:	dd000415 	stw	r20,16(sp)
 2002e68:	dcc00315 	stw	r19,12(sp)
 2002e6c:	dc400115 	stw	r17,4(sp)
 2002e70:	dc000015 	stw	r16,0(sp)
 2002e74:	14807116 	blt	r2,r18,200303c <quorem+0x1f8>
 2002e78:	94bfffc4 	addi	r18,r18,-1
 2002e7c:	94ad883a 	add	r22,r18,r18
 2002e80:	b5ad883a 	add	r22,r22,r22
 2002e84:	2c400504 	addi	r17,r5,20
 2002e88:	8da9883a 	add	r20,r17,r22
 2002e8c:	25400504 	addi	r21,r4,20
 2002e90:	282f883a 	mov	r23,r5
 2002e94:	adad883a 	add	r22,r21,r22
 2002e98:	a1400017 	ldw	r5,0(r20)
 2002e9c:	2021883a 	mov	r16,r4
 2002ea0:	b1000017 	ldw	r4,0(r22)
 2002ea4:	29400044 	addi	r5,r5,1
 2002ea8:	200aadc0 	call	200aadc <__udivsi3>
 2002eac:	1027883a 	mov	r19,r2
 2002eb0:	10002c26 	beq	r2,zero,2002f64 <quorem+0x120>
 2002eb4:	a813883a 	mov	r9,r21
 2002eb8:	880b883a 	mov	r5,r17
 2002ebc:	0009883a 	mov	r4,zero
 2002ec0:	000d883a 	mov	r6,zero
 2002ec4:	2a000017 	ldw	r8,0(r5)
 2002ec8:	49c00017 	ldw	r7,0(r9)
 2002ecc:	29400104 	addi	r5,r5,4
 2002ed0:	40bfffcc 	andi	r2,r8,65535
 2002ed4:	14c5383a 	mul	r2,r2,r19
 2002ed8:	4010d43a 	srli	r8,r8,16
 2002edc:	38ffffcc 	andi	r3,r7,65535
 2002ee0:	1105883a 	add	r2,r2,r4
 2002ee4:	1008d43a 	srli	r4,r2,16
 2002ee8:	44d1383a 	mul	r8,r8,r19
 2002eec:	198d883a 	add	r6,r3,r6
 2002ef0:	10ffffcc 	andi	r3,r2,65535
 2002ef4:	30c7c83a 	sub	r3,r6,r3
 2002ef8:	380ed43a 	srli	r7,r7,16
 2002efc:	4105883a 	add	r2,r8,r4
 2002f00:	180dd43a 	srai	r6,r3,16
 2002f04:	113fffcc 	andi	r4,r2,65535
 2002f08:	390fc83a 	sub	r7,r7,r4
 2002f0c:	398d883a 	add	r6,r7,r6
 2002f10:	300e943a 	slli	r7,r6,16
 2002f14:	18ffffcc 	andi	r3,r3,65535
 2002f18:	1008d43a 	srli	r4,r2,16
 2002f1c:	38ceb03a 	or	r7,r7,r3
 2002f20:	49c00015 	stw	r7,0(r9)
 2002f24:	300dd43a 	srai	r6,r6,16
 2002f28:	4a400104 	addi	r9,r9,4
 2002f2c:	a17fe52e 	bgeu	r20,r5,2002ec4 <__alt_mem_mem_0+0xfcfe2ec4>
 2002f30:	b0800017 	ldw	r2,0(r22)
 2002f34:	10000b1e 	bne	r2,zero,2002f64 <quorem+0x120>
 2002f38:	b0bfff04 	addi	r2,r22,-4
 2002f3c:	a880082e 	bgeu	r21,r2,2002f60 <quorem+0x11c>
 2002f40:	b0ffff17 	ldw	r3,-4(r22)
 2002f44:	18000326 	beq	r3,zero,2002f54 <quorem+0x110>
 2002f48:	00000506 	br	2002f60 <quorem+0x11c>
 2002f4c:	10c00017 	ldw	r3,0(r2)
 2002f50:	1800031e 	bne	r3,zero,2002f60 <quorem+0x11c>
 2002f54:	10bfff04 	addi	r2,r2,-4
 2002f58:	94bfffc4 	addi	r18,r18,-1
 2002f5c:	a8bffb36 	bltu	r21,r2,2002f4c <__alt_mem_mem_0+0xfcfe2f4c>
 2002f60:	84800415 	stw	r18,16(r16)
 2002f64:	b80b883a 	mov	r5,r23
 2002f68:	8009883a 	mov	r4,r16
 2002f6c:	20069900 	call	2006990 <__mcmp>
 2002f70:	10002616 	blt	r2,zero,200300c <quorem+0x1c8>
 2002f74:	9cc00044 	addi	r19,r19,1
 2002f78:	a805883a 	mov	r2,r21
 2002f7c:	000b883a 	mov	r5,zero
 2002f80:	11000017 	ldw	r4,0(r2)
 2002f84:	89800017 	ldw	r6,0(r17)
 2002f88:	10800104 	addi	r2,r2,4
 2002f8c:	20ffffcc 	andi	r3,r4,65535
 2002f90:	194b883a 	add	r5,r3,r5
 2002f94:	30ffffcc 	andi	r3,r6,65535
 2002f98:	28c7c83a 	sub	r3,r5,r3
 2002f9c:	300cd43a 	srli	r6,r6,16
 2002fa0:	2008d43a 	srli	r4,r4,16
 2002fa4:	180bd43a 	srai	r5,r3,16
 2002fa8:	18ffffcc 	andi	r3,r3,65535
 2002fac:	2189c83a 	sub	r4,r4,r6
 2002fb0:	2149883a 	add	r4,r4,r5
 2002fb4:	200c943a 	slli	r6,r4,16
 2002fb8:	8c400104 	addi	r17,r17,4
 2002fbc:	200bd43a 	srai	r5,r4,16
 2002fc0:	30c6b03a 	or	r3,r6,r3
 2002fc4:	10ffff15 	stw	r3,-4(r2)
 2002fc8:	a47fed2e 	bgeu	r20,r17,2002f80 <__alt_mem_mem_0+0xfcfe2f80>
 2002fcc:	9485883a 	add	r2,r18,r18
 2002fd0:	1085883a 	add	r2,r2,r2
 2002fd4:	a887883a 	add	r3,r21,r2
 2002fd8:	18800017 	ldw	r2,0(r3)
 2002fdc:	10000b1e 	bne	r2,zero,200300c <quorem+0x1c8>
 2002fe0:	18bfff04 	addi	r2,r3,-4
 2002fe4:	a880082e 	bgeu	r21,r2,2003008 <quorem+0x1c4>
 2002fe8:	18ffff17 	ldw	r3,-4(r3)
 2002fec:	18000326 	beq	r3,zero,2002ffc <quorem+0x1b8>
 2002ff0:	00000506 	br	2003008 <quorem+0x1c4>
 2002ff4:	10c00017 	ldw	r3,0(r2)
 2002ff8:	1800031e 	bne	r3,zero,2003008 <quorem+0x1c4>
 2002ffc:	10bfff04 	addi	r2,r2,-4
 2003000:	94bfffc4 	addi	r18,r18,-1
 2003004:	a8bffb36 	bltu	r21,r2,2002ff4 <__alt_mem_mem_0+0xfcfe2ff4>
 2003008:	84800415 	stw	r18,16(r16)
 200300c:	9805883a 	mov	r2,r19
 2003010:	dfc00817 	ldw	ra,32(sp)
 2003014:	ddc00717 	ldw	r23,28(sp)
 2003018:	dd800617 	ldw	r22,24(sp)
 200301c:	dd400517 	ldw	r21,20(sp)
 2003020:	dd000417 	ldw	r20,16(sp)
 2003024:	dcc00317 	ldw	r19,12(sp)
 2003028:	dc800217 	ldw	r18,8(sp)
 200302c:	dc400117 	ldw	r17,4(sp)
 2003030:	dc000017 	ldw	r16,0(sp)
 2003034:	dec00904 	addi	sp,sp,36
 2003038:	f800283a 	ret
 200303c:	0005883a 	mov	r2,zero
 2003040:	003ff306 	br	2003010 <__alt_mem_mem_0+0xfcfe3010>

02003044 <_dtoa_r>:
 2003044:	20801017 	ldw	r2,64(r4)
 2003048:	deffde04 	addi	sp,sp,-136
 200304c:	df002015 	stw	fp,128(sp)
 2003050:	dcc01b15 	stw	r19,108(sp)
 2003054:	dc801a15 	stw	r18,104(sp)
 2003058:	dc401915 	stw	r17,100(sp)
 200305c:	dc001815 	stw	r16,96(sp)
 2003060:	dfc02115 	stw	ra,132(sp)
 2003064:	ddc01f15 	stw	r23,124(sp)
 2003068:	dd801e15 	stw	r22,120(sp)
 200306c:	dd401d15 	stw	r21,116(sp)
 2003070:	dd001c15 	stw	r20,112(sp)
 2003074:	d9c00315 	stw	r7,12(sp)
 2003078:	2039883a 	mov	fp,r4
 200307c:	3023883a 	mov	r17,r6
 2003080:	2825883a 	mov	r18,r5
 2003084:	dc002417 	ldw	r16,144(sp)
 2003088:	3027883a 	mov	r19,r6
 200308c:	10000826 	beq	r2,zero,20030b0 <_dtoa_r+0x6c>
 2003090:	21801117 	ldw	r6,68(r4)
 2003094:	00c00044 	movi	r3,1
 2003098:	100b883a 	mov	r5,r2
 200309c:	1986983a 	sll	r3,r3,r6
 20030a0:	11800115 	stw	r6,4(r2)
 20030a4:	10c00215 	stw	r3,8(r2)
 20030a8:	20061700 	call	2006170 <_Bfree>
 20030ac:	e0001015 	stw	zero,64(fp)
 20030b0:	88002e16 	blt	r17,zero,200316c <_dtoa_r+0x128>
 20030b4:	80000015 	stw	zero,0(r16)
 20030b8:	889ffc2c 	andhi	r2,r17,32752
 20030bc:	00dffc34 	movhi	r3,32752
 20030c0:	10c01c26 	beq	r2,r3,2003134 <_dtoa_r+0xf0>
 20030c4:	000d883a 	mov	r6,zero
 20030c8:	000f883a 	mov	r7,zero
 20030cc:	9009883a 	mov	r4,r18
 20030d0:	980b883a 	mov	r5,r19
 20030d4:	200bd2c0 	call	200bd2c <__eqdf2>
 20030d8:	10002b1e 	bne	r2,zero,2003188 <_dtoa_r+0x144>
 20030dc:	d9c02317 	ldw	r7,140(sp)
 20030e0:	00800044 	movi	r2,1
 20030e4:	38800015 	stw	r2,0(r7)
 20030e8:	d8802517 	ldw	r2,148(sp)
 20030ec:	10019e26 	beq	r2,zero,2003768 <_dtoa_r+0x724>
 20030f0:	d8c02517 	ldw	r3,148(sp)
 20030f4:	00808134 	movhi	r2,516
 20030f8:	109a8c44 	addi	r2,r2,27185
 20030fc:	18800015 	stw	r2,0(r3)
 2003100:	10bfffc4 	addi	r2,r2,-1
 2003104:	dfc02117 	ldw	ra,132(sp)
 2003108:	df002017 	ldw	fp,128(sp)
 200310c:	ddc01f17 	ldw	r23,124(sp)
 2003110:	dd801e17 	ldw	r22,120(sp)
 2003114:	dd401d17 	ldw	r21,116(sp)
 2003118:	dd001c17 	ldw	r20,112(sp)
 200311c:	dcc01b17 	ldw	r19,108(sp)
 2003120:	dc801a17 	ldw	r18,104(sp)
 2003124:	dc401917 	ldw	r17,100(sp)
 2003128:	dc001817 	ldw	r16,96(sp)
 200312c:	dec02204 	addi	sp,sp,136
 2003130:	f800283a 	ret
 2003134:	d8c02317 	ldw	r3,140(sp)
 2003138:	0089c3c4 	movi	r2,9999
 200313c:	18800015 	stw	r2,0(r3)
 2003140:	90017726 	beq	r18,zero,2003720 <_dtoa_r+0x6dc>
 2003144:	00808134 	movhi	r2,516
 2003148:	109a9804 	addi	r2,r2,27232
 200314c:	d9002517 	ldw	r4,148(sp)
 2003150:	203fec26 	beq	r4,zero,2003104 <__alt_mem_mem_0+0xfcfe3104>
 2003154:	10c000c7 	ldb	r3,3(r2)
 2003158:	1801781e 	bne	r3,zero,200373c <_dtoa_r+0x6f8>
 200315c:	10c000c4 	addi	r3,r2,3
 2003160:	d9802517 	ldw	r6,148(sp)
 2003164:	30c00015 	stw	r3,0(r6)
 2003168:	003fe606 	br	2003104 <__alt_mem_mem_0+0xfcfe3104>
 200316c:	04e00034 	movhi	r19,32768
 2003170:	9cffffc4 	addi	r19,r19,-1
 2003174:	00800044 	movi	r2,1
 2003178:	8ce6703a 	and	r19,r17,r19
 200317c:	80800015 	stw	r2,0(r16)
 2003180:	9823883a 	mov	r17,r19
 2003184:	003fcc06 	br	20030b8 <__alt_mem_mem_0+0xfcfe30b8>
 2003188:	d8800204 	addi	r2,sp,8
 200318c:	d8800015 	stw	r2,0(sp)
 2003190:	d9c00104 	addi	r7,sp,4
 2003194:	900b883a 	mov	r5,r18
 2003198:	980d883a 	mov	r6,r19
 200319c:	e009883a 	mov	r4,fp
 20031a0:	8820d53a 	srli	r16,r17,20
 20031a4:	2006d5c0 	call	2006d5c <__d2b>
 20031a8:	d8800915 	stw	r2,36(sp)
 20031ac:	8001651e 	bne	r16,zero,2003744 <_dtoa_r+0x700>
 20031b0:	dd800217 	ldw	r22,8(sp)
 20031b4:	dc000117 	ldw	r16,4(sp)
 20031b8:	00800804 	movi	r2,32
 20031bc:	b421883a 	add	r16,r22,r16
 20031c0:	80c10c84 	addi	r3,r16,1074
 20031c4:	10c2d10e 	bge	r2,r3,2003d0c <_dtoa_r+0xcc8>
 20031c8:	00801004 	movi	r2,64
 20031cc:	81010484 	addi	r4,r16,1042
 20031d0:	10c7c83a 	sub	r3,r2,r3
 20031d4:	9108d83a 	srl	r4,r18,r4
 20031d8:	88e2983a 	sll	r17,r17,r3
 20031dc:	2448b03a 	or	r4,r4,r17
 20031e0:	200d0f40 	call	200d0f4 <__floatunsidf>
 20031e4:	017f8434 	movhi	r5,65040
 20031e8:	01800044 	movi	r6,1
 20031ec:	1009883a 	mov	r4,r2
 20031f0:	194b883a 	add	r5,r3,r5
 20031f4:	843fffc4 	addi	r16,r16,-1
 20031f8:	d9801115 	stw	r6,68(sp)
 20031fc:	000d883a 	mov	r6,zero
 2003200:	01cffe34 	movhi	r7,16376
 2003204:	200c69c0 	call	200c69c <__subdf3>
 2003208:	0198dbf4 	movhi	r6,25455
 200320c:	01cff4f4 	movhi	r7,16339
 2003210:	3190d844 	addi	r6,r6,17249
 2003214:	39e1e9c4 	addi	r7,r7,-30809
 2003218:	1009883a 	mov	r4,r2
 200321c:	180b883a 	mov	r5,r3
 2003220:	200bf840 	call	200bf84 <__muldf3>
 2003224:	01a2d874 	movhi	r6,35681
 2003228:	01cff1f4 	movhi	r7,16327
 200322c:	31b22cc4 	addi	r6,r6,-14157
 2003230:	39e28a04 	addi	r7,r7,-30168
 2003234:	180b883a 	mov	r5,r3
 2003238:	1009883a 	mov	r4,r2
 200323c:	200ab980 	call	200ab98 <__adddf3>
 2003240:	8009883a 	mov	r4,r16
 2003244:	1029883a 	mov	r20,r2
 2003248:	1823883a 	mov	r17,r3
 200324c:	200d0180 	call	200d018 <__floatsidf>
 2003250:	019427f4 	movhi	r6,20639
 2003254:	01cff4f4 	movhi	r7,16339
 2003258:	319e7ec4 	addi	r6,r6,31227
 200325c:	39d104c4 	addi	r7,r7,17427
 2003260:	1009883a 	mov	r4,r2
 2003264:	180b883a 	mov	r5,r3
 2003268:	200bf840 	call	200bf84 <__muldf3>
 200326c:	100d883a 	mov	r6,r2
 2003270:	180f883a 	mov	r7,r3
 2003274:	a009883a 	mov	r4,r20
 2003278:	880b883a 	mov	r5,r17
 200327c:	200ab980 	call	200ab98 <__adddf3>
 2003280:	1009883a 	mov	r4,r2
 2003284:	180b883a 	mov	r5,r3
 2003288:	1029883a 	mov	r20,r2
 200328c:	1823883a 	mov	r17,r3
 2003290:	200cf980 	call	200cf98 <__fixdfsi>
 2003294:	000d883a 	mov	r6,zero
 2003298:	000f883a 	mov	r7,zero
 200329c:	a009883a 	mov	r4,r20
 20032a0:	880b883a 	mov	r5,r17
 20032a4:	d8800515 	stw	r2,20(sp)
 20032a8:	200be900 	call	200be90 <__ledf2>
 20032ac:	10028716 	blt	r2,zero,2003ccc <_dtoa_r+0xc88>
 20032b0:	d8c00517 	ldw	r3,20(sp)
 20032b4:	00800584 	movi	r2,22
 20032b8:	10c27536 	bltu	r2,r3,2003c90 <_dtoa_r+0xc4c>
 20032bc:	180490fa 	slli	r2,r3,3
 20032c0:	00c08134 	movhi	r3,516
 20032c4:	18dab404 	addi	r3,r3,27344
 20032c8:	1885883a 	add	r2,r3,r2
 20032cc:	11000017 	ldw	r4,0(r2)
 20032d0:	11400117 	ldw	r5,4(r2)
 20032d4:	900d883a 	mov	r6,r18
 20032d8:	980f883a 	mov	r7,r19
 20032dc:	200bdb40 	call	200bdb4 <__gedf2>
 20032e0:	00828d0e 	bge	zero,r2,2003d18 <_dtoa_r+0xcd4>
 20032e4:	d9000517 	ldw	r4,20(sp)
 20032e8:	d8000e15 	stw	zero,56(sp)
 20032ec:	213fffc4 	addi	r4,r4,-1
 20032f0:	d9000515 	stw	r4,20(sp)
 20032f4:	b42dc83a 	sub	r22,r22,r16
 20032f8:	b5bfffc4 	addi	r22,r22,-1
 20032fc:	b0026f16 	blt	r22,zero,2003cbc <_dtoa_r+0xc78>
 2003300:	d8000815 	stw	zero,32(sp)
 2003304:	d9c00517 	ldw	r7,20(sp)
 2003308:	38026416 	blt	r7,zero,2003c9c <_dtoa_r+0xc58>
 200330c:	b1ed883a 	add	r22,r22,r7
 2003310:	d9c00d15 	stw	r7,52(sp)
 2003314:	d8000a15 	stw	zero,40(sp)
 2003318:	d9800317 	ldw	r6,12(sp)
 200331c:	00800244 	movi	r2,9
 2003320:	11811436 	bltu	r2,r6,2003774 <_dtoa_r+0x730>
 2003324:	00800144 	movi	r2,5
 2003328:	1184e10e 	bge	r2,r6,20046b0 <_dtoa_r+0x166c>
 200332c:	31bfff04 	addi	r6,r6,-4
 2003330:	d9800315 	stw	r6,12(sp)
 2003334:	0023883a 	mov	r17,zero
 2003338:	d9800317 	ldw	r6,12(sp)
 200333c:	008000c4 	movi	r2,3
 2003340:	30836726 	beq	r6,r2,20040e0 <_dtoa_r+0x109c>
 2003344:	1183410e 	bge	r2,r6,200404c <_dtoa_r+0x1008>
 2003348:	d9c00317 	ldw	r7,12(sp)
 200334c:	00800104 	movi	r2,4
 2003350:	38827c26 	beq	r7,r2,2003d44 <_dtoa_r+0xd00>
 2003354:	00800144 	movi	r2,5
 2003358:	3884c41e 	bne	r7,r2,200466c <_dtoa_r+0x1628>
 200335c:	00800044 	movi	r2,1
 2003360:	d8800b15 	stw	r2,44(sp)
 2003364:	d8c00517 	ldw	r3,20(sp)
 2003368:	d9002217 	ldw	r4,136(sp)
 200336c:	1907883a 	add	r3,r3,r4
 2003370:	19800044 	addi	r6,r3,1
 2003374:	d8c00c15 	stw	r3,48(sp)
 2003378:	d9800615 	stw	r6,24(sp)
 200337c:	0183a40e 	bge	zero,r6,2004210 <_dtoa_r+0x11cc>
 2003380:	d9800617 	ldw	r6,24(sp)
 2003384:	3021883a 	mov	r16,r6
 2003388:	e0001115 	stw	zero,68(fp)
 200338c:	008005c4 	movi	r2,23
 2003390:	1184c92e 	bgeu	r2,r6,20046b8 <_dtoa_r+0x1674>
 2003394:	00c00044 	movi	r3,1
 2003398:	00800104 	movi	r2,4
 200339c:	1085883a 	add	r2,r2,r2
 20033a0:	11000504 	addi	r4,r2,20
 20033a4:	180b883a 	mov	r5,r3
 20033a8:	18c00044 	addi	r3,r3,1
 20033ac:	313ffb2e 	bgeu	r6,r4,200339c <__alt_mem_mem_0+0xfcfe339c>
 20033b0:	e1401115 	stw	r5,68(fp)
 20033b4:	e009883a 	mov	r4,fp
 20033b8:	20060c80 	call	20060c8 <_Balloc>
 20033bc:	d8800715 	stw	r2,28(sp)
 20033c0:	e0801015 	stw	r2,64(fp)
 20033c4:	00800384 	movi	r2,14
 20033c8:	1400f736 	bltu	r2,r16,20037a8 <_dtoa_r+0x764>
 20033cc:	8800f626 	beq	r17,zero,20037a8 <_dtoa_r+0x764>
 20033d0:	d9c00517 	ldw	r7,20(sp)
 20033d4:	01c39a0e 	bge	zero,r7,2004240 <_dtoa_r+0x11fc>
 20033d8:	388003cc 	andi	r2,r7,15
 20033dc:	100490fa 	slli	r2,r2,3
 20033e0:	382bd13a 	srai	r21,r7,4
 20033e4:	00c08134 	movhi	r3,516
 20033e8:	18dab404 	addi	r3,r3,27344
 20033ec:	1885883a 	add	r2,r3,r2
 20033f0:	a8c0040c 	andi	r3,r21,16
 20033f4:	12400017 	ldw	r9,0(r2)
 20033f8:	12000117 	ldw	r8,4(r2)
 20033fc:	18037926 	beq	r3,zero,20041e4 <_dtoa_r+0x11a0>
 2003400:	00808134 	movhi	r2,516
 2003404:	109aaa04 	addi	r2,r2,27304
 2003408:	11800817 	ldw	r6,32(r2)
 200340c:	11c00917 	ldw	r7,36(r2)
 2003410:	9009883a 	mov	r4,r18
 2003414:	980b883a 	mov	r5,r19
 2003418:	da001715 	stw	r8,92(sp)
 200341c:	da401615 	stw	r9,88(sp)
 2003420:	200b4440 	call	200b444 <__divdf3>
 2003424:	da001717 	ldw	r8,92(sp)
 2003428:	da401617 	ldw	r9,88(sp)
 200342c:	ad4003cc 	andi	r21,r21,15
 2003430:	040000c4 	movi	r16,3
 2003434:	1023883a 	mov	r17,r2
 2003438:	1829883a 	mov	r20,r3
 200343c:	a8001126 	beq	r21,zero,2003484 <_dtoa_r+0x440>
 2003440:	05c08134 	movhi	r23,516
 2003444:	bddaaa04 	addi	r23,r23,27304
 2003448:	4805883a 	mov	r2,r9
 200344c:	4007883a 	mov	r3,r8
 2003450:	a980004c 	andi	r6,r21,1
 2003454:	1009883a 	mov	r4,r2
 2003458:	a82bd07a 	srai	r21,r21,1
 200345c:	180b883a 	mov	r5,r3
 2003460:	30000426 	beq	r6,zero,2003474 <_dtoa_r+0x430>
 2003464:	b9800017 	ldw	r6,0(r23)
 2003468:	b9c00117 	ldw	r7,4(r23)
 200346c:	84000044 	addi	r16,r16,1
 2003470:	200bf840 	call	200bf84 <__muldf3>
 2003474:	bdc00204 	addi	r23,r23,8
 2003478:	a83ff51e 	bne	r21,zero,2003450 <__alt_mem_mem_0+0xfcfe3450>
 200347c:	1013883a 	mov	r9,r2
 2003480:	1811883a 	mov	r8,r3
 2003484:	480d883a 	mov	r6,r9
 2003488:	400f883a 	mov	r7,r8
 200348c:	8809883a 	mov	r4,r17
 2003490:	a00b883a 	mov	r5,r20
 2003494:	200b4440 	call	200b444 <__divdf3>
 2003498:	d8800f15 	stw	r2,60(sp)
 200349c:	d8c01015 	stw	r3,64(sp)
 20034a0:	d8c00e17 	ldw	r3,56(sp)
 20034a4:	18000626 	beq	r3,zero,20034c0 <_dtoa_r+0x47c>
 20034a8:	d9000f17 	ldw	r4,60(sp)
 20034ac:	d9401017 	ldw	r5,64(sp)
 20034b0:	000d883a 	mov	r6,zero
 20034b4:	01cffc34 	movhi	r7,16368
 20034b8:	200be900 	call	200be90 <__ledf2>
 20034bc:	10040b16 	blt	r2,zero,20044ec <_dtoa_r+0x14a8>
 20034c0:	8009883a 	mov	r4,r16
 20034c4:	200d0180 	call	200d018 <__floatsidf>
 20034c8:	d9800f17 	ldw	r6,60(sp)
 20034cc:	d9c01017 	ldw	r7,64(sp)
 20034d0:	1009883a 	mov	r4,r2
 20034d4:	180b883a 	mov	r5,r3
 20034d8:	200bf840 	call	200bf84 <__muldf3>
 20034dc:	000d883a 	mov	r6,zero
 20034e0:	01d00734 	movhi	r7,16412
 20034e4:	1009883a 	mov	r4,r2
 20034e8:	180b883a 	mov	r5,r3
 20034ec:	200ab980 	call	200ab98 <__adddf3>
 20034f0:	1021883a 	mov	r16,r2
 20034f4:	d8800617 	ldw	r2,24(sp)
 20034f8:	047f3034 	movhi	r17,64704
 20034fc:	1c63883a 	add	r17,r3,r17
 2003500:	10031826 	beq	r2,zero,2004164 <_dtoa_r+0x1120>
 2003504:	d8c00517 	ldw	r3,20(sp)
 2003508:	db000617 	ldw	r12,24(sp)
 200350c:	d8c01315 	stw	r3,76(sp)
 2003510:	d9000b17 	ldw	r4,44(sp)
 2003514:	20038f26 	beq	r4,zero,2004354 <_dtoa_r+0x1310>
 2003518:	60bfffc4 	addi	r2,r12,-1
 200351c:	100490fa 	slli	r2,r2,3
 2003520:	00c08134 	movhi	r3,516
 2003524:	18dab404 	addi	r3,r3,27344
 2003528:	1885883a 	add	r2,r3,r2
 200352c:	11800017 	ldw	r6,0(r2)
 2003530:	11c00117 	ldw	r7,4(r2)
 2003534:	d8800717 	ldw	r2,28(sp)
 2003538:	0009883a 	mov	r4,zero
 200353c:	014ff834 	movhi	r5,16352
 2003540:	db001615 	stw	r12,88(sp)
 2003544:	15c00044 	addi	r23,r2,1
 2003548:	200b4440 	call	200b444 <__divdf3>
 200354c:	800d883a 	mov	r6,r16
 2003550:	880f883a 	mov	r7,r17
 2003554:	1009883a 	mov	r4,r2
 2003558:	180b883a 	mov	r5,r3
 200355c:	200c69c0 	call	200c69c <__subdf3>
 2003560:	d9401017 	ldw	r5,64(sp)
 2003564:	d9000f17 	ldw	r4,60(sp)
 2003568:	102b883a 	mov	r21,r2
 200356c:	d8c01215 	stw	r3,72(sp)
 2003570:	200cf980 	call	200cf98 <__fixdfsi>
 2003574:	1009883a 	mov	r4,r2
 2003578:	1029883a 	mov	r20,r2
 200357c:	200d0180 	call	200d018 <__floatsidf>
 2003580:	d9000f17 	ldw	r4,60(sp)
 2003584:	d9401017 	ldw	r5,64(sp)
 2003588:	100d883a 	mov	r6,r2
 200358c:	180f883a 	mov	r7,r3
 2003590:	200c69c0 	call	200c69c <__subdf3>
 2003594:	1823883a 	mov	r17,r3
 2003598:	d8c00717 	ldw	r3,28(sp)
 200359c:	d9401217 	ldw	r5,72(sp)
 20035a0:	a2000c04 	addi	r8,r20,48
 20035a4:	1021883a 	mov	r16,r2
 20035a8:	1a000005 	stb	r8,0(r3)
 20035ac:	800d883a 	mov	r6,r16
 20035b0:	880f883a 	mov	r7,r17
 20035b4:	a809883a 	mov	r4,r21
 20035b8:	4029883a 	mov	r20,r8
 20035bc:	200bdb40 	call	200bdb4 <__gedf2>
 20035c0:	00841d16 	blt	zero,r2,2004638 <_dtoa_r+0x15f4>
 20035c4:	800d883a 	mov	r6,r16
 20035c8:	880f883a 	mov	r7,r17
 20035cc:	0009883a 	mov	r4,zero
 20035d0:	014ffc34 	movhi	r5,16368
 20035d4:	200c69c0 	call	200c69c <__subdf3>
 20035d8:	d9401217 	ldw	r5,72(sp)
 20035dc:	100d883a 	mov	r6,r2
 20035e0:	180f883a 	mov	r7,r3
 20035e4:	a809883a 	mov	r4,r21
 20035e8:	200bdb40 	call	200bdb4 <__gedf2>
 20035ec:	db001617 	ldw	r12,88(sp)
 20035f0:	00840e16 	blt	zero,r2,200462c <_dtoa_r+0x15e8>
 20035f4:	00800044 	movi	r2,1
 20035f8:	13006b0e 	bge	r2,r12,20037a8 <_dtoa_r+0x764>
 20035fc:	d9000717 	ldw	r4,28(sp)
 2003600:	dd800f15 	stw	r22,60(sp)
 2003604:	dcc01015 	stw	r19,64(sp)
 2003608:	2319883a 	add	r12,r4,r12
 200360c:	dcc01217 	ldw	r19,72(sp)
 2003610:	602d883a 	mov	r22,r12
 2003614:	dc801215 	stw	r18,72(sp)
 2003618:	b825883a 	mov	r18,r23
 200361c:	00000906 	br	2003644 <_dtoa_r+0x600>
 2003620:	200c69c0 	call	200c69c <__subdf3>
 2003624:	a80d883a 	mov	r6,r21
 2003628:	980f883a 	mov	r7,r19
 200362c:	1009883a 	mov	r4,r2
 2003630:	180b883a 	mov	r5,r3
 2003634:	200be900 	call	200be90 <__ledf2>
 2003638:	1003e816 	blt	r2,zero,20045dc <_dtoa_r+0x1598>
 200363c:	b825883a 	mov	r18,r23
 2003640:	bd83e926 	beq	r23,r22,20045e8 <_dtoa_r+0x15a4>
 2003644:	a809883a 	mov	r4,r21
 2003648:	980b883a 	mov	r5,r19
 200364c:	000d883a 	mov	r6,zero
 2003650:	01d00934 	movhi	r7,16420
 2003654:	200bf840 	call	200bf84 <__muldf3>
 2003658:	000d883a 	mov	r6,zero
 200365c:	01d00934 	movhi	r7,16420
 2003660:	8009883a 	mov	r4,r16
 2003664:	880b883a 	mov	r5,r17
 2003668:	102b883a 	mov	r21,r2
 200366c:	1827883a 	mov	r19,r3
 2003670:	200bf840 	call	200bf84 <__muldf3>
 2003674:	180b883a 	mov	r5,r3
 2003678:	1009883a 	mov	r4,r2
 200367c:	1821883a 	mov	r16,r3
 2003680:	1023883a 	mov	r17,r2
 2003684:	200cf980 	call	200cf98 <__fixdfsi>
 2003688:	1009883a 	mov	r4,r2
 200368c:	1029883a 	mov	r20,r2
 2003690:	200d0180 	call	200d018 <__floatsidf>
 2003694:	8809883a 	mov	r4,r17
 2003698:	800b883a 	mov	r5,r16
 200369c:	100d883a 	mov	r6,r2
 20036a0:	180f883a 	mov	r7,r3
 20036a4:	200c69c0 	call	200c69c <__subdf3>
 20036a8:	a5000c04 	addi	r20,r20,48
 20036ac:	a80d883a 	mov	r6,r21
 20036b0:	980f883a 	mov	r7,r19
 20036b4:	1009883a 	mov	r4,r2
 20036b8:	180b883a 	mov	r5,r3
 20036bc:	95000005 	stb	r20,0(r18)
 20036c0:	1021883a 	mov	r16,r2
 20036c4:	1823883a 	mov	r17,r3
 20036c8:	200be900 	call	200be90 <__ledf2>
 20036cc:	bdc00044 	addi	r23,r23,1
 20036d0:	800d883a 	mov	r6,r16
 20036d4:	880f883a 	mov	r7,r17
 20036d8:	0009883a 	mov	r4,zero
 20036dc:	014ffc34 	movhi	r5,16368
 20036e0:	103fcf0e 	bge	r2,zero,2003620 <__alt_mem_mem_0+0xfcfe3620>
 20036e4:	d8c01317 	ldw	r3,76(sp)
 20036e8:	d8c00515 	stw	r3,20(sp)
 20036ec:	d9400917 	ldw	r5,36(sp)
 20036f0:	e009883a 	mov	r4,fp
 20036f4:	20061700 	call	2006170 <_Bfree>
 20036f8:	d9000517 	ldw	r4,20(sp)
 20036fc:	d9802317 	ldw	r6,140(sp)
 2003700:	d9c02517 	ldw	r7,148(sp)
 2003704:	b8000005 	stb	zero,0(r23)
 2003708:	20800044 	addi	r2,r4,1
 200370c:	30800015 	stw	r2,0(r6)
 2003710:	3802aa26 	beq	r7,zero,20041bc <_dtoa_r+0x1178>
 2003714:	3dc00015 	stw	r23,0(r7)
 2003718:	d8800717 	ldw	r2,28(sp)
 200371c:	003e7906 	br	2003104 <__alt_mem_mem_0+0xfcfe3104>
 2003720:	00800434 	movhi	r2,16
 2003724:	10bfffc4 	addi	r2,r2,-1
 2003728:	88a2703a 	and	r17,r17,r2
 200372c:	883e851e 	bne	r17,zero,2003144 <__alt_mem_mem_0+0xfcfe3144>
 2003730:	00808134 	movhi	r2,516
 2003734:	109a9504 	addi	r2,r2,27220
 2003738:	003e8406 	br	200314c <__alt_mem_mem_0+0xfcfe314c>
 200373c:	10c00204 	addi	r3,r2,8
 2003740:	003e8706 	br	2003160 <__alt_mem_mem_0+0xfcfe3160>
 2003744:	01400434 	movhi	r5,16
 2003748:	297fffc4 	addi	r5,r5,-1
 200374c:	994a703a 	and	r5,r19,r5
 2003750:	9009883a 	mov	r4,r18
 2003754:	843f0044 	addi	r16,r16,-1023
 2003758:	294ffc34 	orhi	r5,r5,16368
 200375c:	dd800217 	ldw	r22,8(sp)
 2003760:	d8001115 	stw	zero,68(sp)
 2003764:	003ea506 	br	20031fc <__alt_mem_mem_0+0xfcfe31fc>
 2003768:	00808134 	movhi	r2,516
 200376c:	109a8c04 	addi	r2,r2,27184
 2003770:	003e6406 	br	2003104 <__alt_mem_mem_0+0xfcfe3104>
 2003774:	e0001115 	stw	zero,68(fp)
 2003778:	000b883a 	mov	r5,zero
 200377c:	e009883a 	mov	r4,fp
 2003780:	20060c80 	call	20060c8 <_Balloc>
 2003784:	01bfffc4 	movi	r6,-1
 2003788:	01c00044 	movi	r7,1
 200378c:	d8800715 	stw	r2,28(sp)
 2003790:	d9800c15 	stw	r6,48(sp)
 2003794:	e0801015 	stw	r2,64(fp)
 2003798:	d8000315 	stw	zero,12(sp)
 200379c:	d9c00b15 	stw	r7,44(sp)
 20037a0:	d9800615 	stw	r6,24(sp)
 20037a4:	d8002215 	stw	zero,136(sp)
 20037a8:	d8800117 	ldw	r2,4(sp)
 20037ac:	10008916 	blt	r2,zero,20039d4 <_dtoa_r+0x990>
 20037b0:	d9000517 	ldw	r4,20(sp)
 20037b4:	00c00384 	movi	r3,14
 20037b8:	19008616 	blt	r3,r4,20039d4 <_dtoa_r+0x990>
 20037bc:	200490fa 	slli	r2,r4,3
 20037c0:	00c08134 	movhi	r3,516
 20037c4:	d9802217 	ldw	r6,136(sp)
 20037c8:	18dab404 	addi	r3,r3,27344
 20037cc:	1885883a 	add	r2,r3,r2
 20037d0:	14000017 	ldw	r16,0(r2)
 20037d4:	14400117 	ldw	r17,4(r2)
 20037d8:	30016316 	blt	r6,zero,2003d68 <_dtoa_r+0xd24>
 20037dc:	800d883a 	mov	r6,r16
 20037e0:	880f883a 	mov	r7,r17
 20037e4:	9009883a 	mov	r4,r18
 20037e8:	980b883a 	mov	r5,r19
 20037ec:	200b4440 	call	200b444 <__divdf3>
 20037f0:	180b883a 	mov	r5,r3
 20037f4:	1009883a 	mov	r4,r2
 20037f8:	200cf980 	call	200cf98 <__fixdfsi>
 20037fc:	1009883a 	mov	r4,r2
 2003800:	102b883a 	mov	r21,r2
 2003804:	200d0180 	call	200d018 <__floatsidf>
 2003808:	800d883a 	mov	r6,r16
 200380c:	880f883a 	mov	r7,r17
 2003810:	1009883a 	mov	r4,r2
 2003814:	180b883a 	mov	r5,r3
 2003818:	200bf840 	call	200bf84 <__muldf3>
 200381c:	100d883a 	mov	r6,r2
 2003820:	180f883a 	mov	r7,r3
 2003824:	9009883a 	mov	r4,r18
 2003828:	980b883a 	mov	r5,r19
 200382c:	200c69c0 	call	200c69c <__subdf3>
 2003830:	d9c00717 	ldw	r7,28(sp)
 2003834:	1009883a 	mov	r4,r2
 2003838:	a8800c04 	addi	r2,r21,48
 200383c:	38800005 	stb	r2,0(r7)
 2003840:	3dc00044 	addi	r23,r7,1
 2003844:	d9c00617 	ldw	r7,24(sp)
 2003848:	01800044 	movi	r6,1
 200384c:	180b883a 	mov	r5,r3
 2003850:	2005883a 	mov	r2,r4
 2003854:	39803826 	beq	r7,r6,2003938 <_dtoa_r+0x8f4>
 2003858:	000d883a 	mov	r6,zero
 200385c:	01d00934 	movhi	r7,16420
 2003860:	200bf840 	call	200bf84 <__muldf3>
 2003864:	000d883a 	mov	r6,zero
 2003868:	000f883a 	mov	r7,zero
 200386c:	1009883a 	mov	r4,r2
 2003870:	180b883a 	mov	r5,r3
 2003874:	1025883a 	mov	r18,r2
 2003878:	1827883a 	mov	r19,r3
 200387c:	200bd2c0 	call	200bd2c <__eqdf2>
 2003880:	103f9a26 	beq	r2,zero,20036ec <__alt_mem_mem_0+0xfcfe36ec>
 2003884:	d9c00617 	ldw	r7,24(sp)
 2003888:	d8c00717 	ldw	r3,28(sp)
 200388c:	b829883a 	mov	r20,r23
 2003890:	38bfffc4 	addi	r2,r7,-1
 2003894:	18ad883a 	add	r22,r3,r2
 2003898:	00000a06 	br	20038c4 <_dtoa_r+0x880>
 200389c:	200bf840 	call	200bf84 <__muldf3>
 20038a0:	000d883a 	mov	r6,zero
 20038a4:	000f883a 	mov	r7,zero
 20038a8:	1009883a 	mov	r4,r2
 20038ac:	180b883a 	mov	r5,r3
 20038b0:	1025883a 	mov	r18,r2
 20038b4:	1827883a 	mov	r19,r3
 20038b8:	b829883a 	mov	r20,r23
 20038bc:	200bd2c0 	call	200bd2c <__eqdf2>
 20038c0:	103f8a26 	beq	r2,zero,20036ec <__alt_mem_mem_0+0xfcfe36ec>
 20038c4:	800d883a 	mov	r6,r16
 20038c8:	880f883a 	mov	r7,r17
 20038cc:	9009883a 	mov	r4,r18
 20038d0:	980b883a 	mov	r5,r19
 20038d4:	200b4440 	call	200b444 <__divdf3>
 20038d8:	180b883a 	mov	r5,r3
 20038dc:	1009883a 	mov	r4,r2
 20038e0:	200cf980 	call	200cf98 <__fixdfsi>
 20038e4:	1009883a 	mov	r4,r2
 20038e8:	102b883a 	mov	r21,r2
 20038ec:	200d0180 	call	200d018 <__floatsidf>
 20038f0:	800d883a 	mov	r6,r16
 20038f4:	880f883a 	mov	r7,r17
 20038f8:	1009883a 	mov	r4,r2
 20038fc:	180b883a 	mov	r5,r3
 2003900:	200bf840 	call	200bf84 <__muldf3>
 2003904:	100d883a 	mov	r6,r2
 2003908:	180f883a 	mov	r7,r3
 200390c:	9009883a 	mov	r4,r18
 2003910:	980b883a 	mov	r5,r19
 2003914:	200c69c0 	call	200c69c <__subdf3>
 2003918:	aa000c04 	addi	r8,r21,48
 200391c:	a2000005 	stb	r8,0(r20)
 2003920:	000d883a 	mov	r6,zero
 2003924:	01d00934 	movhi	r7,16420
 2003928:	1009883a 	mov	r4,r2
 200392c:	180b883a 	mov	r5,r3
 2003930:	a5c00044 	addi	r23,r20,1
 2003934:	b53fd91e 	bne	r22,r20,200389c <__alt_mem_mem_0+0xfcfe389c>
 2003938:	100d883a 	mov	r6,r2
 200393c:	180f883a 	mov	r7,r3
 2003940:	1009883a 	mov	r4,r2
 2003944:	180b883a 	mov	r5,r3
 2003948:	200ab980 	call	200ab98 <__adddf3>
 200394c:	100d883a 	mov	r6,r2
 2003950:	180f883a 	mov	r7,r3
 2003954:	8009883a 	mov	r4,r16
 2003958:	880b883a 	mov	r5,r17
 200395c:	1027883a 	mov	r19,r2
 2003960:	1825883a 	mov	r18,r3
 2003964:	200be900 	call	200be90 <__ledf2>
 2003968:	10000816 	blt	r2,zero,200398c <_dtoa_r+0x948>
 200396c:	980d883a 	mov	r6,r19
 2003970:	900f883a 	mov	r7,r18
 2003974:	8009883a 	mov	r4,r16
 2003978:	880b883a 	mov	r5,r17
 200397c:	200bd2c0 	call	200bd2c <__eqdf2>
 2003980:	103f5a1e 	bne	r2,zero,20036ec <__alt_mem_mem_0+0xfcfe36ec>
 2003984:	ad40004c 	andi	r21,r21,1
 2003988:	a83f5826 	beq	r21,zero,20036ec <__alt_mem_mem_0+0xfcfe36ec>
 200398c:	bd3fffc3 	ldbu	r20,-1(r23)
 2003990:	b8bfffc4 	addi	r2,r23,-1
 2003994:	1007883a 	mov	r3,r2
 2003998:	01400e44 	movi	r5,57
 200399c:	d9800717 	ldw	r6,28(sp)
 20039a0:	00000506 	br	20039b8 <_dtoa_r+0x974>
 20039a4:	18ffffc4 	addi	r3,r3,-1
 20039a8:	11824726 	beq	r2,r6,20042c8 <_dtoa_r+0x1284>
 20039ac:	1d000003 	ldbu	r20,0(r3)
 20039b0:	102f883a 	mov	r23,r2
 20039b4:	10bfffc4 	addi	r2,r2,-1
 20039b8:	a1003fcc 	andi	r4,r20,255
 20039bc:	2100201c 	xori	r4,r4,128
 20039c0:	213fe004 	addi	r4,r4,-128
 20039c4:	217ff726 	beq	r4,r5,20039a4 <__alt_mem_mem_0+0xfcfe39a4>
 20039c8:	a2000044 	addi	r8,r20,1
 20039cc:	12000005 	stb	r8,0(r2)
 20039d0:	003f4606 	br	20036ec <__alt_mem_mem_0+0xfcfe36ec>
 20039d4:	d9000b17 	ldw	r4,44(sp)
 20039d8:	2000c826 	beq	r4,zero,2003cfc <_dtoa_r+0xcb8>
 20039dc:	d9800317 	ldw	r6,12(sp)
 20039e0:	00c00044 	movi	r3,1
 20039e4:	1980f90e 	bge	r3,r6,2003dcc <_dtoa_r+0xd88>
 20039e8:	d8800617 	ldw	r2,24(sp)
 20039ec:	d8c00a17 	ldw	r3,40(sp)
 20039f0:	157fffc4 	addi	r21,r2,-1
 20039f4:	1d41f316 	blt	r3,r21,20041c4 <_dtoa_r+0x1180>
 20039f8:	1d6bc83a 	sub	r21,r3,r21
 20039fc:	d9c00617 	ldw	r7,24(sp)
 2003a00:	3802aa16 	blt	r7,zero,20044ac <_dtoa_r+0x1468>
 2003a04:	dd000817 	ldw	r20,32(sp)
 2003a08:	d8800617 	ldw	r2,24(sp)
 2003a0c:	d8c00817 	ldw	r3,32(sp)
 2003a10:	01400044 	movi	r5,1
 2003a14:	e009883a 	mov	r4,fp
 2003a18:	1887883a 	add	r3,r3,r2
 2003a1c:	d8c00815 	stw	r3,32(sp)
 2003a20:	b0ad883a 	add	r22,r22,r2
 2003a24:	20064d40 	call	20064d4 <__i2b>
 2003a28:	1023883a 	mov	r17,r2
 2003a2c:	a0000826 	beq	r20,zero,2003a50 <_dtoa_r+0xa0c>
 2003a30:	0580070e 	bge	zero,r22,2003a50 <_dtoa_r+0xa0c>
 2003a34:	a005883a 	mov	r2,r20
 2003a38:	b500b916 	blt	r22,r20,2003d20 <_dtoa_r+0xcdc>
 2003a3c:	d9000817 	ldw	r4,32(sp)
 2003a40:	a0a9c83a 	sub	r20,r20,r2
 2003a44:	b0adc83a 	sub	r22,r22,r2
 2003a48:	2089c83a 	sub	r4,r4,r2
 2003a4c:	d9000815 	stw	r4,32(sp)
 2003a50:	d9800a17 	ldw	r6,40(sp)
 2003a54:	0181810e 	bge	zero,r6,200405c <_dtoa_r+0x1018>
 2003a58:	d9c00b17 	ldw	r7,44(sp)
 2003a5c:	3800b326 	beq	r7,zero,2003d2c <_dtoa_r+0xce8>
 2003a60:	a800b226 	beq	r21,zero,2003d2c <_dtoa_r+0xce8>
 2003a64:	880b883a 	mov	r5,r17
 2003a68:	a80d883a 	mov	r6,r21
 2003a6c:	e009883a 	mov	r4,fp
 2003a70:	20067080 	call	2006708 <__pow5mult>
 2003a74:	d9800917 	ldw	r6,36(sp)
 2003a78:	100b883a 	mov	r5,r2
 2003a7c:	e009883a 	mov	r4,fp
 2003a80:	1023883a 	mov	r17,r2
 2003a84:	20065100 	call	2006510 <__multiply>
 2003a88:	1021883a 	mov	r16,r2
 2003a8c:	d8800a17 	ldw	r2,40(sp)
 2003a90:	d9400917 	ldw	r5,36(sp)
 2003a94:	e009883a 	mov	r4,fp
 2003a98:	1545c83a 	sub	r2,r2,r21
 2003a9c:	d8800a15 	stw	r2,40(sp)
 2003aa0:	20061700 	call	2006170 <_Bfree>
 2003aa4:	d8c00a17 	ldw	r3,40(sp)
 2003aa8:	18009f1e 	bne	r3,zero,2003d28 <_dtoa_r+0xce4>
 2003aac:	05c00044 	movi	r23,1
 2003ab0:	e009883a 	mov	r4,fp
 2003ab4:	b80b883a 	mov	r5,r23
 2003ab8:	20064d40 	call	20064d4 <__i2b>
 2003abc:	d9000d17 	ldw	r4,52(sp)
 2003ac0:	102b883a 	mov	r21,r2
 2003ac4:	2000ce26 	beq	r4,zero,2003e00 <_dtoa_r+0xdbc>
 2003ac8:	200d883a 	mov	r6,r4
 2003acc:	100b883a 	mov	r5,r2
 2003ad0:	e009883a 	mov	r4,fp
 2003ad4:	20067080 	call	2006708 <__pow5mult>
 2003ad8:	d9800317 	ldw	r6,12(sp)
 2003adc:	102b883a 	mov	r21,r2
 2003ae0:	b981810e 	bge	r23,r6,20040e8 <_dtoa_r+0x10a4>
 2003ae4:	0027883a 	mov	r19,zero
 2003ae8:	a8800417 	ldw	r2,16(r21)
 2003aec:	05c00804 	movi	r23,32
 2003af0:	10800104 	addi	r2,r2,4
 2003af4:	1085883a 	add	r2,r2,r2
 2003af8:	1085883a 	add	r2,r2,r2
 2003afc:	a885883a 	add	r2,r21,r2
 2003b00:	11000017 	ldw	r4,0(r2)
 2003b04:	20063bc0 	call	20063bc <__hi0bits>
 2003b08:	b885c83a 	sub	r2,r23,r2
 2003b0c:	1585883a 	add	r2,r2,r22
 2003b10:	108007cc 	andi	r2,r2,31
 2003b14:	1000b326 	beq	r2,zero,2003de4 <_dtoa_r+0xda0>
 2003b18:	00c00804 	movi	r3,32
 2003b1c:	1887c83a 	sub	r3,r3,r2
 2003b20:	01000104 	movi	r4,4
 2003b24:	20c2cd0e 	bge	r4,r3,200465c <_dtoa_r+0x1618>
 2003b28:	00c00704 	movi	r3,28
 2003b2c:	1885c83a 	sub	r2,r3,r2
 2003b30:	d8c00817 	ldw	r3,32(sp)
 2003b34:	a0a9883a 	add	r20,r20,r2
 2003b38:	b0ad883a 	add	r22,r22,r2
 2003b3c:	1887883a 	add	r3,r3,r2
 2003b40:	d8c00815 	stw	r3,32(sp)
 2003b44:	d9800817 	ldw	r6,32(sp)
 2003b48:	0180040e 	bge	zero,r6,2003b5c <_dtoa_r+0xb18>
 2003b4c:	800b883a 	mov	r5,r16
 2003b50:	e009883a 	mov	r4,fp
 2003b54:	20068480 	call	2006848 <__lshift>
 2003b58:	1021883a 	mov	r16,r2
 2003b5c:	0580050e 	bge	zero,r22,2003b74 <_dtoa_r+0xb30>
 2003b60:	a80b883a 	mov	r5,r21
 2003b64:	b00d883a 	mov	r6,r22
 2003b68:	e009883a 	mov	r4,fp
 2003b6c:	20068480 	call	2006848 <__lshift>
 2003b70:	102b883a 	mov	r21,r2
 2003b74:	d9c00e17 	ldw	r7,56(sp)
 2003b78:	3801211e 	bne	r7,zero,2004000 <_dtoa_r+0xfbc>
 2003b7c:	d9800617 	ldw	r6,24(sp)
 2003b80:	0181380e 	bge	zero,r6,2004064 <_dtoa_r+0x1020>
 2003b84:	d8c00b17 	ldw	r3,44(sp)
 2003b88:	1800ab1e 	bne	r3,zero,2003e38 <_dtoa_r+0xdf4>
 2003b8c:	dc800717 	ldw	r18,28(sp)
 2003b90:	dcc00617 	ldw	r19,24(sp)
 2003b94:	9029883a 	mov	r20,r18
 2003b98:	00000206 	br	2003ba4 <_dtoa_r+0xb60>
 2003b9c:	20061980 	call	2006198 <__multadd>
 2003ba0:	1021883a 	mov	r16,r2
 2003ba4:	a80b883a 	mov	r5,r21
 2003ba8:	8009883a 	mov	r4,r16
 2003bac:	2002e440 	call	2002e44 <quorem>
 2003bb0:	10800c04 	addi	r2,r2,48
 2003bb4:	90800005 	stb	r2,0(r18)
 2003bb8:	94800044 	addi	r18,r18,1
 2003bbc:	9507c83a 	sub	r3,r18,r20
 2003bc0:	000f883a 	mov	r7,zero
 2003bc4:	01800284 	movi	r6,10
 2003bc8:	800b883a 	mov	r5,r16
 2003bcc:	e009883a 	mov	r4,fp
 2003bd0:	1cfff216 	blt	r3,r19,2003b9c <__alt_mem_mem_0+0xfcfe3b9c>
 2003bd4:	1011883a 	mov	r8,r2
 2003bd8:	d8800617 	ldw	r2,24(sp)
 2003bdc:	0082370e 	bge	zero,r2,20044bc <_dtoa_r+0x1478>
 2003be0:	d9000717 	ldw	r4,28(sp)
 2003be4:	0025883a 	mov	r18,zero
 2003be8:	20af883a 	add	r23,r4,r2
 2003bec:	01800044 	movi	r6,1
 2003bf0:	800b883a 	mov	r5,r16
 2003bf4:	e009883a 	mov	r4,fp
 2003bf8:	da001715 	stw	r8,92(sp)
 2003bfc:	20068480 	call	2006848 <__lshift>
 2003c00:	a80b883a 	mov	r5,r21
 2003c04:	1009883a 	mov	r4,r2
 2003c08:	d8800915 	stw	r2,36(sp)
 2003c0c:	20069900 	call	2006990 <__mcmp>
 2003c10:	da001717 	ldw	r8,92(sp)
 2003c14:	0081800e 	bge	zero,r2,2004218 <_dtoa_r+0x11d4>
 2003c18:	b93fffc3 	ldbu	r4,-1(r23)
 2003c1c:	b8bfffc4 	addi	r2,r23,-1
 2003c20:	1007883a 	mov	r3,r2
 2003c24:	01800e44 	movi	r6,57
 2003c28:	d9c00717 	ldw	r7,28(sp)
 2003c2c:	00000506 	br	2003c44 <_dtoa_r+0xc00>
 2003c30:	18ffffc4 	addi	r3,r3,-1
 2003c34:	11c12326 	beq	r2,r7,20040c4 <_dtoa_r+0x1080>
 2003c38:	19000003 	ldbu	r4,0(r3)
 2003c3c:	102f883a 	mov	r23,r2
 2003c40:	10bfffc4 	addi	r2,r2,-1
 2003c44:	21403fcc 	andi	r5,r4,255
 2003c48:	2940201c 	xori	r5,r5,128
 2003c4c:	297fe004 	addi	r5,r5,-128
 2003c50:	29bff726 	beq	r5,r6,2003c30 <__alt_mem_mem_0+0xfcfe3c30>
 2003c54:	21000044 	addi	r4,r4,1
 2003c58:	11000005 	stb	r4,0(r2)
 2003c5c:	a80b883a 	mov	r5,r21
 2003c60:	e009883a 	mov	r4,fp
 2003c64:	20061700 	call	2006170 <_Bfree>
 2003c68:	883ea026 	beq	r17,zero,20036ec <__alt_mem_mem_0+0xfcfe36ec>
 2003c6c:	90000426 	beq	r18,zero,2003c80 <_dtoa_r+0xc3c>
 2003c70:	94400326 	beq	r18,r17,2003c80 <_dtoa_r+0xc3c>
 2003c74:	900b883a 	mov	r5,r18
 2003c78:	e009883a 	mov	r4,fp
 2003c7c:	20061700 	call	2006170 <_Bfree>
 2003c80:	880b883a 	mov	r5,r17
 2003c84:	e009883a 	mov	r4,fp
 2003c88:	20061700 	call	2006170 <_Bfree>
 2003c8c:	003e9706 	br	20036ec <__alt_mem_mem_0+0xfcfe36ec>
 2003c90:	01800044 	movi	r6,1
 2003c94:	d9800e15 	stw	r6,56(sp)
 2003c98:	003d9606 	br	20032f4 <__alt_mem_mem_0+0xfcfe32f4>
 2003c9c:	d8800817 	ldw	r2,32(sp)
 2003ca0:	d8c00517 	ldw	r3,20(sp)
 2003ca4:	d8000d15 	stw	zero,52(sp)
 2003ca8:	10c5c83a 	sub	r2,r2,r3
 2003cac:	00c9c83a 	sub	r4,zero,r3
 2003cb0:	d8800815 	stw	r2,32(sp)
 2003cb4:	d9000a15 	stw	r4,40(sp)
 2003cb8:	003d9706 	br	2003318 <__alt_mem_mem_0+0xfcfe3318>
 2003cbc:	05adc83a 	sub	r22,zero,r22
 2003cc0:	dd800815 	stw	r22,32(sp)
 2003cc4:	002d883a 	mov	r22,zero
 2003cc8:	003d8e06 	br	2003304 <__alt_mem_mem_0+0xfcfe3304>
 2003ccc:	d9000517 	ldw	r4,20(sp)
 2003cd0:	200d0180 	call	200d018 <__floatsidf>
 2003cd4:	100d883a 	mov	r6,r2
 2003cd8:	180f883a 	mov	r7,r3
 2003cdc:	a009883a 	mov	r4,r20
 2003ce0:	880b883a 	mov	r5,r17
 2003ce4:	200bd2c0 	call	200bd2c <__eqdf2>
 2003ce8:	103d7126 	beq	r2,zero,20032b0 <__alt_mem_mem_0+0xfcfe32b0>
 2003cec:	d9c00517 	ldw	r7,20(sp)
 2003cf0:	39ffffc4 	addi	r7,r7,-1
 2003cf4:	d9c00515 	stw	r7,20(sp)
 2003cf8:	003d6d06 	br	20032b0 <__alt_mem_mem_0+0xfcfe32b0>
 2003cfc:	dd400a17 	ldw	r21,40(sp)
 2003d00:	dd000817 	ldw	r20,32(sp)
 2003d04:	0023883a 	mov	r17,zero
 2003d08:	003f4806 	br	2003a2c <__alt_mem_mem_0+0xfcfe3a2c>
 2003d0c:	10e3c83a 	sub	r17,r2,r3
 2003d10:	9448983a 	sll	r4,r18,r17
 2003d14:	003d3206 	br	20031e0 <__alt_mem_mem_0+0xfcfe31e0>
 2003d18:	d8000e15 	stw	zero,56(sp)
 2003d1c:	003d7506 	br	20032f4 <__alt_mem_mem_0+0xfcfe32f4>
 2003d20:	b005883a 	mov	r2,r22
 2003d24:	003f4506 	br	2003a3c <__alt_mem_mem_0+0xfcfe3a3c>
 2003d28:	dc000915 	stw	r16,36(sp)
 2003d2c:	d9800a17 	ldw	r6,40(sp)
 2003d30:	d9400917 	ldw	r5,36(sp)
 2003d34:	e009883a 	mov	r4,fp
 2003d38:	20067080 	call	2006708 <__pow5mult>
 2003d3c:	1021883a 	mov	r16,r2
 2003d40:	003f5a06 	br	2003aac <__alt_mem_mem_0+0xfcfe3aac>
 2003d44:	01c00044 	movi	r7,1
 2003d48:	d9c00b15 	stw	r7,44(sp)
 2003d4c:	d8802217 	ldw	r2,136(sp)
 2003d50:	0081280e 	bge	zero,r2,20041f4 <_dtoa_r+0x11b0>
 2003d54:	100d883a 	mov	r6,r2
 2003d58:	1021883a 	mov	r16,r2
 2003d5c:	d8800c15 	stw	r2,48(sp)
 2003d60:	d8800615 	stw	r2,24(sp)
 2003d64:	003d8806 	br	2003388 <__alt_mem_mem_0+0xfcfe3388>
 2003d68:	d8800617 	ldw	r2,24(sp)
 2003d6c:	00be9b16 	blt	zero,r2,20037dc <__alt_mem_mem_0+0xfcfe37dc>
 2003d70:	10010f1e 	bne	r2,zero,20041b0 <_dtoa_r+0x116c>
 2003d74:	880b883a 	mov	r5,r17
 2003d78:	000d883a 	mov	r6,zero
 2003d7c:	01d00534 	movhi	r7,16404
 2003d80:	8009883a 	mov	r4,r16
 2003d84:	200bf840 	call	200bf84 <__muldf3>
 2003d88:	900d883a 	mov	r6,r18
 2003d8c:	980f883a 	mov	r7,r19
 2003d90:	1009883a 	mov	r4,r2
 2003d94:	180b883a 	mov	r5,r3
 2003d98:	200bdb40 	call	200bdb4 <__gedf2>
 2003d9c:	002b883a 	mov	r21,zero
 2003da0:	0023883a 	mov	r17,zero
 2003da4:	1000bf16 	blt	r2,zero,20040a4 <_dtoa_r+0x1060>
 2003da8:	d9802217 	ldw	r6,136(sp)
 2003dac:	ddc00717 	ldw	r23,28(sp)
 2003db0:	018c303a 	nor	r6,zero,r6
 2003db4:	d9800515 	stw	r6,20(sp)
 2003db8:	a80b883a 	mov	r5,r21
 2003dbc:	e009883a 	mov	r4,fp
 2003dc0:	20061700 	call	2006170 <_Bfree>
 2003dc4:	883e4926 	beq	r17,zero,20036ec <__alt_mem_mem_0+0xfcfe36ec>
 2003dc8:	003fad06 	br	2003c80 <__alt_mem_mem_0+0xfcfe3c80>
 2003dcc:	d9c01117 	ldw	r7,68(sp)
 2003dd0:	3801bc26 	beq	r7,zero,20044c4 <_dtoa_r+0x1480>
 2003dd4:	10810cc4 	addi	r2,r2,1075
 2003dd8:	dd400a17 	ldw	r21,40(sp)
 2003ddc:	dd000817 	ldw	r20,32(sp)
 2003de0:	003f0a06 	br	2003a0c <__alt_mem_mem_0+0xfcfe3a0c>
 2003de4:	00800704 	movi	r2,28
 2003de8:	d9000817 	ldw	r4,32(sp)
 2003dec:	a0a9883a 	add	r20,r20,r2
 2003df0:	b0ad883a 	add	r22,r22,r2
 2003df4:	2089883a 	add	r4,r4,r2
 2003df8:	d9000815 	stw	r4,32(sp)
 2003dfc:	003f5106 	br	2003b44 <__alt_mem_mem_0+0xfcfe3b44>
 2003e00:	d8c00317 	ldw	r3,12(sp)
 2003e04:	b8c1fc0e 	bge	r23,r3,20045f8 <_dtoa_r+0x15b4>
 2003e08:	0027883a 	mov	r19,zero
 2003e0c:	b805883a 	mov	r2,r23
 2003e10:	003f3e06 	br	2003b0c <__alt_mem_mem_0+0xfcfe3b0c>
 2003e14:	880b883a 	mov	r5,r17
 2003e18:	e009883a 	mov	r4,fp
 2003e1c:	000f883a 	mov	r7,zero
 2003e20:	01800284 	movi	r6,10
 2003e24:	20061980 	call	2006198 <__multadd>
 2003e28:	d9000c17 	ldw	r4,48(sp)
 2003e2c:	1023883a 	mov	r17,r2
 2003e30:	0102040e 	bge	zero,r4,2004644 <_dtoa_r+0x1600>
 2003e34:	d9000615 	stw	r4,24(sp)
 2003e38:	0500050e 	bge	zero,r20,2003e50 <_dtoa_r+0xe0c>
 2003e3c:	880b883a 	mov	r5,r17
 2003e40:	a00d883a 	mov	r6,r20
 2003e44:	e009883a 	mov	r4,fp
 2003e48:	20068480 	call	2006848 <__lshift>
 2003e4c:	1023883a 	mov	r17,r2
 2003e50:	9801241e 	bne	r19,zero,20042e4 <_dtoa_r+0x12a0>
 2003e54:	8829883a 	mov	r20,r17
 2003e58:	d9000617 	ldw	r4,24(sp)
 2003e5c:	dcc00717 	ldw	r19,28(sp)
 2003e60:	9480004c 	andi	r18,r18,1
 2003e64:	20bfffc4 	addi	r2,r4,-1
 2003e68:	9885883a 	add	r2,r19,r2
 2003e6c:	d8800415 	stw	r2,16(sp)
 2003e70:	dc800615 	stw	r18,24(sp)
 2003e74:	a80b883a 	mov	r5,r21
 2003e78:	8009883a 	mov	r4,r16
 2003e7c:	2002e440 	call	2002e44 <quorem>
 2003e80:	880b883a 	mov	r5,r17
 2003e84:	8009883a 	mov	r4,r16
 2003e88:	102f883a 	mov	r23,r2
 2003e8c:	20069900 	call	2006990 <__mcmp>
 2003e90:	a80b883a 	mov	r5,r21
 2003e94:	a00d883a 	mov	r6,r20
 2003e98:	e009883a 	mov	r4,fp
 2003e9c:	102d883a 	mov	r22,r2
 2003ea0:	20069f00 	call	20069f0 <__mdiff>
 2003ea4:	1007883a 	mov	r3,r2
 2003ea8:	10800317 	ldw	r2,12(r2)
 2003eac:	bc800c04 	addi	r18,r23,48
 2003eb0:	180b883a 	mov	r5,r3
 2003eb4:	10004e1e 	bne	r2,zero,2003ff0 <_dtoa_r+0xfac>
 2003eb8:	8009883a 	mov	r4,r16
 2003ebc:	d8c01615 	stw	r3,88(sp)
 2003ec0:	20069900 	call	2006990 <__mcmp>
 2003ec4:	d8c01617 	ldw	r3,88(sp)
 2003ec8:	e009883a 	mov	r4,fp
 2003ecc:	d8801615 	stw	r2,88(sp)
 2003ed0:	180b883a 	mov	r5,r3
 2003ed4:	20061700 	call	2006170 <_Bfree>
 2003ed8:	d8801617 	ldw	r2,88(sp)
 2003edc:	1000041e 	bne	r2,zero,2003ef0 <_dtoa_r+0xeac>
 2003ee0:	d9800317 	ldw	r6,12(sp)
 2003ee4:	3000021e 	bne	r6,zero,2003ef0 <_dtoa_r+0xeac>
 2003ee8:	d8c00617 	ldw	r3,24(sp)
 2003eec:	18003726 	beq	r3,zero,2003fcc <_dtoa_r+0xf88>
 2003ef0:	b0002016 	blt	r22,zero,2003f74 <_dtoa_r+0xf30>
 2003ef4:	b000041e 	bne	r22,zero,2003f08 <_dtoa_r+0xec4>
 2003ef8:	d9000317 	ldw	r4,12(sp)
 2003efc:	2000021e 	bne	r4,zero,2003f08 <_dtoa_r+0xec4>
 2003f00:	d8c00617 	ldw	r3,24(sp)
 2003f04:	18001b26 	beq	r3,zero,2003f74 <_dtoa_r+0xf30>
 2003f08:	00810716 	blt	zero,r2,2004328 <_dtoa_r+0x12e4>
 2003f0c:	d8c00417 	ldw	r3,16(sp)
 2003f10:	9d800044 	addi	r22,r19,1
 2003f14:	9c800005 	stb	r18,0(r19)
 2003f18:	b02f883a 	mov	r23,r22
 2003f1c:	98c10626 	beq	r19,r3,2004338 <_dtoa_r+0x12f4>
 2003f20:	800b883a 	mov	r5,r16
 2003f24:	000f883a 	mov	r7,zero
 2003f28:	01800284 	movi	r6,10
 2003f2c:	e009883a 	mov	r4,fp
 2003f30:	20061980 	call	2006198 <__multadd>
 2003f34:	1021883a 	mov	r16,r2
 2003f38:	000f883a 	mov	r7,zero
 2003f3c:	01800284 	movi	r6,10
 2003f40:	880b883a 	mov	r5,r17
 2003f44:	e009883a 	mov	r4,fp
 2003f48:	8d002526 	beq	r17,r20,2003fe0 <_dtoa_r+0xf9c>
 2003f4c:	20061980 	call	2006198 <__multadd>
 2003f50:	a00b883a 	mov	r5,r20
 2003f54:	000f883a 	mov	r7,zero
 2003f58:	01800284 	movi	r6,10
 2003f5c:	e009883a 	mov	r4,fp
 2003f60:	1023883a 	mov	r17,r2
 2003f64:	20061980 	call	2006198 <__multadd>
 2003f68:	1029883a 	mov	r20,r2
 2003f6c:	b027883a 	mov	r19,r22
 2003f70:	003fc006 	br	2003e74 <__alt_mem_mem_0+0xfcfe3e74>
 2003f74:	9011883a 	mov	r8,r18
 2003f78:	00800e0e 	bge	zero,r2,2003fb4 <_dtoa_r+0xf70>
 2003f7c:	800b883a 	mov	r5,r16
 2003f80:	01800044 	movi	r6,1
 2003f84:	e009883a 	mov	r4,fp
 2003f88:	da001715 	stw	r8,92(sp)
 2003f8c:	20068480 	call	2006848 <__lshift>
 2003f90:	a80b883a 	mov	r5,r21
 2003f94:	1009883a 	mov	r4,r2
 2003f98:	1021883a 	mov	r16,r2
 2003f9c:	20069900 	call	2006990 <__mcmp>
 2003fa0:	da001717 	ldw	r8,92(sp)
 2003fa4:	0081960e 	bge	zero,r2,2004600 <_dtoa_r+0x15bc>
 2003fa8:	00800e44 	movi	r2,57
 2003fac:	40817026 	beq	r8,r2,2004570 <_dtoa_r+0x152c>
 2003fb0:	ba000c44 	addi	r8,r23,49
 2003fb4:	8825883a 	mov	r18,r17
 2003fb8:	9dc00044 	addi	r23,r19,1
 2003fbc:	9a000005 	stb	r8,0(r19)
 2003fc0:	a023883a 	mov	r17,r20
 2003fc4:	dc000915 	stw	r16,36(sp)
 2003fc8:	003f2406 	br	2003c5c <__alt_mem_mem_0+0xfcfe3c5c>
 2003fcc:	00800e44 	movi	r2,57
 2003fd0:	9011883a 	mov	r8,r18
 2003fd4:	90816626 	beq	r18,r2,2004570 <_dtoa_r+0x152c>
 2003fd8:	05bff516 	blt	zero,r22,2003fb0 <__alt_mem_mem_0+0xfcfe3fb0>
 2003fdc:	003ff506 	br	2003fb4 <__alt_mem_mem_0+0xfcfe3fb4>
 2003fe0:	20061980 	call	2006198 <__multadd>
 2003fe4:	1023883a 	mov	r17,r2
 2003fe8:	1029883a 	mov	r20,r2
 2003fec:	003fdf06 	br	2003f6c <__alt_mem_mem_0+0xfcfe3f6c>
 2003ff0:	e009883a 	mov	r4,fp
 2003ff4:	20061700 	call	2006170 <_Bfree>
 2003ff8:	00800044 	movi	r2,1
 2003ffc:	003fbc06 	br	2003ef0 <__alt_mem_mem_0+0xfcfe3ef0>
 2004000:	a80b883a 	mov	r5,r21
 2004004:	8009883a 	mov	r4,r16
 2004008:	20069900 	call	2006990 <__mcmp>
 200400c:	103edb0e 	bge	r2,zero,2003b7c <__alt_mem_mem_0+0xfcfe3b7c>
 2004010:	800b883a 	mov	r5,r16
 2004014:	000f883a 	mov	r7,zero
 2004018:	01800284 	movi	r6,10
 200401c:	e009883a 	mov	r4,fp
 2004020:	20061980 	call	2006198 <__multadd>
 2004024:	1021883a 	mov	r16,r2
 2004028:	d8800517 	ldw	r2,20(sp)
 200402c:	d8c00b17 	ldw	r3,44(sp)
 2004030:	10bfffc4 	addi	r2,r2,-1
 2004034:	d8800515 	stw	r2,20(sp)
 2004038:	183f761e 	bne	r3,zero,2003e14 <__alt_mem_mem_0+0xfcfe3e14>
 200403c:	d9000c17 	ldw	r4,48(sp)
 2004040:	0101730e 	bge	zero,r4,2004610 <_dtoa_r+0x15cc>
 2004044:	d9000615 	stw	r4,24(sp)
 2004048:	003ed006 	br	2003b8c <__alt_mem_mem_0+0xfcfe3b8c>
 200404c:	00800084 	movi	r2,2
 2004050:	3081861e 	bne	r6,r2,200466c <_dtoa_r+0x1628>
 2004054:	d8000b15 	stw	zero,44(sp)
 2004058:	003f3c06 	br	2003d4c <__alt_mem_mem_0+0xfcfe3d4c>
 200405c:	dc000917 	ldw	r16,36(sp)
 2004060:	003e9206 	br	2003aac <__alt_mem_mem_0+0xfcfe3aac>
 2004064:	d9c00317 	ldw	r7,12(sp)
 2004068:	00800084 	movi	r2,2
 200406c:	11fec50e 	bge	r2,r7,2003b84 <__alt_mem_mem_0+0xfcfe3b84>
 2004070:	d9000617 	ldw	r4,24(sp)
 2004074:	20013c1e 	bne	r4,zero,2004568 <_dtoa_r+0x1524>
 2004078:	a80b883a 	mov	r5,r21
 200407c:	000f883a 	mov	r7,zero
 2004080:	01800144 	movi	r6,5
 2004084:	e009883a 	mov	r4,fp
 2004088:	20061980 	call	2006198 <__multadd>
 200408c:	100b883a 	mov	r5,r2
 2004090:	8009883a 	mov	r4,r16
 2004094:	102b883a 	mov	r21,r2
 2004098:	20069900 	call	2006990 <__mcmp>
 200409c:	dc000915 	stw	r16,36(sp)
 20040a0:	00bf410e 	bge	zero,r2,2003da8 <__alt_mem_mem_0+0xfcfe3da8>
 20040a4:	d9c00717 	ldw	r7,28(sp)
 20040a8:	00800c44 	movi	r2,49
 20040ac:	38800005 	stb	r2,0(r7)
 20040b0:	d8800517 	ldw	r2,20(sp)
 20040b4:	3dc00044 	addi	r23,r7,1
 20040b8:	10800044 	addi	r2,r2,1
 20040bc:	d8800515 	stw	r2,20(sp)
 20040c0:	003f3d06 	br	2003db8 <__alt_mem_mem_0+0xfcfe3db8>
 20040c4:	d9800517 	ldw	r6,20(sp)
 20040c8:	d9c00717 	ldw	r7,28(sp)
 20040cc:	00800c44 	movi	r2,49
 20040d0:	31800044 	addi	r6,r6,1
 20040d4:	d9800515 	stw	r6,20(sp)
 20040d8:	38800005 	stb	r2,0(r7)
 20040dc:	003edf06 	br	2003c5c <__alt_mem_mem_0+0xfcfe3c5c>
 20040e0:	d8000b15 	stw	zero,44(sp)
 20040e4:	003c9f06 	br	2003364 <__alt_mem_mem_0+0xfcfe3364>
 20040e8:	903e7e1e 	bne	r18,zero,2003ae4 <__alt_mem_mem_0+0xfcfe3ae4>
 20040ec:	00800434 	movhi	r2,16
 20040f0:	10bfffc4 	addi	r2,r2,-1
 20040f4:	9884703a 	and	r2,r19,r2
 20040f8:	1000ea1e 	bne	r2,zero,20044a4 <_dtoa_r+0x1460>
 20040fc:	9cdffc2c 	andhi	r19,r19,32752
 2004100:	9800e826 	beq	r19,zero,20044a4 <_dtoa_r+0x1460>
 2004104:	d9c00817 	ldw	r7,32(sp)
 2004108:	b5800044 	addi	r22,r22,1
 200410c:	04c00044 	movi	r19,1
 2004110:	39c00044 	addi	r7,r7,1
 2004114:	d9c00815 	stw	r7,32(sp)
 2004118:	d8800d17 	ldw	r2,52(sp)
 200411c:	103e721e 	bne	r2,zero,2003ae8 <__alt_mem_mem_0+0xfcfe3ae8>
 2004120:	00800044 	movi	r2,1
 2004124:	003e7906 	br	2003b0c <__alt_mem_mem_0+0xfcfe3b0c>
 2004128:	8009883a 	mov	r4,r16
 200412c:	200d0180 	call	200d018 <__floatsidf>
 2004130:	d9800f17 	ldw	r6,60(sp)
 2004134:	d9c01017 	ldw	r7,64(sp)
 2004138:	1009883a 	mov	r4,r2
 200413c:	180b883a 	mov	r5,r3
 2004140:	200bf840 	call	200bf84 <__muldf3>
 2004144:	000d883a 	mov	r6,zero
 2004148:	01d00734 	movhi	r7,16412
 200414c:	1009883a 	mov	r4,r2
 2004150:	180b883a 	mov	r5,r3
 2004154:	200ab980 	call	200ab98 <__adddf3>
 2004158:	047f3034 	movhi	r17,64704
 200415c:	1021883a 	mov	r16,r2
 2004160:	1c63883a 	add	r17,r3,r17
 2004164:	d9000f17 	ldw	r4,60(sp)
 2004168:	d9401017 	ldw	r5,64(sp)
 200416c:	000d883a 	mov	r6,zero
 2004170:	01d00534 	movhi	r7,16404
 2004174:	200c69c0 	call	200c69c <__subdf3>
 2004178:	800d883a 	mov	r6,r16
 200417c:	880f883a 	mov	r7,r17
 2004180:	1009883a 	mov	r4,r2
 2004184:	180b883a 	mov	r5,r3
 2004188:	102b883a 	mov	r21,r2
 200418c:	1829883a 	mov	r20,r3
 2004190:	200bdb40 	call	200bdb4 <__gedf2>
 2004194:	00806c16 	blt	zero,r2,2004348 <_dtoa_r+0x1304>
 2004198:	89e0003c 	xorhi	r7,r17,32768
 200419c:	800d883a 	mov	r6,r16
 20041a0:	a809883a 	mov	r4,r21
 20041a4:	a00b883a 	mov	r5,r20
 20041a8:	200be900 	call	200be90 <__ledf2>
 20041ac:	103d7e0e 	bge	r2,zero,20037a8 <__alt_mem_mem_0+0xfcfe37a8>
 20041b0:	002b883a 	mov	r21,zero
 20041b4:	0023883a 	mov	r17,zero
 20041b8:	003efb06 	br	2003da8 <__alt_mem_mem_0+0xfcfe3da8>
 20041bc:	d8800717 	ldw	r2,28(sp)
 20041c0:	003bd006 	br	2003104 <__alt_mem_mem_0+0xfcfe3104>
 20041c4:	d9000a17 	ldw	r4,40(sp)
 20041c8:	d9800d17 	ldw	r6,52(sp)
 20041cc:	dd400a15 	stw	r21,40(sp)
 20041d0:	a905c83a 	sub	r2,r21,r4
 20041d4:	308d883a 	add	r6,r6,r2
 20041d8:	d9800d15 	stw	r6,52(sp)
 20041dc:	002b883a 	mov	r21,zero
 20041e0:	003e0606 	br	20039fc <__alt_mem_mem_0+0xfcfe39fc>
 20041e4:	9023883a 	mov	r17,r18
 20041e8:	9829883a 	mov	r20,r19
 20041ec:	04000084 	movi	r16,2
 20041f0:	003c9206 	br	200343c <__alt_mem_mem_0+0xfcfe343c>
 20041f4:	04000044 	movi	r16,1
 20041f8:	dc000c15 	stw	r16,48(sp)
 20041fc:	dc000615 	stw	r16,24(sp)
 2004200:	dc002215 	stw	r16,136(sp)
 2004204:	e0001115 	stw	zero,68(fp)
 2004208:	000b883a 	mov	r5,zero
 200420c:	003c6906 	br	20033b4 <__alt_mem_mem_0+0xfcfe33b4>
 2004210:	3021883a 	mov	r16,r6
 2004214:	003ffb06 	br	2004204 <__alt_mem_mem_0+0xfcfe4204>
 2004218:	1000021e 	bne	r2,zero,2004224 <_dtoa_r+0x11e0>
 200421c:	4200004c 	andi	r8,r8,1
 2004220:	403e7d1e 	bne	r8,zero,2003c18 <__alt_mem_mem_0+0xfcfe3c18>
 2004224:	01000c04 	movi	r4,48
 2004228:	00000106 	br	2004230 <_dtoa_r+0x11ec>
 200422c:	102f883a 	mov	r23,r2
 2004230:	b8bfffc4 	addi	r2,r23,-1
 2004234:	10c00007 	ldb	r3,0(r2)
 2004238:	193ffc26 	beq	r3,r4,200422c <__alt_mem_mem_0+0xfcfe422c>
 200423c:	003e8706 	br	2003c5c <__alt_mem_mem_0+0xfcfe3c5c>
 2004240:	d8800517 	ldw	r2,20(sp)
 2004244:	00a3c83a 	sub	r17,zero,r2
 2004248:	8800a426 	beq	r17,zero,20044dc <_dtoa_r+0x1498>
 200424c:	888003cc 	andi	r2,r17,15
 2004250:	100490fa 	slli	r2,r2,3
 2004254:	00c08134 	movhi	r3,516
 2004258:	18dab404 	addi	r3,r3,27344
 200425c:	1885883a 	add	r2,r3,r2
 2004260:	11800017 	ldw	r6,0(r2)
 2004264:	11c00117 	ldw	r7,4(r2)
 2004268:	9009883a 	mov	r4,r18
 200426c:	980b883a 	mov	r5,r19
 2004270:	8823d13a 	srai	r17,r17,4
 2004274:	200bf840 	call	200bf84 <__muldf3>
 2004278:	d8800f15 	stw	r2,60(sp)
 200427c:	d8c01015 	stw	r3,64(sp)
 2004280:	8800e826 	beq	r17,zero,2004624 <_dtoa_r+0x15e0>
 2004284:	05008134 	movhi	r20,516
 2004288:	a51aaa04 	addi	r20,r20,27304
 200428c:	04000084 	movi	r16,2
 2004290:	8980004c 	andi	r6,r17,1
 2004294:	1009883a 	mov	r4,r2
 2004298:	8823d07a 	srai	r17,r17,1
 200429c:	180b883a 	mov	r5,r3
 20042a0:	30000426 	beq	r6,zero,20042b4 <_dtoa_r+0x1270>
 20042a4:	a1800017 	ldw	r6,0(r20)
 20042a8:	a1c00117 	ldw	r7,4(r20)
 20042ac:	84000044 	addi	r16,r16,1
 20042b0:	200bf840 	call	200bf84 <__muldf3>
 20042b4:	a5000204 	addi	r20,r20,8
 20042b8:	883ff51e 	bne	r17,zero,2004290 <__alt_mem_mem_0+0xfcfe4290>
 20042bc:	d8800f15 	stw	r2,60(sp)
 20042c0:	d8c01015 	stw	r3,64(sp)
 20042c4:	003c7606 	br	20034a0 <__alt_mem_mem_0+0xfcfe34a0>
 20042c8:	00c00c04 	movi	r3,48
 20042cc:	10c00005 	stb	r3,0(r2)
 20042d0:	d8c00517 	ldw	r3,20(sp)
 20042d4:	bd3fffc3 	ldbu	r20,-1(r23)
 20042d8:	18c00044 	addi	r3,r3,1
 20042dc:	d8c00515 	stw	r3,20(sp)
 20042e0:	003db906 	br	20039c8 <__alt_mem_mem_0+0xfcfe39c8>
 20042e4:	89400117 	ldw	r5,4(r17)
 20042e8:	e009883a 	mov	r4,fp
 20042ec:	20060c80 	call	20060c8 <_Balloc>
 20042f0:	89800417 	ldw	r6,16(r17)
 20042f4:	89400304 	addi	r5,r17,12
 20042f8:	11000304 	addi	r4,r2,12
 20042fc:	31800084 	addi	r6,r6,2
 2004300:	318d883a 	add	r6,r6,r6
 2004304:	318d883a 	add	r6,r6,r6
 2004308:	1027883a 	mov	r19,r2
 200430c:	2005e580 	call	2005e58 <memcpy>
 2004310:	01800044 	movi	r6,1
 2004314:	980b883a 	mov	r5,r19
 2004318:	e009883a 	mov	r4,fp
 200431c:	20068480 	call	2006848 <__lshift>
 2004320:	1029883a 	mov	r20,r2
 2004324:	003ecc06 	br	2003e58 <__alt_mem_mem_0+0xfcfe3e58>
 2004328:	00800e44 	movi	r2,57
 200432c:	90809026 	beq	r18,r2,2004570 <_dtoa_r+0x152c>
 2004330:	92000044 	addi	r8,r18,1
 2004334:	003f1f06 	br	2003fb4 <__alt_mem_mem_0+0xfcfe3fb4>
 2004338:	9011883a 	mov	r8,r18
 200433c:	8825883a 	mov	r18,r17
 2004340:	a023883a 	mov	r17,r20
 2004344:	003e2906 	br	2003bec <__alt_mem_mem_0+0xfcfe3bec>
 2004348:	002b883a 	mov	r21,zero
 200434c:	0023883a 	mov	r17,zero
 2004350:	003f5406 	br	20040a4 <__alt_mem_mem_0+0xfcfe40a4>
 2004354:	61bfffc4 	addi	r6,r12,-1
 2004358:	300490fa 	slli	r2,r6,3
 200435c:	00c08134 	movhi	r3,516
 2004360:	18dab404 	addi	r3,r3,27344
 2004364:	1885883a 	add	r2,r3,r2
 2004368:	11000017 	ldw	r4,0(r2)
 200436c:	11400117 	ldw	r5,4(r2)
 2004370:	d8800717 	ldw	r2,28(sp)
 2004374:	880f883a 	mov	r7,r17
 2004378:	d9801215 	stw	r6,72(sp)
 200437c:	800d883a 	mov	r6,r16
 2004380:	db001615 	stw	r12,88(sp)
 2004384:	15c00044 	addi	r23,r2,1
 2004388:	200bf840 	call	200bf84 <__muldf3>
 200438c:	d9401017 	ldw	r5,64(sp)
 2004390:	d9000f17 	ldw	r4,60(sp)
 2004394:	d8c01515 	stw	r3,84(sp)
 2004398:	d8801415 	stw	r2,80(sp)
 200439c:	200cf980 	call	200cf98 <__fixdfsi>
 20043a0:	1009883a 	mov	r4,r2
 20043a4:	1021883a 	mov	r16,r2
 20043a8:	200d0180 	call	200d018 <__floatsidf>
 20043ac:	d9000f17 	ldw	r4,60(sp)
 20043b0:	d9401017 	ldw	r5,64(sp)
 20043b4:	100d883a 	mov	r6,r2
 20043b8:	180f883a 	mov	r7,r3
 20043bc:	200c69c0 	call	200c69c <__subdf3>
 20043c0:	1829883a 	mov	r20,r3
 20043c4:	d8c00717 	ldw	r3,28(sp)
 20043c8:	84000c04 	addi	r16,r16,48
 20043cc:	1023883a 	mov	r17,r2
 20043d0:	1c000005 	stb	r16,0(r3)
 20043d4:	db001617 	ldw	r12,88(sp)
 20043d8:	00800044 	movi	r2,1
 20043dc:	60802226 	beq	r12,r2,2004468 <_dtoa_r+0x1424>
 20043e0:	d9c00717 	ldw	r7,28(sp)
 20043e4:	8805883a 	mov	r2,r17
 20043e8:	b82b883a 	mov	r21,r23
 20043ec:	3b19883a 	add	r12,r7,r12
 20043f0:	6023883a 	mov	r17,r12
 20043f4:	a007883a 	mov	r3,r20
 20043f8:	dc800f15 	stw	r18,60(sp)
 20043fc:	000d883a 	mov	r6,zero
 2004400:	01d00934 	movhi	r7,16420
 2004404:	1009883a 	mov	r4,r2
 2004408:	180b883a 	mov	r5,r3
 200440c:	200bf840 	call	200bf84 <__muldf3>
 2004410:	180b883a 	mov	r5,r3
 2004414:	1009883a 	mov	r4,r2
 2004418:	1829883a 	mov	r20,r3
 200441c:	1025883a 	mov	r18,r2
 2004420:	200cf980 	call	200cf98 <__fixdfsi>
 2004424:	1009883a 	mov	r4,r2
 2004428:	1021883a 	mov	r16,r2
 200442c:	200d0180 	call	200d018 <__floatsidf>
 2004430:	100d883a 	mov	r6,r2
 2004434:	180f883a 	mov	r7,r3
 2004438:	9009883a 	mov	r4,r18
 200443c:	a00b883a 	mov	r5,r20
 2004440:	84000c04 	addi	r16,r16,48
 2004444:	200c69c0 	call	200c69c <__subdf3>
 2004448:	ad400044 	addi	r21,r21,1
 200444c:	ac3fffc5 	stb	r16,-1(r21)
 2004450:	ac7fea1e 	bne	r21,r17,20043fc <__alt_mem_mem_0+0xfcfe43fc>
 2004454:	1023883a 	mov	r17,r2
 2004458:	d8801217 	ldw	r2,72(sp)
 200445c:	dc800f17 	ldw	r18,60(sp)
 2004460:	1829883a 	mov	r20,r3
 2004464:	b8af883a 	add	r23,r23,r2
 2004468:	d9001417 	ldw	r4,80(sp)
 200446c:	d9401517 	ldw	r5,84(sp)
 2004470:	000d883a 	mov	r6,zero
 2004474:	01cff834 	movhi	r7,16352
 2004478:	200ab980 	call	200ab98 <__adddf3>
 200447c:	880d883a 	mov	r6,r17
 2004480:	a00f883a 	mov	r7,r20
 2004484:	1009883a 	mov	r4,r2
 2004488:	180b883a 	mov	r5,r3
 200448c:	200be900 	call	200be90 <__ledf2>
 2004490:	10003e0e 	bge	r2,zero,200458c <_dtoa_r+0x1548>
 2004494:	d9001317 	ldw	r4,76(sp)
 2004498:	bd3fffc3 	ldbu	r20,-1(r23)
 200449c:	d9000515 	stw	r4,20(sp)
 20044a0:	003d3b06 	br	2003990 <__alt_mem_mem_0+0xfcfe3990>
 20044a4:	0027883a 	mov	r19,zero
 20044a8:	003f1b06 	br	2004118 <__alt_mem_mem_0+0xfcfe4118>
 20044ac:	d8800817 	ldw	r2,32(sp)
 20044b0:	11e9c83a 	sub	r20,r2,r7
 20044b4:	0005883a 	mov	r2,zero
 20044b8:	003d5406 	br	2003a0c <__alt_mem_mem_0+0xfcfe3a0c>
 20044bc:	00800044 	movi	r2,1
 20044c0:	003dc706 	br	2003be0 <__alt_mem_mem_0+0xfcfe3be0>
 20044c4:	d8c00217 	ldw	r3,8(sp)
 20044c8:	00800d84 	movi	r2,54
 20044cc:	dd400a17 	ldw	r21,40(sp)
 20044d0:	10c5c83a 	sub	r2,r2,r3
 20044d4:	dd000817 	ldw	r20,32(sp)
 20044d8:	003d4c06 	br	2003a0c <__alt_mem_mem_0+0xfcfe3a0c>
 20044dc:	dc800f15 	stw	r18,60(sp)
 20044e0:	dcc01015 	stw	r19,64(sp)
 20044e4:	04000084 	movi	r16,2
 20044e8:	003bed06 	br	20034a0 <__alt_mem_mem_0+0xfcfe34a0>
 20044ec:	d9000617 	ldw	r4,24(sp)
 20044f0:	203f0d26 	beq	r4,zero,2004128 <__alt_mem_mem_0+0xfcfe4128>
 20044f4:	d9800c17 	ldw	r6,48(sp)
 20044f8:	01bcab0e 	bge	zero,r6,20037a8 <__alt_mem_mem_0+0xfcfe37a8>
 20044fc:	d9401017 	ldw	r5,64(sp)
 2004500:	d9000f17 	ldw	r4,60(sp)
 2004504:	000d883a 	mov	r6,zero
 2004508:	01d00934 	movhi	r7,16420
 200450c:	200bf840 	call	200bf84 <__muldf3>
 2004510:	81000044 	addi	r4,r16,1
 2004514:	d8800f15 	stw	r2,60(sp)
 2004518:	d8c01015 	stw	r3,64(sp)
 200451c:	200d0180 	call	200d018 <__floatsidf>
 2004520:	d9800f17 	ldw	r6,60(sp)
 2004524:	d9c01017 	ldw	r7,64(sp)
 2004528:	1009883a 	mov	r4,r2
 200452c:	180b883a 	mov	r5,r3
 2004530:	200bf840 	call	200bf84 <__muldf3>
 2004534:	01d00734 	movhi	r7,16412
 2004538:	000d883a 	mov	r6,zero
 200453c:	1009883a 	mov	r4,r2
 2004540:	180b883a 	mov	r5,r3
 2004544:	200ab980 	call	200ab98 <__adddf3>
 2004548:	d9c00517 	ldw	r7,20(sp)
 200454c:	047f3034 	movhi	r17,64704
 2004550:	1021883a 	mov	r16,r2
 2004554:	39ffffc4 	addi	r7,r7,-1
 2004558:	d9c01315 	stw	r7,76(sp)
 200455c:	1c63883a 	add	r17,r3,r17
 2004560:	db000c17 	ldw	r12,48(sp)
 2004564:	003bea06 	br	2003510 <__alt_mem_mem_0+0xfcfe3510>
 2004568:	dc000915 	stw	r16,36(sp)
 200456c:	003e0e06 	br	2003da8 <__alt_mem_mem_0+0xfcfe3da8>
 2004570:	01000e44 	movi	r4,57
 2004574:	8825883a 	mov	r18,r17
 2004578:	9dc00044 	addi	r23,r19,1
 200457c:	99000005 	stb	r4,0(r19)
 2004580:	a023883a 	mov	r17,r20
 2004584:	dc000915 	stw	r16,36(sp)
 2004588:	003da406 	br	2003c1c <__alt_mem_mem_0+0xfcfe3c1c>
 200458c:	d9801417 	ldw	r6,80(sp)
 2004590:	d9c01517 	ldw	r7,84(sp)
 2004594:	0009883a 	mov	r4,zero
 2004598:	014ff834 	movhi	r5,16352
 200459c:	200c69c0 	call	200c69c <__subdf3>
 20045a0:	880d883a 	mov	r6,r17
 20045a4:	a00f883a 	mov	r7,r20
 20045a8:	1009883a 	mov	r4,r2
 20045ac:	180b883a 	mov	r5,r3
 20045b0:	200bdb40 	call	200bdb4 <__gedf2>
 20045b4:	00bc7c0e 	bge	zero,r2,20037a8 <__alt_mem_mem_0+0xfcfe37a8>
 20045b8:	01000c04 	movi	r4,48
 20045bc:	00000106 	br	20045c4 <_dtoa_r+0x1580>
 20045c0:	102f883a 	mov	r23,r2
 20045c4:	b8bfffc4 	addi	r2,r23,-1
 20045c8:	10c00007 	ldb	r3,0(r2)
 20045cc:	193ffc26 	beq	r3,r4,20045c0 <__alt_mem_mem_0+0xfcfe45c0>
 20045d0:	d9801317 	ldw	r6,76(sp)
 20045d4:	d9800515 	stw	r6,20(sp)
 20045d8:	003c4406 	br	20036ec <__alt_mem_mem_0+0xfcfe36ec>
 20045dc:	d9801317 	ldw	r6,76(sp)
 20045e0:	d9800515 	stw	r6,20(sp)
 20045e4:	003cea06 	br	2003990 <__alt_mem_mem_0+0xfcfe3990>
 20045e8:	dd800f17 	ldw	r22,60(sp)
 20045ec:	dcc01017 	ldw	r19,64(sp)
 20045f0:	dc801217 	ldw	r18,72(sp)
 20045f4:	003c6c06 	br	20037a8 <__alt_mem_mem_0+0xfcfe37a8>
 20045f8:	903e031e 	bne	r18,zero,2003e08 <__alt_mem_mem_0+0xfcfe3e08>
 20045fc:	003ebb06 	br	20040ec <__alt_mem_mem_0+0xfcfe40ec>
 2004600:	103e6c1e 	bne	r2,zero,2003fb4 <__alt_mem_mem_0+0xfcfe3fb4>
 2004604:	4080004c 	andi	r2,r8,1
 2004608:	103e6a26 	beq	r2,zero,2003fb4 <__alt_mem_mem_0+0xfcfe3fb4>
 200460c:	003e6606 	br	2003fa8 <__alt_mem_mem_0+0xfcfe3fa8>
 2004610:	d8c00317 	ldw	r3,12(sp)
 2004614:	00800084 	movi	r2,2
 2004618:	10c02916 	blt	r2,r3,20046c0 <_dtoa_r+0x167c>
 200461c:	d9000c17 	ldw	r4,48(sp)
 2004620:	003e8806 	br	2004044 <__alt_mem_mem_0+0xfcfe4044>
 2004624:	04000084 	movi	r16,2
 2004628:	003b9d06 	br	20034a0 <__alt_mem_mem_0+0xfcfe34a0>
 200462c:	d9001317 	ldw	r4,76(sp)
 2004630:	d9000515 	stw	r4,20(sp)
 2004634:	003cd606 	br	2003990 <__alt_mem_mem_0+0xfcfe3990>
 2004638:	d8801317 	ldw	r2,76(sp)
 200463c:	d8800515 	stw	r2,20(sp)
 2004640:	003c2a06 	br	20036ec <__alt_mem_mem_0+0xfcfe36ec>
 2004644:	d9800317 	ldw	r6,12(sp)
 2004648:	00800084 	movi	r2,2
 200464c:	11801516 	blt	r2,r6,20046a4 <_dtoa_r+0x1660>
 2004650:	d9c00c17 	ldw	r7,48(sp)
 2004654:	d9c00615 	stw	r7,24(sp)
 2004658:	003df706 	br	2003e38 <__alt_mem_mem_0+0xfcfe3e38>
 200465c:	193d3926 	beq	r3,r4,2003b44 <__alt_mem_mem_0+0xfcfe3b44>
 2004660:	00c00f04 	movi	r3,60
 2004664:	1885c83a 	sub	r2,r3,r2
 2004668:	003ddf06 	br	2003de8 <__alt_mem_mem_0+0xfcfe3de8>
 200466c:	e009883a 	mov	r4,fp
 2004670:	e0001115 	stw	zero,68(fp)
 2004674:	000b883a 	mov	r5,zero
 2004678:	20060c80 	call	20060c8 <_Balloc>
 200467c:	d8800715 	stw	r2,28(sp)
 2004680:	d8c00717 	ldw	r3,28(sp)
 2004684:	00bfffc4 	movi	r2,-1
 2004688:	01000044 	movi	r4,1
 200468c:	d8800c15 	stw	r2,48(sp)
 2004690:	e0c01015 	stw	r3,64(fp)
 2004694:	d9000b15 	stw	r4,44(sp)
 2004698:	d8800615 	stw	r2,24(sp)
 200469c:	d8002215 	stw	zero,136(sp)
 20046a0:	003c4106 	br	20037a8 <__alt_mem_mem_0+0xfcfe37a8>
 20046a4:	d8c00c17 	ldw	r3,48(sp)
 20046a8:	d8c00615 	stw	r3,24(sp)
 20046ac:	003e7006 	br	2004070 <__alt_mem_mem_0+0xfcfe4070>
 20046b0:	04400044 	movi	r17,1
 20046b4:	003b2006 	br	2003338 <__alt_mem_mem_0+0xfcfe3338>
 20046b8:	000b883a 	mov	r5,zero
 20046bc:	003b3d06 	br	20033b4 <__alt_mem_mem_0+0xfcfe33b4>
 20046c0:	d8800c17 	ldw	r2,48(sp)
 20046c4:	d8800615 	stw	r2,24(sp)
 20046c8:	003e6906 	br	2004070 <__alt_mem_mem_0+0xfcfe4070>

020046cc <__sflush_r>:
 20046cc:	2880030b 	ldhu	r2,12(r5)
 20046d0:	defffb04 	addi	sp,sp,-20
 20046d4:	dcc00315 	stw	r19,12(sp)
 20046d8:	dc400115 	stw	r17,4(sp)
 20046dc:	dfc00415 	stw	ra,16(sp)
 20046e0:	dc800215 	stw	r18,8(sp)
 20046e4:	dc000015 	stw	r16,0(sp)
 20046e8:	10c0020c 	andi	r3,r2,8
 20046ec:	2823883a 	mov	r17,r5
 20046f0:	2027883a 	mov	r19,r4
 20046f4:	1800311e 	bne	r3,zero,20047bc <__sflush_r+0xf0>
 20046f8:	28c00117 	ldw	r3,4(r5)
 20046fc:	10820014 	ori	r2,r2,2048
 2004700:	2880030d 	sth	r2,12(r5)
 2004704:	00c04b0e 	bge	zero,r3,2004834 <__sflush_r+0x168>
 2004708:	8a000a17 	ldw	r8,40(r17)
 200470c:	40002326 	beq	r8,zero,200479c <__sflush_r+0xd0>
 2004710:	9c000017 	ldw	r16,0(r19)
 2004714:	10c4000c 	andi	r3,r2,4096
 2004718:	98000015 	stw	zero,0(r19)
 200471c:	18004826 	beq	r3,zero,2004840 <__sflush_r+0x174>
 2004720:	89801417 	ldw	r6,80(r17)
 2004724:	10c0010c 	andi	r3,r2,4
 2004728:	18000626 	beq	r3,zero,2004744 <__sflush_r+0x78>
 200472c:	88c00117 	ldw	r3,4(r17)
 2004730:	88800c17 	ldw	r2,48(r17)
 2004734:	30cdc83a 	sub	r6,r6,r3
 2004738:	10000226 	beq	r2,zero,2004744 <__sflush_r+0x78>
 200473c:	88800f17 	ldw	r2,60(r17)
 2004740:	308dc83a 	sub	r6,r6,r2
 2004744:	89400717 	ldw	r5,28(r17)
 2004748:	000f883a 	mov	r7,zero
 200474c:	9809883a 	mov	r4,r19
 2004750:	403ee83a 	callr	r8
 2004754:	00ffffc4 	movi	r3,-1
 2004758:	10c04426 	beq	r2,r3,200486c <__sflush_r+0x1a0>
 200475c:	88c0030b 	ldhu	r3,12(r17)
 2004760:	89000417 	ldw	r4,16(r17)
 2004764:	88000115 	stw	zero,4(r17)
 2004768:	197dffcc 	andi	r5,r3,63487
 200476c:	8940030d 	sth	r5,12(r17)
 2004770:	89000015 	stw	r4,0(r17)
 2004774:	18c4000c 	andi	r3,r3,4096
 2004778:	18002c1e 	bne	r3,zero,200482c <__sflush_r+0x160>
 200477c:	89400c17 	ldw	r5,48(r17)
 2004780:	9c000015 	stw	r16,0(r19)
 2004784:	28000526 	beq	r5,zero,200479c <__sflush_r+0xd0>
 2004788:	88801004 	addi	r2,r17,64
 200478c:	28800226 	beq	r5,r2,2004798 <__sflush_r+0xcc>
 2004790:	9809883a 	mov	r4,r19
 2004794:	2004e380 	call	2004e38 <_free_r>
 2004798:	88000c15 	stw	zero,48(r17)
 200479c:	0005883a 	mov	r2,zero
 20047a0:	dfc00417 	ldw	ra,16(sp)
 20047a4:	dcc00317 	ldw	r19,12(sp)
 20047a8:	dc800217 	ldw	r18,8(sp)
 20047ac:	dc400117 	ldw	r17,4(sp)
 20047b0:	dc000017 	ldw	r16,0(sp)
 20047b4:	dec00504 	addi	sp,sp,20
 20047b8:	f800283a 	ret
 20047bc:	2c800417 	ldw	r18,16(r5)
 20047c0:	903ff626 	beq	r18,zero,200479c <__alt_mem_mem_0+0xfcfe479c>
 20047c4:	2c000017 	ldw	r16,0(r5)
 20047c8:	108000cc 	andi	r2,r2,3
 20047cc:	2c800015 	stw	r18,0(r5)
 20047d0:	84a1c83a 	sub	r16,r16,r18
 20047d4:	1000131e 	bne	r2,zero,2004824 <__sflush_r+0x158>
 20047d8:	28800517 	ldw	r2,20(r5)
 20047dc:	88800215 	stw	r2,8(r17)
 20047e0:	04000316 	blt	zero,r16,20047f0 <__sflush_r+0x124>
 20047e4:	003fed06 	br	200479c <__alt_mem_mem_0+0xfcfe479c>
 20047e8:	90a5883a 	add	r18,r18,r2
 20047ec:	043feb0e 	bge	zero,r16,200479c <__alt_mem_mem_0+0xfcfe479c>
 20047f0:	88800917 	ldw	r2,36(r17)
 20047f4:	89400717 	ldw	r5,28(r17)
 20047f8:	800f883a 	mov	r7,r16
 20047fc:	900d883a 	mov	r6,r18
 2004800:	9809883a 	mov	r4,r19
 2004804:	103ee83a 	callr	r2
 2004808:	80a1c83a 	sub	r16,r16,r2
 200480c:	00bff616 	blt	zero,r2,20047e8 <__alt_mem_mem_0+0xfcfe47e8>
 2004810:	88c0030b 	ldhu	r3,12(r17)
 2004814:	00bfffc4 	movi	r2,-1
 2004818:	18c01014 	ori	r3,r3,64
 200481c:	88c0030d 	sth	r3,12(r17)
 2004820:	003fdf06 	br	20047a0 <__alt_mem_mem_0+0xfcfe47a0>
 2004824:	0005883a 	mov	r2,zero
 2004828:	003fec06 	br	20047dc <__alt_mem_mem_0+0xfcfe47dc>
 200482c:	88801415 	stw	r2,80(r17)
 2004830:	003fd206 	br	200477c <__alt_mem_mem_0+0xfcfe477c>
 2004834:	28c00f17 	ldw	r3,60(r5)
 2004838:	00ffb316 	blt	zero,r3,2004708 <__alt_mem_mem_0+0xfcfe4708>
 200483c:	003fd706 	br	200479c <__alt_mem_mem_0+0xfcfe479c>
 2004840:	89400717 	ldw	r5,28(r17)
 2004844:	000d883a 	mov	r6,zero
 2004848:	01c00044 	movi	r7,1
 200484c:	9809883a 	mov	r4,r19
 2004850:	403ee83a 	callr	r8
 2004854:	100d883a 	mov	r6,r2
 2004858:	00bfffc4 	movi	r2,-1
 200485c:	30801426 	beq	r6,r2,20048b0 <__sflush_r+0x1e4>
 2004860:	8880030b 	ldhu	r2,12(r17)
 2004864:	8a000a17 	ldw	r8,40(r17)
 2004868:	003fae06 	br	2004724 <__alt_mem_mem_0+0xfcfe4724>
 200486c:	98c00017 	ldw	r3,0(r19)
 2004870:	183fba26 	beq	r3,zero,200475c <__alt_mem_mem_0+0xfcfe475c>
 2004874:	01000744 	movi	r4,29
 2004878:	19000626 	beq	r3,r4,2004894 <__sflush_r+0x1c8>
 200487c:	01000584 	movi	r4,22
 2004880:	19000426 	beq	r3,r4,2004894 <__sflush_r+0x1c8>
 2004884:	88c0030b 	ldhu	r3,12(r17)
 2004888:	18c01014 	ori	r3,r3,64
 200488c:	88c0030d 	sth	r3,12(r17)
 2004890:	003fc306 	br	20047a0 <__alt_mem_mem_0+0xfcfe47a0>
 2004894:	8880030b 	ldhu	r2,12(r17)
 2004898:	88c00417 	ldw	r3,16(r17)
 200489c:	88000115 	stw	zero,4(r17)
 20048a0:	10bdffcc 	andi	r2,r2,63487
 20048a4:	8880030d 	sth	r2,12(r17)
 20048a8:	88c00015 	stw	r3,0(r17)
 20048ac:	003fb306 	br	200477c <__alt_mem_mem_0+0xfcfe477c>
 20048b0:	98800017 	ldw	r2,0(r19)
 20048b4:	103fea26 	beq	r2,zero,2004860 <__alt_mem_mem_0+0xfcfe4860>
 20048b8:	00c00744 	movi	r3,29
 20048bc:	10c00226 	beq	r2,r3,20048c8 <__sflush_r+0x1fc>
 20048c0:	00c00584 	movi	r3,22
 20048c4:	10c0031e 	bne	r2,r3,20048d4 <__sflush_r+0x208>
 20048c8:	9c000015 	stw	r16,0(r19)
 20048cc:	0005883a 	mov	r2,zero
 20048d0:	003fb306 	br	20047a0 <__alt_mem_mem_0+0xfcfe47a0>
 20048d4:	88c0030b 	ldhu	r3,12(r17)
 20048d8:	3005883a 	mov	r2,r6
 20048dc:	18c01014 	ori	r3,r3,64
 20048e0:	88c0030d 	sth	r3,12(r17)
 20048e4:	003fae06 	br	20047a0 <__alt_mem_mem_0+0xfcfe47a0>

020048e8 <_fflush_r>:
 20048e8:	defffd04 	addi	sp,sp,-12
 20048ec:	dc000115 	stw	r16,4(sp)
 20048f0:	dfc00215 	stw	ra,8(sp)
 20048f4:	2021883a 	mov	r16,r4
 20048f8:	20000226 	beq	r4,zero,2004904 <_fflush_r+0x1c>
 20048fc:	20800e17 	ldw	r2,56(r4)
 2004900:	10000c26 	beq	r2,zero,2004934 <_fflush_r+0x4c>
 2004904:	2880030f 	ldh	r2,12(r5)
 2004908:	1000051e 	bne	r2,zero,2004920 <_fflush_r+0x38>
 200490c:	0005883a 	mov	r2,zero
 2004910:	dfc00217 	ldw	ra,8(sp)
 2004914:	dc000117 	ldw	r16,4(sp)
 2004918:	dec00304 	addi	sp,sp,12
 200491c:	f800283a 	ret
 2004920:	8009883a 	mov	r4,r16
 2004924:	dfc00217 	ldw	ra,8(sp)
 2004928:	dc000117 	ldw	r16,4(sp)
 200492c:	dec00304 	addi	sp,sp,12
 2004930:	20046cc1 	jmpi	20046cc <__sflush_r>
 2004934:	d9400015 	stw	r5,0(sp)
 2004938:	2004cc40 	call	2004cc4 <__sinit>
 200493c:	d9400017 	ldw	r5,0(sp)
 2004940:	003ff006 	br	2004904 <__alt_mem_mem_0+0xfcfe4904>

02004944 <fflush>:
 2004944:	20000526 	beq	r4,zero,200495c <fflush+0x18>
 2004948:	00808174 	movhi	r2,517
 200494c:	10ab4004 	addi	r2,r2,-21248
 2004950:	200b883a 	mov	r5,r4
 2004954:	11000017 	ldw	r4,0(r2)
 2004958:	20048e81 	jmpi	20048e8 <_fflush_r>
 200495c:	00808174 	movhi	r2,517
 2004960:	10ab3f04 	addi	r2,r2,-21252
 2004964:	11000017 	ldw	r4,0(r2)
 2004968:	01408034 	movhi	r5,512
 200496c:	29523a04 	addi	r5,r5,18664
 2004970:	200520c1 	jmpi	200520c <_fwalk_reent>

02004974 <__fp_unlock>:
 2004974:	0005883a 	mov	r2,zero
 2004978:	f800283a 	ret

0200497c <_cleanup_r>:
 200497c:	01408074 	movhi	r5,513
 2004980:	2962ff04 	addi	r5,r5,-29700
 2004984:	200520c1 	jmpi	200520c <_fwalk_reent>

02004988 <__sinit.part.1>:
 2004988:	defff704 	addi	sp,sp,-36
 200498c:	00c08034 	movhi	r3,512
 2004990:	dfc00815 	stw	ra,32(sp)
 2004994:	ddc00715 	stw	r23,28(sp)
 2004998:	dd800615 	stw	r22,24(sp)
 200499c:	dd400515 	stw	r21,20(sp)
 20049a0:	dd000415 	stw	r20,16(sp)
 20049a4:	dcc00315 	stw	r19,12(sp)
 20049a8:	dc800215 	stw	r18,8(sp)
 20049ac:	dc400115 	stw	r17,4(sp)
 20049b0:	dc000015 	stw	r16,0(sp)
 20049b4:	18d25f04 	addi	r3,r3,18812
 20049b8:	24000117 	ldw	r16,4(r4)
 20049bc:	20c00f15 	stw	r3,60(r4)
 20049c0:	2080bb04 	addi	r2,r4,748
 20049c4:	00c000c4 	movi	r3,3
 20049c8:	20c0b915 	stw	r3,740(r4)
 20049cc:	2080ba15 	stw	r2,744(r4)
 20049d0:	2000b815 	stw	zero,736(r4)
 20049d4:	05c00204 	movi	r23,8
 20049d8:	00800104 	movi	r2,4
 20049dc:	2025883a 	mov	r18,r4
 20049e0:	b80d883a 	mov	r6,r23
 20049e4:	81001704 	addi	r4,r16,92
 20049e8:	000b883a 	mov	r5,zero
 20049ec:	80000015 	stw	zero,0(r16)
 20049f0:	80000115 	stw	zero,4(r16)
 20049f4:	80000215 	stw	zero,8(r16)
 20049f8:	8080030d 	sth	r2,12(r16)
 20049fc:	80001915 	stw	zero,100(r16)
 2004a00:	8000038d 	sth	zero,14(r16)
 2004a04:	80000415 	stw	zero,16(r16)
 2004a08:	80000515 	stw	zero,20(r16)
 2004a0c:	80000615 	stw	zero,24(r16)
 2004a10:	2005fa00 	call	2005fa0 <memset>
 2004a14:	05808034 	movhi	r22,512
 2004a18:	94400217 	ldw	r17,8(r18)
 2004a1c:	05408034 	movhi	r21,512
 2004a20:	05008034 	movhi	r20,512
 2004a24:	04c08034 	movhi	r19,512
 2004a28:	b59c6304 	addi	r22,r22,29068
 2004a2c:	ad5c7a04 	addi	r21,r21,29160
 2004a30:	a51c9904 	addi	r20,r20,29284
 2004a34:	9cdcb004 	addi	r19,r19,29376
 2004a38:	85800815 	stw	r22,32(r16)
 2004a3c:	85400915 	stw	r21,36(r16)
 2004a40:	85000a15 	stw	r20,40(r16)
 2004a44:	84c00b15 	stw	r19,44(r16)
 2004a48:	84000715 	stw	r16,28(r16)
 2004a4c:	00800284 	movi	r2,10
 2004a50:	8880030d 	sth	r2,12(r17)
 2004a54:	00800044 	movi	r2,1
 2004a58:	b80d883a 	mov	r6,r23
 2004a5c:	89001704 	addi	r4,r17,92
 2004a60:	000b883a 	mov	r5,zero
 2004a64:	88000015 	stw	zero,0(r17)
 2004a68:	88000115 	stw	zero,4(r17)
 2004a6c:	88000215 	stw	zero,8(r17)
 2004a70:	88001915 	stw	zero,100(r17)
 2004a74:	8880038d 	sth	r2,14(r17)
 2004a78:	88000415 	stw	zero,16(r17)
 2004a7c:	88000515 	stw	zero,20(r17)
 2004a80:	88000615 	stw	zero,24(r17)
 2004a84:	2005fa00 	call	2005fa0 <memset>
 2004a88:	94000317 	ldw	r16,12(r18)
 2004a8c:	00800484 	movi	r2,18
 2004a90:	8c400715 	stw	r17,28(r17)
 2004a94:	8d800815 	stw	r22,32(r17)
 2004a98:	8d400915 	stw	r21,36(r17)
 2004a9c:	8d000a15 	stw	r20,40(r17)
 2004aa0:	8cc00b15 	stw	r19,44(r17)
 2004aa4:	8080030d 	sth	r2,12(r16)
 2004aa8:	00800084 	movi	r2,2
 2004aac:	80000015 	stw	zero,0(r16)
 2004ab0:	80000115 	stw	zero,4(r16)
 2004ab4:	80000215 	stw	zero,8(r16)
 2004ab8:	80001915 	stw	zero,100(r16)
 2004abc:	8080038d 	sth	r2,14(r16)
 2004ac0:	80000415 	stw	zero,16(r16)
 2004ac4:	80000515 	stw	zero,20(r16)
 2004ac8:	80000615 	stw	zero,24(r16)
 2004acc:	b80d883a 	mov	r6,r23
 2004ad0:	000b883a 	mov	r5,zero
 2004ad4:	81001704 	addi	r4,r16,92
 2004ad8:	2005fa00 	call	2005fa0 <memset>
 2004adc:	00800044 	movi	r2,1
 2004ae0:	84000715 	stw	r16,28(r16)
 2004ae4:	85800815 	stw	r22,32(r16)
 2004ae8:	85400915 	stw	r21,36(r16)
 2004aec:	85000a15 	stw	r20,40(r16)
 2004af0:	84c00b15 	stw	r19,44(r16)
 2004af4:	90800e15 	stw	r2,56(r18)
 2004af8:	dfc00817 	ldw	ra,32(sp)
 2004afc:	ddc00717 	ldw	r23,28(sp)
 2004b00:	dd800617 	ldw	r22,24(sp)
 2004b04:	dd400517 	ldw	r21,20(sp)
 2004b08:	dd000417 	ldw	r20,16(sp)
 2004b0c:	dcc00317 	ldw	r19,12(sp)
 2004b10:	dc800217 	ldw	r18,8(sp)
 2004b14:	dc400117 	ldw	r17,4(sp)
 2004b18:	dc000017 	ldw	r16,0(sp)
 2004b1c:	dec00904 	addi	sp,sp,36
 2004b20:	f800283a 	ret

02004b24 <__fp_lock>:
 2004b24:	0005883a 	mov	r2,zero
 2004b28:	f800283a 	ret

02004b2c <__sfmoreglue>:
 2004b2c:	defffc04 	addi	sp,sp,-16
 2004b30:	dc400115 	stw	r17,4(sp)
 2004b34:	2c7fffc4 	addi	r17,r5,-1
 2004b38:	8c401a24 	muli	r17,r17,104
 2004b3c:	dc800215 	stw	r18,8(sp)
 2004b40:	2825883a 	mov	r18,r5
 2004b44:	89401d04 	addi	r5,r17,116
 2004b48:	dc000015 	stw	r16,0(sp)
 2004b4c:	dfc00315 	stw	ra,12(sp)
 2004b50:	20055680 	call	2005568 <_malloc_r>
 2004b54:	1021883a 	mov	r16,r2
 2004b58:	10000726 	beq	r2,zero,2004b78 <__sfmoreglue+0x4c>
 2004b5c:	11000304 	addi	r4,r2,12
 2004b60:	10000015 	stw	zero,0(r2)
 2004b64:	14800115 	stw	r18,4(r2)
 2004b68:	11000215 	stw	r4,8(r2)
 2004b6c:	89801a04 	addi	r6,r17,104
 2004b70:	000b883a 	mov	r5,zero
 2004b74:	2005fa00 	call	2005fa0 <memset>
 2004b78:	8005883a 	mov	r2,r16
 2004b7c:	dfc00317 	ldw	ra,12(sp)
 2004b80:	dc800217 	ldw	r18,8(sp)
 2004b84:	dc400117 	ldw	r17,4(sp)
 2004b88:	dc000017 	ldw	r16,0(sp)
 2004b8c:	dec00404 	addi	sp,sp,16
 2004b90:	f800283a 	ret

02004b94 <__sfp>:
 2004b94:	defffb04 	addi	sp,sp,-20
 2004b98:	dc000015 	stw	r16,0(sp)
 2004b9c:	04008174 	movhi	r16,517
 2004ba0:	842b3f04 	addi	r16,r16,-21252
 2004ba4:	dcc00315 	stw	r19,12(sp)
 2004ba8:	2027883a 	mov	r19,r4
 2004bac:	81000017 	ldw	r4,0(r16)
 2004bb0:	dfc00415 	stw	ra,16(sp)
 2004bb4:	dc800215 	stw	r18,8(sp)
 2004bb8:	20800e17 	ldw	r2,56(r4)
 2004bbc:	dc400115 	stw	r17,4(sp)
 2004bc0:	1000021e 	bne	r2,zero,2004bcc <__sfp+0x38>
 2004bc4:	20049880 	call	2004988 <__sinit.part.1>
 2004bc8:	81000017 	ldw	r4,0(r16)
 2004bcc:	2480b804 	addi	r18,r4,736
 2004bd0:	047fffc4 	movi	r17,-1
 2004bd4:	91000117 	ldw	r4,4(r18)
 2004bd8:	94000217 	ldw	r16,8(r18)
 2004bdc:	213fffc4 	addi	r4,r4,-1
 2004be0:	20000a16 	blt	r4,zero,2004c0c <__sfp+0x78>
 2004be4:	8080030f 	ldh	r2,12(r16)
 2004be8:	10000c26 	beq	r2,zero,2004c1c <__sfp+0x88>
 2004bec:	80c01d04 	addi	r3,r16,116
 2004bf0:	00000206 	br	2004bfc <__sfp+0x68>
 2004bf4:	18bfe60f 	ldh	r2,-104(r3)
 2004bf8:	10000826 	beq	r2,zero,2004c1c <__sfp+0x88>
 2004bfc:	213fffc4 	addi	r4,r4,-1
 2004c00:	1c3ffd04 	addi	r16,r3,-12
 2004c04:	18c01a04 	addi	r3,r3,104
 2004c08:	247ffa1e 	bne	r4,r17,2004bf4 <__alt_mem_mem_0+0xfcfe4bf4>
 2004c0c:	90800017 	ldw	r2,0(r18)
 2004c10:	10001d26 	beq	r2,zero,2004c88 <__sfp+0xf4>
 2004c14:	1025883a 	mov	r18,r2
 2004c18:	003fee06 	br	2004bd4 <__alt_mem_mem_0+0xfcfe4bd4>
 2004c1c:	00bfffc4 	movi	r2,-1
 2004c20:	8080038d 	sth	r2,14(r16)
 2004c24:	00800044 	movi	r2,1
 2004c28:	8080030d 	sth	r2,12(r16)
 2004c2c:	80001915 	stw	zero,100(r16)
 2004c30:	80000015 	stw	zero,0(r16)
 2004c34:	80000215 	stw	zero,8(r16)
 2004c38:	80000115 	stw	zero,4(r16)
 2004c3c:	80000415 	stw	zero,16(r16)
 2004c40:	80000515 	stw	zero,20(r16)
 2004c44:	80000615 	stw	zero,24(r16)
 2004c48:	01800204 	movi	r6,8
 2004c4c:	000b883a 	mov	r5,zero
 2004c50:	81001704 	addi	r4,r16,92
 2004c54:	2005fa00 	call	2005fa0 <memset>
 2004c58:	8005883a 	mov	r2,r16
 2004c5c:	80000c15 	stw	zero,48(r16)
 2004c60:	80000d15 	stw	zero,52(r16)
 2004c64:	80001115 	stw	zero,68(r16)
 2004c68:	80001215 	stw	zero,72(r16)
 2004c6c:	dfc00417 	ldw	ra,16(sp)
 2004c70:	dcc00317 	ldw	r19,12(sp)
 2004c74:	dc800217 	ldw	r18,8(sp)
 2004c78:	dc400117 	ldw	r17,4(sp)
 2004c7c:	dc000017 	ldw	r16,0(sp)
 2004c80:	dec00504 	addi	sp,sp,20
 2004c84:	f800283a 	ret
 2004c88:	01400104 	movi	r5,4
 2004c8c:	9809883a 	mov	r4,r19
 2004c90:	2004b2c0 	call	2004b2c <__sfmoreglue>
 2004c94:	90800015 	stw	r2,0(r18)
 2004c98:	103fde1e 	bne	r2,zero,2004c14 <__alt_mem_mem_0+0xfcfe4c14>
 2004c9c:	00800304 	movi	r2,12
 2004ca0:	98800015 	stw	r2,0(r19)
 2004ca4:	0005883a 	mov	r2,zero
 2004ca8:	003ff006 	br	2004c6c <__alt_mem_mem_0+0xfcfe4c6c>

02004cac <_cleanup>:
 2004cac:	00808174 	movhi	r2,517
 2004cb0:	10ab3f04 	addi	r2,r2,-21252
 2004cb4:	11000017 	ldw	r4,0(r2)
 2004cb8:	01408074 	movhi	r5,513
 2004cbc:	2962ff04 	addi	r5,r5,-29700
 2004cc0:	200520c1 	jmpi	200520c <_fwalk_reent>

02004cc4 <__sinit>:
 2004cc4:	20800e17 	ldw	r2,56(r4)
 2004cc8:	10000126 	beq	r2,zero,2004cd0 <__sinit+0xc>
 2004ccc:	f800283a 	ret
 2004cd0:	20049881 	jmpi	2004988 <__sinit.part.1>

02004cd4 <__sfp_lock_acquire>:
 2004cd4:	f800283a 	ret

02004cd8 <__sfp_lock_release>:
 2004cd8:	f800283a 	ret

02004cdc <__sinit_lock_acquire>:
 2004cdc:	f800283a 	ret

02004ce0 <__sinit_lock_release>:
 2004ce0:	f800283a 	ret

02004ce4 <__fp_lock_all>:
 2004ce4:	00808174 	movhi	r2,517
 2004ce8:	10ab4004 	addi	r2,r2,-21248
 2004cec:	11000017 	ldw	r4,0(r2)
 2004cf0:	01408034 	movhi	r5,512
 2004cf4:	2952c904 	addi	r5,r5,19236
 2004cf8:	20051481 	jmpi	2005148 <_fwalk>

02004cfc <__fp_unlock_all>:
 2004cfc:	00808174 	movhi	r2,517
 2004d00:	10ab4004 	addi	r2,r2,-21248
 2004d04:	11000017 	ldw	r4,0(r2)
 2004d08:	01408034 	movhi	r5,512
 2004d0c:	29525d04 	addi	r5,r5,18804
 2004d10:	20051481 	jmpi	2005148 <_fwalk>

02004d14 <_malloc_trim_r>:
 2004d14:	defffb04 	addi	sp,sp,-20
 2004d18:	dcc00315 	stw	r19,12(sp)
 2004d1c:	04c08174 	movhi	r19,517
 2004d20:	dc800215 	stw	r18,8(sp)
 2004d24:	dc400115 	stw	r17,4(sp)
 2004d28:	dc000015 	stw	r16,0(sp)
 2004d2c:	dfc00415 	stw	ra,16(sp)
 2004d30:	2821883a 	mov	r16,r5
 2004d34:	9ce50e04 	addi	r19,r19,-27592
 2004d38:	2025883a 	mov	r18,r4
 2004d3c:	200d3180 	call	200d318 <__malloc_lock>
 2004d40:	98800217 	ldw	r2,8(r19)
 2004d44:	14400117 	ldw	r17,4(r2)
 2004d48:	00bfff04 	movi	r2,-4
 2004d4c:	88a2703a 	and	r17,r17,r2
 2004d50:	8c21c83a 	sub	r16,r17,r16
 2004d54:	8403fbc4 	addi	r16,r16,4079
 2004d58:	8020d33a 	srli	r16,r16,12
 2004d5c:	0083ffc4 	movi	r2,4095
 2004d60:	843fffc4 	addi	r16,r16,-1
 2004d64:	8020933a 	slli	r16,r16,12
 2004d68:	1400060e 	bge	r2,r16,2004d84 <_malloc_trim_r+0x70>
 2004d6c:	000b883a 	mov	r5,zero
 2004d70:	9009883a 	mov	r4,r18
 2004d74:	20071380 	call	2007138 <_sbrk_r>
 2004d78:	98c00217 	ldw	r3,8(r19)
 2004d7c:	1c47883a 	add	r3,r3,r17
 2004d80:	10c00a26 	beq	r2,r3,2004dac <_malloc_trim_r+0x98>
 2004d84:	9009883a 	mov	r4,r18
 2004d88:	200d3780 	call	200d378 <__malloc_unlock>
 2004d8c:	0005883a 	mov	r2,zero
 2004d90:	dfc00417 	ldw	ra,16(sp)
 2004d94:	dcc00317 	ldw	r19,12(sp)
 2004d98:	dc800217 	ldw	r18,8(sp)
 2004d9c:	dc400117 	ldw	r17,4(sp)
 2004da0:	dc000017 	ldw	r16,0(sp)
 2004da4:	dec00504 	addi	sp,sp,20
 2004da8:	f800283a 	ret
 2004dac:	040bc83a 	sub	r5,zero,r16
 2004db0:	9009883a 	mov	r4,r18
 2004db4:	20071380 	call	2007138 <_sbrk_r>
 2004db8:	00ffffc4 	movi	r3,-1
 2004dbc:	10c00d26 	beq	r2,r3,2004df4 <_malloc_trim_r+0xe0>
 2004dc0:	00c08174 	movhi	r3,517
 2004dc4:	18f34304 	addi	r3,r3,-13044
 2004dc8:	18800017 	ldw	r2,0(r3)
 2004dcc:	99000217 	ldw	r4,8(r19)
 2004dd0:	8c23c83a 	sub	r17,r17,r16
 2004dd4:	8c400054 	ori	r17,r17,1
 2004dd8:	1421c83a 	sub	r16,r2,r16
 2004ddc:	24400115 	stw	r17,4(r4)
 2004de0:	9009883a 	mov	r4,r18
 2004de4:	1c000015 	stw	r16,0(r3)
 2004de8:	200d3780 	call	200d378 <__malloc_unlock>
 2004dec:	00800044 	movi	r2,1
 2004df0:	003fe706 	br	2004d90 <__alt_mem_mem_0+0xfcfe4d90>
 2004df4:	000b883a 	mov	r5,zero
 2004df8:	9009883a 	mov	r4,r18
 2004dfc:	20071380 	call	2007138 <_sbrk_r>
 2004e00:	99000217 	ldw	r4,8(r19)
 2004e04:	014003c4 	movi	r5,15
 2004e08:	1107c83a 	sub	r3,r2,r4
 2004e0c:	28ffdd0e 	bge	r5,r3,2004d84 <__alt_mem_mem_0+0xfcfe4d84>
 2004e10:	01408174 	movhi	r5,517
 2004e14:	296b4204 	addi	r5,r5,-21240
 2004e18:	29400017 	ldw	r5,0(r5)
 2004e1c:	18c00054 	ori	r3,r3,1
 2004e20:	20c00115 	stw	r3,4(r4)
 2004e24:	00c08174 	movhi	r3,517
 2004e28:	1145c83a 	sub	r2,r2,r5
 2004e2c:	18f34304 	addi	r3,r3,-13044
 2004e30:	18800015 	stw	r2,0(r3)
 2004e34:	003fd306 	br	2004d84 <__alt_mem_mem_0+0xfcfe4d84>

02004e38 <_free_r>:
 2004e38:	28004126 	beq	r5,zero,2004f40 <_free_r+0x108>
 2004e3c:	defffd04 	addi	sp,sp,-12
 2004e40:	dc400115 	stw	r17,4(sp)
 2004e44:	dc000015 	stw	r16,0(sp)
 2004e48:	2023883a 	mov	r17,r4
 2004e4c:	2821883a 	mov	r16,r5
 2004e50:	dfc00215 	stw	ra,8(sp)
 2004e54:	200d3180 	call	200d318 <__malloc_lock>
 2004e58:	81ffff17 	ldw	r7,-4(r16)
 2004e5c:	00bfff84 	movi	r2,-2
 2004e60:	01008174 	movhi	r4,517
 2004e64:	81bffe04 	addi	r6,r16,-8
 2004e68:	3884703a 	and	r2,r7,r2
 2004e6c:	21250e04 	addi	r4,r4,-27592
 2004e70:	308b883a 	add	r5,r6,r2
 2004e74:	2a400117 	ldw	r9,4(r5)
 2004e78:	22000217 	ldw	r8,8(r4)
 2004e7c:	00ffff04 	movi	r3,-4
 2004e80:	48c6703a 	and	r3,r9,r3
 2004e84:	2a005726 	beq	r5,r8,2004fe4 <_free_r+0x1ac>
 2004e88:	28c00115 	stw	r3,4(r5)
 2004e8c:	39c0004c 	andi	r7,r7,1
 2004e90:	3800091e 	bne	r7,zero,2004eb8 <_free_r+0x80>
 2004e94:	823ffe17 	ldw	r8,-8(r16)
 2004e98:	22400204 	addi	r9,r4,8
 2004e9c:	320dc83a 	sub	r6,r6,r8
 2004ea0:	31c00217 	ldw	r7,8(r6)
 2004ea4:	1205883a 	add	r2,r2,r8
 2004ea8:	3a406526 	beq	r7,r9,2005040 <_free_r+0x208>
 2004eac:	32000317 	ldw	r8,12(r6)
 2004eb0:	3a000315 	stw	r8,12(r7)
 2004eb4:	41c00215 	stw	r7,8(r8)
 2004eb8:	28cf883a 	add	r7,r5,r3
 2004ebc:	39c00117 	ldw	r7,4(r7)
 2004ec0:	39c0004c 	andi	r7,r7,1
 2004ec4:	38003a26 	beq	r7,zero,2004fb0 <_free_r+0x178>
 2004ec8:	10c00054 	ori	r3,r2,1
 2004ecc:	30c00115 	stw	r3,4(r6)
 2004ed0:	3087883a 	add	r3,r6,r2
 2004ed4:	18800015 	stw	r2,0(r3)
 2004ed8:	00c07fc4 	movi	r3,511
 2004edc:	18801936 	bltu	r3,r2,2004f44 <_free_r+0x10c>
 2004ee0:	1004d0fa 	srli	r2,r2,3
 2004ee4:	01c00044 	movi	r7,1
 2004ee8:	21400117 	ldw	r5,4(r4)
 2004eec:	10c00044 	addi	r3,r2,1
 2004ef0:	18c7883a 	add	r3,r3,r3
 2004ef4:	1005d0ba 	srai	r2,r2,2
 2004ef8:	18c7883a 	add	r3,r3,r3
 2004efc:	18c7883a 	add	r3,r3,r3
 2004f00:	1907883a 	add	r3,r3,r4
 2004f04:	3884983a 	sll	r2,r7,r2
 2004f08:	19c00017 	ldw	r7,0(r3)
 2004f0c:	1a3ffe04 	addi	r8,r3,-8
 2004f10:	1144b03a 	or	r2,r2,r5
 2004f14:	32000315 	stw	r8,12(r6)
 2004f18:	31c00215 	stw	r7,8(r6)
 2004f1c:	20800115 	stw	r2,4(r4)
 2004f20:	19800015 	stw	r6,0(r3)
 2004f24:	39800315 	stw	r6,12(r7)
 2004f28:	8809883a 	mov	r4,r17
 2004f2c:	dfc00217 	ldw	ra,8(sp)
 2004f30:	dc400117 	ldw	r17,4(sp)
 2004f34:	dc000017 	ldw	r16,0(sp)
 2004f38:	dec00304 	addi	sp,sp,12
 2004f3c:	200d3781 	jmpi	200d378 <__malloc_unlock>
 2004f40:	f800283a 	ret
 2004f44:	100ad27a 	srli	r5,r2,9
 2004f48:	00c00104 	movi	r3,4
 2004f4c:	19404a36 	bltu	r3,r5,2005078 <_free_r+0x240>
 2004f50:	100ad1ba 	srli	r5,r2,6
 2004f54:	28c00e44 	addi	r3,r5,57
 2004f58:	18c7883a 	add	r3,r3,r3
 2004f5c:	29400e04 	addi	r5,r5,56
 2004f60:	18c7883a 	add	r3,r3,r3
 2004f64:	18c7883a 	add	r3,r3,r3
 2004f68:	1909883a 	add	r4,r3,r4
 2004f6c:	20c00017 	ldw	r3,0(r4)
 2004f70:	01c08174 	movhi	r7,517
 2004f74:	213ffe04 	addi	r4,r4,-8
 2004f78:	39e50e04 	addi	r7,r7,-27592
 2004f7c:	20c04426 	beq	r4,r3,2005090 <_free_r+0x258>
 2004f80:	01ffff04 	movi	r7,-4
 2004f84:	19400117 	ldw	r5,4(r3)
 2004f88:	29ca703a 	and	r5,r5,r7
 2004f8c:	1140022e 	bgeu	r2,r5,2004f98 <_free_r+0x160>
 2004f90:	18c00217 	ldw	r3,8(r3)
 2004f94:	20fffb1e 	bne	r4,r3,2004f84 <__alt_mem_mem_0+0xfcfe4f84>
 2004f98:	19000317 	ldw	r4,12(r3)
 2004f9c:	31000315 	stw	r4,12(r6)
 2004fa0:	30c00215 	stw	r3,8(r6)
 2004fa4:	21800215 	stw	r6,8(r4)
 2004fa8:	19800315 	stw	r6,12(r3)
 2004fac:	003fde06 	br	2004f28 <__alt_mem_mem_0+0xfcfe4f28>
 2004fb0:	29c00217 	ldw	r7,8(r5)
 2004fb4:	10c5883a 	add	r2,r2,r3
 2004fb8:	00c08174 	movhi	r3,517
 2004fbc:	18e51004 	addi	r3,r3,-27584
 2004fc0:	38c03b26 	beq	r7,r3,20050b0 <_free_r+0x278>
 2004fc4:	2a000317 	ldw	r8,12(r5)
 2004fc8:	11400054 	ori	r5,r2,1
 2004fcc:	3087883a 	add	r3,r6,r2
 2004fd0:	3a000315 	stw	r8,12(r7)
 2004fd4:	41c00215 	stw	r7,8(r8)
 2004fd8:	31400115 	stw	r5,4(r6)
 2004fdc:	18800015 	stw	r2,0(r3)
 2004fe0:	003fbd06 	br	2004ed8 <__alt_mem_mem_0+0xfcfe4ed8>
 2004fe4:	39c0004c 	andi	r7,r7,1
 2004fe8:	10c5883a 	add	r2,r2,r3
 2004fec:	3800071e 	bne	r7,zero,200500c <_free_r+0x1d4>
 2004ff0:	81fffe17 	ldw	r7,-8(r16)
 2004ff4:	31cdc83a 	sub	r6,r6,r7
 2004ff8:	30c00317 	ldw	r3,12(r6)
 2004ffc:	31400217 	ldw	r5,8(r6)
 2005000:	11c5883a 	add	r2,r2,r7
 2005004:	28c00315 	stw	r3,12(r5)
 2005008:	19400215 	stw	r5,8(r3)
 200500c:	10c00054 	ori	r3,r2,1
 2005010:	30c00115 	stw	r3,4(r6)
 2005014:	00c08174 	movhi	r3,517
 2005018:	18eb4304 	addi	r3,r3,-21236
 200501c:	18c00017 	ldw	r3,0(r3)
 2005020:	21800215 	stw	r6,8(r4)
 2005024:	10ffc036 	bltu	r2,r3,2004f28 <__alt_mem_mem_0+0xfcfe4f28>
 2005028:	00808174 	movhi	r2,517
 200502c:	10b2e204 	addi	r2,r2,-13432
 2005030:	11400017 	ldw	r5,0(r2)
 2005034:	8809883a 	mov	r4,r17
 2005038:	2004d140 	call	2004d14 <_malloc_trim_r>
 200503c:	003fba06 	br	2004f28 <__alt_mem_mem_0+0xfcfe4f28>
 2005040:	28c9883a 	add	r4,r5,r3
 2005044:	21000117 	ldw	r4,4(r4)
 2005048:	2100004c 	andi	r4,r4,1
 200504c:	2000391e 	bne	r4,zero,2005134 <_free_r+0x2fc>
 2005050:	29c00217 	ldw	r7,8(r5)
 2005054:	29000317 	ldw	r4,12(r5)
 2005058:	1885883a 	add	r2,r3,r2
 200505c:	10c00054 	ori	r3,r2,1
 2005060:	39000315 	stw	r4,12(r7)
 2005064:	21c00215 	stw	r7,8(r4)
 2005068:	30c00115 	stw	r3,4(r6)
 200506c:	308d883a 	add	r6,r6,r2
 2005070:	30800015 	stw	r2,0(r6)
 2005074:	003fac06 	br	2004f28 <__alt_mem_mem_0+0xfcfe4f28>
 2005078:	00c00504 	movi	r3,20
 200507c:	19401536 	bltu	r3,r5,20050d4 <_free_r+0x29c>
 2005080:	28c01704 	addi	r3,r5,92
 2005084:	18c7883a 	add	r3,r3,r3
 2005088:	294016c4 	addi	r5,r5,91
 200508c:	003fb406 	br	2004f60 <__alt_mem_mem_0+0xfcfe4f60>
 2005090:	280bd0ba 	srai	r5,r5,2
 2005094:	00c00044 	movi	r3,1
 2005098:	38800117 	ldw	r2,4(r7)
 200509c:	194a983a 	sll	r5,r3,r5
 20050a0:	2007883a 	mov	r3,r4
 20050a4:	2884b03a 	or	r2,r5,r2
 20050a8:	38800115 	stw	r2,4(r7)
 20050ac:	003fbb06 	br	2004f9c <__alt_mem_mem_0+0xfcfe4f9c>
 20050b0:	21800515 	stw	r6,20(r4)
 20050b4:	21800415 	stw	r6,16(r4)
 20050b8:	10c00054 	ori	r3,r2,1
 20050bc:	31c00315 	stw	r7,12(r6)
 20050c0:	31c00215 	stw	r7,8(r6)
 20050c4:	30c00115 	stw	r3,4(r6)
 20050c8:	308d883a 	add	r6,r6,r2
 20050cc:	30800015 	stw	r2,0(r6)
 20050d0:	003f9506 	br	2004f28 <__alt_mem_mem_0+0xfcfe4f28>
 20050d4:	00c01504 	movi	r3,84
 20050d8:	19400536 	bltu	r3,r5,20050f0 <_free_r+0x2b8>
 20050dc:	100ad33a 	srli	r5,r2,12
 20050e0:	28c01bc4 	addi	r3,r5,111
 20050e4:	18c7883a 	add	r3,r3,r3
 20050e8:	29401b84 	addi	r5,r5,110
 20050ec:	003f9c06 	br	2004f60 <__alt_mem_mem_0+0xfcfe4f60>
 20050f0:	00c05504 	movi	r3,340
 20050f4:	19400536 	bltu	r3,r5,200510c <_free_r+0x2d4>
 20050f8:	100ad3fa 	srli	r5,r2,15
 20050fc:	28c01e04 	addi	r3,r5,120
 2005100:	18c7883a 	add	r3,r3,r3
 2005104:	29401dc4 	addi	r5,r5,119
 2005108:	003f9506 	br	2004f60 <__alt_mem_mem_0+0xfcfe4f60>
 200510c:	00c15504 	movi	r3,1364
 2005110:	19400536 	bltu	r3,r5,2005128 <_free_r+0x2f0>
 2005114:	100ad4ba 	srli	r5,r2,18
 2005118:	28c01f44 	addi	r3,r5,125
 200511c:	18c7883a 	add	r3,r3,r3
 2005120:	29401f04 	addi	r5,r5,124
 2005124:	003f8e06 	br	2004f60 <__alt_mem_mem_0+0xfcfe4f60>
 2005128:	00c03f84 	movi	r3,254
 200512c:	01401f84 	movi	r5,126
 2005130:	003f8b06 	br	2004f60 <__alt_mem_mem_0+0xfcfe4f60>
 2005134:	10c00054 	ori	r3,r2,1
 2005138:	30c00115 	stw	r3,4(r6)
 200513c:	308d883a 	add	r6,r6,r2
 2005140:	30800015 	stw	r2,0(r6)
 2005144:	003f7806 	br	2004f28 <__alt_mem_mem_0+0xfcfe4f28>

02005148 <_fwalk>:
 2005148:	defff704 	addi	sp,sp,-36
 200514c:	dd000415 	stw	r20,16(sp)
 2005150:	dfc00815 	stw	ra,32(sp)
 2005154:	ddc00715 	stw	r23,28(sp)
 2005158:	dd800615 	stw	r22,24(sp)
 200515c:	dd400515 	stw	r21,20(sp)
 2005160:	dcc00315 	stw	r19,12(sp)
 2005164:	dc800215 	stw	r18,8(sp)
 2005168:	dc400115 	stw	r17,4(sp)
 200516c:	dc000015 	stw	r16,0(sp)
 2005170:	2500b804 	addi	r20,r4,736
 2005174:	a0002326 	beq	r20,zero,2005204 <_fwalk+0xbc>
 2005178:	282b883a 	mov	r21,r5
 200517c:	002f883a 	mov	r23,zero
 2005180:	05800044 	movi	r22,1
 2005184:	04ffffc4 	movi	r19,-1
 2005188:	a4400117 	ldw	r17,4(r20)
 200518c:	a4800217 	ldw	r18,8(r20)
 2005190:	8c7fffc4 	addi	r17,r17,-1
 2005194:	88000d16 	blt	r17,zero,20051cc <_fwalk+0x84>
 2005198:	94000304 	addi	r16,r18,12
 200519c:	94800384 	addi	r18,r18,14
 20051a0:	8080000b 	ldhu	r2,0(r16)
 20051a4:	8c7fffc4 	addi	r17,r17,-1
 20051a8:	813ffd04 	addi	r4,r16,-12
 20051ac:	b080042e 	bgeu	r22,r2,20051c0 <_fwalk+0x78>
 20051b0:	9080000f 	ldh	r2,0(r18)
 20051b4:	14c00226 	beq	r2,r19,20051c0 <_fwalk+0x78>
 20051b8:	a83ee83a 	callr	r21
 20051bc:	b8aeb03a 	or	r23,r23,r2
 20051c0:	84001a04 	addi	r16,r16,104
 20051c4:	94801a04 	addi	r18,r18,104
 20051c8:	8cfff51e 	bne	r17,r19,20051a0 <__alt_mem_mem_0+0xfcfe51a0>
 20051cc:	a5000017 	ldw	r20,0(r20)
 20051d0:	a03fed1e 	bne	r20,zero,2005188 <__alt_mem_mem_0+0xfcfe5188>
 20051d4:	b805883a 	mov	r2,r23
 20051d8:	dfc00817 	ldw	ra,32(sp)
 20051dc:	ddc00717 	ldw	r23,28(sp)
 20051e0:	dd800617 	ldw	r22,24(sp)
 20051e4:	dd400517 	ldw	r21,20(sp)
 20051e8:	dd000417 	ldw	r20,16(sp)
 20051ec:	dcc00317 	ldw	r19,12(sp)
 20051f0:	dc800217 	ldw	r18,8(sp)
 20051f4:	dc400117 	ldw	r17,4(sp)
 20051f8:	dc000017 	ldw	r16,0(sp)
 20051fc:	dec00904 	addi	sp,sp,36
 2005200:	f800283a 	ret
 2005204:	002f883a 	mov	r23,zero
 2005208:	003ff206 	br	20051d4 <__alt_mem_mem_0+0xfcfe51d4>

0200520c <_fwalk_reent>:
 200520c:	defff704 	addi	sp,sp,-36
 2005210:	dd000415 	stw	r20,16(sp)
 2005214:	dfc00815 	stw	ra,32(sp)
 2005218:	ddc00715 	stw	r23,28(sp)
 200521c:	dd800615 	stw	r22,24(sp)
 2005220:	dd400515 	stw	r21,20(sp)
 2005224:	dcc00315 	stw	r19,12(sp)
 2005228:	dc800215 	stw	r18,8(sp)
 200522c:	dc400115 	stw	r17,4(sp)
 2005230:	dc000015 	stw	r16,0(sp)
 2005234:	2500b804 	addi	r20,r4,736
 2005238:	a0002326 	beq	r20,zero,20052c8 <_fwalk_reent+0xbc>
 200523c:	282b883a 	mov	r21,r5
 2005240:	2027883a 	mov	r19,r4
 2005244:	002f883a 	mov	r23,zero
 2005248:	05800044 	movi	r22,1
 200524c:	04bfffc4 	movi	r18,-1
 2005250:	a4400117 	ldw	r17,4(r20)
 2005254:	a4000217 	ldw	r16,8(r20)
 2005258:	8c7fffc4 	addi	r17,r17,-1
 200525c:	88000c16 	blt	r17,zero,2005290 <_fwalk_reent+0x84>
 2005260:	84000304 	addi	r16,r16,12
 2005264:	8080000b 	ldhu	r2,0(r16)
 2005268:	8c7fffc4 	addi	r17,r17,-1
 200526c:	817ffd04 	addi	r5,r16,-12
 2005270:	b080052e 	bgeu	r22,r2,2005288 <_fwalk_reent+0x7c>
 2005274:	8080008f 	ldh	r2,2(r16)
 2005278:	9809883a 	mov	r4,r19
 200527c:	14800226 	beq	r2,r18,2005288 <_fwalk_reent+0x7c>
 2005280:	a83ee83a 	callr	r21
 2005284:	b8aeb03a 	or	r23,r23,r2
 2005288:	84001a04 	addi	r16,r16,104
 200528c:	8cbff51e 	bne	r17,r18,2005264 <__alt_mem_mem_0+0xfcfe5264>
 2005290:	a5000017 	ldw	r20,0(r20)
 2005294:	a03fee1e 	bne	r20,zero,2005250 <__alt_mem_mem_0+0xfcfe5250>
 2005298:	b805883a 	mov	r2,r23
 200529c:	dfc00817 	ldw	ra,32(sp)
 20052a0:	ddc00717 	ldw	r23,28(sp)
 20052a4:	dd800617 	ldw	r22,24(sp)
 20052a8:	dd400517 	ldw	r21,20(sp)
 20052ac:	dd000417 	ldw	r20,16(sp)
 20052b0:	dcc00317 	ldw	r19,12(sp)
 20052b4:	dc800217 	ldw	r18,8(sp)
 20052b8:	dc400117 	ldw	r17,4(sp)
 20052bc:	dc000017 	ldw	r16,0(sp)
 20052c0:	dec00904 	addi	sp,sp,36
 20052c4:	f800283a 	ret
 20052c8:	002f883a 	mov	r23,zero
 20052cc:	003ff206 	br	2005298 <__alt_mem_mem_0+0xfcfe5298>

020052d0 <_setlocale_r>:
 20052d0:	30001b26 	beq	r6,zero,2005340 <_setlocale_r+0x70>
 20052d4:	01408134 	movhi	r5,516
 20052d8:	defffe04 	addi	sp,sp,-8
 20052dc:	295a9a04 	addi	r5,r5,27240
 20052e0:	3009883a 	mov	r4,r6
 20052e4:	dc000015 	stw	r16,0(sp)
 20052e8:	dfc00115 	stw	ra,4(sp)
 20052ec:	3021883a 	mov	r16,r6
 20052f0:	20072c80 	call	20072c8 <strcmp>
 20052f4:	1000061e 	bne	r2,zero,2005310 <_setlocale_r+0x40>
 20052f8:	00808134 	movhi	r2,516
 20052fc:	109a9904 	addi	r2,r2,27236
 2005300:	dfc00117 	ldw	ra,4(sp)
 2005304:	dc000017 	ldw	r16,0(sp)
 2005308:	dec00204 	addi	sp,sp,8
 200530c:	f800283a 	ret
 2005310:	01408134 	movhi	r5,516
 2005314:	295a9904 	addi	r5,r5,27236
 2005318:	8009883a 	mov	r4,r16
 200531c:	20072c80 	call	20072c8 <strcmp>
 2005320:	103ff526 	beq	r2,zero,20052f8 <__alt_mem_mem_0+0xfcfe52f8>
 2005324:	01408134 	movhi	r5,516
 2005328:	295a8404 	addi	r5,r5,27152
 200532c:	8009883a 	mov	r4,r16
 2005330:	20072c80 	call	20072c8 <strcmp>
 2005334:	103ff026 	beq	r2,zero,20052f8 <__alt_mem_mem_0+0xfcfe52f8>
 2005338:	0005883a 	mov	r2,zero
 200533c:	003ff006 	br	2005300 <__alt_mem_mem_0+0xfcfe5300>
 2005340:	00808134 	movhi	r2,516
 2005344:	109a9904 	addi	r2,r2,27236
 2005348:	f800283a 	ret

0200534c <__locale_charset>:
 200534c:	00808174 	movhi	r2,517
 2005350:	10a4f804 	addi	r2,r2,-27680
 2005354:	f800283a 	ret

02005358 <__locale_mb_cur_max>:
 2005358:	00808174 	movhi	r2,517
 200535c:	10ab4104 	addi	r2,r2,-21244
 2005360:	10800017 	ldw	r2,0(r2)
 2005364:	f800283a 	ret

02005368 <__locale_msgcharset>:
 2005368:	00808174 	movhi	r2,517
 200536c:	10a4f004 	addi	r2,r2,-27712
 2005370:	f800283a 	ret

02005374 <__locale_cjk_lang>:
 2005374:	0005883a 	mov	r2,zero
 2005378:	f800283a 	ret

0200537c <_localeconv_r>:
 200537c:	00808174 	movhi	r2,517
 2005380:	10a50004 	addi	r2,r2,-27648
 2005384:	f800283a 	ret

02005388 <setlocale>:
 2005388:	00808174 	movhi	r2,517
 200538c:	10ab4004 	addi	r2,r2,-21248
 2005390:	280d883a 	mov	r6,r5
 2005394:	200b883a 	mov	r5,r4
 2005398:	11000017 	ldw	r4,0(r2)
 200539c:	20052d01 	jmpi	20052d0 <_setlocale_r>

020053a0 <localeconv>:
 20053a0:	00808174 	movhi	r2,517
 20053a4:	10a50004 	addi	r2,r2,-27648
 20053a8:	f800283a 	ret

020053ac <__smakebuf_r>:
 20053ac:	2880030b 	ldhu	r2,12(r5)
 20053b0:	10c0008c 	andi	r3,r2,2
 20053b4:	1800411e 	bne	r3,zero,20054bc <__smakebuf_r+0x110>
 20053b8:	deffec04 	addi	sp,sp,-80
 20053bc:	dc000f15 	stw	r16,60(sp)
 20053c0:	2821883a 	mov	r16,r5
 20053c4:	2940038f 	ldh	r5,14(r5)
 20053c8:	dc401015 	stw	r17,64(sp)
 20053cc:	dfc01315 	stw	ra,76(sp)
 20053d0:	dcc01215 	stw	r19,72(sp)
 20053d4:	dc801115 	stw	r18,68(sp)
 20053d8:	2023883a 	mov	r17,r4
 20053dc:	28001c16 	blt	r5,zero,2005450 <__smakebuf_r+0xa4>
 20053e0:	d80d883a 	mov	r6,sp
 20053e4:	2008f080 	call	2008f08 <_fstat_r>
 20053e8:	10001816 	blt	r2,zero,200544c <__smakebuf_r+0xa0>
 20053ec:	d8800117 	ldw	r2,4(sp)
 20053f0:	00e00014 	movui	r3,32768
 20053f4:	10bc000c 	andi	r2,r2,61440
 20053f8:	14c80020 	cmpeqi	r19,r2,8192
 20053fc:	10c03726 	beq	r2,r3,20054dc <__smakebuf_r+0x130>
 2005400:	80c0030b 	ldhu	r3,12(r16)
 2005404:	18c20014 	ori	r3,r3,2048
 2005408:	80c0030d 	sth	r3,12(r16)
 200540c:	00c80004 	movi	r3,8192
 2005410:	10c0521e 	bne	r2,r3,200555c <__smakebuf_r+0x1b0>
 2005414:	8140038f 	ldh	r5,14(r16)
 2005418:	8809883a 	mov	r4,r17
 200541c:	20094200 	call	2009420 <_isatty_r>
 2005420:	10004c26 	beq	r2,zero,2005554 <__smakebuf_r+0x1a8>
 2005424:	8080030b 	ldhu	r2,12(r16)
 2005428:	80c010c4 	addi	r3,r16,67
 200542c:	80c00015 	stw	r3,0(r16)
 2005430:	10800054 	ori	r2,r2,1
 2005434:	8080030d 	sth	r2,12(r16)
 2005438:	00800044 	movi	r2,1
 200543c:	80c00415 	stw	r3,16(r16)
 2005440:	80800515 	stw	r2,20(r16)
 2005444:	04810004 	movi	r18,1024
 2005448:	00000706 	br	2005468 <__smakebuf_r+0xbc>
 200544c:	8080030b 	ldhu	r2,12(r16)
 2005450:	10c0200c 	andi	r3,r2,128
 2005454:	18001f1e 	bne	r3,zero,20054d4 <__smakebuf_r+0x128>
 2005458:	04810004 	movi	r18,1024
 200545c:	10820014 	ori	r2,r2,2048
 2005460:	8080030d 	sth	r2,12(r16)
 2005464:	0027883a 	mov	r19,zero
 2005468:	900b883a 	mov	r5,r18
 200546c:	8809883a 	mov	r4,r17
 2005470:	20055680 	call	2005568 <_malloc_r>
 2005474:	10002c26 	beq	r2,zero,2005528 <__smakebuf_r+0x17c>
 2005478:	80c0030b 	ldhu	r3,12(r16)
 200547c:	01008034 	movhi	r4,512
 2005480:	21125f04 	addi	r4,r4,18812
 2005484:	89000f15 	stw	r4,60(r17)
 2005488:	18c02014 	ori	r3,r3,128
 200548c:	80c0030d 	sth	r3,12(r16)
 2005490:	80800015 	stw	r2,0(r16)
 2005494:	80800415 	stw	r2,16(r16)
 2005498:	84800515 	stw	r18,20(r16)
 200549c:	98001a1e 	bne	r19,zero,2005508 <__smakebuf_r+0x15c>
 20054a0:	dfc01317 	ldw	ra,76(sp)
 20054a4:	dcc01217 	ldw	r19,72(sp)
 20054a8:	dc801117 	ldw	r18,68(sp)
 20054ac:	dc401017 	ldw	r17,64(sp)
 20054b0:	dc000f17 	ldw	r16,60(sp)
 20054b4:	dec01404 	addi	sp,sp,80
 20054b8:	f800283a 	ret
 20054bc:	288010c4 	addi	r2,r5,67
 20054c0:	28800015 	stw	r2,0(r5)
 20054c4:	28800415 	stw	r2,16(r5)
 20054c8:	00800044 	movi	r2,1
 20054cc:	28800515 	stw	r2,20(r5)
 20054d0:	f800283a 	ret
 20054d4:	04801004 	movi	r18,64
 20054d8:	003fe006 	br	200545c <__alt_mem_mem_0+0xfcfe545c>
 20054dc:	81000a17 	ldw	r4,40(r16)
 20054e0:	00c08034 	movhi	r3,512
 20054e4:	18dc9904 	addi	r3,r3,29284
 20054e8:	20ffc51e 	bne	r4,r3,2005400 <__alt_mem_mem_0+0xfcfe5400>
 20054ec:	8080030b 	ldhu	r2,12(r16)
 20054f0:	04810004 	movi	r18,1024
 20054f4:	84801315 	stw	r18,76(r16)
 20054f8:	1484b03a 	or	r2,r2,r18
 20054fc:	8080030d 	sth	r2,12(r16)
 2005500:	0027883a 	mov	r19,zero
 2005504:	003fd806 	br	2005468 <__alt_mem_mem_0+0xfcfe5468>
 2005508:	8140038f 	ldh	r5,14(r16)
 200550c:	8809883a 	mov	r4,r17
 2005510:	20094200 	call	2009420 <_isatty_r>
 2005514:	103fe226 	beq	r2,zero,20054a0 <__alt_mem_mem_0+0xfcfe54a0>
 2005518:	8080030b 	ldhu	r2,12(r16)
 200551c:	10800054 	ori	r2,r2,1
 2005520:	8080030d 	sth	r2,12(r16)
 2005524:	003fde06 	br	20054a0 <__alt_mem_mem_0+0xfcfe54a0>
 2005528:	8080030b 	ldhu	r2,12(r16)
 200552c:	10c0800c 	andi	r3,r2,512
 2005530:	183fdb1e 	bne	r3,zero,20054a0 <__alt_mem_mem_0+0xfcfe54a0>
 2005534:	10800094 	ori	r2,r2,2
 2005538:	80c010c4 	addi	r3,r16,67
 200553c:	8080030d 	sth	r2,12(r16)
 2005540:	00800044 	movi	r2,1
 2005544:	80c00015 	stw	r3,0(r16)
 2005548:	80c00415 	stw	r3,16(r16)
 200554c:	80800515 	stw	r2,20(r16)
 2005550:	003fd306 	br	20054a0 <__alt_mem_mem_0+0xfcfe54a0>
 2005554:	04810004 	movi	r18,1024
 2005558:	003fc306 	br	2005468 <__alt_mem_mem_0+0xfcfe5468>
 200555c:	0027883a 	mov	r19,zero
 2005560:	04810004 	movi	r18,1024
 2005564:	003fc006 	br	2005468 <__alt_mem_mem_0+0xfcfe5468>

02005568 <_malloc_r>:
 2005568:	defff504 	addi	sp,sp,-44
 200556c:	dc800315 	stw	r18,12(sp)
 2005570:	dfc00a15 	stw	ra,40(sp)
 2005574:	df000915 	stw	fp,36(sp)
 2005578:	ddc00815 	stw	r23,32(sp)
 200557c:	dd800715 	stw	r22,28(sp)
 2005580:	dd400615 	stw	r21,24(sp)
 2005584:	dd000515 	stw	r20,20(sp)
 2005588:	dcc00415 	stw	r19,16(sp)
 200558c:	dc400215 	stw	r17,8(sp)
 2005590:	dc000115 	stw	r16,4(sp)
 2005594:	288002c4 	addi	r2,r5,11
 2005598:	00c00584 	movi	r3,22
 200559c:	2025883a 	mov	r18,r4
 20055a0:	18807f2e 	bgeu	r3,r2,20057a0 <_malloc_r+0x238>
 20055a4:	047ffe04 	movi	r17,-8
 20055a8:	1462703a 	and	r17,r2,r17
 20055ac:	8800a316 	blt	r17,zero,200583c <_malloc_r+0x2d4>
 20055b0:	8940a236 	bltu	r17,r5,200583c <_malloc_r+0x2d4>
 20055b4:	200d3180 	call	200d318 <__malloc_lock>
 20055b8:	00807dc4 	movi	r2,503
 20055bc:	1441e92e 	bgeu	r2,r17,2005d64 <_malloc_r+0x7fc>
 20055c0:	8804d27a 	srli	r2,r17,9
 20055c4:	1000a126 	beq	r2,zero,200584c <_malloc_r+0x2e4>
 20055c8:	00c00104 	movi	r3,4
 20055cc:	18811e36 	bltu	r3,r2,2005a48 <_malloc_r+0x4e0>
 20055d0:	8804d1ba 	srli	r2,r17,6
 20055d4:	12000e44 	addi	r8,r2,57
 20055d8:	11c00e04 	addi	r7,r2,56
 20055dc:	4209883a 	add	r4,r8,r8
 20055e0:	04c08174 	movhi	r19,517
 20055e4:	2109883a 	add	r4,r4,r4
 20055e8:	9ce50e04 	addi	r19,r19,-27592
 20055ec:	2109883a 	add	r4,r4,r4
 20055f0:	9909883a 	add	r4,r19,r4
 20055f4:	24000117 	ldw	r16,4(r4)
 20055f8:	213ffe04 	addi	r4,r4,-8
 20055fc:	24009726 	beq	r4,r16,200585c <_malloc_r+0x2f4>
 2005600:	80800117 	ldw	r2,4(r16)
 2005604:	01bfff04 	movi	r6,-4
 2005608:	014003c4 	movi	r5,15
 200560c:	1184703a 	and	r2,r2,r6
 2005610:	1447c83a 	sub	r3,r2,r17
 2005614:	28c00716 	blt	r5,r3,2005634 <_malloc_r+0xcc>
 2005618:	1800920e 	bge	r3,zero,2005864 <_malloc_r+0x2fc>
 200561c:	84000317 	ldw	r16,12(r16)
 2005620:	24008e26 	beq	r4,r16,200585c <_malloc_r+0x2f4>
 2005624:	80800117 	ldw	r2,4(r16)
 2005628:	1184703a 	and	r2,r2,r6
 200562c:	1447c83a 	sub	r3,r2,r17
 2005630:	28fff90e 	bge	r5,r3,2005618 <__alt_mem_mem_0+0xfcfe5618>
 2005634:	3809883a 	mov	r4,r7
 2005638:	01808174 	movhi	r6,517
 200563c:	9c000417 	ldw	r16,16(r19)
 2005640:	31a50e04 	addi	r6,r6,-27592
 2005644:	32000204 	addi	r8,r6,8
 2005648:	82013426 	beq	r16,r8,2005b1c <_malloc_r+0x5b4>
 200564c:	80c00117 	ldw	r3,4(r16)
 2005650:	00bfff04 	movi	r2,-4
 2005654:	188e703a 	and	r7,r3,r2
 2005658:	3c45c83a 	sub	r2,r7,r17
 200565c:	00c003c4 	movi	r3,15
 2005660:	18811f16 	blt	r3,r2,2005ae0 <_malloc_r+0x578>
 2005664:	32000515 	stw	r8,20(r6)
 2005668:	32000415 	stw	r8,16(r6)
 200566c:	10007f0e 	bge	r2,zero,200586c <_malloc_r+0x304>
 2005670:	00807fc4 	movi	r2,511
 2005674:	11c0fd36 	bltu	r2,r7,2005a6c <_malloc_r+0x504>
 2005678:	3806d0fa 	srli	r3,r7,3
 200567c:	01c00044 	movi	r7,1
 2005680:	30800117 	ldw	r2,4(r6)
 2005684:	19400044 	addi	r5,r3,1
 2005688:	294b883a 	add	r5,r5,r5
 200568c:	1807d0ba 	srai	r3,r3,2
 2005690:	294b883a 	add	r5,r5,r5
 2005694:	294b883a 	add	r5,r5,r5
 2005698:	298b883a 	add	r5,r5,r6
 200569c:	38c6983a 	sll	r3,r7,r3
 20056a0:	29c00017 	ldw	r7,0(r5)
 20056a4:	2a7ffe04 	addi	r9,r5,-8
 20056a8:	1886b03a 	or	r3,r3,r2
 20056ac:	82400315 	stw	r9,12(r16)
 20056b0:	81c00215 	stw	r7,8(r16)
 20056b4:	30c00115 	stw	r3,4(r6)
 20056b8:	2c000015 	stw	r16,0(r5)
 20056bc:	3c000315 	stw	r16,12(r7)
 20056c0:	2005d0ba 	srai	r2,r4,2
 20056c4:	01400044 	movi	r5,1
 20056c8:	288a983a 	sll	r5,r5,r2
 20056cc:	19406f36 	bltu	r3,r5,200588c <_malloc_r+0x324>
 20056d0:	28c4703a 	and	r2,r5,r3
 20056d4:	10000a1e 	bne	r2,zero,2005700 <_malloc_r+0x198>
 20056d8:	00bfff04 	movi	r2,-4
 20056dc:	294b883a 	add	r5,r5,r5
 20056e0:	2088703a 	and	r4,r4,r2
 20056e4:	28c4703a 	and	r2,r5,r3
 20056e8:	21000104 	addi	r4,r4,4
 20056ec:	1000041e 	bne	r2,zero,2005700 <_malloc_r+0x198>
 20056f0:	294b883a 	add	r5,r5,r5
 20056f4:	28c4703a 	and	r2,r5,r3
 20056f8:	21000104 	addi	r4,r4,4
 20056fc:	103ffc26 	beq	r2,zero,20056f0 <__alt_mem_mem_0+0xfcfe56f0>
 2005700:	02bfff04 	movi	r10,-4
 2005704:	024003c4 	movi	r9,15
 2005708:	21800044 	addi	r6,r4,1
 200570c:	318d883a 	add	r6,r6,r6
 2005710:	318d883a 	add	r6,r6,r6
 2005714:	318d883a 	add	r6,r6,r6
 2005718:	998d883a 	add	r6,r19,r6
 200571c:	333ffe04 	addi	r12,r6,-8
 2005720:	2017883a 	mov	r11,r4
 2005724:	31800104 	addi	r6,r6,4
 2005728:	34000017 	ldw	r16,0(r6)
 200572c:	31fffd04 	addi	r7,r6,-12
 2005730:	81c0041e 	bne	r16,r7,2005744 <_malloc_r+0x1dc>
 2005734:	0000fb06 	br	2005b24 <_malloc_r+0x5bc>
 2005738:	1801030e 	bge	r3,zero,2005b48 <_malloc_r+0x5e0>
 200573c:	84000317 	ldw	r16,12(r16)
 2005740:	81c0f826 	beq	r16,r7,2005b24 <_malloc_r+0x5bc>
 2005744:	80800117 	ldw	r2,4(r16)
 2005748:	1284703a 	and	r2,r2,r10
 200574c:	1447c83a 	sub	r3,r2,r17
 2005750:	48fff90e 	bge	r9,r3,2005738 <__alt_mem_mem_0+0xfcfe5738>
 2005754:	80800317 	ldw	r2,12(r16)
 2005758:	81000217 	ldw	r4,8(r16)
 200575c:	89400054 	ori	r5,r17,1
 2005760:	81400115 	stw	r5,4(r16)
 2005764:	20800315 	stw	r2,12(r4)
 2005768:	11000215 	stw	r4,8(r2)
 200576c:	8463883a 	add	r17,r16,r17
 2005770:	9c400515 	stw	r17,20(r19)
 2005774:	9c400415 	stw	r17,16(r19)
 2005778:	18800054 	ori	r2,r3,1
 200577c:	88800115 	stw	r2,4(r17)
 2005780:	8a000315 	stw	r8,12(r17)
 2005784:	8a000215 	stw	r8,8(r17)
 2005788:	88e3883a 	add	r17,r17,r3
 200578c:	88c00015 	stw	r3,0(r17)
 2005790:	9009883a 	mov	r4,r18
 2005794:	200d3780 	call	200d378 <__malloc_unlock>
 2005798:	80800204 	addi	r2,r16,8
 200579c:	00001b06 	br	200580c <_malloc_r+0x2a4>
 20057a0:	04400404 	movi	r17,16
 20057a4:	89402536 	bltu	r17,r5,200583c <_malloc_r+0x2d4>
 20057a8:	200d3180 	call	200d318 <__malloc_lock>
 20057ac:	00800184 	movi	r2,6
 20057b0:	01000084 	movi	r4,2
 20057b4:	04c08174 	movhi	r19,517
 20057b8:	1085883a 	add	r2,r2,r2
 20057bc:	9ce50e04 	addi	r19,r19,-27592
 20057c0:	1085883a 	add	r2,r2,r2
 20057c4:	9885883a 	add	r2,r19,r2
 20057c8:	14000117 	ldw	r16,4(r2)
 20057cc:	10fffe04 	addi	r3,r2,-8
 20057d0:	80c0d926 	beq	r16,r3,2005b38 <_malloc_r+0x5d0>
 20057d4:	80c00117 	ldw	r3,4(r16)
 20057d8:	81000317 	ldw	r4,12(r16)
 20057dc:	00bfff04 	movi	r2,-4
 20057e0:	1884703a 	and	r2,r3,r2
 20057e4:	81400217 	ldw	r5,8(r16)
 20057e8:	8085883a 	add	r2,r16,r2
 20057ec:	10c00117 	ldw	r3,4(r2)
 20057f0:	29000315 	stw	r4,12(r5)
 20057f4:	21400215 	stw	r5,8(r4)
 20057f8:	18c00054 	ori	r3,r3,1
 20057fc:	10c00115 	stw	r3,4(r2)
 2005800:	9009883a 	mov	r4,r18
 2005804:	200d3780 	call	200d378 <__malloc_unlock>
 2005808:	80800204 	addi	r2,r16,8
 200580c:	dfc00a17 	ldw	ra,40(sp)
 2005810:	df000917 	ldw	fp,36(sp)
 2005814:	ddc00817 	ldw	r23,32(sp)
 2005818:	dd800717 	ldw	r22,28(sp)
 200581c:	dd400617 	ldw	r21,24(sp)
 2005820:	dd000517 	ldw	r20,20(sp)
 2005824:	dcc00417 	ldw	r19,16(sp)
 2005828:	dc800317 	ldw	r18,12(sp)
 200582c:	dc400217 	ldw	r17,8(sp)
 2005830:	dc000117 	ldw	r16,4(sp)
 2005834:	dec00b04 	addi	sp,sp,44
 2005838:	f800283a 	ret
 200583c:	00800304 	movi	r2,12
 2005840:	90800015 	stw	r2,0(r18)
 2005844:	0005883a 	mov	r2,zero
 2005848:	003ff006 	br	200580c <__alt_mem_mem_0+0xfcfe580c>
 200584c:	01002004 	movi	r4,128
 2005850:	02001004 	movi	r8,64
 2005854:	01c00fc4 	movi	r7,63
 2005858:	003f6106 	br	20055e0 <__alt_mem_mem_0+0xfcfe55e0>
 200585c:	4009883a 	mov	r4,r8
 2005860:	003f7506 	br	2005638 <__alt_mem_mem_0+0xfcfe5638>
 2005864:	81000317 	ldw	r4,12(r16)
 2005868:	003fde06 	br	20057e4 <__alt_mem_mem_0+0xfcfe57e4>
 200586c:	81c5883a 	add	r2,r16,r7
 2005870:	11400117 	ldw	r5,4(r2)
 2005874:	9009883a 	mov	r4,r18
 2005878:	29400054 	ori	r5,r5,1
 200587c:	11400115 	stw	r5,4(r2)
 2005880:	200d3780 	call	200d378 <__malloc_unlock>
 2005884:	80800204 	addi	r2,r16,8
 2005888:	003fe006 	br	200580c <__alt_mem_mem_0+0xfcfe580c>
 200588c:	9c000217 	ldw	r16,8(r19)
 2005890:	00bfff04 	movi	r2,-4
 2005894:	85800117 	ldw	r22,4(r16)
 2005898:	b0ac703a 	and	r22,r22,r2
 200589c:	b4400336 	bltu	r22,r17,20058ac <_malloc_r+0x344>
 20058a0:	b445c83a 	sub	r2,r22,r17
 20058a4:	00c003c4 	movi	r3,15
 20058a8:	18805d16 	blt	r3,r2,2005a20 <_malloc_r+0x4b8>
 20058ac:	05c08174 	movhi	r23,517
 20058b0:	00808174 	movhi	r2,517
 20058b4:	10b2e204 	addi	r2,r2,-13432
 20058b8:	bdeb4204 	addi	r23,r23,-21240
 20058bc:	15400017 	ldw	r21,0(r2)
 20058c0:	b8c00017 	ldw	r3,0(r23)
 20058c4:	00bfffc4 	movi	r2,-1
 20058c8:	858d883a 	add	r6,r16,r22
 20058cc:	8d6b883a 	add	r21,r17,r21
 20058d0:	1880ea26 	beq	r3,r2,2005c7c <_malloc_r+0x714>
 20058d4:	ad4403c4 	addi	r21,r21,4111
 20058d8:	00bc0004 	movi	r2,-4096
 20058dc:	a8aa703a 	and	r21,r21,r2
 20058e0:	a80b883a 	mov	r5,r21
 20058e4:	9009883a 	mov	r4,r18
 20058e8:	d9800015 	stw	r6,0(sp)
 20058ec:	20071380 	call	2007138 <_sbrk_r>
 20058f0:	1029883a 	mov	r20,r2
 20058f4:	00bfffc4 	movi	r2,-1
 20058f8:	d9800017 	ldw	r6,0(sp)
 20058fc:	a080e826 	beq	r20,r2,2005ca0 <_malloc_r+0x738>
 2005900:	a180a636 	bltu	r20,r6,2005b9c <_malloc_r+0x634>
 2005904:	07008174 	movhi	fp,517
 2005908:	e7334304 	addi	fp,fp,-13044
 200590c:	e0800017 	ldw	r2,0(fp)
 2005910:	a887883a 	add	r3,r21,r2
 2005914:	e0c00015 	stw	r3,0(fp)
 2005918:	3500e626 	beq	r6,r20,2005cb4 <_malloc_r+0x74c>
 200591c:	b9000017 	ldw	r4,0(r23)
 2005920:	00bfffc4 	movi	r2,-1
 2005924:	2080ee26 	beq	r4,r2,2005ce0 <_malloc_r+0x778>
 2005928:	a185c83a 	sub	r2,r20,r6
 200592c:	10c5883a 	add	r2,r2,r3
 2005930:	e0800015 	stw	r2,0(fp)
 2005934:	a0c001cc 	andi	r3,r20,7
 2005938:	1800bc26 	beq	r3,zero,2005c2c <_malloc_r+0x6c4>
 200593c:	a0e9c83a 	sub	r20,r20,r3
 2005940:	00840204 	movi	r2,4104
 2005944:	a5000204 	addi	r20,r20,8
 2005948:	10c7c83a 	sub	r3,r2,r3
 200594c:	a545883a 	add	r2,r20,r21
 2005950:	1083ffcc 	andi	r2,r2,4095
 2005954:	18abc83a 	sub	r21,r3,r2
 2005958:	a80b883a 	mov	r5,r21
 200595c:	9009883a 	mov	r4,r18
 2005960:	20071380 	call	2007138 <_sbrk_r>
 2005964:	00ffffc4 	movi	r3,-1
 2005968:	10c0e126 	beq	r2,r3,2005cf0 <_malloc_r+0x788>
 200596c:	1505c83a 	sub	r2,r2,r20
 2005970:	1545883a 	add	r2,r2,r21
 2005974:	10800054 	ori	r2,r2,1
 2005978:	e0c00017 	ldw	r3,0(fp)
 200597c:	9d000215 	stw	r20,8(r19)
 2005980:	a0800115 	stw	r2,4(r20)
 2005984:	a8c7883a 	add	r3,r21,r3
 2005988:	e0c00015 	stw	r3,0(fp)
 200598c:	84c00e26 	beq	r16,r19,20059c8 <_malloc_r+0x460>
 2005990:	018003c4 	movi	r6,15
 2005994:	3580a72e 	bgeu	r6,r22,2005c34 <_malloc_r+0x6cc>
 2005998:	81400117 	ldw	r5,4(r16)
 200599c:	013ffe04 	movi	r4,-8
 20059a0:	b0bffd04 	addi	r2,r22,-12
 20059a4:	1104703a 	and	r2,r2,r4
 20059a8:	2900004c 	andi	r4,r5,1
 20059ac:	2088b03a 	or	r4,r4,r2
 20059b0:	81000115 	stw	r4,4(r16)
 20059b4:	01400144 	movi	r5,5
 20059b8:	8089883a 	add	r4,r16,r2
 20059bc:	21400115 	stw	r5,4(r4)
 20059c0:	21400215 	stw	r5,8(r4)
 20059c4:	3080cd36 	bltu	r6,r2,2005cfc <_malloc_r+0x794>
 20059c8:	00808174 	movhi	r2,517
 20059cc:	10b2e104 	addi	r2,r2,-13436
 20059d0:	11000017 	ldw	r4,0(r2)
 20059d4:	20c0012e 	bgeu	r4,r3,20059dc <_malloc_r+0x474>
 20059d8:	10c00015 	stw	r3,0(r2)
 20059dc:	00808174 	movhi	r2,517
 20059e0:	10b2e004 	addi	r2,r2,-13440
 20059e4:	11000017 	ldw	r4,0(r2)
 20059e8:	9c000217 	ldw	r16,8(r19)
 20059ec:	20c0012e 	bgeu	r4,r3,20059f4 <_malloc_r+0x48c>
 20059f0:	10c00015 	stw	r3,0(r2)
 20059f4:	80c00117 	ldw	r3,4(r16)
 20059f8:	00bfff04 	movi	r2,-4
 20059fc:	1886703a 	and	r3,r3,r2
 2005a00:	1c45c83a 	sub	r2,r3,r17
 2005a04:	1c400236 	bltu	r3,r17,2005a10 <_malloc_r+0x4a8>
 2005a08:	00c003c4 	movi	r3,15
 2005a0c:	18800416 	blt	r3,r2,2005a20 <_malloc_r+0x4b8>
 2005a10:	9009883a 	mov	r4,r18
 2005a14:	200d3780 	call	200d378 <__malloc_unlock>
 2005a18:	0005883a 	mov	r2,zero
 2005a1c:	003f7b06 	br	200580c <__alt_mem_mem_0+0xfcfe580c>
 2005a20:	88c00054 	ori	r3,r17,1
 2005a24:	80c00115 	stw	r3,4(r16)
 2005a28:	8463883a 	add	r17,r16,r17
 2005a2c:	10800054 	ori	r2,r2,1
 2005a30:	9c400215 	stw	r17,8(r19)
 2005a34:	88800115 	stw	r2,4(r17)
 2005a38:	9009883a 	mov	r4,r18
 2005a3c:	200d3780 	call	200d378 <__malloc_unlock>
 2005a40:	80800204 	addi	r2,r16,8
 2005a44:	003f7106 	br	200580c <__alt_mem_mem_0+0xfcfe580c>
 2005a48:	00c00504 	movi	r3,20
 2005a4c:	18804a2e 	bgeu	r3,r2,2005b78 <_malloc_r+0x610>
 2005a50:	00c01504 	movi	r3,84
 2005a54:	18806e36 	bltu	r3,r2,2005c10 <_malloc_r+0x6a8>
 2005a58:	8804d33a 	srli	r2,r17,12
 2005a5c:	12001bc4 	addi	r8,r2,111
 2005a60:	11c01b84 	addi	r7,r2,110
 2005a64:	4209883a 	add	r4,r8,r8
 2005a68:	003edd06 	br	20055e0 <__alt_mem_mem_0+0xfcfe55e0>
 2005a6c:	3804d27a 	srli	r2,r7,9
 2005a70:	00c00104 	movi	r3,4
 2005a74:	1880442e 	bgeu	r3,r2,2005b88 <_malloc_r+0x620>
 2005a78:	00c00504 	movi	r3,20
 2005a7c:	18808136 	bltu	r3,r2,2005c84 <_malloc_r+0x71c>
 2005a80:	11401704 	addi	r5,r2,92
 2005a84:	10c016c4 	addi	r3,r2,91
 2005a88:	294b883a 	add	r5,r5,r5
 2005a8c:	294b883a 	add	r5,r5,r5
 2005a90:	294b883a 	add	r5,r5,r5
 2005a94:	994b883a 	add	r5,r19,r5
 2005a98:	28800017 	ldw	r2,0(r5)
 2005a9c:	01808174 	movhi	r6,517
 2005aa0:	297ffe04 	addi	r5,r5,-8
 2005aa4:	31a50e04 	addi	r6,r6,-27592
 2005aa8:	28806526 	beq	r5,r2,2005c40 <_malloc_r+0x6d8>
 2005aac:	01bfff04 	movi	r6,-4
 2005ab0:	10c00117 	ldw	r3,4(r2)
 2005ab4:	1986703a 	and	r3,r3,r6
 2005ab8:	38c0022e 	bgeu	r7,r3,2005ac4 <_malloc_r+0x55c>
 2005abc:	10800217 	ldw	r2,8(r2)
 2005ac0:	28bffb1e 	bne	r5,r2,2005ab0 <__alt_mem_mem_0+0xfcfe5ab0>
 2005ac4:	11400317 	ldw	r5,12(r2)
 2005ac8:	98c00117 	ldw	r3,4(r19)
 2005acc:	81400315 	stw	r5,12(r16)
 2005ad0:	80800215 	stw	r2,8(r16)
 2005ad4:	2c000215 	stw	r16,8(r5)
 2005ad8:	14000315 	stw	r16,12(r2)
 2005adc:	003ef806 	br	20056c0 <__alt_mem_mem_0+0xfcfe56c0>
 2005ae0:	88c00054 	ori	r3,r17,1
 2005ae4:	80c00115 	stw	r3,4(r16)
 2005ae8:	8463883a 	add	r17,r16,r17
 2005aec:	34400515 	stw	r17,20(r6)
 2005af0:	34400415 	stw	r17,16(r6)
 2005af4:	10c00054 	ori	r3,r2,1
 2005af8:	8a000315 	stw	r8,12(r17)
 2005afc:	8a000215 	stw	r8,8(r17)
 2005b00:	88c00115 	stw	r3,4(r17)
 2005b04:	88a3883a 	add	r17,r17,r2
 2005b08:	88800015 	stw	r2,0(r17)
 2005b0c:	9009883a 	mov	r4,r18
 2005b10:	200d3780 	call	200d378 <__malloc_unlock>
 2005b14:	80800204 	addi	r2,r16,8
 2005b18:	003f3c06 	br	200580c <__alt_mem_mem_0+0xfcfe580c>
 2005b1c:	30c00117 	ldw	r3,4(r6)
 2005b20:	003ee706 	br	20056c0 <__alt_mem_mem_0+0xfcfe56c0>
 2005b24:	5ac00044 	addi	r11,r11,1
 2005b28:	588000cc 	andi	r2,r11,3
 2005b2c:	31800204 	addi	r6,r6,8
 2005b30:	103efd1e 	bne	r2,zero,2005728 <__alt_mem_mem_0+0xfcfe5728>
 2005b34:	00002406 	br	2005bc8 <_malloc_r+0x660>
 2005b38:	14000317 	ldw	r16,12(r2)
 2005b3c:	143f251e 	bne	r2,r16,20057d4 <__alt_mem_mem_0+0xfcfe57d4>
 2005b40:	21000084 	addi	r4,r4,2
 2005b44:	003ebc06 	br	2005638 <__alt_mem_mem_0+0xfcfe5638>
 2005b48:	8085883a 	add	r2,r16,r2
 2005b4c:	10c00117 	ldw	r3,4(r2)
 2005b50:	81000317 	ldw	r4,12(r16)
 2005b54:	81400217 	ldw	r5,8(r16)
 2005b58:	18c00054 	ori	r3,r3,1
 2005b5c:	10c00115 	stw	r3,4(r2)
 2005b60:	29000315 	stw	r4,12(r5)
 2005b64:	21400215 	stw	r5,8(r4)
 2005b68:	9009883a 	mov	r4,r18
 2005b6c:	200d3780 	call	200d378 <__malloc_unlock>
 2005b70:	80800204 	addi	r2,r16,8
 2005b74:	003f2506 	br	200580c <__alt_mem_mem_0+0xfcfe580c>
 2005b78:	12001704 	addi	r8,r2,92
 2005b7c:	11c016c4 	addi	r7,r2,91
 2005b80:	4209883a 	add	r4,r8,r8
 2005b84:	003e9606 	br	20055e0 <__alt_mem_mem_0+0xfcfe55e0>
 2005b88:	3804d1ba 	srli	r2,r7,6
 2005b8c:	11400e44 	addi	r5,r2,57
 2005b90:	10c00e04 	addi	r3,r2,56
 2005b94:	294b883a 	add	r5,r5,r5
 2005b98:	003fbc06 	br	2005a8c <__alt_mem_mem_0+0xfcfe5a8c>
 2005b9c:	84ff5926 	beq	r16,r19,2005904 <__alt_mem_mem_0+0xfcfe5904>
 2005ba0:	00808174 	movhi	r2,517
 2005ba4:	10a50e04 	addi	r2,r2,-27592
 2005ba8:	14000217 	ldw	r16,8(r2)
 2005bac:	00bfff04 	movi	r2,-4
 2005bb0:	80c00117 	ldw	r3,4(r16)
 2005bb4:	1886703a 	and	r3,r3,r2
 2005bb8:	003f9106 	br	2005a00 <__alt_mem_mem_0+0xfcfe5a00>
 2005bbc:	60800217 	ldw	r2,8(r12)
 2005bc0:	213fffc4 	addi	r4,r4,-1
 2005bc4:	1300651e 	bne	r2,r12,2005d5c <_malloc_r+0x7f4>
 2005bc8:	208000cc 	andi	r2,r4,3
 2005bcc:	633ffe04 	addi	r12,r12,-8
 2005bd0:	103ffa1e 	bne	r2,zero,2005bbc <__alt_mem_mem_0+0xfcfe5bbc>
 2005bd4:	98800117 	ldw	r2,4(r19)
 2005bd8:	0146303a 	nor	r3,zero,r5
 2005bdc:	1884703a 	and	r2,r3,r2
 2005be0:	98800115 	stw	r2,4(r19)
 2005be4:	294b883a 	add	r5,r5,r5
 2005be8:	117f2836 	bltu	r2,r5,200588c <__alt_mem_mem_0+0xfcfe588c>
 2005bec:	283f2726 	beq	r5,zero,200588c <__alt_mem_mem_0+0xfcfe588c>
 2005bf0:	2886703a 	and	r3,r5,r2
 2005bf4:	5809883a 	mov	r4,r11
 2005bf8:	183ec31e 	bne	r3,zero,2005708 <__alt_mem_mem_0+0xfcfe5708>
 2005bfc:	294b883a 	add	r5,r5,r5
 2005c00:	2886703a 	and	r3,r5,r2
 2005c04:	21000104 	addi	r4,r4,4
 2005c08:	183ffc26 	beq	r3,zero,2005bfc <__alt_mem_mem_0+0xfcfe5bfc>
 2005c0c:	003ebe06 	br	2005708 <__alt_mem_mem_0+0xfcfe5708>
 2005c10:	00c05504 	movi	r3,340
 2005c14:	18801236 	bltu	r3,r2,2005c60 <_malloc_r+0x6f8>
 2005c18:	8804d3fa 	srli	r2,r17,15
 2005c1c:	12001e04 	addi	r8,r2,120
 2005c20:	11c01dc4 	addi	r7,r2,119
 2005c24:	4209883a 	add	r4,r8,r8
 2005c28:	003e6d06 	br	20055e0 <__alt_mem_mem_0+0xfcfe55e0>
 2005c2c:	00c40004 	movi	r3,4096
 2005c30:	003f4606 	br	200594c <__alt_mem_mem_0+0xfcfe594c>
 2005c34:	00800044 	movi	r2,1
 2005c38:	a0800115 	stw	r2,4(r20)
 2005c3c:	003f7406 	br	2005a10 <__alt_mem_mem_0+0xfcfe5a10>
 2005c40:	1805d0ba 	srai	r2,r3,2
 2005c44:	01c00044 	movi	r7,1
 2005c48:	30c00117 	ldw	r3,4(r6)
 2005c4c:	388e983a 	sll	r7,r7,r2
 2005c50:	2805883a 	mov	r2,r5
 2005c54:	38c6b03a 	or	r3,r7,r3
 2005c58:	30c00115 	stw	r3,4(r6)
 2005c5c:	003f9b06 	br	2005acc <__alt_mem_mem_0+0xfcfe5acc>
 2005c60:	00c15504 	movi	r3,1364
 2005c64:	18801a36 	bltu	r3,r2,2005cd0 <_malloc_r+0x768>
 2005c68:	8804d4ba 	srli	r2,r17,18
 2005c6c:	12001f44 	addi	r8,r2,125
 2005c70:	11c01f04 	addi	r7,r2,124
 2005c74:	4209883a 	add	r4,r8,r8
 2005c78:	003e5906 	br	20055e0 <__alt_mem_mem_0+0xfcfe55e0>
 2005c7c:	ad400404 	addi	r21,r21,16
 2005c80:	003f1706 	br	20058e0 <__alt_mem_mem_0+0xfcfe58e0>
 2005c84:	00c01504 	movi	r3,84
 2005c88:	18802336 	bltu	r3,r2,2005d18 <_malloc_r+0x7b0>
 2005c8c:	3804d33a 	srli	r2,r7,12
 2005c90:	11401bc4 	addi	r5,r2,111
 2005c94:	10c01b84 	addi	r3,r2,110
 2005c98:	294b883a 	add	r5,r5,r5
 2005c9c:	003f7b06 	br	2005a8c <__alt_mem_mem_0+0xfcfe5a8c>
 2005ca0:	9c000217 	ldw	r16,8(r19)
 2005ca4:	00bfff04 	movi	r2,-4
 2005ca8:	80c00117 	ldw	r3,4(r16)
 2005cac:	1886703a 	and	r3,r3,r2
 2005cb0:	003f5306 	br	2005a00 <__alt_mem_mem_0+0xfcfe5a00>
 2005cb4:	3083ffcc 	andi	r2,r6,4095
 2005cb8:	103f181e 	bne	r2,zero,200591c <__alt_mem_mem_0+0xfcfe591c>
 2005cbc:	99000217 	ldw	r4,8(r19)
 2005cc0:	b545883a 	add	r2,r22,r21
 2005cc4:	10800054 	ori	r2,r2,1
 2005cc8:	20800115 	stw	r2,4(r4)
 2005ccc:	003f3e06 	br	20059c8 <__alt_mem_mem_0+0xfcfe59c8>
 2005cd0:	01003f84 	movi	r4,254
 2005cd4:	02001fc4 	movi	r8,127
 2005cd8:	01c01f84 	movi	r7,126
 2005cdc:	003e4006 	br	20055e0 <__alt_mem_mem_0+0xfcfe55e0>
 2005ce0:	00808174 	movhi	r2,517
 2005ce4:	10ab4204 	addi	r2,r2,-21240
 2005ce8:	15000015 	stw	r20,0(r2)
 2005cec:	003f1106 	br	2005934 <__alt_mem_mem_0+0xfcfe5934>
 2005cf0:	00800044 	movi	r2,1
 2005cf4:	002b883a 	mov	r21,zero
 2005cf8:	003f1f06 	br	2005978 <__alt_mem_mem_0+0xfcfe5978>
 2005cfc:	81400204 	addi	r5,r16,8
 2005d00:	9009883a 	mov	r4,r18
 2005d04:	2004e380 	call	2004e38 <_free_r>
 2005d08:	00808174 	movhi	r2,517
 2005d0c:	10b34304 	addi	r2,r2,-13044
 2005d10:	10c00017 	ldw	r3,0(r2)
 2005d14:	003f2c06 	br	20059c8 <__alt_mem_mem_0+0xfcfe59c8>
 2005d18:	00c05504 	movi	r3,340
 2005d1c:	18800536 	bltu	r3,r2,2005d34 <_malloc_r+0x7cc>
 2005d20:	3804d3fa 	srli	r2,r7,15
 2005d24:	11401e04 	addi	r5,r2,120
 2005d28:	10c01dc4 	addi	r3,r2,119
 2005d2c:	294b883a 	add	r5,r5,r5
 2005d30:	003f5606 	br	2005a8c <__alt_mem_mem_0+0xfcfe5a8c>
 2005d34:	00c15504 	movi	r3,1364
 2005d38:	18800536 	bltu	r3,r2,2005d50 <_malloc_r+0x7e8>
 2005d3c:	3804d4ba 	srli	r2,r7,18
 2005d40:	11401f44 	addi	r5,r2,125
 2005d44:	10c01f04 	addi	r3,r2,124
 2005d48:	294b883a 	add	r5,r5,r5
 2005d4c:	003f4f06 	br	2005a8c <__alt_mem_mem_0+0xfcfe5a8c>
 2005d50:	01403f84 	movi	r5,254
 2005d54:	00c01f84 	movi	r3,126
 2005d58:	003f4c06 	br	2005a8c <__alt_mem_mem_0+0xfcfe5a8c>
 2005d5c:	98800117 	ldw	r2,4(r19)
 2005d60:	003fa006 	br	2005be4 <__alt_mem_mem_0+0xfcfe5be4>
 2005d64:	8808d0fa 	srli	r4,r17,3
 2005d68:	20800044 	addi	r2,r4,1
 2005d6c:	1085883a 	add	r2,r2,r2
 2005d70:	003e9006 	br	20057b4 <__alt_mem_mem_0+0xfcfe57b4>

02005d74 <memchr>:
 2005d74:	208000cc 	andi	r2,r4,3
 2005d78:	280f883a 	mov	r7,r5
 2005d7c:	10003426 	beq	r2,zero,2005e50 <memchr+0xdc>
 2005d80:	30bfffc4 	addi	r2,r6,-1
 2005d84:	30001a26 	beq	r6,zero,2005df0 <memchr+0x7c>
 2005d88:	20c00003 	ldbu	r3,0(r4)
 2005d8c:	29803fcc 	andi	r6,r5,255
 2005d90:	30c0051e 	bne	r6,r3,2005da8 <memchr+0x34>
 2005d94:	00001806 	br	2005df8 <memchr+0x84>
 2005d98:	10001526 	beq	r2,zero,2005df0 <memchr+0x7c>
 2005d9c:	20c00003 	ldbu	r3,0(r4)
 2005da0:	10bfffc4 	addi	r2,r2,-1
 2005da4:	30c01426 	beq	r6,r3,2005df8 <memchr+0x84>
 2005da8:	21000044 	addi	r4,r4,1
 2005dac:	20c000cc 	andi	r3,r4,3
 2005db0:	183ff91e 	bne	r3,zero,2005d98 <__alt_mem_mem_0+0xfcfe5d98>
 2005db4:	020000c4 	movi	r8,3
 2005db8:	40801136 	bltu	r8,r2,2005e00 <memchr+0x8c>
 2005dbc:	10000c26 	beq	r2,zero,2005df0 <memchr+0x7c>
 2005dc0:	20c00003 	ldbu	r3,0(r4)
 2005dc4:	29403fcc 	andi	r5,r5,255
 2005dc8:	28c00b26 	beq	r5,r3,2005df8 <memchr+0x84>
 2005dcc:	20c00044 	addi	r3,r4,1
 2005dd0:	39803fcc 	andi	r6,r7,255
 2005dd4:	2089883a 	add	r4,r4,r2
 2005dd8:	00000306 	br	2005de8 <memchr+0x74>
 2005ddc:	18c00044 	addi	r3,r3,1
 2005de0:	197fffc3 	ldbu	r5,-1(r3)
 2005de4:	31400526 	beq	r6,r5,2005dfc <memchr+0x88>
 2005de8:	1805883a 	mov	r2,r3
 2005dec:	20fffb1e 	bne	r4,r3,2005ddc <__alt_mem_mem_0+0xfcfe5ddc>
 2005df0:	0005883a 	mov	r2,zero
 2005df4:	f800283a 	ret
 2005df8:	2005883a 	mov	r2,r4
 2005dfc:	f800283a 	ret
 2005e00:	28c03fcc 	andi	r3,r5,255
 2005e04:	1812923a 	slli	r9,r3,8
 2005e08:	02ffbff4 	movhi	r11,65279
 2005e0c:	02a02074 	movhi	r10,32897
 2005e10:	48d2b03a 	or	r9,r9,r3
 2005e14:	4806943a 	slli	r3,r9,16
 2005e18:	5affbfc4 	addi	r11,r11,-257
 2005e1c:	52a02004 	addi	r10,r10,-32640
 2005e20:	48d2b03a 	or	r9,r9,r3
 2005e24:	20c00017 	ldw	r3,0(r4)
 2005e28:	48c6f03a 	xor	r3,r9,r3
 2005e2c:	1acd883a 	add	r6,r3,r11
 2005e30:	00c6303a 	nor	r3,zero,r3
 2005e34:	30c6703a 	and	r3,r6,r3
 2005e38:	1a86703a 	and	r3,r3,r10
 2005e3c:	183fe01e 	bne	r3,zero,2005dc0 <__alt_mem_mem_0+0xfcfe5dc0>
 2005e40:	10bfff04 	addi	r2,r2,-4
 2005e44:	21000104 	addi	r4,r4,4
 2005e48:	40bff636 	bltu	r8,r2,2005e24 <__alt_mem_mem_0+0xfcfe5e24>
 2005e4c:	003fdb06 	br	2005dbc <__alt_mem_mem_0+0xfcfe5dbc>
 2005e50:	3005883a 	mov	r2,r6
 2005e54:	003fd706 	br	2005db4 <__alt_mem_mem_0+0xfcfe5db4>

02005e58 <memcpy>:
 2005e58:	defffd04 	addi	sp,sp,-12
 2005e5c:	dfc00215 	stw	ra,8(sp)
 2005e60:	dc400115 	stw	r17,4(sp)
 2005e64:	dc000015 	stw	r16,0(sp)
 2005e68:	00c003c4 	movi	r3,15
 2005e6c:	2005883a 	mov	r2,r4
 2005e70:	1980452e 	bgeu	r3,r6,2005f88 <memcpy+0x130>
 2005e74:	2906b03a 	or	r3,r5,r4
 2005e78:	18c000cc 	andi	r3,r3,3
 2005e7c:	1800441e 	bne	r3,zero,2005f90 <memcpy+0x138>
 2005e80:	347ffc04 	addi	r17,r6,-16
 2005e84:	8822d13a 	srli	r17,r17,4
 2005e88:	28c00104 	addi	r3,r5,4
 2005e8c:	23400104 	addi	r13,r4,4
 2005e90:	8820913a 	slli	r16,r17,4
 2005e94:	2b000204 	addi	r12,r5,8
 2005e98:	22c00204 	addi	r11,r4,8
 2005e9c:	84000504 	addi	r16,r16,20
 2005ea0:	2a800304 	addi	r10,r5,12
 2005ea4:	22400304 	addi	r9,r4,12
 2005ea8:	2c21883a 	add	r16,r5,r16
 2005eac:	2811883a 	mov	r8,r5
 2005eb0:	200f883a 	mov	r7,r4
 2005eb4:	41000017 	ldw	r4,0(r8)
 2005eb8:	1fc00017 	ldw	ra,0(r3)
 2005ebc:	63c00017 	ldw	r15,0(r12)
 2005ec0:	39000015 	stw	r4,0(r7)
 2005ec4:	53800017 	ldw	r14,0(r10)
 2005ec8:	6fc00015 	stw	ra,0(r13)
 2005ecc:	5bc00015 	stw	r15,0(r11)
 2005ed0:	4b800015 	stw	r14,0(r9)
 2005ed4:	18c00404 	addi	r3,r3,16
 2005ed8:	39c00404 	addi	r7,r7,16
 2005edc:	42000404 	addi	r8,r8,16
 2005ee0:	6b400404 	addi	r13,r13,16
 2005ee4:	63000404 	addi	r12,r12,16
 2005ee8:	5ac00404 	addi	r11,r11,16
 2005eec:	52800404 	addi	r10,r10,16
 2005ef0:	4a400404 	addi	r9,r9,16
 2005ef4:	1c3fef1e 	bne	r3,r16,2005eb4 <__alt_mem_mem_0+0xfcfe5eb4>
 2005ef8:	89c00044 	addi	r7,r17,1
 2005efc:	380e913a 	slli	r7,r7,4
 2005f00:	310003cc 	andi	r4,r6,15
 2005f04:	02c000c4 	movi	r11,3
 2005f08:	11c7883a 	add	r3,r2,r7
 2005f0c:	29cb883a 	add	r5,r5,r7
 2005f10:	5900212e 	bgeu	r11,r4,2005f98 <memcpy+0x140>
 2005f14:	1813883a 	mov	r9,r3
 2005f18:	2811883a 	mov	r8,r5
 2005f1c:	200f883a 	mov	r7,r4
 2005f20:	42800017 	ldw	r10,0(r8)
 2005f24:	4a400104 	addi	r9,r9,4
 2005f28:	39ffff04 	addi	r7,r7,-4
 2005f2c:	4abfff15 	stw	r10,-4(r9)
 2005f30:	42000104 	addi	r8,r8,4
 2005f34:	59fffa36 	bltu	r11,r7,2005f20 <__alt_mem_mem_0+0xfcfe5f20>
 2005f38:	213fff04 	addi	r4,r4,-4
 2005f3c:	2008d0ba 	srli	r4,r4,2
 2005f40:	318000cc 	andi	r6,r6,3
 2005f44:	21000044 	addi	r4,r4,1
 2005f48:	2109883a 	add	r4,r4,r4
 2005f4c:	2109883a 	add	r4,r4,r4
 2005f50:	1907883a 	add	r3,r3,r4
 2005f54:	290b883a 	add	r5,r5,r4
 2005f58:	30000626 	beq	r6,zero,2005f74 <memcpy+0x11c>
 2005f5c:	198d883a 	add	r6,r3,r6
 2005f60:	29c00003 	ldbu	r7,0(r5)
 2005f64:	18c00044 	addi	r3,r3,1
 2005f68:	29400044 	addi	r5,r5,1
 2005f6c:	19ffffc5 	stb	r7,-1(r3)
 2005f70:	19bffb1e 	bne	r3,r6,2005f60 <__alt_mem_mem_0+0xfcfe5f60>
 2005f74:	dfc00217 	ldw	ra,8(sp)
 2005f78:	dc400117 	ldw	r17,4(sp)
 2005f7c:	dc000017 	ldw	r16,0(sp)
 2005f80:	dec00304 	addi	sp,sp,12
 2005f84:	f800283a 	ret
 2005f88:	2007883a 	mov	r3,r4
 2005f8c:	003ff206 	br	2005f58 <__alt_mem_mem_0+0xfcfe5f58>
 2005f90:	2007883a 	mov	r3,r4
 2005f94:	003ff106 	br	2005f5c <__alt_mem_mem_0+0xfcfe5f5c>
 2005f98:	200d883a 	mov	r6,r4
 2005f9c:	003fee06 	br	2005f58 <__alt_mem_mem_0+0xfcfe5f58>

02005fa0 <memset>:
 2005fa0:	20c000cc 	andi	r3,r4,3
 2005fa4:	2005883a 	mov	r2,r4
 2005fa8:	18004426 	beq	r3,zero,20060bc <memset+0x11c>
 2005fac:	31ffffc4 	addi	r7,r6,-1
 2005fb0:	30004026 	beq	r6,zero,20060b4 <memset+0x114>
 2005fb4:	2813883a 	mov	r9,r5
 2005fb8:	200d883a 	mov	r6,r4
 2005fbc:	2007883a 	mov	r3,r4
 2005fc0:	00000406 	br	2005fd4 <memset+0x34>
 2005fc4:	3a3fffc4 	addi	r8,r7,-1
 2005fc8:	31800044 	addi	r6,r6,1
 2005fcc:	38003926 	beq	r7,zero,20060b4 <memset+0x114>
 2005fd0:	400f883a 	mov	r7,r8
 2005fd4:	18c00044 	addi	r3,r3,1
 2005fd8:	32400005 	stb	r9,0(r6)
 2005fdc:	1a0000cc 	andi	r8,r3,3
 2005fe0:	403ff81e 	bne	r8,zero,2005fc4 <__alt_mem_mem_0+0xfcfe5fc4>
 2005fe4:	010000c4 	movi	r4,3
 2005fe8:	21c02d2e 	bgeu	r4,r7,20060a0 <memset+0x100>
 2005fec:	29003fcc 	andi	r4,r5,255
 2005ff0:	200c923a 	slli	r6,r4,8
 2005ff4:	3108b03a 	or	r4,r6,r4
 2005ff8:	200c943a 	slli	r6,r4,16
 2005ffc:	218cb03a 	or	r6,r4,r6
 2006000:	010003c4 	movi	r4,15
 2006004:	21c0182e 	bgeu	r4,r7,2006068 <memset+0xc8>
 2006008:	3b3ffc04 	addi	r12,r7,-16
 200600c:	6018d13a 	srli	r12,r12,4
 2006010:	1a000104 	addi	r8,r3,4
 2006014:	1ac00204 	addi	r11,r3,8
 2006018:	6008913a 	slli	r4,r12,4
 200601c:	1a800304 	addi	r10,r3,12
 2006020:	1813883a 	mov	r9,r3
 2006024:	21000504 	addi	r4,r4,20
 2006028:	1909883a 	add	r4,r3,r4
 200602c:	49800015 	stw	r6,0(r9)
 2006030:	41800015 	stw	r6,0(r8)
 2006034:	59800015 	stw	r6,0(r11)
 2006038:	51800015 	stw	r6,0(r10)
 200603c:	42000404 	addi	r8,r8,16
 2006040:	4a400404 	addi	r9,r9,16
 2006044:	5ac00404 	addi	r11,r11,16
 2006048:	52800404 	addi	r10,r10,16
 200604c:	413ff71e 	bne	r8,r4,200602c <__alt_mem_mem_0+0xfcfe602c>
 2006050:	63000044 	addi	r12,r12,1
 2006054:	6018913a 	slli	r12,r12,4
 2006058:	39c003cc 	andi	r7,r7,15
 200605c:	010000c4 	movi	r4,3
 2006060:	1b07883a 	add	r3,r3,r12
 2006064:	21c00e2e 	bgeu	r4,r7,20060a0 <memset+0x100>
 2006068:	1813883a 	mov	r9,r3
 200606c:	3811883a 	mov	r8,r7
 2006070:	010000c4 	movi	r4,3
 2006074:	49800015 	stw	r6,0(r9)
 2006078:	423fff04 	addi	r8,r8,-4
 200607c:	4a400104 	addi	r9,r9,4
 2006080:	223ffc36 	bltu	r4,r8,2006074 <__alt_mem_mem_0+0xfcfe6074>
 2006084:	393fff04 	addi	r4,r7,-4
 2006088:	2008d0ba 	srli	r4,r4,2
 200608c:	39c000cc 	andi	r7,r7,3
 2006090:	21000044 	addi	r4,r4,1
 2006094:	2109883a 	add	r4,r4,r4
 2006098:	2109883a 	add	r4,r4,r4
 200609c:	1907883a 	add	r3,r3,r4
 20060a0:	38000526 	beq	r7,zero,20060b8 <memset+0x118>
 20060a4:	19cf883a 	add	r7,r3,r7
 20060a8:	19400005 	stb	r5,0(r3)
 20060ac:	18c00044 	addi	r3,r3,1
 20060b0:	38fffd1e 	bne	r7,r3,20060a8 <__alt_mem_mem_0+0xfcfe60a8>
 20060b4:	f800283a 	ret
 20060b8:	f800283a 	ret
 20060bc:	2007883a 	mov	r3,r4
 20060c0:	300f883a 	mov	r7,r6
 20060c4:	003fc706 	br	2005fe4 <__alt_mem_mem_0+0xfcfe5fe4>

020060c8 <_Balloc>:
 20060c8:	20801317 	ldw	r2,76(r4)
 20060cc:	defffc04 	addi	sp,sp,-16
 20060d0:	dc400115 	stw	r17,4(sp)
 20060d4:	dc000015 	stw	r16,0(sp)
 20060d8:	dfc00315 	stw	ra,12(sp)
 20060dc:	dc800215 	stw	r18,8(sp)
 20060e0:	2023883a 	mov	r17,r4
 20060e4:	2821883a 	mov	r16,r5
 20060e8:	10000f26 	beq	r2,zero,2006128 <_Balloc+0x60>
 20060ec:	8407883a 	add	r3,r16,r16
 20060f0:	18c7883a 	add	r3,r3,r3
 20060f4:	10c7883a 	add	r3,r2,r3
 20060f8:	18800017 	ldw	r2,0(r3)
 20060fc:	10001126 	beq	r2,zero,2006144 <_Balloc+0x7c>
 2006100:	11000017 	ldw	r4,0(r2)
 2006104:	19000015 	stw	r4,0(r3)
 2006108:	10000415 	stw	zero,16(r2)
 200610c:	10000315 	stw	zero,12(r2)
 2006110:	dfc00317 	ldw	ra,12(sp)
 2006114:	dc800217 	ldw	r18,8(sp)
 2006118:	dc400117 	ldw	r17,4(sp)
 200611c:	dc000017 	ldw	r16,0(sp)
 2006120:	dec00404 	addi	sp,sp,16
 2006124:	f800283a 	ret
 2006128:	01800844 	movi	r6,33
 200612c:	01400104 	movi	r5,4
 2006130:	2008b380 	call	2008b38 <_calloc_r>
 2006134:	88801315 	stw	r2,76(r17)
 2006138:	103fec1e 	bne	r2,zero,20060ec <__alt_mem_mem_0+0xfcfe60ec>
 200613c:	0005883a 	mov	r2,zero
 2006140:	003ff306 	br	2006110 <__alt_mem_mem_0+0xfcfe6110>
 2006144:	01400044 	movi	r5,1
 2006148:	2c24983a 	sll	r18,r5,r16
 200614c:	8809883a 	mov	r4,r17
 2006150:	91800144 	addi	r6,r18,5
 2006154:	318d883a 	add	r6,r6,r6
 2006158:	318d883a 	add	r6,r6,r6
 200615c:	2008b380 	call	2008b38 <_calloc_r>
 2006160:	103ff626 	beq	r2,zero,200613c <__alt_mem_mem_0+0xfcfe613c>
 2006164:	14000115 	stw	r16,4(r2)
 2006168:	14800215 	stw	r18,8(r2)
 200616c:	003fe606 	br	2006108 <__alt_mem_mem_0+0xfcfe6108>

02006170 <_Bfree>:
 2006170:	28000826 	beq	r5,zero,2006194 <_Bfree+0x24>
 2006174:	28c00117 	ldw	r3,4(r5)
 2006178:	20801317 	ldw	r2,76(r4)
 200617c:	18c7883a 	add	r3,r3,r3
 2006180:	18c7883a 	add	r3,r3,r3
 2006184:	10c5883a 	add	r2,r2,r3
 2006188:	10c00017 	ldw	r3,0(r2)
 200618c:	28c00015 	stw	r3,0(r5)
 2006190:	11400015 	stw	r5,0(r2)
 2006194:	f800283a 	ret

02006198 <__multadd>:
 2006198:	defffa04 	addi	sp,sp,-24
 200619c:	dc800315 	stw	r18,12(sp)
 20061a0:	dc400215 	stw	r17,8(sp)
 20061a4:	dc000115 	stw	r16,4(sp)
 20061a8:	2823883a 	mov	r17,r5
 20061ac:	2c000417 	ldw	r16,16(r5)
 20061b0:	dfc00515 	stw	ra,20(sp)
 20061b4:	dcc00415 	stw	r19,16(sp)
 20061b8:	2025883a 	mov	r18,r4
 20061bc:	29400504 	addi	r5,r5,20
 20061c0:	0011883a 	mov	r8,zero
 20061c4:	28c00017 	ldw	r3,0(r5)
 20061c8:	29400104 	addi	r5,r5,4
 20061cc:	42000044 	addi	r8,r8,1
 20061d0:	18bfffcc 	andi	r2,r3,65535
 20061d4:	1185383a 	mul	r2,r2,r6
 20061d8:	1806d43a 	srli	r3,r3,16
 20061dc:	11cf883a 	add	r7,r2,r7
 20061e0:	3808d43a 	srli	r4,r7,16
 20061e4:	1987383a 	mul	r3,r3,r6
 20061e8:	38bfffcc 	andi	r2,r7,65535
 20061ec:	1907883a 	add	r3,r3,r4
 20061f0:	1808943a 	slli	r4,r3,16
 20061f4:	180ed43a 	srli	r7,r3,16
 20061f8:	2085883a 	add	r2,r4,r2
 20061fc:	28bfff15 	stw	r2,-4(r5)
 2006200:	443ff016 	blt	r8,r16,20061c4 <__alt_mem_mem_0+0xfcfe61c4>
 2006204:	38000926 	beq	r7,zero,200622c <__multadd+0x94>
 2006208:	88800217 	ldw	r2,8(r17)
 200620c:	80800f0e 	bge	r16,r2,200624c <__multadd+0xb4>
 2006210:	80800144 	addi	r2,r16,5
 2006214:	1085883a 	add	r2,r2,r2
 2006218:	1085883a 	add	r2,r2,r2
 200621c:	8885883a 	add	r2,r17,r2
 2006220:	11c00015 	stw	r7,0(r2)
 2006224:	84000044 	addi	r16,r16,1
 2006228:	8c000415 	stw	r16,16(r17)
 200622c:	8805883a 	mov	r2,r17
 2006230:	dfc00517 	ldw	ra,20(sp)
 2006234:	dcc00417 	ldw	r19,16(sp)
 2006238:	dc800317 	ldw	r18,12(sp)
 200623c:	dc400217 	ldw	r17,8(sp)
 2006240:	dc000117 	ldw	r16,4(sp)
 2006244:	dec00604 	addi	sp,sp,24
 2006248:	f800283a 	ret
 200624c:	89400117 	ldw	r5,4(r17)
 2006250:	9009883a 	mov	r4,r18
 2006254:	d9c00015 	stw	r7,0(sp)
 2006258:	29400044 	addi	r5,r5,1
 200625c:	20060c80 	call	20060c8 <_Balloc>
 2006260:	89800417 	ldw	r6,16(r17)
 2006264:	89400304 	addi	r5,r17,12
 2006268:	11000304 	addi	r4,r2,12
 200626c:	31800084 	addi	r6,r6,2
 2006270:	318d883a 	add	r6,r6,r6
 2006274:	318d883a 	add	r6,r6,r6
 2006278:	1027883a 	mov	r19,r2
 200627c:	2005e580 	call	2005e58 <memcpy>
 2006280:	d9c00017 	ldw	r7,0(sp)
 2006284:	88000a26 	beq	r17,zero,20062b0 <__multadd+0x118>
 2006288:	88c00117 	ldw	r3,4(r17)
 200628c:	90801317 	ldw	r2,76(r18)
 2006290:	18c7883a 	add	r3,r3,r3
 2006294:	18c7883a 	add	r3,r3,r3
 2006298:	10c5883a 	add	r2,r2,r3
 200629c:	10c00017 	ldw	r3,0(r2)
 20062a0:	88c00015 	stw	r3,0(r17)
 20062a4:	14400015 	stw	r17,0(r2)
 20062a8:	9823883a 	mov	r17,r19
 20062ac:	003fd806 	br	2006210 <__alt_mem_mem_0+0xfcfe6210>
 20062b0:	9823883a 	mov	r17,r19
 20062b4:	003fd606 	br	2006210 <__alt_mem_mem_0+0xfcfe6210>

020062b8 <__s2b>:
 20062b8:	defff904 	addi	sp,sp,-28
 20062bc:	dc400115 	stw	r17,4(sp)
 20062c0:	dc000015 	stw	r16,0(sp)
 20062c4:	2023883a 	mov	r17,r4
 20062c8:	2821883a 	mov	r16,r5
 20062cc:	39000204 	addi	r4,r7,8
 20062d0:	01400244 	movi	r5,9
 20062d4:	dcc00315 	stw	r19,12(sp)
 20062d8:	dc800215 	stw	r18,8(sp)
 20062dc:	dfc00615 	stw	ra,24(sp)
 20062e0:	dd400515 	stw	r21,20(sp)
 20062e4:	dd000415 	stw	r20,16(sp)
 20062e8:	3825883a 	mov	r18,r7
 20062ec:	3027883a 	mov	r19,r6
 20062f0:	200a9e40 	call	200a9e4 <__divsi3>
 20062f4:	00c00044 	movi	r3,1
 20062f8:	000b883a 	mov	r5,zero
 20062fc:	1880030e 	bge	r3,r2,200630c <__s2b+0x54>
 2006300:	18c7883a 	add	r3,r3,r3
 2006304:	29400044 	addi	r5,r5,1
 2006308:	18bffd16 	blt	r3,r2,2006300 <__alt_mem_mem_0+0xfcfe6300>
 200630c:	8809883a 	mov	r4,r17
 2006310:	20060c80 	call	20060c8 <_Balloc>
 2006314:	d8c00717 	ldw	r3,28(sp)
 2006318:	10c00515 	stw	r3,20(r2)
 200631c:	00c00044 	movi	r3,1
 2006320:	10c00415 	stw	r3,16(r2)
 2006324:	00c00244 	movi	r3,9
 2006328:	1cc0210e 	bge	r3,r19,20063b0 <__s2b+0xf8>
 200632c:	80eb883a 	add	r21,r16,r3
 2006330:	a829883a 	mov	r20,r21
 2006334:	84e1883a 	add	r16,r16,r19
 2006338:	a1c00007 	ldb	r7,0(r20)
 200633c:	01800284 	movi	r6,10
 2006340:	a5000044 	addi	r20,r20,1
 2006344:	100b883a 	mov	r5,r2
 2006348:	39fff404 	addi	r7,r7,-48
 200634c:	8809883a 	mov	r4,r17
 2006350:	20061980 	call	2006198 <__multadd>
 2006354:	a43ff81e 	bne	r20,r16,2006338 <__alt_mem_mem_0+0xfcfe6338>
 2006358:	ace1883a 	add	r16,r21,r19
 200635c:	843ffe04 	addi	r16,r16,-8
 2006360:	9c800a0e 	bge	r19,r18,200638c <__s2b+0xd4>
 2006364:	94e5c83a 	sub	r18,r18,r19
 2006368:	84a5883a 	add	r18,r16,r18
 200636c:	81c00007 	ldb	r7,0(r16)
 2006370:	01800284 	movi	r6,10
 2006374:	84000044 	addi	r16,r16,1
 2006378:	100b883a 	mov	r5,r2
 200637c:	39fff404 	addi	r7,r7,-48
 2006380:	8809883a 	mov	r4,r17
 2006384:	20061980 	call	2006198 <__multadd>
 2006388:	84bff81e 	bne	r16,r18,200636c <__alt_mem_mem_0+0xfcfe636c>
 200638c:	dfc00617 	ldw	ra,24(sp)
 2006390:	dd400517 	ldw	r21,20(sp)
 2006394:	dd000417 	ldw	r20,16(sp)
 2006398:	dcc00317 	ldw	r19,12(sp)
 200639c:	dc800217 	ldw	r18,8(sp)
 20063a0:	dc400117 	ldw	r17,4(sp)
 20063a4:	dc000017 	ldw	r16,0(sp)
 20063a8:	dec00704 	addi	sp,sp,28
 20063ac:	f800283a 	ret
 20063b0:	84000284 	addi	r16,r16,10
 20063b4:	1827883a 	mov	r19,r3
 20063b8:	003fe906 	br	2006360 <__alt_mem_mem_0+0xfcfe6360>

020063bc <__hi0bits>:
 20063bc:	20bfffec 	andhi	r2,r4,65535
 20063c0:	1000141e 	bne	r2,zero,2006414 <__hi0bits+0x58>
 20063c4:	2008943a 	slli	r4,r4,16
 20063c8:	00800404 	movi	r2,16
 20063cc:	20ffc02c 	andhi	r3,r4,65280
 20063d0:	1800021e 	bne	r3,zero,20063dc <__hi0bits+0x20>
 20063d4:	2008923a 	slli	r4,r4,8
 20063d8:	10800204 	addi	r2,r2,8
 20063dc:	20fc002c 	andhi	r3,r4,61440
 20063e0:	1800021e 	bne	r3,zero,20063ec <__hi0bits+0x30>
 20063e4:	2008913a 	slli	r4,r4,4
 20063e8:	10800104 	addi	r2,r2,4
 20063ec:	20f0002c 	andhi	r3,r4,49152
 20063f0:	1800031e 	bne	r3,zero,2006400 <__hi0bits+0x44>
 20063f4:	2109883a 	add	r4,r4,r4
 20063f8:	10800084 	addi	r2,r2,2
 20063fc:	2109883a 	add	r4,r4,r4
 2006400:	20000316 	blt	r4,zero,2006410 <__hi0bits+0x54>
 2006404:	2110002c 	andhi	r4,r4,16384
 2006408:	2000041e 	bne	r4,zero,200641c <__hi0bits+0x60>
 200640c:	00800804 	movi	r2,32
 2006410:	f800283a 	ret
 2006414:	0005883a 	mov	r2,zero
 2006418:	003fec06 	br	20063cc <__alt_mem_mem_0+0xfcfe63cc>
 200641c:	10800044 	addi	r2,r2,1
 2006420:	f800283a 	ret

02006424 <__lo0bits>:
 2006424:	20c00017 	ldw	r3,0(r4)
 2006428:	188001cc 	andi	r2,r3,7
 200642c:	10000826 	beq	r2,zero,2006450 <__lo0bits+0x2c>
 2006430:	1880004c 	andi	r2,r3,1
 2006434:	1000211e 	bne	r2,zero,20064bc <__lo0bits+0x98>
 2006438:	1880008c 	andi	r2,r3,2
 200643c:	1000211e 	bne	r2,zero,20064c4 <__lo0bits+0xa0>
 2006440:	1806d0ba 	srli	r3,r3,2
 2006444:	00800084 	movi	r2,2
 2006448:	20c00015 	stw	r3,0(r4)
 200644c:	f800283a 	ret
 2006450:	18bfffcc 	andi	r2,r3,65535
 2006454:	10001326 	beq	r2,zero,20064a4 <__lo0bits+0x80>
 2006458:	0005883a 	mov	r2,zero
 200645c:	19403fcc 	andi	r5,r3,255
 2006460:	2800021e 	bne	r5,zero,200646c <__lo0bits+0x48>
 2006464:	1806d23a 	srli	r3,r3,8
 2006468:	10800204 	addi	r2,r2,8
 200646c:	194003cc 	andi	r5,r3,15
 2006470:	2800021e 	bne	r5,zero,200647c <__lo0bits+0x58>
 2006474:	1806d13a 	srli	r3,r3,4
 2006478:	10800104 	addi	r2,r2,4
 200647c:	194000cc 	andi	r5,r3,3
 2006480:	2800021e 	bne	r5,zero,200648c <__lo0bits+0x68>
 2006484:	1806d0ba 	srli	r3,r3,2
 2006488:	10800084 	addi	r2,r2,2
 200648c:	1940004c 	andi	r5,r3,1
 2006490:	2800081e 	bne	r5,zero,20064b4 <__lo0bits+0x90>
 2006494:	1806d07a 	srli	r3,r3,1
 2006498:	1800051e 	bne	r3,zero,20064b0 <__lo0bits+0x8c>
 200649c:	00800804 	movi	r2,32
 20064a0:	f800283a 	ret
 20064a4:	1806d43a 	srli	r3,r3,16
 20064a8:	00800404 	movi	r2,16
 20064ac:	003feb06 	br	200645c <__alt_mem_mem_0+0xfcfe645c>
 20064b0:	10800044 	addi	r2,r2,1
 20064b4:	20c00015 	stw	r3,0(r4)
 20064b8:	f800283a 	ret
 20064bc:	0005883a 	mov	r2,zero
 20064c0:	f800283a 	ret
 20064c4:	1806d07a 	srli	r3,r3,1
 20064c8:	00800044 	movi	r2,1
 20064cc:	20c00015 	stw	r3,0(r4)
 20064d0:	f800283a 	ret

020064d4 <__i2b>:
 20064d4:	defffd04 	addi	sp,sp,-12
 20064d8:	dc000015 	stw	r16,0(sp)
 20064dc:	04000044 	movi	r16,1
 20064e0:	dc400115 	stw	r17,4(sp)
 20064e4:	2823883a 	mov	r17,r5
 20064e8:	800b883a 	mov	r5,r16
 20064ec:	dfc00215 	stw	ra,8(sp)
 20064f0:	20060c80 	call	20060c8 <_Balloc>
 20064f4:	14400515 	stw	r17,20(r2)
 20064f8:	14000415 	stw	r16,16(r2)
 20064fc:	dfc00217 	ldw	ra,8(sp)
 2006500:	dc400117 	ldw	r17,4(sp)
 2006504:	dc000017 	ldw	r16,0(sp)
 2006508:	dec00304 	addi	sp,sp,12
 200650c:	f800283a 	ret

02006510 <__multiply>:
 2006510:	defffa04 	addi	sp,sp,-24
 2006514:	dcc00315 	stw	r19,12(sp)
 2006518:	dc800215 	stw	r18,8(sp)
 200651c:	34c00417 	ldw	r19,16(r6)
 2006520:	2c800417 	ldw	r18,16(r5)
 2006524:	dd000415 	stw	r20,16(sp)
 2006528:	dc400115 	stw	r17,4(sp)
 200652c:	dfc00515 	stw	ra,20(sp)
 2006530:	dc000015 	stw	r16,0(sp)
 2006534:	2829883a 	mov	r20,r5
 2006538:	3023883a 	mov	r17,r6
 200653c:	94c0050e 	bge	r18,r19,2006554 <__multiply+0x44>
 2006540:	9007883a 	mov	r3,r18
 2006544:	3029883a 	mov	r20,r6
 2006548:	9825883a 	mov	r18,r19
 200654c:	2823883a 	mov	r17,r5
 2006550:	1827883a 	mov	r19,r3
 2006554:	a0800217 	ldw	r2,8(r20)
 2006558:	94e1883a 	add	r16,r18,r19
 200655c:	a1400117 	ldw	r5,4(r20)
 2006560:	1400010e 	bge	r2,r16,2006568 <__multiply+0x58>
 2006564:	29400044 	addi	r5,r5,1
 2006568:	20060c80 	call	20060c8 <_Balloc>
 200656c:	8415883a 	add	r10,r16,r16
 2006570:	12c00504 	addi	r11,r2,20
 2006574:	5295883a 	add	r10,r10,r10
 2006578:	5a95883a 	add	r10,r11,r10
 200657c:	5807883a 	mov	r3,r11
 2006580:	5a80032e 	bgeu	r11,r10,2006590 <__multiply+0x80>
 2006584:	18000015 	stw	zero,0(r3)
 2006588:	18c00104 	addi	r3,r3,4
 200658c:	1abffd36 	bltu	r3,r10,2006584 <__alt_mem_mem_0+0xfcfe6584>
 2006590:	9ce7883a 	add	r19,r19,r19
 2006594:	94a5883a 	add	r18,r18,r18
 2006598:	89800504 	addi	r6,r17,20
 200659c:	9ce7883a 	add	r19,r19,r19
 20065a0:	a3400504 	addi	r13,r20,20
 20065a4:	94a5883a 	add	r18,r18,r18
 20065a8:	34d9883a 	add	r12,r6,r19
 20065ac:	6c93883a 	add	r9,r13,r18
 20065b0:	3300422e 	bgeu	r6,r12,20066bc <__multiply+0x1ac>
 20065b4:	37c00017 	ldw	ra,0(r6)
 20065b8:	fbffffcc 	andi	r15,ra,65535
 20065bc:	78001b26 	beq	r15,zero,200662c <__multiply+0x11c>
 20065c0:	5811883a 	mov	r8,r11
 20065c4:	681d883a 	mov	r14,r13
 20065c8:	000f883a 	mov	r7,zero
 20065cc:	71000017 	ldw	r4,0(r14)
 20065d0:	40c00017 	ldw	r3,0(r8)
 20065d4:	73800104 	addi	r14,r14,4
 20065d8:	217fffcc 	andi	r5,r4,65535
 20065dc:	2bcb383a 	mul	r5,r5,r15
 20065e0:	2008d43a 	srli	r4,r4,16
 20065e4:	1c7fffcc 	andi	r17,r3,65535
 20065e8:	2c4b883a 	add	r5,r5,r17
 20065ec:	29cb883a 	add	r5,r5,r7
 20065f0:	23c9383a 	mul	r4,r4,r15
 20065f4:	1806d43a 	srli	r3,r3,16
 20065f8:	280ed43a 	srli	r7,r5,16
 20065fc:	297fffcc 	andi	r5,r5,65535
 2006600:	20c7883a 	add	r3,r4,r3
 2006604:	19c7883a 	add	r3,r3,r7
 2006608:	1808943a 	slli	r4,r3,16
 200660c:	4023883a 	mov	r17,r8
 2006610:	180ed43a 	srli	r7,r3,16
 2006614:	214ab03a 	or	r5,r4,r5
 2006618:	41400015 	stw	r5,0(r8)
 200661c:	42000104 	addi	r8,r8,4
 2006620:	727fea36 	bltu	r14,r9,20065cc <__alt_mem_mem_0+0xfcfe65cc>
 2006624:	89c00115 	stw	r7,4(r17)
 2006628:	37c00017 	ldw	ra,0(r6)
 200662c:	f83ed43a 	srli	ra,ra,16
 2006630:	f8001f26 	beq	ra,zero,20066b0 <__multiply+0x1a0>
 2006634:	58c00017 	ldw	r3,0(r11)
 2006638:	681d883a 	mov	r14,r13
 200663c:	581f883a 	mov	r15,r11
 2006640:	1811883a 	mov	r8,r3
 2006644:	5825883a 	mov	r18,r11
 2006648:	000f883a 	mov	r7,zero
 200664c:	00000106 	br	2006654 <__multiply+0x144>
 2006650:	8825883a 	mov	r18,r17
 2006654:	7140000b 	ldhu	r5,0(r14)
 2006658:	4010d43a 	srli	r8,r8,16
 200665c:	193fffcc 	andi	r4,r3,65535
 2006660:	2fcb383a 	mul	r5,r5,ra
 2006664:	7bc00104 	addi	r15,r15,4
 2006668:	73800104 	addi	r14,r14,4
 200666c:	2a0b883a 	add	r5,r5,r8
 2006670:	29cb883a 	add	r5,r5,r7
 2006674:	2806943a 	slli	r3,r5,16
 2006678:	94400104 	addi	r17,r18,4
 200667c:	280ad43a 	srli	r5,r5,16
 2006680:	1908b03a 	or	r4,r3,r4
 2006684:	793fff15 	stw	r4,-4(r15)
 2006688:	70ffff17 	ldw	r3,-4(r14)
 200668c:	8a000017 	ldw	r8,0(r17)
 2006690:	1806d43a 	srli	r3,r3,16
 2006694:	413fffcc 	andi	r4,r8,65535
 2006698:	1fc7383a 	mul	r3,r3,ra
 200669c:	1907883a 	add	r3,r3,r4
 20066a0:	1947883a 	add	r3,r3,r5
 20066a4:	180ed43a 	srli	r7,r3,16
 20066a8:	727fe936 	bltu	r14,r9,2006650 <__alt_mem_mem_0+0xfcfe6650>
 20066ac:	90c00115 	stw	r3,4(r18)
 20066b0:	31800104 	addi	r6,r6,4
 20066b4:	5ac00104 	addi	r11,r11,4
 20066b8:	333fbe36 	bltu	r6,r12,20065b4 <__alt_mem_mem_0+0xfcfe65b4>
 20066bc:	0400090e 	bge	zero,r16,20066e4 <__multiply+0x1d4>
 20066c0:	50ffff17 	ldw	r3,-4(r10)
 20066c4:	52bfff04 	addi	r10,r10,-4
 20066c8:	18000326 	beq	r3,zero,20066d8 <__multiply+0x1c8>
 20066cc:	00000506 	br	20066e4 <__multiply+0x1d4>
 20066d0:	50c00017 	ldw	r3,0(r10)
 20066d4:	1800031e 	bne	r3,zero,20066e4 <__multiply+0x1d4>
 20066d8:	843fffc4 	addi	r16,r16,-1
 20066dc:	52bfff04 	addi	r10,r10,-4
 20066e0:	803ffb1e 	bne	r16,zero,20066d0 <__alt_mem_mem_0+0xfcfe66d0>
 20066e4:	14000415 	stw	r16,16(r2)
 20066e8:	dfc00517 	ldw	ra,20(sp)
 20066ec:	dd000417 	ldw	r20,16(sp)
 20066f0:	dcc00317 	ldw	r19,12(sp)
 20066f4:	dc800217 	ldw	r18,8(sp)
 20066f8:	dc400117 	ldw	r17,4(sp)
 20066fc:	dc000017 	ldw	r16,0(sp)
 2006700:	dec00604 	addi	sp,sp,24
 2006704:	f800283a 	ret

02006708 <__pow5mult>:
 2006708:	defffa04 	addi	sp,sp,-24
 200670c:	dcc00315 	stw	r19,12(sp)
 2006710:	dc000015 	stw	r16,0(sp)
 2006714:	dfc00515 	stw	ra,20(sp)
 2006718:	dd000415 	stw	r20,16(sp)
 200671c:	dc800215 	stw	r18,8(sp)
 2006720:	dc400115 	stw	r17,4(sp)
 2006724:	308000cc 	andi	r2,r6,3
 2006728:	3021883a 	mov	r16,r6
 200672c:	2027883a 	mov	r19,r4
 2006730:	10002f1e 	bne	r2,zero,20067f0 <__pow5mult+0xe8>
 2006734:	2825883a 	mov	r18,r5
 2006738:	8021d0ba 	srai	r16,r16,2
 200673c:	80001a26 	beq	r16,zero,20067a8 <__pow5mult+0xa0>
 2006740:	9c401217 	ldw	r17,72(r19)
 2006744:	8800061e 	bne	r17,zero,2006760 <__pow5mult+0x58>
 2006748:	00003406 	br	200681c <__pow5mult+0x114>
 200674c:	8021d07a 	srai	r16,r16,1
 2006750:	80001526 	beq	r16,zero,20067a8 <__pow5mult+0xa0>
 2006754:	88800017 	ldw	r2,0(r17)
 2006758:	10001c26 	beq	r2,zero,20067cc <__pow5mult+0xc4>
 200675c:	1023883a 	mov	r17,r2
 2006760:	8080004c 	andi	r2,r16,1
 2006764:	103ff926 	beq	r2,zero,200674c <__alt_mem_mem_0+0xfcfe674c>
 2006768:	880d883a 	mov	r6,r17
 200676c:	900b883a 	mov	r5,r18
 2006770:	9809883a 	mov	r4,r19
 2006774:	20065100 	call	2006510 <__multiply>
 2006778:	90001b26 	beq	r18,zero,20067e8 <__pow5mult+0xe0>
 200677c:	91000117 	ldw	r4,4(r18)
 2006780:	98c01317 	ldw	r3,76(r19)
 2006784:	8021d07a 	srai	r16,r16,1
 2006788:	2109883a 	add	r4,r4,r4
 200678c:	2109883a 	add	r4,r4,r4
 2006790:	1907883a 	add	r3,r3,r4
 2006794:	19000017 	ldw	r4,0(r3)
 2006798:	91000015 	stw	r4,0(r18)
 200679c:	1c800015 	stw	r18,0(r3)
 20067a0:	1025883a 	mov	r18,r2
 20067a4:	803feb1e 	bne	r16,zero,2006754 <__alt_mem_mem_0+0xfcfe6754>
 20067a8:	9005883a 	mov	r2,r18
 20067ac:	dfc00517 	ldw	ra,20(sp)
 20067b0:	dd000417 	ldw	r20,16(sp)
 20067b4:	dcc00317 	ldw	r19,12(sp)
 20067b8:	dc800217 	ldw	r18,8(sp)
 20067bc:	dc400117 	ldw	r17,4(sp)
 20067c0:	dc000017 	ldw	r16,0(sp)
 20067c4:	dec00604 	addi	sp,sp,24
 20067c8:	f800283a 	ret
 20067cc:	880d883a 	mov	r6,r17
 20067d0:	880b883a 	mov	r5,r17
 20067d4:	9809883a 	mov	r4,r19
 20067d8:	20065100 	call	2006510 <__multiply>
 20067dc:	88800015 	stw	r2,0(r17)
 20067e0:	10000015 	stw	zero,0(r2)
 20067e4:	003fdd06 	br	200675c <__alt_mem_mem_0+0xfcfe675c>
 20067e8:	1025883a 	mov	r18,r2
 20067ec:	003fd706 	br	200674c <__alt_mem_mem_0+0xfcfe674c>
 20067f0:	10bfffc4 	addi	r2,r2,-1
 20067f4:	1085883a 	add	r2,r2,r2
 20067f8:	00c08134 	movhi	r3,516
 20067fc:	18da9d04 	addi	r3,r3,27252
 2006800:	1085883a 	add	r2,r2,r2
 2006804:	1885883a 	add	r2,r3,r2
 2006808:	11800017 	ldw	r6,0(r2)
 200680c:	000f883a 	mov	r7,zero
 2006810:	20061980 	call	2006198 <__multadd>
 2006814:	1025883a 	mov	r18,r2
 2006818:	003fc706 	br	2006738 <__alt_mem_mem_0+0xfcfe6738>
 200681c:	05000044 	movi	r20,1
 2006820:	a00b883a 	mov	r5,r20
 2006824:	9809883a 	mov	r4,r19
 2006828:	20060c80 	call	20060c8 <_Balloc>
 200682c:	1023883a 	mov	r17,r2
 2006830:	00809c44 	movi	r2,625
 2006834:	88800515 	stw	r2,20(r17)
 2006838:	8d000415 	stw	r20,16(r17)
 200683c:	9c401215 	stw	r17,72(r19)
 2006840:	88000015 	stw	zero,0(r17)
 2006844:	003fc606 	br	2006760 <__alt_mem_mem_0+0xfcfe6760>

02006848 <__lshift>:
 2006848:	defff904 	addi	sp,sp,-28
 200684c:	dd400515 	stw	r21,20(sp)
 2006850:	dcc00315 	stw	r19,12(sp)
 2006854:	302bd17a 	srai	r21,r6,5
 2006858:	2cc00417 	ldw	r19,16(r5)
 200685c:	28800217 	ldw	r2,8(r5)
 2006860:	dd000415 	stw	r20,16(sp)
 2006864:	ace7883a 	add	r19,r21,r19
 2006868:	dc800215 	stw	r18,8(sp)
 200686c:	dc400115 	stw	r17,4(sp)
 2006870:	dc000015 	stw	r16,0(sp)
 2006874:	dfc00615 	stw	ra,24(sp)
 2006878:	9c000044 	addi	r16,r19,1
 200687c:	2823883a 	mov	r17,r5
 2006880:	3029883a 	mov	r20,r6
 2006884:	2025883a 	mov	r18,r4
 2006888:	29400117 	ldw	r5,4(r5)
 200688c:	1400030e 	bge	r2,r16,200689c <__lshift+0x54>
 2006890:	1085883a 	add	r2,r2,r2
 2006894:	29400044 	addi	r5,r5,1
 2006898:	143ffd16 	blt	r2,r16,2006890 <__alt_mem_mem_0+0xfcfe6890>
 200689c:	9009883a 	mov	r4,r18
 20068a0:	20060c80 	call	20060c8 <_Balloc>
 20068a4:	10c00504 	addi	r3,r2,20
 20068a8:	0540070e 	bge	zero,r21,20068c8 <__lshift+0x80>
 20068ac:	ad6b883a 	add	r21,r21,r21
 20068b0:	ad6b883a 	add	r21,r21,r21
 20068b4:	1809883a 	mov	r4,r3
 20068b8:	1d47883a 	add	r3,r3,r21
 20068bc:	20000015 	stw	zero,0(r4)
 20068c0:	21000104 	addi	r4,r4,4
 20068c4:	193ffd1e 	bne	r3,r4,20068bc <__alt_mem_mem_0+0xfcfe68bc>
 20068c8:	8a000417 	ldw	r8,16(r17)
 20068cc:	89000504 	addi	r4,r17,20
 20068d0:	a18007cc 	andi	r6,r20,31
 20068d4:	4211883a 	add	r8,r8,r8
 20068d8:	4211883a 	add	r8,r8,r8
 20068dc:	2211883a 	add	r8,r4,r8
 20068e0:	30002326 	beq	r6,zero,2006970 <__lshift+0x128>
 20068e4:	02400804 	movi	r9,32
 20068e8:	4993c83a 	sub	r9,r9,r6
 20068ec:	000b883a 	mov	r5,zero
 20068f0:	21c00017 	ldw	r7,0(r4)
 20068f4:	1815883a 	mov	r10,r3
 20068f8:	18c00104 	addi	r3,r3,4
 20068fc:	398e983a 	sll	r7,r7,r6
 2006900:	21000104 	addi	r4,r4,4
 2006904:	394ab03a 	or	r5,r7,r5
 2006908:	197fff15 	stw	r5,-4(r3)
 200690c:	217fff17 	ldw	r5,-4(r4)
 2006910:	2a4ad83a 	srl	r5,r5,r9
 2006914:	223ff636 	bltu	r4,r8,20068f0 <__alt_mem_mem_0+0xfcfe68f0>
 2006918:	51400115 	stw	r5,4(r10)
 200691c:	28001a1e 	bne	r5,zero,2006988 <__lshift+0x140>
 2006920:	843fffc4 	addi	r16,r16,-1
 2006924:	14000415 	stw	r16,16(r2)
 2006928:	88000826 	beq	r17,zero,200694c <__lshift+0x104>
 200692c:	89000117 	ldw	r4,4(r17)
 2006930:	90c01317 	ldw	r3,76(r18)
 2006934:	2109883a 	add	r4,r4,r4
 2006938:	2109883a 	add	r4,r4,r4
 200693c:	1907883a 	add	r3,r3,r4
 2006940:	19000017 	ldw	r4,0(r3)
 2006944:	89000015 	stw	r4,0(r17)
 2006948:	1c400015 	stw	r17,0(r3)
 200694c:	dfc00617 	ldw	ra,24(sp)
 2006950:	dd400517 	ldw	r21,20(sp)
 2006954:	dd000417 	ldw	r20,16(sp)
 2006958:	dcc00317 	ldw	r19,12(sp)
 200695c:	dc800217 	ldw	r18,8(sp)
 2006960:	dc400117 	ldw	r17,4(sp)
 2006964:	dc000017 	ldw	r16,0(sp)
 2006968:	dec00704 	addi	sp,sp,28
 200696c:	f800283a 	ret
 2006970:	21400017 	ldw	r5,0(r4)
 2006974:	18c00104 	addi	r3,r3,4
 2006978:	21000104 	addi	r4,r4,4
 200697c:	197fff15 	stw	r5,-4(r3)
 2006980:	223ffb36 	bltu	r4,r8,2006970 <__alt_mem_mem_0+0xfcfe6970>
 2006984:	003fe606 	br	2006920 <__alt_mem_mem_0+0xfcfe6920>
 2006988:	9c000084 	addi	r16,r19,2
 200698c:	003fe406 	br	2006920 <__alt_mem_mem_0+0xfcfe6920>

02006990 <__mcmp>:
 2006990:	20800417 	ldw	r2,16(r4)
 2006994:	28c00417 	ldw	r3,16(r5)
 2006998:	10c5c83a 	sub	r2,r2,r3
 200699c:	1000111e 	bne	r2,zero,20069e4 <__mcmp+0x54>
 20069a0:	18c7883a 	add	r3,r3,r3
 20069a4:	18c7883a 	add	r3,r3,r3
 20069a8:	21000504 	addi	r4,r4,20
 20069ac:	29400504 	addi	r5,r5,20
 20069b0:	20c5883a 	add	r2,r4,r3
 20069b4:	28cb883a 	add	r5,r5,r3
 20069b8:	00000106 	br	20069c0 <__mcmp+0x30>
 20069bc:	20800a2e 	bgeu	r4,r2,20069e8 <__mcmp+0x58>
 20069c0:	10bfff04 	addi	r2,r2,-4
 20069c4:	297fff04 	addi	r5,r5,-4
 20069c8:	11800017 	ldw	r6,0(r2)
 20069cc:	28c00017 	ldw	r3,0(r5)
 20069d0:	30fffa26 	beq	r6,r3,20069bc <__alt_mem_mem_0+0xfcfe69bc>
 20069d4:	30c00236 	bltu	r6,r3,20069e0 <__mcmp+0x50>
 20069d8:	00800044 	movi	r2,1
 20069dc:	f800283a 	ret
 20069e0:	00bfffc4 	movi	r2,-1
 20069e4:	f800283a 	ret
 20069e8:	0005883a 	mov	r2,zero
 20069ec:	f800283a 	ret

020069f0 <__mdiff>:
 20069f0:	28c00417 	ldw	r3,16(r5)
 20069f4:	30800417 	ldw	r2,16(r6)
 20069f8:	defffa04 	addi	sp,sp,-24
 20069fc:	dcc00315 	stw	r19,12(sp)
 2006a00:	dc800215 	stw	r18,8(sp)
 2006a04:	dfc00515 	stw	ra,20(sp)
 2006a08:	dd000415 	stw	r20,16(sp)
 2006a0c:	dc400115 	stw	r17,4(sp)
 2006a10:	dc000015 	stw	r16,0(sp)
 2006a14:	1887c83a 	sub	r3,r3,r2
 2006a18:	2825883a 	mov	r18,r5
 2006a1c:	3027883a 	mov	r19,r6
 2006a20:	1800141e 	bne	r3,zero,2006a74 <__mdiff+0x84>
 2006a24:	1085883a 	add	r2,r2,r2
 2006a28:	1085883a 	add	r2,r2,r2
 2006a2c:	2a000504 	addi	r8,r5,20
 2006a30:	34000504 	addi	r16,r6,20
 2006a34:	4087883a 	add	r3,r8,r2
 2006a38:	8085883a 	add	r2,r16,r2
 2006a3c:	00000106 	br	2006a44 <__mdiff+0x54>
 2006a40:	40c0592e 	bgeu	r8,r3,2006ba8 <__mdiff+0x1b8>
 2006a44:	18ffff04 	addi	r3,r3,-4
 2006a48:	10bfff04 	addi	r2,r2,-4
 2006a4c:	19c00017 	ldw	r7,0(r3)
 2006a50:	11400017 	ldw	r5,0(r2)
 2006a54:	397ffa26 	beq	r7,r5,2006a40 <__alt_mem_mem_0+0xfcfe6a40>
 2006a58:	3940592e 	bgeu	r7,r5,2006bc0 <__mdiff+0x1d0>
 2006a5c:	9005883a 	mov	r2,r18
 2006a60:	4023883a 	mov	r17,r8
 2006a64:	9825883a 	mov	r18,r19
 2006a68:	05000044 	movi	r20,1
 2006a6c:	1027883a 	mov	r19,r2
 2006a70:	00000406 	br	2006a84 <__mdiff+0x94>
 2006a74:	18005616 	blt	r3,zero,2006bd0 <__mdiff+0x1e0>
 2006a78:	34400504 	addi	r17,r6,20
 2006a7c:	2c000504 	addi	r16,r5,20
 2006a80:	0029883a 	mov	r20,zero
 2006a84:	91400117 	ldw	r5,4(r18)
 2006a88:	20060c80 	call	20060c8 <_Balloc>
 2006a8c:	92400417 	ldw	r9,16(r18)
 2006a90:	9b000417 	ldw	r12,16(r19)
 2006a94:	12c00504 	addi	r11,r2,20
 2006a98:	4a51883a 	add	r8,r9,r9
 2006a9c:	6319883a 	add	r12,r12,r12
 2006aa0:	4211883a 	add	r8,r8,r8
 2006aa4:	6319883a 	add	r12,r12,r12
 2006aa8:	15000315 	stw	r20,12(r2)
 2006aac:	8211883a 	add	r8,r16,r8
 2006ab0:	8b19883a 	add	r12,r17,r12
 2006ab4:	0007883a 	mov	r3,zero
 2006ab8:	81400017 	ldw	r5,0(r16)
 2006abc:	89c00017 	ldw	r7,0(r17)
 2006ac0:	59800104 	addi	r6,r11,4
 2006ac4:	293fffcc 	andi	r4,r5,65535
 2006ac8:	20c7883a 	add	r3,r4,r3
 2006acc:	393fffcc 	andi	r4,r7,65535
 2006ad0:	1909c83a 	sub	r4,r3,r4
 2006ad4:	280ad43a 	srli	r5,r5,16
 2006ad8:	380ed43a 	srli	r7,r7,16
 2006adc:	2007d43a 	srai	r3,r4,16
 2006ae0:	213fffcc 	andi	r4,r4,65535
 2006ae4:	29cbc83a 	sub	r5,r5,r7
 2006ae8:	28c7883a 	add	r3,r5,r3
 2006aec:	180a943a 	slli	r5,r3,16
 2006af0:	8c400104 	addi	r17,r17,4
 2006af4:	84000104 	addi	r16,r16,4
 2006af8:	2908b03a 	or	r4,r5,r4
 2006afc:	59000015 	stw	r4,0(r11)
 2006b00:	1807d43a 	srai	r3,r3,16
 2006b04:	3015883a 	mov	r10,r6
 2006b08:	3017883a 	mov	r11,r6
 2006b0c:	8b3fea36 	bltu	r17,r12,2006ab8 <__alt_mem_mem_0+0xfcfe6ab8>
 2006b10:	8200162e 	bgeu	r16,r8,2006b6c <__mdiff+0x17c>
 2006b14:	8017883a 	mov	r11,r16
 2006b18:	59400017 	ldw	r5,0(r11)
 2006b1c:	31800104 	addi	r6,r6,4
 2006b20:	5ac00104 	addi	r11,r11,4
 2006b24:	293fffcc 	andi	r4,r5,65535
 2006b28:	20c7883a 	add	r3,r4,r3
 2006b2c:	280ed43a 	srli	r7,r5,16
 2006b30:	180bd43a 	srai	r5,r3,16
 2006b34:	193fffcc 	andi	r4,r3,65535
 2006b38:	3947883a 	add	r3,r7,r5
 2006b3c:	180a943a 	slli	r5,r3,16
 2006b40:	1807d43a 	srai	r3,r3,16
 2006b44:	2908b03a 	or	r4,r5,r4
 2006b48:	313fff15 	stw	r4,-4(r6)
 2006b4c:	5a3ff236 	bltu	r11,r8,2006b18 <__alt_mem_mem_0+0xfcfe6b18>
 2006b50:	0406303a 	nor	r3,zero,r16
 2006b54:	1a07883a 	add	r3,r3,r8
 2006b58:	1806d0ba 	srli	r3,r3,2
 2006b5c:	18c00044 	addi	r3,r3,1
 2006b60:	18c7883a 	add	r3,r3,r3
 2006b64:	18c7883a 	add	r3,r3,r3
 2006b68:	50d5883a 	add	r10,r10,r3
 2006b6c:	50ffff04 	addi	r3,r10,-4
 2006b70:	2000041e 	bne	r4,zero,2006b84 <__mdiff+0x194>
 2006b74:	18ffff04 	addi	r3,r3,-4
 2006b78:	19000017 	ldw	r4,0(r3)
 2006b7c:	4a7fffc4 	addi	r9,r9,-1
 2006b80:	203ffc26 	beq	r4,zero,2006b74 <__alt_mem_mem_0+0xfcfe6b74>
 2006b84:	12400415 	stw	r9,16(r2)
 2006b88:	dfc00517 	ldw	ra,20(sp)
 2006b8c:	dd000417 	ldw	r20,16(sp)
 2006b90:	dcc00317 	ldw	r19,12(sp)
 2006b94:	dc800217 	ldw	r18,8(sp)
 2006b98:	dc400117 	ldw	r17,4(sp)
 2006b9c:	dc000017 	ldw	r16,0(sp)
 2006ba0:	dec00604 	addi	sp,sp,24
 2006ba4:	f800283a 	ret
 2006ba8:	000b883a 	mov	r5,zero
 2006bac:	20060c80 	call	20060c8 <_Balloc>
 2006bb0:	00c00044 	movi	r3,1
 2006bb4:	10c00415 	stw	r3,16(r2)
 2006bb8:	10000515 	stw	zero,20(r2)
 2006bbc:	003ff206 	br	2006b88 <__alt_mem_mem_0+0xfcfe6b88>
 2006bc0:	8023883a 	mov	r17,r16
 2006bc4:	0029883a 	mov	r20,zero
 2006bc8:	4021883a 	mov	r16,r8
 2006bcc:	003fad06 	br	2006a84 <__alt_mem_mem_0+0xfcfe6a84>
 2006bd0:	9005883a 	mov	r2,r18
 2006bd4:	94400504 	addi	r17,r18,20
 2006bd8:	9c000504 	addi	r16,r19,20
 2006bdc:	9825883a 	mov	r18,r19
 2006be0:	05000044 	movi	r20,1
 2006be4:	1027883a 	mov	r19,r2
 2006be8:	003fa606 	br	2006a84 <__alt_mem_mem_0+0xfcfe6a84>

02006bec <__ulp>:
 2006bec:	295ffc2c 	andhi	r5,r5,32752
 2006bf0:	00bf3034 	movhi	r2,64704
 2006bf4:	2887883a 	add	r3,r5,r2
 2006bf8:	00c0020e 	bge	zero,r3,2006c04 <__ulp+0x18>
 2006bfc:	0005883a 	mov	r2,zero
 2006c00:	f800283a 	ret
 2006c04:	00c7c83a 	sub	r3,zero,r3
 2006c08:	1807d53a 	srai	r3,r3,20
 2006c0c:	008004c4 	movi	r2,19
 2006c10:	10c00b0e 	bge	r2,r3,2006c40 <__ulp+0x54>
 2006c14:	18bffb04 	addi	r2,r3,-20
 2006c18:	01000784 	movi	r4,30
 2006c1c:	0007883a 	mov	r3,zero
 2006c20:	20800516 	blt	r4,r2,2006c38 <__ulp+0x4c>
 2006c24:	010007c4 	movi	r4,31
 2006c28:	2089c83a 	sub	r4,r4,r2
 2006c2c:	00800044 	movi	r2,1
 2006c30:	1104983a 	sll	r2,r2,r4
 2006c34:	f800283a 	ret
 2006c38:	00800044 	movi	r2,1
 2006c3c:	f800283a 	ret
 2006c40:	01400234 	movhi	r5,8
 2006c44:	28c7d83a 	sra	r3,r5,r3
 2006c48:	0005883a 	mov	r2,zero
 2006c4c:	f800283a 	ret

02006c50 <__b2d>:
 2006c50:	defffa04 	addi	sp,sp,-24
 2006c54:	dc000015 	stw	r16,0(sp)
 2006c58:	24000417 	ldw	r16,16(r4)
 2006c5c:	dc400115 	stw	r17,4(sp)
 2006c60:	24400504 	addi	r17,r4,20
 2006c64:	8421883a 	add	r16,r16,r16
 2006c68:	8421883a 	add	r16,r16,r16
 2006c6c:	8c21883a 	add	r16,r17,r16
 2006c70:	dc800215 	stw	r18,8(sp)
 2006c74:	84bfff17 	ldw	r18,-4(r16)
 2006c78:	dd000415 	stw	r20,16(sp)
 2006c7c:	dcc00315 	stw	r19,12(sp)
 2006c80:	9009883a 	mov	r4,r18
 2006c84:	2829883a 	mov	r20,r5
 2006c88:	dfc00515 	stw	ra,20(sp)
 2006c8c:	20063bc0 	call	20063bc <__hi0bits>
 2006c90:	00c00804 	movi	r3,32
 2006c94:	1889c83a 	sub	r4,r3,r2
 2006c98:	a1000015 	stw	r4,0(r20)
 2006c9c:	01000284 	movi	r4,10
 2006ca0:	84ffff04 	addi	r19,r16,-4
 2006ca4:	20801216 	blt	r4,r2,2006cf0 <__b2d+0xa0>
 2006ca8:	018002c4 	movi	r6,11
 2006cac:	308dc83a 	sub	r6,r6,r2
 2006cb0:	9186d83a 	srl	r3,r18,r6
 2006cb4:	18cffc34 	orhi	r3,r3,16368
 2006cb8:	8cc0212e 	bgeu	r17,r19,2006d40 <__b2d+0xf0>
 2006cbc:	813ffe17 	ldw	r4,-8(r16)
 2006cc0:	218cd83a 	srl	r6,r4,r6
 2006cc4:	10800544 	addi	r2,r2,21
 2006cc8:	9084983a 	sll	r2,r18,r2
 2006ccc:	1184b03a 	or	r2,r2,r6
 2006cd0:	dfc00517 	ldw	ra,20(sp)
 2006cd4:	dd000417 	ldw	r20,16(sp)
 2006cd8:	dcc00317 	ldw	r19,12(sp)
 2006cdc:	dc800217 	ldw	r18,8(sp)
 2006ce0:	dc400117 	ldw	r17,4(sp)
 2006ce4:	dc000017 	ldw	r16,0(sp)
 2006ce8:	dec00604 	addi	sp,sp,24
 2006cec:	f800283a 	ret
 2006cf0:	8cc00f2e 	bgeu	r17,r19,2006d30 <__b2d+0xe0>
 2006cf4:	117ffd44 	addi	r5,r2,-11
 2006cf8:	80bffe17 	ldw	r2,-8(r16)
 2006cfc:	28000e26 	beq	r5,zero,2006d38 <__b2d+0xe8>
 2006d00:	1949c83a 	sub	r4,r3,r5
 2006d04:	9164983a 	sll	r18,r18,r5
 2006d08:	1106d83a 	srl	r3,r2,r4
 2006d0c:	81bffe04 	addi	r6,r16,-8
 2006d10:	948ffc34 	orhi	r18,r18,16368
 2006d14:	90c6b03a 	or	r3,r18,r3
 2006d18:	89800e2e 	bgeu	r17,r6,2006d54 <__b2d+0x104>
 2006d1c:	81bffd17 	ldw	r6,-12(r16)
 2006d20:	1144983a 	sll	r2,r2,r5
 2006d24:	310ad83a 	srl	r5,r6,r4
 2006d28:	2884b03a 	or	r2,r5,r2
 2006d2c:	003fe806 	br	2006cd0 <__alt_mem_mem_0+0xfcfe6cd0>
 2006d30:	10bffd44 	addi	r2,r2,-11
 2006d34:	1000041e 	bne	r2,zero,2006d48 <__b2d+0xf8>
 2006d38:	90cffc34 	orhi	r3,r18,16368
 2006d3c:	003fe406 	br	2006cd0 <__alt_mem_mem_0+0xfcfe6cd0>
 2006d40:	000d883a 	mov	r6,zero
 2006d44:	003fdf06 	br	2006cc4 <__alt_mem_mem_0+0xfcfe6cc4>
 2006d48:	90a4983a 	sll	r18,r18,r2
 2006d4c:	0005883a 	mov	r2,zero
 2006d50:	003ff906 	br	2006d38 <__alt_mem_mem_0+0xfcfe6d38>
 2006d54:	1144983a 	sll	r2,r2,r5
 2006d58:	003fdd06 	br	2006cd0 <__alt_mem_mem_0+0xfcfe6cd0>

02006d5c <__d2b>:
 2006d5c:	defff804 	addi	sp,sp,-32
 2006d60:	dc000215 	stw	r16,8(sp)
 2006d64:	3021883a 	mov	r16,r6
 2006d68:	dc400315 	stw	r17,12(sp)
 2006d6c:	8022907a 	slli	r17,r16,1
 2006d70:	dd000615 	stw	r20,24(sp)
 2006d74:	2829883a 	mov	r20,r5
 2006d78:	01400044 	movi	r5,1
 2006d7c:	dcc00515 	stw	r19,20(sp)
 2006d80:	dc800415 	stw	r18,16(sp)
 2006d84:	dfc00715 	stw	ra,28(sp)
 2006d88:	3825883a 	mov	r18,r7
 2006d8c:	8822d57a 	srli	r17,r17,21
 2006d90:	20060c80 	call	20060c8 <_Balloc>
 2006d94:	1027883a 	mov	r19,r2
 2006d98:	00800434 	movhi	r2,16
 2006d9c:	10bfffc4 	addi	r2,r2,-1
 2006da0:	808c703a 	and	r6,r16,r2
 2006da4:	88000126 	beq	r17,zero,2006dac <__d2b+0x50>
 2006da8:	31800434 	orhi	r6,r6,16
 2006dac:	d9800015 	stw	r6,0(sp)
 2006db0:	a0002426 	beq	r20,zero,2006e44 <__d2b+0xe8>
 2006db4:	d9000104 	addi	r4,sp,4
 2006db8:	dd000115 	stw	r20,4(sp)
 2006dbc:	20064240 	call	2006424 <__lo0bits>
 2006dc0:	d8c00017 	ldw	r3,0(sp)
 2006dc4:	10002f1e 	bne	r2,zero,2006e84 <__d2b+0x128>
 2006dc8:	d9000117 	ldw	r4,4(sp)
 2006dcc:	99000515 	stw	r4,20(r19)
 2006dd0:	1821003a 	cmpeq	r16,r3,zero
 2006dd4:	01000084 	movi	r4,2
 2006dd8:	2421c83a 	sub	r16,r4,r16
 2006ddc:	98c00615 	stw	r3,24(r19)
 2006de0:	9c000415 	stw	r16,16(r19)
 2006de4:	88001f1e 	bne	r17,zero,2006e64 <__d2b+0x108>
 2006de8:	10bef384 	addi	r2,r2,-1074
 2006dec:	90800015 	stw	r2,0(r18)
 2006df0:	00900034 	movhi	r2,16384
 2006df4:	10bfffc4 	addi	r2,r2,-1
 2006df8:	8085883a 	add	r2,r16,r2
 2006dfc:	1085883a 	add	r2,r2,r2
 2006e00:	1085883a 	add	r2,r2,r2
 2006e04:	9885883a 	add	r2,r19,r2
 2006e08:	11000517 	ldw	r4,20(r2)
 2006e0c:	8020917a 	slli	r16,r16,5
 2006e10:	20063bc0 	call	20063bc <__hi0bits>
 2006e14:	d8c00817 	ldw	r3,32(sp)
 2006e18:	8085c83a 	sub	r2,r16,r2
 2006e1c:	18800015 	stw	r2,0(r3)
 2006e20:	9805883a 	mov	r2,r19
 2006e24:	dfc00717 	ldw	ra,28(sp)
 2006e28:	dd000617 	ldw	r20,24(sp)
 2006e2c:	dcc00517 	ldw	r19,20(sp)
 2006e30:	dc800417 	ldw	r18,16(sp)
 2006e34:	dc400317 	ldw	r17,12(sp)
 2006e38:	dc000217 	ldw	r16,8(sp)
 2006e3c:	dec00804 	addi	sp,sp,32
 2006e40:	f800283a 	ret
 2006e44:	d809883a 	mov	r4,sp
 2006e48:	20064240 	call	2006424 <__lo0bits>
 2006e4c:	d8c00017 	ldw	r3,0(sp)
 2006e50:	04000044 	movi	r16,1
 2006e54:	9c000415 	stw	r16,16(r19)
 2006e58:	98c00515 	stw	r3,20(r19)
 2006e5c:	10800804 	addi	r2,r2,32
 2006e60:	883fe126 	beq	r17,zero,2006de8 <__alt_mem_mem_0+0xfcfe6de8>
 2006e64:	00c00d44 	movi	r3,53
 2006e68:	8c7ef344 	addi	r17,r17,-1075
 2006e6c:	88a3883a 	add	r17,r17,r2
 2006e70:	1885c83a 	sub	r2,r3,r2
 2006e74:	d8c00817 	ldw	r3,32(sp)
 2006e78:	94400015 	stw	r17,0(r18)
 2006e7c:	18800015 	stw	r2,0(r3)
 2006e80:	003fe706 	br	2006e20 <__alt_mem_mem_0+0xfcfe6e20>
 2006e84:	01000804 	movi	r4,32
 2006e88:	2089c83a 	sub	r4,r4,r2
 2006e8c:	1908983a 	sll	r4,r3,r4
 2006e90:	d9400117 	ldw	r5,4(sp)
 2006e94:	1886d83a 	srl	r3,r3,r2
 2006e98:	2148b03a 	or	r4,r4,r5
 2006e9c:	99000515 	stw	r4,20(r19)
 2006ea0:	d8c00015 	stw	r3,0(sp)
 2006ea4:	003fca06 	br	2006dd0 <__alt_mem_mem_0+0xfcfe6dd0>

02006ea8 <__ratio>:
 2006ea8:	defff904 	addi	sp,sp,-28
 2006eac:	dc400315 	stw	r17,12(sp)
 2006eb0:	2823883a 	mov	r17,r5
 2006eb4:	d9400104 	addi	r5,sp,4
 2006eb8:	dfc00615 	stw	ra,24(sp)
 2006ebc:	dcc00515 	stw	r19,20(sp)
 2006ec0:	dc800415 	stw	r18,16(sp)
 2006ec4:	2027883a 	mov	r19,r4
 2006ec8:	dc000215 	stw	r16,8(sp)
 2006ecc:	2006c500 	call	2006c50 <__b2d>
 2006ed0:	d80b883a 	mov	r5,sp
 2006ed4:	8809883a 	mov	r4,r17
 2006ed8:	1025883a 	mov	r18,r2
 2006edc:	1821883a 	mov	r16,r3
 2006ee0:	2006c500 	call	2006c50 <__b2d>
 2006ee4:	8a000417 	ldw	r8,16(r17)
 2006ee8:	99000417 	ldw	r4,16(r19)
 2006eec:	d9400117 	ldw	r5,4(sp)
 2006ef0:	2209c83a 	sub	r4,r4,r8
 2006ef4:	2010917a 	slli	r8,r4,5
 2006ef8:	d9000017 	ldw	r4,0(sp)
 2006efc:	2909c83a 	sub	r4,r5,r4
 2006f00:	4109883a 	add	r4,r8,r4
 2006f04:	01000e0e 	bge	zero,r4,2006f40 <__ratio+0x98>
 2006f08:	2008953a 	slli	r4,r4,20
 2006f0c:	2421883a 	add	r16,r4,r16
 2006f10:	100d883a 	mov	r6,r2
 2006f14:	180f883a 	mov	r7,r3
 2006f18:	9009883a 	mov	r4,r18
 2006f1c:	800b883a 	mov	r5,r16
 2006f20:	200b4440 	call	200b444 <__divdf3>
 2006f24:	dfc00617 	ldw	ra,24(sp)
 2006f28:	dcc00517 	ldw	r19,20(sp)
 2006f2c:	dc800417 	ldw	r18,16(sp)
 2006f30:	dc400317 	ldw	r17,12(sp)
 2006f34:	dc000217 	ldw	r16,8(sp)
 2006f38:	dec00704 	addi	sp,sp,28
 2006f3c:	f800283a 	ret
 2006f40:	2008953a 	slli	r4,r4,20
 2006f44:	1907c83a 	sub	r3,r3,r4
 2006f48:	003ff106 	br	2006f10 <__alt_mem_mem_0+0xfcfe6f10>

02006f4c <_mprec_log10>:
 2006f4c:	defffe04 	addi	sp,sp,-8
 2006f50:	dc000015 	stw	r16,0(sp)
 2006f54:	dfc00115 	stw	ra,4(sp)
 2006f58:	008005c4 	movi	r2,23
 2006f5c:	2021883a 	mov	r16,r4
 2006f60:	11000d0e 	bge	r2,r4,2006f98 <_mprec_log10+0x4c>
 2006f64:	0005883a 	mov	r2,zero
 2006f68:	00cffc34 	movhi	r3,16368
 2006f6c:	843fffc4 	addi	r16,r16,-1
 2006f70:	000d883a 	mov	r6,zero
 2006f74:	01d00934 	movhi	r7,16420
 2006f78:	1009883a 	mov	r4,r2
 2006f7c:	180b883a 	mov	r5,r3
 2006f80:	200bf840 	call	200bf84 <__muldf3>
 2006f84:	803ff91e 	bne	r16,zero,2006f6c <__alt_mem_mem_0+0xfcfe6f6c>
 2006f88:	dfc00117 	ldw	ra,4(sp)
 2006f8c:	dc000017 	ldw	r16,0(sp)
 2006f90:	dec00204 	addi	sp,sp,8
 2006f94:	f800283a 	ret
 2006f98:	202090fa 	slli	r16,r4,3
 2006f9c:	00808134 	movhi	r2,516
 2006fa0:	109ab404 	addi	r2,r2,27344
 2006fa4:	1421883a 	add	r16,r2,r16
 2006fa8:	80800017 	ldw	r2,0(r16)
 2006fac:	80c00117 	ldw	r3,4(r16)
 2006fb0:	dfc00117 	ldw	ra,4(sp)
 2006fb4:	dc000017 	ldw	r16,0(sp)
 2006fb8:	dec00204 	addi	sp,sp,8
 2006fbc:	f800283a 	ret

02006fc0 <__copybits>:
 2006fc0:	297fffc4 	addi	r5,r5,-1
 2006fc4:	280fd17a 	srai	r7,r5,5
 2006fc8:	30c00417 	ldw	r3,16(r6)
 2006fcc:	30800504 	addi	r2,r6,20
 2006fd0:	39c00044 	addi	r7,r7,1
 2006fd4:	18c7883a 	add	r3,r3,r3
 2006fd8:	39cf883a 	add	r7,r7,r7
 2006fdc:	18c7883a 	add	r3,r3,r3
 2006fe0:	39cf883a 	add	r7,r7,r7
 2006fe4:	10c7883a 	add	r3,r2,r3
 2006fe8:	21cf883a 	add	r7,r4,r7
 2006fec:	10c00d2e 	bgeu	r2,r3,2007024 <__copybits+0x64>
 2006ff0:	200b883a 	mov	r5,r4
 2006ff4:	12000017 	ldw	r8,0(r2)
 2006ff8:	29400104 	addi	r5,r5,4
 2006ffc:	10800104 	addi	r2,r2,4
 2007000:	2a3fff15 	stw	r8,-4(r5)
 2007004:	10fffb36 	bltu	r2,r3,2006ff4 <__alt_mem_mem_0+0xfcfe6ff4>
 2007008:	1985c83a 	sub	r2,r3,r6
 200700c:	10bffac4 	addi	r2,r2,-21
 2007010:	1004d0ba 	srli	r2,r2,2
 2007014:	10800044 	addi	r2,r2,1
 2007018:	1085883a 	add	r2,r2,r2
 200701c:	1085883a 	add	r2,r2,r2
 2007020:	2089883a 	add	r4,r4,r2
 2007024:	21c0032e 	bgeu	r4,r7,2007034 <__copybits+0x74>
 2007028:	20000015 	stw	zero,0(r4)
 200702c:	21000104 	addi	r4,r4,4
 2007030:	21fffd36 	bltu	r4,r7,2007028 <__alt_mem_mem_0+0xfcfe7028>
 2007034:	f800283a 	ret

02007038 <__any_on>:
 2007038:	20c00417 	ldw	r3,16(r4)
 200703c:	2805d17a 	srai	r2,r5,5
 2007040:	21000504 	addi	r4,r4,20
 2007044:	18800d0e 	bge	r3,r2,200707c <__any_on+0x44>
 2007048:	18c7883a 	add	r3,r3,r3
 200704c:	18c7883a 	add	r3,r3,r3
 2007050:	20c7883a 	add	r3,r4,r3
 2007054:	20c0192e 	bgeu	r4,r3,20070bc <__any_on+0x84>
 2007058:	18bfff17 	ldw	r2,-4(r3)
 200705c:	18ffff04 	addi	r3,r3,-4
 2007060:	1000041e 	bne	r2,zero,2007074 <__any_on+0x3c>
 2007064:	20c0142e 	bgeu	r4,r3,20070b8 <__any_on+0x80>
 2007068:	18ffff04 	addi	r3,r3,-4
 200706c:	19400017 	ldw	r5,0(r3)
 2007070:	283ffc26 	beq	r5,zero,2007064 <__alt_mem_mem_0+0xfcfe7064>
 2007074:	00800044 	movi	r2,1
 2007078:	f800283a 	ret
 200707c:	10c00a0e 	bge	r2,r3,20070a8 <__any_on+0x70>
 2007080:	1085883a 	add	r2,r2,r2
 2007084:	1085883a 	add	r2,r2,r2
 2007088:	294007cc 	andi	r5,r5,31
 200708c:	2087883a 	add	r3,r4,r2
 2007090:	283ff026 	beq	r5,zero,2007054 <__alt_mem_mem_0+0xfcfe7054>
 2007094:	19800017 	ldw	r6,0(r3)
 2007098:	3144d83a 	srl	r2,r6,r5
 200709c:	114a983a 	sll	r5,r2,r5
 20070a0:	317ff41e 	bne	r6,r5,2007074 <__alt_mem_mem_0+0xfcfe7074>
 20070a4:	003feb06 	br	2007054 <__alt_mem_mem_0+0xfcfe7054>
 20070a8:	1085883a 	add	r2,r2,r2
 20070ac:	1085883a 	add	r2,r2,r2
 20070b0:	2087883a 	add	r3,r4,r2
 20070b4:	003fe706 	br	2007054 <__alt_mem_mem_0+0xfcfe7054>
 20070b8:	f800283a 	ret
 20070bc:	0005883a 	mov	r2,zero
 20070c0:	f800283a 	ret

020070c4 <__fpclassifyd>:
 20070c4:	00a00034 	movhi	r2,32768
 20070c8:	10bfffc4 	addi	r2,r2,-1
 20070cc:	2884703a 	and	r2,r5,r2
 20070d0:	10000726 	beq	r2,zero,20070f0 <__fpclassifyd+0x2c>
 20070d4:	00fffc34 	movhi	r3,65520
 20070d8:	019ff834 	movhi	r6,32736
 20070dc:	28c7883a 	add	r3,r5,r3
 20070e0:	31bfffc4 	addi	r6,r6,-1
 20070e4:	30c00536 	bltu	r6,r3,20070fc <__fpclassifyd+0x38>
 20070e8:	00800104 	movi	r2,4
 20070ec:	f800283a 	ret
 20070f0:	2000021e 	bne	r4,zero,20070fc <__fpclassifyd+0x38>
 20070f4:	00800084 	movi	r2,2
 20070f8:	f800283a 	ret
 20070fc:	00dffc34 	movhi	r3,32752
 2007100:	019ff834 	movhi	r6,32736
 2007104:	28cb883a 	add	r5,r5,r3
 2007108:	31bfffc4 	addi	r6,r6,-1
 200710c:	317ff62e 	bgeu	r6,r5,20070e8 <__alt_mem_mem_0+0xfcfe70e8>
 2007110:	01400434 	movhi	r5,16
 2007114:	297fffc4 	addi	r5,r5,-1
 2007118:	28800236 	bltu	r5,r2,2007124 <__fpclassifyd+0x60>
 200711c:	008000c4 	movi	r2,3
 2007120:	f800283a 	ret
 2007124:	10c00226 	beq	r2,r3,2007130 <__fpclassifyd+0x6c>
 2007128:	0005883a 	mov	r2,zero
 200712c:	f800283a 	ret
 2007130:	2005003a 	cmpeq	r2,r4,zero
 2007134:	f800283a 	ret

02007138 <_sbrk_r>:
 2007138:	defffd04 	addi	sp,sp,-12
 200713c:	dc000015 	stw	r16,0(sp)
 2007140:	04008174 	movhi	r16,517
 2007144:	dc400115 	stw	r17,4(sp)
 2007148:	8432e304 	addi	r16,r16,-13428
 200714c:	2023883a 	mov	r17,r4
 2007150:	2809883a 	mov	r4,r5
 2007154:	dfc00215 	stw	ra,8(sp)
 2007158:	80000015 	stw	zero,0(r16)
 200715c:	2012f8c0 	call	2012f8c <sbrk>
 2007160:	00ffffc4 	movi	r3,-1
 2007164:	10c00526 	beq	r2,r3,200717c <_sbrk_r+0x44>
 2007168:	dfc00217 	ldw	ra,8(sp)
 200716c:	dc400117 	ldw	r17,4(sp)
 2007170:	dc000017 	ldw	r16,0(sp)
 2007174:	dec00304 	addi	sp,sp,12
 2007178:	f800283a 	ret
 200717c:	80c00017 	ldw	r3,0(r16)
 2007180:	183ff926 	beq	r3,zero,2007168 <__alt_mem_mem_0+0xfcfe7168>
 2007184:	88c00015 	stw	r3,0(r17)
 2007188:	003ff706 	br	2007168 <__alt_mem_mem_0+0xfcfe7168>

0200718c <__sread>:
 200718c:	defffe04 	addi	sp,sp,-8
 2007190:	dc000015 	stw	r16,0(sp)
 2007194:	2821883a 	mov	r16,r5
 2007198:	2940038f 	ldh	r5,14(r5)
 200719c:	dfc00115 	stw	ra,4(sp)
 20071a0:	20096300 	call	2009630 <_read_r>
 20071a4:	10000716 	blt	r2,zero,20071c4 <__sread+0x38>
 20071a8:	80c01417 	ldw	r3,80(r16)
 20071ac:	1887883a 	add	r3,r3,r2
 20071b0:	80c01415 	stw	r3,80(r16)
 20071b4:	dfc00117 	ldw	ra,4(sp)
 20071b8:	dc000017 	ldw	r16,0(sp)
 20071bc:	dec00204 	addi	sp,sp,8
 20071c0:	f800283a 	ret
 20071c4:	80c0030b 	ldhu	r3,12(r16)
 20071c8:	18fbffcc 	andi	r3,r3,61439
 20071cc:	80c0030d 	sth	r3,12(r16)
 20071d0:	dfc00117 	ldw	ra,4(sp)
 20071d4:	dc000017 	ldw	r16,0(sp)
 20071d8:	dec00204 	addi	sp,sp,8
 20071dc:	f800283a 	ret

020071e0 <__seofread>:
 20071e0:	0005883a 	mov	r2,zero
 20071e4:	f800283a 	ret

020071e8 <__swrite>:
 20071e8:	2880030b 	ldhu	r2,12(r5)
 20071ec:	defffb04 	addi	sp,sp,-20
 20071f0:	dcc00315 	stw	r19,12(sp)
 20071f4:	dc800215 	stw	r18,8(sp)
 20071f8:	dc400115 	stw	r17,4(sp)
 20071fc:	dc000015 	stw	r16,0(sp)
 2007200:	dfc00415 	stw	ra,16(sp)
 2007204:	10c0400c 	andi	r3,r2,256
 2007208:	2821883a 	mov	r16,r5
 200720c:	2023883a 	mov	r17,r4
 2007210:	3025883a 	mov	r18,r6
 2007214:	3827883a 	mov	r19,r7
 2007218:	18000526 	beq	r3,zero,2007230 <__swrite+0x48>
 200721c:	2940038f 	ldh	r5,14(r5)
 2007220:	01c00084 	movi	r7,2
 2007224:	000d883a 	mov	r6,zero
 2007228:	20094740 	call	2009474 <_lseek_r>
 200722c:	8080030b 	ldhu	r2,12(r16)
 2007230:	8140038f 	ldh	r5,14(r16)
 2007234:	10bbffcc 	andi	r2,r2,61439
 2007238:	980f883a 	mov	r7,r19
 200723c:	900d883a 	mov	r6,r18
 2007240:	8809883a 	mov	r4,r17
 2007244:	8080030d 	sth	r2,12(r16)
 2007248:	dfc00417 	ldw	ra,16(sp)
 200724c:	dcc00317 	ldw	r19,12(sp)
 2007250:	dc800217 	ldw	r18,8(sp)
 2007254:	dc400117 	ldw	r17,4(sp)
 2007258:	dc000017 	ldw	r16,0(sp)
 200725c:	dec00504 	addi	sp,sp,20
 2007260:	2008a841 	jmpi	2008a84 <_write_r>

02007264 <__sseek>:
 2007264:	defffe04 	addi	sp,sp,-8
 2007268:	dc000015 	stw	r16,0(sp)
 200726c:	2821883a 	mov	r16,r5
 2007270:	2940038f 	ldh	r5,14(r5)
 2007274:	dfc00115 	stw	ra,4(sp)
 2007278:	20094740 	call	2009474 <_lseek_r>
 200727c:	00ffffc4 	movi	r3,-1
 2007280:	10c00826 	beq	r2,r3,20072a4 <__sseek+0x40>
 2007284:	80c0030b 	ldhu	r3,12(r16)
 2007288:	80801415 	stw	r2,80(r16)
 200728c:	18c40014 	ori	r3,r3,4096
 2007290:	80c0030d 	sth	r3,12(r16)
 2007294:	dfc00117 	ldw	ra,4(sp)
 2007298:	dc000017 	ldw	r16,0(sp)
 200729c:	dec00204 	addi	sp,sp,8
 20072a0:	f800283a 	ret
 20072a4:	80c0030b 	ldhu	r3,12(r16)
 20072a8:	18fbffcc 	andi	r3,r3,61439
 20072ac:	80c0030d 	sth	r3,12(r16)
 20072b0:	dfc00117 	ldw	ra,4(sp)
 20072b4:	dc000017 	ldw	r16,0(sp)
 20072b8:	dec00204 	addi	sp,sp,8
 20072bc:	f800283a 	ret

020072c0 <__sclose>:
 20072c0:	2940038f 	ldh	r5,14(r5)
 20072c4:	2008ae41 	jmpi	2008ae4 <_close_r>

020072c8 <strcmp>:
 20072c8:	2144b03a 	or	r2,r4,r5
 20072cc:	108000cc 	andi	r2,r2,3
 20072d0:	1000171e 	bne	r2,zero,2007330 <strcmp+0x68>
 20072d4:	20800017 	ldw	r2,0(r4)
 20072d8:	28c00017 	ldw	r3,0(r5)
 20072dc:	10c0141e 	bne	r2,r3,2007330 <strcmp+0x68>
 20072e0:	027fbff4 	movhi	r9,65279
 20072e4:	4a7fbfc4 	addi	r9,r9,-257
 20072e8:	0086303a 	nor	r3,zero,r2
 20072ec:	02202074 	movhi	r8,32897
 20072f0:	1245883a 	add	r2,r2,r9
 20072f4:	42202004 	addi	r8,r8,-32640
 20072f8:	10c4703a 	and	r2,r2,r3
 20072fc:	1204703a 	and	r2,r2,r8
 2007300:	10000226 	beq	r2,zero,200730c <strcmp+0x44>
 2007304:	00002306 	br	2007394 <strcmp+0xcc>
 2007308:	1000221e 	bne	r2,zero,2007394 <strcmp+0xcc>
 200730c:	21000104 	addi	r4,r4,4
 2007310:	20c00017 	ldw	r3,0(r4)
 2007314:	29400104 	addi	r5,r5,4
 2007318:	29800017 	ldw	r6,0(r5)
 200731c:	1a4f883a 	add	r7,r3,r9
 2007320:	00c4303a 	nor	r2,zero,r3
 2007324:	3884703a 	and	r2,r7,r2
 2007328:	1204703a 	and	r2,r2,r8
 200732c:	19bff626 	beq	r3,r6,2007308 <__alt_mem_mem_0+0xfcfe7308>
 2007330:	20800003 	ldbu	r2,0(r4)
 2007334:	10c03fcc 	andi	r3,r2,255
 2007338:	18c0201c 	xori	r3,r3,128
 200733c:	18ffe004 	addi	r3,r3,-128
 2007340:	18000c26 	beq	r3,zero,2007374 <strcmp+0xac>
 2007344:	29800007 	ldb	r6,0(r5)
 2007348:	19800326 	beq	r3,r6,2007358 <strcmp+0x90>
 200734c:	00001306 	br	200739c <strcmp+0xd4>
 2007350:	29800007 	ldb	r6,0(r5)
 2007354:	11800b1e 	bne	r2,r6,2007384 <strcmp+0xbc>
 2007358:	21000044 	addi	r4,r4,1
 200735c:	20c00003 	ldbu	r3,0(r4)
 2007360:	29400044 	addi	r5,r5,1
 2007364:	18803fcc 	andi	r2,r3,255
 2007368:	1080201c 	xori	r2,r2,128
 200736c:	10bfe004 	addi	r2,r2,-128
 2007370:	103ff71e 	bne	r2,zero,2007350 <__alt_mem_mem_0+0xfcfe7350>
 2007374:	0007883a 	mov	r3,zero
 2007378:	28800003 	ldbu	r2,0(r5)
 200737c:	1885c83a 	sub	r2,r3,r2
 2007380:	f800283a 	ret
 2007384:	28800003 	ldbu	r2,0(r5)
 2007388:	18c03fcc 	andi	r3,r3,255
 200738c:	1885c83a 	sub	r2,r3,r2
 2007390:	f800283a 	ret
 2007394:	0005883a 	mov	r2,zero
 2007398:	f800283a 	ret
 200739c:	10c03fcc 	andi	r3,r2,255
 20073a0:	003ff506 	br	2007378 <__alt_mem_mem_0+0xfcfe7378>

020073a4 <strlen>:
 20073a4:	208000cc 	andi	r2,r4,3
 20073a8:	10002026 	beq	r2,zero,200742c <strlen+0x88>
 20073ac:	20800007 	ldb	r2,0(r4)
 20073b0:	10002026 	beq	r2,zero,2007434 <strlen+0x90>
 20073b4:	2005883a 	mov	r2,r4
 20073b8:	00000206 	br	20073c4 <strlen+0x20>
 20073bc:	10c00007 	ldb	r3,0(r2)
 20073c0:	18001826 	beq	r3,zero,2007424 <strlen+0x80>
 20073c4:	10800044 	addi	r2,r2,1
 20073c8:	10c000cc 	andi	r3,r2,3
 20073cc:	183ffb1e 	bne	r3,zero,20073bc <__alt_mem_mem_0+0xfcfe73bc>
 20073d0:	10c00017 	ldw	r3,0(r2)
 20073d4:	01ffbff4 	movhi	r7,65279
 20073d8:	39ffbfc4 	addi	r7,r7,-257
 20073dc:	00ca303a 	nor	r5,zero,r3
 20073e0:	01a02074 	movhi	r6,32897
 20073e4:	19c7883a 	add	r3,r3,r7
 20073e8:	31a02004 	addi	r6,r6,-32640
 20073ec:	1946703a 	and	r3,r3,r5
 20073f0:	1986703a 	and	r3,r3,r6
 20073f4:	1800091e 	bne	r3,zero,200741c <strlen+0x78>
 20073f8:	10800104 	addi	r2,r2,4
 20073fc:	10c00017 	ldw	r3,0(r2)
 2007400:	19cb883a 	add	r5,r3,r7
 2007404:	00c6303a 	nor	r3,zero,r3
 2007408:	28c6703a 	and	r3,r5,r3
 200740c:	1986703a 	and	r3,r3,r6
 2007410:	183ff926 	beq	r3,zero,20073f8 <__alt_mem_mem_0+0xfcfe73f8>
 2007414:	00000106 	br	200741c <strlen+0x78>
 2007418:	10800044 	addi	r2,r2,1
 200741c:	10c00007 	ldb	r3,0(r2)
 2007420:	183ffd1e 	bne	r3,zero,2007418 <__alt_mem_mem_0+0xfcfe7418>
 2007424:	1105c83a 	sub	r2,r2,r4
 2007428:	f800283a 	ret
 200742c:	2005883a 	mov	r2,r4
 2007430:	003fe706 	br	20073d0 <__alt_mem_mem_0+0xfcfe73d0>
 2007434:	0005883a 	mov	r2,zero
 2007438:	f800283a 	ret

0200743c <__sprint_r.part.0>:
 200743c:	28801917 	ldw	r2,100(r5)
 2007440:	defff604 	addi	sp,sp,-40
 2007444:	dd400515 	stw	r21,20(sp)
 2007448:	dfc00915 	stw	ra,36(sp)
 200744c:	df000815 	stw	fp,32(sp)
 2007450:	ddc00715 	stw	r23,28(sp)
 2007454:	dd800615 	stw	r22,24(sp)
 2007458:	dd000415 	stw	r20,16(sp)
 200745c:	dcc00315 	stw	r19,12(sp)
 2007460:	dc800215 	stw	r18,8(sp)
 2007464:	dc400115 	stw	r17,4(sp)
 2007468:	dc000015 	stw	r16,0(sp)
 200746c:	1088000c 	andi	r2,r2,8192
 2007470:	302b883a 	mov	r21,r6
 2007474:	10002e26 	beq	r2,zero,2007530 <__sprint_r.part.0+0xf4>
 2007478:	30800217 	ldw	r2,8(r6)
 200747c:	35800017 	ldw	r22,0(r6)
 2007480:	10002926 	beq	r2,zero,2007528 <__sprint_r.part.0+0xec>
 2007484:	2827883a 	mov	r19,r5
 2007488:	2029883a 	mov	r20,r4
 200748c:	b5c00104 	addi	r23,r22,4
 2007490:	04bfffc4 	movi	r18,-1
 2007494:	bc400017 	ldw	r17,0(r23)
 2007498:	b4000017 	ldw	r16,0(r22)
 200749c:	0039883a 	mov	fp,zero
 20074a0:	8822d0ba 	srli	r17,r17,2
 20074a4:	8800031e 	bne	r17,zero,20074b4 <__sprint_r.part.0+0x78>
 20074a8:	00001806 	br	200750c <__sprint_r.part.0+0xd0>
 20074ac:	84000104 	addi	r16,r16,4
 20074b0:	8f001526 	beq	r17,fp,2007508 <__sprint_r.part.0+0xcc>
 20074b4:	81400017 	ldw	r5,0(r16)
 20074b8:	980d883a 	mov	r6,r19
 20074bc:	a009883a 	mov	r4,r20
 20074c0:	2008e640 	call	2008e64 <_fputwc_r>
 20074c4:	e7000044 	addi	fp,fp,1
 20074c8:	14bff81e 	bne	r2,r18,20074ac <__alt_mem_mem_0+0xfcfe74ac>
 20074cc:	9005883a 	mov	r2,r18
 20074d0:	a8000215 	stw	zero,8(r21)
 20074d4:	a8000115 	stw	zero,4(r21)
 20074d8:	dfc00917 	ldw	ra,36(sp)
 20074dc:	df000817 	ldw	fp,32(sp)
 20074e0:	ddc00717 	ldw	r23,28(sp)
 20074e4:	dd800617 	ldw	r22,24(sp)
 20074e8:	dd400517 	ldw	r21,20(sp)
 20074ec:	dd000417 	ldw	r20,16(sp)
 20074f0:	dcc00317 	ldw	r19,12(sp)
 20074f4:	dc800217 	ldw	r18,8(sp)
 20074f8:	dc400117 	ldw	r17,4(sp)
 20074fc:	dc000017 	ldw	r16,0(sp)
 2007500:	dec00a04 	addi	sp,sp,40
 2007504:	f800283a 	ret
 2007508:	a8800217 	ldw	r2,8(r21)
 200750c:	8c63883a 	add	r17,r17,r17
 2007510:	8c63883a 	add	r17,r17,r17
 2007514:	1445c83a 	sub	r2,r2,r17
 2007518:	a8800215 	stw	r2,8(r21)
 200751c:	b5800204 	addi	r22,r22,8
 2007520:	bdc00204 	addi	r23,r23,8
 2007524:	103fdb1e 	bne	r2,zero,2007494 <__alt_mem_mem_0+0xfcfe7494>
 2007528:	0005883a 	mov	r2,zero
 200752c:	003fe806 	br	20074d0 <__alt_mem_mem_0+0xfcfe74d0>
 2007530:	2008f640 	call	2008f64 <__sfvwrite_r>
 2007534:	003fe606 	br	20074d0 <__alt_mem_mem_0+0xfcfe74d0>

02007538 <__sprint_r>:
 2007538:	30c00217 	ldw	r3,8(r6)
 200753c:	18000126 	beq	r3,zero,2007544 <__sprint_r+0xc>
 2007540:	200743c1 	jmpi	200743c <__sprint_r.part.0>
 2007544:	30000115 	stw	zero,4(r6)
 2007548:	0005883a 	mov	r2,zero
 200754c:	f800283a 	ret

02007550 <___vfiprintf_internal_r>:
 2007550:	deffc904 	addi	sp,sp,-220
 2007554:	df003515 	stw	fp,212(sp)
 2007558:	dd003115 	stw	r20,196(sp)
 200755c:	dfc03615 	stw	ra,216(sp)
 2007560:	ddc03415 	stw	r23,208(sp)
 2007564:	dd803315 	stw	r22,204(sp)
 2007568:	dd403215 	stw	r21,200(sp)
 200756c:	dcc03015 	stw	r19,192(sp)
 2007570:	dc802f15 	stw	r18,188(sp)
 2007574:	dc402e15 	stw	r17,184(sp)
 2007578:	dc002d15 	stw	r16,180(sp)
 200757c:	d9002015 	stw	r4,128(sp)
 2007580:	d9c02215 	stw	r7,136(sp)
 2007584:	2829883a 	mov	r20,r5
 2007588:	3039883a 	mov	fp,r6
 200758c:	20000226 	beq	r4,zero,2007598 <___vfiprintf_internal_r+0x48>
 2007590:	20800e17 	ldw	r2,56(r4)
 2007594:	1000cf26 	beq	r2,zero,20078d4 <___vfiprintf_internal_r+0x384>
 2007598:	a080030b 	ldhu	r2,12(r20)
 200759c:	10c8000c 	andi	r3,r2,8192
 20075a0:	1800061e 	bne	r3,zero,20075bc <___vfiprintf_internal_r+0x6c>
 20075a4:	a1001917 	ldw	r4,100(r20)
 20075a8:	00f7ffc4 	movi	r3,-8193
 20075ac:	10880014 	ori	r2,r2,8192
 20075b0:	20c6703a 	and	r3,r4,r3
 20075b4:	a080030d 	sth	r2,12(r20)
 20075b8:	a0c01915 	stw	r3,100(r20)
 20075bc:	10c0020c 	andi	r3,r2,8
 20075c0:	1800a926 	beq	r3,zero,2007868 <___vfiprintf_internal_r+0x318>
 20075c4:	a0c00417 	ldw	r3,16(r20)
 20075c8:	1800a726 	beq	r3,zero,2007868 <___vfiprintf_internal_r+0x318>
 20075cc:	1080068c 	andi	r2,r2,26
 20075d0:	00c00284 	movi	r3,10
 20075d4:	10c0ac26 	beq	r2,r3,2007888 <___vfiprintf_internal_r+0x338>
 20075d8:	da801a04 	addi	r10,sp,104
 20075dc:	da801e15 	stw	r10,120(sp)
 20075e0:	d8801e17 	ldw	r2,120(sp)
 20075e4:	da8019c4 	addi	r10,sp,103
 20075e8:	05808134 	movhi	r22,516
 20075ec:	05c08134 	movhi	r23,516
 20075f0:	da801f15 	stw	r10,124(sp)
 20075f4:	1295c83a 	sub	r10,r2,r10
 20075f8:	b59aea04 	addi	r22,r22,27560
 20075fc:	bddae604 	addi	r23,r23,27544
 2007600:	dec01a15 	stw	sp,104(sp)
 2007604:	d8001c15 	stw	zero,112(sp)
 2007608:	d8001b15 	stw	zero,108(sp)
 200760c:	d8002615 	stw	zero,152(sp)
 2007610:	d8002315 	stw	zero,140(sp)
 2007614:	da802715 	stw	r10,156(sp)
 2007618:	d811883a 	mov	r8,sp
 200761c:	dd002115 	stw	r20,132(sp)
 2007620:	e021883a 	mov	r16,fp
 2007624:	80800007 	ldb	r2,0(r16)
 2007628:	1003ea26 	beq	r2,zero,20085d4 <___vfiprintf_internal_r+0x1084>
 200762c:	00c00944 	movi	r3,37
 2007630:	8025883a 	mov	r18,r16
 2007634:	10c0021e 	bne	r2,r3,2007640 <___vfiprintf_internal_r+0xf0>
 2007638:	00001606 	br	2007694 <___vfiprintf_internal_r+0x144>
 200763c:	10c00326 	beq	r2,r3,200764c <___vfiprintf_internal_r+0xfc>
 2007640:	94800044 	addi	r18,r18,1
 2007644:	90800007 	ldb	r2,0(r18)
 2007648:	103ffc1e 	bne	r2,zero,200763c <__alt_mem_mem_0+0xfcfe763c>
 200764c:	9423c83a 	sub	r17,r18,r16
 2007650:	88001026 	beq	r17,zero,2007694 <___vfiprintf_internal_r+0x144>
 2007654:	d8c01c17 	ldw	r3,112(sp)
 2007658:	d8801b17 	ldw	r2,108(sp)
 200765c:	44000015 	stw	r16,0(r8)
 2007660:	88c7883a 	add	r3,r17,r3
 2007664:	10800044 	addi	r2,r2,1
 2007668:	44400115 	stw	r17,4(r8)
 200766c:	d8c01c15 	stw	r3,112(sp)
 2007670:	d8801b15 	stw	r2,108(sp)
 2007674:	010001c4 	movi	r4,7
 2007678:	2080760e 	bge	r4,r2,2007854 <___vfiprintf_internal_r+0x304>
 200767c:	1803821e 	bne	r3,zero,2008488 <___vfiprintf_internal_r+0xf38>
 2007680:	da802317 	ldw	r10,140(sp)
 2007684:	d8001b15 	stw	zero,108(sp)
 2007688:	d811883a 	mov	r8,sp
 200768c:	5455883a 	add	r10,r10,r17
 2007690:	da802315 	stw	r10,140(sp)
 2007694:	90800007 	ldb	r2,0(r18)
 2007698:	10044626 	beq	r2,zero,20087b4 <___vfiprintf_internal_r+0x1264>
 200769c:	90c00047 	ldb	r3,1(r18)
 20076a0:	94000044 	addi	r16,r18,1
 20076a4:	d8001d85 	stb	zero,118(sp)
 20076a8:	0009883a 	mov	r4,zero
 20076ac:	000f883a 	mov	r7,zero
 20076b0:	027fffc4 	movi	r9,-1
 20076b4:	0023883a 	mov	r17,zero
 20076b8:	0029883a 	mov	r20,zero
 20076bc:	01401604 	movi	r5,88
 20076c0:	01800244 	movi	r6,9
 20076c4:	03400a84 	movi	r13,42
 20076c8:	03001b04 	movi	r12,108
 20076cc:	84000044 	addi	r16,r16,1
 20076d0:	18bff804 	addi	r2,r3,-32
 20076d4:	28827336 	bltu	r5,r2,20080a4 <___vfiprintf_internal_r+0xb54>
 20076d8:	100490ba 	slli	r2,r2,2
 20076dc:	02808034 	movhi	r10,512
 20076e0:	529dbc04 	addi	r10,r10,30448
 20076e4:	1285883a 	add	r2,r2,r10
 20076e8:	10800017 	ldw	r2,0(r2)
 20076ec:	1000683a 	jmp	r2
 20076f0:	02007dd8 	cmpnei	r8,zero,503
 20076f4:	020080a4 	muli	r8,zero,514
 20076f8:	020080a4 	muli	r8,zero,514
 20076fc:	02007df8 	rdprs	r8,zero,503
 2007700:	020080a4 	muli	r8,zero,514
 2007704:	020080a4 	muli	r8,zero,514
 2007708:	020080a4 	muli	r8,zero,514
 200770c:	020080a4 	muli	r8,zero,514
 2007710:	020080a4 	muli	r8,zero,514
 2007714:	020080a4 	muli	r8,zero,514
 2007718:	02007fe0 	cmpeqi	r8,zero,511
 200771c:	02007ffc 	xorhi	r8,zero,511
 2007720:	020080a4 	muli	r8,zero,514
 2007724:	020078e4 	muli	r8,zero,483
 2007728:	0200800c 	andi	r8,zero,512
 200772c:	020080a4 	muli	r8,zero,514
 2007730:	02007e04 	movi	r8,504
 2007734:	02007e10 	cmplti	r8,zero,504
 2007738:	02007e10 	cmplti	r8,zero,504
 200773c:	02007e10 	cmplti	r8,zero,504
 2007740:	02007e10 	cmplti	r8,zero,504
 2007744:	02007e10 	cmplti	r8,zero,504
 2007748:	02007e10 	cmplti	r8,zero,504
 200774c:	02007e10 	cmplti	r8,zero,504
 2007750:	02007e10 	cmplti	r8,zero,504
 2007754:	02007e10 	cmplti	r8,zero,504
 2007758:	020080a4 	muli	r8,zero,514
 200775c:	020080a4 	muli	r8,zero,514
 2007760:	020080a4 	muli	r8,zero,514
 2007764:	020080a4 	muli	r8,zero,514
 2007768:	020080a4 	muli	r8,zero,514
 200776c:	020080a4 	muli	r8,zero,514
 2007770:	020080a4 	muli	r8,zero,514
 2007774:	020080a4 	muli	r8,zero,514
 2007778:	020080a4 	muli	r8,zero,514
 200777c:	020080a4 	muli	r8,zero,514
 2007780:	02007e3c 	xorhi	r8,zero,504
 2007784:	020080a4 	muli	r8,zero,514
 2007788:	020080a4 	muli	r8,zero,514
 200778c:	020080a4 	muli	r8,zero,514
 2007790:	020080a4 	muli	r8,zero,514
 2007794:	020080a4 	muli	r8,zero,514
 2007798:	020080a4 	muli	r8,zero,514
 200779c:	020080a4 	muli	r8,zero,514
 20077a0:	020080a4 	muli	r8,zero,514
 20077a4:	020080a4 	muli	r8,zero,514
 20077a8:	020080a4 	muli	r8,zero,514
 20077ac:	02007e74 	movhi	r8,505
 20077b0:	020080a4 	muli	r8,zero,514
 20077b4:	020080a4 	muli	r8,zero,514
 20077b8:	020080a4 	muli	r8,zero,514
 20077bc:	020080a4 	muli	r8,zero,514
 20077c0:	020080a4 	muli	r8,zero,514
 20077c4:	02007ecc 	andi	r8,zero,507
 20077c8:	020080a4 	muli	r8,zero,514
 20077cc:	020080a4 	muli	r8,zero,514
 20077d0:	02007f3c 	xorhi	r8,zero,508
 20077d4:	020080a4 	muli	r8,zero,514
 20077d8:	020080a4 	muli	r8,zero,514
 20077dc:	020080a4 	muli	r8,zero,514
 20077e0:	020080a4 	muli	r8,zero,514
 20077e4:	020080a4 	muli	r8,zero,514
 20077e8:	020080a4 	muli	r8,zero,514
 20077ec:	020080a4 	muli	r8,zero,514
 20077f0:	020080a4 	muli	r8,zero,514
 20077f4:	020080a4 	muli	r8,zero,514
 20077f8:	020080a4 	muli	r8,zero,514
 20077fc:	02007ce8 	cmpgeui	r8,zero,499
 2007800:	02007d14 	movui	r8,500
 2007804:	020080a4 	muli	r8,zero,514
 2007808:	020080a4 	muli	r8,zero,514
 200780c:	020080a4 	muli	r8,zero,514
 2007810:	0200804c 	andi	r8,zero,513
 2007814:	02007d14 	movui	r8,500
 2007818:	020080a4 	muli	r8,zero,514
 200781c:	020080a4 	muli	r8,zero,514
 2007820:	02007ba8 	cmpgeui	r8,zero,494
 2007824:	020080a4 	muli	r8,zero,514
 2007828:	02007bb8 	rdprs	r8,zero,494
 200782c:	02007bf4 	movhi	r8,495
 2007830:	020078f0 	cmpltui	r8,zero,483
 2007834:	02007b9c 	xori	r8,zero,494
 2007838:	020080a4 	muli	r8,zero,514
 200783c:	02007f78 	rdprs	r8,zero,509
 2007840:	020080a4 	muli	r8,zero,514
 2007844:	02007fd0 	cmplti	r8,zero,511
 2007848:	020080a4 	muli	r8,zero,514
 200784c:	020080a4 	muli	r8,zero,514
 2007850:	02007c94 	movui	r8,498
 2007854:	42000204 	addi	r8,r8,8
 2007858:	da802317 	ldw	r10,140(sp)
 200785c:	5455883a 	add	r10,r10,r17
 2007860:	da802315 	stw	r10,140(sp)
 2007864:	003f8b06 	br	2007694 <__alt_mem_mem_0+0xfcfe7694>
 2007868:	d9002017 	ldw	r4,128(sp)
 200786c:	a00b883a 	mov	r5,r20
 2007870:	2002cf00 	call	2002cf0 <__swsetup_r>
 2007874:	1003b11e 	bne	r2,zero,200873c <___vfiprintf_internal_r+0x11ec>
 2007878:	a080030b 	ldhu	r2,12(r20)
 200787c:	00c00284 	movi	r3,10
 2007880:	1080068c 	andi	r2,r2,26
 2007884:	10ff541e 	bne	r2,r3,20075d8 <__alt_mem_mem_0+0xfcfe75d8>
 2007888:	a080038f 	ldh	r2,14(r20)
 200788c:	103f5216 	blt	r2,zero,20075d8 <__alt_mem_mem_0+0xfcfe75d8>
 2007890:	d9c02217 	ldw	r7,136(sp)
 2007894:	d9002017 	ldw	r4,128(sp)
 2007898:	e00d883a 	mov	r6,fp
 200789c:	a00b883a 	mov	r5,r20
 20078a0:	20089c80 	call	20089c8 <__sbprintf>
 20078a4:	dfc03617 	ldw	ra,216(sp)
 20078a8:	df003517 	ldw	fp,212(sp)
 20078ac:	ddc03417 	ldw	r23,208(sp)
 20078b0:	dd803317 	ldw	r22,204(sp)
 20078b4:	dd403217 	ldw	r21,200(sp)
 20078b8:	dd003117 	ldw	r20,196(sp)
 20078bc:	dcc03017 	ldw	r19,192(sp)
 20078c0:	dc802f17 	ldw	r18,188(sp)
 20078c4:	dc402e17 	ldw	r17,184(sp)
 20078c8:	dc002d17 	ldw	r16,180(sp)
 20078cc:	dec03704 	addi	sp,sp,220
 20078d0:	f800283a 	ret
 20078d4:	2004cc40 	call	2004cc4 <__sinit>
 20078d8:	003f2f06 	br	2007598 <__alt_mem_mem_0+0xfcfe7598>
 20078dc:	0463c83a 	sub	r17,zero,r17
 20078e0:	d8802215 	stw	r2,136(sp)
 20078e4:	a5000114 	ori	r20,r20,4
 20078e8:	80c00007 	ldb	r3,0(r16)
 20078ec:	003f7706 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 20078f0:	00800c04 	movi	r2,48
 20078f4:	da802217 	ldw	r10,136(sp)
 20078f8:	d8801d05 	stb	r2,116(sp)
 20078fc:	00801e04 	movi	r2,120
 2007900:	d8801d45 	stb	r2,117(sp)
 2007904:	d8001d85 	stb	zero,118(sp)
 2007908:	50c00104 	addi	r3,r10,4
 200790c:	54800017 	ldw	r18,0(r10)
 2007910:	0027883a 	mov	r19,zero
 2007914:	a0800094 	ori	r2,r20,2
 2007918:	48030b16 	blt	r9,zero,2008548 <___vfiprintf_internal_r+0xff8>
 200791c:	00bfdfc4 	movi	r2,-129
 2007920:	a096703a 	and	r11,r20,r2
 2007924:	d8c02215 	stw	r3,136(sp)
 2007928:	5d000094 	ori	r20,r11,2
 200792c:	90032b1e 	bne	r18,zero,20085dc <___vfiprintf_internal_r+0x108c>
 2007930:	00808134 	movhi	r2,516
 2007934:	109a8504 	addi	r2,r2,27156
 2007938:	d8802615 	stw	r2,152(sp)
 200793c:	0039883a 	mov	fp,zero
 2007940:	48017b1e 	bne	r9,zero,2007f30 <___vfiprintf_internal_r+0x9e0>
 2007944:	0013883a 	mov	r9,zero
 2007948:	0027883a 	mov	r19,zero
 200794c:	dd401a04 	addi	r21,sp,104
 2007950:	4825883a 	mov	r18,r9
 2007954:	4cc0010e 	bge	r9,r19,200795c <___vfiprintf_internal_r+0x40c>
 2007958:	9825883a 	mov	r18,r19
 200795c:	e7003fcc 	andi	fp,fp,255
 2007960:	e700201c 	xori	fp,fp,128
 2007964:	e73fe004 	addi	fp,fp,-128
 2007968:	e0000126 	beq	fp,zero,2007970 <___vfiprintf_internal_r+0x420>
 200796c:	94800044 	addi	r18,r18,1
 2007970:	a380008c 	andi	r14,r20,2
 2007974:	70000126 	beq	r14,zero,200797c <___vfiprintf_internal_r+0x42c>
 2007978:	94800084 	addi	r18,r18,2
 200797c:	a700210c 	andi	fp,r20,132
 2007980:	e001df1e 	bne	fp,zero,2008100 <___vfiprintf_internal_r+0xbb0>
 2007984:	8c87c83a 	sub	r3,r17,r18
 2007988:	00c1dd0e 	bge	zero,r3,2008100 <___vfiprintf_internal_r+0xbb0>
 200798c:	01c00404 	movi	r7,16
 2007990:	d8801c17 	ldw	r2,112(sp)
 2007994:	38c3ad0e 	bge	r7,r3,200884c <___vfiprintf_internal_r+0x12fc>
 2007998:	02808134 	movhi	r10,516
 200799c:	529aea04 	addi	r10,r10,27560
 20079a0:	dc002915 	stw	r16,164(sp)
 20079a4:	d9801b17 	ldw	r6,108(sp)
 20079a8:	da802415 	stw	r10,144(sp)
 20079ac:	03c001c4 	movi	r15,7
 20079b0:	da402515 	stw	r9,148(sp)
 20079b4:	db802815 	stw	r14,160(sp)
 20079b8:	1821883a 	mov	r16,r3
 20079bc:	00000506 	br	20079d4 <___vfiprintf_internal_r+0x484>
 20079c0:	31400084 	addi	r5,r6,2
 20079c4:	42000204 	addi	r8,r8,8
 20079c8:	200d883a 	mov	r6,r4
 20079cc:	843ffc04 	addi	r16,r16,-16
 20079d0:	3c000d0e 	bge	r7,r16,2007a08 <___vfiprintf_internal_r+0x4b8>
 20079d4:	10800404 	addi	r2,r2,16
 20079d8:	31000044 	addi	r4,r6,1
 20079dc:	45800015 	stw	r22,0(r8)
 20079e0:	41c00115 	stw	r7,4(r8)
 20079e4:	d8801c15 	stw	r2,112(sp)
 20079e8:	d9001b15 	stw	r4,108(sp)
 20079ec:	793ff40e 	bge	r15,r4,20079c0 <__alt_mem_mem_0+0xfcfe79c0>
 20079f0:	1001b51e 	bne	r2,zero,20080c8 <___vfiprintf_internal_r+0xb78>
 20079f4:	843ffc04 	addi	r16,r16,-16
 20079f8:	000d883a 	mov	r6,zero
 20079fc:	01400044 	movi	r5,1
 2007a00:	d811883a 	mov	r8,sp
 2007a04:	3c3ff316 	blt	r7,r16,20079d4 <__alt_mem_mem_0+0xfcfe79d4>
 2007a08:	8007883a 	mov	r3,r16
 2007a0c:	da402517 	ldw	r9,148(sp)
 2007a10:	db802817 	ldw	r14,160(sp)
 2007a14:	dc002917 	ldw	r16,164(sp)
 2007a18:	da802417 	ldw	r10,144(sp)
 2007a1c:	1885883a 	add	r2,r3,r2
 2007a20:	40c00115 	stw	r3,4(r8)
 2007a24:	42800015 	stw	r10,0(r8)
 2007a28:	d8801c15 	stw	r2,112(sp)
 2007a2c:	d9401b15 	stw	r5,108(sp)
 2007a30:	00c001c4 	movi	r3,7
 2007a34:	19426016 	blt	r3,r5,20083b8 <___vfiprintf_internal_r+0xe68>
 2007a38:	d8c01d87 	ldb	r3,118(sp)
 2007a3c:	42000204 	addi	r8,r8,8
 2007a40:	29000044 	addi	r4,r5,1
 2007a44:	1801b31e 	bne	r3,zero,2008114 <___vfiprintf_internal_r+0xbc4>
 2007a48:	7001c026 	beq	r14,zero,200814c <___vfiprintf_internal_r+0xbfc>
 2007a4c:	d8c01d04 	addi	r3,sp,116
 2007a50:	10800084 	addi	r2,r2,2
 2007a54:	40c00015 	stw	r3,0(r8)
 2007a58:	00c00084 	movi	r3,2
 2007a5c:	40c00115 	stw	r3,4(r8)
 2007a60:	d8801c15 	stw	r2,112(sp)
 2007a64:	d9001b15 	stw	r4,108(sp)
 2007a68:	00c001c4 	movi	r3,7
 2007a6c:	1902650e 	bge	r3,r4,2008404 <___vfiprintf_internal_r+0xeb4>
 2007a70:	10029a1e 	bne	r2,zero,20084dc <___vfiprintf_internal_r+0xf8c>
 2007a74:	00c02004 	movi	r3,128
 2007a78:	01000044 	movi	r4,1
 2007a7c:	000b883a 	mov	r5,zero
 2007a80:	d811883a 	mov	r8,sp
 2007a84:	e0c1b31e 	bne	fp,r3,2008154 <___vfiprintf_internal_r+0xc04>
 2007a88:	8cb9c83a 	sub	fp,r17,r18
 2007a8c:	0701b10e 	bge	zero,fp,2008154 <___vfiprintf_internal_r+0xc04>
 2007a90:	01c00404 	movi	r7,16
 2007a94:	3f03890e 	bge	r7,fp,20088bc <___vfiprintf_internal_r+0x136c>
 2007a98:	00c08134 	movhi	r3,516
 2007a9c:	18dae604 	addi	r3,r3,27544
 2007aa0:	d8c02415 	stw	r3,144(sp)
 2007aa4:	8007883a 	mov	r3,r16
 2007aa8:	034001c4 	movi	r13,7
 2007aac:	e021883a 	mov	r16,fp
 2007ab0:	da402515 	stw	r9,148(sp)
 2007ab4:	1839883a 	mov	fp,r3
 2007ab8:	00000506 	br	2007ad0 <___vfiprintf_internal_r+0x580>
 2007abc:	29800084 	addi	r6,r5,2
 2007ac0:	42000204 	addi	r8,r8,8
 2007ac4:	180b883a 	mov	r5,r3
 2007ac8:	843ffc04 	addi	r16,r16,-16
 2007acc:	3c000d0e 	bge	r7,r16,2007b04 <___vfiprintf_internal_r+0x5b4>
 2007ad0:	10800404 	addi	r2,r2,16
 2007ad4:	28c00044 	addi	r3,r5,1
 2007ad8:	45c00015 	stw	r23,0(r8)
 2007adc:	41c00115 	stw	r7,4(r8)
 2007ae0:	d8801c15 	stw	r2,112(sp)
 2007ae4:	d8c01b15 	stw	r3,108(sp)
 2007ae8:	68fff40e 	bge	r13,r3,2007abc <__alt_mem_mem_0+0xfcfe7abc>
 2007aec:	1002241e 	bne	r2,zero,2008380 <___vfiprintf_internal_r+0xe30>
 2007af0:	843ffc04 	addi	r16,r16,-16
 2007af4:	01800044 	movi	r6,1
 2007af8:	000b883a 	mov	r5,zero
 2007afc:	d811883a 	mov	r8,sp
 2007b00:	3c3ff316 	blt	r7,r16,2007ad0 <__alt_mem_mem_0+0xfcfe7ad0>
 2007b04:	da402517 	ldw	r9,148(sp)
 2007b08:	e007883a 	mov	r3,fp
 2007b0c:	8039883a 	mov	fp,r16
 2007b10:	1821883a 	mov	r16,r3
 2007b14:	d8c02417 	ldw	r3,144(sp)
 2007b18:	1705883a 	add	r2,r2,fp
 2007b1c:	47000115 	stw	fp,4(r8)
 2007b20:	40c00015 	stw	r3,0(r8)
 2007b24:	d8801c15 	stw	r2,112(sp)
 2007b28:	d9801b15 	stw	r6,108(sp)
 2007b2c:	00c001c4 	movi	r3,7
 2007b30:	19827616 	blt	r3,r6,200850c <___vfiprintf_internal_r+0xfbc>
 2007b34:	4cf9c83a 	sub	fp,r9,r19
 2007b38:	42000204 	addi	r8,r8,8
 2007b3c:	31000044 	addi	r4,r6,1
 2007b40:	300b883a 	mov	r5,r6
 2007b44:	07018516 	blt	zero,fp,200815c <___vfiprintf_internal_r+0xc0c>
 2007b48:	9885883a 	add	r2,r19,r2
 2007b4c:	45400015 	stw	r21,0(r8)
 2007b50:	44c00115 	stw	r19,4(r8)
 2007b54:	d8801c15 	stw	r2,112(sp)
 2007b58:	d9001b15 	stw	r4,108(sp)
 2007b5c:	00c001c4 	movi	r3,7
 2007b60:	1901dd0e 	bge	r3,r4,20082d8 <___vfiprintf_internal_r+0xd88>
 2007b64:	1002401e 	bne	r2,zero,2008468 <___vfiprintf_internal_r+0xf18>
 2007b68:	d8001b15 	stw	zero,108(sp)
 2007b6c:	a2c0010c 	andi	r11,r20,4
 2007b70:	58000226 	beq	r11,zero,2007b7c <___vfiprintf_internal_r+0x62c>
 2007b74:	8ca7c83a 	sub	r19,r17,r18
 2007b78:	04c2f216 	blt	zero,r19,2008744 <___vfiprintf_internal_r+0x11f4>
 2007b7c:	8c80010e 	bge	r17,r18,2007b84 <___vfiprintf_internal_r+0x634>
 2007b80:	9023883a 	mov	r17,r18
 2007b84:	da802317 	ldw	r10,140(sp)
 2007b88:	5455883a 	add	r10,r10,r17
 2007b8c:	da802315 	stw	r10,140(sp)
 2007b90:	d8001b15 	stw	zero,108(sp)
 2007b94:	d811883a 	mov	r8,sp
 2007b98:	003ea206 	br	2007624 <__alt_mem_mem_0+0xfcfe7624>
 2007b9c:	a5000814 	ori	r20,r20,32
 2007ba0:	80c00007 	ldb	r3,0(r16)
 2007ba4:	003ec906 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 2007ba8:	80c00007 	ldb	r3,0(r16)
 2007bac:	1b030926 	beq	r3,r12,20087d4 <___vfiprintf_internal_r+0x1284>
 2007bb0:	a5000414 	ori	r20,r20,16
 2007bb4:	003ec506 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 2007bb8:	21003fcc 	andi	r4,r4,255
 2007bbc:	20035e1e 	bne	r4,zero,2008938 <___vfiprintf_internal_r+0x13e8>
 2007bc0:	a080080c 	andi	r2,r20,32
 2007bc4:	1002a526 	beq	r2,zero,200865c <___vfiprintf_internal_r+0x110c>
 2007bc8:	da802217 	ldw	r10,136(sp)
 2007bcc:	50800017 	ldw	r2,0(r10)
 2007bd0:	da802317 	ldw	r10,140(sp)
 2007bd4:	5007d7fa 	srai	r3,r10,31
 2007bd8:	da802217 	ldw	r10,136(sp)
 2007bdc:	10c00115 	stw	r3,4(r2)
 2007be0:	52800104 	addi	r10,r10,4
 2007be4:	da802215 	stw	r10,136(sp)
 2007be8:	da802317 	ldw	r10,140(sp)
 2007bec:	12800015 	stw	r10,0(r2)
 2007bf0:	003e8c06 	br	2007624 <__alt_mem_mem_0+0xfcfe7624>
 2007bf4:	21003fcc 	andi	r4,r4,255
 2007bf8:	2003511e 	bne	r4,zero,2008940 <___vfiprintf_internal_r+0x13f0>
 2007bfc:	a080080c 	andi	r2,r20,32
 2007c00:	1000a126 	beq	r2,zero,2007e88 <___vfiprintf_internal_r+0x938>
 2007c04:	da802217 	ldw	r10,136(sp)
 2007c08:	d8001d85 	stb	zero,118(sp)
 2007c0c:	50800204 	addi	r2,r10,8
 2007c10:	54800017 	ldw	r18,0(r10)
 2007c14:	54c00117 	ldw	r19,4(r10)
 2007c18:	4802b416 	blt	r9,zero,20086ec <___vfiprintf_internal_r+0x119c>
 2007c1c:	013fdfc4 	movi	r4,-129
 2007c20:	94c6b03a 	or	r3,r18,r19
 2007c24:	d8802215 	stw	r2,136(sp)
 2007c28:	a128703a 	and	r20,r20,r4
 2007c2c:	1800a226 	beq	r3,zero,2007eb8 <___vfiprintf_internal_r+0x968>
 2007c30:	0039883a 	mov	fp,zero
 2007c34:	dd401a04 	addi	r21,sp,104
 2007c38:	9006d0fa 	srli	r3,r18,3
 2007c3c:	9808977a 	slli	r4,r19,29
 2007c40:	9826d0fa 	srli	r19,r19,3
 2007c44:	948001cc 	andi	r18,r18,7
 2007c48:	90800c04 	addi	r2,r18,48
 2007c4c:	ad7fffc4 	addi	r21,r21,-1
 2007c50:	20e4b03a 	or	r18,r4,r3
 2007c54:	a8800005 	stb	r2,0(r21)
 2007c58:	94c6b03a 	or	r3,r18,r19
 2007c5c:	183ff61e 	bne	r3,zero,2007c38 <__alt_mem_mem_0+0xfcfe7c38>
 2007c60:	a0c0004c 	andi	r3,r20,1
 2007c64:	18005926 	beq	r3,zero,2007dcc <___vfiprintf_internal_r+0x87c>
 2007c68:	10803fcc 	andi	r2,r2,255
 2007c6c:	1080201c 	xori	r2,r2,128
 2007c70:	10bfe004 	addi	r2,r2,-128
 2007c74:	00c00c04 	movi	r3,48
 2007c78:	10c05426 	beq	r2,r3,2007dcc <___vfiprintf_internal_r+0x87c>
 2007c7c:	da801e17 	ldw	r10,120(sp)
 2007c80:	a8bfffc4 	addi	r2,r21,-1
 2007c84:	a8ffffc5 	stb	r3,-1(r21)
 2007c88:	50a7c83a 	sub	r19,r10,r2
 2007c8c:	102b883a 	mov	r21,r2
 2007c90:	003f2f06 	br	2007950 <__alt_mem_mem_0+0xfcfe7950>
 2007c94:	21003fcc 	andi	r4,r4,255
 2007c98:	2003421e 	bne	r4,zero,20089a4 <___vfiprintf_internal_r+0x1454>
 2007c9c:	00808134 	movhi	r2,516
 2007ca0:	109a8504 	addi	r2,r2,27156
 2007ca4:	d8802615 	stw	r2,152(sp)
 2007ca8:	a080080c 	andi	r2,r20,32
 2007cac:	1000aa26 	beq	r2,zero,2007f58 <___vfiprintf_internal_r+0xa08>
 2007cb0:	da802217 	ldw	r10,136(sp)
 2007cb4:	54800017 	ldw	r18,0(r10)
 2007cb8:	54c00117 	ldw	r19,4(r10)
 2007cbc:	52800204 	addi	r10,r10,8
 2007cc0:	da802215 	stw	r10,136(sp)
 2007cc4:	a080004c 	andi	r2,r20,1
 2007cc8:	1001d226 	beq	r2,zero,2008414 <___vfiprintf_internal_r+0xec4>
 2007ccc:	94c4b03a 	or	r2,r18,r19
 2007cd0:	1002351e 	bne	r2,zero,20085a8 <___vfiprintf_internal_r+0x1058>
 2007cd4:	d8001d85 	stb	zero,118(sp)
 2007cd8:	48022216 	blt	r9,zero,2008564 <___vfiprintf_internal_r+0x1014>
 2007cdc:	00bfdfc4 	movi	r2,-129
 2007ce0:	a0a8703a 	and	r20,r20,r2
 2007ce4:	003f1506 	br	200793c <__alt_mem_mem_0+0xfcfe793c>
 2007ce8:	da802217 	ldw	r10,136(sp)
 2007cec:	04800044 	movi	r18,1
 2007cf0:	d8001d85 	stb	zero,118(sp)
 2007cf4:	50800017 	ldw	r2,0(r10)
 2007cf8:	52800104 	addi	r10,r10,4
 2007cfc:	da802215 	stw	r10,136(sp)
 2007d00:	d8801005 	stb	r2,64(sp)
 2007d04:	9027883a 	mov	r19,r18
 2007d08:	dd401004 	addi	r21,sp,64
 2007d0c:	0013883a 	mov	r9,zero
 2007d10:	003f1706 	br	2007970 <__alt_mem_mem_0+0xfcfe7970>
 2007d14:	21003fcc 	andi	r4,r4,255
 2007d18:	2003201e 	bne	r4,zero,200899c <___vfiprintf_internal_r+0x144c>
 2007d1c:	a080080c 	andi	r2,r20,32
 2007d20:	10004b26 	beq	r2,zero,2007e50 <___vfiprintf_internal_r+0x900>
 2007d24:	da802217 	ldw	r10,136(sp)
 2007d28:	50800117 	ldw	r2,4(r10)
 2007d2c:	54800017 	ldw	r18,0(r10)
 2007d30:	52800204 	addi	r10,r10,8
 2007d34:	da802215 	stw	r10,136(sp)
 2007d38:	1027883a 	mov	r19,r2
 2007d3c:	10022c16 	blt	r2,zero,20085f0 <___vfiprintf_internal_r+0x10a0>
 2007d40:	df001d83 	ldbu	fp,118(sp)
 2007d44:	48007216 	blt	r9,zero,2007f10 <___vfiprintf_internal_r+0x9c0>
 2007d48:	00ffdfc4 	movi	r3,-129
 2007d4c:	94c4b03a 	or	r2,r18,r19
 2007d50:	a0e8703a 	and	r20,r20,r3
 2007d54:	1000cc26 	beq	r2,zero,2008088 <___vfiprintf_internal_r+0xb38>
 2007d58:	98021026 	beq	r19,zero,200859c <___vfiprintf_internal_r+0x104c>
 2007d5c:	dc402415 	stw	r17,144(sp)
 2007d60:	dc002515 	stw	r16,148(sp)
 2007d64:	9823883a 	mov	r17,r19
 2007d68:	9021883a 	mov	r16,r18
 2007d6c:	dd401a04 	addi	r21,sp,104
 2007d70:	4825883a 	mov	r18,r9
 2007d74:	4027883a 	mov	r19,r8
 2007d78:	8009883a 	mov	r4,r16
 2007d7c:	880b883a 	mov	r5,r17
 2007d80:	01800284 	movi	r6,10
 2007d84:	000f883a 	mov	r7,zero
 2007d88:	200a4ac0 	call	200a4ac <__umoddi3>
 2007d8c:	10800c04 	addi	r2,r2,48
 2007d90:	ad7fffc4 	addi	r21,r21,-1
 2007d94:	8009883a 	mov	r4,r16
 2007d98:	880b883a 	mov	r5,r17
 2007d9c:	a8800005 	stb	r2,0(r21)
 2007da0:	01800284 	movi	r6,10
 2007da4:	000f883a 	mov	r7,zero
 2007da8:	2009f340 	call	2009f34 <__udivdi3>
 2007dac:	1021883a 	mov	r16,r2
 2007db0:	10c4b03a 	or	r2,r2,r3
 2007db4:	1823883a 	mov	r17,r3
 2007db8:	103fef1e 	bne	r2,zero,2007d78 <__alt_mem_mem_0+0xfcfe7d78>
 2007dbc:	dc402417 	ldw	r17,144(sp)
 2007dc0:	dc002517 	ldw	r16,148(sp)
 2007dc4:	9013883a 	mov	r9,r18
 2007dc8:	9811883a 	mov	r8,r19
 2007dcc:	da801e17 	ldw	r10,120(sp)
 2007dd0:	5567c83a 	sub	r19,r10,r21
 2007dd4:	003ede06 	br	2007950 <__alt_mem_mem_0+0xfcfe7950>
 2007dd8:	38803fcc 	andi	r2,r7,255
 2007ddc:	1080201c 	xori	r2,r2,128
 2007de0:	10bfe004 	addi	r2,r2,-128
 2007de4:	1002371e 	bne	r2,zero,20086c4 <___vfiprintf_internal_r+0x1174>
 2007de8:	01000044 	movi	r4,1
 2007dec:	01c00804 	movi	r7,32
 2007df0:	80c00007 	ldb	r3,0(r16)
 2007df4:	003e3506 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 2007df8:	a5000054 	ori	r20,r20,1
 2007dfc:	80c00007 	ldb	r3,0(r16)
 2007e00:	003e3206 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 2007e04:	a5002014 	ori	r20,r20,128
 2007e08:	80c00007 	ldb	r3,0(r16)
 2007e0c:	003e2f06 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 2007e10:	8015883a 	mov	r10,r16
 2007e14:	0023883a 	mov	r17,zero
 2007e18:	18bff404 	addi	r2,r3,-48
 2007e1c:	50c00007 	ldb	r3,0(r10)
 2007e20:	8c4002a4 	muli	r17,r17,10
 2007e24:	84000044 	addi	r16,r16,1
 2007e28:	8015883a 	mov	r10,r16
 2007e2c:	1463883a 	add	r17,r2,r17
 2007e30:	18bff404 	addi	r2,r3,-48
 2007e34:	30bff92e 	bgeu	r6,r2,2007e1c <__alt_mem_mem_0+0xfcfe7e1c>
 2007e38:	003e2506 	br	20076d0 <__alt_mem_mem_0+0xfcfe76d0>
 2007e3c:	21003fcc 	andi	r4,r4,255
 2007e40:	2002d41e 	bne	r4,zero,2008994 <___vfiprintf_internal_r+0x1444>
 2007e44:	a5000414 	ori	r20,r20,16
 2007e48:	a080080c 	andi	r2,r20,32
 2007e4c:	103fb51e 	bne	r2,zero,2007d24 <__alt_mem_mem_0+0xfcfe7d24>
 2007e50:	a080040c 	andi	r2,r20,16
 2007e54:	1001f826 	beq	r2,zero,2008638 <___vfiprintf_internal_r+0x10e8>
 2007e58:	da802217 	ldw	r10,136(sp)
 2007e5c:	54800017 	ldw	r18,0(r10)
 2007e60:	52800104 	addi	r10,r10,4
 2007e64:	da802215 	stw	r10,136(sp)
 2007e68:	9027d7fa 	srai	r19,r18,31
 2007e6c:	9805883a 	mov	r2,r19
 2007e70:	003fb206 	br	2007d3c <__alt_mem_mem_0+0xfcfe7d3c>
 2007e74:	21003fcc 	andi	r4,r4,255
 2007e78:	2002c41e 	bne	r4,zero,200898c <___vfiprintf_internal_r+0x143c>
 2007e7c:	a5000414 	ori	r20,r20,16
 2007e80:	a080080c 	andi	r2,r20,32
 2007e84:	103f5f1e 	bne	r2,zero,2007c04 <__alt_mem_mem_0+0xfcfe7c04>
 2007e88:	a080040c 	andi	r2,r20,16
 2007e8c:	10020f26 	beq	r2,zero,20086cc <___vfiprintf_internal_r+0x117c>
 2007e90:	da802217 	ldw	r10,136(sp)
 2007e94:	d8001d85 	stb	zero,118(sp)
 2007e98:	0027883a 	mov	r19,zero
 2007e9c:	50800104 	addi	r2,r10,4
 2007ea0:	54800017 	ldw	r18,0(r10)
 2007ea4:	48021116 	blt	r9,zero,20086ec <___vfiprintf_internal_r+0x119c>
 2007ea8:	00ffdfc4 	movi	r3,-129
 2007eac:	d8802215 	stw	r2,136(sp)
 2007eb0:	a0e8703a 	and	r20,r20,r3
 2007eb4:	903f5e1e 	bne	r18,zero,2007c30 <__alt_mem_mem_0+0xfcfe7c30>
 2007eb8:	0039883a 	mov	fp,zero
 2007ebc:	4802a626 	beq	r9,zero,2008958 <___vfiprintf_internal_r+0x1408>
 2007ec0:	0025883a 	mov	r18,zero
 2007ec4:	0027883a 	mov	r19,zero
 2007ec8:	003f5a06 	br	2007c34 <__alt_mem_mem_0+0xfcfe7c34>
 2007ecc:	21003fcc 	andi	r4,r4,255
 2007ed0:	20029f1e 	bne	r4,zero,2008950 <___vfiprintf_internal_r+0x1400>
 2007ed4:	a5000414 	ori	r20,r20,16
 2007ed8:	a080080c 	andi	r2,r20,32
 2007edc:	10005e1e 	bne	r2,zero,2008058 <___vfiprintf_internal_r+0xb08>
 2007ee0:	a080040c 	andi	r2,r20,16
 2007ee4:	1001a21e 	bne	r2,zero,2008570 <___vfiprintf_internal_r+0x1020>
 2007ee8:	a080100c 	andi	r2,r20,64
 2007eec:	d8001d85 	stb	zero,118(sp)
 2007ef0:	da802217 	ldw	r10,136(sp)
 2007ef4:	1002231e 	bne	r2,zero,2008784 <___vfiprintf_internal_r+0x1234>
 2007ef8:	50800104 	addi	r2,r10,4
 2007efc:	54800017 	ldw	r18,0(r10)
 2007f00:	0027883a 	mov	r19,zero
 2007f04:	4801a00e 	bge	r9,zero,2008588 <___vfiprintf_internal_r+0x1038>
 2007f08:	d8802215 	stw	r2,136(sp)
 2007f0c:	0039883a 	mov	fp,zero
 2007f10:	94c4b03a 	or	r2,r18,r19
 2007f14:	103f901e 	bne	r2,zero,2007d58 <__alt_mem_mem_0+0xfcfe7d58>
 2007f18:	00800044 	movi	r2,1
 2007f1c:	10803fcc 	andi	r2,r2,255
 2007f20:	00c00044 	movi	r3,1
 2007f24:	10c05926 	beq	r2,r3,200808c <___vfiprintf_internal_r+0xb3c>
 2007f28:	00c00084 	movi	r3,2
 2007f2c:	10ffe41e 	bne	r2,r3,2007ec0 <__alt_mem_mem_0+0xfcfe7ec0>
 2007f30:	0025883a 	mov	r18,zero
 2007f34:	0027883a 	mov	r19,zero
 2007f38:	00013d06 	br	2008430 <___vfiprintf_internal_r+0xee0>
 2007f3c:	21003fcc 	andi	r4,r4,255
 2007f40:	2002811e 	bne	r4,zero,2008948 <___vfiprintf_internal_r+0x13f8>
 2007f44:	00808134 	movhi	r2,516
 2007f48:	109a8004 	addi	r2,r2,27136
 2007f4c:	d8802615 	stw	r2,152(sp)
 2007f50:	a080080c 	andi	r2,r20,32
 2007f54:	103f561e 	bne	r2,zero,2007cb0 <__alt_mem_mem_0+0xfcfe7cb0>
 2007f58:	a080040c 	andi	r2,r20,16
 2007f5c:	1001d126 	beq	r2,zero,20086a4 <___vfiprintf_internal_r+0x1154>
 2007f60:	da802217 	ldw	r10,136(sp)
 2007f64:	0027883a 	mov	r19,zero
 2007f68:	54800017 	ldw	r18,0(r10)
 2007f6c:	52800104 	addi	r10,r10,4
 2007f70:	da802215 	stw	r10,136(sp)
 2007f74:	003f5306 	br	2007cc4 <__alt_mem_mem_0+0xfcfe7cc4>
 2007f78:	da802217 	ldw	r10,136(sp)
 2007f7c:	d8001d85 	stb	zero,118(sp)
 2007f80:	55400017 	ldw	r21,0(r10)
 2007f84:	50c00104 	addi	r3,r10,4
 2007f88:	a8024226 	beq	r21,zero,2008894 <___vfiprintf_internal_r+0x1344>
 2007f8c:	48021816 	blt	r9,zero,20087f0 <___vfiprintf_internal_r+0x12a0>
 2007f90:	480d883a 	mov	r6,r9
 2007f94:	000b883a 	mov	r5,zero
 2007f98:	a809883a 	mov	r4,r21
 2007f9c:	d8c02a15 	stw	r3,168(sp)
 2007fa0:	da002b15 	stw	r8,172(sp)
 2007fa4:	da402c15 	stw	r9,176(sp)
 2007fa8:	2005d740 	call	2005d74 <memchr>
 2007fac:	d8c02a17 	ldw	r3,168(sp)
 2007fb0:	da002b17 	ldw	r8,172(sp)
 2007fb4:	da402c17 	ldw	r9,176(sp)
 2007fb8:	10024826 	beq	r2,zero,20088dc <___vfiprintf_internal_r+0x138c>
 2007fbc:	1567c83a 	sub	r19,r2,r21
 2007fc0:	df001d83 	ldbu	fp,118(sp)
 2007fc4:	d8c02215 	stw	r3,136(sp)
 2007fc8:	0013883a 	mov	r9,zero
 2007fcc:	003e6006 	br	2007950 <__alt_mem_mem_0+0xfcfe7950>
 2007fd0:	21003fcc 	andi	r4,r4,255
 2007fd4:	203fc026 	beq	r4,zero,2007ed8 <__alt_mem_mem_0+0xfcfe7ed8>
 2007fd8:	d9c01d85 	stb	r7,118(sp)
 2007fdc:	003fbe06 	br	2007ed8 <__alt_mem_mem_0+0xfcfe7ed8>
 2007fe0:	da802217 	ldw	r10,136(sp)
 2007fe4:	54400017 	ldw	r17,0(r10)
 2007fe8:	50800104 	addi	r2,r10,4
 2007fec:	883e3b16 	blt	r17,zero,20078dc <__alt_mem_mem_0+0xfcfe78dc>
 2007ff0:	d8802215 	stw	r2,136(sp)
 2007ff4:	80c00007 	ldb	r3,0(r16)
 2007ff8:	003db406 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 2007ffc:	01000044 	movi	r4,1
 2008000:	01c00ac4 	movi	r7,43
 2008004:	80c00007 	ldb	r3,0(r16)
 2008008:	003db006 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 200800c:	80c00007 	ldb	r3,0(r16)
 2008010:	82800044 	addi	r10,r16,1
 2008014:	1b423c26 	beq	r3,r13,2008908 <___vfiprintf_internal_r+0x13b8>
 2008018:	18bff404 	addi	r2,r3,-48
 200801c:	0013883a 	mov	r9,zero
 2008020:	30822b36 	bltu	r6,r2,20088d0 <___vfiprintf_internal_r+0x1380>
 2008024:	50c00007 	ldb	r3,0(r10)
 2008028:	4a4002a4 	muli	r9,r9,10
 200802c:	54000044 	addi	r16,r10,1
 2008030:	8015883a 	mov	r10,r16
 2008034:	4893883a 	add	r9,r9,r2
 2008038:	18bff404 	addi	r2,r3,-48
 200803c:	30bff92e 	bgeu	r6,r2,2008024 <__alt_mem_mem_0+0xfcfe8024>
 2008040:	483da30e 	bge	r9,zero,20076d0 <__alt_mem_mem_0+0xfcfe76d0>
 2008044:	027fffc4 	movi	r9,-1
 2008048:	003da106 	br	20076d0 <__alt_mem_mem_0+0xfcfe76d0>
 200804c:	a5001014 	ori	r20,r20,64
 2008050:	80c00007 	ldb	r3,0(r16)
 2008054:	003d9d06 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 2008058:	da802217 	ldw	r10,136(sp)
 200805c:	d8001d85 	stb	zero,118(sp)
 2008060:	50c00204 	addi	r3,r10,8
 2008064:	54800017 	ldw	r18,0(r10)
 2008068:	54c00117 	ldw	r19,4(r10)
 200806c:	4801ca16 	blt	r9,zero,2008798 <___vfiprintf_internal_r+0x1248>
 2008070:	013fdfc4 	movi	r4,-129
 2008074:	94c4b03a 	or	r2,r18,r19
 2008078:	d8c02215 	stw	r3,136(sp)
 200807c:	a128703a 	and	r20,r20,r4
 2008080:	0039883a 	mov	fp,zero
 2008084:	103f341e 	bne	r2,zero,2007d58 <__alt_mem_mem_0+0xfcfe7d58>
 2008088:	483e2e26 	beq	r9,zero,2007944 <__alt_mem_mem_0+0xfcfe7944>
 200808c:	0025883a 	mov	r18,zero
 2008090:	94800c04 	addi	r18,r18,48
 2008094:	dc8019c5 	stb	r18,103(sp)
 2008098:	dcc02717 	ldw	r19,156(sp)
 200809c:	dd4019c4 	addi	r21,sp,103
 20080a0:	003e2b06 	br	2007950 <__alt_mem_mem_0+0xfcfe7950>
 20080a4:	21003fcc 	andi	r4,r4,255
 20080a8:	2002361e 	bne	r4,zero,2008984 <___vfiprintf_internal_r+0x1434>
 20080ac:	1801c126 	beq	r3,zero,20087b4 <___vfiprintf_internal_r+0x1264>
 20080b0:	04800044 	movi	r18,1
 20080b4:	d8c01005 	stb	r3,64(sp)
 20080b8:	d8001d85 	stb	zero,118(sp)
 20080bc:	9027883a 	mov	r19,r18
 20080c0:	dd401004 	addi	r21,sp,64
 20080c4:	003f1106 	br	2007d0c <__alt_mem_mem_0+0xfcfe7d0c>
 20080c8:	d9402117 	ldw	r5,132(sp)
 20080cc:	d9002017 	ldw	r4,128(sp)
 20080d0:	d9801a04 	addi	r6,sp,104
 20080d4:	d9c02b15 	stw	r7,172(sp)
 20080d8:	dbc02a15 	stw	r15,168(sp)
 20080dc:	200743c0 	call	200743c <__sprint_r.part.0>
 20080e0:	d9c02b17 	ldw	r7,172(sp)
 20080e4:	dbc02a17 	ldw	r15,168(sp)
 20080e8:	10006d1e 	bne	r2,zero,20082a0 <___vfiprintf_internal_r+0xd50>
 20080ec:	d9801b17 	ldw	r6,108(sp)
 20080f0:	d8801c17 	ldw	r2,112(sp)
 20080f4:	d811883a 	mov	r8,sp
 20080f8:	31400044 	addi	r5,r6,1
 20080fc:	003e3306 	br	20079cc <__alt_mem_mem_0+0xfcfe79cc>
 2008100:	d9401b17 	ldw	r5,108(sp)
 2008104:	d8801c17 	ldw	r2,112(sp)
 2008108:	29000044 	addi	r4,r5,1
 200810c:	d8c01d87 	ldb	r3,118(sp)
 2008110:	183e4d26 	beq	r3,zero,2007a48 <__alt_mem_mem_0+0xfcfe7a48>
 2008114:	00c00044 	movi	r3,1
 2008118:	d9401d84 	addi	r5,sp,118
 200811c:	10c5883a 	add	r2,r2,r3
 2008120:	41400015 	stw	r5,0(r8)
 2008124:	40c00115 	stw	r3,4(r8)
 2008128:	d8801c15 	stw	r2,112(sp)
 200812c:	d9001b15 	stw	r4,108(sp)
 2008130:	014001c4 	movi	r5,7
 2008134:	2900a90e 	bge	r5,r4,20083dc <___vfiprintf_internal_r+0xe8c>
 2008138:	1000da1e 	bne	r2,zero,20084a4 <___vfiprintf_internal_r+0xf54>
 200813c:	7000ab1e 	bne	r14,zero,20083ec <___vfiprintf_internal_r+0xe9c>
 2008140:	000b883a 	mov	r5,zero
 2008144:	1809883a 	mov	r4,r3
 2008148:	d811883a 	mov	r8,sp
 200814c:	00c02004 	movi	r3,128
 2008150:	e0fe4d26 	beq	fp,r3,2007a88 <__alt_mem_mem_0+0xfcfe7a88>
 2008154:	4cf9c83a 	sub	fp,r9,r19
 2008158:	073e7b0e 	bge	zero,fp,2007b48 <__alt_mem_mem_0+0xfcfe7b48>
 200815c:	01c00404 	movi	r7,16
 2008160:	3f01900e 	bge	r7,fp,20087a4 <___vfiprintf_internal_r+0x1254>
 2008164:	00c08134 	movhi	r3,516
 2008168:	18dae604 	addi	r3,r3,27544
 200816c:	d8c02415 	stw	r3,144(sp)
 2008170:	034001c4 	movi	r13,7
 2008174:	00000506 	br	200818c <___vfiprintf_internal_r+0xc3c>
 2008178:	29000084 	addi	r4,r5,2
 200817c:	42000204 	addi	r8,r8,8
 2008180:	180b883a 	mov	r5,r3
 2008184:	e73ffc04 	addi	fp,fp,-16
 2008188:	3f000d0e 	bge	r7,fp,20081c0 <___vfiprintf_internal_r+0xc70>
 200818c:	10800404 	addi	r2,r2,16
 2008190:	28c00044 	addi	r3,r5,1
 2008194:	45c00015 	stw	r23,0(r8)
 2008198:	41c00115 	stw	r7,4(r8)
 200819c:	d8801c15 	stw	r2,112(sp)
 20081a0:	d8c01b15 	stw	r3,108(sp)
 20081a4:	68fff40e 	bge	r13,r3,2008178 <__alt_mem_mem_0+0xfcfe8178>
 20081a8:	1000101e 	bne	r2,zero,20081ec <___vfiprintf_internal_r+0xc9c>
 20081ac:	e73ffc04 	addi	fp,fp,-16
 20081b0:	01000044 	movi	r4,1
 20081b4:	000b883a 	mov	r5,zero
 20081b8:	d811883a 	mov	r8,sp
 20081bc:	3f3ff316 	blt	r7,fp,200818c <__alt_mem_mem_0+0xfcfe818c>
 20081c0:	da802417 	ldw	r10,144(sp)
 20081c4:	1705883a 	add	r2,r2,fp
 20081c8:	47000115 	stw	fp,4(r8)
 20081cc:	42800015 	stw	r10,0(r8)
 20081d0:	d8801c15 	stw	r2,112(sp)
 20081d4:	d9001b15 	stw	r4,108(sp)
 20081d8:	00c001c4 	movi	r3,7
 20081dc:	19003616 	blt	r3,r4,20082b8 <___vfiprintf_internal_r+0xd68>
 20081e0:	42000204 	addi	r8,r8,8
 20081e4:	21000044 	addi	r4,r4,1
 20081e8:	003e5706 	br	2007b48 <__alt_mem_mem_0+0xfcfe7b48>
 20081ec:	d9402117 	ldw	r5,132(sp)
 20081f0:	d9002017 	ldw	r4,128(sp)
 20081f4:	d9801a04 	addi	r6,sp,104
 20081f8:	d9c02b15 	stw	r7,172(sp)
 20081fc:	db402a15 	stw	r13,168(sp)
 2008200:	200743c0 	call	200743c <__sprint_r.part.0>
 2008204:	d9c02b17 	ldw	r7,172(sp)
 2008208:	db402a17 	ldw	r13,168(sp)
 200820c:	1000241e 	bne	r2,zero,20082a0 <___vfiprintf_internal_r+0xd50>
 2008210:	d9401b17 	ldw	r5,108(sp)
 2008214:	d8801c17 	ldw	r2,112(sp)
 2008218:	d811883a 	mov	r8,sp
 200821c:	29000044 	addi	r4,r5,1
 2008220:	003fd806 	br	2008184 <__alt_mem_mem_0+0xfcfe8184>
 2008224:	d9401b17 	ldw	r5,108(sp)
 2008228:	00c08134 	movhi	r3,516
 200822c:	18daea04 	addi	r3,r3,27560
 2008230:	d8c02415 	stw	r3,144(sp)
 2008234:	29400044 	addi	r5,r5,1
 2008238:	d8c02417 	ldw	r3,144(sp)
 200823c:	14c5883a 	add	r2,r2,r19
 2008240:	44c00115 	stw	r19,4(r8)
 2008244:	40c00015 	stw	r3,0(r8)
 2008248:	d8801c15 	stw	r2,112(sp)
 200824c:	d9401b15 	stw	r5,108(sp)
 2008250:	00c001c4 	movi	r3,7
 2008254:	1940070e 	bge	r3,r5,2008274 <___vfiprintf_internal_r+0xd24>
 2008258:	103e4826 	beq	r2,zero,2007b7c <__alt_mem_mem_0+0xfcfe7b7c>
 200825c:	d9402117 	ldw	r5,132(sp)
 2008260:	d9002017 	ldw	r4,128(sp)
 2008264:	d9801a04 	addi	r6,sp,104
 2008268:	200743c0 	call	200743c <__sprint_r.part.0>
 200826c:	10000c1e 	bne	r2,zero,20082a0 <___vfiprintf_internal_r+0xd50>
 2008270:	d8801c17 	ldw	r2,112(sp)
 2008274:	8c80010e 	bge	r17,r18,200827c <___vfiprintf_internal_r+0xd2c>
 2008278:	9023883a 	mov	r17,r18
 200827c:	da802317 	ldw	r10,140(sp)
 2008280:	5455883a 	add	r10,r10,r17
 2008284:	da802315 	stw	r10,140(sp)
 2008288:	103e4126 	beq	r2,zero,2007b90 <__alt_mem_mem_0+0xfcfe7b90>
 200828c:	d9402117 	ldw	r5,132(sp)
 2008290:	d9002017 	ldw	r4,128(sp)
 2008294:	d9801a04 	addi	r6,sp,104
 2008298:	200743c0 	call	200743c <__sprint_r.part.0>
 200829c:	103e3c26 	beq	r2,zero,2007b90 <__alt_mem_mem_0+0xfcfe7b90>
 20082a0:	dd002117 	ldw	r20,132(sp)
 20082a4:	a080030b 	ldhu	r2,12(r20)
 20082a8:	1080100c 	andi	r2,r2,64
 20082ac:	1001231e 	bne	r2,zero,200873c <___vfiprintf_internal_r+0x11ec>
 20082b0:	d8802317 	ldw	r2,140(sp)
 20082b4:	003d7b06 	br	20078a4 <__alt_mem_mem_0+0xfcfe78a4>
 20082b8:	1000991e 	bne	r2,zero,2008520 <___vfiprintf_internal_r+0xfd0>
 20082bc:	00c00044 	movi	r3,1
 20082c0:	9805883a 	mov	r2,r19
 20082c4:	dd400015 	stw	r21,0(sp)
 20082c8:	dcc00115 	stw	r19,4(sp)
 20082cc:	dcc01c15 	stw	r19,112(sp)
 20082d0:	d8c01b15 	stw	r3,108(sp)
 20082d4:	d811883a 	mov	r8,sp
 20082d8:	42000204 	addi	r8,r8,8
 20082dc:	a2c0010c 	andi	r11,r20,4
 20082e0:	583fe426 	beq	r11,zero,2008274 <__alt_mem_mem_0+0xfcfe8274>
 20082e4:	8ca7c83a 	sub	r19,r17,r18
 20082e8:	04ffe20e 	bge	zero,r19,2008274 <__alt_mem_mem_0+0xfcfe8274>
 20082ec:	01c00404 	movi	r7,16
 20082f0:	3cffcc0e 	bge	r7,r19,2008224 <__alt_mem_mem_0+0xfcfe8224>
 20082f4:	02808134 	movhi	r10,516
 20082f8:	529aea04 	addi	r10,r10,27560
 20082fc:	d9001b17 	ldw	r4,108(sp)
 2008300:	da802415 	stw	r10,144(sp)
 2008304:	382b883a 	mov	r21,r7
 2008308:	050001c4 	movi	r20,7
 200830c:	df002017 	ldw	fp,128(sp)
 2008310:	00000506 	br	2008328 <___vfiprintf_internal_r+0xdd8>
 2008314:	21400084 	addi	r5,r4,2
 2008318:	42000204 	addi	r8,r8,8
 200831c:	1809883a 	mov	r4,r3
 2008320:	9cfffc04 	addi	r19,r19,-16
 2008324:	acffc40e 	bge	r21,r19,2008238 <__alt_mem_mem_0+0xfcfe8238>
 2008328:	10800404 	addi	r2,r2,16
 200832c:	20c00044 	addi	r3,r4,1
 2008330:	45800015 	stw	r22,0(r8)
 2008334:	45400115 	stw	r21,4(r8)
 2008338:	d8801c15 	stw	r2,112(sp)
 200833c:	d8c01b15 	stw	r3,108(sp)
 2008340:	a0fff40e 	bge	r20,r3,2008314 <__alt_mem_mem_0+0xfcfe8314>
 2008344:	1000041e 	bne	r2,zero,2008358 <___vfiprintf_internal_r+0xe08>
 2008348:	01400044 	movi	r5,1
 200834c:	0009883a 	mov	r4,zero
 2008350:	d811883a 	mov	r8,sp
 2008354:	003ff206 	br	2008320 <__alt_mem_mem_0+0xfcfe8320>
 2008358:	d9402117 	ldw	r5,132(sp)
 200835c:	d9801a04 	addi	r6,sp,104
 2008360:	e009883a 	mov	r4,fp
 2008364:	200743c0 	call	200743c <__sprint_r.part.0>
 2008368:	103fcd1e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 200836c:	d9001b17 	ldw	r4,108(sp)
 2008370:	d8801c17 	ldw	r2,112(sp)
 2008374:	d811883a 	mov	r8,sp
 2008378:	21400044 	addi	r5,r4,1
 200837c:	003fe806 	br	2008320 <__alt_mem_mem_0+0xfcfe8320>
 2008380:	d9402117 	ldw	r5,132(sp)
 2008384:	d9002017 	ldw	r4,128(sp)
 2008388:	d9801a04 	addi	r6,sp,104
 200838c:	d9c02b15 	stw	r7,172(sp)
 2008390:	db402a15 	stw	r13,168(sp)
 2008394:	200743c0 	call	200743c <__sprint_r.part.0>
 2008398:	d9c02b17 	ldw	r7,172(sp)
 200839c:	db402a17 	ldw	r13,168(sp)
 20083a0:	103fbf1e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 20083a4:	d9401b17 	ldw	r5,108(sp)
 20083a8:	d8801c17 	ldw	r2,112(sp)
 20083ac:	d811883a 	mov	r8,sp
 20083b0:	29800044 	addi	r6,r5,1
 20083b4:	003dc406 	br	2007ac8 <__alt_mem_mem_0+0xfcfe7ac8>
 20083b8:	1000d21e 	bne	r2,zero,2008704 <___vfiprintf_internal_r+0x11b4>
 20083bc:	d8c01d87 	ldb	r3,118(sp)
 20083c0:	18009526 	beq	r3,zero,2008618 <___vfiprintf_internal_r+0x10c8>
 20083c4:	00800044 	movi	r2,1
 20083c8:	d8c01d84 	addi	r3,sp,118
 20083cc:	1009883a 	mov	r4,r2
 20083d0:	d8c00015 	stw	r3,0(sp)
 20083d4:	d8800115 	stw	r2,4(sp)
 20083d8:	d811883a 	mov	r8,sp
 20083dc:	200b883a 	mov	r5,r4
 20083e0:	42000204 	addi	r8,r8,8
 20083e4:	21000044 	addi	r4,r4,1
 20083e8:	003d9706 	br	2007a48 <__alt_mem_mem_0+0xfcfe7a48>
 20083ec:	d9001d04 	addi	r4,sp,116
 20083f0:	00800084 	movi	r2,2
 20083f4:	d9000015 	stw	r4,0(sp)
 20083f8:	d8800115 	stw	r2,4(sp)
 20083fc:	1809883a 	mov	r4,r3
 2008400:	d811883a 	mov	r8,sp
 2008404:	200b883a 	mov	r5,r4
 2008408:	42000204 	addi	r8,r8,8
 200840c:	21000044 	addi	r4,r4,1
 2008410:	003f4e06 	br	200814c <__alt_mem_mem_0+0xfcfe814c>
 2008414:	d8001d85 	stb	zero,118(sp)
 2008418:	48005016 	blt	r9,zero,200855c <___vfiprintf_internal_r+0x100c>
 200841c:	00ffdfc4 	movi	r3,-129
 2008420:	94c4b03a 	or	r2,r18,r19
 2008424:	a0e8703a 	and	r20,r20,r3
 2008428:	103d4426 	beq	r2,zero,200793c <__alt_mem_mem_0+0xfcfe793c>
 200842c:	0039883a 	mov	fp,zero
 2008430:	d9002617 	ldw	r4,152(sp)
 2008434:	dd401a04 	addi	r21,sp,104
 2008438:	908003cc 	andi	r2,r18,15
 200843c:	9806973a 	slli	r3,r19,28
 2008440:	2085883a 	add	r2,r4,r2
 2008444:	9024d13a 	srli	r18,r18,4
 2008448:	10800003 	ldbu	r2,0(r2)
 200844c:	9826d13a 	srli	r19,r19,4
 2008450:	ad7fffc4 	addi	r21,r21,-1
 2008454:	1ca4b03a 	or	r18,r3,r18
 2008458:	a8800005 	stb	r2,0(r21)
 200845c:	94c4b03a 	or	r2,r18,r19
 2008460:	103ff51e 	bne	r2,zero,2008438 <__alt_mem_mem_0+0xfcfe8438>
 2008464:	003e5906 	br	2007dcc <__alt_mem_mem_0+0xfcfe7dcc>
 2008468:	d9402117 	ldw	r5,132(sp)
 200846c:	d9002017 	ldw	r4,128(sp)
 2008470:	d9801a04 	addi	r6,sp,104
 2008474:	200743c0 	call	200743c <__sprint_r.part.0>
 2008478:	103f891e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 200847c:	d8801c17 	ldw	r2,112(sp)
 2008480:	d811883a 	mov	r8,sp
 2008484:	003f9506 	br	20082dc <__alt_mem_mem_0+0xfcfe82dc>
 2008488:	d9402117 	ldw	r5,132(sp)
 200848c:	d9002017 	ldw	r4,128(sp)
 2008490:	d9801a04 	addi	r6,sp,104
 2008494:	200743c0 	call	200743c <__sprint_r.part.0>
 2008498:	103f811e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 200849c:	d811883a 	mov	r8,sp
 20084a0:	003ced06 	br	2007858 <__alt_mem_mem_0+0xfcfe7858>
 20084a4:	d9402117 	ldw	r5,132(sp)
 20084a8:	d9002017 	ldw	r4,128(sp)
 20084ac:	d9801a04 	addi	r6,sp,104
 20084b0:	da402c15 	stw	r9,176(sp)
 20084b4:	db802a15 	stw	r14,168(sp)
 20084b8:	200743c0 	call	200743c <__sprint_r.part.0>
 20084bc:	da402c17 	ldw	r9,176(sp)
 20084c0:	db802a17 	ldw	r14,168(sp)
 20084c4:	103f761e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 20084c8:	d9401b17 	ldw	r5,108(sp)
 20084cc:	d8801c17 	ldw	r2,112(sp)
 20084d0:	d811883a 	mov	r8,sp
 20084d4:	29000044 	addi	r4,r5,1
 20084d8:	003d5b06 	br	2007a48 <__alt_mem_mem_0+0xfcfe7a48>
 20084dc:	d9402117 	ldw	r5,132(sp)
 20084e0:	d9002017 	ldw	r4,128(sp)
 20084e4:	d9801a04 	addi	r6,sp,104
 20084e8:	da402c15 	stw	r9,176(sp)
 20084ec:	200743c0 	call	200743c <__sprint_r.part.0>
 20084f0:	da402c17 	ldw	r9,176(sp)
 20084f4:	103f6a1e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 20084f8:	d9401b17 	ldw	r5,108(sp)
 20084fc:	d8801c17 	ldw	r2,112(sp)
 2008500:	d811883a 	mov	r8,sp
 2008504:	29000044 	addi	r4,r5,1
 2008508:	003f1006 	br	200814c <__alt_mem_mem_0+0xfcfe814c>
 200850c:	1000c31e 	bne	r2,zero,200881c <___vfiprintf_internal_r+0x12cc>
 2008510:	01000044 	movi	r4,1
 2008514:	000b883a 	mov	r5,zero
 2008518:	d811883a 	mov	r8,sp
 200851c:	003f0d06 	br	2008154 <__alt_mem_mem_0+0xfcfe8154>
 2008520:	d9402117 	ldw	r5,132(sp)
 2008524:	d9002017 	ldw	r4,128(sp)
 2008528:	d9801a04 	addi	r6,sp,104
 200852c:	200743c0 	call	200743c <__sprint_r.part.0>
 2008530:	103f5b1e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 2008534:	d9001b17 	ldw	r4,108(sp)
 2008538:	d8801c17 	ldw	r2,112(sp)
 200853c:	d811883a 	mov	r8,sp
 2008540:	21000044 	addi	r4,r4,1
 2008544:	003d8006 	br	2007b48 <__alt_mem_mem_0+0xfcfe7b48>
 2008548:	01008134 	movhi	r4,516
 200854c:	211a8504 	addi	r4,r4,27156
 2008550:	d9002615 	stw	r4,152(sp)
 2008554:	d8c02215 	stw	r3,136(sp)
 2008558:	1029883a 	mov	r20,r2
 200855c:	94c4b03a 	or	r2,r18,r19
 2008560:	103fb21e 	bne	r2,zero,200842c <__alt_mem_mem_0+0xfcfe842c>
 2008564:	0039883a 	mov	fp,zero
 2008568:	00800084 	movi	r2,2
 200856c:	003e6b06 	br	2007f1c <__alt_mem_mem_0+0xfcfe7f1c>
 2008570:	da802217 	ldw	r10,136(sp)
 2008574:	d8001d85 	stb	zero,118(sp)
 2008578:	0027883a 	mov	r19,zero
 200857c:	50800104 	addi	r2,r10,4
 2008580:	54800017 	ldw	r18,0(r10)
 2008584:	483e6016 	blt	r9,zero,2007f08 <__alt_mem_mem_0+0xfcfe7f08>
 2008588:	00ffdfc4 	movi	r3,-129
 200858c:	d8802215 	stw	r2,136(sp)
 2008590:	a0e8703a 	and	r20,r20,r3
 2008594:	0039883a 	mov	fp,zero
 2008598:	903ebb26 	beq	r18,zero,2008088 <__alt_mem_mem_0+0xfcfe8088>
 200859c:	00800244 	movi	r2,9
 20085a0:	14bdee36 	bltu	r2,r18,2007d5c <__alt_mem_mem_0+0xfcfe7d5c>
 20085a4:	003eba06 	br	2008090 <__alt_mem_mem_0+0xfcfe8090>
 20085a8:	00800c04 	movi	r2,48
 20085ac:	d8c01d45 	stb	r3,117(sp)
 20085b0:	d8801d05 	stb	r2,116(sp)
 20085b4:	d8001d85 	stb	zero,118(sp)
 20085b8:	a0c00094 	ori	r3,r20,2
 20085bc:	4800a916 	blt	r9,zero,2008864 <___vfiprintf_internal_r+0x1314>
 20085c0:	00bfdfc4 	movi	r2,-129
 20085c4:	a096703a 	and	r11,r20,r2
 20085c8:	5d000094 	ori	r20,r11,2
 20085cc:	0039883a 	mov	fp,zero
 20085d0:	003f9706 	br	2008430 <__alt_mem_mem_0+0xfcfe8430>
 20085d4:	8025883a 	mov	r18,r16
 20085d8:	003c2e06 	br	2007694 <__alt_mem_mem_0+0xfcfe7694>
 20085dc:	00808134 	movhi	r2,516
 20085e0:	109a8504 	addi	r2,r2,27156
 20085e4:	0039883a 	mov	fp,zero
 20085e8:	d8802615 	stw	r2,152(sp)
 20085ec:	003f9006 	br	2008430 <__alt_mem_mem_0+0xfcfe8430>
 20085f0:	04a5c83a 	sub	r18,zero,r18
 20085f4:	07000b44 	movi	fp,45
 20085f8:	9004c03a 	cmpne	r2,r18,zero
 20085fc:	04e7c83a 	sub	r19,zero,r19
 2008600:	df001d85 	stb	fp,118(sp)
 2008604:	98a7c83a 	sub	r19,r19,r2
 2008608:	48009f16 	blt	r9,zero,2008888 <___vfiprintf_internal_r+0x1338>
 200860c:	00bfdfc4 	movi	r2,-129
 2008610:	a0a8703a 	and	r20,r20,r2
 2008614:	003dd006 	br	2007d58 <__alt_mem_mem_0+0xfcfe7d58>
 2008618:	70004c26 	beq	r14,zero,200874c <___vfiprintf_internal_r+0x11fc>
 200861c:	00800084 	movi	r2,2
 2008620:	d8c01d04 	addi	r3,sp,116
 2008624:	d8c00015 	stw	r3,0(sp)
 2008628:	d8800115 	stw	r2,4(sp)
 200862c:	01000044 	movi	r4,1
 2008630:	d811883a 	mov	r8,sp
 2008634:	003f7306 	br	2008404 <__alt_mem_mem_0+0xfcfe8404>
 2008638:	a080100c 	andi	r2,r20,64
 200863c:	da802217 	ldw	r10,136(sp)
 2008640:	103e0626 	beq	r2,zero,2007e5c <__alt_mem_mem_0+0xfcfe7e5c>
 2008644:	5480000f 	ldh	r18,0(r10)
 2008648:	52800104 	addi	r10,r10,4
 200864c:	da802215 	stw	r10,136(sp)
 2008650:	9027d7fa 	srai	r19,r18,31
 2008654:	9805883a 	mov	r2,r19
 2008658:	003db806 	br	2007d3c <__alt_mem_mem_0+0xfcfe7d3c>
 200865c:	a080040c 	andi	r2,r20,16
 2008660:	1000091e 	bne	r2,zero,2008688 <___vfiprintf_internal_r+0x1138>
 2008664:	a2c0100c 	andi	r11,r20,64
 2008668:	58000726 	beq	r11,zero,2008688 <___vfiprintf_internal_r+0x1138>
 200866c:	da802217 	ldw	r10,136(sp)
 2008670:	50800017 	ldw	r2,0(r10)
 2008674:	52800104 	addi	r10,r10,4
 2008678:	da802215 	stw	r10,136(sp)
 200867c:	da802317 	ldw	r10,140(sp)
 2008680:	1280000d 	sth	r10,0(r2)
 2008684:	003be706 	br	2007624 <__alt_mem_mem_0+0xfcfe7624>
 2008688:	da802217 	ldw	r10,136(sp)
 200868c:	50800017 	ldw	r2,0(r10)
 2008690:	52800104 	addi	r10,r10,4
 2008694:	da802215 	stw	r10,136(sp)
 2008698:	da802317 	ldw	r10,140(sp)
 200869c:	12800015 	stw	r10,0(r2)
 20086a0:	003be006 	br	2007624 <__alt_mem_mem_0+0xfcfe7624>
 20086a4:	a080100c 	andi	r2,r20,64
 20086a8:	da802217 	ldw	r10,136(sp)
 20086ac:	10003026 	beq	r2,zero,2008770 <___vfiprintf_internal_r+0x1220>
 20086b0:	5480000b 	ldhu	r18,0(r10)
 20086b4:	52800104 	addi	r10,r10,4
 20086b8:	0027883a 	mov	r19,zero
 20086bc:	da802215 	stw	r10,136(sp)
 20086c0:	003d8006 	br	2007cc4 <__alt_mem_mem_0+0xfcfe7cc4>
 20086c4:	80c00007 	ldb	r3,0(r16)
 20086c8:	003c0006 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 20086cc:	a080100c 	andi	r2,r20,64
 20086d0:	d8001d85 	stb	zero,118(sp)
 20086d4:	da802217 	ldw	r10,136(sp)
 20086d8:	1000201e 	bne	r2,zero,200875c <___vfiprintf_internal_r+0x120c>
 20086dc:	50800104 	addi	r2,r10,4
 20086e0:	54800017 	ldw	r18,0(r10)
 20086e4:	0027883a 	mov	r19,zero
 20086e8:	483def0e 	bge	r9,zero,2007ea8 <__alt_mem_mem_0+0xfcfe7ea8>
 20086ec:	94c6b03a 	or	r3,r18,r19
 20086f0:	d8802215 	stw	r2,136(sp)
 20086f4:	183d4e1e 	bne	r3,zero,2007c30 <__alt_mem_mem_0+0xfcfe7c30>
 20086f8:	0039883a 	mov	fp,zero
 20086fc:	0005883a 	mov	r2,zero
 2008700:	003e0606 	br	2007f1c <__alt_mem_mem_0+0xfcfe7f1c>
 2008704:	d9402117 	ldw	r5,132(sp)
 2008708:	d9002017 	ldw	r4,128(sp)
 200870c:	d9801a04 	addi	r6,sp,104
 2008710:	da402c15 	stw	r9,176(sp)
 2008714:	db802a15 	stw	r14,168(sp)
 2008718:	200743c0 	call	200743c <__sprint_r.part.0>
 200871c:	da402c17 	ldw	r9,176(sp)
 2008720:	db802a17 	ldw	r14,168(sp)
 2008724:	103ede1e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 2008728:	d9401b17 	ldw	r5,108(sp)
 200872c:	d8801c17 	ldw	r2,112(sp)
 2008730:	d811883a 	mov	r8,sp
 2008734:	29000044 	addi	r4,r5,1
 2008738:	003e7406 	br	200810c <__alt_mem_mem_0+0xfcfe810c>
 200873c:	00bfffc4 	movi	r2,-1
 2008740:	003c5806 	br	20078a4 <__alt_mem_mem_0+0xfcfe78a4>
 2008744:	d811883a 	mov	r8,sp
 2008748:	003ee806 	br	20082ec <__alt_mem_mem_0+0xfcfe82ec>
 200874c:	000b883a 	mov	r5,zero
 2008750:	01000044 	movi	r4,1
 2008754:	d811883a 	mov	r8,sp
 2008758:	003e7c06 	br	200814c <__alt_mem_mem_0+0xfcfe814c>
 200875c:	50800104 	addi	r2,r10,4
 2008760:	5480000b 	ldhu	r18,0(r10)
 2008764:	0027883a 	mov	r19,zero
 2008768:	483dcf0e 	bge	r9,zero,2007ea8 <__alt_mem_mem_0+0xfcfe7ea8>
 200876c:	003fdf06 	br	20086ec <__alt_mem_mem_0+0xfcfe86ec>
 2008770:	54800017 	ldw	r18,0(r10)
 2008774:	52800104 	addi	r10,r10,4
 2008778:	0027883a 	mov	r19,zero
 200877c:	da802215 	stw	r10,136(sp)
 2008780:	003d5006 	br	2007cc4 <__alt_mem_mem_0+0xfcfe7cc4>
 2008784:	50800104 	addi	r2,r10,4
 2008788:	5480000b 	ldhu	r18,0(r10)
 200878c:	0027883a 	mov	r19,zero
 2008790:	483f7d0e 	bge	r9,zero,2008588 <__alt_mem_mem_0+0xfcfe8588>
 2008794:	003ddc06 	br	2007f08 <__alt_mem_mem_0+0xfcfe7f08>
 2008798:	d8c02215 	stw	r3,136(sp)
 200879c:	0039883a 	mov	fp,zero
 20087a0:	003ddb06 	br	2007f10 <__alt_mem_mem_0+0xfcfe7f10>
 20087a4:	02808134 	movhi	r10,516
 20087a8:	529ae604 	addi	r10,r10,27544
 20087ac:	da802415 	stw	r10,144(sp)
 20087b0:	003e8306 	br	20081c0 <__alt_mem_mem_0+0xfcfe81c0>
 20087b4:	d8801c17 	ldw	r2,112(sp)
 20087b8:	dd002117 	ldw	r20,132(sp)
 20087bc:	103eb926 	beq	r2,zero,20082a4 <__alt_mem_mem_0+0xfcfe82a4>
 20087c0:	d9002017 	ldw	r4,128(sp)
 20087c4:	d9801a04 	addi	r6,sp,104
 20087c8:	a00b883a 	mov	r5,r20
 20087cc:	200743c0 	call	200743c <__sprint_r.part.0>
 20087d0:	003eb406 	br	20082a4 <__alt_mem_mem_0+0xfcfe82a4>
 20087d4:	80c00043 	ldbu	r3,1(r16)
 20087d8:	a5000814 	ori	r20,r20,32
 20087dc:	84000044 	addi	r16,r16,1
 20087e0:	18c03fcc 	andi	r3,r3,255
 20087e4:	18c0201c 	xori	r3,r3,128
 20087e8:	18ffe004 	addi	r3,r3,-128
 20087ec:	003bb706 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 20087f0:	a809883a 	mov	r4,r21
 20087f4:	d8c02a15 	stw	r3,168(sp)
 20087f8:	da002b15 	stw	r8,172(sp)
 20087fc:	20073a40 	call	20073a4 <strlen>
 2008800:	d8c02a17 	ldw	r3,168(sp)
 2008804:	1027883a 	mov	r19,r2
 2008808:	df001d83 	ldbu	fp,118(sp)
 200880c:	d8c02215 	stw	r3,136(sp)
 2008810:	0013883a 	mov	r9,zero
 2008814:	da002b17 	ldw	r8,172(sp)
 2008818:	003c4d06 	br	2007950 <__alt_mem_mem_0+0xfcfe7950>
 200881c:	d9402117 	ldw	r5,132(sp)
 2008820:	d9002017 	ldw	r4,128(sp)
 2008824:	d9801a04 	addi	r6,sp,104
 2008828:	da402c15 	stw	r9,176(sp)
 200882c:	200743c0 	call	200743c <__sprint_r.part.0>
 2008830:	da402c17 	ldw	r9,176(sp)
 2008834:	103e9a1e 	bne	r2,zero,20082a0 <__alt_mem_mem_0+0xfcfe82a0>
 2008838:	d9401b17 	ldw	r5,108(sp)
 200883c:	d8801c17 	ldw	r2,112(sp)
 2008840:	d811883a 	mov	r8,sp
 2008844:	29000044 	addi	r4,r5,1
 2008848:	003e4206 	br	2008154 <__alt_mem_mem_0+0xfcfe8154>
 200884c:	d9401b17 	ldw	r5,108(sp)
 2008850:	01008134 	movhi	r4,516
 2008854:	211aea04 	addi	r4,r4,27560
 2008858:	d9002415 	stw	r4,144(sp)
 200885c:	29400044 	addi	r5,r5,1
 2008860:	003c6d06 	br	2007a18 <__alt_mem_mem_0+0xfcfe7a18>
 2008864:	0039883a 	mov	fp,zero
 2008868:	00800084 	movi	r2,2
 200886c:	10803fcc 	andi	r2,r2,255
 2008870:	01000044 	movi	r4,1
 2008874:	11001e26 	beq	r2,r4,20088f0 <___vfiprintf_internal_r+0x13a0>
 2008878:	01000084 	movi	r4,2
 200887c:	11001e1e 	bne	r2,r4,20088f8 <___vfiprintf_internal_r+0x13a8>
 2008880:	1829883a 	mov	r20,r3
 2008884:	003eea06 	br	2008430 <__alt_mem_mem_0+0xfcfe8430>
 2008888:	a007883a 	mov	r3,r20
 200888c:	00800044 	movi	r2,1
 2008890:	003ff606 	br	200886c <__alt_mem_mem_0+0xfcfe886c>
 2008894:	00800184 	movi	r2,6
 2008898:	1240012e 	bgeu	r2,r9,20088a0 <___vfiprintf_internal_r+0x1350>
 200889c:	1013883a 	mov	r9,r2
 20088a0:	4827883a 	mov	r19,r9
 20088a4:	4825883a 	mov	r18,r9
 20088a8:	48001516 	blt	r9,zero,2008900 <___vfiprintf_internal_r+0x13b0>
 20088ac:	05408134 	movhi	r21,516
 20088b0:	d8c02215 	stw	r3,136(sp)
 20088b4:	ad5a8a04 	addi	r21,r21,27176
 20088b8:	003d1406 	br	2007d0c <__alt_mem_mem_0+0xfcfe7d0c>
 20088bc:	02808134 	movhi	r10,516
 20088c0:	529ae604 	addi	r10,r10,27544
 20088c4:	da802415 	stw	r10,144(sp)
 20088c8:	200d883a 	mov	r6,r4
 20088cc:	003c9106 	br	2007b14 <__alt_mem_mem_0+0xfcfe7b14>
 20088d0:	5021883a 	mov	r16,r10
 20088d4:	0013883a 	mov	r9,zero
 20088d8:	003b7d06 	br	20076d0 <__alt_mem_mem_0+0xfcfe76d0>
 20088dc:	4827883a 	mov	r19,r9
 20088e0:	df001d83 	ldbu	fp,118(sp)
 20088e4:	d8c02215 	stw	r3,136(sp)
 20088e8:	0013883a 	mov	r9,zero
 20088ec:	003c1806 	br	2007950 <__alt_mem_mem_0+0xfcfe7950>
 20088f0:	1829883a 	mov	r20,r3
 20088f4:	003d1806 	br	2007d58 <__alt_mem_mem_0+0xfcfe7d58>
 20088f8:	1829883a 	mov	r20,r3
 20088fc:	003ccd06 	br	2007c34 <__alt_mem_mem_0+0xfcfe7c34>
 2008900:	0025883a 	mov	r18,zero
 2008904:	003fe906 	br	20088ac <__alt_mem_mem_0+0xfcfe88ac>
 2008908:	d8802217 	ldw	r2,136(sp)
 200890c:	80c00043 	ldbu	r3,1(r16)
 2008910:	5021883a 	mov	r16,r10
 2008914:	12400017 	ldw	r9,0(r2)
 2008918:	10800104 	addi	r2,r2,4
 200891c:	d8802215 	stw	r2,136(sp)
 2008920:	483faf0e 	bge	r9,zero,20087e0 <__alt_mem_mem_0+0xfcfe87e0>
 2008924:	18c03fcc 	andi	r3,r3,255
 2008928:	18c0201c 	xori	r3,r3,128
 200892c:	027fffc4 	movi	r9,-1
 2008930:	18ffe004 	addi	r3,r3,-128
 2008934:	003b6506 	br	20076cc <__alt_mem_mem_0+0xfcfe76cc>
 2008938:	d9c01d85 	stb	r7,118(sp)
 200893c:	003ca006 	br	2007bc0 <__alt_mem_mem_0+0xfcfe7bc0>
 2008940:	d9c01d85 	stb	r7,118(sp)
 2008944:	003cad06 	br	2007bfc <__alt_mem_mem_0+0xfcfe7bfc>
 2008948:	d9c01d85 	stb	r7,118(sp)
 200894c:	003d7d06 	br	2007f44 <__alt_mem_mem_0+0xfcfe7f44>
 2008950:	d9c01d85 	stb	r7,118(sp)
 2008954:	003d5f06 	br	2007ed4 <__alt_mem_mem_0+0xfcfe7ed4>
 2008958:	a080004c 	andi	r2,r20,1
 200895c:	0039883a 	mov	fp,zero
 2008960:	10000526 	beq	r2,zero,2008978 <___vfiprintf_internal_r+0x1428>
 2008964:	00800c04 	movi	r2,48
 2008968:	d88019c5 	stb	r2,103(sp)
 200896c:	dcc02717 	ldw	r19,156(sp)
 2008970:	dd4019c4 	addi	r21,sp,103
 2008974:	003bf606 	br	2007950 <__alt_mem_mem_0+0xfcfe7950>
 2008978:	0027883a 	mov	r19,zero
 200897c:	dd401a04 	addi	r21,sp,104
 2008980:	003bf306 	br	2007950 <__alt_mem_mem_0+0xfcfe7950>
 2008984:	d9c01d85 	stb	r7,118(sp)
 2008988:	003dc806 	br	20080ac <__alt_mem_mem_0+0xfcfe80ac>
 200898c:	d9c01d85 	stb	r7,118(sp)
 2008990:	003d3a06 	br	2007e7c <__alt_mem_mem_0+0xfcfe7e7c>
 2008994:	d9c01d85 	stb	r7,118(sp)
 2008998:	003d2a06 	br	2007e44 <__alt_mem_mem_0+0xfcfe7e44>
 200899c:	d9c01d85 	stb	r7,118(sp)
 20089a0:	003cde06 	br	2007d1c <__alt_mem_mem_0+0xfcfe7d1c>
 20089a4:	d9c01d85 	stb	r7,118(sp)
 20089a8:	003cbc06 	br	2007c9c <__alt_mem_mem_0+0xfcfe7c9c>

020089ac <__vfiprintf_internal>:
 20089ac:	00808174 	movhi	r2,517
 20089b0:	10ab4004 	addi	r2,r2,-21248
 20089b4:	300f883a 	mov	r7,r6
 20089b8:	280d883a 	mov	r6,r5
 20089bc:	200b883a 	mov	r5,r4
 20089c0:	11000017 	ldw	r4,0(r2)
 20089c4:	20075501 	jmpi	2007550 <___vfiprintf_internal_r>

020089c8 <__sbprintf>:
 20089c8:	2880030b 	ldhu	r2,12(r5)
 20089cc:	2ac01917 	ldw	r11,100(r5)
 20089d0:	2a80038b 	ldhu	r10,14(r5)
 20089d4:	2a400717 	ldw	r9,28(r5)
 20089d8:	2a000917 	ldw	r8,36(r5)
 20089dc:	defee204 	addi	sp,sp,-1144
 20089e0:	00c10004 	movi	r3,1024
 20089e4:	dc011a15 	stw	r16,1128(sp)
 20089e8:	10bfff4c 	andi	r2,r2,65533
 20089ec:	2821883a 	mov	r16,r5
 20089f0:	d8cb883a 	add	r5,sp,r3
 20089f4:	dc811c15 	stw	r18,1136(sp)
 20089f8:	dc411b15 	stw	r17,1132(sp)
 20089fc:	dfc11d15 	stw	ra,1140(sp)
 2008a00:	2025883a 	mov	r18,r4
 2008a04:	d881030d 	sth	r2,1036(sp)
 2008a08:	dac11915 	stw	r11,1124(sp)
 2008a0c:	da81038d 	sth	r10,1038(sp)
 2008a10:	da410715 	stw	r9,1052(sp)
 2008a14:	da010915 	stw	r8,1060(sp)
 2008a18:	dec10015 	stw	sp,1024(sp)
 2008a1c:	dec10415 	stw	sp,1040(sp)
 2008a20:	d8c10215 	stw	r3,1032(sp)
 2008a24:	d8c10515 	stw	r3,1044(sp)
 2008a28:	d8010615 	stw	zero,1048(sp)
 2008a2c:	20075500 	call	2007550 <___vfiprintf_internal_r>
 2008a30:	1023883a 	mov	r17,r2
 2008a34:	10000416 	blt	r2,zero,2008a48 <__sbprintf+0x80>
 2008a38:	d9410004 	addi	r5,sp,1024
 2008a3c:	9009883a 	mov	r4,r18
 2008a40:	20048e80 	call	20048e8 <_fflush_r>
 2008a44:	10000d1e 	bne	r2,zero,2008a7c <__sbprintf+0xb4>
 2008a48:	d881030b 	ldhu	r2,1036(sp)
 2008a4c:	1080100c 	andi	r2,r2,64
 2008a50:	10000326 	beq	r2,zero,2008a60 <__sbprintf+0x98>
 2008a54:	8080030b 	ldhu	r2,12(r16)
 2008a58:	10801014 	ori	r2,r2,64
 2008a5c:	8080030d 	sth	r2,12(r16)
 2008a60:	8805883a 	mov	r2,r17
 2008a64:	dfc11d17 	ldw	ra,1140(sp)
 2008a68:	dc811c17 	ldw	r18,1136(sp)
 2008a6c:	dc411b17 	ldw	r17,1132(sp)
 2008a70:	dc011a17 	ldw	r16,1128(sp)
 2008a74:	dec11e04 	addi	sp,sp,1144
 2008a78:	f800283a 	ret
 2008a7c:	047fffc4 	movi	r17,-1
 2008a80:	003ff106 	br	2008a48 <__alt_mem_mem_0+0xfcfe8a48>

02008a84 <_write_r>:
 2008a84:	defffd04 	addi	sp,sp,-12
 2008a88:	2805883a 	mov	r2,r5
 2008a8c:	dc000015 	stw	r16,0(sp)
 2008a90:	04008174 	movhi	r16,517
 2008a94:	dc400115 	stw	r17,4(sp)
 2008a98:	300b883a 	mov	r5,r6
 2008a9c:	8432e304 	addi	r16,r16,-13428
 2008aa0:	2023883a 	mov	r17,r4
 2008aa4:	380d883a 	mov	r6,r7
 2008aa8:	1009883a 	mov	r4,r2
 2008aac:	dfc00215 	stw	ra,8(sp)
 2008ab0:	80000015 	stw	zero,0(r16)
 2008ab4:	20130f00 	call	20130f0 <write>
 2008ab8:	00ffffc4 	movi	r3,-1
 2008abc:	10c00526 	beq	r2,r3,2008ad4 <_write_r+0x50>
 2008ac0:	dfc00217 	ldw	ra,8(sp)
 2008ac4:	dc400117 	ldw	r17,4(sp)
 2008ac8:	dc000017 	ldw	r16,0(sp)
 2008acc:	dec00304 	addi	sp,sp,12
 2008ad0:	f800283a 	ret
 2008ad4:	80c00017 	ldw	r3,0(r16)
 2008ad8:	183ff926 	beq	r3,zero,2008ac0 <__alt_mem_mem_0+0xfcfe8ac0>
 2008adc:	88c00015 	stw	r3,0(r17)
 2008ae0:	003ff706 	br	2008ac0 <__alt_mem_mem_0+0xfcfe8ac0>

02008ae4 <_close_r>:
 2008ae4:	defffd04 	addi	sp,sp,-12
 2008ae8:	dc000015 	stw	r16,0(sp)
 2008aec:	04008174 	movhi	r16,517
 2008af0:	dc400115 	stw	r17,4(sp)
 2008af4:	8432e304 	addi	r16,r16,-13428
 2008af8:	2023883a 	mov	r17,r4
 2008afc:	2809883a 	mov	r4,r5
 2008b00:	dfc00215 	stw	ra,8(sp)
 2008b04:	80000015 	stw	zero,0(r16)
 2008b08:	201303c0 	call	201303c <close>
 2008b0c:	00ffffc4 	movi	r3,-1
 2008b10:	10c00526 	beq	r2,r3,2008b28 <_close_r+0x44>
 2008b14:	dfc00217 	ldw	ra,8(sp)
 2008b18:	dc400117 	ldw	r17,4(sp)
 2008b1c:	dc000017 	ldw	r16,0(sp)
 2008b20:	dec00304 	addi	sp,sp,12
 2008b24:	f800283a 	ret
 2008b28:	80c00017 	ldw	r3,0(r16)
 2008b2c:	183ff926 	beq	r3,zero,2008b14 <__alt_mem_mem_0+0xfcfe8b14>
 2008b30:	88c00015 	stw	r3,0(r17)
 2008b34:	003ff706 	br	2008b14 <__alt_mem_mem_0+0xfcfe8b14>

02008b38 <_calloc_r>:
 2008b38:	298b383a 	mul	r5,r5,r6
 2008b3c:	defffe04 	addi	sp,sp,-8
 2008b40:	dfc00115 	stw	ra,4(sp)
 2008b44:	dc000015 	stw	r16,0(sp)
 2008b48:	20055680 	call	2005568 <_malloc_r>
 2008b4c:	10002926 	beq	r2,zero,2008bf4 <_calloc_r+0xbc>
 2008b50:	11bfff17 	ldw	r6,-4(r2)
 2008b54:	1021883a 	mov	r16,r2
 2008b58:	00bfff04 	movi	r2,-4
 2008b5c:	308c703a 	and	r6,r6,r2
 2008b60:	00c00904 	movi	r3,36
 2008b64:	308d883a 	add	r6,r6,r2
 2008b68:	19801636 	bltu	r3,r6,2008bc4 <_calloc_r+0x8c>
 2008b6c:	008004c4 	movi	r2,19
 2008b70:	11800b2e 	bgeu	r2,r6,2008ba0 <_calloc_r+0x68>
 2008b74:	80000015 	stw	zero,0(r16)
 2008b78:	80000115 	stw	zero,4(r16)
 2008b7c:	008006c4 	movi	r2,27
 2008b80:	11801a2e 	bgeu	r2,r6,2008bec <_calloc_r+0xb4>
 2008b84:	80000215 	stw	zero,8(r16)
 2008b88:	80000315 	stw	zero,12(r16)
 2008b8c:	30c0151e 	bne	r6,r3,2008be4 <_calloc_r+0xac>
 2008b90:	80000415 	stw	zero,16(r16)
 2008b94:	80800604 	addi	r2,r16,24
 2008b98:	80000515 	stw	zero,20(r16)
 2008b9c:	00000106 	br	2008ba4 <_calloc_r+0x6c>
 2008ba0:	8005883a 	mov	r2,r16
 2008ba4:	10000015 	stw	zero,0(r2)
 2008ba8:	10000115 	stw	zero,4(r2)
 2008bac:	10000215 	stw	zero,8(r2)
 2008bb0:	8005883a 	mov	r2,r16
 2008bb4:	dfc00117 	ldw	ra,4(sp)
 2008bb8:	dc000017 	ldw	r16,0(sp)
 2008bbc:	dec00204 	addi	sp,sp,8
 2008bc0:	f800283a 	ret
 2008bc4:	000b883a 	mov	r5,zero
 2008bc8:	8009883a 	mov	r4,r16
 2008bcc:	2005fa00 	call	2005fa0 <memset>
 2008bd0:	8005883a 	mov	r2,r16
 2008bd4:	dfc00117 	ldw	ra,4(sp)
 2008bd8:	dc000017 	ldw	r16,0(sp)
 2008bdc:	dec00204 	addi	sp,sp,8
 2008be0:	f800283a 	ret
 2008be4:	80800404 	addi	r2,r16,16
 2008be8:	003fee06 	br	2008ba4 <__alt_mem_mem_0+0xfcfe8ba4>
 2008bec:	80800204 	addi	r2,r16,8
 2008bf0:	003fec06 	br	2008ba4 <__alt_mem_mem_0+0xfcfe8ba4>
 2008bf4:	0005883a 	mov	r2,zero
 2008bf8:	003fee06 	br	2008bb4 <__alt_mem_mem_0+0xfcfe8bb4>

02008bfc <_fclose_r>:
 2008bfc:	28003926 	beq	r5,zero,2008ce4 <_fclose_r+0xe8>
 2008c00:	defffc04 	addi	sp,sp,-16
 2008c04:	dc400115 	stw	r17,4(sp)
 2008c08:	dc000015 	stw	r16,0(sp)
 2008c0c:	dfc00315 	stw	ra,12(sp)
 2008c10:	dc800215 	stw	r18,8(sp)
 2008c14:	2023883a 	mov	r17,r4
 2008c18:	2821883a 	mov	r16,r5
 2008c1c:	20000226 	beq	r4,zero,2008c28 <_fclose_r+0x2c>
 2008c20:	20800e17 	ldw	r2,56(r4)
 2008c24:	10002726 	beq	r2,zero,2008cc4 <_fclose_r+0xc8>
 2008c28:	8080030f 	ldh	r2,12(r16)
 2008c2c:	1000071e 	bne	r2,zero,2008c4c <_fclose_r+0x50>
 2008c30:	0005883a 	mov	r2,zero
 2008c34:	dfc00317 	ldw	ra,12(sp)
 2008c38:	dc800217 	ldw	r18,8(sp)
 2008c3c:	dc400117 	ldw	r17,4(sp)
 2008c40:	dc000017 	ldw	r16,0(sp)
 2008c44:	dec00404 	addi	sp,sp,16
 2008c48:	f800283a 	ret
 2008c4c:	800b883a 	mov	r5,r16
 2008c50:	8809883a 	mov	r4,r17
 2008c54:	20046cc0 	call	20046cc <__sflush_r>
 2008c58:	1025883a 	mov	r18,r2
 2008c5c:	80800b17 	ldw	r2,44(r16)
 2008c60:	10000426 	beq	r2,zero,2008c74 <_fclose_r+0x78>
 2008c64:	81400717 	ldw	r5,28(r16)
 2008c68:	8809883a 	mov	r4,r17
 2008c6c:	103ee83a 	callr	r2
 2008c70:	10001616 	blt	r2,zero,2008ccc <_fclose_r+0xd0>
 2008c74:	8080030b 	ldhu	r2,12(r16)
 2008c78:	1080200c 	andi	r2,r2,128
 2008c7c:	1000151e 	bne	r2,zero,2008cd4 <_fclose_r+0xd8>
 2008c80:	81400c17 	ldw	r5,48(r16)
 2008c84:	28000526 	beq	r5,zero,2008c9c <_fclose_r+0xa0>
 2008c88:	80801004 	addi	r2,r16,64
 2008c8c:	28800226 	beq	r5,r2,2008c98 <_fclose_r+0x9c>
 2008c90:	8809883a 	mov	r4,r17
 2008c94:	2004e380 	call	2004e38 <_free_r>
 2008c98:	80000c15 	stw	zero,48(r16)
 2008c9c:	81401117 	ldw	r5,68(r16)
 2008ca0:	28000326 	beq	r5,zero,2008cb0 <_fclose_r+0xb4>
 2008ca4:	8809883a 	mov	r4,r17
 2008ca8:	2004e380 	call	2004e38 <_free_r>
 2008cac:	80001115 	stw	zero,68(r16)
 2008cb0:	2004cd40 	call	2004cd4 <__sfp_lock_acquire>
 2008cb4:	8000030d 	sth	zero,12(r16)
 2008cb8:	2004cd80 	call	2004cd8 <__sfp_lock_release>
 2008cbc:	9005883a 	mov	r2,r18
 2008cc0:	003fdc06 	br	2008c34 <__alt_mem_mem_0+0xfcfe8c34>
 2008cc4:	2004cc40 	call	2004cc4 <__sinit>
 2008cc8:	003fd706 	br	2008c28 <__alt_mem_mem_0+0xfcfe8c28>
 2008ccc:	04bfffc4 	movi	r18,-1
 2008cd0:	003fe806 	br	2008c74 <__alt_mem_mem_0+0xfcfe8c74>
 2008cd4:	81400417 	ldw	r5,16(r16)
 2008cd8:	8809883a 	mov	r4,r17
 2008cdc:	2004e380 	call	2004e38 <_free_r>
 2008ce0:	003fe706 	br	2008c80 <__alt_mem_mem_0+0xfcfe8c80>
 2008ce4:	0005883a 	mov	r2,zero
 2008ce8:	f800283a 	ret

02008cec <fclose>:
 2008cec:	00808174 	movhi	r2,517
 2008cf0:	10ab4004 	addi	r2,r2,-21248
 2008cf4:	200b883a 	mov	r5,r4
 2008cf8:	11000017 	ldw	r4,0(r2)
 2008cfc:	2008bfc1 	jmpi	2008bfc <_fclose_r>

02008d00 <__fputwc>:
 2008d00:	defff804 	addi	sp,sp,-32
 2008d04:	dcc00415 	stw	r19,16(sp)
 2008d08:	dc800315 	stw	r18,12(sp)
 2008d0c:	dc000115 	stw	r16,4(sp)
 2008d10:	dfc00715 	stw	ra,28(sp)
 2008d14:	dd400615 	stw	r21,24(sp)
 2008d18:	dd000515 	stw	r20,20(sp)
 2008d1c:	dc400215 	stw	r17,8(sp)
 2008d20:	2027883a 	mov	r19,r4
 2008d24:	2825883a 	mov	r18,r5
 2008d28:	3021883a 	mov	r16,r6
 2008d2c:	20053580 	call	2005358 <__locale_mb_cur_max>
 2008d30:	00c00044 	movi	r3,1
 2008d34:	10c03e26 	beq	r2,r3,2008e30 <__fputwc+0x130>
 2008d38:	81c01704 	addi	r7,r16,92
 2008d3c:	900d883a 	mov	r6,r18
 2008d40:	d80b883a 	mov	r5,sp
 2008d44:	9809883a 	mov	r4,r19
 2008d48:	2009d4c0 	call	2009d4c <_wcrtomb_r>
 2008d4c:	1029883a 	mov	r20,r2
 2008d50:	00bfffc4 	movi	r2,-1
 2008d54:	a0802026 	beq	r20,r2,2008dd8 <__fputwc+0xd8>
 2008d58:	d9400003 	ldbu	r5,0(sp)
 2008d5c:	a0001c26 	beq	r20,zero,2008dd0 <__fputwc+0xd0>
 2008d60:	0023883a 	mov	r17,zero
 2008d64:	05400284 	movi	r21,10
 2008d68:	00000906 	br	2008d90 <__fputwc+0x90>
 2008d6c:	80800017 	ldw	r2,0(r16)
 2008d70:	11400005 	stb	r5,0(r2)
 2008d74:	80c00017 	ldw	r3,0(r16)
 2008d78:	18c00044 	addi	r3,r3,1
 2008d7c:	80c00015 	stw	r3,0(r16)
 2008d80:	8c400044 	addi	r17,r17,1
 2008d84:	dc45883a 	add	r2,sp,r17
 2008d88:	8d00112e 	bgeu	r17,r20,2008dd0 <__fputwc+0xd0>
 2008d8c:	11400003 	ldbu	r5,0(r2)
 2008d90:	80c00217 	ldw	r3,8(r16)
 2008d94:	18ffffc4 	addi	r3,r3,-1
 2008d98:	80c00215 	stw	r3,8(r16)
 2008d9c:	183ff30e 	bge	r3,zero,2008d6c <__alt_mem_mem_0+0xfcfe8d6c>
 2008da0:	80800617 	ldw	r2,24(r16)
 2008da4:	18801916 	blt	r3,r2,2008e0c <__fputwc+0x10c>
 2008da8:	80800017 	ldw	r2,0(r16)
 2008dac:	11400005 	stb	r5,0(r2)
 2008db0:	80800017 	ldw	r2,0(r16)
 2008db4:	10c00003 	ldbu	r3,0(r2)
 2008db8:	10800044 	addi	r2,r2,1
 2008dbc:	1d402326 	beq	r3,r21,2008e4c <__fputwc+0x14c>
 2008dc0:	80800015 	stw	r2,0(r16)
 2008dc4:	8c400044 	addi	r17,r17,1
 2008dc8:	dc45883a 	add	r2,sp,r17
 2008dcc:	8d3fef36 	bltu	r17,r20,2008d8c <__alt_mem_mem_0+0xfcfe8d8c>
 2008dd0:	9005883a 	mov	r2,r18
 2008dd4:	00000406 	br	2008de8 <__fputwc+0xe8>
 2008dd8:	80c0030b 	ldhu	r3,12(r16)
 2008ddc:	a005883a 	mov	r2,r20
 2008de0:	18c01014 	ori	r3,r3,64
 2008de4:	80c0030d 	sth	r3,12(r16)
 2008de8:	dfc00717 	ldw	ra,28(sp)
 2008dec:	dd400617 	ldw	r21,24(sp)
 2008df0:	dd000517 	ldw	r20,20(sp)
 2008df4:	dcc00417 	ldw	r19,16(sp)
 2008df8:	dc800317 	ldw	r18,12(sp)
 2008dfc:	dc400217 	ldw	r17,8(sp)
 2008e00:	dc000117 	ldw	r16,4(sp)
 2008e04:	dec00804 	addi	sp,sp,32
 2008e08:	f800283a 	ret
 2008e0c:	800d883a 	mov	r6,r16
 2008e10:	29403fcc 	andi	r5,r5,255
 2008e14:	9809883a 	mov	r4,r19
 2008e18:	2009bf40 	call	2009bf4 <__swbuf_r>
 2008e1c:	10bfffe0 	cmpeqi	r2,r2,-1
 2008e20:	10803fcc 	andi	r2,r2,255
 2008e24:	103fd626 	beq	r2,zero,2008d80 <__alt_mem_mem_0+0xfcfe8d80>
 2008e28:	00bfffc4 	movi	r2,-1
 2008e2c:	003fee06 	br	2008de8 <__alt_mem_mem_0+0xfcfe8de8>
 2008e30:	90ffffc4 	addi	r3,r18,-1
 2008e34:	01003f84 	movi	r4,254
 2008e38:	20ffbf36 	bltu	r4,r3,2008d38 <__alt_mem_mem_0+0xfcfe8d38>
 2008e3c:	900b883a 	mov	r5,r18
 2008e40:	dc800005 	stb	r18,0(sp)
 2008e44:	1029883a 	mov	r20,r2
 2008e48:	003fc506 	br	2008d60 <__alt_mem_mem_0+0xfcfe8d60>
 2008e4c:	800d883a 	mov	r6,r16
 2008e50:	a80b883a 	mov	r5,r21
 2008e54:	9809883a 	mov	r4,r19
 2008e58:	2009bf40 	call	2009bf4 <__swbuf_r>
 2008e5c:	10bfffe0 	cmpeqi	r2,r2,-1
 2008e60:	003fef06 	br	2008e20 <__alt_mem_mem_0+0xfcfe8e20>

02008e64 <_fputwc_r>:
 2008e64:	3080030b 	ldhu	r2,12(r6)
 2008e68:	10c8000c 	andi	r3,r2,8192
 2008e6c:	1800051e 	bne	r3,zero,2008e84 <_fputwc_r+0x20>
 2008e70:	30c01917 	ldw	r3,100(r6)
 2008e74:	10880014 	ori	r2,r2,8192
 2008e78:	3080030d 	sth	r2,12(r6)
 2008e7c:	18880014 	ori	r2,r3,8192
 2008e80:	30801915 	stw	r2,100(r6)
 2008e84:	2008d001 	jmpi	2008d00 <__fputwc>

02008e88 <fputwc>:
 2008e88:	00808174 	movhi	r2,517
 2008e8c:	defffc04 	addi	sp,sp,-16
 2008e90:	10ab4004 	addi	r2,r2,-21248
 2008e94:	dc000115 	stw	r16,4(sp)
 2008e98:	14000017 	ldw	r16,0(r2)
 2008e9c:	dc400215 	stw	r17,8(sp)
 2008ea0:	dfc00315 	stw	ra,12(sp)
 2008ea4:	2023883a 	mov	r17,r4
 2008ea8:	80000226 	beq	r16,zero,2008eb4 <fputwc+0x2c>
 2008eac:	80800e17 	ldw	r2,56(r16)
 2008eb0:	10001026 	beq	r2,zero,2008ef4 <fputwc+0x6c>
 2008eb4:	2880030b 	ldhu	r2,12(r5)
 2008eb8:	10c8000c 	andi	r3,r2,8192
 2008ebc:	1800051e 	bne	r3,zero,2008ed4 <fputwc+0x4c>
 2008ec0:	28c01917 	ldw	r3,100(r5)
 2008ec4:	10880014 	ori	r2,r2,8192
 2008ec8:	2880030d 	sth	r2,12(r5)
 2008ecc:	18880014 	ori	r2,r3,8192
 2008ed0:	28801915 	stw	r2,100(r5)
 2008ed4:	280d883a 	mov	r6,r5
 2008ed8:	8009883a 	mov	r4,r16
 2008edc:	880b883a 	mov	r5,r17
 2008ee0:	dfc00317 	ldw	ra,12(sp)
 2008ee4:	dc400217 	ldw	r17,8(sp)
 2008ee8:	dc000117 	ldw	r16,4(sp)
 2008eec:	dec00404 	addi	sp,sp,16
 2008ef0:	2008d001 	jmpi	2008d00 <__fputwc>
 2008ef4:	8009883a 	mov	r4,r16
 2008ef8:	d9400015 	stw	r5,0(sp)
 2008efc:	2004cc40 	call	2004cc4 <__sinit>
 2008f00:	d9400017 	ldw	r5,0(sp)
 2008f04:	003feb06 	br	2008eb4 <__alt_mem_mem_0+0xfcfe8eb4>

02008f08 <_fstat_r>:
 2008f08:	defffd04 	addi	sp,sp,-12
 2008f0c:	2805883a 	mov	r2,r5
 2008f10:	dc000015 	stw	r16,0(sp)
 2008f14:	04008174 	movhi	r16,517
 2008f18:	dc400115 	stw	r17,4(sp)
 2008f1c:	8432e304 	addi	r16,r16,-13428
 2008f20:	2023883a 	mov	r17,r4
 2008f24:	300b883a 	mov	r5,r6
 2008f28:	1009883a 	mov	r4,r2
 2008f2c:	dfc00215 	stw	ra,8(sp)
 2008f30:	80000015 	stw	zero,0(r16)
 2008f34:	20125a00 	call	20125a0 <fstat>
 2008f38:	00ffffc4 	movi	r3,-1
 2008f3c:	10c00526 	beq	r2,r3,2008f54 <_fstat_r+0x4c>
 2008f40:	dfc00217 	ldw	ra,8(sp)
 2008f44:	dc400117 	ldw	r17,4(sp)
 2008f48:	dc000017 	ldw	r16,0(sp)
 2008f4c:	dec00304 	addi	sp,sp,12
 2008f50:	f800283a 	ret
 2008f54:	80c00017 	ldw	r3,0(r16)
 2008f58:	183ff926 	beq	r3,zero,2008f40 <__alt_mem_mem_0+0xfcfe8f40>
 2008f5c:	88c00015 	stw	r3,0(r17)
 2008f60:	003ff706 	br	2008f40 <__alt_mem_mem_0+0xfcfe8f40>

02008f64 <__sfvwrite_r>:
 2008f64:	30800217 	ldw	r2,8(r6)
 2008f68:	10006726 	beq	r2,zero,2009108 <__sfvwrite_r+0x1a4>
 2008f6c:	28c0030b 	ldhu	r3,12(r5)
 2008f70:	defff404 	addi	sp,sp,-48
 2008f74:	dd400715 	stw	r21,28(sp)
 2008f78:	dd000615 	stw	r20,24(sp)
 2008f7c:	dc000215 	stw	r16,8(sp)
 2008f80:	dfc00b15 	stw	ra,44(sp)
 2008f84:	df000a15 	stw	fp,40(sp)
 2008f88:	ddc00915 	stw	r23,36(sp)
 2008f8c:	dd800815 	stw	r22,32(sp)
 2008f90:	dcc00515 	stw	r19,20(sp)
 2008f94:	dc800415 	stw	r18,16(sp)
 2008f98:	dc400315 	stw	r17,12(sp)
 2008f9c:	1880020c 	andi	r2,r3,8
 2008fa0:	2821883a 	mov	r16,r5
 2008fa4:	202b883a 	mov	r21,r4
 2008fa8:	3029883a 	mov	r20,r6
 2008fac:	10002726 	beq	r2,zero,200904c <__sfvwrite_r+0xe8>
 2008fb0:	28800417 	ldw	r2,16(r5)
 2008fb4:	10002526 	beq	r2,zero,200904c <__sfvwrite_r+0xe8>
 2008fb8:	1880008c 	andi	r2,r3,2
 2008fbc:	a4400017 	ldw	r17,0(r20)
 2008fc0:	10002a26 	beq	r2,zero,200906c <__sfvwrite_r+0x108>
 2008fc4:	05a00034 	movhi	r22,32768
 2008fc8:	0027883a 	mov	r19,zero
 2008fcc:	0025883a 	mov	r18,zero
 2008fd0:	b5bf0004 	addi	r22,r22,-1024
 2008fd4:	980d883a 	mov	r6,r19
 2008fd8:	a809883a 	mov	r4,r21
 2008fdc:	90004626 	beq	r18,zero,20090f8 <__sfvwrite_r+0x194>
 2008fe0:	900f883a 	mov	r7,r18
 2008fe4:	b480022e 	bgeu	r22,r18,2008ff0 <__sfvwrite_r+0x8c>
 2008fe8:	01e00034 	movhi	r7,32768
 2008fec:	39ff0004 	addi	r7,r7,-1024
 2008ff0:	80800917 	ldw	r2,36(r16)
 2008ff4:	81400717 	ldw	r5,28(r16)
 2008ff8:	103ee83a 	callr	r2
 2008ffc:	0080570e 	bge	zero,r2,200915c <__sfvwrite_r+0x1f8>
 2009000:	a0c00217 	ldw	r3,8(r20)
 2009004:	98a7883a 	add	r19,r19,r2
 2009008:	90a5c83a 	sub	r18,r18,r2
 200900c:	1885c83a 	sub	r2,r3,r2
 2009010:	a0800215 	stw	r2,8(r20)
 2009014:	103fef1e 	bne	r2,zero,2008fd4 <__alt_mem_mem_0+0xfcfe8fd4>
 2009018:	0005883a 	mov	r2,zero
 200901c:	dfc00b17 	ldw	ra,44(sp)
 2009020:	df000a17 	ldw	fp,40(sp)
 2009024:	ddc00917 	ldw	r23,36(sp)
 2009028:	dd800817 	ldw	r22,32(sp)
 200902c:	dd400717 	ldw	r21,28(sp)
 2009030:	dd000617 	ldw	r20,24(sp)
 2009034:	dcc00517 	ldw	r19,20(sp)
 2009038:	dc800417 	ldw	r18,16(sp)
 200903c:	dc400317 	ldw	r17,12(sp)
 2009040:	dc000217 	ldw	r16,8(sp)
 2009044:	dec00c04 	addi	sp,sp,48
 2009048:	f800283a 	ret
 200904c:	800b883a 	mov	r5,r16
 2009050:	a809883a 	mov	r4,r21
 2009054:	2002cf00 	call	2002cf0 <__swsetup_r>
 2009058:	1000eb1e 	bne	r2,zero,2009408 <__sfvwrite_r+0x4a4>
 200905c:	80c0030b 	ldhu	r3,12(r16)
 2009060:	a4400017 	ldw	r17,0(r20)
 2009064:	1880008c 	andi	r2,r3,2
 2009068:	103fd61e 	bne	r2,zero,2008fc4 <__alt_mem_mem_0+0xfcfe8fc4>
 200906c:	1880004c 	andi	r2,r3,1
 2009070:	10003f1e 	bne	r2,zero,2009170 <__sfvwrite_r+0x20c>
 2009074:	0039883a 	mov	fp,zero
 2009078:	0025883a 	mov	r18,zero
 200907c:	90001a26 	beq	r18,zero,20090e8 <__sfvwrite_r+0x184>
 2009080:	1880800c 	andi	r2,r3,512
 2009084:	84c00217 	ldw	r19,8(r16)
 2009088:	10002126 	beq	r2,zero,2009110 <__sfvwrite_r+0x1ac>
 200908c:	982f883a 	mov	r23,r19
 2009090:	94c09336 	bltu	r18,r19,20092e0 <__sfvwrite_r+0x37c>
 2009094:	1881200c 	andi	r2,r3,1152
 2009098:	10009e1e 	bne	r2,zero,2009314 <__sfvwrite_r+0x3b0>
 200909c:	81000017 	ldw	r4,0(r16)
 20090a0:	b80d883a 	mov	r6,r23
 20090a4:	e00b883a 	mov	r5,fp
 20090a8:	20094d40 	call	20094d4 <memmove>
 20090ac:	80c00217 	ldw	r3,8(r16)
 20090b0:	81000017 	ldw	r4,0(r16)
 20090b4:	9005883a 	mov	r2,r18
 20090b8:	1ce7c83a 	sub	r19,r3,r19
 20090bc:	25cf883a 	add	r7,r4,r23
 20090c0:	84c00215 	stw	r19,8(r16)
 20090c4:	81c00015 	stw	r7,0(r16)
 20090c8:	a0c00217 	ldw	r3,8(r20)
 20090cc:	e0b9883a 	add	fp,fp,r2
 20090d0:	90a5c83a 	sub	r18,r18,r2
 20090d4:	18a7c83a 	sub	r19,r3,r2
 20090d8:	a4c00215 	stw	r19,8(r20)
 20090dc:	983fce26 	beq	r19,zero,2009018 <__alt_mem_mem_0+0xfcfe9018>
 20090e0:	80c0030b 	ldhu	r3,12(r16)
 20090e4:	903fe61e 	bne	r18,zero,2009080 <__alt_mem_mem_0+0xfcfe9080>
 20090e8:	8f000017 	ldw	fp,0(r17)
 20090ec:	8c800117 	ldw	r18,4(r17)
 20090f0:	8c400204 	addi	r17,r17,8
 20090f4:	003fe106 	br	200907c <__alt_mem_mem_0+0xfcfe907c>
 20090f8:	8cc00017 	ldw	r19,0(r17)
 20090fc:	8c800117 	ldw	r18,4(r17)
 2009100:	8c400204 	addi	r17,r17,8
 2009104:	003fb306 	br	2008fd4 <__alt_mem_mem_0+0xfcfe8fd4>
 2009108:	0005883a 	mov	r2,zero
 200910c:	f800283a 	ret
 2009110:	81000017 	ldw	r4,0(r16)
 2009114:	80800417 	ldw	r2,16(r16)
 2009118:	11005736 	bltu	r2,r4,2009278 <__sfvwrite_r+0x314>
 200911c:	85c00517 	ldw	r23,20(r16)
 2009120:	95c05536 	bltu	r18,r23,2009278 <__sfvwrite_r+0x314>
 2009124:	00a00034 	movhi	r2,32768
 2009128:	10bfffc4 	addi	r2,r2,-1
 200912c:	9009883a 	mov	r4,r18
 2009130:	1480012e 	bgeu	r2,r18,2009138 <__sfvwrite_r+0x1d4>
 2009134:	1009883a 	mov	r4,r2
 2009138:	b80b883a 	mov	r5,r23
 200913c:	200a9e40 	call	200a9e4 <__divsi3>
 2009140:	15cf383a 	mul	r7,r2,r23
 2009144:	81400717 	ldw	r5,28(r16)
 2009148:	80800917 	ldw	r2,36(r16)
 200914c:	e00d883a 	mov	r6,fp
 2009150:	a809883a 	mov	r4,r21
 2009154:	103ee83a 	callr	r2
 2009158:	00bfdb16 	blt	zero,r2,20090c8 <__alt_mem_mem_0+0xfcfe90c8>
 200915c:	8080030b 	ldhu	r2,12(r16)
 2009160:	10801014 	ori	r2,r2,64
 2009164:	8080030d 	sth	r2,12(r16)
 2009168:	00bfffc4 	movi	r2,-1
 200916c:	003fab06 	br	200901c <__alt_mem_mem_0+0xfcfe901c>
 2009170:	0027883a 	mov	r19,zero
 2009174:	0011883a 	mov	r8,zero
 2009178:	0039883a 	mov	fp,zero
 200917c:	0025883a 	mov	r18,zero
 2009180:	90001f26 	beq	r18,zero,2009200 <__sfvwrite_r+0x29c>
 2009184:	40005a26 	beq	r8,zero,20092f0 <__sfvwrite_r+0x38c>
 2009188:	982d883a 	mov	r22,r19
 200918c:	94c0012e 	bgeu	r18,r19,2009194 <__sfvwrite_r+0x230>
 2009190:	902d883a 	mov	r22,r18
 2009194:	81000017 	ldw	r4,0(r16)
 2009198:	80800417 	ldw	r2,16(r16)
 200919c:	b02f883a 	mov	r23,r22
 20091a0:	81c00517 	ldw	r7,20(r16)
 20091a4:	1100032e 	bgeu	r2,r4,20091b4 <__sfvwrite_r+0x250>
 20091a8:	80c00217 	ldw	r3,8(r16)
 20091ac:	38c7883a 	add	r3,r7,r3
 20091b0:	1d801816 	blt	r3,r22,2009214 <__sfvwrite_r+0x2b0>
 20091b4:	b1c03e16 	blt	r22,r7,20092b0 <__sfvwrite_r+0x34c>
 20091b8:	80800917 	ldw	r2,36(r16)
 20091bc:	81400717 	ldw	r5,28(r16)
 20091c0:	e00d883a 	mov	r6,fp
 20091c4:	da000115 	stw	r8,4(sp)
 20091c8:	a809883a 	mov	r4,r21
 20091cc:	103ee83a 	callr	r2
 20091d0:	102f883a 	mov	r23,r2
 20091d4:	da000117 	ldw	r8,4(sp)
 20091d8:	00bfe00e 	bge	zero,r2,200915c <__alt_mem_mem_0+0xfcfe915c>
 20091dc:	9de7c83a 	sub	r19,r19,r23
 20091e0:	98001f26 	beq	r19,zero,2009260 <__sfvwrite_r+0x2fc>
 20091e4:	a0800217 	ldw	r2,8(r20)
 20091e8:	e5f9883a 	add	fp,fp,r23
 20091ec:	95e5c83a 	sub	r18,r18,r23
 20091f0:	15efc83a 	sub	r23,r2,r23
 20091f4:	a5c00215 	stw	r23,8(r20)
 20091f8:	b83f8726 	beq	r23,zero,2009018 <__alt_mem_mem_0+0xfcfe9018>
 20091fc:	903fe11e 	bne	r18,zero,2009184 <__alt_mem_mem_0+0xfcfe9184>
 2009200:	8f000017 	ldw	fp,0(r17)
 2009204:	8c800117 	ldw	r18,4(r17)
 2009208:	0011883a 	mov	r8,zero
 200920c:	8c400204 	addi	r17,r17,8
 2009210:	003fdb06 	br	2009180 <__alt_mem_mem_0+0xfcfe9180>
 2009214:	180d883a 	mov	r6,r3
 2009218:	e00b883a 	mov	r5,fp
 200921c:	da000115 	stw	r8,4(sp)
 2009220:	d8c00015 	stw	r3,0(sp)
 2009224:	20094d40 	call	20094d4 <memmove>
 2009228:	d8c00017 	ldw	r3,0(sp)
 200922c:	80800017 	ldw	r2,0(r16)
 2009230:	800b883a 	mov	r5,r16
 2009234:	a809883a 	mov	r4,r21
 2009238:	10c5883a 	add	r2,r2,r3
 200923c:	80800015 	stw	r2,0(r16)
 2009240:	d8c00015 	stw	r3,0(sp)
 2009244:	20048e80 	call	20048e8 <_fflush_r>
 2009248:	d8c00017 	ldw	r3,0(sp)
 200924c:	da000117 	ldw	r8,4(sp)
 2009250:	103fc21e 	bne	r2,zero,200915c <__alt_mem_mem_0+0xfcfe915c>
 2009254:	182f883a 	mov	r23,r3
 2009258:	9de7c83a 	sub	r19,r19,r23
 200925c:	983fe11e 	bne	r19,zero,20091e4 <__alt_mem_mem_0+0xfcfe91e4>
 2009260:	800b883a 	mov	r5,r16
 2009264:	a809883a 	mov	r4,r21
 2009268:	20048e80 	call	20048e8 <_fflush_r>
 200926c:	103fbb1e 	bne	r2,zero,200915c <__alt_mem_mem_0+0xfcfe915c>
 2009270:	0011883a 	mov	r8,zero
 2009274:	003fdb06 	br	20091e4 <__alt_mem_mem_0+0xfcfe91e4>
 2009278:	94c0012e 	bgeu	r18,r19,2009280 <__sfvwrite_r+0x31c>
 200927c:	9027883a 	mov	r19,r18
 2009280:	980d883a 	mov	r6,r19
 2009284:	e00b883a 	mov	r5,fp
 2009288:	20094d40 	call	20094d4 <memmove>
 200928c:	80800217 	ldw	r2,8(r16)
 2009290:	80c00017 	ldw	r3,0(r16)
 2009294:	14c5c83a 	sub	r2,r2,r19
 2009298:	1cc7883a 	add	r3,r3,r19
 200929c:	80800215 	stw	r2,8(r16)
 20092a0:	80c00015 	stw	r3,0(r16)
 20092a4:	10004326 	beq	r2,zero,20093b4 <__sfvwrite_r+0x450>
 20092a8:	9805883a 	mov	r2,r19
 20092ac:	003f8606 	br	20090c8 <__alt_mem_mem_0+0xfcfe90c8>
 20092b0:	b00d883a 	mov	r6,r22
 20092b4:	e00b883a 	mov	r5,fp
 20092b8:	da000115 	stw	r8,4(sp)
 20092bc:	20094d40 	call	20094d4 <memmove>
 20092c0:	80800217 	ldw	r2,8(r16)
 20092c4:	80c00017 	ldw	r3,0(r16)
 20092c8:	da000117 	ldw	r8,4(sp)
 20092cc:	1585c83a 	sub	r2,r2,r22
 20092d0:	1dad883a 	add	r22,r3,r22
 20092d4:	80800215 	stw	r2,8(r16)
 20092d8:	85800015 	stw	r22,0(r16)
 20092dc:	003fbf06 	br	20091dc <__alt_mem_mem_0+0xfcfe91dc>
 20092e0:	81000017 	ldw	r4,0(r16)
 20092e4:	9027883a 	mov	r19,r18
 20092e8:	902f883a 	mov	r23,r18
 20092ec:	003f6c06 	br	20090a0 <__alt_mem_mem_0+0xfcfe90a0>
 20092f0:	900d883a 	mov	r6,r18
 20092f4:	01400284 	movi	r5,10
 20092f8:	e009883a 	mov	r4,fp
 20092fc:	2005d740 	call	2005d74 <memchr>
 2009300:	10003e26 	beq	r2,zero,20093fc <__sfvwrite_r+0x498>
 2009304:	10800044 	addi	r2,r2,1
 2009308:	1727c83a 	sub	r19,r2,fp
 200930c:	02000044 	movi	r8,1
 2009310:	003f9d06 	br	2009188 <__alt_mem_mem_0+0xfcfe9188>
 2009314:	80800517 	ldw	r2,20(r16)
 2009318:	81400417 	ldw	r5,16(r16)
 200931c:	81c00017 	ldw	r7,0(r16)
 2009320:	10a7883a 	add	r19,r2,r2
 2009324:	9885883a 	add	r2,r19,r2
 2009328:	1026d7fa 	srli	r19,r2,31
 200932c:	396dc83a 	sub	r22,r7,r5
 2009330:	b1000044 	addi	r4,r22,1
 2009334:	9885883a 	add	r2,r19,r2
 2009338:	1027d07a 	srai	r19,r2,1
 200933c:	2485883a 	add	r2,r4,r18
 2009340:	980d883a 	mov	r6,r19
 2009344:	9880022e 	bgeu	r19,r2,2009350 <__sfvwrite_r+0x3ec>
 2009348:	1027883a 	mov	r19,r2
 200934c:	100d883a 	mov	r6,r2
 2009350:	18c1000c 	andi	r3,r3,1024
 2009354:	18001c26 	beq	r3,zero,20093c8 <__sfvwrite_r+0x464>
 2009358:	300b883a 	mov	r5,r6
 200935c:	a809883a 	mov	r4,r21
 2009360:	20055680 	call	2005568 <_malloc_r>
 2009364:	102f883a 	mov	r23,r2
 2009368:	10002926 	beq	r2,zero,2009410 <__sfvwrite_r+0x4ac>
 200936c:	81400417 	ldw	r5,16(r16)
 2009370:	b00d883a 	mov	r6,r22
 2009374:	1009883a 	mov	r4,r2
 2009378:	2005e580 	call	2005e58 <memcpy>
 200937c:	8080030b 	ldhu	r2,12(r16)
 2009380:	00fedfc4 	movi	r3,-1153
 2009384:	10c4703a 	and	r2,r2,r3
 2009388:	10802014 	ori	r2,r2,128
 200938c:	8080030d 	sth	r2,12(r16)
 2009390:	bd89883a 	add	r4,r23,r22
 2009394:	9d8fc83a 	sub	r7,r19,r22
 2009398:	85c00415 	stw	r23,16(r16)
 200939c:	84c00515 	stw	r19,20(r16)
 20093a0:	81000015 	stw	r4,0(r16)
 20093a4:	9027883a 	mov	r19,r18
 20093a8:	81c00215 	stw	r7,8(r16)
 20093ac:	902f883a 	mov	r23,r18
 20093b0:	003f3b06 	br	20090a0 <__alt_mem_mem_0+0xfcfe90a0>
 20093b4:	800b883a 	mov	r5,r16
 20093b8:	a809883a 	mov	r4,r21
 20093bc:	20048e80 	call	20048e8 <_fflush_r>
 20093c0:	103fb926 	beq	r2,zero,20092a8 <__alt_mem_mem_0+0xfcfe92a8>
 20093c4:	003f6506 	br	200915c <__alt_mem_mem_0+0xfcfe915c>
 20093c8:	a809883a 	mov	r4,r21
 20093cc:	20096900 	call	2009690 <_realloc_r>
 20093d0:	102f883a 	mov	r23,r2
 20093d4:	103fee1e 	bne	r2,zero,2009390 <__alt_mem_mem_0+0xfcfe9390>
 20093d8:	81400417 	ldw	r5,16(r16)
 20093dc:	a809883a 	mov	r4,r21
 20093e0:	2004e380 	call	2004e38 <_free_r>
 20093e4:	8080030b 	ldhu	r2,12(r16)
 20093e8:	00ffdfc4 	movi	r3,-129
 20093ec:	1884703a 	and	r2,r3,r2
 20093f0:	00c00304 	movi	r3,12
 20093f4:	a8c00015 	stw	r3,0(r21)
 20093f8:	003f5906 	br	2009160 <__alt_mem_mem_0+0xfcfe9160>
 20093fc:	94c00044 	addi	r19,r18,1
 2009400:	02000044 	movi	r8,1
 2009404:	003f6006 	br	2009188 <__alt_mem_mem_0+0xfcfe9188>
 2009408:	00bfffc4 	movi	r2,-1
 200940c:	003f0306 	br	200901c <__alt_mem_mem_0+0xfcfe901c>
 2009410:	00800304 	movi	r2,12
 2009414:	a8800015 	stw	r2,0(r21)
 2009418:	8080030b 	ldhu	r2,12(r16)
 200941c:	003f5006 	br	2009160 <__alt_mem_mem_0+0xfcfe9160>

02009420 <_isatty_r>:
 2009420:	defffd04 	addi	sp,sp,-12
 2009424:	dc000015 	stw	r16,0(sp)
 2009428:	04008174 	movhi	r16,517
 200942c:	dc400115 	stw	r17,4(sp)
 2009430:	8432e304 	addi	r16,r16,-13428
 2009434:	2023883a 	mov	r17,r4
 2009438:	2809883a 	mov	r4,r5
 200943c:	dfc00215 	stw	ra,8(sp)
 2009440:	80000015 	stw	zero,0(r16)
 2009444:	20127cc0 	call	20127cc <isatty>
 2009448:	00ffffc4 	movi	r3,-1
 200944c:	10c00526 	beq	r2,r3,2009464 <_isatty_r+0x44>
 2009450:	dfc00217 	ldw	ra,8(sp)
 2009454:	dc400117 	ldw	r17,4(sp)
 2009458:	dc000017 	ldw	r16,0(sp)
 200945c:	dec00304 	addi	sp,sp,12
 2009460:	f800283a 	ret
 2009464:	80c00017 	ldw	r3,0(r16)
 2009468:	183ff926 	beq	r3,zero,2009450 <__alt_mem_mem_0+0xfcfe9450>
 200946c:	88c00015 	stw	r3,0(r17)
 2009470:	003ff706 	br	2009450 <__alt_mem_mem_0+0xfcfe9450>

02009474 <_lseek_r>:
 2009474:	defffd04 	addi	sp,sp,-12
 2009478:	2805883a 	mov	r2,r5
 200947c:	dc000015 	stw	r16,0(sp)
 2009480:	04008174 	movhi	r16,517
 2009484:	dc400115 	stw	r17,4(sp)
 2009488:	300b883a 	mov	r5,r6
 200948c:	8432e304 	addi	r16,r16,-13428
 2009490:	2023883a 	mov	r17,r4
 2009494:	380d883a 	mov	r6,r7
 2009498:	1009883a 	mov	r4,r2
 200949c:	dfc00215 	stw	ra,8(sp)
 20094a0:	80000015 	stw	zero,0(r16)
 20094a4:	20129980 	call	2012998 <lseek>
 20094a8:	00ffffc4 	movi	r3,-1
 20094ac:	10c00526 	beq	r2,r3,20094c4 <_lseek_r+0x50>
 20094b0:	dfc00217 	ldw	ra,8(sp)
 20094b4:	dc400117 	ldw	r17,4(sp)
 20094b8:	dc000017 	ldw	r16,0(sp)
 20094bc:	dec00304 	addi	sp,sp,12
 20094c0:	f800283a 	ret
 20094c4:	80c00017 	ldw	r3,0(r16)
 20094c8:	183ff926 	beq	r3,zero,20094b0 <__alt_mem_mem_0+0xfcfe94b0>
 20094cc:	88c00015 	stw	r3,0(r17)
 20094d0:	003ff706 	br	20094b0 <__alt_mem_mem_0+0xfcfe94b0>

020094d4 <memmove>:
 20094d4:	2005883a 	mov	r2,r4
 20094d8:	29000b2e 	bgeu	r5,r4,2009508 <memmove+0x34>
 20094dc:	298f883a 	add	r7,r5,r6
 20094e0:	21c0092e 	bgeu	r4,r7,2009508 <memmove+0x34>
 20094e4:	2187883a 	add	r3,r4,r6
 20094e8:	198bc83a 	sub	r5,r3,r6
 20094ec:	30004826 	beq	r6,zero,2009610 <memmove+0x13c>
 20094f0:	39ffffc4 	addi	r7,r7,-1
 20094f4:	39000003 	ldbu	r4,0(r7)
 20094f8:	18ffffc4 	addi	r3,r3,-1
 20094fc:	19000005 	stb	r4,0(r3)
 2009500:	28fffb1e 	bne	r5,r3,20094f0 <__alt_mem_mem_0+0xfcfe94f0>
 2009504:	f800283a 	ret
 2009508:	00c003c4 	movi	r3,15
 200950c:	1980412e 	bgeu	r3,r6,2009614 <memmove+0x140>
 2009510:	2886b03a 	or	r3,r5,r2
 2009514:	18c000cc 	andi	r3,r3,3
 2009518:	1800401e 	bne	r3,zero,200961c <memmove+0x148>
 200951c:	33fffc04 	addi	r15,r6,-16
 2009520:	781ed13a 	srli	r15,r15,4
 2009524:	28c00104 	addi	r3,r5,4
 2009528:	13400104 	addi	r13,r2,4
 200952c:	781c913a 	slli	r14,r15,4
 2009530:	2b000204 	addi	r12,r5,8
 2009534:	12c00204 	addi	r11,r2,8
 2009538:	73800504 	addi	r14,r14,20
 200953c:	2a800304 	addi	r10,r5,12
 2009540:	12400304 	addi	r9,r2,12
 2009544:	2b9d883a 	add	r14,r5,r14
 2009548:	2811883a 	mov	r8,r5
 200954c:	100f883a 	mov	r7,r2
 2009550:	41000017 	ldw	r4,0(r8)
 2009554:	39c00404 	addi	r7,r7,16
 2009558:	18c00404 	addi	r3,r3,16
 200955c:	393ffc15 	stw	r4,-16(r7)
 2009560:	193ffc17 	ldw	r4,-16(r3)
 2009564:	6b400404 	addi	r13,r13,16
 2009568:	5ac00404 	addi	r11,r11,16
 200956c:	693ffc15 	stw	r4,-16(r13)
 2009570:	61000017 	ldw	r4,0(r12)
 2009574:	4a400404 	addi	r9,r9,16
 2009578:	42000404 	addi	r8,r8,16
 200957c:	593ffc15 	stw	r4,-16(r11)
 2009580:	51000017 	ldw	r4,0(r10)
 2009584:	63000404 	addi	r12,r12,16
 2009588:	52800404 	addi	r10,r10,16
 200958c:	493ffc15 	stw	r4,-16(r9)
 2009590:	1bbfef1e 	bne	r3,r14,2009550 <__alt_mem_mem_0+0xfcfe9550>
 2009594:	79000044 	addi	r4,r15,1
 2009598:	2008913a 	slli	r4,r4,4
 200959c:	328003cc 	andi	r10,r6,15
 20095a0:	02c000c4 	movi	r11,3
 20095a4:	1107883a 	add	r3,r2,r4
 20095a8:	290b883a 	add	r5,r5,r4
 20095ac:	5a801e2e 	bgeu	r11,r10,2009628 <memmove+0x154>
 20095b0:	1813883a 	mov	r9,r3
 20095b4:	2811883a 	mov	r8,r5
 20095b8:	500f883a 	mov	r7,r10
 20095bc:	41000017 	ldw	r4,0(r8)
 20095c0:	4a400104 	addi	r9,r9,4
 20095c4:	39ffff04 	addi	r7,r7,-4
 20095c8:	493fff15 	stw	r4,-4(r9)
 20095cc:	42000104 	addi	r8,r8,4
 20095d0:	59fffa36 	bltu	r11,r7,20095bc <__alt_mem_mem_0+0xfcfe95bc>
 20095d4:	513fff04 	addi	r4,r10,-4
 20095d8:	2008d0ba 	srli	r4,r4,2
 20095dc:	318000cc 	andi	r6,r6,3
 20095e0:	21000044 	addi	r4,r4,1
 20095e4:	2109883a 	add	r4,r4,r4
 20095e8:	2109883a 	add	r4,r4,r4
 20095ec:	1907883a 	add	r3,r3,r4
 20095f0:	290b883a 	add	r5,r5,r4
 20095f4:	30000b26 	beq	r6,zero,2009624 <memmove+0x150>
 20095f8:	198d883a 	add	r6,r3,r6
 20095fc:	29c00003 	ldbu	r7,0(r5)
 2009600:	18c00044 	addi	r3,r3,1
 2009604:	29400044 	addi	r5,r5,1
 2009608:	19ffffc5 	stb	r7,-1(r3)
 200960c:	19bffb1e 	bne	r3,r6,20095fc <__alt_mem_mem_0+0xfcfe95fc>
 2009610:	f800283a 	ret
 2009614:	1007883a 	mov	r3,r2
 2009618:	003ff606 	br	20095f4 <__alt_mem_mem_0+0xfcfe95f4>
 200961c:	1007883a 	mov	r3,r2
 2009620:	003ff506 	br	20095f8 <__alt_mem_mem_0+0xfcfe95f8>
 2009624:	f800283a 	ret
 2009628:	500d883a 	mov	r6,r10
 200962c:	003ff106 	br	20095f4 <__alt_mem_mem_0+0xfcfe95f4>

02009630 <_read_r>:
 2009630:	defffd04 	addi	sp,sp,-12
 2009634:	2805883a 	mov	r2,r5
 2009638:	dc000015 	stw	r16,0(sp)
 200963c:	04008174 	movhi	r16,517
 2009640:	dc400115 	stw	r17,4(sp)
 2009644:	300b883a 	mov	r5,r6
 2009648:	8432e304 	addi	r16,r16,-13428
 200964c:	2023883a 	mov	r17,r4
 2009650:	380d883a 	mov	r6,r7
 2009654:	1009883a 	mov	r4,r2
 2009658:	dfc00215 	stw	ra,8(sp)
 200965c:	80000015 	stw	zero,0(r16)
 2009660:	20130840 	call	2013084 <read>
 2009664:	00ffffc4 	movi	r3,-1
 2009668:	10c00526 	beq	r2,r3,2009680 <_read_r+0x50>
 200966c:	dfc00217 	ldw	ra,8(sp)
 2009670:	dc400117 	ldw	r17,4(sp)
 2009674:	dc000017 	ldw	r16,0(sp)
 2009678:	dec00304 	addi	sp,sp,12
 200967c:	f800283a 	ret
 2009680:	80c00017 	ldw	r3,0(r16)
 2009684:	183ff926 	beq	r3,zero,200966c <__alt_mem_mem_0+0xfcfe966c>
 2009688:	88c00015 	stw	r3,0(r17)
 200968c:	003ff706 	br	200966c <__alt_mem_mem_0+0xfcfe966c>

02009690 <_realloc_r>:
 2009690:	defff604 	addi	sp,sp,-40
 2009694:	dc800215 	stw	r18,8(sp)
 2009698:	dfc00915 	stw	ra,36(sp)
 200969c:	df000815 	stw	fp,32(sp)
 20096a0:	ddc00715 	stw	r23,28(sp)
 20096a4:	dd800615 	stw	r22,24(sp)
 20096a8:	dd400515 	stw	r21,20(sp)
 20096ac:	dd000415 	stw	r20,16(sp)
 20096b0:	dcc00315 	stw	r19,12(sp)
 20096b4:	dc400115 	stw	r17,4(sp)
 20096b8:	dc000015 	stw	r16,0(sp)
 20096bc:	3025883a 	mov	r18,r6
 20096c0:	2800b726 	beq	r5,zero,20099a0 <_realloc_r+0x310>
 20096c4:	282b883a 	mov	r21,r5
 20096c8:	2029883a 	mov	r20,r4
 20096cc:	200d3180 	call	200d318 <__malloc_lock>
 20096d0:	a8bfff17 	ldw	r2,-4(r21)
 20096d4:	043fff04 	movi	r16,-4
 20096d8:	90c002c4 	addi	r3,r18,11
 20096dc:	01000584 	movi	r4,22
 20096e0:	acfffe04 	addi	r19,r21,-8
 20096e4:	1420703a 	and	r16,r2,r16
 20096e8:	20c0332e 	bgeu	r4,r3,20097b8 <_realloc_r+0x128>
 20096ec:	047ffe04 	movi	r17,-8
 20096f0:	1c62703a 	and	r17,r3,r17
 20096f4:	8807883a 	mov	r3,r17
 20096f8:	88005816 	blt	r17,zero,200985c <_realloc_r+0x1cc>
 20096fc:	8c805736 	bltu	r17,r18,200985c <_realloc_r+0x1cc>
 2009700:	80c0300e 	bge	r16,r3,20097c4 <_realloc_r+0x134>
 2009704:	07008174 	movhi	fp,517
 2009708:	e7250e04 	addi	fp,fp,-27592
 200970c:	e1c00217 	ldw	r7,8(fp)
 2009710:	9c09883a 	add	r4,r19,r16
 2009714:	22000117 	ldw	r8,4(r4)
 2009718:	21c06326 	beq	r4,r7,20098a8 <_realloc_r+0x218>
 200971c:	017fff84 	movi	r5,-2
 2009720:	414a703a 	and	r5,r8,r5
 2009724:	214b883a 	add	r5,r4,r5
 2009728:	29800117 	ldw	r6,4(r5)
 200972c:	3180004c 	andi	r6,r6,1
 2009730:	30003f26 	beq	r6,zero,2009830 <_realloc_r+0x1a0>
 2009734:	1080004c 	andi	r2,r2,1
 2009738:	10008326 	beq	r2,zero,2009948 <_realloc_r+0x2b8>
 200973c:	900b883a 	mov	r5,r18
 2009740:	a009883a 	mov	r4,r20
 2009744:	20055680 	call	2005568 <_malloc_r>
 2009748:	1025883a 	mov	r18,r2
 200974c:	10011e26 	beq	r2,zero,2009bc8 <_realloc_r+0x538>
 2009750:	a93fff17 	ldw	r4,-4(r21)
 2009754:	10fffe04 	addi	r3,r2,-8
 2009758:	00bfff84 	movi	r2,-2
 200975c:	2084703a 	and	r2,r4,r2
 2009760:	9885883a 	add	r2,r19,r2
 2009764:	1880ee26 	beq	r3,r2,2009b20 <_realloc_r+0x490>
 2009768:	81bfff04 	addi	r6,r16,-4
 200976c:	00800904 	movi	r2,36
 2009770:	1180b836 	bltu	r2,r6,2009a54 <_realloc_r+0x3c4>
 2009774:	00c004c4 	movi	r3,19
 2009778:	19809636 	bltu	r3,r6,20099d4 <_realloc_r+0x344>
 200977c:	9005883a 	mov	r2,r18
 2009780:	a807883a 	mov	r3,r21
 2009784:	19000017 	ldw	r4,0(r3)
 2009788:	11000015 	stw	r4,0(r2)
 200978c:	19000117 	ldw	r4,4(r3)
 2009790:	11000115 	stw	r4,4(r2)
 2009794:	18c00217 	ldw	r3,8(r3)
 2009798:	10c00215 	stw	r3,8(r2)
 200979c:	a80b883a 	mov	r5,r21
 20097a0:	a009883a 	mov	r4,r20
 20097a4:	2004e380 	call	2004e38 <_free_r>
 20097a8:	a009883a 	mov	r4,r20
 20097ac:	200d3780 	call	200d378 <__malloc_unlock>
 20097b0:	9005883a 	mov	r2,r18
 20097b4:	00001206 	br	2009800 <_realloc_r+0x170>
 20097b8:	00c00404 	movi	r3,16
 20097bc:	1823883a 	mov	r17,r3
 20097c0:	003fce06 	br	20096fc <__alt_mem_mem_0+0xfcfe96fc>
 20097c4:	a825883a 	mov	r18,r21
 20097c8:	8445c83a 	sub	r2,r16,r17
 20097cc:	00c003c4 	movi	r3,15
 20097d0:	18802636 	bltu	r3,r2,200986c <_realloc_r+0x1dc>
 20097d4:	99800117 	ldw	r6,4(r19)
 20097d8:	9c07883a 	add	r3,r19,r16
 20097dc:	3180004c 	andi	r6,r6,1
 20097e0:	3420b03a 	or	r16,r6,r16
 20097e4:	9c000115 	stw	r16,4(r19)
 20097e8:	18800117 	ldw	r2,4(r3)
 20097ec:	10800054 	ori	r2,r2,1
 20097f0:	18800115 	stw	r2,4(r3)
 20097f4:	a009883a 	mov	r4,r20
 20097f8:	200d3780 	call	200d378 <__malloc_unlock>
 20097fc:	9005883a 	mov	r2,r18
 2009800:	dfc00917 	ldw	ra,36(sp)
 2009804:	df000817 	ldw	fp,32(sp)
 2009808:	ddc00717 	ldw	r23,28(sp)
 200980c:	dd800617 	ldw	r22,24(sp)
 2009810:	dd400517 	ldw	r21,20(sp)
 2009814:	dd000417 	ldw	r20,16(sp)
 2009818:	dcc00317 	ldw	r19,12(sp)
 200981c:	dc800217 	ldw	r18,8(sp)
 2009820:	dc400117 	ldw	r17,4(sp)
 2009824:	dc000017 	ldw	r16,0(sp)
 2009828:	dec00a04 	addi	sp,sp,40
 200982c:	f800283a 	ret
 2009830:	017fff04 	movi	r5,-4
 2009834:	414a703a 	and	r5,r8,r5
 2009838:	814d883a 	add	r6,r16,r5
 200983c:	30c01f16 	blt	r6,r3,20098bc <_realloc_r+0x22c>
 2009840:	20800317 	ldw	r2,12(r4)
 2009844:	20c00217 	ldw	r3,8(r4)
 2009848:	a825883a 	mov	r18,r21
 200984c:	3021883a 	mov	r16,r6
 2009850:	18800315 	stw	r2,12(r3)
 2009854:	10c00215 	stw	r3,8(r2)
 2009858:	003fdb06 	br	20097c8 <__alt_mem_mem_0+0xfcfe97c8>
 200985c:	00800304 	movi	r2,12
 2009860:	a0800015 	stw	r2,0(r20)
 2009864:	0005883a 	mov	r2,zero
 2009868:	003fe506 	br	2009800 <__alt_mem_mem_0+0xfcfe9800>
 200986c:	98c00117 	ldw	r3,4(r19)
 2009870:	9c4b883a 	add	r5,r19,r17
 2009874:	11000054 	ori	r4,r2,1
 2009878:	18c0004c 	andi	r3,r3,1
 200987c:	1c62b03a 	or	r17,r3,r17
 2009880:	9c400115 	stw	r17,4(r19)
 2009884:	29000115 	stw	r4,4(r5)
 2009888:	2885883a 	add	r2,r5,r2
 200988c:	10c00117 	ldw	r3,4(r2)
 2009890:	29400204 	addi	r5,r5,8
 2009894:	a009883a 	mov	r4,r20
 2009898:	18c00054 	ori	r3,r3,1
 200989c:	10c00115 	stw	r3,4(r2)
 20098a0:	2004e380 	call	2004e38 <_free_r>
 20098a4:	003fd306 	br	20097f4 <__alt_mem_mem_0+0xfcfe97f4>
 20098a8:	017fff04 	movi	r5,-4
 20098ac:	414a703a 	and	r5,r8,r5
 20098b0:	89800404 	addi	r6,r17,16
 20098b4:	8151883a 	add	r8,r16,r5
 20098b8:	4180590e 	bge	r8,r6,2009a20 <_realloc_r+0x390>
 20098bc:	1080004c 	andi	r2,r2,1
 20098c0:	103f9e1e 	bne	r2,zero,200973c <__alt_mem_mem_0+0xfcfe973c>
 20098c4:	adbffe17 	ldw	r22,-8(r21)
 20098c8:	00bfff04 	movi	r2,-4
 20098cc:	9dadc83a 	sub	r22,r19,r22
 20098d0:	b1800117 	ldw	r6,4(r22)
 20098d4:	3084703a 	and	r2,r6,r2
 20098d8:	20002026 	beq	r4,zero,200995c <_realloc_r+0x2cc>
 20098dc:	80af883a 	add	r23,r16,r2
 20098e0:	b96f883a 	add	r23,r23,r5
 20098e4:	21c05f26 	beq	r4,r7,2009a64 <_realloc_r+0x3d4>
 20098e8:	b8c01c16 	blt	r23,r3,200995c <_realloc_r+0x2cc>
 20098ec:	20800317 	ldw	r2,12(r4)
 20098f0:	20c00217 	ldw	r3,8(r4)
 20098f4:	81bfff04 	addi	r6,r16,-4
 20098f8:	01000904 	movi	r4,36
 20098fc:	18800315 	stw	r2,12(r3)
 2009900:	10c00215 	stw	r3,8(r2)
 2009904:	b0c00217 	ldw	r3,8(r22)
 2009908:	b0800317 	ldw	r2,12(r22)
 200990c:	b4800204 	addi	r18,r22,8
 2009910:	18800315 	stw	r2,12(r3)
 2009914:	10c00215 	stw	r3,8(r2)
 2009918:	21801b36 	bltu	r4,r6,2009988 <_realloc_r+0x2f8>
 200991c:	008004c4 	movi	r2,19
 2009920:	1180352e 	bgeu	r2,r6,20099f8 <_realloc_r+0x368>
 2009924:	a8800017 	ldw	r2,0(r21)
 2009928:	b0800215 	stw	r2,8(r22)
 200992c:	a8800117 	ldw	r2,4(r21)
 2009930:	b0800315 	stw	r2,12(r22)
 2009934:	008006c4 	movi	r2,27
 2009938:	11807f36 	bltu	r2,r6,2009b38 <_realloc_r+0x4a8>
 200993c:	b0800404 	addi	r2,r22,16
 2009940:	ad400204 	addi	r21,r21,8
 2009944:	00002d06 	br	20099fc <_realloc_r+0x36c>
 2009948:	adbffe17 	ldw	r22,-8(r21)
 200994c:	00bfff04 	movi	r2,-4
 2009950:	9dadc83a 	sub	r22,r19,r22
 2009954:	b1000117 	ldw	r4,4(r22)
 2009958:	2084703a 	and	r2,r4,r2
 200995c:	b03f7726 	beq	r22,zero,200973c <__alt_mem_mem_0+0xfcfe973c>
 2009960:	80af883a 	add	r23,r16,r2
 2009964:	b8ff7516 	blt	r23,r3,200973c <__alt_mem_mem_0+0xfcfe973c>
 2009968:	b0800317 	ldw	r2,12(r22)
 200996c:	b0c00217 	ldw	r3,8(r22)
 2009970:	81bfff04 	addi	r6,r16,-4
 2009974:	01000904 	movi	r4,36
 2009978:	18800315 	stw	r2,12(r3)
 200997c:	10c00215 	stw	r3,8(r2)
 2009980:	b4800204 	addi	r18,r22,8
 2009984:	21bfe52e 	bgeu	r4,r6,200991c <__alt_mem_mem_0+0xfcfe991c>
 2009988:	a80b883a 	mov	r5,r21
 200998c:	9009883a 	mov	r4,r18
 2009990:	20094d40 	call	20094d4 <memmove>
 2009994:	b821883a 	mov	r16,r23
 2009998:	b027883a 	mov	r19,r22
 200999c:	003f8a06 	br	20097c8 <__alt_mem_mem_0+0xfcfe97c8>
 20099a0:	300b883a 	mov	r5,r6
 20099a4:	dfc00917 	ldw	ra,36(sp)
 20099a8:	df000817 	ldw	fp,32(sp)
 20099ac:	ddc00717 	ldw	r23,28(sp)
 20099b0:	dd800617 	ldw	r22,24(sp)
 20099b4:	dd400517 	ldw	r21,20(sp)
 20099b8:	dd000417 	ldw	r20,16(sp)
 20099bc:	dcc00317 	ldw	r19,12(sp)
 20099c0:	dc800217 	ldw	r18,8(sp)
 20099c4:	dc400117 	ldw	r17,4(sp)
 20099c8:	dc000017 	ldw	r16,0(sp)
 20099cc:	dec00a04 	addi	sp,sp,40
 20099d0:	20055681 	jmpi	2005568 <_malloc_r>
 20099d4:	a8c00017 	ldw	r3,0(r21)
 20099d8:	90c00015 	stw	r3,0(r18)
 20099dc:	a8c00117 	ldw	r3,4(r21)
 20099e0:	90c00115 	stw	r3,4(r18)
 20099e4:	00c006c4 	movi	r3,27
 20099e8:	19804536 	bltu	r3,r6,2009b00 <_realloc_r+0x470>
 20099ec:	90800204 	addi	r2,r18,8
 20099f0:	a8c00204 	addi	r3,r21,8
 20099f4:	003f6306 	br	2009784 <__alt_mem_mem_0+0xfcfe9784>
 20099f8:	9005883a 	mov	r2,r18
 20099fc:	a8c00017 	ldw	r3,0(r21)
 2009a00:	b821883a 	mov	r16,r23
 2009a04:	b027883a 	mov	r19,r22
 2009a08:	10c00015 	stw	r3,0(r2)
 2009a0c:	a8c00117 	ldw	r3,4(r21)
 2009a10:	10c00115 	stw	r3,4(r2)
 2009a14:	a8c00217 	ldw	r3,8(r21)
 2009a18:	10c00215 	stw	r3,8(r2)
 2009a1c:	003f6a06 	br	20097c8 <__alt_mem_mem_0+0xfcfe97c8>
 2009a20:	9c67883a 	add	r19,r19,r17
 2009a24:	4445c83a 	sub	r2,r8,r17
 2009a28:	e4c00215 	stw	r19,8(fp)
 2009a2c:	10800054 	ori	r2,r2,1
 2009a30:	98800115 	stw	r2,4(r19)
 2009a34:	a8bfff17 	ldw	r2,-4(r21)
 2009a38:	a009883a 	mov	r4,r20
 2009a3c:	1080004c 	andi	r2,r2,1
 2009a40:	1462b03a 	or	r17,r2,r17
 2009a44:	ac7fff15 	stw	r17,-4(r21)
 2009a48:	200d3780 	call	200d378 <__malloc_unlock>
 2009a4c:	a805883a 	mov	r2,r21
 2009a50:	003f6b06 	br	2009800 <__alt_mem_mem_0+0xfcfe9800>
 2009a54:	a80b883a 	mov	r5,r21
 2009a58:	9009883a 	mov	r4,r18
 2009a5c:	20094d40 	call	20094d4 <memmove>
 2009a60:	003f4e06 	br	200979c <__alt_mem_mem_0+0xfcfe979c>
 2009a64:	89000404 	addi	r4,r17,16
 2009a68:	b93fbc16 	blt	r23,r4,200995c <__alt_mem_mem_0+0xfcfe995c>
 2009a6c:	b0800317 	ldw	r2,12(r22)
 2009a70:	b0c00217 	ldw	r3,8(r22)
 2009a74:	81bfff04 	addi	r6,r16,-4
 2009a78:	01000904 	movi	r4,36
 2009a7c:	18800315 	stw	r2,12(r3)
 2009a80:	10c00215 	stw	r3,8(r2)
 2009a84:	b4800204 	addi	r18,r22,8
 2009a88:	21804336 	bltu	r4,r6,2009b98 <_realloc_r+0x508>
 2009a8c:	008004c4 	movi	r2,19
 2009a90:	11803f2e 	bgeu	r2,r6,2009b90 <_realloc_r+0x500>
 2009a94:	a8800017 	ldw	r2,0(r21)
 2009a98:	b0800215 	stw	r2,8(r22)
 2009a9c:	a8800117 	ldw	r2,4(r21)
 2009aa0:	b0800315 	stw	r2,12(r22)
 2009aa4:	008006c4 	movi	r2,27
 2009aa8:	11803f36 	bltu	r2,r6,2009ba8 <_realloc_r+0x518>
 2009aac:	b0800404 	addi	r2,r22,16
 2009ab0:	ad400204 	addi	r21,r21,8
 2009ab4:	a8c00017 	ldw	r3,0(r21)
 2009ab8:	10c00015 	stw	r3,0(r2)
 2009abc:	a8c00117 	ldw	r3,4(r21)
 2009ac0:	10c00115 	stw	r3,4(r2)
 2009ac4:	a8c00217 	ldw	r3,8(r21)
 2009ac8:	10c00215 	stw	r3,8(r2)
 2009acc:	b447883a 	add	r3,r22,r17
 2009ad0:	bc45c83a 	sub	r2,r23,r17
 2009ad4:	e0c00215 	stw	r3,8(fp)
 2009ad8:	10800054 	ori	r2,r2,1
 2009adc:	18800115 	stw	r2,4(r3)
 2009ae0:	b0800117 	ldw	r2,4(r22)
 2009ae4:	a009883a 	mov	r4,r20
 2009ae8:	1080004c 	andi	r2,r2,1
 2009aec:	1462b03a 	or	r17,r2,r17
 2009af0:	b4400115 	stw	r17,4(r22)
 2009af4:	200d3780 	call	200d378 <__malloc_unlock>
 2009af8:	9005883a 	mov	r2,r18
 2009afc:	003f4006 	br	2009800 <__alt_mem_mem_0+0xfcfe9800>
 2009b00:	a8c00217 	ldw	r3,8(r21)
 2009b04:	90c00215 	stw	r3,8(r18)
 2009b08:	a8c00317 	ldw	r3,12(r21)
 2009b0c:	90c00315 	stw	r3,12(r18)
 2009b10:	30801126 	beq	r6,r2,2009b58 <_realloc_r+0x4c8>
 2009b14:	90800404 	addi	r2,r18,16
 2009b18:	a8c00404 	addi	r3,r21,16
 2009b1c:	003f1906 	br	2009784 <__alt_mem_mem_0+0xfcfe9784>
 2009b20:	90ffff17 	ldw	r3,-4(r18)
 2009b24:	00bfff04 	movi	r2,-4
 2009b28:	a825883a 	mov	r18,r21
 2009b2c:	1884703a 	and	r2,r3,r2
 2009b30:	80a1883a 	add	r16,r16,r2
 2009b34:	003f2406 	br	20097c8 <__alt_mem_mem_0+0xfcfe97c8>
 2009b38:	a8800217 	ldw	r2,8(r21)
 2009b3c:	b0800415 	stw	r2,16(r22)
 2009b40:	a8800317 	ldw	r2,12(r21)
 2009b44:	b0800515 	stw	r2,20(r22)
 2009b48:	31000a26 	beq	r6,r4,2009b74 <_realloc_r+0x4e4>
 2009b4c:	b0800604 	addi	r2,r22,24
 2009b50:	ad400404 	addi	r21,r21,16
 2009b54:	003fa906 	br	20099fc <__alt_mem_mem_0+0xfcfe99fc>
 2009b58:	a9000417 	ldw	r4,16(r21)
 2009b5c:	90800604 	addi	r2,r18,24
 2009b60:	a8c00604 	addi	r3,r21,24
 2009b64:	91000415 	stw	r4,16(r18)
 2009b68:	a9000517 	ldw	r4,20(r21)
 2009b6c:	91000515 	stw	r4,20(r18)
 2009b70:	003f0406 	br	2009784 <__alt_mem_mem_0+0xfcfe9784>
 2009b74:	a8c00417 	ldw	r3,16(r21)
 2009b78:	ad400604 	addi	r21,r21,24
 2009b7c:	b0800804 	addi	r2,r22,32
 2009b80:	b0c00615 	stw	r3,24(r22)
 2009b84:	a8ffff17 	ldw	r3,-4(r21)
 2009b88:	b0c00715 	stw	r3,28(r22)
 2009b8c:	003f9b06 	br	20099fc <__alt_mem_mem_0+0xfcfe99fc>
 2009b90:	9005883a 	mov	r2,r18
 2009b94:	003fc706 	br	2009ab4 <__alt_mem_mem_0+0xfcfe9ab4>
 2009b98:	a80b883a 	mov	r5,r21
 2009b9c:	9009883a 	mov	r4,r18
 2009ba0:	20094d40 	call	20094d4 <memmove>
 2009ba4:	003fc906 	br	2009acc <__alt_mem_mem_0+0xfcfe9acc>
 2009ba8:	a8800217 	ldw	r2,8(r21)
 2009bac:	b0800415 	stw	r2,16(r22)
 2009bb0:	a8800317 	ldw	r2,12(r21)
 2009bb4:	b0800515 	stw	r2,20(r22)
 2009bb8:	31000726 	beq	r6,r4,2009bd8 <_realloc_r+0x548>
 2009bbc:	b0800604 	addi	r2,r22,24
 2009bc0:	ad400404 	addi	r21,r21,16
 2009bc4:	003fbb06 	br	2009ab4 <__alt_mem_mem_0+0xfcfe9ab4>
 2009bc8:	a009883a 	mov	r4,r20
 2009bcc:	200d3780 	call	200d378 <__malloc_unlock>
 2009bd0:	0005883a 	mov	r2,zero
 2009bd4:	003f0a06 	br	2009800 <__alt_mem_mem_0+0xfcfe9800>
 2009bd8:	a8c00417 	ldw	r3,16(r21)
 2009bdc:	ad400604 	addi	r21,r21,24
 2009be0:	b0800804 	addi	r2,r22,32
 2009be4:	b0c00615 	stw	r3,24(r22)
 2009be8:	a8ffff17 	ldw	r3,-4(r21)
 2009bec:	b0c00715 	stw	r3,28(r22)
 2009bf0:	003fb006 	br	2009ab4 <__alt_mem_mem_0+0xfcfe9ab4>

02009bf4 <__swbuf_r>:
 2009bf4:	defffb04 	addi	sp,sp,-20
 2009bf8:	dcc00315 	stw	r19,12(sp)
 2009bfc:	dc800215 	stw	r18,8(sp)
 2009c00:	dc000015 	stw	r16,0(sp)
 2009c04:	dfc00415 	stw	ra,16(sp)
 2009c08:	dc400115 	stw	r17,4(sp)
 2009c0c:	2025883a 	mov	r18,r4
 2009c10:	2827883a 	mov	r19,r5
 2009c14:	3021883a 	mov	r16,r6
 2009c18:	20000226 	beq	r4,zero,2009c24 <__swbuf_r+0x30>
 2009c1c:	20800e17 	ldw	r2,56(r4)
 2009c20:	10004226 	beq	r2,zero,2009d2c <__swbuf_r+0x138>
 2009c24:	80800617 	ldw	r2,24(r16)
 2009c28:	8100030b 	ldhu	r4,12(r16)
 2009c2c:	80800215 	stw	r2,8(r16)
 2009c30:	2080020c 	andi	r2,r4,8
 2009c34:	10003626 	beq	r2,zero,2009d10 <__swbuf_r+0x11c>
 2009c38:	80c00417 	ldw	r3,16(r16)
 2009c3c:	18003426 	beq	r3,zero,2009d10 <__swbuf_r+0x11c>
 2009c40:	2088000c 	andi	r2,r4,8192
 2009c44:	9c403fcc 	andi	r17,r19,255
 2009c48:	10001a26 	beq	r2,zero,2009cb4 <__swbuf_r+0xc0>
 2009c4c:	80800017 	ldw	r2,0(r16)
 2009c50:	81000517 	ldw	r4,20(r16)
 2009c54:	10c7c83a 	sub	r3,r2,r3
 2009c58:	1900200e 	bge	r3,r4,2009cdc <__swbuf_r+0xe8>
 2009c5c:	18c00044 	addi	r3,r3,1
 2009c60:	81000217 	ldw	r4,8(r16)
 2009c64:	11400044 	addi	r5,r2,1
 2009c68:	81400015 	stw	r5,0(r16)
 2009c6c:	213fffc4 	addi	r4,r4,-1
 2009c70:	81000215 	stw	r4,8(r16)
 2009c74:	14c00005 	stb	r19,0(r2)
 2009c78:	80800517 	ldw	r2,20(r16)
 2009c7c:	10c01e26 	beq	r2,r3,2009cf8 <__swbuf_r+0x104>
 2009c80:	8080030b 	ldhu	r2,12(r16)
 2009c84:	1080004c 	andi	r2,r2,1
 2009c88:	10000226 	beq	r2,zero,2009c94 <__swbuf_r+0xa0>
 2009c8c:	00800284 	movi	r2,10
 2009c90:	88801926 	beq	r17,r2,2009cf8 <__swbuf_r+0x104>
 2009c94:	8805883a 	mov	r2,r17
 2009c98:	dfc00417 	ldw	ra,16(sp)
 2009c9c:	dcc00317 	ldw	r19,12(sp)
 2009ca0:	dc800217 	ldw	r18,8(sp)
 2009ca4:	dc400117 	ldw	r17,4(sp)
 2009ca8:	dc000017 	ldw	r16,0(sp)
 2009cac:	dec00504 	addi	sp,sp,20
 2009cb0:	f800283a 	ret
 2009cb4:	81401917 	ldw	r5,100(r16)
 2009cb8:	00b7ffc4 	movi	r2,-8193
 2009cbc:	21080014 	ori	r4,r4,8192
 2009cc0:	2884703a 	and	r2,r5,r2
 2009cc4:	80801915 	stw	r2,100(r16)
 2009cc8:	80800017 	ldw	r2,0(r16)
 2009ccc:	8100030d 	sth	r4,12(r16)
 2009cd0:	81000517 	ldw	r4,20(r16)
 2009cd4:	10c7c83a 	sub	r3,r2,r3
 2009cd8:	193fe016 	blt	r3,r4,2009c5c <__alt_mem_mem_0+0xfcfe9c5c>
 2009cdc:	800b883a 	mov	r5,r16
 2009ce0:	9009883a 	mov	r4,r18
 2009ce4:	20048e80 	call	20048e8 <_fflush_r>
 2009ce8:	1000071e 	bne	r2,zero,2009d08 <__swbuf_r+0x114>
 2009cec:	80800017 	ldw	r2,0(r16)
 2009cf0:	00c00044 	movi	r3,1
 2009cf4:	003fda06 	br	2009c60 <__alt_mem_mem_0+0xfcfe9c60>
 2009cf8:	800b883a 	mov	r5,r16
 2009cfc:	9009883a 	mov	r4,r18
 2009d00:	20048e80 	call	20048e8 <_fflush_r>
 2009d04:	103fe326 	beq	r2,zero,2009c94 <__alt_mem_mem_0+0xfcfe9c94>
 2009d08:	00bfffc4 	movi	r2,-1
 2009d0c:	003fe206 	br	2009c98 <__alt_mem_mem_0+0xfcfe9c98>
 2009d10:	800b883a 	mov	r5,r16
 2009d14:	9009883a 	mov	r4,r18
 2009d18:	2002cf00 	call	2002cf0 <__swsetup_r>
 2009d1c:	103ffa1e 	bne	r2,zero,2009d08 <__alt_mem_mem_0+0xfcfe9d08>
 2009d20:	8100030b 	ldhu	r4,12(r16)
 2009d24:	80c00417 	ldw	r3,16(r16)
 2009d28:	003fc506 	br	2009c40 <__alt_mem_mem_0+0xfcfe9c40>
 2009d2c:	2004cc40 	call	2004cc4 <__sinit>
 2009d30:	003fbc06 	br	2009c24 <__alt_mem_mem_0+0xfcfe9c24>

02009d34 <__swbuf>:
 2009d34:	00808174 	movhi	r2,517
 2009d38:	10ab4004 	addi	r2,r2,-21248
 2009d3c:	280d883a 	mov	r6,r5
 2009d40:	200b883a 	mov	r5,r4
 2009d44:	11000017 	ldw	r4,0(r2)
 2009d48:	2009bf41 	jmpi	2009bf4 <__swbuf_r>

02009d4c <_wcrtomb_r>:
 2009d4c:	defff604 	addi	sp,sp,-40
 2009d50:	00808174 	movhi	r2,517
 2009d54:	dc800815 	stw	r18,32(sp)
 2009d58:	dc400715 	stw	r17,28(sp)
 2009d5c:	dc000615 	stw	r16,24(sp)
 2009d60:	10ab4404 	addi	r2,r2,-21232
 2009d64:	dfc00915 	stw	ra,36(sp)
 2009d68:	2021883a 	mov	r16,r4
 2009d6c:	3823883a 	mov	r17,r7
 2009d70:	14800017 	ldw	r18,0(r2)
 2009d74:	28001426 	beq	r5,zero,2009dc8 <_wcrtomb_r+0x7c>
 2009d78:	d9400415 	stw	r5,16(sp)
 2009d7c:	d9800515 	stw	r6,20(sp)
 2009d80:	200534c0 	call	200534c <__locale_charset>
 2009d84:	d9800517 	ldw	r6,20(sp)
 2009d88:	d9400417 	ldw	r5,16(sp)
 2009d8c:	100f883a 	mov	r7,r2
 2009d90:	dc400015 	stw	r17,0(sp)
 2009d94:	8009883a 	mov	r4,r16
 2009d98:	903ee83a 	callr	r18
 2009d9c:	00ffffc4 	movi	r3,-1
 2009da0:	10c0031e 	bne	r2,r3,2009db0 <_wcrtomb_r+0x64>
 2009da4:	88000015 	stw	zero,0(r17)
 2009da8:	00c02284 	movi	r3,138
 2009dac:	80c00015 	stw	r3,0(r16)
 2009db0:	dfc00917 	ldw	ra,36(sp)
 2009db4:	dc800817 	ldw	r18,32(sp)
 2009db8:	dc400717 	ldw	r17,28(sp)
 2009dbc:	dc000617 	ldw	r16,24(sp)
 2009dc0:	dec00a04 	addi	sp,sp,40
 2009dc4:	f800283a 	ret
 2009dc8:	200534c0 	call	200534c <__locale_charset>
 2009dcc:	100f883a 	mov	r7,r2
 2009dd0:	dc400015 	stw	r17,0(sp)
 2009dd4:	000d883a 	mov	r6,zero
 2009dd8:	d9400104 	addi	r5,sp,4
 2009ddc:	8009883a 	mov	r4,r16
 2009de0:	903ee83a 	callr	r18
 2009de4:	003fed06 	br	2009d9c <__alt_mem_mem_0+0xfcfe9d9c>

02009de8 <wcrtomb>:
 2009de8:	defff604 	addi	sp,sp,-40
 2009dec:	00808174 	movhi	r2,517
 2009df0:	dc800615 	stw	r18,24(sp)
 2009df4:	dc400515 	stw	r17,20(sp)
 2009df8:	10ab4004 	addi	r2,r2,-21248
 2009dfc:	dfc00915 	stw	ra,36(sp)
 2009e00:	dd000815 	stw	r20,32(sp)
 2009e04:	dcc00715 	stw	r19,28(sp)
 2009e08:	dc000415 	stw	r16,16(sp)
 2009e0c:	3025883a 	mov	r18,r6
 2009e10:	14400017 	ldw	r17,0(r2)
 2009e14:	20001926 	beq	r4,zero,2009e7c <wcrtomb+0x94>
 2009e18:	00808174 	movhi	r2,517
 2009e1c:	10ab4404 	addi	r2,r2,-21232
 2009e20:	15000017 	ldw	r20,0(r2)
 2009e24:	2021883a 	mov	r16,r4
 2009e28:	2827883a 	mov	r19,r5
 2009e2c:	200534c0 	call	200534c <__locale_charset>
 2009e30:	100f883a 	mov	r7,r2
 2009e34:	dc800015 	stw	r18,0(sp)
 2009e38:	980d883a 	mov	r6,r19
 2009e3c:	800b883a 	mov	r5,r16
 2009e40:	8809883a 	mov	r4,r17
 2009e44:	a03ee83a 	callr	r20
 2009e48:	00ffffc4 	movi	r3,-1
 2009e4c:	10c0031e 	bne	r2,r3,2009e5c <wcrtomb+0x74>
 2009e50:	90000015 	stw	zero,0(r18)
 2009e54:	00c02284 	movi	r3,138
 2009e58:	88c00015 	stw	r3,0(r17)
 2009e5c:	dfc00917 	ldw	ra,36(sp)
 2009e60:	dd000817 	ldw	r20,32(sp)
 2009e64:	dcc00717 	ldw	r19,28(sp)
 2009e68:	dc800617 	ldw	r18,24(sp)
 2009e6c:	dc400517 	ldw	r17,20(sp)
 2009e70:	dc000417 	ldw	r16,16(sp)
 2009e74:	dec00a04 	addi	sp,sp,40
 2009e78:	f800283a 	ret
 2009e7c:	00808174 	movhi	r2,517
 2009e80:	10ab4404 	addi	r2,r2,-21232
 2009e84:	14000017 	ldw	r16,0(r2)
 2009e88:	200534c0 	call	200534c <__locale_charset>
 2009e8c:	100f883a 	mov	r7,r2
 2009e90:	dc800015 	stw	r18,0(sp)
 2009e94:	000d883a 	mov	r6,zero
 2009e98:	d9400104 	addi	r5,sp,4
 2009e9c:	8809883a 	mov	r4,r17
 2009ea0:	803ee83a 	callr	r16
 2009ea4:	003fe806 	br	2009e48 <__alt_mem_mem_0+0xfcfe9e48>

02009ea8 <__ascii_wctomb>:
 2009ea8:	28000526 	beq	r5,zero,2009ec0 <__ascii_wctomb+0x18>
 2009eac:	00803fc4 	movi	r2,255
 2009eb0:	11800536 	bltu	r2,r6,2009ec8 <__ascii_wctomb+0x20>
 2009eb4:	29800005 	stb	r6,0(r5)
 2009eb8:	00800044 	movi	r2,1
 2009ebc:	f800283a 	ret
 2009ec0:	0005883a 	mov	r2,zero
 2009ec4:	f800283a 	ret
 2009ec8:	00802284 	movi	r2,138
 2009ecc:	20800015 	stw	r2,0(r4)
 2009ed0:	00bfffc4 	movi	r2,-1
 2009ed4:	f800283a 	ret

02009ed8 <_wctomb_r>:
 2009ed8:	00808174 	movhi	r2,517
 2009edc:	defff904 	addi	sp,sp,-28
 2009ee0:	10ab4404 	addi	r2,r2,-21232
 2009ee4:	dfc00615 	stw	ra,24(sp)
 2009ee8:	dc400515 	stw	r17,20(sp)
 2009eec:	dc000415 	stw	r16,16(sp)
 2009ef0:	3823883a 	mov	r17,r7
 2009ef4:	14000017 	ldw	r16,0(r2)
 2009ef8:	d9000115 	stw	r4,4(sp)
 2009efc:	d9400215 	stw	r5,8(sp)
 2009f00:	d9800315 	stw	r6,12(sp)
 2009f04:	200534c0 	call	200534c <__locale_charset>
 2009f08:	d9800317 	ldw	r6,12(sp)
 2009f0c:	d9400217 	ldw	r5,8(sp)
 2009f10:	d9000117 	ldw	r4,4(sp)
 2009f14:	100f883a 	mov	r7,r2
 2009f18:	dc400015 	stw	r17,0(sp)
 2009f1c:	803ee83a 	callr	r16
 2009f20:	dfc00617 	ldw	ra,24(sp)
 2009f24:	dc400517 	ldw	r17,20(sp)
 2009f28:	dc000417 	ldw	r16,16(sp)
 2009f2c:	dec00704 	addi	sp,sp,28
 2009f30:	f800283a 	ret

02009f34 <__udivdi3>:
 2009f34:	defff504 	addi	sp,sp,-44
 2009f38:	dcc00415 	stw	r19,16(sp)
 2009f3c:	dc000115 	stw	r16,4(sp)
 2009f40:	dfc00a15 	stw	ra,40(sp)
 2009f44:	df000915 	stw	fp,36(sp)
 2009f48:	ddc00815 	stw	r23,32(sp)
 2009f4c:	dd800715 	stw	r22,28(sp)
 2009f50:	dd400615 	stw	r21,24(sp)
 2009f54:	dd000515 	stw	r20,20(sp)
 2009f58:	dc800315 	stw	r18,12(sp)
 2009f5c:	dc400215 	stw	r17,8(sp)
 2009f60:	2027883a 	mov	r19,r4
 2009f64:	2821883a 	mov	r16,r5
 2009f68:	3800411e 	bne	r7,zero,200a070 <__udivdi3+0x13c>
 2009f6c:	3023883a 	mov	r17,r6
 2009f70:	2025883a 	mov	r18,r4
 2009f74:	2980522e 	bgeu	r5,r6,200a0c0 <__udivdi3+0x18c>
 2009f78:	00bfffd4 	movui	r2,65535
 2009f7c:	282d883a 	mov	r22,r5
 2009f80:	1180a836 	bltu	r2,r6,200a224 <__udivdi3+0x2f0>
 2009f84:	00803fc4 	movi	r2,255
 2009f88:	1185803a 	cmpltu	r2,r2,r6
 2009f8c:	100490fa 	slli	r2,r2,3
 2009f90:	3086d83a 	srl	r3,r6,r2
 2009f94:	01008134 	movhi	r4,516
 2009f98:	211aee04 	addi	r4,r4,27576
 2009f9c:	20c7883a 	add	r3,r4,r3
 2009fa0:	18c00003 	ldbu	r3,0(r3)
 2009fa4:	1885883a 	add	r2,r3,r2
 2009fa8:	00c00804 	movi	r3,32
 2009fac:	1887c83a 	sub	r3,r3,r2
 2009fb0:	18000526 	beq	r3,zero,2009fc8 <__udivdi3+0x94>
 2009fb4:	80e0983a 	sll	r16,r16,r3
 2009fb8:	9884d83a 	srl	r2,r19,r2
 2009fbc:	30e2983a 	sll	r17,r6,r3
 2009fc0:	98e4983a 	sll	r18,r19,r3
 2009fc4:	142cb03a 	or	r22,r2,r16
 2009fc8:	882ad43a 	srli	r21,r17,16
 2009fcc:	b009883a 	mov	r4,r22
 2009fd0:	8d3fffcc 	andi	r20,r17,65535
 2009fd4:	a80b883a 	mov	r5,r21
 2009fd8:	200ab400 	call	200ab40 <__umodsi3>
 2009fdc:	b009883a 	mov	r4,r22
 2009fe0:	a80b883a 	mov	r5,r21
 2009fe4:	1027883a 	mov	r19,r2
 2009fe8:	200aadc0 	call	200aadc <__udivsi3>
 2009fec:	102d883a 	mov	r22,r2
 2009ff0:	9826943a 	slli	r19,r19,16
 2009ff4:	9004d43a 	srli	r2,r18,16
 2009ff8:	a5a1383a 	mul	r16,r20,r22
 2009ffc:	14c4b03a 	or	r2,r2,r19
 200a000:	1400052e 	bgeu	r2,r16,200a018 <__udivdi3+0xe4>
 200a004:	1445883a 	add	r2,r2,r17
 200a008:	b0ffffc4 	addi	r3,r22,-1
 200a00c:	14400136 	bltu	r2,r17,200a014 <__udivdi3+0xe0>
 200a010:	14012336 	bltu	r2,r16,200a4a0 <__udivdi3+0x56c>
 200a014:	182d883a 	mov	r22,r3
 200a018:	1421c83a 	sub	r16,r2,r16
 200a01c:	a80b883a 	mov	r5,r21
 200a020:	8009883a 	mov	r4,r16
 200a024:	200ab400 	call	200ab40 <__umodsi3>
 200a028:	1027883a 	mov	r19,r2
 200a02c:	a80b883a 	mov	r5,r21
 200a030:	8009883a 	mov	r4,r16
 200a034:	200aadc0 	call	200aadc <__udivsi3>
 200a038:	9826943a 	slli	r19,r19,16
 200a03c:	a0a9383a 	mul	r20,r20,r2
 200a040:	94bfffcc 	andi	r18,r18,65535
 200a044:	94e4b03a 	or	r18,r18,r19
 200a048:	9500052e 	bgeu	r18,r20,200a060 <__udivdi3+0x12c>
 200a04c:	8ca5883a 	add	r18,r17,r18
 200a050:	10ffffc4 	addi	r3,r2,-1
 200a054:	9440f136 	bltu	r18,r17,200a41c <__udivdi3+0x4e8>
 200a058:	9500f02e 	bgeu	r18,r20,200a41c <__udivdi3+0x4e8>
 200a05c:	10bfff84 	addi	r2,r2,-2
 200a060:	b00c943a 	slli	r6,r22,16
 200a064:	0007883a 	mov	r3,zero
 200a068:	3084b03a 	or	r2,r6,r2
 200a06c:	00005906 	br	200a1d4 <__udivdi3+0x2a0>
 200a070:	29c05636 	bltu	r5,r7,200a1cc <__udivdi3+0x298>
 200a074:	00bfffd4 	movui	r2,65535
 200a078:	11c0622e 	bgeu	r2,r7,200a204 <__udivdi3+0x2d0>
 200a07c:	00804034 	movhi	r2,256
 200a080:	10bfffc4 	addi	r2,r2,-1
 200a084:	11c0ee36 	bltu	r2,r7,200a440 <__udivdi3+0x50c>
 200a088:	00800404 	movi	r2,16
 200a08c:	3886d83a 	srl	r3,r7,r2
 200a090:	01008134 	movhi	r4,516
 200a094:	211aee04 	addi	r4,r4,27576
 200a098:	20c7883a 	add	r3,r4,r3
 200a09c:	18c00003 	ldbu	r3,0(r3)
 200a0a0:	05400804 	movi	r21,32
 200a0a4:	1885883a 	add	r2,r3,r2
 200a0a8:	a8abc83a 	sub	r21,r21,r2
 200a0ac:	a800621e 	bne	r21,zero,200a238 <__udivdi3+0x304>
 200a0b0:	3c00e936 	bltu	r7,r16,200a458 <__udivdi3+0x524>
 200a0b4:	9985403a 	cmpgeu	r2,r19,r6
 200a0b8:	0007883a 	mov	r3,zero
 200a0bc:	00004506 	br	200a1d4 <__udivdi3+0x2a0>
 200a0c0:	3000041e 	bne	r6,zero,200a0d4 <__udivdi3+0x1a0>
 200a0c4:	000b883a 	mov	r5,zero
 200a0c8:	01000044 	movi	r4,1
 200a0cc:	200aadc0 	call	200aadc <__udivsi3>
 200a0d0:	1023883a 	mov	r17,r2
 200a0d4:	00bfffd4 	movui	r2,65535
 200a0d8:	14404e2e 	bgeu	r2,r17,200a214 <__udivdi3+0x2e0>
 200a0dc:	00804034 	movhi	r2,256
 200a0e0:	10bfffc4 	addi	r2,r2,-1
 200a0e4:	1440d836 	bltu	r2,r17,200a448 <__udivdi3+0x514>
 200a0e8:	00800404 	movi	r2,16
 200a0ec:	8886d83a 	srl	r3,r17,r2
 200a0f0:	01008134 	movhi	r4,516
 200a0f4:	211aee04 	addi	r4,r4,27576
 200a0f8:	20c7883a 	add	r3,r4,r3
 200a0fc:	18c00003 	ldbu	r3,0(r3)
 200a100:	1885883a 	add	r2,r3,r2
 200a104:	00c00804 	movi	r3,32
 200a108:	1887c83a 	sub	r3,r3,r2
 200a10c:	18008f1e 	bne	r3,zero,200a34c <__udivdi3+0x418>
 200a110:	882ad43a 	srli	r21,r17,16
 200a114:	8461c83a 	sub	r16,r16,r17
 200a118:	8d3fffcc 	andi	r20,r17,65535
 200a11c:	00c00044 	movi	r3,1
 200a120:	8009883a 	mov	r4,r16
 200a124:	a80b883a 	mov	r5,r21
 200a128:	d8c00015 	stw	r3,0(sp)
 200a12c:	200ab400 	call	200ab40 <__umodsi3>
 200a130:	8009883a 	mov	r4,r16
 200a134:	a80b883a 	mov	r5,r21
 200a138:	1027883a 	mov	r19,r2
 200a13c:	200aadc0 	call	200aadc <__udivsi3>
 200a140:	9826943a 	slli	r19,r19,16
 200a144:	9008d43a 	srli	r4,r18,16
 200a148:	1521383a 	mul	r16,r2,r20
 200a14c:	102d883a 	mov	r22,r2
 200a150:	24c8b03a 	or	r4,r4,r19
 200a154:	d8c00017 	ldw	r3,0(sp)
 200a158:	2400052e 	bgeu	r4,r16,200a170 <__udivdi3+0x23c>
 200a15c:	2449883a 	add	r4,r4,r17
 200a160:	b0bfffc4 	addi	r2,r22,-1
 200a164:	24400136 	bltu	r4,r17,200a16c <__udivdi3+0x238>
 200a168:	2400ca36 	bltu	r4,r16,200a494 <__udivdi3+0x560>
 200a16c:	102d883a 	mov	r22,r2
 200a170:	2421c83a 	sub	r16,r4,r16
 200a174:	a80b883a 	mov	r5,r21
 200a178:	8009883a 	mov	r4,r16
 200a17c:	d8c00015 	stw	r3,0(sp)
 200a180:	200ab400 	call	200ab40 <__umodsi3>
 200a184:	1027883a 	mov	r19,r2
 200a188:	a80b883a 	mov	r5,r21
 200a18c:	8009883a 	mov	r4,r16
 200a190:	200aadc0 	call	200aadc <__udivsi3>
 200a194:	9826943a 	slli	r19,r19,16
 200a198:	1529383a 	mul	r20,r2,r20
 200a19c:	94bfffcc 	andi	r18,r18,65535
 200a1a0:	94e4b03a 	or	r18,r18,r19
 200a1a4:	d8c00017 	ldw	r3,0(sp)
 200a1a8:	9500052e 	bgeu	r18,r20,200a1c0 <__udivdi3+0x28c>
 200a1ac:	8ca5883a 	add	r18,r17,r18
 200a1b0:	113fffc4 	addi	r4,r2,-1
 200a1b4:	94409736 	bltu	r18,r17,200a414 <__udivdi3+0x4e0>
 200a1b8:	9500962e 	bgeu	r18,r20,200a414 <__udivdi3+0x4e0>
 200a1bc:	10bfff84 	addi	r2,r2,-2
 200a1c0:	b00c943a 	slli	r6,r22,16
 200a1c4:	3084b03a 	or	r2,r6,r2
 200a1c8:	00000206 	br	200a1d4 <__udivdi3+0x2a0>
 200a1cc:	0007883a 	mov	r3,zero
 200a1d0:	0005883a 	mov	r2,zero
 200a1d4:	dfc00a17 	ldw	ra,40(sp)
 200a1d8:	df000917 	ldw	fp,36(sp)
 200a1dc:	ddc00817 	ldw	r23,32(sp)
 200a1e0:	dd800717 	ldw	r22,28(sp)
 200a1e4:	dd400617 	ldw	r21,24(sp)
 200a1e8:	dd000517 	ldw	r20,20(sp)
 200a1ec:	dcc00417 	ldw	r19,16(sp)
 200a1f0:	dc800317 	ldw	r18,12(sp)
 200a1f4:	dc400217 	ldw	r17,8(sp)
 200a1f8:	dc000117 	ldw	r16,4(sp)
 200a1fc:	dec00b04 	addi	sp,sp,44
 200a200:	f800283a 	ret
 200a204:	00803fc4 	movi	r2,255
 200a208:	11c5803a 	cmpltu	r2,r2,r7
 200a20c:	100490fa 	slli	r2,r2,3
 200a210:	003f9e06 	br	200a08c <__alt_mem_mem_0+0xfcfea08c>
 200a214:	00803fc4 	movi	r2,255
 200a218:	1445803a 	cmpltu	r2,r2,r17
 200a21c:	100490fa 	slli	r2,r2,3
 200a220:	003fb206 	br	200a0ec <__alt_mem_mem_0+0xfcfea0ec>
 200a224:	00804034 	movhi	r2,256
 200a228:	10bfffc4 	addi	r2,r2,-1
 200a22c:	11808836 	bltu	r2,r6,200a450 <__udivdi3+0x51c>
 200a230:	00800404 	movi	r2,16
 200a234:	003f5606 	br	2009f90 <__alt_mem_mem_0+0xfcfe9f90>
 200a238:	30aed83a 	srl	r23,r6,r2
 200a23c:	3d4e983a 	sll	r7,r7,r21
 200a240:	80acd83a 	srl	r22,r16,r2
 200a244:	9884d83a 	srl	r2,r19,r2
 200a248:	3deeb03a 	or	r23,r7,r23
 200a24c:	b824d43a 	srli	r18,r23,16
 200a250:	8560983a 	sll	r16,r16,r21
 200a254:	b009883a 	mov	r4,r22
 200a258:	900b883a 	mov	r5,r18
 200a25c:	3568983a 	sll	r20,r6,r21
 200a260:	1420b03a 	or	r16,r2,r16
 200a264:	200ab400 	call	200ab40 <__umodsi3>
 200a268:	b009883a 	mov	r4,r22
 200a26c:	900b883a 	mov	r5,r18
 200a270:	1023883a 	mov	r17,r2
 200a274:	200aadc0 	call	200aadc <__udivsi3>
 200a278:	8808943a 	slli	r4,r17,16
 200a27c:	bf3fffcc 	andi	fp,r23,65535
 200a280:	8006d43a 	srli	r3,r16,16
 200a284:	e0a3383a 	mul	r17,fp,r2
 200a288:	100d883a 	mov	r6,r2
 200a28c:	1906b03a 	or	r3,r3,r4
 200a290:	1c40042e 	bgeu	r3,r17,200a2a4 <__udivdi3+0x370>
 200a294:	1dc7883a 	add	r3,r3,r23
 200a298:	10bfffc4 	addi	r2,r2,-1
 200a29c:	1dc0752e 	bgeu	r3,r23,200a474 <__udivdi3+0x540>
 200a2a0:	100d883a 	mov	r6,r2
 200a2a4:	1c63c83a 	sub	r17,r3,r17
 200a2a8:	900b883a 	mov	r5,r18
 200a2ac:	8809883a 	mov	r4,r17
 200a2b0:	d9800015 	stw	r6,0(sp)
 200a2b4:	200ab400 	call	200ab40 <__umodsi3>
 200a2b8:	102d883a 	mov	r22,r2
 200a2bc:	8809883a 	mov	r4,r17
 200a2c0:	900b883a 	mov	r5,r18
 200a2c4:	200aadc0 	call	200aadc <__udivsi3>
 200a2c8:	b02c943a 	slli	r22,r22,16
 200a2cc:	e089383a 	mul	r4,fp,r2
 200a2d0:	843fffcc 	andi	r16,r16,65535
 200a2d4:	85a0b03a 	or	r16,r16,r22
 200a2d8:	d9800017 	ldw	r6,0(sp)
 200a2dc:	8100042e 	bgeu	r16,r4,200a2f0 <__udivdi3+0x3bc>
 200a2e0:	85e1883a 	add	r16,r16,r23
 200a2e4:	10ffffc4 	addi	r3,r2,-1
 200a2e8:	85c05e2e 	bgeu	r16,r23,200a464 <__udivdi3+0x530>
 200a2ec:	1805883a 	mov	r2,r3
 200a2f0:	300c943a 	slli	r6,r6,16
 200a2f4:	a17fffcc 	andi	r5,r20,65535
 200a2f8:	a028d43a 	srli	r20,r20,16
 200a2fc:	3084b03a 	or	r2,r6,r2
 200a300:	10ffffcc 	andi	r3,r2,65535
 200a304:	100cd43a 	srli	r6,r2,16
 200a308:	194f383a 	mul	r7,r3,r5
 200a30c:	1d07383a 	mul	r3,r3,r20
 200a310:	314b383a 	mul	r5,r6,r5
 200a314:	3810d43a 	srli	r8,r7,16
 200a318:	8121c83a 	sub	r16,r16,r4
 200a31c:	1947883a 	add	r3,r3,r5
 200a320:	40c7883a 	add	r3,r8,r3
 200a324:	350d383a 	mul	r6,r6,r20
 200a328:	1940022e 	bgeu	r3,r5,200a334 <__udivdi3+0x400>
 200a32c:	01000074 	movhi	r4,1
 200a330:	310d883a 	add	r6,r6,r4
 200a334:	1828d43a 	srli	r20,r3,16
 200a338:	a18d883a 	add	r6,r20,r6
 200a33c:	81803e36 	bltu	r16,r6,200a438 <__udivdi3+0x504>
 200a340:	81803826 	beq	r16,r6,200a424 <__udivdi3+0x4f0>
 200a344:	0007883a 	mov	r3,zero
 200a348:	003fa206 	br	200a1d4 <__alt_mem_mem_0+0xfcfea1d4>
 200a34c:	88e2983a 	sll	r17,r17,r3
 200a350:	80a8d83a 	srl	r20,r16,r2
 200a354:	80e0983a 	sll	r16,r16,r3
 200a358:	882ad43a 	srli	r21,r17,16
 200a35c:	9884d83a 	srl	r2,r19,r2
 200a360:	a009883a 	mov	r4,r20
 200a364:	a80b883a 	mov	r5,r21
 200a368:	142eb03a 	or	r23,r2,r16
 200a36c:	98e4983a 	sll	r18,r19,r3
 200a370:	200ab400 	call	200ab40 <__umodsi3>
 200a374:	a009883a 	mov	r4,r20
 200a378:	a80b883a 	mov	r5,r21
 200a37c:	1021883a 	mov	r16,r2
 200a380:	200aadc0 	call	200aadc <__udivsi3>
 200a384:	1039883a 	mov	fp,r2
 200a388:	8d3fffcc 	andi	r20,r17,65535
 200a38c:	8020943a 	slli	r16,r16,16
 200a390:	b804d43a 	srli	r2,r23,16
 200a394:	a72d383a 	mul	r22,r20,fp
 200a398:	1404b03a 	or	r2,r2,r16
 200a39c:	1580062e 	bgeu	r2,r22,200a3b8 <__udivdi3+0x484>
 200a3a0:	1445883a 	add	r2,r2,r17
 200a3a4:	e0ffffc4 	addi	r3,fp,-1
 200a3a8:	14403836 	bltu	r2,r17,200a48c <__udivdi3+0x558>
 200a3ac:	1580372e 	bgeu	r2,r22,200a48c <__udivdi3+0x558>
 200a3b0:	e73fff84 	addi	fp,fp,-2
 200a3b4:	1445883a 	add	r2,r2,r17
 200a3b8:	15adc83a 	sub	r22,r2,r22
 200a3bc:	a80b883a 	mov	r5,r21
 200a3c0:	b009883a 	mov	r4,r22
 200a3c4:	200ab400 	call	200ab40 <__umodsi3>
 200a3c8:	1027883a 	mov	r19,r2
 200a3cc:	b009883a 	mov	r4,r22
 200a3d0:	a80b883a 	mov	r5,r21
 200a3d4:	200aadc0 	call	200aadc <__udivsi3>
 200a3d8:	9826943a 	slli	r19,r19,16
 200a3dc:	a0a1383a 	mul	r16,r20,r2
 200a3e0:	b93fffcc 	andi	r4,r23,65535
 200a3e4:	24c8b03a 	or	r4,r4,r19
 200a3e8:	2400062e 	bgeu	r4,r16,200a404 <__udivdi3+0x4d0>
 200a3ec:	2449883a 	add	r4,r4,r17
 200a3f0:	10ffffc4 	addi	r3,r2,-1
 200a3f4:	24402336 	bltu	r4,r17,200a484 <__udivdi3+0x550>
 200a3f8:	2400222e 	bgeu	r4,r16,200a484 <__udivdi3+0x550>
 200a3fc:	10bfff84 	addi	r2,r2,-2
 200a400:	2449883a 	add	r4,r4,r17
 200a404:	e038943a 	slli	fp,fp,16
 200a408:	2421c83a 	sub	r16,r4,r16
 200a40c:	e086b03a 	or	r3,fp,r2
 200a410:	003f4306 	br	200a120 <__alt_mem_mem_0+0xfcfea120>
 200a414:	2005883a 	mov	r2,r4
 200a418:	003f6906 	br	200a1c0 <__alt_mem_mem_0+0xfcfea1c0>
 200a41c:	1805883a 	mov	r2,r3
 200a420:	003f0f06 	br	200a060 <__alt_mem_mem_0+0xfcfea060>
 200a424:	1806943a 	slli	r3,r3,16
 200a428:	9d66983a 	sll	r19,r19,r21
 200a42c:	39ffffcc 	andi	r7,r7,65535
 200a430:	19c7883a 	add	r3,r3,r7
 200a434:	98ffc32e 	bgeu	r19,r3,200a344 <__alt_mem_mem_0+0xfcfea344>
 200a438:	10bfffc4 	addi	r2,r2,-1
 200a43c:	003fc106 	br	200a344 <__alt_mem_mem_0+0xfcfea344>
 200a440:	00800604 	movi	r2,24
 200a444:	003f1106 	br	200a08c <__alt_mem_mem_0+0xfcfea08c>
 200a448:	00800604 	movi	r2,24
 200a44c:	003f2706 	br	200a0ec <__alt_mem_mem_0+0xfcfea0ec>
 200a450:	00800604 	movi	r2,24
 200a454:	003ece06 	br	2009f90 <__alt_mem_mem_0+0xfcfe9f90>
 200a458:	0007883a 	mov	r3,zero
 200a45c:	00800044 	movi	r2,1
 200a460:	003f5c06 	br	200a1d4 <__alt_mem_mem_0+0xfcfea1d4>
 200a464:	813fa12e 	bgeu	r16,r4,200a2ec <__alt_mem_mem_0+0xfcfea2ec>
 200a468:	10bfff84 	addi	r2,r2,-2
 200a46c:	85e1883a 	add	r16,r16,r23
 200a470:	003f9f06 	br	200a2f0 <__alt_mem_mem_0+0xfcfea2f0>
 200a474:	1c7f8a2e 	bgeu	r3,r17,200a2a0 <__alt_mem_mem_0+0xfcfea2a0>
 200a478:	31bfff84 	addi	r6,r6,-2
 200a47c:	1dc7883a 	add	r3,r3,r23
 200a480:	003f8806 	br	200a2a4 <__alt_mem_mem_0+0xfcfea2a4>
 200a484:	1805883a 	mov	r2,r3
 200a488:	003fde06 	br	200a404 <__alt_mem_mem_0+0xfcfea404>
 200a48c:	1839883a 	mov	fp,r3
 200a490:	003fc906 	br	200a3b8 <__alt_mem_mem_0+0xfcfea3b8>
 200a494:	b5bfff84 	addi	r22,r22,-2
 200a498:	2449883a 	add	r4,r4,r17
 200a49c:	003f3406 	br	200a170 <__alt_mem_mem_0+0xfcfea170>
 200a4a0:	b5bfff84 	addi	r22,r22,-2
 200a4a4:	1445883a 	add	r2,r2,r17
 200a4a8:	003edb06 	br	200a018 <__alt_mem_mem_0+0xfcfea018>

0200a4ac <__umoddi3>:
 200a4ac:	defff404 	addi	sp,sp,-48
 200a4b0:	df000a15 	stw	fp,40(sp)
 200a4b4:	dc400315 	stw	r17,12(sp)
 200a4b8:	dc000215 	stw	r16,8(sp)
 200a4bc:	dfc00b15 	stw	ra,44(sp)
 200a4c0:	ddc00915 	stw	r23,36(sp)
 200a4c4:	dd800815 	stw	r22,32(sp)
 200a4c8:	dd400715 	stw	r21,28(sp)
 200a4cc:	dd000615 	stw	r20,24(sp)
 200a4d0:	dcc00515 	stw	r19,20(sp)
 200a4d4:	dc800415 	stw	r18,16(sp)
 200a4d8:	2021883a 	mov	r16,r4
 200a4dc:	2823883a 	mov	r17,r5
 200a4e0:	2839883a 	mov	fp,r5
 200a4e4:	38003c1e 	bne	r7,zero,200a5d8 <__umoddi3+0x12c>
 200a4e8:	3027883a 	mov	r19,r6
 200a4ec:	2029883a 	mov	r20,r4
 200a4f0:	2980512e 	bgeu	r5,r6,200a638 <__umoddi3+0x18c>
 200a4f4:	00bfffd4 	movui	r2,65535
 200a4f8:	11809a36 	bltu	r2,r6,200a764 <__umoddi3+0x2b8>
 200a4fc:	01003fc4 	movi	r4,255
 200a500:	2189803a 	cmpltu	r4,r4,r6
 200a504:	200890fa 	slli	r4,r4,3
 200a508:	3104d83a 	srl	r2,r6,r4
 200a50c:	00c08134 	movhi	r3,516
 200a510:	18daee04 	addi	r3,r3,27576
 200a514:	1885883a 	add	r2,r3,r2
 200a518:	10c00003 	ldbu	r3,0(r2)
 200a51c:	00800804 	movi	r2,32
 200a520:	1909883a 	add	r4,r3,r4
 200a524:	1125c83a 	sub	r18,r2,r4
 200a528:	90000526 	beq	r18,zero,200a540 <__umoddi3+0x94>
 200a52c:	8ca2983a 	sll	r17,r17,r18
 200a530:	8108d83a 	srl	r4,r16,r4
 200a534:	34a6983a 	sll	r19,r6,r18
 200a538:	84a8983a 	sll	r20,r16,r18
 200a53c:	2478b03a 	or	fp,r4,r17
 200a540:	982ed43a 	srli	r23,r19,16
 200a544:	e009883a 	mov	r4,fp
 200a548:	9dbfffcc 	andi	r22,r19,65535
 200a54c:	b80b883a 	mov	r5,r23
 200a550:	200ab400 	call	200ab40 <__umodsi3>
 200a554:	e009883a 	mov	r4,fp
 200a558:	b80b883a 	mov	r5,r23
 200a55c:	102b883a 	mov	r21,r2
 200a560:	200aadc0 	call	200aadc <__udivsi3>
 200a564:	a806943a 	slli	r3,r21,16
 200a568:	a008d43a 	srli	r4,r20,16
 200a56c:	b085383a 	mul	r2,r22,r2
 200a570:	20c8b03a 	or	r4,r4,r3
 200a574:	2080032e 	bgeu	r4,r2,200a584 <__umoddi3+0xd8>
 200a578:	24c9883a 	add	r4,r4,r19
 200a57c:	24c00136 	bltu	r4,r19,200a584 <__umoddi3+0xd8>
 200a580:	20811036 	bltu	r4,r2,200a9c4 <__umoddi3+0x518>
 200a584:	20abc83a 	sub	r21,r4,r2
 200a588:	b80b883a 	mov	r5,r23
 200a58c:	a809883a 	mov	r4,r21
 200a590:	200ab400 	call	200ab40 <__umodsi3>
 200a594:	1023883a 	mov	r17,r2
 200a598:	b80b883a 	mov	r5,r23
 200a59c:	a809883a 	mov	r4,r21
 200a5a0:	200aadc0 	call	200aadc <__udivsi3>
 200a5a4:	8822943a 	slli	r17,r17,16
 200a5a8:	b085383a 	mul	r2,r22,r2
 200a5ac:	a0ffffcc 	andi	r3,r20,65535
 200a5b0:	1c46b03a 	or	r3,r3,r17
 200a5b4:	1880042e 	bgeu	r3,r2,200a5c8 <__umoddi3+0x11c>
 200a5b8:	1cc7883a 	add	r3,r3,r19
 200a5bc:	1cc00236 	bltu	r3,r19,200a5c8 <__umoddi3+0x11c>
 200a5c0:	1880012e 	bgeu	r3,r2,200a5c8 <__umoddi3+0x11c>
 200a5c4:	1cc7883a 	add	r3,r3,r19
 200a5c8:	1885c83a 	sub	r2,r3,r2
 200a5cc:	1484d83a 	srl	r2,r2,r18
 200a5d0:	0007883a 	mov	r3,zero
 200a5d4:	00004f06 	br	200a714 <__umoddi3+0x268>
 200a5d8:	29c04c36 	bltu	r5,r7,200a70c <__umoddi3+0x260>
 200a5dc:	00bfffd4 	movui	r2,65535
 200a5e0:	11c0582e 	bgeu	r2,r7,200a744 <__umoddi3+0x298>
 200a5e4:	00804034 	movhi	r2,256
 200a5e8:	10bfffc4 	addi	r2,r2,-1
 200a5ec:	11c0e736 	bltu	r2,r7,200a98c <__umoddi3+0x4e0>
 200a5f0:	01000404 	movi	r4,16
 200a5f4:	3904d83a 	srl	r2,r7,r4
 200a5f8:	00c08134 	movhi	r3,516
 200a5fc:	18daee04 	addi	r3,r3,27576
 200a600:	1885883a 	add	r2,r3,r2
 200a604:	14c00003 	ldbu	r19,0(r2)
 200a608:	00c00804 	movi	r3,32
 200a60c:	9927883a 	add	r19,r19,r4
 200a610:	1ce9c83a 	sub	r20,r3,r19
 200a614:	a000581e 	bne	r20,zero,200a778 <__umoddi3+0x2cc>
 200a618:	3c400136 	bltu	r7,r17,200a620 <__umoddi3+0x174>
 200a61c:	8180eb36 	bltu	r16,r6,200a9cc <__umoddi3+0x520>
 200a620:	8185c83a 	sub	r2,r16,r6
 200a624:	89e3c83a 	sub	r17,r17,r7
 200a628:	8089803a 	cmpltu	r4,r16,r2
 200a62c:	8939c83a 	sub	fp,r17,r4
 200a630:	e007883a 	mov	r3,fp
 200a634:	00003706 	br	200a714 <__umoddi3+0x268>
 200a638:	3000041e 	bne	r6,zero,200a64c <__umoddi3+0x1a0>
 200a63c:	000b883a 	mov	r5,zero
 200a640:	01000044 	movi	r4,1
 200a644:	200aadc0 	call	200aadc <__udivsi3>
 200a648:	1027883a 	mov	r19,r2
 200a64c:	00bfffd4 	movui	r2,65535
 200a650:	14c0402e 	bgeu	r2,r19,200a754 <__umoddi3+0x2a8>
 200a654:	00804034 	movhi	r2,256
 200a658:	10bfffc4 	addi	r2,r2,-1
 200a65c:	14c0cd36 	bltu	r2,r19,200a994 <__umoddi3+0x4e8>
 200a660:	00800404 	movi	r2,16
 200a664:	9886d83a 	srl	r3,r19,r2
 200a668:	01008134 	movhi	r4,516
 200a66c:	211aee04 	addi	r4,r4,27576
 200a670:	20c7883a 	add	r3,r4,r3
 200a674:	18c00003 	ldbu	r3,0(r3)
 200a678:	1887883a 	add	r3,r3,r2
 200a67c:	00800804 	movi	r2,32
 200a680:	10e5c83a 	sub	r18,r2,r3
 200a684:	9000901e 	bne	r18,zero,200a8c8 <__umoddi3+0x41c>
 200a688:	982cd43a 	srli	r22,r19,16
 200a68c:	8ce3c83a 	sub	r17,r17,r19
 200a690:	9d7fffcc 	andi	r21,r19,65535
 200a694:	b00b883a 	mov	r5,r22
 200a698:	8809883a 	mov	r4,r17
 200a69c:	200ab400 	call	200ab40 <__umodsi3>
 200a6a0:	8809883a 	mov	r4,r17
 200a6a4:	b00b883a 	mov	r5,r22
 200a6a8:	1021883a 	mov	r16,r2
 200a6ac:	200aadc0 	call	200aadc <__udivsi3>
 200a6b0:	8006943a 	slli	r3,r16,16
 200a6b4:	a008d43a 	srli	r4,r20,16
 200a6b8:	1545383a 	mul	r2,r2,r21
 200a6bc:	20c8b03a 	or	r4,r4,r3
 200a6c0:	2080042e 	bgeu	r4,r2,200a6d4 <__umoddi3+0x228>
 200a6c4:	24c9883a 	add	r4,r4,r19
 200a6c8:	24c00236 	bltu	r4,r19,200a6d4 <__umoddi3+0x228>
 200a6cc:	2080012e 	bgeu	r4,r2,200a6d4 <__umoddi3+0x228>
 200a6d0:	24c9883a 	add	r4,r4,r19
 200a6d4:	20a1c83a 	sub	r16,r4,r2
 200a6d8:	b00b883a 	mov	r5,r22
 200a6dc:	8009883a 	mov	r4,r16
 200a6e0:	200ab400 	call	200ab40 <__umodsi3>
 200a6e4:	1023883a 	mov	r17,r2
 200a6e8:	b00b883a 	mov	r5,r22
 200a6ec:	8009883a 	mov	r4,r16
 200a6f0:	200aadc0 	call	200aadc <__udivsi3>
 200a6f4:	8822943a 	slli	r17,r17,16
 200a6f8:	1545383a 	mul	r2,r2,r21
 200a6fc:	a53fffcc 	andi	r20,r20,65535
 200a700:	a446b03a 	or	r3,r20,r17
 200a704:	18bfb02e 	bgeu	r3,r2,200a5c8 <__alt_mem_mem_0+0xfcfea5c8>
 200a708:	003fab06 	br	200a5b8 <__alt_mem_mem_0+0xfcfea5b8>
 200a70c:	2005883a 	mov	r2,r4
 200a710:	2807883a 	mov	r3,r5
 200a714:	dfc00b17 	ldw	ra,44(sp)
 200a718:	df000a17 	ldw	fp,40(sp)
 200a71c:	ddc00917 	ldw	r23,36(sp)
 200a720:	dd800817 	ldw	r22,32(sp)
 200a724:	dd400717 	ldw	r21,28(sp)
 200a728:	dd000617 	ldw	r20,24(sp)
 200a72c:	dcc00517 	ldw	r19,20(sp)
 200a730:	dc800417 	ldw	r18,16(sp)
 200a734:	dc400317 	ldw	r17,12(sp)
 200a738:	dc000217 	ldw	r16,8(sp)
 200a73c:	dec00c04 	addi	sp,sp,48
 200a740:	f800283a 	ret
 200a744:	04c03fc4 	movi	r19,255
 200a748:	99c9803a 	cmpltu	r4,r19,r7
 200a74c:	200890fa 	slli	r4,r4,3
 200a750:	003fa806 	br	200a5f4 <__alt_mem_mem_0+0xfcfea5f4>
 200a754:	00803fc4 	movi	r2,255
 200a758:	14c5803a 	cmpltu	r2,r2,r19
 200a75c:	100490fa 	slli	r2,r2,3
 200a760:	003fc006 	br	200a664 <__alt_mem_mem_0+0xfcfea664>
 200a764:	00804034 	movhi	r2,256
 200a768:	10bfffc4 	addi	r2,r2,-1
 200a76c:	11808b36 	bltu	r2,r6,200a99c <__umoddi3+0x4f0>
 200a770:	01000404 	movi	r4,16
 200a774:	003f6406 	br	200a508 <__alt_mem_mem_0+0xfcfea508>
 200a778:	34c4d83a 	srl	r2,r6,r19
 200a77c:	3d0e983a 	sll	r7,r7,r20
 200a780:	8cf8d83a 	srl	fp,r17,r19
 200a784:	8d10983a 	sll	r8,r17,r20
 200a788:	38aab03a 	or	r21,r7,r2
 200a78c:	a82cd43a 	srli	r22,r21,16
 200a790:	84e2d83a 	srl	r17,r16,r19
 200a794:	e009883a 	mov	r4,fp
 200a798:	b00b883a 	mov	r5,r22
 200a79c:	8a22b03a 	or	r17,r17,r8
 200a7a0:	3524983a 	sll	r18,r6,r20
 200a7a4:	200ab400 	call	200ab40 <__umodsi3>
 200a7a8:	e009883a 	mov	r4,fp
 200a7ac:	b00b883a 	mov	r5,r22
 200a7b0:	102f883a 	mov	r23,r2
 200a7b4:	200aadc0 	call	200aadc <__udivsi3>
 200a7b8:	100d883a 	mov	r6,r2
 200a7bc:	b808943a 	slli	r4,r23,16
 200a7c0:	aa3fffcc 	andi	r8,r21,65535
 200a7c4:	8804d43a 	srli	r2,r17,16
 200a7c8:	41af383a 	mul	r23,r8,r6
 200a7cc:	8520983a 	sll	r16,r16,r20
 200a7d0:	1104b03a 	or	r2,r2,r4
 200a7d4:	15c0042e 	bgeu	r2,r23,200a7e8 <__umoddi3+0x33c>
 200a7d8:	1545883a 	add	r2,r2,r21
 200a7dc:	30ffffc4 	addi	r3,r6,-1
 200a7e0:	1540742e 	bgeu	r2,r21,200a9b4 <__umoddi3+0x508>
 200a7e4:	180d883a 	mov	r6,r3
 200a7e8:	15efc83a 	sub	r23,r2,r23
 200a7ec:	b00b883a 	mov	r5,r22
 200a7f0:	b809883a 	mov	r4,r23
 200a7f4:	d9800115 	stw	r6,4(sp)
 200a7f8:	da000015 	stw	r8,0(sp)
 200a7fc:	200ab400 	call	200ab40 <__umodsi3>
 200a800:	b00b883a 	mov	r5,r22
 200a804:	b809883a 	mov	r4,r23
 200a808:	1039883a 	mov	fp,r2
 200a80c:	200aadc0 	call	200aadc <__udivsi3>
 200a810:	da000017 	ldw	r8,0(sp)
 200a814:	e038943a 	slli	fp,fp,16
 200a818:	100b883a 	mov	r5,r2
 200a81c:	4089383a 	mul	r4,r8,r2
 200a820:	8a3fffcc 	andi	r8,r17,65535
 200a824:	4710b03a 	or	r8,r8,fp
 200a828:	d9800117 	ldw	r6,4(sp)
 200a82c:	4100042e 	bgeu	r8,r4,200a840 <__umoddi3+0x394>
 200a830:	4551883a 	add	r8,r8,r21
 200a834:	10bfffc4 	addi	r2,r2,-1
 200a838:	45405a2e 	bgeu	r8,r21,200a9a4 <__umoddi3+0x4f8>
 200a83c:	100b883a 	mov	r5,r2
 200a840:	300c943a 	slli	r6,r6,16
 200a844:	91ffffcc 	andi	r7,r18,65535
 200a848:	9004d43a 	srli	r2,r18,16
 200a84c:	314cb03a 	or	r6,r6,r5
 200a850:	317fffcc 	andi	r5,r6,65535
 200a854:	300cd43a 	srli	r6,r6,16
 200a858:	29d3383a 	mul	r9,r5,r7
 200a85c:	288b383a 	mul	r5,r5,r2
 200a860:	31cf383a 	mul	r7,r6,r7
 200a864:	4806d43a 	srli	r3,r9,16
 200a868:	4111c83a 	sub	r8,r8,r4
 200a86c:	29cb883a 	add	r5,r5,r7
 200a870:	194b883a 	add	r5,r3,r5
 200a874:	3085383a 	mul	r2,r6,r2
 200a878:	29c0022e 	bgeu	r5,r7,200a884 <__umoddi3+0x3d8>
 200a87c:	00c00074 	movhi	r3,1
 200a880:	10c5883a 	add	r2,r2,r3
 200a884:	2808d43a 	srli	r4,r5,16
 200a888:	280a943a 	slli	r5,r5,16
 200a88c:	4a7fffcc 	andi	r9,r9,65535
 200a890:	2085883a 	add	r2,r4,r2
 200a894:	2a4b883a 	add	r5,r5,r9
 200a898:	40803636 	bltu	r8,r2,200a974 <__umoddi3+0x4c8>
 200a89c:	40804d26 	beq	r8,r2,200a9d4 <__umoddi3+0x528>
 200a8a0:	4089c83a 	sub	r4,r8,r2
 200a8a4:	280f883a 	mov	r7,r5
 200a8a8:	81cfc83a 	sub	r7,r16,r7
 200a8ac:	81c7803a 	cmpltu	r3,r16,r7
 200a8b0:	20c7c83a 	sub	r3,r4,r3
 200a8b4:	1cc4983a 	sll	r2,r3,r19
 200a8b8:	3d0ed83a 	srl	r7,r7,r20
 200a8bc:	1d06d83a 	srl	r3,r3,r20
 200a8c0:	11c4b03a 	or	r2,r2,r7
 200a8c4:	003f9306 	br	200a714 <__alt_mem_mem_0+0xfcfea714>
 200a8c8:	9ca6983a 	sll	r19,r19,r18
 200a8cc:	88e8d83a 	srl	r20,r17,r3
 200a8d0:	80c4d83a 	srl	r2,r16,r3
 200a8d4:	982cd43a 	srli	r22,r19,16
 200a8d8:	8ca2983a 	sll	r17,r17,r18
 200a8dc:	a009883a 	mov	r4,r20
 200a8e0:	b00b883a 	mov	r5,r22
 200a8e4:	1478b03a 	or	fp,r2,r17
 200a8e8:	200ab400 	call	200ab40 <__umodsi3>
 200a8ec:	a009883a 	mov	r4,r20
 200a8f0:	b00b883a 	mov	r5,r22
 200a8f4:	1023883a 	mov	r17,r2
 200a8f8:	200aadc0 	call	200aadc <__udivsi3>
 200a8fc:	9d7fffcc 	andi	r21,r19,65535
 200a900:	880a943a 	slli	r5,r17,16
 200a904:	e008d43a 	srli	r4,fp,16
 200a908:	a885383a 	mul	r2,r21,r2
 200a90c:	84a8983a 	sll	r20,r16,r18
 200a910:	2148b03a 	or	r4,r4,r5
 200a914:	2080042e 	bgeu	r4,r2,200a928 <__umoddi3+0x47c>
 200a918:	24c9883a 	add	r4,r4,r19
 200a91c:	24c00236 	bltu	r4,r19,200a928 <__umoddi3+0x47c>
 200a920:	2080012e 	bgeu	r4,r2,200a928 <__umoddi3+0x47c>
 200a924:	24c9883a 	add	r4,r4,r19
 200a928:	20a3c83a 	sub	r17,r4,r2
 200a92c:	b00b883a 	mov	r5,r22
 200a930:	8809883a 	mov	r4,r17
 200a934:	200ab400 	call	200ab40 <__umodsi3>
 200a938:	102f883a 	mov	r23,r2
 200a93c:	8809883a 	mov	r4,r17
 200a940:	b00b883a 	mov	r5,r22
 200a944:	200aadc0 	call	200aadc <__udivsi3>
 200a948:	b82e943a 	slli	r23,r23,16
 200a94c:	a885383a 	mul	r2,r21,r2
 200a950:	e13fffcc 	andi	r4,fp,65535
 200a954:	25c8b03a 	or	r4,r4,r23
 200a958:	2080042e 	bgeu	r4,r2,200a96c <__umoddi3+0x4c0>
 200a95c:	24c9883a 	add	r4,r4,r19
 200a960:	24c00236 	bltu	r4,r19,200a96c <__umoddi3+0x4c0>
 200a964:	2080012e 	bgeu	r4,r2,200a96c <__umoddi3+0x4c0>
 200a968:	24c9883a 	add	r4,r4,r19
 200a96c:	20a3c83a 	sub	r17,r4,r2
 200a970:	003f4806 	br	200a694 <__alt_mem_mem_0+0xfcfea694>
 200a974:	2c8fc83a 	sub	r7,r5,r18
 200a978:	1545c83a 	sub	r2,r2,r21
 200a97c:	29cb803a 	cmpltu	r5,r5,r7
 200a980:	1145c83a 	sub	r2,r2,r5
 200a984:	4089c83a 	sub	r4,r8,r2
 200a988:	003fc706 	br	200a8a8 <__alt_mem_mem_0+0xfcfea8a8>
 200a98c:	01000604 	movi	r4,24
 200a990:	003f1806 	br	200a5f4 <__alt_mem_mem_0+0xfcfea5f4>
 200a994:	00800604 	movi	r2,24
 200a998:	003f3206 	br	200a664 <__alt_mem_mem_0+0xfcfea664>
 200a99c:	01000604 	movi	r4,24
 200a9a0:	003ed906 	br	200a508 <__alt_mem_mem_0+0xfcfea508>
 200a9a4:	413fa52e 	bgeu	r8,r4,200a83c <__alt_mem_mem_0+0xfcfea83c>
 200a9a8:	297fff84 	addi	r5,r5,-2
 200a9ac:	4551883a 	add	r8,r8,r21
 200a9b0:	003fa306 	br	200a840 <__alt_mem_mem_0+0xfcfea840>
 200a9b4:	15ff8b2e 	bgeu	r2,r23,200a7e4 <__alt_mem_mem_0+0xfcfea7e4>
 200a9b8:	31bfff84 	addi	r6,r6,-2
 200a9bc:	1545883a 	add	r2,r2,r21
 200a9c0:	003f8906 	br	200a7e8 <__alt_mem_mem_0+0xfcfea7e8>
 200a9c4:	24c9883a 	add	r4,r4,r19
 200a9c8:	003eee06 	br	200a584 <__alt_mem_mem_0+0xfcfea584>
 200a9cc:	8005883a 	mov	r2,r16
 200a9d0:	003f1706 	br	200a630 <__alt_mem_mem_0+0xfcfea630>
 200a9d4:	817fe736 	bltu	r16,r5,200a974 <__alt_mem_mem_0+0xfcfea974>
 200a9d8:	280f883a 	mov	r7,r5
 200a9dc:	0009883a 	mov	r4,zero
 200a9e0:	003fb106 	br	200a8a8 <__alt_mem_mem_0+0xfcfea8a8>

0200a9e4 <__divsi3>:
 200a9e4:	20001b16 	blt	r4,zero,200aa54 <__divsi3+0x70>
 200a9e8:	000f883a 	mov	r7,zero
 200a9ec:	28001616 	blt	r5,zero,200aa48 <__divsi3+0x64>
 200a9f0:	200d883a 	mov	r6,r4
 200a9f4:	29001a2e 	bgeu	r5,r4,200aa60 <__divsi3+0x7c>
 200a9f8:	00800804 	movi	r2,32
 200a9fc:	00c00044 	movi	r3,1
 200aa00:	00000106 	br	200aa08 <__divsi3+0x24>
 200aa04:	10000d26 	beq	r2,zero,200aa3c <__divsi3+0x58>
 200aa08:	294b883a 	add	r5,r5,r5
 200aa0c:	10bfffc4 	addi	r2,r2,-1
 200aa10:	18c7883a 	add	r3,r3,r3
 200aa14:	293ffb36 	bltu	r5,r4,200aa04 <__alt_mem_mem_0+0xfcfeaa04>
 200aa18:	0005883a 	mov	r2,zero
 200aa1c:	18000726 	beq	r3,zero,200aa3c <__divsi3+0x58>
 200aa20:	0005883a 	mov	r2,zero
 200aa24:	31400236 	bltu	r6,r5,200aa30 <__divsi3+0x4c>
 200aa28:	314dc83a 	sub	r6,r6,r5
 200aa2c:	10c4b03a 	or	r2,r2,r3
 200aa30:	1806d07a 	srli	r3,r3,1
 200aa34:	280ad07a 	srli	r5,r5,1
 200aa38:	183ffa1e 	bne	r3,zero,200aa24 <__alt_mem_mem_0+0xfcfeaa24>
 200aa3c:	38000126 	beq	r7,zero,200aa44 <__divsi3+0x60>
 200aa40:	0085c83a 	sub	r2,zero,r2
 200aa44:	f800283a 	ret
 200aa48:	014bc83a 	sub	r5,zero,r5
 200aa4c:	39c0005c 	xori	r7,r7,1
 200aa50:	003fe706 	br	200a9f0 <__alt_mem_mem_0+0xfcfea9f0>
 200aa54:	0109c83a 	sub	r4,zero,r4
 200aa58:	01c00044 	movi	r7,1
 200aa5c:	003fe306 	br	200a9ec <__alt_mem_mem_0+0xfcfea9ec>
 200aa60:	00c00044 	movi	r3,1
 200aa64:	003fee06 	br	200aa20 <__alt_mem_mem_0+0xfcfeaa20>

0200aa68 <__modsi3>:
 200aa68:	20001716 	blt	r4,zero,200aac8 <__modsi3+0x60>
 200aa6c:	000f883a 	mov	r7,zero
 200aa70:	2005883a 	mov	r2,r4
 200aa74:	28001216 	blt	r5,zero,200aac0 <__modsi3+0x58>
 200aa78:	2900162e 	bgeu	r5,r4,200aad4 <__modsi3+0x6c>
 200aa7c:	01800804 	movi	r6,32
 200aa80:	00c00044 	movi	r3,1
 200aa84:	00000106 	br	200aa8c <__modsi3+0x24>
 200aa88:	30000a26 	beq	r6,zero,200aab4 <__modsi3+0x4c>
 200aa8c:	294b883a 	add	r5,r5,r5
 200aa90:	31bfffc4 	addi	r6,r6,-1
 200aa94:	18c7883a 	add	r3,r3,r3
 200aa98:	293ffb36 	bltu	r5,r4,200aa88 <__alt_mem_mem_0+0xfcfeaa88>
 200aa9c:	18000526 	beq	r3,zero,200aab4 <__modsi3+0x4c>
 200aaa0:	1806d07a 	srli	r3,r3,1
 200aaa4:	11400136 	bltu	r2,r5,200aaac <__modsi3+0x44>
 200aaa8:	1145c83a 	sub	r2,r2,r5
 200aaac:	280ad07a 	srli	r5,r5,1
 200aab0:	183ffb1e 	bne	r3,zero,200aaa0 <__alt_mem_mem_0+0xfcfeaaa0>
 200aab4:	38000126 	beq	r7,zero,200aabc <__modsi3+0x54>
 200aab8:	0085c83a 	sub	r2,zero,r2
 200aabc:	f800283a 	ret
 200aac0:	014bc83a 	sub	r5,zero,r5
 200aac4:	003fec06 	br	200aa78 <__alt_mem_mem_0+0xfcfeaa78>
 200aac8:	0109c83a 	sub	r4,zero,r4
 200aacc:	01c00044 	movi	r7,1
 200aad0:	003fe706 	br	200aa70 <__alt_mem_mem_0+0xfcfeaa70>
 200aad4:	00c00044 	movi	r3,1
 200aad8:	003ff106 	br	200aaa0 <__alt_mem_mem_0+0xfcfeaaa0>

0200aadc <__udivsi3>:
 200aadc:	200d883a 	mov	r6,r4
 200aae0:	2900152e 	bgeu	r5,r4,200ab38 <__udivsi3+0x5c>
 200aae4:	28001416 	blt	r5,zero,200ab38 <__udivsi3+0x5c>
 200aae8:	00800804 	movi	r2,32
 200aaec:	00c00044 	movi	r3,1
 200aaf0:	00000206 	br	200aafc <__udivsi3+0x20>
 200aaf4:	10000e26 	beq	r2,zero,200ab30 <__udivsi3+0x54>
 200aaf8:	28000516 	blt	r5,zero,200ab10 <__udivsi3+0x34>
 200aafc:	294b883a 	add	r5,r5,r5
 200ab00:	10bfffc4 	addi	r2,r2,-1
 200ab04:	18c7883a 	add	r3,r3,r3
 200ab08:	293ffa36 	bltu	r5,r4,200aaf4 <__alt_mem_mem_0+0xfcfeaaf4>
 200ab0c:	18000826 	beq	r3,zero,200ab30 <__udivsi3+0x54>
 200ab10:	0005883a 	mov	r2,zero
 200ab14:	31400236 	bltu	r6,r5,200ab20 <__udivsi3+0x44>
 200ab18:	314dc83a 	sub	r6,r6,r5
 200ab1c:	10c4b03a 	or	r2,r2,r3
 200ab20:	1806d07a 	srli	r3,r3,1
 200ab24:	280ad07a 	srli	r5,r5,1
 200ab28:	183ffa1e 	bne	r3,zero,200ab14 <__alt_mem_mem_0+0xfcfeab14>
 200ab2c:	f800283a 	ret
 200ab30:	0005883a 	mov	r2,zero
 200ab34:	f800283a 	ret
 200ab38:	00c00044 	movi	r3,1
 200ab3c:	003ff406 	br	200ab10 <__alt_mem_mem_0+0xfcfeab10>

0200ab40 <__umodsi3>:
 200ab40:	2005883a 	mov	r2,r4
 200ab44:	2900122e 	bgeu	r5,r4,200ab90 <__umodsi3+0x50>
 200ab48:	28001116 	blt	r5,zero,200ab90 <__umodsi3+0x50>
 200ab4c:	01800804 	movi	r6,32
 200ab50:	00c00044 	movi	r3,1
 200ab54:	00000206 	br	200ab60 <__umodsi3+0x20>
 200ab58:	30000c26 	beq	r6,zero,200ab8c <__umodsi3+0x4c>
 200ab5c:	28000516 	blt	r5,zero,200ab74 <__umodsi3+0x34>
 200ab60:	294b883a 	add	r5,r5,r5
 200ab64:	31bfffc4 	addi	r6,r6,-1
 200ab68:	18c7883a 	add	r3,r3,r3
 200ab6c:	293ffa36 	bltu	r5,r4,200ab58 <__alt_mem_mem_0+0xfcfeab58>
 200ab70:	18000626 	beq	r3,zero,200ab8c <__umodsi3+0x4c>
 200ab74:	1806d07a 	srli	r3,r3,1
 200ab78:	11400136 	bltu	r2,r5,200ab80 <__umodsi3+0x40>
 200ab7c:	1145c83a 	sub	r2,r2,r5
 200ab80:	280ad07a 	srli	r5,r5,1
 200ab84:	183ffb1e 	bne	r3,zero,200ab74 <__alt_mem_mem_0+0xfcfeab74>
 200ab88:	f800283a 	ret
 200ab8c:	f800283a 	ret
 200ab90:	00c00044 	movi	r3,1
 200ab94:	003ff706 	br	200ab74 <__alt_mem_mem_0+0xfcfeab74>

0200ab98 <__adddf3>:
 200ab98:	02c00434 	movhi	r11,16
 200ab9c:	5affffc4 	addi	r11,r11,-1
 200aba0:	2806d7fa 	srli	r3,r5,31
 200aba4:	2ad4703a 	and	r10,r5,r11
 200aba8:	3ad2703a 	and	r9,r7,r11
 200abac:	3804d53a 	srli	r2,r7,20
 200abb0:	3018d77a 	srli	r12,r6,29
 200abb4:	280ad53a 	srli	r5,r5,20
 200abb8:	501490fa 	slli	r10,r10,3
 200abbc:	2010d77a 	srli	r8,r4,29
 200abc0:	481290fa 	slli	r9,r9,3
 200abc4:	380ed7fa 	srli	r7,r7,31
 200abc8:	defffb04 	addi	sp,sp,-20
 200abcc:	dc800215 	stw	r18,8(sp)
 200abd0:	dc400115 	stw	r17,4(sp)
 200abd4:	dc000015 	stw	r16,0(sp)
 200abd8:	dfc00415 	stw	ra,16(sp)
 200abdc:	dcc00315 	stw	r19,12(sp)
 200abe0:	1c803fcc 	andi	r18,r3,255
 200abe4:	2c01ffcc 	andi	r16,r5,2047
 200abe8:	5210b03a 	or	r8,r10,r8
 200abec:	202290fa 	slli	r17,r4,3
 200abf0:	1081ffcc 	andi	r2,r2,2047
 200abf4:	4b12b03a 	or	r9,r9,r12
 200abf8:	300c90fa 	slli	r6,r6,3
 200abfc:	91c07526 	beq	r18,r7,200add4 <__adddf3+0x23c>
 200ac00:	8087c83a 	sub	r3,r16,r2
 200ac04:	00c0ab0e 	bge	zero,r3,200aeb4 <__adddf3+0x31c>
 200ac08:	10002a1e 	bne	r2,zero,200acb4 <__adddf3+0x11c>
 200ac0c:	4984b03a 	or	r2,r9,r6
 200ac10:	1000961e 	bne	r2,zero,200ae6c <__adddf3+0x2d4>
 200ac14:	888001cc 	andi	r2,r17,7
 200ac18:	10000726 	beq	r2,zero,200ac38 <__adddf3+0xa0>
 200ac1c:	888003cc 	andi	r2,r17,15
 200ac20:	00c00104 	movi	r3,4
 200ac24:	10c00426 	beq	r2,r3,200ac38 <__adddf3+0xa0>
 200ac28:	88c7883a 	add	r3,r17,r3
 200ac2c:	1c63803a 	cmpltu	r17,r3,r17
 200ac30:	4451883a 	add	r8,r8,r17
 200ac34:	1823883a 	mov	r17,r3
 200ac38:	4080202c 	andhi	r2,r8,128
 200ac3c:	10005926 	beq	r2,zero,200ada4 <__adddf3+0x20c>
 200ac40:	84000044 	addi	r16,r16,1
 200ac44:	0081ffc4 	movi	r2,2047
 200ac48:	8080ba26 	beq	r16,r2,200af34 <__adddf3+0x39c>
 200ac4c:	00bfe034 	movhi	r2,65408
 200ac50:	10bfffc4 	addi	r2,r2,-1
 200ac54:	4090703a 	and	r8,r8,r2
 200ac58:	4004977a 	slli	r2,r8,29
 200ac5c:	4010927a 	slli	r8,r8,9
 200ac60:	8822d0fa 	srli	r17,r17,3
 200ac64:	8401ffcc 	andi	r16,r16,2047
 200ac68:	4010d33a 	srli	r8,r8,12
 200ac6c:	9007883a 	mov	r3,r18
 200ac70:	1444b03a 	or	r2,r2,r17
 200ac74:	8401ffcc 	andi	r16,r16,2047
 200ac78:	8020953a 	slli	r16,r16,20
 200ac7c:	18c03fcc 	andi	r3,r3,255
 200ac80:	01000434 	movhi	r4,16
 200ac84:	213fffc4 	addi	r4,r4,-1
 200ac88:	180697fa 	slli	r3,r3,31
 200ac8c:	4110703a 	and	r8,r8,r4
 200ac90:	4410b03a 	or	r8,r8,r16
 200ac94:	40c6b03a 	or	r3,r8,r3
 200ac98:	dfc00417 	ldw	ra,16(sp)
 200ac9c:	dcc00317 	ldw	r19,12(sp)
 200aca0:	dc800217 	ldw	r18,8(sp)
 200aca4:	dc400117 	ldw	r17,4(sp)
 200aca8:	dc000017 	ldw	r16,0(sp)
 200acac:	dec00504 	addi	sp,sp,20
 200acb0:	f800283a 	ret
 200acb4:	0081ffc4 	movi	r2,2047
 200acb8:	80bfd626 	beq	r16,r2,200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200acbc:	4a402034 	orhi	r9,r9,128
 200acc0:	00800e04 	movi	r2,56
 200acc4:	10c09f16 	blt	r2,r3,200af44 <__adddf3+0x3ac>
 200acc8:	008007c4 	movi	r2,31
 200accc:	10c0c216 	blt	r2,r3,200afd8 <__adddf3+0x440>
 200acd0:	00800804 	movi	r2,32
 200acd4:	10c5c83a 	sub	r2,r2,r3
 200acd8:	488a983a 	sll	r5,r9,r2
 200acdc:	30c8d83a 	srl	r4,r6,r3
 200ace0:	3084983a 	sll	r2,r6,r2
 200ace4:	48c6d83a 	srl	r3,r9,r3
 200ace8:	290cb03a 	or	r6,r5,r4
 200acec:	1004c03a 	cmpne	r2,r2,zero
 200acf0:	308cb03a 	or	r6,r6,r2
 200acf4:	898dc83a 	sub	r6,r17,r6
 200acf8:	89a3803a 	cmpltu	r17,r17,r6
 200acfc:	40d1c83a 	sub	r8,r8,r3
 200ad00:	4451c83a 	sub	r8,r8,r17
 200ad04:	3023883a 	mov	r17,r6
 200ad08:	4080202c 	andhi	r2,r8,128
 200ad0c:	10002326 	beq	r2,zero,200ad9c <__adddf3+0x204>
 200ad10:	04c02034 	movhi	r19,128
 200ad14:	9cffffc4 	addi	r19,r19,-1
 200ad18:	44e6703a 	and	r19,r8,r19
 200ad1c:	98007626 	beq	r19,zero,200aef8 <__adddf3+0x360>
 200ad20:	9809883a 	mov	r4,r19
 200ad24:	200d19c0 	call	200d19c <__clzsi2>
 200ad28:	10fffe04 	addi	r3,r2,-8
 200ad2c:	010007c4 	movi	r4,31
 200ad30:	20c07716 	blt	r4,r3,200af10 <__adddf3+0x378>
 200ad34:	00800804 	movi	r2,32
 200ad38:	10c5c83a 	sub	r2,r2,r3
 200ad3c:	8884d83a 	srl	r2,r17,r2
 200ad40:	98d0983a 	sll	r8,r19,r3
 200ad44:	88e2983a 	sll	r17,r17,r3
 200ad48:	1204b03a 	or	r2,r2,r8
 200ad4c:	1c007416 	blt	r3,r16,200af20 <__adddf3+0x388>
 200ad50:	1c21c83a 	sub	r16,r3,r16
 200ad54:	82000044 	addi	r8,r16,1
 200ad58:	00c007c4 	movi	r3,31
 200ad5c:	1a009116 	blt	r3,r8,200afa4 <__adddf3+0x40c>
 200ad60:	00c00804 	movi	r3,32
 200ad64:	1a07c83a 	sub	r3,r3,r8
 200ad68:	8a08d83a 	srl	r4,r17,r8
 200ad6c:	88e2983a 	sll	r17,r17,r3
 200ad70:	10c6983a 	sll	r3,r2,r3
 200ad74:	1210d83a 	srl	r8,r2,r8
 200ad78:	8804c03a 	cmpne	r2,r17,zero
 200ad7c:	1906b03a 	or	r3,r3,r4
 200ad80:	18a2b03a 	or	r17,r3,r2
 200ad84:	0021883a 	mov	r16,zero
 200ad88:	003fa206 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200ad8c:	1890b03a 	or	r8,r3,r2
 200ad90:	40017d26 	beq	r8,zero,200b388 <__adddf3+0x7f0>
 200ad94:	1011883a 	mov	r8,r2
 200ad98:	1823883a 	mov	r17,r3
 200ad9c:	888001cc 	andi	r2,r17,7
 200ada0:	103f9e1e 	bne	r2,zero,200ac1c <__alt_mem_mem_0+0xfcfeac1c>
 200ada4:	4004977a 	slli	r2,r8,29
 200ada8:	8822d0fa 	srli	r17,r17,3
 200adac:	4010d0fa 	srli	r8,r8,3
 200adb0:	9007883a 	mov	r3,r18
 200adb4:	1444b03a 	or	r2,r2,r17
 200adb8:	0101ffc4 	movi	r4,2047
 200adbc:	81002426 	beq	r16,r4,200ae50 <__adddf3+0x2b8>
 200adc0:	8120703a 	and	r16,r16,r4
 200adc4:	01000434 	movhi	r4,16
 200adc8:	213fffc4 	addi	r4,r4,-1
 200adcc:	4110703a 	and	r8,r8,r4
 200add0:	003fa806 	br	200ac74 <__alt_mem_mem_0+0xfcfeac74>
 200add4:	8089c83a 	sub	r4,r16,r2
 200add8:	01005e0e 	bge	zero,r4,200af54 <__adddf3+0x3bc>
 200addc:	10002b26 	beq	r2,zero,200ae8c <__adddf3+0x2f4>
 200ade0:	0081ffc4 	movi	r2,2047
 200ade4:	80bf8b26 	beq	r16,r2,200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200ade8:	4a402034 	orhi	r9,r9,128
 200adec:	00800e04 	movi	r2,56
 200adf0:	1100a40e 	bge	r2,r4,200b084 <__adddf3+0x4ec>
 200adf4:	498cb03a 	or	r6,r9,r6
 200adf8:	300ac03a 	cmpne	r5,r6,zero
 200adfc:	0013883a 	mov	r9,zero
 200ae00:	2c4b883a 	add	r5,r5,r17
 200ae04:	2c63803a 	cmpltu	r17,r5,r17
 200ae08:	4a11883a 	add	r8,r9,r8
 200ae0c:	8a11883a 	add	r8,r17,r8
 200ae10:	2823883a 	mov	r17,r5
 200ae14:	4080202c 	andhi	r2,r8,128
 200ae18:	103fe026 	beq	r2,zero,200ad9c <__alt_mem_mem_0+0xfcfead9c>
 200ae1c:	84000044 	addi	r16,r16,1
 200ae20:	0081ffc4 	movi	r2,2047
 200ae24:	8080d226 	beq	r16,r2,200b170 <__adddf3+0x5d8>
 200ae28:	00bfe034 	movhi	r2,65408
 200ae2c:	10bfffc4 	addi	r2,r2,-1
 200ae30:	4090703a 	and	r8,r8,r2
 200ae34:	880ad07a 	srli	r5,r17,1
 200ae38:	400897fa 	slli	r4,r8,31
 200ae3c:	88c0004c 	andi	r3,r17,1
 200ae40:	28e2b03a 	or	r17,r5,r3
 200ae44:	4010d07a 	srli	r8,r8,1
 200ae48:	2462b03a 	or	r17,r4,r17
 200ae4c:	003f7106 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200ae50:	4088b03a 	or	r4,r8,r2
 200ae54:	20014526 	beq	r4,zero,200b36c <__adddf3+0x7d4>
 200ae58:	01000434 	movhi	r4,16
 200ae5c:	42000234 	orhi	r8,r8,8
 200ae60:	213fffc4 	addi	r4,r4,-1
 200ae64:	4110703a 	and	r8,r8,r4
 200ae68:	003f8206 	br	200ac74 <__alt_mem_mem_0+0xfcfeac74>
 200ae6c:	18ffffc4 	addi	r3,r3,-1
 200ae70:	1800491e 	bne	r3,zero,200af98 <__adddf3+0x400>
 200ae74:	898bc83a 	sub	r5,r17,r6
 200ae78:	8963803a 	cmpltu	r17,r17,r5
 200ae7c:	4251c83a 	sub	r8,r8,r9
 200ae80:	4451c83a 	sub	r8,r8,r17
 200ae84:	2823883a 	mov	r17,r5
 200ae88:	003f9f06 	br	200ad08 <__alt_mem_mem_0+0xfcfead08>
 200ae8c:	4984b03a 	or	r2,r9,r6
 200ae90:	103f6026 	beq	r2,zero,200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200ae94:	213fffc4 	addi	r4,r4,-1
 200ae98:	2000931e 	bne	r4,zero,200b0e8 <__adddf3+0x550>
 200ae9c:	898d883a 	add	r6,r17,r6
 200aea0:	3463803a 	cmpltu	r17,r6,r17
 200aea4:	4251883a 	add	r8,r8,r9
 200aea8:	8a11883a 	add	r8,r17,r8
 200aeac:	3023883a 	mov	r17,r6
 200aeb0:	003fd806 	br	200ae14 <__alt_mem_mem_0+0xfcfeae14>
 200aeb4:	1800541e 	bne	r3,zero,200b008 <__adddf3+0x470>
 200aeb8:	80800044 	addi	r2,r16,1
 200aebc:	1081ffcc 	andi	r2,r2,2047
 200aec0:	00c00044 	movi	r3,1
 200aec4:	1880a00e 	bge	r3,r2,200b148 <__adddf3+0x5b0>
 200aec8:	8989c83a 	sub	r4,r17,r6
 200aecc:	8905803a 	cmpltu	r2,r17,r4
 200aed0:	4267c83a 	sub	r19,r8,r9
 200aed4:	98a7c83a 	sub	r19,r19,r2
 200aed8:	9880202c 	andhi	r2,r19,128
 200aedc:	10006326 	beq	r2,zero,200b06c <__adddf3+0x4d4>
 200aee0:	3463c83a 	sub	r17,r6,r17
 200aee4:	4a07c83a 	sub	r3,r9,r8
 200aee8:	344d803a 	cmpltu	r6,r6,r17
 200aeec:	19a7c83a 	sub	r19,r3,r6
 200aef0:	3825883a 	mov	r18,r7
 200aef4:	983f8a1e 	bne	r19,zero,200ad20 <__alt_mem_mem_0+0xfcfead20>
 200aef8:	8809883a 	mov	r4,r17
 200aefc:	200d19c0 	call	200d19c <__clzsi2>
 200af00:	10800804 	addi	r2,r2,32
 200af04:	10fffe04 	addi	r3,r2,-8
 200af08:	010007c4 	movi	r4,31
 200af0c:	20ff890e 	bge	r4,r3,200ad34 <__alt_mem_mem_0+0xfcfead34>
 200af10:	10bff604 	addi	r2,r2,-40
 200af14:	8884983a 	sll	r2,r17,r2
 200af18:	0023883a 	mov	r17,zero
 200af1c:	1c3f8c0e 	bge	r3,r16,200ad50 <__alt_mem_mem_0+0xfcfead50>
 200af20:	023fe034 	movhi	r8,65408
 200af24:	423fffc4 	addi	r8,r8,-1
 200af28:	80e1c83a 	sub	r16,r16,r3
 200af2c:	1210703a 	and	r8,r2,r8
 200af30:	003f3806 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200af34:	9007883a 	mov	r3,r18
 200af38:	0011883a 	mov	r8,zero
 200af3c:	0005883a 	mov	r2,zero
 200af40:	003f4c06 	br	200ac74 <__alt_mem_mem_0+0xfcfeac74>
 200af44:	498cb03a 	or	r6,r9,r6
 200af48:	300cc03a 	cmpne	r6,r6,zero
 200af4c:	0007883a 	mov	r3,zero
 200af50:	003f6806 	br	200acf4 <__alt_mem_mem_0+0xfcfeacf4>
 200af54:	20009c1e 	bne	r4,zero,200b1c8 <__adddf3+0x630>
 200af58:	80800044 	addi	r2,r16,1
 200af5c:	1141ffcc 	andi	r5,r2,2047
 200af60:	01000044 	movi	r4,1
 200af64:	2140670e 	bge	r4,r5,200b104 <__adddf3+0x56c>
 200af68:	0101ffc4 	movi	r4,2047
 200af6c:	11007f26 	beq	r2,r4,200b16c <__adddf3+0x5d4>
 200af70:	898d883a 	add	r6,r17,r6
 200af74:	4247883a 	add	r3,r8,r9
 200af78:	3451803a 	cmpltu	r8,r6,r17
 200af7c:	40d1883a 	add	r8,r8,r3
 200af80:	402297fa 	slli	r17,r8,31
 200af84:	300cd07a 	srli	r6,r6,1
 200af88:	4010d07a 	srli	r8,r8,1
 200af8c:	1021883a 	mov	r16,r2
 200af90:	89a2b03a 	or	r17,r17,r6
 200af94:	003f1f06 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200af98:	0081ffc4 	movi	r2,2047
 200af9c:	80bf481e 	bne	r16,r2,200acc0 <__alt_mem_mem_0+0xfcfeacc0>
 200afa0:	003f1c06 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200afa4:	843ff844 	addi	r16,r16,-31
 200afa8:	01000804 	movi	r4,32
 200afac:	1406d83a 	srl	r3,r2,r16
 200afb0:	41005026 	beq	r8,r4,200b0f4 <__adddf3+0x55c>
 200afb4:	01001004 	movi	r4,64
 200afb8:	2211c83a 	sub	r8,r4,r8
 200afbc:	1204983a 	sll	r2,r2,r8
 200afc0:	88a2b03a 	or	r17,r17,r2
 200afc4:	8822c03a 	cmpne	r17,r17,zero
 200afc8:	1c62b03a 	or	r17,r3,r17
 200afcc:	0011883a 	mov	r8,zero
 200afd0:	0021883a 	mov	r16,zero
 200afd4:	003f7106 	br	200ad9c <__alt_mem_mem_0+0xfcfead9c>
 200afd8:	193ff804 	addi	r4,r3,-32
 200afdc:	00800804 	movi	r2,32
 200afe0:	4908d83a 	srl	r4,r9,r4
 200afe4:	18804526 	beq	r3,r2,200b0fc <__adddf3+0x564>
 200afe8:	00801004 	movi	r2,64
 200afec:	10c5c83a 	sub	r2,r2,r3
 200aff0:	4886983a 	sll	r3,r9,r2
 200aff4:	198cb03a 	or	r6,r3,r6
 200aff8:	300cc03a 	cmpne	r6,r6,zero
 200affc:	218cb03a 	or	r6,r4,r6
 200b000:	0007883a 	mov	r3,zero
 200b004:	003f3b06 	br	200acf4 <__alt_mem_mem_0+0xfcfeacf4>
 200b008:	80002a26 	beq	r16,zero,200b0b4 <__adddf3+0x51c>
 200b00c:	0101ffc4 	movi	r4,2047
 200b010:	11006826 	beq	r2,r4,200b1b4 <__adddf3+0x61c>
 200b014:	00c7c83a 	sub	r3,zero,r3
 200b018:	42002034 	orhi	r8,r8,128
 200b01c:	01000e04 	movi	r4,56
 200b020:	20c07c16 	blt	r4,r3,200b214 <__adddf3+0x67c>
 200b024:	010007c4 	movi	r4,31
 200b028:	20c0da16 	blt	r4,r3,200b394 <__adddf3+0x7fc>
 200b02c:	01000804 	movi	r4,32
 200b030:	20c9c83a 	sub	r4,r4,r3
 200b034:	4114983a 	sll	r10,r8,r4
 200b038:	88cad83a 	srl	r5,r17,r3
 200b03c:	8908983a 	sll	r4,r17,r4
 200b040:	40c6d83a 	srl	r3,r8,r3
 200b044:	5162b03a 	or	r17,r10,r5
 200b048:	2008c03a 	cmpne	r4,r4,zero
 200b04c:	8922b03a 	or	r17,r17,r4
 200b050:	3463c83a 	sub	r17,r6,r17
 200b054:	48c7c83a 	sub	r3,r9,r3
 200b058:	344d803a 	cmpltu	r6,r6,r17
 200b05c:	1991c83a 	sub	r8,r3,r6
 200b060:	1021883a 	mov	r16,r2
 200b064:	3825883a 	mov	r18,r7
 200b068:	003f2706 	br	200ad08 <__alt_mem_mem_0+0xfcfead08>
 200b06c:	24d0b03a 	or	r8,r4,r19
 200b070:	40001b1e 	bne	r8,zero,200b0e0 <__adddf3+0x548>
 200b074:	0005883a 	mov	r2,zero
 200b078:	0007883a 	mov	r3,zero
 200b07c:	0021883a 	mov	r16,zero
 200b080:	003f4d06 	br	200adb8 <__alt_mem_mem_0+0xfcfeadb8>
 200b084:	008007c4 	movi	r2,31
 200b088:	11003c16 	blt	r2,r4,200b17c <__adddf3+0x5e4>
 200b08c:	00800804 	movi	r2,32
 200b090:	1105c83a 	sub	r2,r2,r4
 200b094:	488e983a 	sll	r7,r9,r2
 200b098:	310ad83a 	srl	r5,r6,r4
 200b09c:	3084983a 	sll	r2,r6,r2
 200b0a0:	4912d83a 	srl	r9,r9,r4
 200b0a4:	394ab03a 	or	r5,r7,r5
 200b0a8:	1004c03a 	cmpne	r2,r2,zero
 200b0ac:	288ab03a 	or	r5,r5,r2
 200b0b0:	003f5306 	br	200ae00 <__alt_mem_mem_0+0xfcfeae00>
 200b0b4:	4448b03a 	or	r4,r8,r17
 200b0b8:	20003e26 	beq	r4,zero,200b1b4 <__adddf3+0x61c>
 200b0bc:	00c6303a 	nor	r3,zero,r3
 200b0c0:	18003a1e 	bne	r3,zero,200b1ac <__adddf3+0x614>
 200b0c4:	3463c83a 	sub	r17,r6,r17
 200b0c8:	4a07c83a 	sub	r3,r9,r8
 200b0cc:	344d803a 	cmpltu	r6,r6,r17
 200b0d0:	1991c83a 	sub	r8,r3,r6
 200b0d4:	1021883a 	mov	r16,r2
 200b0d8:	3825883a 	mov	r18,r7
 200b0dc:	003f0a06 	br	200ad08 <__alt_mem_mem_0+0xfcfead08>
 200b0e0:	2023883a 	mov	r17,r4
 200b0e4:	003f0d06 	br	200ad1c <__alt_mem_mem_0+0xfcfead1c>
 200b0e8:	0081ffc4 	movi	r2,2047
 200b0ec:	80bf3f1e 	bne	r16,r2,200adec <__alt_mem_mem_0+0xfcfeadec>
 200b0f0:	003ec806 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b0f4:	0005883a 	mov	r2,zero
 200b0f8:	003fb106 	br	200afc0 <__alt_mem_mem_0+0xfcfeafc0>
 200b0fc:	0007883a 	mov	r3,zero
 200b100:	003fbc06 	br	200aff4 <__alt_mem_mem_0+0xfcfeaff4>
 200b104:	4444b03a 	or	r2,r8,r17
 200b108:	8000871e 	bne	r16,zero,200b328 <__adddf3+0x790>
 200b10c:	1000ba26 	beq	r2,zero,200b3f8 <__adddf3+0x860>
 200b110:	4984b03a 	or	r2,r9,r6
 200b114:	103ebf26 	beq	r2,zero,200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b118:	8985883a 	add	r2,r17,r6
 200b11c:	4247883a 	add	r3,r8,r9
 200b120:	1451803a 	cmpltu	r8,r2,r17
 200b124:	40d1883a 	add	r8,r8,r3
 200b128:	40c0202c 	andhi	r3,r8,128
 200b12c:	1023883a 	mov	r17,r2
 200b130:	183f1a26 	beq	r3,zero,200ad9c <__alt_mem_mem_0+0xfcfead9c>
 200b134:	00bfe034 	movhi	r2,65408
 200b138:	10bfffc4 	addi	r2,r2,-1
 200b13c:	2021883a 	mov	r16,r4
 200b140:	4090703a 	and	r8,r8,r2
 200b144:	003eb306 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b148:	4444b03a 	or	r2,r8,r17
 200b14c:	8000291e 	bne	r16,zero,200b1f4 <__adddf3+0x65c>
 200b150:	10004b1e 	bne	r2,zero,200b280 <__adddf3+0x6e8>
 200b154:	4990b03a 	or	r8,r9,r6
 200b158:	40008b26 	beq	r8,zero,200b388 <__adddf3+0x7f0>
 200b15c:	4811883a 	mov	r8,r9
 200b160:	3023883a 	mov	r17,r6
 200b164:	3825883a 	mov	r18,r7
 200b168:	003eaa06 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b16c:	1021883a 	mov	r16,r2
 200b170:	0011883a 	mov	r8,zero
 200b174:	0005883a 	mov	r2,zero
 200b178:	003f0f06 	br	200adb8 <__alt_mem_mem_0+0xfcfeadb8>
 200b17c:	217ff804 	addi	r5,r4,-32
 200b180:	00800804 	movi	r2,32
 200b184:	494ad83a 	srl	r5,r9,r5
 200b188:	20807d26 	beq	r4,r2,200b380 <__adddf3+0x7e8>
 200b18c:	00801004 	movi	r2,64
 200b190:	1109c83a 	sub	r4,r2,r4
 200b194:	4912983a 	sll	r9,r9,r4
 200b198:	498cb03a 	or	r6,r9,r6
 200b19c:	300cc03a 	cmpne	r6,r6,zero
 200b1a0:	298ab03a 	or	r5,r5,r6
 200b1a4:	0013883a 	mov	r9,zero
 200b1a8:	003f1506 	br	200ae00 <__alt_mem_mem_0+0xfcfeae00>
 200b1ac:	0101ffc4 	movi	r4,2047
 200b1b0:	113f9a1e 	bne	r2,r4,200b01c <__alt_mem_mem_0+0xfcfeb01c>
 200b1b4:	4811883a 	mov	r8,r9
 200b1b8:	3023883a 	mov	r17,r6
 200b1bc:	1021883a 	mov	r16,r2
 200b1c0:	3825883a 	mov	r18,r7
 200b1c4:	003e9306 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b1c8:	8000161e 	bne	r16,zero,200b224 <__adddf3+0x68c>
 200b1cc:	444ab03a 	or	r5,r8,r17
 200b1d0:	28005126 	beq	r5,zero,200b318 <__adddf3+0x780>
 200b1d4:	0108303a 	nor	r4,zero,r4
 200b1d8:	20004d1e 	bne	r4,zero,200b310 <__adddf3+0x778>
 200b1dc:	89a3883a 	add	r17,r17,r6
 200b1e0:	4253883a 	add	r9,r8,r9
 200b1e4:	898d803a 	cmpltu	r6,r17,r6
 200b1e8:	3251883a 	add	r8,r6,r9
 200b1ec:	1021883a 	mov	r16,r2
 200b1f0:	003f0806 	br	200ae14 <__alt_mem_mem_0+0xfcfeae14>
 200b1f4:	1000301e 	bne	r2,zero,200b2b8 <__adddf3+0x720>
 200b1f8:	4984b03a 	or	r2,r9,r6
 200b1fc:	10007126 	beq	r2,zero,200b3c4 <__adddf3+0x82c>
 200b200:	4811883a 	mov	r8,r9
 200b204:	3023883a 	mov	r17,r6
 200b208:	3825883a 	mov	r18,r7
 200b20c:	0401ffc4 	movi	r16,2047
 200b210:	003e8006 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b214:	4462b03a 	or	r17,r8,r17
 200b218:	8822c03a 	cmpne	r17,r17,zero
 200b21c:	0007883a 	mov	r3,zero
 200b220:	003f8b06 	br	200b050 <__alt_mem_mem_0+0xfcfeb050>
 200b224:	0141ffc4 	movi	r5,2047
 200b228:	11403b26 	beq	r2,r5,200b318 <__adddf3+0x780>
 200b22c:	0109c83a 	sub	r4,zero,r4
 200b230:	42002034 	orhi	r8,r8,128
 200b234:	01400e04 	movi	r5,56
 200b238:	29006716 	blt	r5,r4,200b3d8 <__adddf3+0x840>
 200b23c:	014007c4 	movi	r5,31
 200b240:	29007016 	blt	r5,r4,200b404 <__adddf3+0x86c>
 200b244:	01400804 	movi	r5,32
 200b248:	290bc83a 	sub	r5,r5,r4
 200b24c:	4154983a 	sll	r10,r8,r5
 200b250:	890ed83a 	srl	r7,r17,r4
 200b254:	894a983a 	sll	r5,r17,r5
 200b258:	4108d83a 	srl	r4,r8,r4
 200b25c:	51e2b03a 	or	r17,r10,r7
 200b260:	280ac03a 	cmpne	r5,r5,zero
 200b264:	8962b03a 	or	r17,r17,r5
 200b268:	89a3883a 	add	r17,r17,r6
 200b26c:	2253883a 	add	r9,r4,r9
 200b270:	898d803a 	cmpltu	r6,r17,r6
 200b274:	3251883a 	add	r8,r6,r9
 200b278:	1021883a 	mov	r16,r2
 200b27c:	003ee506 	br	200ae14 <__alt_mem_mem_0+0xfcfeae14>
 200b280:	4984b03a 	or	r2,r9,r6
 200b284:	103e6326 	beq	r2,zero,200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b288:	8987c83a 	sub	r3,r17,r6
 200b28c:	88c9803a 	cmpltu	r4,r17,r3
 200b290:	4245c83a 	sub	r2,r8,r9
 200b294:	1105c83a 	sub	r2,r2,r4
 200b298:	1100202c 	andhi	r4,r2,128
 200b29c:	203ebb26 	beq	r4,zero,200ad8c <__alt_mem_mem_0+0xfcfead8c>
 200b2a0:	3463c83a 	sub	r17,r6,r17
 200b2a4:	4a07c83a 	sub	r3,r9,r8
 200b2a8:	344d803a 	cmpltu	r6,r6,r17
 200b2ac:	1991c83a 	sub	r8,r3,r6
 200b2b0:	3825883a 	mov	r18,r7
 200b2b4:	003e5706 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b2b8:	4984b03a 	or	r2,r9,r6
 200b2bc:	10002e26 	beq	r2,zero,200b378 <__adddf3+0x7e0>
 200b2c0:	4004d0fa 	srli	r2,r8,3
 200b2c4:	8822d0fa 	srli	r17,r17,3
 200b2c8:	4010977a 	slli	r8,r8,29
 200b2cc:	10c0022c 	andhi	r3,r2,8
 200b2d0:	4462b03a 	or	r17,r8,r17
 200b2d4:	18000826 	beq	r3,zero,200b2f8 <__adddf3+0x760>
 200b2d8:	4808d0fa 	srli	r4,r9,3
 200b2dc:	20c0022c 	andhi	r3,r4,8
 200b2e0:	1800051e 	bne	r3,zero,200b2f8 <__adddf3+0x760>
 200b2e4:	300cd0fa 	srli	r6,r6,3
 200b2e8:	4806977a 	slli	r3,r9,29
 200b2ec:	2005883a 	mov	r2,r4
 200b2f0:	3825883a 	mov	r18,r7
 200b2f4:	19a2b03a 	or	r17,r3,r6
 200b2f8:	8810d77a 	srli	r8,r17,29
 200b2fc:	100490fa 	slli	r2,r2,3
 200b300:	882290fa 	slli	r17,r17,3
 200b304:	0401ffc4 	movi	r16,2047
 200b308:	4090b03a 	or	r8,r8,r2
 200b30c:	003e4106 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b310:	0141ffc4 	movi	r5,2047
 200b314:	117fc71e 	bne	r2,r5,200b234 <__alt_mem_mem_0+0xfcfeb234>
 200b318:	4811883a 	mov	r8,r9
 200b31c:	3023883a 	mov	r17,r6
 200b320:	1021883a 	mov	r16,r2
 200b324:	003e3b06 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b328:	10002f26 	beq	r2,zero,200b3e8 <__adddf3+0x850>
 200b32c:	4984b03a 	or	r2,r9,r6
 200b330:	10001126 	beq	r2,zero,200b378 <__adddf3+0x7e0>
 200b334:	4004d0fa 	srli	r2,r8,3
 200b338:	8822d0fa 	srli	r17,r17,3
 200b33c:	4010977a 	slli	r8,r8,29
 200b340:	10c0022c 	andhi	r3,r2,8
 200b344:	4462b03a 	or	r17,r8,r17
 200b348:	183feb26 	beq	r3,zero,200b2f8 <__alt_mem_mem_0+0xfcfeb2f8>
 200b34c:	4808d0fa 	srli	r4,r9,3
 200b350:	20c0022c 	andhi	r3,r4,8
 200b354:	183fe81e 	bne	r3,zero,200b2f8 <__alt_mem_mem_0+0xfcfeb2f8>
 200b358:	300cd0fa 	srli	r6,r6,3
 200b35c:	4806977a 	slli	r3,r9,29
 200b360:	2005883a 	mov	r2,r4
 200b364:	19a2b03a 	or	r17,r3,r6
 200b368:	003fe306 	br	200b2f8 <__alt_mem_mem_0+0xfcfeb2f8>
 200b36c:	0011883a 	mov	r8,zero
 200b370:	0005883a 	mov	r2,zero
 200b374:	003e3f06 	br	200ac74 <__alt_mem_mem_0+0xfcfeac74>
 200b378:	0401ffc4 	movi	r16,2047
 200b37c:	003e2506 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b380:	0013883a 	mov	r9,zero
 200b384:	003f8406 	br	200b198 <__alt_mem_mem_0+0xfcfeb198>
 200b388:	0005883a 	mov	r2,zero
 200b38c:	0007883a 	mov	r3,zero
 200b390:	003e8906 	br	200adb8 <__alt_mem_mem_0+0xfcfeadb8>
 200b394:	197ff804 	addi	r5,r3,-32
 200b398:	01000804 	movi	r4,32
 200b39c:	414ad83a 	srl	r5,r8,r5
 200b3a0:	19002426 	beq	r3,r4,200b434 <__adddf3+0x89c>
 200b3a4:	01001004 	movi	r4,64
 200b3a8:	20c7c83a 	sub	r3,r4,r3
 200b3ac:	40c6983a 	sll	r3,r8,r3
 200b3b0:	1c46b03a 	or	r3,r3,r17
 200b3b4:	1806c03a 	cmpne	r3,r3,zero
 200b3b8:	28e2b03a 	or	r17,r5,r3
 200b3bc:	0007883a 	mov	r3,zero
 200b3c0:	003f2306 	br	200b050 <__alt_mem_mem_0+0xfcfeb050>
 200b3c4:	0007883a 	mov	r3,zero
 200b3c8:	5811883a 	mov	r8,r11
 200b3cc:	00bfffc4 	movi	r2,-1
 200b3d0:	0401ffc4 	movi	r16,2047
 200b3d4:	003e7806 	br	200adb8 <__alt_mem_mem_0+0xfcfeadb8>
 200b3d8:	4462b03a 	or	r17,r8,r17
 200b3dc:	8822c03a 	cmpne	r17,r17,zero
 200b3e0:	0009883a 	mov	r4,zero
 200b3e4:	003fa006 	br	200b268 <__alt_mem_mem_0+0xfcfeb268>
 200b3e8:	4811883a 	mov	r8,r9
 200b3ec:	3023883a 	mov	r17,r6
 200b3f0:	0401ffc4 	movi	r16,2047
 200b3f4:	003e0706 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b3f8:	4811883a 	mov	r8,r9
 200b3fc:	3023883a 	mov	r17,r6
 200b400:	003e0406 	br	200ac14 <__alt_mem_mem_0+0xfcfeac14>
 200b404:	21fff804 	addi	r7,r4,-32
 200b408:	01400804 	movi	r5,32
 200b40c:	41ced83a 	srl	r7,r8,r7
 200b410:	21400a26 	beq	r4,r5,200b43c <__adddf3+0x8a4>
 200b414:	01401004 	movi	r5,64
 200b418:	2909c83a 	sub	r4,r5,r4
 200b41c:	4108983a 	sll	r4,r8,r4
 200b420:	2448b03a 	or	r4,r4,r17
 200b424:	2008c03a 	cmpne	r4,r4,zero
 200b428:	3922b03a 	or	r17,r7,r4
 200b42c:	0009883a 	mov	r4,zero
 200b430:	003f8d06 	br	200b268 <__alt_mem_mem_0+0xfcfeb268>
 200b434:	0007883a 	mov	r3,zero
 200b438:	003fdd06 	br	200b3b0 <__alt_mem_mem_0+0xfcfeb3b0>
 200b43c:	0009883a 	mov	r4,zero
 200b440:	003ff706 	br	200b420 <__alt_mem_mem_0+0xfcfeb420>

0200b444 <__divdf3>:
 200b444:	defff204 	addi	sp,sp,-56
 200b448:	dd400915 	stw	r21,36(sp)
 200b44c:	282ad53a 	srli	r21,r5,20
 200b450:	dd000815 	stw	r20,32(sp)
 200b454:	2828d7fa 	srli	r20,r5,31
 200b458:	dc000415 	stw	r16,16(sp)
 200b45c:	04000434 	movhi	r16,16
 200b460:	df000c15 	stw	fp,48(sp)
 200b464:	843fffc4 	addi	r16,r16,-1
 200b468:	dfc00d15 	stw	ra,52(sp)
 200b46c:	ddc00b15 	stw	r23,44(sp)
 200b470:	dd800a15 	stw	r22,40(sp)
 200b474:	dcc00715 	stw	r19,28(sp)
 200b478:	dc800615 	stw	r18,24(sp)
 200b47c:	dc400515 	stw	r17,20(sp)
 200b480:	ad41ffcc 	andi	r21,r21,2047
 200b484:	2c20703a 	and	r16,r5,r16
 200b488:	a7003fcc 	andi	fp,r20,255
 200b48c:	a8006126 	beq	r21,zero,200b614 <__divdf3+0x1d0>
 200b490:	0081ffc4 	movi	r2,2047
 200b494:	2025883a 	mov	r18,r4
 200b498:	a8803726 	beq	r21,r2,200b578 <__divdf3+0x134>
 200b49c:	80800434 	orhi	r2,r16,16
 200b4a0:	100490fa 	slli	r2,r2,3
 200b4a4:	2020d77a 	srli	r16,r4,29
 200b4a8:	202490fa 	slli	r18,r4,3
 200b4ac:	ad7f0044 	addi	r21,r21,-1023
 200b4b0:	80a0b03a 	or	r16,r16,r2
 200b4b4:	0027883a 	mov	r19,zero
 200b4b8:	0013883a 	mov	r9,zero
 200b4bc:	3804d53a 	srli	r2,r7,20
 200b4c0:	382cd7fa 	srli	r22,r7,31
 200b4c4:	04400434 	movhi	r17,16
 200b4c8:	8c7fffc4 	addi	r17,r17,-1
 200b4cc:	1081ffcc 	andi	r2,r2,2047
 200b4d0:	3011883a 	mov	r8,r6
 200b4d4:	3c62703a 	and	r17,r7,r17
 200b4d8:	b5c03fcc 	andi	r23,r22,255
 200b4dc:	10006c26 	beq	r2,zero,200b690 <__divdf3+0x24c>
 200b4e0:	00c1ffc4 	movi	r3,2047
 200b4e4:	10c06426 	beq	r2,r3,200b678 <__divdf3+0x234>
 200b4e8:	88c00434 	orhi	r3,r17,16
 200b4ec:	180690fa 	slli	r3,r3,3
 200b4f0:	3022d77a 	srli	r17,r6,29
 200b4f4:	301090fa 	slli	r8,r6,3
 200b4f8:	10bf0044 	addi	r2,r2,-1023
 200b4fc:	88e2b03a 	or	r17,r17,r3
 200b500:	000f883a 	mov	r7,zero
 200b504:	a58cf03a 	xor	r6,r20,r22
 200b508:	3cc8b03a 	or	r4,r7,r19
 200b50c:	a8abc83a 	sub	r21,r21,r2
 200b510:	008003c4 	movi	r2,15
 200b514:	3007883a 	mov	r3,r6
 200b518:	34c03fcc 	andi	r19,r6,255
 200b51c:	11009036 	bltu	r2,r4,200b760 <__divdf3+0x31c>
 200b520:	200890ba 	slli	r4,r4,2
 200b524:	00808074 	movhi	r2,513
 200b528:	10ad4e04 	addi	r2,r2,-19144
 200b52c:	2089883a 	add	r4,r4,r2
 200b530:	20800017 	ldw	r2,0(r4)
 200b534:	1000683a 	jmp	r2
 200b538:	0200b760 	cmpeqi	r8,zero,733
 200b53c:	0200b5b0 	cmpltui	r8,zero,726
 200b540:	0200b750 	cmplti	r8,zero,733
 200b544:	0200b5a4 	muli	r8,zero,726
 200b548:	0200b750 	cmplti	r8,zero,733
 200b54c:	0200b724 	muli	r8,zero,732
 200b550:	0200b750 	cmplti	r8,zero,733
 200b554:	0200b5a4 	muli	r8,zero,726
 200b558:	0200b5b0 	cmpltui	r8,zero,726
 200b55c:	0200b5b0 	cmpltui	r8,zero,726
 200b560:	0200b724 	muli	r8,zero,732
 200b564:	0200b5a4 	muli	r8,zero,726
 200b568:	0200b594 	movui	r8,726
 200b56c:	0200b594 	movui	r8,726
 200b570:	0200b594 	movui	r8,726
 200b574:	0200ba44 	movi	r8,745
 200b578:	2404b03a 	or	r2,r4,r16
 200b57c:	1000661e 	bne	r2,zero,200b718 <__divdf3+0x2d4>
 200b580:	04c00204 	movi	r19,8
 200b584:	0021883a 	mov	r16,zero
 200b588:	0025883a 	mov	r18,zero
 200b58c:	02400084 	movi	r9,2
 200b590:	003fca06 	br	200b4bc <__alt_mem_mem_0+0xfcfeb4bc>
 200b594:	8023883a 	mov	r17,r16
 200b598:	9011883a 	mov	r8,r18
 200b59c:	e02f883a 	mov	r23,fp
 200b5a0:	480f883a 	mov	r7,r9
 200b5a4:	00800084 	movi	r2,2
 200b5a8:	3881311e 	bne	r7,r2,200ba70 <__divdf3+0x62c>
 200b5ac:	b827883a 	mov	r19,r23
 200b5b0:	98c0004c 	andi	r3,r19,1
 200b5b4:	0081ffc4 	movi	r2,2047
 200b5b8:	000b883a 	mov	r5,zero
 200b5bc:	0025883a 	mov	r18,zero
 200b5c0:	1004953a 	slli	r2,r2,20
 200b5c4:	18c03fcc 	andi	r3,r3,255
 200b5c8:	04400434 	movhi	r17,16
 200b5cc:	8c7fffc4 	addi	r17,r17,-1
 200b5d0:	180697fa 	slli	r3,r3,31
 200b5d4:	2c4a703a 	and	r5,r5,r17
 200b5d8:	288ab03a 	or	r5,r5,r2
 200b5dc:	28c6b03a 	or	r3,r5,r3
 200b5e0:	9005883a 	mov	r2,r18
 200b5e4:	dfc00d17 	ldw	ra,52(sp)
 200b5e8:	df000c17 	ldw	fp,48(sp)
 200b5ec:	ddc00b17 	ldw	r23,44(sp)
 200b5f0:	dd800a17 	ldw	r22,40(sp)
 200b5f4:	dd400917 	ldw	r21,36(sp)
 200b5f8:	dd000817 	ldw	r20,32(sp)
 200b5fc:	dcc00717 	ldw	r19,28(sp)
 200b600:	dc800617 	ldw	r18,24(sp)
 200b604:	dc400517 	ldw	r17,20(sp)
 200b608:	dc000417 	ldw	r16,16(sp)
 200b60c:	dec00e04 	addi	sp,sp,56
 200b610:	f800283a 	ret
 200b614:	2404b03a 	or	r2,r4,r16
 200b618:	2027883a 	mov	r19,r4
 200b61c:	10003926 	beq	r2,zero,200b704 <__divdf3+0x2c0>
 200b620:	80012e26 	beq	r16,zero,200badc <__divdf3+0x698>
 200b624:	8009883a 	mov	r4,r16
 200b628:	d9800315 	stw	r6,12(sp)
 200b62c:	d9c00215 	stw	r7,8(sp)
 200b630:	200d19c0 	call	200d19c <__clzsi2>
 200b634:	d9800317 	ldw	r6,12(sp)
 200b638:	d9c00217 	ldw	r7,8(sp)
 200b63c:	113ffd44 	addi	r4,r2,-11
 200b640:	00c00704 	movi	r3,28
 200b644:	19012116 	blt	r3,r4,200bacc <__divdf3+0x688>
 200b648:	00c00744 	movi	r3,29
 200b64c:	147ffe04 	addi	r17,r2,-8
 200b650:	1907c83a 	sub	r3,r3,r4
 200b654:	8460983a 	sll	r16,r16,r17
 200b658:	98c6d83a 	srl	r3,r19,r3
 200b65c:	9c64983a 	sll	r18,r19,r17
 200b660:	1c20b03a 	or	r16,r3,r16
 200b664:	1080fcc4 	addi	r2,r2,1011
 200b668:	00abc83a 	sub	r21,zero,r2
 200b66c:	0027883a 	mov	r19,zero
 200b670:	0013883a 	mov	r9,zero
 200b674:	003f9106 	br	200b4bc <__alt_mem_mem_0+0xfcfeb4bc>
 200b678:	3446b03a 	or	r3,r6,r17
 200b67c:	18001f1e 	bne	r3,zero,200b6fc <__divdf3+0x2b8>
 200b680:	0023883a 	mov	r17,zero
 200b684:	0011883a 	mov	r8,zero
 200b688:	01c00084 	movi	r7,2
 200b68c:	003f9d06 	br	200b504 <__alt_mem_mem_0+0xfcfeb504>
 200b690:	3446b03a 	or	r3,r6,r17
 200b694:	18001526 	beq	r3,zero,200b6ec <__divdf3+0x2a8>
 200b698:	88011b26 	beq	r17,zero,200bb08 <__divdf3+0x6c4>
 200b69c:	8809883a 	mov	r4,r17
 200b6a0:	d9800315 	stw	r6,12(sp)
 200b6a4:	da400115 	stw	r9,4(sp)
 200b6a8:	200d19c0 	call	200d19c <__clzsi2>
 200b6ac:	d9800317 	ldw	r6,12(sp)
 200b6b0:	da400117 	ldw	r9,4(sp)
 200b6b4:	113ffd44 	addi	r4,r2,-11
 200b6b8:	00c00704 	movi	r3,28
 200b6bc:	19010e16 	blt	r3,r4,200baf8 <__divdf3+0x6b4>
 200b6c0:	00c00744 	movi	r3,29
 200b6c4:	123ffe04 	addi	r8,r2,-8
 200b6c8:	1907c83a 	sub	r3,r3,r4
 200b6cc:	8a22983a 	sll	r17,r17,r8
 200b6d0:	30c6d83a 	srl	r3,r6,r3
 200b6d4:	3210983a 	sll	r8,r6,r8
 200b6d8:	1c62b03a 	or	r17,r3,r17
 200b6dc:	1080fcc4 	addi	r2,r2,1011
 200b6e0:	0085c83a 	sub	r2,zero,r2
 200b6e4:	000f883a 	mov	r7,zero
 200b6e8:	003f8606 	br	200b504 <__alt_mem_mem_0+0xfcfeb504>
 200b6ec:	0023883a 	mov	r17,zero
 200b6f0:	0011883a 	mov	r8,zero
 200b6f4:	01c00044 	movi	r7,1
 200b6f8:	003f8206 	br	200b504 <__alt_mem_mem_0+0xfcfeb504>
 200b6fc:	01c000c4 	movi	r7,3
 200b700:	003f8006 	br	200b504 <__alt_mem_mem_0+0xfcfeb504>
 200b704:	04c00104 	movi	r19,4
 200b708:	0021883a 	mov	r16,zero
 200b70c:	0025883a 	mov	r18,zero
 200b710:	02400044 	movi	r9,1
 200b714:	003f6906 	br	200b4bc <__alt_mem_mem_0+0xfcfeb4bc>
 200b718:	04c00304 	movi	r19,12
 200b71c:	024000c4 	movi	r9,3
 200b720:	003f6606 	br	200b4bc <__alt_mem_mem_0+0xfcfeb4bc>
 200b724:	01400434 	movhi	r5,16
 200b728:	0007883a 	mov	r3,zero
 200b72c:	297fffc4 	addi	r5,r5,-1
 200b730:	04bfffc4 	movi	r18,-1
 200b734:	0081ffc4 	movi	r2,2047
 200b738:	003fa106 	br	200b5c0 <__alt_mem_mem_0+0xfcfeb5c0>
 200b73c:	00c00044 	movi	r3,1
 200b740:	1887c83a 	sub	r3,r3,r2
 200b744:	01000e04 	movi	r4,56
 200b748:	20c1210e 	bge	r4,r3,200bbd0 <__divdf3+0x78c>
 200b74c:	98c0004c 	andi	r3,r19,1
 200b750:	0005883a 	mov	r2,zero
 200b754:	000b883a 	mov	r5,zero
 200b758:	0025883a 	mov	r18,zero
 200b75c:	003f9806 	br	200b5c0 <__alt_mem_mem_0+0xfcfeb5c0>
 200b760:	8c00fd36 	bltu	r17,r16,200bb58 <__divdf3+0x714>
 200b764:	8440fb26 	beq	r16,r17,200bb54 <__divdf3+0x710>
 200b768:	8007883a 	mov	r3,r16
 200b76c:	ad7fffc4 	addi	r21,r21,-1
 200b770:	0021883a 	mov	r16,zero
 200b774:	4004d63a 	srli	r2,r8,24
 200b778:	8822923a 	slli	r17,r17,8
 200b77c:	1809883a 	mov	r4,r3
 200b780:	402c923a 	slli	r22,r8,8
 200b784:	88b8b03a 	or	fp,r17,r2
 200b788:	e028d43a 	srli	r20,fp,16
 200b78c:	d8c00015 	stw	r3,0(sp)
 200b790:	e5ffffcc 	andi	r23,fp,65535
 200b794:	a00b883a 	mov	r5,r20
 200b798:	200aadc0 	call	200aadc <__udivsi3>
 200b79c:	d8c00017 	ldw	r3,0(sp)
 200b7a0:	a00b883a 	mov	r5,r20
 200b7a4:	d8800315 	stw	r2,12(sp)
 200b7a8:	1809883a 	mov	r4,r3
 200b7ac:	200ab400 	call	200ab40 <__umodsi3>
 200b7b0:	d9800317 	ldw	r6,12(sp)
 200b7b4:	1006943a 	slli	r3,r2,16
 200b7b8:	9004d43a 	srli	r2,r18,16
 200b7bc:	b9a3383a 	mul	r17,r23,r6
 200b7c0:	10c4b03a 	or	r2,r2,r3
 200b7c4:	1440062e 	bgeu	r2,r17,200b7e0 <__divdf3+0x39c>
 200b7c8:	1705883a 	add	r2,r2,fp
 200b7cc:	30ffffc4 	addi	r3,r6,-1
 200b7d0:	1700ee36 	bltu	r2,fp,200bb8c <__divdf3+0x748>
 200b7d4:	1440ed2e 	bgeu	r2,r17,200bb8c <__divdf3+0x748>
 200b7d8:	31bfff84 	addi	r6,r6,-2
 200b7dc:	1705883a 	add	r2,r2,fp
 200b7e0:	1463c83a 	sub	r17,r2,r17
 200b7e4:	a00b883a 	mov	r5,r20
 200b7e8:	8809883a 	mov	r4,r17
 200b7ec:	d9800315 	stw	r6,12(sp)
 200b7f0:	200aadc0 	call	200aadc <__udivsi3>
 200b7f4:	a00b883a 	mov	r5,r20
 200b7f8:	8809883a 	mov	r4,r17
 200b7fc:	d8800215 	stw	r2,8(sp)
 200b800:	200ab400 	call	200ab40 <__umodsi3>
 200b804:	d9c00217 	ldw	r7,8(sp)
 200b808:	1004943a 	slli	r2,r2,16
 200b80c:	94bfffcc 	andi	r18,r18,65535
 200b810:	b9d1383a 	mul	r8,r23,r7
 200b814:	90a4b03a 	or	r18,r18,r2
 200b818:	d9800317 	ldw	r6,12(sp)
 200b81c:	9200062e 	bgeu	r18,r8,200b838 <__divdf3+0x3f4>
 200b820:	9725883a 	add	r18,r18,fp
 200b824:	38bfffc4 	addi	r2,r7,-1
 200b828:	9700d636 	bltu	r18,fp,200bb84 <__divdf3+0x740>
 200b82c:	9200d52e 	bgeu	r18,r8,200bb84 <__divdf3+0x740>
 200b830:	39ffff84 	addi	r7,r7,-2
 200b834:	9725883a 	add	r18,r18,fp
 200b838:	3004943a 	slli	r2,r6,16
 200b83c:	b012d43a 	srli	r9,r22,16
 200b840:	b1bfffcc 	andi	r6,r22,65535
 200b844:	11e2b03a 	or	r17,r2,r7
 200b848:	8806d43a 	srli	r3,r17,16
 200b84c:	893fffcc 	andi	r4,r17,65535
 200b850:	218b383a 	mul	r5,r4,r6
 200b854:	30c5383a 	mul	r2,r6,r3
 200b858:	2249383a 	mul	r4,r4,r9
 200b85c:	280ed43a 	srli	r7,r5,16
 200b860:	9225c83a 	sub	r18,r18,r8
 200b864:	2089883a 	add	r4,r4,r2
 200b868:	3909883a 	add	r4,r7,r4
 200b86c:	1a47383a 	mul	r3,r3,r9
 200b870:	2080022e 	bgeu	r4,r2,200b87c <__divdf3+0x438>
 200b874:	00800074 	movhi	r2,1
 200b878:	1887883a 	add	r3,r3,r2
 200b87c:	2004d43a 	srli	r2,r4,16
 200b880:	2008943a 	slli	r4,r4,16
 200b884:	297fffcc 	andi	r5,r5,65535
 200b888:	10c7883a 	add	r3,r2,r3
 200b88c:	2149883a 	add	r4,r4,r5
 200b890:	90c0a536 	bltu	r18,r3,200bb28 <__divdf3+0x6e4>
 200b894:	90c0bf26 	beq	r18,r3,200bb94 <__divdf3+0x750>
 200b898:	90c7c83a 	sub	r3,r18,r3
 200b89c:	810fc83a 	sub	r7,r16,r4
 200b8a0:	81e5803a 	cmpltu	r18,r16,r7
 200b8a4:	1ca5c83a 	sub	r18,r3,r18
 200b8a8:	e480c126 	beq	fp,r18,200bbb0 <__divdf3+0x76c>
 200b8ac:	a00b883a 	mov	r5,r20
 200b8b0:	9009883a 	mov	r4,r18
 200b8b4:	d9800315 	stw	r6,12(sp)
 200b8b8:	d9c00215 	stw	r7,8(sp)
 200b8bc:	da400115 	stw	r9,4(sp)
 200b8c0:	200aadc0 	call	200aadc <__udivsi3>
 200b8c4:	a00b883a 	mov	r5,r20
 200b8c8:	9009883a 	mov	r4,r18
 200b8cc:	d8800015 	stw	r2,0(sp)
 200b8d0:	200ab400 	call	200ab40 <__umodsi3>
 200b8d4:	d9c00217 	ldw	r7,8(sp)
 200b8d8:	da000017 	ldw	r8,0(sp)
 200b8dc:	1006943a 	slli	r3,r2,16
 200b8e0:	3804d43a 	srli	r2,r7,16
 200b8e4:	ba21383a 	mul	r16,r23,r8
 200b8e8:	d9800317 	ldw	r6,12(sp)
 200b8ec:	10c4b03a 	or	r2,r2,r3
 200b8f0:	da400117 	ldw	r9,4(sp)
 200b8f4:	1400062e 	bgeu	r2,r16,200b910 <__divdf3+0x4cc>
 200b8f8:	1705883a 	add	r2,r2,fp
 200b8fc:	40ffffc4 	addi	r3,r8,-1
 200b900:	1700ad36 	bltu	r2,fp,200bbb8 <__divdf3+0x774>
 200b904:	1400ac2e 	bgeu	r2,r16,200bbb8 <__divdf3+0x774>
 200b908:	423fff84 	addi	r8,r8,-2
 200b90c:	1705883a 	add	r2,r2,fp
 200b910:	1421c83a 	sub	r16,r2,r16
 200b914:	a00b883a 	mov	r5,r20
 200b918:	8009883a 	mov	r4,r16
 200b91c:	d9800315 	stw	r6,12(sp)
 200b920:	d9c00215 	stw	r7,8(sp)
 200b924:	da000015 	stw	r8,0(sp)
 200b928:	da400115 	stw	r9,4(sp)
 200b92c:	200aadc0 	call	200aadc <__udivsi3>
 200b930:	8009883a 	mov	r4,r16
 200b934:	a00b883a 	mov	r5,r20
 200b938:	1025883a 	mov	r18,r2
 200b93c:	200ab400 	call	200ab40 <__umodsi3>
 200b940:	d9c00217 	ldw	r7,8(sp)
 200b944:	1004943a 	slli	r2,r2,16
 200b948:	bcaf383a 	mul	r23,r23,r18
 200b94c:	393fffcc 	andi	r4,r7,65535
 200b950:	2088b03a 	or	r4,r4,r2
 200b954:	d9800317 	ldw	r6,12(sp)
 200b958:	da000017 	ldw	r8,0(sp)
 200b95c:	da400117 	ldw	r9,4(sp)
 200b960:	25c0062e 	bgeu	r4,r23,200b97c <__divdf3+0x538>
 200b964:	2709883a 	add	r4,r4,fp
 200b968:	90bfffc4 	addi	r2,r18,-1
 200b96c:	27009436 	bltu	r4,fp,200bbc0 <__divdf3+0x77c>
 200b970:	25c0932e 	bgeu	r4,r23,200bbc0 <__divdf3+0x77c>
 200b974:	94bfff84 	addi	r18,r18,-2
 200b978:	2709883a 	add	r4,r4,fp
 200b97c:	4004943a 	slli	r2,r8,16
 200b980:	25efc83a 	sub	r23,r4,r23
 200b984:	1490b03a 	or	r8,r2,r18
 200b988:	4008d43a 	srli	r4,r8,16
 200b98c:	40ffffcc 	andi	r3,r8,65535
 200b990:	30c5383a 	mul	r2,r6,r3
 200b994:	1a47383a 	mul	r3,r3,r9
 200b998:	310d383a 	mul	r6,r6,r4
 200b99c:	100ad43a 	srli	r5,r2,16
 200b9a0:	4913383a 	mul	r9,r9,r4
 200b9a4:	1987883a 	add	r3,r3,r6
 200b9a8:	28c7883a 	add	r3,r5,r3
 200b9ac:	1980022e 	bgeu	r3,r6,200b9b8 <__divdf3+0x574>
 200b9b0:	01000074 	movhi	r4,1
 200b9b4:	4913883a 	add	r9,r9,r4
 200b9b8:	1808d43a 	srli	r4,r3,16
 200b9bc:	1806943a 	slli	r3,r3,16
 200b9c0:	10bfffcc 	andi	r2,r2,65535
 200b9c4:	2253883a 	add	r9,r4,r9
 200b9c8:	1887883a 	add	r3,r3,r2
 200b9cc:	ba403836 	bltu	r23,r9,200bab0 <__divdf3+0x66c>
 200b9d0:	ba403626 	beq	r23,r9,200baac <__divdf3+0x668>
 200b9d4:	42000054 	ori	r8,r8,1
 200b9d8:	a880ffc4 	addi	r2,r21,1023
 200b9dc:	00bf570e 	bge	zero,r2,200b73c <__alt_mem_mem_0+0xfcfeb73c>
 200b9e0:	40c001cc 	andi	r3,r8,7
 200b9e4:	18000726 	beq	r3,zero,200ba04 <__divdf3+0x5c0>
 200b9e8:	40c003cc 	andi	r3,r8,15
 200b9ec:	01000104 	movi	r4,4
 200b9f0:	19000426 	beq	r3,r4,200ba04 <__divdf3+0x5c0>
 200b9f4:	4107883a 	add	r3,r8,r4
 200b9f8:	1a11803a 	cmpltu	r8,r3,r8
 200b9fc:	8a23883a 	add	r17,r17,r8
 200ba00:	1811883a 	mov	r8,r3
 200ba04:	88c0402c 	andhi	r3,r17,256
 200ba08:	18000426 	beq	r3,zero,200ba1c <__divdf3+0x5d8>
 200ba0c:	00ffc034 	movhi	r3,65280
 200ba10:	18ffffc4 	addi	r3,r3,-1
 200ba14:	a8810004 	addi	r2,r21,1024
 200ba18:	88e2703a 	and	r17,r17,r3
 200ba1c:	00c1ff84 	movi	r3,2046
 200ba20:	18bee316 	blt	r3,r2,200b5b0 <__alt_mem_mem_0+0xfcfeb5b0>
 200ba24:	8824977a 	slli	r18,r17,29
 200ba28:	4010d0fa 	srli	r8,r8,3
 200ba2c:	8822927a 	slli	r17,r17,9
 200ba30:	1081ffcc 	andi	r2,r2,2047
 200ba34:	9224b03a 	or	r18,r18,r8
 200ba38:	880ad33a 	srli	r5,r17,12
 200ba3c:	98c0004c 	andi	r3,r19,1
 200ba40:	003edf06 	br	200b5c0 <__alt_mem_mem_0+0xfcfeb5c0>
 200ba44:	8080022c 	andhi	r2,r16,8
 200ba48:	10001226 	beq	r2,zero,200ba94 <__divdf3+0x650>
 200ba4c:	8880022c 	andhi	r2,r17,8
 200ba50:	1000101e 	bne	r2,zero,200ba94 <__divdf3+0x650>
 200ba54:	00800434 	movhi	r2,16
 200ba58:	89400234 	orhi	r5,r17,8
 200ba5c:	10bfffc4 	addi	r2,r2,-1
 200ba60:	b007883a 	mov	r3,r22
 200ba64:	288a703a 	and	r5,r5,r2
 200ba68:	4025883a 	mov	r18,r8
 200ba6c:	003f3106 	br	200b734 <__alt_mem_mem_0+0xfcfeb734>
 200ba70:	008000c4 	movi	r2,3
 200ba74:	3880a626 	beq	r7,r2,200bd10 <__divdf3+0x8cc>
 200ba78:	00800044 	movi	r2,1
 200ba7c:	3880521e 	bne	r7,r2,200bbc8 <__divdf3+0x784>
 200ba80:	b807883a 	mov	r3,r23
 200ba84:	0005883a 	mov	r2,zero
 200ba88:	000b883a 	mov	r5,zero
 200ba8c:	0025883a 	mov	r18,zero
 200ba90:	003ecb06 	br	200b5c0 <__alt_mem_mem_0+0xfcfeb5c0>
 200ba94:	00800434 	movhi	r2,16
 200ba98:	81400234 	orhi	r5,r16,8
 200ba9c:	10bfffc4 	addi	r2,r2,-1
 200baa0:	a007883a 	mov	r3,r20
 200baa4:	288a703a 	and	r5,r5,r2
 200baa8:	003f2206 	br	200b734 <__alt_mem_mem_0+0xfcfeb734>
 200baac:	183fca26 	beq	r3,zero,200b9d8 <__alt_mem_mem_0+0xfcfeb9d8>
 200bab0:	e5ef883a 	add	r23,fp,r23
 200bab4:	40bfffc4 	addi	r2,r8,-1
 200bab8:	bf00392e 	bgeu	r23,fp,200bba0 <__divdf3+0x75c>
 200babc:	1011883a 	mov	r8,r2
 200bac0:	ba7fc41e 	bne	r23,r9,200b9d4 <__alt_mem_mem_0+0xfcfeb9d4>
 200bac4:	b0ffc31e 	bne	r22,r3,200b9d4 <__alt_mem_mem_0+0xfcfeb9d4>
 200bac8:	003fc306 	br	200b9d8 <__alt_mem_mem_0+0xfcfeb9d8>
 200bacc:	143ff604 	addi	r16,r2,-40
 200bad0:	9c20983a 	sll	r16,r19,r16
 200bad4:	0025883a 	mov	r18,zero
 200bad8:	003ee206 	br	200b664 <__alt_mem_mem_0+0xfcfeb664>
 200badc:	d9800315 	stw	r6,12(sp)
 200bae0:	d9c00215 	stw	r7,8(sp)
 200bae4:	200d19c0 	call	200d19c <__clzsi2>
 200bae8:	10800804 	addi	r2,r2,32
 200baec:	d9c00217 	ldw	r7,8(sp)
 200baf0:	d9800317 	ldw	r6,12(sp)
 200baf4:	003ed106 	br	200b63c <__alt_mem_mem_0+0xfcfeb63c>
 200baf8:	147ff604 	addi	r17,r2,-40
 200bafc:	3462983a 	sll	r17,r6,r17
 200bb00:	0011883a 	mov	r8,zero
 200bb04:	003ef506 	br	200b6dc <__alt_mem_mem_0+0xfcfeb6dc>
 200bb08:	3009883a 	mov	r4,r6
 200bb0c:	d9800315 	stw	r6,12(sp)
 200bb10:	da400115 	stw	r9,4(sp)
 200bb14:	200d19c0 	call	200d19c <__clzsi2>
 200bb18:	10800804 	addi	r2,r2,32
 200bb1c:	da400117 	ldw	r9,4(sp)
 200bb20:	d9800317 	ldw	r6,12(sp)
 200bb24:	003ee306 	br	200b6b4 <__alt_mem_mem_0+0xfcfeb6b4>
 200bb28:	85a1883a 	add	r16,r16,r22
 200bb2c:	8585803a 	cmpltu	r2,r16,r22
 200bb30:	1705883a 	add	r2,r2,fp
 200bb34:	14a5883a 	add	r18,r2,r18
 200bb38:	88bfffc4 	addi	r2,r17,-1
 200bb3c:	e4800c2e 	bgeu	fp,r18,200bb70 <__divdf3+0x72c>
 200bb40:	90c03e36 	bltu	r18,r3,200bc3c <__divdf3+0x7f8>
 200bb44:	1c806926 	beq	r3,r18,200bcec <__divdf3+0x8a8>
 200bb48:	90c7c83a 	sub	r3,r18,r3
 200bb4c:	1023883a 	mov	r17,r2
 200bb50:	003f5206 	br	200b89c <__alt_mem_mem_0+0xfcfeb89c>
 200bb54:	923f0436 	bltu	r18,r8,200b768 <__alt_mem_mem_0+0xfcfeb768>
 200bb58:	800897fa 	slli	r4,r16,31
 200bb5c:	9004d07a 	srli	r2,r18,1
 200bb60:	8006d07a 	srli	r3,r16,1
 200bb64:	902097fa 	slli	r16,r18,31
 200bb68:	20a4b03a 	or	r18,r4,r2
 200bb6c:	003f0106 	br	200b774 <__alt_mem_mem_0+0xfcfeb774>
 200bb70:	e4bff51e 	bne	fp,r18,200bb48 <__alt_mem_mem_0+0xfcfebb48>
 200bb74:	85bff22e 	bgeu	r16,r22,200bb40 <__alt_mem_mem_0+0xfcfebb40>
 200bb78:	e0c7c83a 	sub	r3,fp,r3
 200bb7c:	1023883a 	mov	r17,r2
 200bb80:	003f4606 	br	200b89c <__alt_mem_mem_0+0xfcfeb89c>
 200bb84:	100f883a 	mov	r7,r2
 200bb88:	003f2b06 	br	200b838 <__alt_mem_mem_0+0xfcfeb838>
 200bb8c:	180d883a 	mov	r6,r3
 200bb90:	003f1306 	br	200b7e0 <__alt_mem_mem_0+0xfcfeb7e0>
 200bb94:	813fe436 	bltu	r16,r4,200bb28 <__alt_mem_mem_0+0xfcfebb28>
 200bb98:	0007883a 	mov	r3,zero
 200bb9c:	003f3f06 	br	200b89c <__alt_mem_mem_0+0xfcfeb89c>
 200bba0:	ba402c36 	bltu	r23,r9,200bc54 <__divdf3+0x810>
 200bba4:	4dc05426 	beq	r9,r23,200bcf8 <__divdf3+0x8b4>
 200bba8:	1011883a 	mov	r8,r2
 200bbac:	003f8906 	br	200b9d4 <__alt_mem_mem_0+0xfcfeb9d4>
 200bbb0:	023fffc4 	movi	r8,-1
 200bbb4:	003f8806 	br	200b9d8 <__alt_mem_mem_0+0xfcfeb9d8>
 200bbb8:	1811883a 	mov	r8,r3
 200bbbc:	003f5406 	br	200b910 <__alt_mem_mem_0+0xfcfeb910>
 200bbc0:	1025883a 	mov	r18,r2
 200bbc4:	003f6d06 	br	200b97c <__alt_mem_mem_0+0xfcfeb97c>
 200bbc8:	b827883a 	mov	r19,r23
 200bbcc:	003f8206 	br	200b9d8 <__alt_mem_mem_0+0xfcfeb9d8>
 200bbd0:	010007c4 	movi	r4,31
 200bbd4:	20c02616 	blt	r4,r3,200bc70 <__divdf3+0x82c>
 200bbd8:	00800804 	movi	r2,32
 200bbdc:	10c5c83a 	sub	r2,r2,r3
 200bbe0:	888a983a 	sll	r5,r17,r2
 200bbe4:	40c8d83a 	srl	r4,r8,r3
 200bbe8:	4084983a 	sll	r2,r8,r2
 200bbec:	88e2d83a 	srl	r17,r17,r3
 200bbf0:	2906b03a 	or	r3,r5,r4
 200bbf4:	1004c03a 	cmpne	r2,r2,zero
 200bbf8:	1886b03a 	or	r3,r3,r2
 200bbfc:	188001cc 	andi	r2,r3,7
 200bc00:	10000726 	beq	r2,zero,200bc20 <__divdf3+0x7dc>
 200bc04:	188003cc 	andi	r2,r3,15
 200bc08:	01000104 	movi	r4,4
 200bc0c:	11000426 	beq	r2,r4,200bc20 <__divdf3+0x7dc>
 200bc10:	1805883a 	mov	r2,r3
 200bc14:	10c00104 	addi	r3,r2,4
 200bc18:	1885803a 	cmpltu	r2,r3,r2
 200bc1c:	88a3883a 	add	r17,r17,r2
 200bc20:	8880202c 	andhi	r2,r17,128
 200bc24:	10002726 	beq	r2,zero,200bcc4 <__divdf3+0x880>
 200bc28:	98c0004c 	andi	r3,r19,1
 200bc2c:	00800044 	movi	r2,1
 200bc30:	000b883a 	mov	r5,zero
 200bc34:	0025883a 	mov	r18,zero
 200bc38:	003e6106 	br	200b5c0 <__alt_mem_mem_0+0xfcfeb5c0>
 200bc3c:	85a1883a 	add	r16,r16,r22
 200bc40:	8585803a 	cmpltu	r2,r16,r22
 200bc44:	1705883a 	add	r2,r2,fp
 200bc48:	14a5883a 	add	r18,r2,r18
 200bc4c:	8c7fff84 	addi	r17,r17,-2
 200bc50:	003f1106 	br	200b898 <__alt_mem_mem_0+0xfcfeb898>
 200bc54:	b589883a 	add	r4,r22,r22
 200bc58:	25ad803a 	cmpltu	r22,r4,r22
 200bc5c:	b739883a 	add	fp,r22,fp
 200bc60:	40bfff84 	addi	r2,r8,-2
 200bc64:	bf2f883a 	add	r23,r23,fp
 200bc68:	202d883a 	mov	r22,r4
 200bc6c:	003f9306 	br	200babc <__alt_mem_mem_0+0xfcfebabc>
 200bc70:	013ff844 	movi	r4,-31
 200bc74:	2085c83a 	sub	r2,r4,r2
 200bc78:	8888d83a 	srl	r4,r17,r2
 200bc7c:	00800804 	movi	r2,32
 200bc80:	18802126 	beq	r3,r2,200bd08 <__divdf3+0x8c4>
 200bc84:	00801004 	movi	r2,64
 200bc88:	10c5c83a 	sub	r2,r2,r3
 200bc8c:	8884983a 	sll	r2,r17,r2
 200bc90:	1204b03a 	or	r2,r2,r8
 200bc94:	1004c03a 	cmpne	r2,r2,zero
 200bc98:	2084b03a 	or	r2,r4,r2
 200bc9c:	144001cc 	andi	r17,r2,7
 200bca0:	88000d1e 	bne	r17,zero,200bcd8 <__divdf3+0x894>
 200bca4:	000b883a 	mov	r5,zero
 200bca8:	1024d0fa 	srli	r18,r2,3
 200bcac:	98c0004c 	andi	r3,r19,1
 200bcb0:	0005883a 	mov	r2,zero
 200bcb4:	9464b03a 	or	r18,r18,r17
 200bcb8:	003e4106 	br	200b5c0 <__alt_mem_mem_0+0xfcfeb5c0>
 200bcbc:	1007883a 	mov	r3,r2
 200bcc0:	0023883a 	mov	r17,zero
 200bcc4:	880a927a 	slli	r5,r17,9
 200bcc8:	1805883a 	mov	r2,r3
 200bccc:	8822977a 	slli	r17,r17,29
 200bcd0:	280ad33a 	srli	r5,r5,12
 200bcd4:	003ff406 	br	200bca8 <__alt_mem_mem_0+0xfcfebca8>
 200bcd8:	10c003cc 	andi	r3,r2,15
 200bcdc:	01000104 	movi	r4,4
 200bce0:	193ff626 	beq	r3,r4,200bcbc <__alt_mem_mem_0+0xfcfebcbc>
 200bce4:	0023883a 	mov	r17,zero
 200bce8:	003fca06 	br	200bc14 <__alt_mem_mem_0+0xfcfebc14>
 200bcec:	813fd336 	bltu	r16,r4,200bc3c <__alt_mem_mem_0+0xfcfebc3c>
 200bcf0:	1023883a 	mov	r17,r2
 200bcf4:	003fa806 	br	200bb98 <__alt_mem_mem_0+0xfcfebb98>
 200bcf8:	b0ffd636 	bltu	r22,r3,200bc54 <__alt_mem_mem_0+0xfcfebc54>
 200bcfc:	1011883a 	mov	r8,r2
 200bd00:	b0ff341e 	bne	r22,r3,200b9d4 <__alt_mem_mem_0+0xfcfeb9d4>
 200bd04:	003f3406 	br	200b9d8 <__alt_mem_mem_0+0xfcfeb9d8>
 200bd08:	0005883a 	mov	r2,zero
 200bd0c:	003fe006 	br	200bc90 <__alt_mem_mem_0+0xfcfebc90>
 200bd10:	00800434 	movhi	r2,16
 200bd14:	89400234 	orhi	r5,r17,8
 200bd18:	10bfffc4 	addi	r2,r2,-1
 200bd1c:	b807883a 	mov	r3,r23
 200bd20:	288a703a 	and	r5,r5,r2
 200bd24:	4025883a 	mov	r18,r8
 200bd28:	003e8206 	br	200b734 <__alt_mem_mem_0+0xfcfeb734>

0200bd2c <__eqdf2>:
 200bd2c:	2804d53a 	srli	r2,r5,20
 200bd30:	3806d53a 	srli	r3,r7,20
 200bd34:	02000434 	movhi	r8,16
 200bd38:	423fffc4 	addi	r8,r8,-1
 200bd3c:	1081ffcc 	andi	r2,r2,2047
 200bd40:	0281ffc4 	movi	r10,2047
 200bd44:	2a12703a 	and	r9,r5,r8
 200bd48:	18c1ffcc 	andi	r3,r3,2047
 200bd4c:	3a10703a 	and	r8,r7,r8
 200bd50:	280ad7fa 	srli	r5,r5,31
 200bd54:	380ed7fa 	srli	r7,r7,31
 200bd58:	12801026 	beq	r2,r10,200bd9c <__eqdf2+0x70>
 200bd5c:	0281ffc4 	movi	r10,2047
 200bd60:	1a800a26 	beq	r3,r10,200bd8c <__eqdf2+0x60>
 200bd64:	10c00226 	beq	r2,r3,200bd70 <__eqdf2+0x44>
 200bd68:	00800044 	movi	r2,1
 200bd6c:	f800283a 	ret
 200bd70:	4a3ffd1e 	bne	r9,r8,200bd68 <__alt_mem_mem_0+0xfcfebd68>
 200bd74:	21bffc1e 	bne	r4,r6,200bd68 <__alt_mem_mem_0+0xfcfebd68>
 200bd78:	29c00c26 	beq	r5,r7,200bdac <__eqdf2+0x80>
 200bd7c:	103ffa1e 	bne	r2,zero,200bd68 <__alt_mem_mem_0+0xfcfebd68>
 200bd80:	2244b03a 	or	r2,r4,r9
 200bd84:	1004c03a 	cmpne	r2,r2,zero
 200bd88:	f800283a 	ret
 200bd8c:	3214b03a 	or	r10,r6,r8
 200bd90:	503ff426 	beq	r10,zero,200bd64 <__alt_mem_mem_0+0xfcfebd64>
 200bd94:	00800044 	movi	r2,1
 200bd98:	f800283a 	ret
 200bd9c:	2254b03a 	or	r10,r4,r9
 200bda0:	503fee26 	beq	r10,zero,200bd5c <__alt_mem_mem_0+0xfcfebd5c>
 200bda4:	00800044 	movi	r2,1
 200bda8:	f800283a 	ret
 200bdac:	0005883a 	mov	r2,zero
 200bdb0:	f800283a 	ret

0200bdb4 <__gedf2>:
 200bdb4:	2804d53a 	srli	r2,r5,20
 200bdb8:	3806d53a 	srli	r3,r7,20
 200bdbc:	02000434 	movhi	r8,16
 200bdc0:	423fffc4 	addi	r8,r8,-1
 200bdc4:	1081ffcc 	andi	r2,r2,2047
 200bdc8:	0241ffc4 	movi	r9,2047
 200bdcc:	2a14703a 	and	r10,r5,r8
 200bdd0:	18c1ffcc 	andi	r3,r3,2047
 200bdd4:	3a10703a 	and	r8,r7,r8
 200bdd8:	280ad7fa 	srli	r5,r5,31
 200bddc:	380ed7fa 	srli	r7,r7,31
 200bde0:	12401d26 	beq	r2,r9,200be58 <__gedf2+0xa4>
 200bde4:	0241ffc4 	movi	r9,2047
 200bde8:	1a401226 	beq	r3,r9,200be34 <__gedf2+0x80>
 200bdec:	1000081e 	bne	r2,zero,200be10 <__gedf2+0x5c>
 200bdf0:	2296b03a 	or	r11,r4,r10
 200bdf4:	5813003a 	cmpeq	r9,r11,zero
 200bdf8:	1800091e 	bne	r3,zero,200be20 <__gedf2+0x6c>
 200bdfc:	3218b03a 	or	r12,r6,r8
 200be00:	6000071e 	bne	r12,zero,200be20 <__gedf2+0x6c>
 200be04:	0005883a 	mov	r2,zero
 200be08:	5800101e 	bne	r11,zero,200be4c <__gedf2+0x98>
 200be0c:	f800283a 	ret
 200be10:	18000c1e 	bne	r3,zero,200be44 <__gedf2+0x90>
 200be14:	3212b03a 	or	r9,r6,r8
 200be18:	48000c26 	beq	r9,zero,200be4c <__gedf2+0x98>
 200be1c:	0013883a 	mov	r9,zero
 200be20:	39c03fcc 	andi	r7,r7,255
 200be24:	48000826 	beq	r9,zero,200be48 <__gedf2+0x94>
 200be28:	38000926 	beq	r7,zero,200be50 <__gedf2+0x9c>
 200be2c:	00800044 	movi	r2,1
 200be30:	f800283a 	ret
 200be34:	3212b03a 	or	r9,r6,r8
 200be38:	483fec26 	beq	r9,zero,200bdec <__alt_mem_mem_0+0xfcfebdec>
 200be3c:	00bfff84 	movi	r2,-2
 200be40:	f800283a 	ret
 200be44:	39c03fcc 	andi	r7,r7,255
 200be48:	29c00626 	beq	r5,r7,200be64 <__gedf2+0xb0>
 200be4c:	283ff726 	beq	r5,zero,200be2c <__alt_mem_mem_0+0xfcfebe2c>
 200be50:	00bfffc4 	movi	r2,-1
 200be54:	f800283a 	ret
 200be58:	2292b03a 	or	r9,r4,r10
 200be5c:	483fe126 	beq	r9,zero,200bde4 <__alt_mem_mem_0+0xfcfebde4>
 200be60:	003ff606 	br	200be3c <__alt_mem_mem_0+0xfcfebe3c>
 200be64:	18bff916 	blt	r3,r2,200be4c <__alt_mem_mem_0+0xfcfebe4c>
 200be68:	10c00316 	blt	r2,r3,200be78 <__gedf2+0xc4>
 200be6c:	42bff736 	bltu	r8,r10,200be4c <__alt_mem_mem_0+0xfcfebe4c>
 200be70:	52000326 	beq	r10,r8,200be80 <__gedf2+0xcc>
 200be74:	5200042e 	bgeu	r10,r8,200be88 <__gedf2+0xd4>
 200be78:	283fec1e 	bne	r5,zero,200be2c <__alt_mem_mem_0+0xfcfebe2c>
 200be7c:	003ff406 	br	200be50 <__alt_mem_mem_0+0xfcfebe50>
 200be80:	313ff236 	bltu	r6,r4,200be4c <__alt_mem_mem_0+0xfcfebe4c>
 200be84:	21bffc36 	bltu	r4,r6,200be78 <__alt_mem_mem_0+0xfcfebe78>
 200be88:	0005883a 	mov	r2,zero
 200be8c:	f800283a 	ret

0200be90 <__ledf2>:
 200be90:	2804d53a 	srli	r2,r5,20
 200be94:	3810d53a 	srli	r8,r7,20
 200be98:	00c00434 	movhi	r3,16
 200be9c:	18ffffc4 	addi	r3,r3,-1
 200bea0:	1081ffcc 	andi	r2,r2,2047
 200bea4:	0241ffc4 	movi	r9,2047
 200bea8:	28d4703a 	and	r10,r5,r3
 200beac:	4201ffcc 	andi	r8,r8,2047
 200beb0:	38c6703a 	and	r3,r7,r3
 200beb4:	280ad7fa 	srli	r5,r5,31
 200beb8:	380ed7fa 	srli	r7,r7,31
 200bebc:	12401f26 	beq	r2,r9,200bf3c <__ledf2+0xac>
 200bec0:	0241ffc4 	movi	r9,2047
 200bec4:	42401426 	beq	r8,r9,200bf18 <__ledf2+0x88>
 200bec8:	1000091e 	bne	r2,zero,200bef0 <__ledf2+0x60>
 200becc:	2296b03a 	or	r11,r4,r10
 200bed0:	5813003a 	cmpeq	r9,r11,zero
 200bed4:	29403fcc 	andi	r5,r5,255
 200bed8:	40000a1e 	bne	r8,zero,200bf04 <__ledf2+0x74>
 200bedc:	30d8b03a 	or	r12,r6,r3
 200bee0:	6000081e 	bne	r12,zero,200bf04 <__ledf2+0x74>
 200bee4:	0005883a 	mov	r2,zero
 200bee8:	5800111e 	bne	r11,zero,200bf30 <__ledf2+0xa0>
 200beec:	f800283a 	ret
 200bef0:	29403fcc 	andi	r5,r5,255
 200bef4:	40000c1e 	bne	r8,zero,200bf28 <__ledf2+0x98>
 200bef8:	30d2b03a 	or	r9,r6,r3
 200befc:	48000c26 	beq	r9,zero,200bf30 <__ledf2+0xa0>
 200bf00:	0013883a 	mov	r9,zero
 200bf04:	39c03fcc 	andi	r7,r7,255
 200bf08:	48000826 	beq	r9,zero,200bf2c <__ledf2+0x9c>
 200bf0c:	38001126 	beq	r7,zero,200bf54 <__ledf2+0xc4>
 200bf10:	00800044 	movi	r2,1
 200bf14:	f800283a 	ret
 200bf18:	30d2b03a 	or	r9,r6,r3
 200bf1c:	483fea26 	beq	r9,zero,200bec8 <__alt_mem_mem_0+0xfcfebec8>
 200bf20:	00800084 	movi	r2,2
 200bf24:	f800283a 	ret
 200bf28:	39c03fcc 	andi	r7,r7,255
 200bf2c:	39400726 	beq	r7,r5,200bf4c <__ledf2+0xbc>
 200bf30:	2800081e 	bne	r5,zero,200bf54 <__ledf2+0xc4>
 200bf34:	00800044 	movi	r2,1
 200bf38:	f800283a 	ret
 200bf3c:	2292b03a 	or	r9,r4,r10
 200bf40:	483fdf26 	beq	r9,zero,200bec0 <__alt_mem_mem_0+0xfcfebec0>
 200bf44:	00800084 	movi	r2,2
 200bf48:	f800283a 	ret
 200bf4c:	4080030e 	bge	r8,r2,200bf5c <__ledf2+0xcc>
 200bf50:	383fef26 	beq	r7,zero,200bf10 <__alt_mem_mem_0+0xfcfebf10>
 200bf54:	00bfffc4 	movi	r2,-1
 200bf58:	f800283a 	ret
 200bf5c:	123feb16 	blt	r2,r8,200bf0c <__alt_mem_mem_0+0xfcfebf0c>
 200bf60:	1abff336 	bltu	r3,r10,200bf30 <__alt_mem_mem_0+0xfcfebf30>
 200bf64:	50c00326 	beq	r10,r3,200bf74 <__ledf2+0xe4>
 200bf68:	50c0042e 	bgeu	r10,r3,200bf7c <__ledf2+0xec>
 200bf6c:	283fe81e 	bne	r5,zero,200bf10 <__alt_mem_mem_0+0xfcfebf10>
 200bf70:	003ff806 	br	200bf54 <__alt_mem_mem_0+0xfcfebf54>
 200bf74:	313fee36 	bltu	r6,r4,200bf30 <__alt_mem_mem_0+0xfcfebf30>
 200bf78:	21bffc36 	bltu	r4,r6,200bf6c <__alt_mem_mem_0+0xfcfebf6c>
 200bf7c:	0005883a 	mov	r2,zero
 200bf80:	f800283a 	ret

0200bf84 <__muldf3>:
 200bf84:	defff304 	addi	sp,sp,-52
 200bf88:	2804d53a 	srli	r2,r5,20
 200bf8c:	dd800915 	stw	r22,36(sp)
 200bf90:	282cd7fa 	srli	r22,r5,31
 200bf94:	dc000315 	stw	r16,12(sp)
 200bf98:	04000434 	movhi	r16,16
 200bf9c:	dd400815 	stw	r21,32(sp)
 200bfa0:	dc800515 	stw	r18,20(sp)
 200bfa4:	843fffc4 	addi	r16,r16,-1
 200bfa8:	dfc00c15 	stw	ra,48(sp)
 200bfac:	df000b15 	stw	fp,44(sp)
 200bfb0:	ddc00a15 	stw	r23,40(sp)
 200bfb4:	dd000715 	stw	r20,28(sp)
 200bfb8:	dcc00615 	stw	r19,24(sp)
 200bfbc:	dc400415 	stw	r17,16(sp)
 200bfc0:	1481ffcc 	andi	r18,r2,2047
 200bfc4:	2c20703a 	and	r16,r5,r16
 200bfc8:	b02b883a 	mov	r21,r22
 200bfcc:	b2403fcc 	andi	r9,r22,255
 200bfd0:	90006026 	beq	r18,zero,200c154 <__muldf3+0x1d0>
 200bfd4:	0081ffc4 	movi	r2,2047
 200bfd8:	2029883a 	mov	r20,r4
 200bfdc:	90803626 	beq	r18,r2,200c0b8 <__muldf3+0x134>
 200bfe0:	80800434 	orhi	r2,r16,16
 200bfe4:	100490fa 	slli	r2,r2,3
 200bfe8:	2020d77a 	srli	r16,r4,29
 200bfec:	202890fa 	slli	r20,r4,3
 200bff0:	94bf0044 	addi	r18,r18,-1023
 200bff4:	80a0b03a 	or	r16,r16,r2
 200bff8:	0027883a 	mov	r19,zero
 200bffc:	0039883a 	mov	fp,zero
 200c000:	3804d53a 	srli	r2,r7,20
 200c004:	382ed7fa 	srli	r23,r7,31
 200c008:	04400434 	movhi	r17,16
 200c00c:	8c7fffc4 	addi	r17,r17,-1
 200c010:	1081ffcc 	andi	r2,r2,2047
 200c014:	3011883a 	mov	r8,r6
 200c018:	3c62703a 	and	r17,r7,r17
 200c01c:	ba803fcc 	andi	r10,r23,255
 200c020:	10006d26 	beq	r2,zero,200c1d8 <__muldf3+0x254>
 200c024:	00c1ffc4 	movi	r3,2047
 200c028:	10c06526 	beq	r2,r3,200c1c0 <__muldf3+0x23c>
 200c02c:	88c00434 	orhi	r3,r17,16
 200c030:	180690fa 	slli	r3,r3,3
 200c034:	3022d77a 	srli	r17,r6,29
 200c038:	301090fa 	slli	r8,r6,3
 200c03c:	10bf0044 	addi	r2,r2,-1023
 200c040:	88e2b03a 	or	r17,r17,r3
 200c044:	000b883a 	mov	r5,zero
 200c048:	9085883a 	add	r2,r18,r2
 200c04c:	2cc8b03a 	or	r4,r5,r19
 200c050:	00c003c4 	movi	r3,15
 200c054:	bdacf03a 	xor	r22,r23,r22
 200c058:	12c00044 	addi	r11,r2,1
 200c05c:	19009936 	bltu	r3,r4,200c2c4 <__muldf3+0x340>
 200c060:	200890ba 	slli	r4,r4,2
 200c064:	00c08074 	movhi	r3,513
 200c068:	18f01e04 	addi	r3,r3,-16264
 200c06c:	20c9883a 	add	r4,r4,r3
 200c070:	20c00017 	ldw	r3,0(r4)
 200c074:	1800683a 	jmp	r3
 200c078:	0200c2c4 	movi	r8,779
 200c07c:	0200c0d8 	cmpnei	r8,zero,771
 200c080:	0200c0d8 	cmpnei	r8,zero,771
 200c084:	0200c0d4 	movui	r8,771
 200c088:	0200c2a0 	cmpeqi	r8,zero,778
 200c08c:	0200c2a0 	cmpeqi	r8,zero,778
 200c090:	0200c288 	cmpgei	r8,zero,778
 200c094:	0200c0d4 	movui	r8,771
 200c098:	0200c2a0 	cmpeqi	r8,zero,778
 200c09c:	0200c288 	cmpgei	r8,zero,778
 200c0a0:	0200c2a0 	cmpeqi	r8,zero,778
 200c0a4:	0200c0d4 	movui	r8,771
 200c0a8:	0200c2b0 	cmpltui	r8,zero,778
 200c0ac:	0200c2b0 	cmpltui	r8,zero,778
 200c0b0:	0200c2b0 	cmpltui	r8,zero,778
 200c0b4:	0200c4cc 	andi	r8,zero,787
 200c0b8:	2404b03a 	or	r2,r4,r16
 200c0bc:	10006f1e 	bne	r2,zero,200c27c <__muldf3+0x2f8>
 200c0c0:	04c00204 	movi	r19,8
 200c0c4:	0021883a 	mov	r16,zero
 200c0c8:	0029883a 	mov	r20,zero
 200c0cc:	07000084 	movi	fp,2
 200c0d0:	003fcb06 	br	200c000 <__alt_mem_mem_0+0xfcfec000>
 200c0d4:	502d883a 	mov	r22,r10
 200c0d8:	00800084 	movi	r2,2
 200c0dc:	28805726 	beq	r5,r2,200c23c <__muldf3+0x2b8>
 200c0e0:	008000c4 	movi	r2,3
 200c0e4:	28816626 	beq	r5,r2,200c680 <__muldf3+0x6fc>
 200c0e8:	00800044 	movi	r2,1
 200c0ec:	2881411e 	bne	r5,r2,200c5f4 <__muldf3+0x670>
 200c0f0:	b02b883a 	mov	r21,r22
 200c0f4:	0005883a 	mov	r2,zero
 200c0f8:	000b883a 	mov	r5,zero
 200c0fc:	0029883a 	mov	r20,zero
 200c100:	1004953a 	slli	r2,r2,20
 200c104:	a8c03fcc 	andi	r3,r21,255
 200c108:	04400434 	movhi	r17,16
 200c10c:	8c7fffc4 	addi	r17,r17,-1
 200c110:	180697fa 	slli	r3,r3,31
 200c114:	2c4a703a 	and	r5,r5,r17
 200c118:	288ab03a 	or	r5,r5,r2
 200c11c:	28c6b03a 	or	r3,r5,r3
 200c120:	a005883a 	mov	r2,r20
 200c124:	dfc00c17 	ldw	ra,48(sp)
 200c128:	df000b17 	ldw	fp,44(sp)
 200c12c:	ddc00a17 	ldw	r23,40(sp)
 200c130:	dd800917 	ldw	r22,36(sp)
 200c134:	dd400817 	ldw	r21,32(sp)
 200c138:	dd000717 	ldw	r20,28(sp)
 200c13c:	dcc00617 	ldw	r19,24(sp)
 200c140:	dc800517 	ldw	r18,20(sp)
 200c144:	dc400417 	ldw	r17,16(sp)
 200c148:	dc000317 	ldw	r16,12(sp)
 200c14c:	dec00d04 	addi	sp,sp,52
 200c150:	f800283a 	ret
 200c154:	2404b03a 	or	r2,r4,r16
 200c158:	2027883a 	mov	r19,r4
 200c15c:	10004226 	beq	r2,zero,200c268 <__muldf3+0x2e4>
 200c160:	8000fc26 	beq	r16,zero,200c554 <__muldf3+0x5d0>
 200c164:	8009883a 	mov	r4,r16
 200c168:	d9800215 	stw	r6,8(sp)
 200c16c:	d9c00015 	stw	r7,0(sp)
 200c170:	da400115 	stw	r9,4(sp)
 200c174:	200d19c0 	call	200d19c <__clzsi2>
 200c178:	d9800217 	ldw	r6,8(sp)
 200c17c:	d9c00017 	ldw	r7,0(sp)
 200c180:	da400117 	ldw	r9,4(sp)
 200c184:	113ffd44 	addi	r4,r2,-11
 200c188:	00c00704 	movi	r3,28
 200c18c:	1900ed16 	blt	r3,r4,200c544 <__muldf3+0x5c0>
 200c190:	00c00744 	movi	r3,29
 200c194:	147ffe04 	addi	r17,r2,-8
 200c198:	1907c83a 	sub	r3,r3,r4
 200c19c:	8460983a 	sll	r16,r16,r17
 200c1a0:	98c6d83a 	srl	r3,r19,r3
 200c1a4:	9c68983a 	sll	r20,r19,r17
 200c1a8:	1c20b03a 	or	r16,r3,r16
 200c1ac:	1080fcc4 	addi	r2,r2,1011
 200c1b0:	00a5c83a 	sub	r18,zero,r2
 200c1b4:	0027883a 	mov	r19,zero
 200c1b8:	0039883a 	mov	fp,zero
 200c1bc:	003f9006 	br	200c000 <__alt_mem_mem_0+0xfcfec000>
 200c1c0:	3446b03a 	or	r3,r6,r17
 200c1c4:	1800261e 	bne	r3,zero,200c260 <__muldf3+0x2dc>
 200c1c8:	0023883a 	mov	r17,zero
 200c1cc:	0011883a 	mov	r8,zero
 200c1d0:	01400084 	movi	r5,2
 200c1d4:	003f9c06 	br	200c048 <__alt_mem_mem_0+0xfcfec048>
 200c1d8:	3446b03a 	or	r3,r6,r17
 200c1dc:	18001c26 	beq	r3,zero,200c250 <__muldf3+0x2cc>
 200c1e0:	8800ce26 	beq	r17,zero,200c51c <__muldf3+0x598>
 200c1e4:	8809883a 	mov	r4,r17
 200c1e8:	d9800215 	stw	r6,8(sp)
 200c1ec:	da400115 	stw	r9,4(sp)
 200c1f0:	da800015 	stw	r10,0(sp)
 200c1f4:	200d19c0 	call	200d19c <__clzsi2>
 200c1f8:	d9800217 	ldw	r6,8(sp)
 200c1fc:	da400117 	ldw	r9,4(sp)
 200c200:	da800017 	ldw	r10,0(sp)
 200c204:	113ffd44 	addi	r4,r2,-11
 200c208:	00c00704 	movi	r3,28
 200c20c:	1900bf16 	blt	r3,r4,200c50c <__muldf3+0x588>
 200c210:	00c00744 	movi	r3,29
 200c214:	123ffe04 	addi	r8,r2,-8
 200c218:	1907c83a 	sub	r3,r3,r4
 200c21c:	8a22983a 	sll	r17,r17,r8
 200c220:	30c6d83a 	srl	r3,r6,r3
 200c224:	3210983a 	sll	r8,r6,r8
 200c228:	1c62b03a 	or	r17,r3,r17
 200c22c:	1080fcc4 	addi	r2,r2,1011
 200c230:	0085c83a 	sub	r2,zero,r2
 200c234:	000b883a 	mov	r5,zero
 200c238:	003f8306 	br	200c048 <__alt_mem_mem_0+0xfcfec048>
 200c23c:	b02b883a 	mov	r21,r22
 200c240:	0081ffc4 	movi	r2,2047
 200c244:	000b883a 	mov	r5,zero
 200c248:	0029883a 	mov	r20,zero
 200c24c:	003fac06 	br	200c100 <__alt_mem_mem_0+0xfcfec100>
 200c250:	0023883a 	mov	r17,zero
 200c254:	0011883a 	mov	r8,zero
 200c258:	01400044 	movi	r5,1
 200c25c:	003f7a06 	br	200c048 <__alt_mem_mem_0+0xfcfec048>
 200c260:	014000c4 	movi	r5,3
 200c264:	003f7806 	br	200c048 <__alt_mem_mem_0+0xfcfec048>
 200c268:	04c00104 	movi	r19,4
 200c26c:	0021883a 	mov	r16,zero
 200c270:	0029883a 	mov	r20,zero
 200c274:	07000044 	movi	fp,1
 200c278:	003f6106 	br	200c000 <__alt_mem_mem_0+0xfcfec000>
 200c27c:	04c00304 	movi	r19,12
 200c280:	070000c4 	movi	fp,3
 200c284:	003f5e06 	br	200c000 <__alt_mem_mem_0+0xfcfec000>
 200c288:	01400434 	movhi	r5,16
 200c28c:	002b883a 	mov	r21,zero
 200c290:	297fffc4 	addi	r5,r5,-1
 200c294:	053fffc4 	movi	r20,-1
 200c298:	0081ffc4 	movi	r2,2047
 200c29c:	003f9806 	br	200c100 <__alt_mem_mem_0+0xfcfec100>
 200c2a0:	8023883a 	mov	r17,r16
 200c2a4:	a011883a 	mov	r8,r20
 200c2a8:	e00b883a 	mov	r5,fp
 200c2ac:	003f8a06 	br	200c0d8 <__alt_mem_mem_0+0xfcfec0d8>
 200c2b0:	8023883a 	mov	r17,r16
 200c2b4:	a011883a 	mov	r8,r20
 200c2b8:	482d883a 	mov	r22,r9
 200c2bc:	e00b883a 	mov	r5,fp
 200c2c0:	003f8506 	br	200c0d8 <__alt_mem_mem_0+0xfcfec0d8>
 200c2c4:	a00ad43a 	srli	r5,r20,16
 200c2c8:	401ad43a 	srli	r13,r8,16
 200c2cc:	a53fffcc 	andi	r20,r20,65535
 200c2d0:	423fffcc 	andi	r8,r8,65535
 200c2d4:	4519383a 	mul	r12,r8,r20
 200c2d8:	4147383a 	mul	r3,r8,r5
 200c2dc:	6d09383a 	mul	r4,r13,r20
 200c2e0:	600cd43a 	srli	r6,r12,16
 200c2e4:	2b5d383a 	mul	r14,r5,r13
 200c2e8:	20c9883a 	add	r4,r4,r3
 200c2ec:	310d883a 	add	r6,r6,r4
 200c2f0:	30c0022e 	bgeu	r6,r3,200c2fc <__muldf3+0x378>
 200c2f4:	00c00074 	movhi	r3,1
 200c2f8:	70dd883a 	add	r14,r14,r3
 200c2fc:	8826d43a 	srli	r19,r17,16
 200c300:	8bffffcc 	andi	r15,r17,65535
 200c304:	7d23383a 	mul	r17,r15,r20
 200c308:	7949383a 	mul	r4,r15,r5
 200c30c:	9d29383a 	mul	r20,r19,r20
 200c310:	8814d43a 	srli	r10,r17,16
 200c314:	3012943a 	slli	r9,r6,16
 200c318:	a129883a 	add	r20,r20,r4
 200c31c:	633fffcc 	andi	r12,r12,65535
 200c320:	5515883a 	add	r10,r10,r20
 200c324:	3006d43a 	srli	r3,r6,16
 200c328:	4b13883a 	add	r9,r9,r12
 200c32c:	2ccb383a 	mul	r5,r5,r19
 200c330:	5100022e 	bgeu	r10,r4,200c33c <__muldf3+0x3b8>
 200c334:	01000074 	movhi	r4,1
 200c338:	290b883a 	add	r5,r5,r4
 200c33c:	802ad43a 	srli	r21,r16,16
 200c340:	843fffcc 	andi	r16,r16,65535
 200c344:	440d383a 	mul	r6,r8,r16
 200c348:	4565383a 	mul	r18,r8,r21
 200c34c:	8349383a 	mul	r4,r16,r13
 200c350:	500e943a 	slli	r7,r10,16
 200c354:	3010d43a 	srli	r8,r6,16
 200c358:	5028d43a 	srli	r20,r10,16
 200c35c:	2489883a 	add	r4,r4,r18
 200c360:	8abfffcc 	andi	r10,r17,65535
 200c364:	3a95883a 	add	r10,r7,r10
 200c368:	4119883a 	add	r12,r8,r4
 200c36c:	a169883a 	add	r20,r20,r5
 200c370:	1a87883a 	add	r3,r3,r10
 200c374:	6d5b383a 	mul	r13,r13,r21
 200c378:	6480022e 	bgeu	r12,r18,200c384 <__muldf3+0x400>
 200c37c:	01000074 	movhi	r4,1
 200c380:	691b883a 	add	r13,r13,r4
 200c384:	7c25383a 	mul	r18,r15,r16
 200c388:	7d4b383a 	mul	r5,r15,r21
 200c38c:	84cf383a 	mul	r7,r16,r19
 200c390:	901ed43a 	srli	r15,r18,16
 200c394:	6008d43a 	srli	r4,r12,16
 200c398:	6010943a 	slli	r8,r12,16
 200c39c:	394f883a 	add	r7,r7,r5
 200c3a0:	333fffcc 	andi	r12,r6,65535
 200c3a4:	79df883a 	add	r15,r15,r7
 200c3a8:	235b883a 	add	r13,r4,r13
 200c3ac:	9d63383a 	mul	r17,r19,r21
 200c3b0:	4309883a 	add	r4,r8,r12
 200c3b4:	7940022e 	bgeu	r15,r5,200c3c0 <__muldf3+0x43c>
 200c3b8:	01400074 	movhi	r5,1
 200c3bc:	8963883a 	add	r17,r17,r5
 200c3c0:	780a943a 	slli	r5,r15,16
 200c3c4:	91bfffcc 	andi	r6,r18,65535
 200c3c8:	70c7883a 	add	r3,r14,r3
 200c3cc:	298d883a 	add	r6,r5,r6
 200c3d0:	1a8f803a 	cmpltu	r7,r3,r10
 200c3d4:	350b883a 	add	r5,r6,r20
 200c3d8:	20c7883a 	add	r3,r4,r3
 200c3dc:	3955883a 	add	r10,r7,r5
 200c3e0:	1909803a 	cmpltu	r4,r3,r4
 200c3e4:	6a91883a 	add	r8,r13,r10
 200c3e8:	780cd43a 	srli	r6,r15,16
 200c3ec:	2219883a 	add	r12,r4,r8
 200c3f0:	2d0b803a 	cmpltu	r5,r5,r20
 200c3f4:	51cf803a 	cmpltu	r7,r10,r7
 200c3f8:	29ceb03a 	or	r7,r5,r7
 200c3fc:	4351803a 	cmpltu	r8,r8,r13
 200c400:	610b803a 	cmpltu	r5,r12,r4
 200c404:	4148b03a 	or	r4,r8,r5
 200c408:	398f883a 	add	r7,r7,r6
 200c40c:	3909883a 	add	r4,r7,r4
 200c410:	1810927a 	slli	r8,r3,9
 200c414:	2449883a 	add	r4,r4,r17
 200c418:	2008927a 	slli	r4,r4,9
 200c41c:	6022d5fa 	srli	r17,r12,23
 200c420:	1806d5fa 	srli	r3,r3,23
 200c424:	4252b03a 	or	r9,r8,r9
 200c428:	600a927a 	slli	r5,r12,9
 200c42c:	4810c03a 	cmpne	r8,r9,zero
 200c430:	2462b03a 	or	r17,r4,r17
 200c434:	40c6b03a 	or	r3,r8,r3
 200c438:	8900402c 	andhi	r4,r17,256
 200c43c:	1950b03a 	or	r8,r3,r5
 200c440:	20000726 	beq	r4,zero,200c460 <__muldf3+0x4dc>
 200c444:	4006d07a 	srli	r3,r8,1
 200c448:	880497fa 	slli	r2,r17,31
 200c44c:	4200004c 	andi	r8,r8,1
 200c450:	8822d07a 	srli	r17,r17,1
 200c454:	1a10b03a 	or	r8,r3,r8
 200c458:	1210b03a 	or	r8,r2,r8
 200c45c:	5805883a 	mov	r2,r11
 200c460:	1140ffc4 	addi	r5,r2,1023
 200c464:	0140440e 	bge	zero,r5,200c578 <__muldf3+0x5f4>
 200c468:	40c001cc 	andi	r3,r8,7
 200c46c:	18000726 	beq	r3,zero,200c48c <__muldf3+0x508>
 200c470:	40c003cc 	andi	r3,r8,15
 200c474:	01000104 	movi	r4,4
 200c478:	19000426 	beq	r3,r4,200c48c <__muldf3+0x508>
 200c47c:	4107883a 	add	r3,r8,r4
 200c480:	1a11803a 	cmpltu	r8,r3,r8
 200c484:	8a23883a 	add	r17,r17,r8
 200c488:	1811883a 	mov	r8,r3
 200c48c:	88c0402c 	andhi	r3,r17,256
 200c490:	18000426 	beq	r3,zero,200c4a4 <__muldf3+0x520>
 200c494:	11410004 	addi	r5,r2,1024
 200c498:	00bfc034 	movhi	r2,65280
 200c49c:	10bfffc4 	addi	r2,r2,-1
 200c4a0:	88a2703a 	and	r17,r17,r2
 200c4a4:	0081ff84 	movi	r2,2046
 200c4a8:	117f6416 	blt	r2,r5,200c23c <__alt_mem_mem_0+0xfcfec23c>
 200c4ac:	8828977a 	slli	r20,r17,29
 200c4b0:	4010d0fa 	srli	r8,r8,3
 200c4b4:	8822927a 	slli	r17,r17,9
 200c4b8:	2881ffcc 	andi	r2,r5,2047
 200c4bc:	a228b03a 	or	r20,r20,r8
 200c4c0:	880ad33a 	srli	r5,r17,12
 200c4c4:	b02b883a 	mov	r21,r22
 200c4c8:	003f0d06 	br	200c100 <__alt_mem_mem_0+0xfcfec100>
 200c4cc:	8080022c 	andhi	r2,r16,8
 200c4d0:	10000926 	beq	r2,zero,200c4f8 <__muldf3+0x574>
 200c4d4:	8880022c 	andhi	r2,r17,8
 200c4d8:	1000071e 	bne	r2,zero,200c4f8 <__muldf3+0x574>
 200c4dc:	00800434 	movhi	r2,16
 200c4e0:	89400234 	orhi	r5,r17,8
 200c4e4:	10bfffc4 	addi	r2,r2,-1
 200c4e8:	b82b883a 	mov	r21,r23
 200c4ec:	288a703a 	and	r5,r5,r2
 200c4f0:	4029883a 	mov	r20,r8
 200c4f4:	003f6806 	br	200c298 <__alt_mem_mem_0+0xfcfec298>
 200c4f8:	00800434 	movhi	r2,16
 200c4fc:	81400234 	orhi	r5,r16,8
 200c500:	10bfffc4 	addi	r2,r2,-1
 200c504:	288a703a 	and	r5,r5,r2
 200c508:	003f6306 	br	200c298 <__alt_mem_mem_0+0xfcfec298>
 200c50c:	147ff604 	addi	r17,r2,-40
 200c510:	3462983a 	sll	r17,r6,r17
 200c514:	0011883a 	mov	r8,zero
 200c518:	003f4406 	br	200c22c <__alt_mem_mem_0+0xfcfec22c>
 200c51c:	3009883a 	mov	r4,r6
 200c520:	d9800215 	stw	r6,8(sp)
 200c524:	da400115 	stw	r9,4(sp)
 200c528:	da800015 	stw	r10,0(sp)
 200c52c:	200d19c0 	call	200d19c <__clzsi2>
 200c530:	10800804 	addi	r2,r2,32
 200c534:	da800017 	ldw	r10,0(sp)
 200c538:	da400117 	ldw	r9,4(sp)
 200c53c:	d9800217 	ldw	r6,8(sp)
 200c540:	003f3006 	br	200c204 <__alt_mem_mem_0+0xfcfec204>
 200c544:	143ff604 	addi	r16,r2,-40
 200c548:	9c20983a 	sll	r16,r19,r16
 200c54c:	0029883a 	mov	r20,zero
 200c550:	003f1606 	br	200c1ac <__alt_mem_mem_0+0xfcfec1ac>
 200c554:	d9800215 	stw	r6,8(sp)
 200c558:	d9c00015 	stw	r7,0(sp)
 200c55c:	da400115 	stw	r9,4(sp)
 200c560:	200d19c0 	call	200d19c <__clzsi2>
 200c564:	10800804 	addi	r2,r2,32
 200c568:	da400117 	ldw	r9,4(sp)
 200c56c:	d9c00017 	ldw	r7,0(sp)
 200c570:	d9800217 	ldw	r6,8(sp)
 200c574:	003f0306 	br	200c184 <__alt_mem_mem_0+0xfcfec184>
 200c578:	00c00044 	movi	r3,1
 200c57c:	1947c83a 	sub	r3,r3,r5
 200c580:	00800e04 	movi	r2,56
 200c584:	10feda16 	blt	r2,r3,200c0f0 <__alt_mem_mem_0+0xfcfec0f0>
 200c588:	008007c4 	movi	r2,31
 200c58c:	10c01b16 	blt	r2,r3,200c5fc <__muldf3+0x678>
 200c590:	00800804 	movi	r2,32
 200c594:	10c5c83a 	sub	r2,r2,r3
 200c598:	888a983a 	sll	r5,r17,r2
 200c59c:	40c8d83a 	srl	r4,r8,r3
 200c5a0:	4084983a 	sll	r2,r8,r2
 200c5a4:	88e2d83a 	srl	r17,r17,r3
 200c5a8:	2906b03a 	or	r3,r5,r4
 200c5ac:	1004c03a 	cmpne	r2,r2,zero
 200c5b0:	1886b03a 	or	r3,r3,r2
 200c5b4:	188001cc 	andi	r2,r3,7
 200c5b8:	10000726 	beq	r2,zero,200c5d8 <__muldf3+0x654>
 200c5bc:	188003cc 	andi	r2,r3,15
 200c5c0:	01000104 	movi	r4,4
 200c5c4:	11000426 	beq	r2,r4,200c5d8 <__muldf3+0x654>
 200c5c8:	1805883a 	mov	r2,r3
 200c5cc:	10c00104 	addi	r3,r2,4
 200c5d0:	1885803a 	cmpltu	r2,r3,r2
 200c5d4:	88a3883a 	add	r17,r17,r2
 200c5d8:	8880202c 	andhi	r2,r17,128
 200c5dc:	10001c26 	beq	r2,zero,200c650 <__muldf3+0x6cc>
 200c5e0:	b02b883a 	mov	r21,r22
 200c5e4:	00800044 	movi	r2,1
 200c5e8:	000b883a 	mov	r5,zero
 200c5ec:	0029883a 	mov	r20,zero
 200c5f0:	003ec306 	br	200c100 <__alt_mem_mem_0+0xfcfec100>
 200c5f4:	5805883a 	mov	r2,r11
 200c5f8:	003f9906 	br	200c460 <__alt_mem_mem_0+0xfcfec460>
 200c5fc:	00bff844 	movi	r2,-31
 200c600:	1145c83a 	sub	r2,r2,r5
 200c604:	8888d83a 	srl	r4,r17,r2
 200c608:	00800804 	movi	r2,32
 200c60c:	18801a26 	beq	r3,r2,200c678 <__muldf3+0x6f4>
 200c610:	00801004 	movi	r2,64
 200c614:	10c5c83a 	sub	r2,r2,r3
 200c618:	8884983a 	sll	r2,r17,r2
 200c61c:	1204b03a 	or	r2,r2,r8
 200c620:	1004c03a 	cmpne	r2,r2,zero
 200c624:	2084b03a 	or	r2,r4,r2
 200c628:	144001cc 	andi	r17,r2,7
 200c62c:	88000d1e 	bne	r17,zero,200c664 <__muldf3+0x6e0>
 200c630:	000b883a 	mov	r5,zero
 200c634:	1028d0fa 	srli	r20,r2,3
 200c638:	b02b883a 	mov	r21,r22
 200c63c:	0005883a 	mov	r2,zero
 200c640:	a468b03a 	or	r20,r20,r17
 200c644:	003eae06 	br	200c100 <__alt_mem_mem_0+0xfcfec100>
 200c648:	1007883a 	mov	r3,r2
 200c64c:	0023883a 	mov	r17,zero
 200c650:	880a927a 	slli	r5,r17,9
 200c654:	1805883a 	mov	r2,r3
 200c658:	8822977a 	slli	r17,r17,29
 200c65c:	280ad33a 	srli	r5,r5,12
 200c660:	003ff406 	br	200c634 <__alt_mem_mem_0+0xfcfec634>
 200c664:	10c003cc 	andi	r3,r2,15
 200c668:	01000104 	movi	r4,4
 200c66c:	193ff626 	beq	r3,r4,200c648 <__alt_mem_mem_0+0xfcfec648>
 200c670:	0023883a 	mov	r17,zero
 200c674:	003fd506 	br	200c5cc <__alt_mem_mem_0+0xfcfec5cc>
 200c678:	0005883a 	mov	r2,zero
 200c67c:	003fe706 	br	200c61c <__alt_mem_mem_0+0xfcfec61c>
 200c680:	00800434 	movhi	r2,16
 200c684:	89400234 	orhi	r5,r17,8
 200c688:	10bfffc4 	addi	r2,r2,-1
 200c68c:	b02b883a 	mov	r21,r22
 200c690:	288a703a 	and	r5,r5,r2
 200c694:	4029883a 	mov	r20,r8
 200c698:	003eff06 	br	200c298 <__alt_mem_mem_0+0xfcfec298>

0200c69c <__subdf3>:
 200c69c:	02000434 	movhi	r8,16
 200c6a0:	423fffc4 	addi	r8,r8,-1
 200c6a4:	defffb04 	addi	sp,sp,-20
 200c6a8:	2a14703a 	and	r10,r5,r8
 200c6ac:	3812d53a 	srli	r9,r7,20
 200c6b0:	3a10703a 	and	r8,r7,r8
 200c6b4:	2006d77a 	srli	r3,r4,29
 200c6b8:	3004d77a 	srli	r2,r6,29
 200c6bc:	dc000015 	stw	r16,0(sp)
 200c6c0:	501490fa 	slli	r10,r10,3
 200c6c4:	2820d53a 	srli	r16,r5,20
 200c6c8:	401090fa 	slli	r8,r8,3
 200c6cc:	dc800215 	stw	r18,8(sp)
 200c6d0:	dc400115 	stw	r17,4(sp)
 200c6d4:	dfc00415 	stw	ra,16(sp)
 200c6d8:	202290fa 	slli	r17,r4,3
 200c6dc:	dcc00315 	stw	r19,12(sp)
 200c6e0:	4a41ffcc 	andi	r9,r9,2047
 200c6e4:	0101ffc4 	movi	r4,2047
 200c6e8:	2824d7fa 	srli	r18,r5,31
 200c6ec:	8401ffcc 	andi	r16,r16,2047
 200c6f0:	50c6b03a 	or	r3,r10,r3
 200c6f4:	380ed7fa 	srli	r7,r7,31
 200c6f8:	408ab03a 	or	r5,r8,r2
 200c6fc:	300c90fa 	slli	r6,r6,3
 200c700:	49009626 	beq	r9,r4,200c95c <__subdf3+0x2c0>
 200c704:	39c0005c 	xori	r7,r7,1
 200c708:	8245c83a 	sub	r2,r16,r9
 200c70c:	3c807426 	beq	r7,r18,200c8e0 <__subdf3+0x244>
 200c710:	0080af0e 	bge	zero,r2,200c9d0 <__subdf3+0x334>
 200c714:	48002a1e 	bne	r9,zero,200c7c0 <__subdf3+0x124>
 200c718:	2988b03a 	or	r4,r5,r6
 200c71c:	20009a1e 	bne	r4,zero,200c988 <__subdf3+0x2ec>
 200c720:	888001cc 	andi	r2,r17,7
 200c724:	10000726 	beq	r2,zero,200c744 <__subdf3+0xa8>
 200c728:	888003cc 	andi	r2,r17,15
 200c72c:	01000104 	movi	r4,4
 200c730:	11000426 	beq	r2,r4,200c744 <__subdf3+0xa8>
 200c734:	890b883a 	add	r5,r17,r4
 200c738:	2c63803a 	cmpltu	r17,r5,r17
 200c73c:	1c47883a 	add	r3,r3,r17
 200c740:	2823883a 	mov	r17,r5
 200c744:	1880202c 	andhi	r2,r3,128
 200c748:	10005926 	beq	r2,zero,200c8b0 <__subdf3+0x214>
 200c74c:	84000044 	addi	r16,r16,1
 200c750:	0081ffc4 	movi	r2,2047
 200c754:	8080be26 	beq	r16,r2,200ca50 <__subdf3+0x3b4>
 200c758:	017fe034 	movhi	r5,65408
 200c75c:	297fffc4 	addi	r5,r5,-1
 200c760:	1946703a 	and	r3,r3,r5
 200c764:	1804977a 	slli	r2,r3,29
 200c768:	1806927a 	slli	r3,r3,9
 200c76c:	8822d0fa 	srli	r17,r17,3
 200c770:	8401ffcc 	andi	r16,r16,2047
 200c774:	180ad33a 	srli	r5,r3,12
 200c778:	9100004c 	andi	r4,r18,1
 200c77c:	1444b03a 	or	r2,r2,r17
 200c780:	80c1ffcc 	andi	r3,r16,2047
 200c784:	1820953a 	slli	r16,r3,20
 200c788:	20c03fcc 	andi	r3,r4,255
 200c78c:	180897fa 	slli	r4,r3,31
 200c790:	00c00434 	movhi	r3,16
 200c794:	18ffffc4 	addi	r3,r3,-1
 200c798:	28c6703a 	and	r3,r5,r3
 200c79c:	1c06b03a 	or	r3,r3,r16
 200c7a0:	1906b03a 	or	r3,r3,r4
 200c7a4:	dfc00417 	ldw	ra,16(sp)
 200c7a8:	dcc00317 	ldw	r19,12(sp)
 200c7ac:	dc800217 	ldw	r18,8(sp)
 200c7b0:	dc400117 	ldw	r17,4(sp)
 200c7b4:	dc000017 	ldw	r16,0(sp)
 200c7b8:	dec00504 	addi	sp,sp,20
 200c7bc:	f800283a 	ret
 200c7c0:	0101ffc4 	movi	r4,2047
 200c7c4:	813fd626 	beq	r16,r4,200c720 <__alt_mem_mem_0+0xfcfec720>
 200c7c8:	29402034 	orhi	r5,r5,128
 200c7cc:	01000e04 	movi	r4,56
 200c7d0:	2080a316 	blt	r4,r2,200ca60 <__subdf3+0x3c4>
 200c7d4:	010007c4 	movi	r4,31
 200c7d8:	2080c616 	blt	r4,r2,200caf4 <__subdf3+0x458>
 200c7dc:	01000804 	movi	r4,32
 200c7e0:	2089c83a 	sub	r4,r4,r2
 200c7e4:	2910983a 	sll	r8,r5,r4
 200c7e8:	308ed83a 	srl	r7,r6,r2
 200c7ec:	3108983a 	sll	r4,r6,r4
 200c7f0:	2884d83a 	srl	r2,r5,r2
 200c7f4:	41ccb03a 	or	r6,r8,r7
 200c7f8:	2008c03a 	cmpne	r4,r4,zero
 200c7fc:	310cb03a 	or	r6,r6,r4
 200c800:	898dc83a 	sub	r6,r17,r6
 200c804:	89a3803a 	cmpltu	r17,r17,r6
 200c808:	1887c83a 	sub	r3,r3,r2
 200c80c:	1c47c83a 	sub	r3,r3,r17
 200c810:	3023883a 	mov	r17,r6
 200c814:	1880202c 	andhi	r2,r3,128
 200c818:	10002326 	beq	r2,zero,200c8a8 <__subdf3+0x20c>
 200c81c:	04c02034 	movhi	r19,128
 200c820:	9cffffc4 	addi	r19,r19,-1
 200c824:	1ce6703a 	and	r19,r3,r19
 200c828:	98007a26 	beq	r19,zero,200ca14 <__subdf3+0x378>
 200c82c:	9809883a 	mov	r4,r19
 200c830:	200d19c0 	call	200d19c <__clzsi2>
 200c834:	113ffe04 	addi	r4,r2,-8
 200c838:	00c007c4 	movi	r3,31
 200c83c:	19007b16 	blt	r3,r4,200ca2c <__subdf3+0x390>
 200c840:	00800804 	movi	r2,32
 200c844:	1105c83a 	sub	r2,r2,r4
 200c848:	8884d83a 	srl	r2,r17,r2
 200c84c:	9906983a 	sll	r3,r19,r4
 200c850:	8922983a 	sll	r17,r17,r4
 200c854:	10c4b03a 	or	r2,r2,r3
 200c858:	24007816 	blt	r4,r16,200ca3c <__subdf3+0x3a0>
 200c85c:	2421c83a 	sub	r16,r4,r16
 200c860:	80c00044 	addi	r3,r16,1
 200c864:	010007c4 	movi	r4,31
 200c868:	20c09516 	blt	r4,r3,200cac0 <__subdf3+0x424>
 200c86c:	01400804 	movi	r5,32
 200c870:	28cbc83a 	sub	r5,r5,r3
 200c874:	88c8d83a 	srl	r4,r17,r3
 200c878:	8962983a 	sll	r17,r17,r5
 200c87c:	114a983a 	sll	r5,r2,r5
 200c880:	10c6d83a 	srl	r3,r2,r3
 200c884:	8804c03a 	cmpne	r2,r17,zero
 200c888:	290ab03a 	or	r5,r5,r4
 200c88c:	28a2b03a 	or	r17,r5,r2
 200c890:	0021883a 	mov	r16,zero
 200c894:	003fa206 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200c898:	2090b03a 	or	r8,r4,r2
 200c89c:	40018e26 	beq	r8,zero,200ced8 <__subdf3+0x83c>
 200c8a0:	1007883a 	mov	r3,r2
 200c8a4:	2023883a 	mov	r17,r4
 200c8a8:	888001cc 	andi	r2,r17,7
 200c8ac:	103f9e1e 	bne	r2,zero,200c728 <__alt_mem_mem_0+0xfcfec728>
 200c8b0:	1804977a 	slli	r2,r3,29
 200c8b4:	8822d0fa 	srli	r17,r17,3
 200c8b8:	1810d0fa 	srli	r8,r3,3
 200c8bc:	9100004c 	andi	r4,r18,1
 200c8c0:	1444b03a 	or	r2,r2,r17
 200c8c4:	00c1ffc4 	movi	r3,2047
 200c8c8:	80c02826 	beq	r16,r3,200c96c <__subdf3+0x2d0>
 200c8cc:	01400434 	movhi	r5,16
 200c8d0:	297fffc4 	addi	r5,r5,-1
 200c8d4:	80e0703a 	and	r16,r16,r3
 200c8d8:	414a703a 	and	r5,r8,r5
 200c8dc:	003fa806 	br	200c780 <__alt_mem_mem_0+0xfcfec780>
 200c8e0:	0080630e 	bge	zero,r2,200ca70 <__subdf3+0x3d4>
 200c8e4:	48003026 	beq	r9,zero,200c9a8 <__subdf3+0x30c>
 200c8e8:	0101ffc4 	movi	r4,2047
 200c8ec:	813f8c26 	beq	r16,r4,200c720 <__alt_mem_mem_0+0xfcfec720>
 200c8f0:	29402034 	orhi	r5,r5,128
 200c8f4:	01000e04 	movi	r4,56
 200c8f8:	2080a90e 	bge	r4,r2,200cba0 <__subdf3+0x504>
 200c8fc:	298cb03a 	or	r6,r5,r6
 200c900:	3012c03a 	cmpne	r9,r6,zero
 200c904:	0005883a 	mov	r2,zero
 200c908:	4c53883a 	add	r9,r9,r17
 200c90c:	4c63803a 	cmpltu	r17,r9,r17
 200c910:	10c7883a 	add	r3,r2,r3
 200c914:	88c7883a 	add	r3,r17,r3
 200c918:	4823883a 	mov	r17,r9
 200c91c:	1880202c 	andhi	r2,r3,128
 200c920:	1000d026 	beq	r2,zero,200cc64 <__subdf3+0x5c8>
 200c924:	84000044 	addi	r16,r16,1
 200c928:	0081ffc4 	movi	r2,2047
 200c92c:	8080fe26 	beq	r16,r2,200cd28 <__subdf3+0x68c>
 200c930:	00bfe034 	movhi	r2,65408
 200c934:	10bfffc4 	addi	r2,r2,-1
 200c938:	1886703a 	and	r3,r3,r2
 200c93c:	880ad07a 	srli	r5,r17,1
 200c940:	180497fa 	slli	r2,r3,31
 200c944:	8900004c 	andi	r4,r17,1
 200c948:	2922b03a 	or	r17,r5,r4
 200c94c:	1806d07a 	srli	r3,r3,1
 200c950:	1462b03a 	or	r17,r2,r17
 200c954:	3825883a 	mov	r18,r7
 200c958:	003f7106 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200c95c:	2984b03a 	or	r2,r5,r6
 200c960:	103f6826 	beq	r2,zero,200c704 <__alt_mem_mem_0+0xfcfec704>
 200c964:	39c03fcc 	andi	r7,r7,255
 200c968:	003f6706 	br	200c708 <__alt_mem_mem_0+0xfcfec708>
 200c96c:	4086b03a 	or	r3,r8,r2
 200c970:	18015226 	beq	r3,zero,200cebc <__subdf3+0x820>
 200c974:	00c00434 	movhi	r3,16
 200c978:	41400234 	orhi	r5,r8,8
 200c97c:	18ffffc4 	addi	r3,r3,-1
 200c980:	28ca703a 	and	r5,r5,r3
 200c984:	003f7e06 	br	200c780 <__alt_mem_mem_0+0xfcfec780>
 200c988:	10bfffc4 	addi	r2,r2,-1
 200c98c:	1000491e 	bne	r2,zero,200cab4 <__subdf3+0x418>
 200c990:	898fc83a 	sub	r7,r17,r6
 200c994:	89e3803a 	cmpltu	r17,r17,r7
 200c998:	1947c83a 	sub	r3,r3,r5
 200c99c:	1c47c83a 	sub	r3,r3,r17
 200c9a0:	3823883a 	mov	r17,r7
 200c9a4:	003f9b06 	br	200c814 <__alt_mem_mem_0+0xfcfec814>
 200c9a8:	2988b03a 	or	r4,r5,r6
 200c9ac:	203f5c26 	beq	r4,zero,200c720 <__alt_mem_mem_0+0xfcfec720>
 200c9b0:	10bfffc4 	addi	r2,r2,-1
 200c9b4:	1000931e 	bne	r2,zero,200cc04 <__subdf3+0x568>
 200c9b8:	898d883a 	add	r6,r17,r6
 200c9bc:	3463803a 	cmpltu	r17,r6,r17
 200c9c0:	1947883a 	add	r3,r3,r5
 200c9c4:	88c7883a 	add	r3,r17,r3
 200c9c8:	3023883a 	mov	r17,r6
 200c9cc:	003fd306 	br	200c91c <__alt_mem_mem_0+0xfcfec91c>
 200c9d0:	1000541e 	bne	r2,zero,200cb24 <__subdf3+0x488>
 200c9d4:	80800044 	addi	r2,r16,1
 200c9d8:	1081ffcc 	andi	r2,r2,2047
 200c9dc:	01000044 	movi	r4,1
 200c9e0:	2080a20e 	bge	r4,r2,200cc6c <__subdf3+0x5d0>
 200c9e4:	8989c83a 	sub	r4,r17,r6
 200c9e8:	8905803a 	cmpltu	r2,r17,r4
 200c9ec:	1967c83a 	sub	r19,r3,r5
 200c9f0:	98a7c83a 	sub	r19,r19,r2
 200c9f4:	9880202c 	andhi	r2,r19,128
 200c9f8:	10006326 	beq	r2,zero,200cb88 <__subdf3+0x4ec>
 200c9fc:	3463c83a 	sub	r17,r6,r17
 200ca00:	28c7c83a 	sub	r3,r5,r3
 200ca04:	344d803a 	cmpltu	r6,r6,r17
 200ca08:	19a7c83a 	sub	r19,r3,r6
 200ca0c:	3825883a 	mov	r18,r7
 200ca10:	983f861e 	bne	r19,zero,200c82c <__alt_mem_mem_0+0xfcfec82c>
 200ca14:	8809883a 	mov	r4,r17
 200ca18:	200d19c0 	call	200d19c <__clzsi2>
 200ca1c:	10800804 	addi	r2,r2,32
 200ca20:	113ffe04 	addi	r4,r2,-8
 200ca24:	00c007c4 	movi	r3,31
 200ca28:	193f850e 	bge	r3,r4,200c840 <__alt_mem_mem_0+0xfcfec840>
 200ca2c:	10bff604 	addi	r2,r2,-40
 200ca30:	8884983a 	sll	r2,r17,r2
 200ca34:	0023883a 	mov	r17,zero
 200ca38:	243f880e 	bge	r4,r16,200c85c <__alt_mem_mem_0+0xfcfec85c>
 200ca3c:	00ffe034 	movhi	r3,65408
 200ca40:	18ffffc4 	addi	r3,r3,-1
 200ca44:	8121c83a 	sub	r16,r16,r4
 200ca48:	10c6703a 	and	r3,r2,r3
 200ca4c:	003f3406 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200ca50:	9100004c 	andi	r4,r18,1
 200ca54:	000b883a 	mov	r5,zero
 200ca58:	0005883a 	mov	r2,zero
 200ca5c:	003f4806 	br	200c780 <__alt_mem_mem_0+0xfcfec780>
 200ca60:	298cb03a 	or	r6,r5,r6
 200ca64:	300cc03a 	cmpne	r6,r6,zero
 200ca68:	0005883a 	mov	r2,zero
 200ca6c:	003f6406 	br	200c800 <__alt_mem_mem_0+0xfcfec800>
 200ca70:	10009a1e 	bne	r2,zero,200ccdc <__subdf3+0x640>
 200ca74:	82400044 	addi	r9,r16,1
 200ca78:	4881ffcc 	andi	r2,r9,2047
 200ca7c:	02800044 	movi	r10,1
 200ca80:	5080670e 	bge	r10,r2,200cc20 <__subdf3+0x584>
 200ca84:	0081ffc4 	movi	r2,2047
 200ca88:	4880af26 	beq	r9,r2,200cd48 <__subdf3+0x6ac>
 200ca8c:	898d883a 	add	r6,r17,r6
 200ca90:	1945883a 	add	r2,r3,r5
 200ca94:	3447803a 	cmpltu	r3,r6,r17
 200ca98:	1887883a 	add	r3,r3,r2
 200ca9c:	182297fa 	slli	r17,r3,31
 200caa0:	300cd07a 	srli	r6,r6,1
 200caa4:	1806d07a 	srli	r3,r3,1
 200caa8:	4821883a 	mov	r16,r9
 200caac:	89a2b03a 	or	r17,r17,r6
 200cab0:	003f1b06 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cab4:	0101ffc4 	movi	r4,2047
 200cab8:	813f441e 	bne	r16,r4,200c7cc <__alt_mem_mem_0+0xfcfec7cc>
 200cabc:	003f1806 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cac0:	843ff844 	addi	r16,r16,-31
 200cac4:	01400804 	movi	r5,32
 200cac8:	1408d83a 	srl	r4,r2,r16
 200cacc:	19405026 	beq	r3,r5,200cc10 <__subdf3+0x574>
 200cad0:	01401004 	movi	r5,64
 200cad4:	28c7c83a 	sub	r3,r5,r3
 200cad8:	10c4983a 	sll	r2,r2,r3
 200cadc:	88a2b03a 	or	r17,r17,r2
 200cae0:	8822c03a 	cmpne	r17,r17,zero
 200cae4:	2462b03a 	or	r17,r4,r17
 200cae8:	0007883a 	mov	r3,zero
 200caec:	0021883a 	mov	r16,zero
 200caf0:	003f6d06 	br	200c8a8 <__alt_mem_mem_0+0xfcfec8a8>
 200caf4:	11fff804 	addi	r7,r2,-32
 200caf8:	01000804 	movi	r4,32
 200cafc:	29ced83a 	srl	r7,r5,r7
 200cb00:	11004526 	beq	r2,r4,200cc18 <__subdf3+0x57c>
 200cb04:	01001004 	movi	r4,64
 200cb08:	2089c83a 	sub	r4,r4,r2
 200cb0c:	2904983a 	sll	r2,r5,r4
 200cb10:	118cb03a 	or	r6,r2,r6
 200cb14:	300cc03a 	cmpne	r6,r6,zero
 200cb18:	398cb03a 	or	r6,r7,r6
 200cb1c:	0005883a 	mov	r2,zero
 200cb20:	003f3706 	br	200c800 <__alt_mem_mem_0+0xfcfec800>
 200cb24:	80002a26 	beq	r16,zero,200cbd0 <__subdf3+0x534>
 200cb28:	0101ffc4 	movi	r4,2047
 200cb2c:	49006626 	beq	r9,r4,200ccc8 <__subdf3+0x62c>
 200cb30:	0085c83a 	sub	r2,zero,r2
 200cb34:	18c02034 	orhi	r3,r3,128
 200cb38:	01000e04 	movi	r4,56
 200cb3c:	20807e16 	blt	r4,r2,200cd38 <__subdf3+0x69c>
 200cb40:	010007c4 	movi	r4,31
 200cb44:	2080e716 	blt	r4,r2,200cee4 <__subdf3+0x848>
 200cb48:	01000804 	movi	r4,32
 200cb4c:	2089c83a 	sub	r4,r4,r2
 200cb50:	1914983a 	sll	r10,r3,r4
 200cb54:	8890d83a 	srl	r8,r17,r2
 200cb58:	8908983a 	sll	r4,r17,r4
 200cb5c:	1884d83a 	srl	r2,r3,r2
 200cb60:	5222b03a 	or	r17,r10,r8
 200cb64:	2006c03a 	cmpne	r3,r4,zero
 200cb68:	88e2b03a 	or	r17,r17,r3
 200cb6c:	3463c83a 	sub	r17,r6,r17
 200cb70:	2885c83a 	sub	r2,r5,r2
 200cb74:	344d803a 	cmpltu	r6,r6,r17
 200cb78:	1187c83a 	sub	r3,r2,r6
 200cb7c:	4821883a 	mov	r16,r9
 200cb80:	3825883a 	mov	r18,r7
 200cb84:	003f2306 	br	200c814 <__alt_mem_mem_0+0xfcfec814>
 200cb88:	24d0b03a 	or	r8,r4,r19
 200cb8c:	40001b1e 	bne	r8,zero,200cbfc <__subdf3+0x560>
 200cb90:	0005883a 	mov	r2,zero
 200cb94:	0009883a 	mov	r4,zero
 200cb98:	0021883a 	mov	r16,zero
 200cb9c:	003f4906 	br	200c8c4 <__alt_mem_mem_0+0xfcfec8c4>
 200cba0:	010007c4 	movi	r4,31
 200cba4:	20803a16 	blt	r4,r2,200cc90 <__subdf3+0x5f4>
 200cba8:	01000804 	movi	r4,32
 200cbac:	2089c83a 	sub	r4,r4,r2
 200cbb0:	2912983a 	sll	r9,r5,r4
 200cbb4:	3090d83a 	srl	r8,r6,r2
 200cbb8:	3108983a 	sll	r4,r6,r4
 200cbbc:	2884d83a 	srl	r2,r5,r2
 200cbc0:	4a12b03a 	or	r9,r9,r8
 200cbc4:	2008c03a 	cmpne	r4,r4,zero
 200cbc8:	4912b03a 	or	r9,r9,r4
 200cbcc:	003f4e06 	br	200c908 <__alt_mem_mem_0+0xfcfec908>
 200cbd0:	1c48b03a 	or	r4,r3,r17
 200cbd4:	20003c26 	beq	r4,zero,200ccc8 <__subdf3+0x62c>
 200cbd8:	0084303a 	nor	r2,zero,r2
 200cbdc:	1000381e 	bne	r2,zero,200ccc0 <__subdf3+0x624>
 200cbe0:	3463c83a 	sub	r17,r6,r17
 200cbe4:	28c5c83a 	sub	r2,r5,r3
 200cbe8:	344d803a 	cmpltu	r6,r6,r17
 200cbec:	1187c83a 	sub	r3,r2,r6
 200cbf0:	4821883a 	mov	r16,r9
 200cbf4:	3825883a 	mov	r18,r7
 200cbf8:	003f0606 	br	200c814 <__alt_mem_mem_0+0xfcfec814>
 200cbfc:	2023883a 	mov	r17,r4
 200cc00:	003f0906 	br	200c828 <__alt_mem_mem_0+0xfcfec828>
 200cc04:	0101ffc4 	movi	r4,2047
 200cc08:	813f3a1e 	bne	r16,r4,200c8f4 <__alt_mem_mem_0+0xfcfec8f4>
 200cc0c:	003ec406 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cc10:	0005883a 	mov	r2,zero
 200cc14:	003fb106 	br	200cadc <__alt_mem_mem_0+0xfcfecadc>
 200cc18:	0005883a 	mov	r2,zero
 200cc1c:	003fbc06 	br	200cb10 <__alt_mem_mem_0+0xfcfecb10>
 200cc20:	1c44b03a 	or	r2,r3,r17
 200cc24:	80008e1e 	bne	r16,zero,200ce60 <__subdf3+0x7c4>
 200cc28:	1000c826 	beq	r2,zero,200cf4c <__subdf3+0x8b0>
 200cc2c:	2984b03a 	or	r2,r5,r6
 200cc30:	103ebb26 	beq	r2,zero,200c720 <__alt_mem_mem_0+0xfcfec720>
 200cc34:	8989883a 	add	r4,r17,r6
 200cc38:	1945883a 	add	r2,r3,r5
 200cc3c:	2447803a 	cmpltu	r3,r4,r17
 200cc40:	1887883a 	add	r3,r3,r2
 200cc44:	1880202c 	andhi	r2,r3,128
 200cc48:	2023883a 	mov	r17,r4
 200cc4c:	103f1626 	beq	r2,zero,200c8a8 <__alt_mem_mem_0+0xfcfec8a8>
 200cc50:	00bfe034 	movhi	r2,65408
 200cc54:	10bfffc4 	addi	r2,r2,-1
 200cc58:	5021883a 	mov	r16,r10
 200cc5c:	1886703a 	and	r3,r3,r2
 200cc60:	003eaf06 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cc64:	3825883a 	mov	r18,r7
 200cc68:	003f0f06 	br	200c8a8 <__alt_mem_mem_0+0xfcfec8a8>
 200cc6c:	1c44b03a 	or	r2,r3,r17
 200cc70:	8000251e 	bne	r16,zero,200cd08 <__subdf3+0x66c>
 200cc74:	1000661e 	bne	r2,zero,200ce10 <__subdf3+0x774>
 200cc78:	2990b03a 	or	r8,r5,r6
 200cc7c:	40009626 	beq	r8,zero,200ced8 <__subdf3+0x83c>
 200cc80:	2807883a 	mov	r3,r5
 200cc84:	3023883a 	mov	r17,r6
 200cc88:	3825883a 	mov	r18,r7
 200cc8c:	003ea406 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cc90:	127ff804 	addi	r9,r2,-32
 200cc94:	01000804 	movi	r4,32
 200cc98:	2a52d83a 	srl	r9,r5,r9
 200cc9c:	11008c26 	beq	r2,r4,200ced0 <__subdf3+0x834>
 200cca0:	01001004 	movi	r4,64
 200cca4:	2085c83a 	sub	r2,r4,r2
 200cca8:	2884983a 	sll	r2,r5,r2
 200ccac:	118cb03a 	or	r6,r2,r6
 200ccb0:	300cc03a 	cmpne	r6,r6,zero
 200ccb4:	4992b03a 	or	r9,r9,r6
 200ccb8:	0005883a 	mov	r2,zero
 200ccbc:	003f1206 	br	200c908 <__alt_mem_mem_0+0xfcfec908>
 200ccc0:	0101ffc4 	movi	r4,2047
 200ccc4:	493f9c1e 	bne	r9,r4,200cb38 <__alt_mem_mem_0+0xfcfecb38>
 200ccc8:	2807883a 	mov	r3,r5
 200cccc:	3023883a 	mov	r17,r6
 200ccd0:	4821883a 	mov	r16,r9
 200ccd4:	3825883a 	mov	r18,r7
 200ccd8:	003e9106 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200ccdc:	80001f1e 	bne	r16,zero,200cd5c <__subdf3+0x6c0>
 200cce0:	1c48b03a 	or	r4,r3,r17
 200cce4:	20005a26 	beq	r4,zero,200ce50 <__subdf3+0x7b4>
 200cce8:	0084303a 	nor	r2,zero,r2
 200ccec:	1000561e 	bne	r2,zero,200ce48 <__subdf3+0x7ac>
 200ccf0:	89a3883a 	add	r17,r17,r6
 200ccf4:	1945883a 	add	r2,r3,r5
 200ccf8:	898d803a 	cmpltu	r6,r17,r6
 200ccfc:	3087883a 	add	r3,r6,r2
 200cd00:	4821883a 	mov	r16,r9
 200cd04:	003f0506 	br	200c91c <__alt_mem_mem_0+0xfcfec91c>
 200cd08:	10002b1e 	bne	r2,zero,200cdb8 <__subdf3+0x71c>
 200cd0c:	2984b03a 	or	r2,r5,r6
 200cd10:	10008026 	beq	r2,zero,200cf14 <__subdf3+0x878>
 200cd14:	2807883a 	mov	r3,r5
 200cd18:	3023883a 	mov	r17,r6
 200cd1c:	3825883a 	mov	r18,r7
 200cd20:	0401ffc4 	movi	r16,2047
 200cd24:	003e7e06 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cd28:	3809883a 	mov	r4,r7
 200cd2c:	0011883a 	mov	r8,zero
 200cd30:	0005883a 	mov	r2,zero
 200cd34:	003ee306 	br	200c8c4 <__alt_mem_mem_0+0xfcfec8c4>
 200cd38:	1c62b03a 	or	r17,r3,r17
 200cd3c:	8822c03a 	cmpne	r17,r17,zero
 200cd40:	0005883a 	mov	r2,zero
 200cd44:	003f8906 	br	200cb6c <__alt_mem_mem_0+0xfcfecb6c>
 200cd48:	3809883a 	mov	r4,r7
 200cd4c:	4821883a 	mov	r16,r9
 200cd50:	0011883a 	mov	r8,zero
 200cd54:	0005883a 	mov	r2,zero
 200cd58:	003eda06 	br	200c8c4 <__alt_mem_mem_0+0xfcfec8c4>
 200cd5c:	0101ffc4 	movi	r4,2047
 200cd60:	49003b26 	beq	r9,r4,200ce50 <__subdf3+0x7b4>
 200cd64:	0085c83a 	sub	r2,zero,r2
 200cd68:	18c02034 	orhi	r3,r3,128
 200cd6c:	01000e04 	movi	r4,56
 200cd70:	20806e16 	blt	r4,r2,200cf2c <__subdf3+0x890>
 200cd74:	010007c4 	movi	r4,31
 200cd78:	20807716 	blt	r4,r2,200cf58 <__subdf3+0x8bc>
 200cd7c:	01000804 	movi	r4,32
 200cd80:	2089c83a 	sub	r4,r4,r2
 200cd84:	1914983a 	sll	r10,r3,r4
 200cd88:	8890d83a 	srl	r8,r17,r2
 200cd8c:	8908983a 	sll	r4,r17,r4
 200cd90:	1884d83a 	srl	r2,r3,r2
 200cd94:	5222b03a 	or	r17,r10,r8
 200cd98:	2006c03a 	cmpne	r3,r4,zero
 200cd9c:	88e2b03a 	or	r17,r17,r3
 200cda0:	89a3883a 	add	r17,r17,r6
 200cda4:	1145883a 	add	r2,r2,r5
 200cda8:	898d803a 	cmpltu	r6,r17,r6
 200cdac:	3087883a 	add	r3,r6,r2
 200cdb0:	4821883a 	mov	r16,r9
 200cdb4:	003ed906 	br	200c91c <__alt_mem_mem_0+0xfcfec91c>
 200cdb8:	2984b03a 	or	r2,r5,r6
 200cdbc:	10004226 	beq	r2,zero,200cec8 <__subdf3+0x82c>
 200cdc0:	1808d0fa 	srli	r4,r3,3
 200cdc4:	8822d0fa 	srli	r17,r17,3
 200cdc8:	1806977a 	slli	r3,r3,29
 200cdcc:	2080022c 	andhi	r2,r4,8
 200cdd0:	1c62b03a 	or	r17,r3,r17
 200cdd4:	10000826 	beq	r2,zero,200cdf8 <__subdf3+0x75c>
 200cdd8:	2812d0fa 	srli	r9,r5,3
 200cddc:	4880022c 	andhi	r2,r9,8
 200cde0:	1000051e 	bne	r2,zero,200cdf8 <__subdf3+0x75c>
 200cde4:	300cd0fa 	srli	r6,r6,3
 200cde8:	2804977a 	slli	r2,r5,29
 200cdec:	4809883a 	mov	r4,r9
 200cdf0:	3825883a 	mov	r18,r7
 200cdf4:	11a2b03a 	or	r17,r2,r6
 200cdf8:	8806d77a 	srli	r3,r17,29
 200cdfc:	200890fa 	slli	r4,r4,3
 200ce00:	882290fa 	slli	r17,r17,3
 200ce04:	0401ffc4 	movi	r16,2047
 200ce08:	1906b03a 	or	r3,r3,r4
 200ce0c:	003e4406 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200ce10:	2984b03a 	or	r2,r5,r6
 200ce14:	103e4226 	beq	r2,zero,200c720 <__alt_mem_mem_0+0xfcfec720>
 200ce18:	8989c83a 	sub	r4,r17,r6
 200ce1c:	8911803a 	cmpltu	r8,r17,r4
 200ce20:	1945c83a 	sub	r2,r3,r5
 200ce24:	1205c83a 	sub	r2,r2,r8
 200ce28:	1200202c 	andhi	r8,r2,128
 200ce2c:	403e9a26 	beq	r8,zero,200c898 <__alt_mem_mem_0+0xfcfec898>
 200ce30:	3463c83a 	sub	r17,r6,r17
 200ce34:	28c5c83a 	sub	r2,r5,r3
 200ce38:	344d803a 	cmpltu	r6,r6,r17
 200ce3c:	1187c83a 	sub	r3,r2,r6
 200ce40:	3825883a 	mov	r18,r7
 200ce44:	003e3606 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200ce48:	0101ffc4 	movi	r4,2047
 200ce4c:	493fc71e 	bne	r9,r4,200cd6c <__alt_mem_mem_0+0xfcfecd6c>
 200ce50:	2807883a 	mov	r3,r5
 200ce54:	3023883a 	mov	r17,r6
 200ce58:	4821883a 	mov	r16,r9
 200ce5c:	003e3006 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200ce60:	10003626 	beq	r2,zero,200cf3c <__subdf3+0x8a0>
 200ce64:	2984b03a 	or	r2,r5,r6
 200ce68:	10001726 	beq	r2,zero,200cec8 <__subdf3+0x82c>
 200ce6c:	1808d0fa 	srli	r4,r3,3
 200ce70:	8822d0fa 	srli	r17,r17,3
 200ce74:	1806977a 	slli	r3,r3,29
 200ce78:	2080022c 	andhi	r2,r4,8
 200ce7c:	1c62b03a 	or	r17,r3,r17
 200ce80:	10000726 	beq	r2,zero,200cea0 <__subdf3+0x804>
 200ce84:	2812d0fa 	srli	r9,r5,3
 200ce88:	4880022c 	andhi	r2,r9,8
 200ce8c:	1000041e 	bne	r2,zero,200cea0 <__subdf3+0x804>
 200ce90:	300cd0fa 	srli	r6,r6,3
 200ce94:	2804977a 	slli	r2,r5,29
 200ce98:	4809883a 	mov	r4,r9
 200ce9c:	11a2b03a 	or	r17,r2,r6
 200cea0:	8806d77a 	srli	r3,r17,29
 200cea4:	200890fa 	slli	r4,r4,3
 200cea8:	882290fa 	slli	r17,r17,3
 200ceac:	3825883a 	mov	r18,r7
 200ceb0:	1906b03a 	or	r3,r3,r4
 200ceb4:	0401ffc4 	movi	r16,2047
 200ceb8:	003e1906 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cebc:	000b883a 	mov	r5,zero
 200cec0:	0005883a 	mov	r2,zero
 200cec4:	003e2e06 	br	200c780 <__alt_mem_mem_0+0xfcfec780>
 200cec8:	0401ffc4 	movi	r16,2047
 200cecc:	003e1406 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200ced0:	0005883a 	mov	r2,zero
 200ced4:	003f7506 	br	200ccac <__alt_mem_mem_0+0xfcfeccac>
 200ced8:	0005883a 	mov	r2,zero
 200cedc:	0009883a 	mov	r4,zero
 200cee0:	003e7806 	br	200c8c4 <__alt_mem_mem_0+0xfcfec8c4>
 200cee4:	123ff804 	addi	r8,r2,-32
 200cee8:	01000804 	movi	r4,32
 200ceec:	1a10d83a 	srl	r8,r3,r8
 200cef0:	11002526 	beq	r2,r4,200cf88 <__subdf3+0x8ec>
 200cef4:	01001004 	movi	r4,64
 200cef8:	2085c83a 	sub	r2,r4,r2
 200cefc:	1884983a 	sll	r2,r3,r2
 200cf00:	1444b03a 	or	r2,r2,r17
 200cf04:	1004c03a 	cmpne	r2,r2,zero
 200cf08:	40a2b03a 	or	r17,r8,r2
 200cf0c:	0005883a 	mov	r2,zero
 200cf10:	003f1606 	br	200cb6c <__alt_mem_mem_0+0xfcfecb6c>
 200cf14:	02000434 	movhi	r8,16
 200cf18:	0009883a 	mov	r4,zero
 200cf1c:	423fffc4 	addi	r8,r8,-1
 200cf20:	00bfffc4 	movi	r2,-1
 200cf24:	0401ffc4 	movi	r16,2047
 200cf28:	003e6606 	br	200c8c4 <__alt_mem_mem_0+0xfcfec8c4>
 200cf2c:	1c62b03a 	or	r17,r3,r17
 200cf30:	8822c03a 	cmpne	r17,r17,zero
 200cf34:	0005883a 	mov	r2,zero
 200cf38:	003f9906 	br	200cda0 <__alt_mem_mem_0+0xfcfecda0>
 200cf3c:	2807883a 	mov	r3,r5
 200cf40:	3023883a 	mov	r17,r6
 200cf44:	0401ffc4 	movi	r16,2047
 200cf48:	003df506 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cf4c:	2807883a 	mov	r3,r5
 200cf50:	3023883a 	mov	r17,r6
 200cf54:	003df206 	br	200c720 <__alt_mem_mem_0+0xfcfec720>
 200cf58:	123ff804 	addi	r8,r2,-32
 200cf5c:	01000804 	movi	r4,32
 200cf60:	1a10d83a 	srl	r8,r3,r8
 200cf64:	11000a26 	beq	r2,r4,200cf90 <__subdf3+0x8f4>
 200cf68:	01001004 	movi	r4,64
 200cf6c:	2085c83a 	sub	r2,r4,r2
 200cf70:	1884983a 	sll	r2,r3,r2
 200cf74:	1444b03a 	or	r2,r2,r17
 200cf78:	1004c03a 	cmpne	r2,r2,zero
 200cf7c:	40a2b03a 	or	r17,r8,r2
 200cf80:	0005883a 	mov	r2,zero
 200cf84:	003f8606 	br	200cda0 <__alt_mem_mem_0+0xfcfecda0>
 200cf88:	0005883a 	mov	r2,zero
 200cf8c:	003fdc06 	br	200cf00 <__alt_mem_mem_0+0xfcfecf00>
 200cf90:	0005883a 	mov	r2,zero
 200cf94:	003ff706 	br	200cf74 <__alt_mem_mem_0+0xfcfecf74>

0200cf98 <__fixdfsi>:
 200cf98:	280cd53a 	srli	r6,r5,20
 200cf9c:	00c00434 	movhi	r3,16
 200cfa0:	18ffffc4 	addi	r3,r3,-1
 200cfa4:	3181ffcc 	andi	r6,r6,2047
 200cfa8:	01c0ff84 	movi	r7,1022
 200cfac:	28c6703a 	and	r3,r5,r3
 200cfb0:	280ad7fa 	srli	r5,r5,31
 200cfb4:	3980120e 	bge	r7,r6,200d000 <__fixdfsi+0x68>
 200cfb8:	00810744 	movi	r2,1053
 200cfbc:	11800c16 	blt	r2,r6,200cff0 <__fixdfsi+0x58>
 200cfc0:	00810cc4 	movi	r2,1075
 200cfc4:	1185c83a 	sub	r2,r2,r6
 200cfc8:	01c007c4 	movi	r7,31
 200cfcc:	18c00434 	orhi	r3,r3,16
 200cfd0:	38800d16 	blt	r7,r2,200d008 <__fixdfsi+0x70>
 200cfd4:	31befb44 	addi	r6,r6,-1043
 200cfd8:	2084d83a 	srl	r2,r4,r2
 200cfdc:	1986983a 	sll	r3,r3,r6
 200cfe0:	1884b03a 	or	r2,r3,r2
 200cfe4:	28000726 	beq	r5,zero,200d004 <__fixdfsi+0x6c>
 200cfe8:	0085c83a 	sub	r2,zero,r2
 200cfec:	f800283a 	ret
 200cff0:	00a00034 	movhi	r2,32768
 200cff4:	10bfffc4 	addi	r2,r2,-1
 200cff8:	2885883a 	add	r2,r5,r2
 200cffc:	f800283a 	ret
 200d000:	0005883a 	mov	r2,zero
 200d004:	f800283a 	ret
 200d008:	008104c4 	movi	r2,1043
 200d00c:	1185c83a 	sub	r2,r2,r6
 200d010:	1884d83a 	srl	r2,r3,r2
 200d014:	003ff306 	br	200cfe4 <__alt_mem_mem_0+0xfcfecfe4>

0200d018 <__floatsidf>:
 200d018:	defffd04 	addi	sp,sp,-12
 200d01c:	dfc00215 	stw	ra,8(sp)
 200d020:	dc400115 	stw	r17,4(sp)
 200d024:	dc000015 	stw	r16,0(sp)
 200d028:	20002b26 	beq	r4,zero,200d0d8 <__floatsidf+0xc0>
 200d02c:	2023883a 	mov	r17,r4
 200d030:	2020d7fa 	srli	r16,r4,31
 200d034:	20002d16 	blt	r4,zero,200d0ec <__floatsidf+0xd4>
 200d038:	8809883a 	mov	r4,r17
 200d03c:	200d19c0 	call	200d19c <__clzsi2>
 200d040:	01410784 	movi	r5,1054
 200d044:	288bc83a 	sub	r5,r5,r2
 200d048:	01010cc4 	movi	r4,1075
 200d04c:	2149c83a 	sub	r4,r4,r5
 200d050:	00c007c4 	movi	r3,31
 200d054:	1900160e 	bge	r3,r4,200d0b0 <__floatsidf+0x98>
 200d058:	00c104c4 	movi	r3,1043
 200d05c:	1947c83a 	sub	r3,r3,r5
 200d060:	88c6983a 	sll	r3,r17,r3
 200d064:	00800434 	movhi	r2,16
 200d068:	10bfffc4 	addi	r2,r2,-1
 200d06c:	1886703a 	and	r3,r3,r2
 200d070:	2941ffcc 	andi	r5,r5,2047
 200d074:	800d883a 	mov	r6,r16
 200d078:	0005883a 	mov	r2,zero
 200d07c:	280a953a 	slli	r5,r5,20
 200d080:	31803fcc 	andi	r6,r6,255
 200d084:	01000434 	movhi	r4,16
 200d088:	300c97fa 	slli	r6,r6,31
 200d08c:	213fffc4 	addi	r4,r4,-1
 200d090:	1906703a 	and	r3,r3,r4
 200d094:	1946b03a 	or	r3,r3,r5
 200d098:	1986b03a 	or	r3,r3,r6
 200d09c:	dfc00217 	ldw	ra,8(sp)
 200d0a0:	dc400117 	ldw	r17,4(sp)
 200d0a4:	dc000017 	ldw	r16,0(sp)
 200d0a8:	dec00304 	addi	sp,sp,12
 200d0ac:	f800283a 	ret
 200d0b0:	00c002c4 	movi	r3,11
 200d0b4:	1887c83a 	sub	r3,r3,r2
 200d0b8:	88c6d83a 	srl	r3,r17,r3
 200d0bc:	8904983a 	sll	r2,r17,r4
 200d0c0:	01000434 	movhi	r4,16
 200d0c4:	213fffc4 	addi	r4,r4,-1
 200d0c8:	2941ffcc 	andi	r5,r5,2047
 200d0cc:	1906703a 	and	r3,r3,r4
 200d0d0:	800d883a 	mov	r6,r16
 200d0d4:	003fe906 	br	200d07c <__alt_mem_mem_0+0xfcfed07c>
 200d0d8:	000d883a 	mov	r6,zero
 200d0dc:	000b883a 	mov	r5,zero
 200d0e0:	0007883a 	mov	r3,zero
 200d0e4:	0005883a 	mov	r2,zero
 200d0e8:	003fe406 	br	200d07c <__alt_mem_mem_0+0xfcfed07c>
 200d0ec:	0123c83a 	sub	r17,zero,r4
 200d0f0:	003fd106 	br	200d038 <__alt_mem_mem_0+0xfcfed038>

0200d0f4 <__floatunsidf>:
 200d0f4:	defffe04 	addi	sp,sp,-8
 200d0f8:	dc000015 	stw	r16,0(sp)
 200d0fc:	dfc00115 	stw	ra,4(sp)
 200d100:	2021883a 	mov	r16,r4
 200d104:	20002226 	beq	r4,zero,200d190 <__floatunsidf+0x9c>
 200d108:	200d19c0 	call	200d19c <__clzsi2>
 200d10c:	01010784 	movi	r4,1054
 200d110:	2089c83a 	sub	r4,r4,r2
 200d114:	01810cc4 	movi	r6,1075
 200d118:	310dc83a 	sub	r6,r6,r4
 200d11c:	00c007c4 	movi	r3,31
 200d120:	1980120e 	bge	r3,r6,200d16c <__floatunsidf+0x78>
 200d124:	00c104c4 	movi	r3,1043
 200d128:	1907c83a 	sub	r3,r3,r4
 200d12c:	80ca983a 	sll	r5,r16,r3
 200d130:	00800434 	movhi	r2,16
 200d134:	10bfffc4 	addi	r2,r2,-1
 200d138:	2101ffcc 	andi	r4,r4,2047
 200d13c:	0021883a 	mov	r16,zero
 200d140:	288a703a 	and	r5,r5,r2
 200d144:	2008953a 	slli	r4,r4,20
 200d148:	00c00434 	movhi	r3,16
 200d14c:	18ffffc4 	addi	r3,r3,-1
 200d150:	28c6703a 	and	r3,r5,r3
 200d154:	8005883a 	mov	r2,r16
 200d158:	1906b03a 	or	r3,r3,r4
 200d15c:	dfc00117 	ldw	ra,4(sp)
 200d160:	dc000017 	ldw	r16,0(sp)
 200d164:	dec00204 	addi	sp,sp,8
 200d168:	f800283a 	ret
 200d16c:	00c002c4 	movi	r3,11
 200d170:	188bc83a 	sub	r5,r3,r2
 200d174:	814ad83a 	srl	r5,r16,r5
 200d178:	00c00434 	movhi	r3,16
 200d17c:	18ffffc4 	addi	r3,r3,-1
 200d180:	81a0983a 	sll	r16,r16,r6
 200d184:	2101ffcc 	andi	r4,r4,2047
 200d188:	28ca703a 	and	r5,r5,r3
 200d18c:	003fed06 	br	200d144 <__alt_mem_mem_0+0xfcfed144>
 200d190:	0009883a 	mov	r4,zero
 200d194:	000b883a 	mov	r5,zero
 200d198:	003fea06 	br	200d144 <__alt_mem_mem_0+0xfcfed144>

0200d19c <__clzsi2>:
 200d19c:	00bfffd4 	movui	r2,65535
 200d1a0:	11000536 	bltu	r2,r4,200d1b8 <__clzsi2+0x1c>
 200d1a4:	00803fc4 	movi	r2,255
 200d1a8:	11000f36 	bltu	r2,r4,200d1e8 <__clzsi2+0x4c>
 200d1ac:	00800804 	movi	r2,32
 200d1b0:	0007883a 	mov	r3,zero
 200d1b4:	00000506 	br	200d1cc <__clzsi2+0x30>
 200d1b8:	00804034 	movhi	r2,256
 200d1bc:	10bfffc4 	addi	r2,r2,-1
 200d1c0:	11000c2e 	bgeu	r2,r4,200d1f4 <__clzsi2+0x58>
 200d1c4:	00800204 	movi	r2,8
 200d1c8:	00c00604 	movi	r3,24
 200d1cc:	20c8d83a 	srl	r4,r4,r3
 200d1d0:	00c08134 	movhi	r3,516
 200d1d4:	18daee04 	addi	r3,r3,27576
 200d1d8:	1909883a 	add	r4,r3,r4
 200d1dc:	20c00003 	ldbu	r3,0(r4)
 200d1e0:	10c5c83a 	sub	r2,r2,r3
 200d1e4:	f800283a 	ret
 200d1e8:	00800604 	movi	r2,24
 200d1ec:	00c00204 	movi	r3,8
 200d1f0:	003ff606 	br	200d1cc <__alt_mem_mem_0+0xfcfed1cc>
 200d1f4:	00800404 	movi	r2,16
 200d1f8:	1007883a 	mov	r3,r2
 200d1fc:	003ff306 	br	200d1cc <__alt_mem_mem_0+0xfcfed1cc>

0200d200 <pre_constructors>:
/*
 * We want this pre_constructors and post_constructors functions to be called when it is defined by the user, if the user didn't define it
 * we don't want a link error, just call this empty function
 */
void __attribute__((weak)) pre_constructors()
{
 200d200:	deffff04 	addi	sp,sp,-4
 200d204:	df000015 	stw	fp,0(sp)
 200d208:	d839883a 	mov	fp,sp
	// nothing to do here... may be overloaded by the application
}
 200d20c:	0001883a 	nop
 200d210:	e037883a 	mov	sp,fp
 200d214:	df000017 	ldw	fp,0(sp)
 200d218:	dec00104 	addi	sp,sp,4
 200d21c:	f800283a 	ret

0200d220 <post_constructors>:

void __attribute__((weak)) post_constructors()
{
 200d220:	deffff04 	addi	sp,sp,-4
 200d224:	df000015 	stw	fp,0(sp)
 200d228:	d839883a 	mov	fp,sp
	// nothing to do here... may be overloaded by the application
}
 200d22c:	0001883a 	nop
 200d230:	e037883a 	mov	sp,fp
 200d234:	df000017 	ldw	fp,0(sp)
 200d238:	dec00104 	addi	sp,sp,4
 200d23c:	f800283a 	ret

0200d240 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 200d240:	defff904 	addi	sp,sp,-28
 200d244:	dfc00615 	stw	ra,24(sp)
 200d248:	df000515 	stw	fp,20(sp)
 200d24c:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 200d250:	0009883a 	mov	r4,zero
 200d254:	202b0f80 	call	202b0f8 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 200d258:	01000104 	movi	r4,4
 200d25c:	200d6680 	call	200d668 <xQueueCreateMutex>
 200d260:	d0a7a815 	stw	r2,-24928(gp)
 200d264:	01000104 	movi	r4,4
 200d268:	200d6680 	call	200d668 <xQueueCreateMutex>
 200d26c:	d0a7f415 	stw	r2,-24624(gp)
 200d270:	d0a7bd04 	addi	r2,gp,-24844
 200d274:	e0bffc15 	stw	r2,-16(fp)
 200d278:	00800044 	movi	r2,1
 200d27c:	e0bffd0d 	sth	r2,-12(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 200d280:	e0bffd0b 	ldhu	r2,-12(fp)
 200d284:	10000226 	beq	r2,zero,200d290 <alt_main+0x50>
 200d288:	e0bffd0b 	ldhu	r2,-12(fp)
 200d28c:	00000106 	br	200d294 <alt_main+0x54>
 200d290:	00800044 	movi	r2,1
 200d294:	e0fffd0b 	ldhu	r3,-12(fp)
 200d298:	180b883a 	mov	r5,r3
 200d29c:	1009883a 	mov	r4,r2
 200d2a0:	200d7f00 	call	200d7f0 <xQueueCreateCountingSemaphore>
 200d2a4:	1007883a 	mov	r3,r2
 200d2a8:	e0bffc17 	ldw	r2,-16(fp)
 200d2ac:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 200d2b0:	202b1300 	call	202b130 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 200d2b4:	01808134 	movhi	r6,516
 200d2b8:	319b2e04 	addi	r6,r6,27832
 200d2bc:	01408134 	movhi	r5,516
 200d2c0:	295b2e04 	addi	r5,r5,27832
 200d2c4:	01008134 	movhi	r4,516
 200d2c8:	211b2e04 	addi	r4,r4,27832
 200d2cc:	20127140 	call	2012714 <alt_io_redirect>
#endif

  /*
   * Call the pre_constructors function
   */
  pre_constructors();
 200d2d0:	200d2000 	call	200d200 <pre_constructors>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 200d2d4:	20124a40 	call	20124a4 <_do_ctors>
#endif /* ALT_NO_C_PLUS_PLUS */

  /*
   * Call the post_constructors function
   */
  post_constructors();
 200d2d8:	200d2200 	call	200d220 <post_constructors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 200d2dc:	01008074 	movhi	r4,513
 200d2e0:	21094104 	addi	r4,r4,9476
 200d2e4:	204238c0 	call	204238c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 200d2e8:	d0a7a517 	ldw	r2,-24940(gp)
 200d2ec:	d0e7a617 	ldw	r3,-24936(gp)
 200d2f0:	d127a717 	ldw	r4,-24932(gp)
 200d2f4:	200d883a 	mov	r6,r4
 200d2f8:	180b883a 	mov	r5,r3
 200d2fc:	1009883a 	mov	r4,r2
 200d300:	20008d00 	call	20008d0 <main>
 200d304:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 200d308:	01000044 	movi	r4,1
 200d30c:	201303c0 	call	201303c <close>
  exit (result);
 200d310:	e13ffb17 	ldw	r4,-20(fp)
 200d314:	20423c80 	call	20423c8 <exit>

0200d318 <__malloc_lock>:
xSemaphoreHandle alt_heapsem;

/* __malloc_lock needs to provide recursive mutex locking */

void __malloc_lock ( struct _reent *_r )
{
 200d318:	defffd04 	addi	sp,sp,-12
 200d31c:	dfc00215 	stw	ra,8(sp)
 200d320:	df000115 	stw	fp,4(sp)
 200d324:	df000104 	addi	fp,sp,4
 200d328:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 200d32c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d330:	10000b26 	beq	r2,zero,200d360 <__malloc_lock+0x48>
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
 200d334:	00000206 	br	200d340 <__malloc_lock+0x28>
		vTaskDelay(1);
 200d338:	01000044 	movi	r4,1
 200d33c:	200f0980 	call	200f098 <vTaskDelay>
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
 200d340:	d0a7a817 	ldw	r2,-24928(gp)
 200d344:	01400284 	movi	r5,10
 200d348:	1009883a 	mov	r4,r2
 200d34c:	200d7540 	call	200d754 <xQueueTakeMutexRecursive>
 200d350:	10800058 	cmpnei	r2,r2,1
 200d354:	103ff81e 	bne	r2,zero,200d338 <__alt_mem_mem_0+0xfcfed338>
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
 200d358:	0001883a 	nop
 200d35c:	00000106 	br	200d364 <__malloc_lock+0x4c>

void __malloc_lock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 200d360:	0001883a 	nop
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
}
 200d364:	e037883a 	mov	sp,fp
 200d368:	dfc00117 	ldw	ra,4(sp)
 200d36c:	df000017 	ldw	fp,0(sp)
 200d370:	dec00204 	addi	sp,sp,8
 200d374:	f800283a 	ret

0200d378 <__malloc_unlock>:

/* __malloc_unlock needs to provide recursive mutex unlocking */

void __malloc_unlock ( struct _reent *_r )
{
 200d378:	defffd04 	addi	sp,sp,-12
 200d37c:	dfc00215 	stw	ra,8(sp)
 200d380:	df000115 	stw	fp,4(sp)
 200d384:	df000104 	addi	fp,sp,4
 200d388:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 200d38c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d390:	10000426 	beq	r2,zero,200d3a4 <__malloc_unlock+0x2c>
		return;
	  
	xSemaphoreGiveRecursive(alt_heapsem);
 200d394:	d0a7a817 	ldw	r2,-24928(gp)
 200d398:	1009883a 	mov	r4,r2
 200d39c:	200d6c40 	call	200d6c4 <xQueueGiveMutexRecursive>
 200d3a0:	00000106 	br	200d3a8 <__malloc_unlock+0x30>

void __malloc_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 200d3a4:	0001883a 	nop
	  
	xSemaphoreGiveRecursive(alt_heapsem);
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 200d3a8:	e037883a 	mov	sp,fp
 200d3ac:	dfc00117 	ldw	ra,4(sp)
 200d3b0:	df000017 	ldw	fp,0(sp)
 200d3b4:	dec00204 	addi	sp,sp,8
 200d3b8:	f800283a 	ret

0200d3bc <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 200d3bc:	defffb04 	addi	sp,sp,-20
 200d3c0:	dfc00415 	stw	ra,16(sp)
 200d3c4:	df000315 	stw	fp,12(sp)
 200d3c8:	df000304 	addi	fp,sp,12
 200d3cc:	e13ffe15 	stw	r4,-8(fp)
 200d3d0:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = xQueue;
 200d3d4:	e0bffe17 	ldw	r2,-8(fp)
 200d3d8:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 200d3dc:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d3e0:	10000126 	beq	r2,zero,200d3e8 <xQueueGenericReset+0x2c>
 200d3e4:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 200d3e8:	e0bffd17 	ldw	r2,-12(fp)
 200d3ec:	10c00017 	ldw	r3,0(r2)
 200d3f0:	e0bffd17 	ldw	r2,-12(fp)
 200d3f4:	11000f17 	ldw	r4,60(r2)
 200d3f8:	e0bffd17 	ldw	r2,-12(fp)
 200d3fc:	10801017 	ldw	r2,64(r2)
 200d400:	2085383a 	mul	r2,r4,r2
 200d404:	1887883a 	add	r3,r3,r2
 200d408:	e0bffd17 	ldw	r2,-12(fp)
 200d40c:	10c00215 	stw	r3,8(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 200d410:	e0bffd17 	ldw	r2,-12(fp)
 200d414:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
 200d418:	e0bffd17 	ldw	r2,-12(fp)
 200d41c:	10c00017 	ldw	r3,0(r2)
 200d420:	e0bffd17 	ldw	r2,-12(fp)
 200d424:	10c00115 	stw	r3,4(r2)
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 200d428:	e0bffd17 	ldw	r2,-12(fp)
 200d42c:	10c00017 	ldw	r3,0(r2)
 200d430:	e0bffd17 	ldw	r2,-12(fp)
 200d434:	10800f17 	ldw	r2,60(r2)
 200d438:	113fffc4 	addi	r4,r2,-1
 200d43c:	e0bffd17 	ldw	r2,-12(fp)
 200d440:	10801017 	ldw	r2,64(r2)
 200d444:	2085383a 	mul	r2,r4,r2
 200d448:	1887883a 	add	r3,r3,r2
 200d44c:	e0bffd17 	ldw	r2,-12(fp)
 200d450:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
 200d454:	e0bffd17 	ldw	r2,-12(fp)
 200d458:	00ffffc4 	movi	r3,-1
 200d45c:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
 200d460:	e0bffd17 	ldw	r2,-12(fp)
 200d464:	00ffffc4 	movi	r3,-1
 200d468:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
 200d46c:	e0bfff17 	ldw	r2,-4(fp)
 200d470:	10000a1e 	bne	r2,zero,200d49c <xQueueGenericReset+0xe0>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200d474:	e0bffd17 	ldw	r2,-12(fp)
 200d478:	10800417 	ldw	r2,16(r2)
 200d47c:	10000f26 	beq	r2,zero,200d4bc <xQueueGenericReset+0x100>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200d480:	e0bffd17 	ldw	r2,-12(fp)
 200d484:	10800404 	addi	r2,r2,16
 200d488:	1009883a 	mov	r4,r2
 200d48c:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200d490:	10000a26 	beq	r2,zero,200d4bc <xQueueGenericReset+0x100>
				{
					queueYIELD_IF_USING_PREEMPTION();
 200d494:	003b683a 	trap	0
 200d498:	00000806 	br	200d4bc <xQueueGenericReset+0x100>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 200d49c:	e0bffd17 	ldw	r2,-12(fp)
 200d4a0:	10800404 	addi	r2,r2,16
 200d4a4:	1009883a 	mov	r4,r2
 200d4a8:	202d7a40 	call	202d7a4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 200d4ac:	e0bffd17 	ldw	r2,-12(fp)
 200d4b0:	10800904 	addi	r2,r2,36
 200d4b4:	1009883a 	mov	r4,r2
 200d4b8:	202d7a40 	call	202d7a4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 200d4bc:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d4c0:	10000126 	beq	r2,zero,200d4c8 <xQueueGenericReset+0x10c>
 200d4c4:	2010e300 	call	2010e30 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 200d4c8:	00800044 	movi	r2,1
}
 200d4cc:	e037883a 	mov	sp,fp
 200d4d0:	dfc00117 	ldw	ra,4(sp)
 200d4d4:	df000017 	ldw	fp,0(sp)
 200d4d8:	dec00204 	addi	sp,sp,8
 200d4dc:	f800283a 	ret

0200d4e0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 200d4e0:	defff704 	addi	sp,sp,-36
 200d4e4:	dfc00815 	stw	ra,32(sp)
 200d4e8:	df000715 	stw	fp,28(sp)
 200d4ec:	df000704 	addi	fp,sp,28
 200d4f0:	e13ffd15 	stw	r4,-12(fp)
 200d4f4:	e17ffe15 	stw	r5,-8(fp)
 200d4f8:	3005883a 	mov	r2,r6
 200d4fc:	e0bfff05 	stb	r2,-4(fp)
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200d500:	e0fffd17 	ldw	r3,-12(fp)
 200d504:	e0bffe17 	ldw	r2,-8(fp)
 200d508:	1885383a 	mul	r2,r3,r2
 200d50c:	e0bffa15 	stw	r2,-24(fp)
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 200d510:	e0bffa17 	ldw	r2,-24(fp)
 200d514:	10801404 	addi	r2,r2,80
 200d518:	1009883a 	mov	r4,r2
 200d51c:	202d6700 	call	202d670 <pvPortMalloc>
 200d520:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
 200d524:	e0bffb17 	ldw	r2,-20(fp)
 200d528:	10000d26 	beq	r2,zero,200d560 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 200d52c:	e0bffb17 	ldw	r2,-20(fp)
 200d530:	e0bffc15 	stw	r2,-16(fp)
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 200d534:	e0bffc17 	ldw	r2,-16(fp)
 200d538:	10801404 	addi	r2,r2,80
 200d53c:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 200d540:	e0ffff03 	ldbu	r3,-4(fp)
 200d544:	e0bffb17 	ldw	r2,-20(fp)
 200d548:	d8800015 	stw	r2,0(sp)
 200d54c:	180f883a 	mov	r7,r3
 200d550:	e1bffc17 	ldw	r6,-16(fp)
 200d554:	e17ffe17 	ldw	r5,-8(fp)
 200d558:	e13ffd17 	ldw	r4,-12(fp)
 200d55c:	200d5780 	call	200d578 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 200d560:	e0bffb17 	ldw	r2,-20(fp)
	}
 200d564:	e037883a 	mov	sp,fp
 200d568:	dfc00117 	ldw	ra,4(sp)
 200d56c:	df000017 	ldw	fp,0(sp)
 200d570:	dec00204 	addi	sp,sp,8
 200d574:	f800283a 	ret

0200d578 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 200d578:	defffa04 	addi	sp,sp,-24
 200d57c:	dfc00515 	stw	ra,20(sp)
 200d580:	df000415 	stw	fp,16(sp)
 200d584:	df000404 	addi	fp,sp,16
 200d588:	e13ffc15 	stw	r4,-16(fp)
 200d58c:	e17ffd15 	stw	r5,-12(fp)
 200d590:	e1bffe15 	stw	r6,-8(fp)
 200d594:	3805883a 	mov	r2,r7
 200d598:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 200d59c:	e0bffd17 	ldw	r2,-12(fp)
 200d5a0:	1000041e 	bne	r2,zero,200d5b4 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 200d5a4:	e0800217 	ldw	r2,8(fp)
 200d5a8:	e0c00217 	ldw	r3,8(fp)
 200d5ac:	10c00015 	stw	r3,0(r2)
 200d5b0:	00000306 	br	200d5c0 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 200d5b4:	e0800217 	ldw	r2,8(fp)
 200d5b8:	e0fffe17 	ldw	r3,-8(fp)
 200d5bc:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 200d5c0:	e0800217 	ldw	r2,8(fp)
 200d5c4:	e0fffc17 	ldw	r3,-16(fp)
 200d5c8:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
 200d5cc:	e0800217 	ldw	r2,8(fp)
 200d5d0:	e0fffd17 	ldw	r3,-12(fp)
 200d5d4:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 200d5d8:	01400044 	movi	r5,1
 200d5dc:	e1000217 	ldw	r4,8(fp)
 200d5e0:	200d3bc0 	call	200d3bc <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
 200d5e4:	e0800217 	ldw	r2,8(fp)
 200d5e8:	e0ffff03 	ldbu	r3,-4(fp)
 200d5ec:	10c01305 	stb	r3,76(r2)
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 200d5f0:	0001883a 	nop
 200d5f4:	e037883a 	mov	sp,fp
 200d5f8:	dfc00117 	ldw	ra,4(sp)
 200d5fc:	df000017 	ldw	fp,0(sp)
 200d600:	dec00204 	addi	sp,sp,8
 200d604:	f800283a 	ret

0200d608 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 200d608:	defffd04 	addi	sp,sp,-12
 200d60c:	dfc00215 	stw	ra,8(sp)
 200d610:	df000115 	stw	fp,4(sp)
 200d614:	df000104 	addi	fp,sp,4
 200d618:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
 200d61c:	e0bfff17 	ldw	r2,-4(fp)
 200d620:	10000b26 	beq	r2,zero,200d650 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 200d624:	e0bfff17 	ldw	r2,-4(fp)
 200d628:	10000215 	stw	zero,8(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 200d62c:	e0bfff17 	ldw	r2,-4(fp)
 200d630:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 200d634:	e0bfff17 	ldw	r2,-4(fp)
 200d638:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 200d63c:	000f883a 	mov	r7,zero
 200d640:	000d883a 	mov	r6,zero
 200d644:	000b883a 	mov	r5,zero
 200d648:	e13fff17 	ldw	r4,-4(fp)
 200d64c:	200d8480 	call	200d848 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 200d650:	0001883a 	nop
 200d654:	e037883a 	mov	sp,fp
 200d658:	dfc00117 	ldw	ra,4(sp)
 200d65c:	df000017 	ldw	fp,0(sp)
 200d660:	dec00204 	addi	sp,sp,8
 200d664:	f800283a 	ret

0200d668 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 200d668:	defffa04 	addi	sp,sp,-24
 200d66c:	dfc00515 	stw	ra,20(sp)
 200d670:	df000415 	stw	fp,16(sp)
 200d674:	df000404 	addi	fp,sp,16
 200d678:	2005883a 	mov	r2,r4
 200d67c:	e0bfff05 	stb	r2,-4(fp)
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 200d680:	00800044 	movi	r2,1
 200d684:	e0bffc15 	stw	r2,-16(fp)
 200d688:	e03ffd15 	stw	zero,-12(fp)

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 200d68c:	e0bfff03 	ldbu	r2,-4(fp)
 200d690:	100d883a 	mov	r6,r2
 200d694:	e17ffd17 	ldw	r5,-12(fp)
 200d698:	e13ffc17 	ldw	r4,-16(fp)
 200d69c:	200d4e00 	call	200d4e0 <xQueueGenericCreate>
 200d6a0:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 200d6a4:	e13ffe17 	ldw	r4,-8(fp)
 200d6a8:	200d6080 	call	200d608 <prvInitialiseMutex>

		return xNewQueue;
 200d6ac:	e0bffe17 	ldw	r2,-8(fp)
	}
 200d6b0:	e037883a 	mov	sp,fp
 200d6b4:	dfc00117 	ldw	ra,4(sp)
 200d6b8:	df000017 	ldw	fp,0(sp)
 200d6bc:	dec00204 	addi	sp,sp,8
 200d6c0:	f800283a 	ret

0200d6c4 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 200d6c4:	defffa04 	addi	sp,sp,-24
 200d6c8:	dfc00515 	stw	ra,20(sp)
 200d6cc:	df000415 	stw	fp,16(sp)
 200d6d0:	dc000315 	stw	r16,12(sp)
 200d6d4:	df000404 	addi	fp,sp,16
 200d6d8:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 200d6dc:	e0bffe17 	ldw	r2,-8(fp)
 200d6e0:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 200d6e4:	e0bffd17 	ldw	r2,-12(fp)
 200d6e8:	14000217 	ldw	r16,8(r2)
 200d6ec:	20109f80 	call	20109f8 <xTaskGetCurrentTaskHandle>
 200d6f0:	8080101e 	bne	r16,r2,200d734 <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 200d6f4:	e0bffd17 	ldw	r2,-12(fp)
 200d6f8:	10800317 	ldw	r2,12(r2)
 200d6fc:	10ffffc4 	addi	r3,r2,-1
 200d700:	e0bffd17 	ldw	r2,-12(fp)
 200d704:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 200d708:	e0bffd17 	ldw	r2,-12(fp)
 200d70c:	10800317 	ldw	r2,12(r2)
 200d710:	1000051e 	bne	r2,zero,200d728 <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 200d714:	000f883a 	mov	r7,zero
 200d718:	000d883a 	mov	r6,zero
 200d71c:	000b883a 	mov	r5,zero
 200d720:	e13ffd17 	ldw	r4,-12(fp)
 200d724:	200d8480 	call	200d848 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 200d728:	00800044 	movi	r2,1
 200d72c:	e0bffc15 	stw	r2,-16(fp)
 200d730:	00000106 	br	200d738 <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 200d734:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 200d738:	e0bffc17 	ldw	r2,-16(fp)
	}
 200d73c:	e6ffff04 	addi	sp,fp,-4
 200d740:	dfc00217 	ldw	ra,8(sp)
 200d744:	df000117 	ldw	fp,4(sp)
 200d748:	dc000017 	ldw	r16,0(sp)
 200d74c:	dec00304 	addi	sp,sp,12
 200d750:	f800283a 	ret

0200d754 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 200d754:	defff904 	addi	sp,sp,-28
 200d758:	dfc00615 	stw	ra,24(sp)
 200d75c:	df000515 	stw	fp,20(sp)
 200d760:	dc000415 	stw	r16,16(sp)
 200d764:	df000504 	addi	fp,sp,20
 200d768:	e13ffd15 	stw	r4,-12(fp)
 200d76c:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 200d770:	e0bffd17 	ldw	r2,-12(fp)
 200d774:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 200d778:	e0bffc17 	ldw	r2,-16(fp)
 200d77c:	14000217 	ldw	r16,8(r2)
 200d780:	20109f80 	call	20109f8 <xTaskGetCurrentTaskHandle>
 200d784:	8080081e 	bne	r16,r2,200d7a8 <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 200d788:	e0bffc17 	ldw	r2,-16(fp)
 200d78c:	10800317 	ldw	r2,12(r2)
 200d790:	10c00044 	addi	r3,r2,1
 200d794:	e0bffc17 	ldw	r2,-16(fp)
 200d798:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
 200d79c:	00800044 	movi	r2,1
 200d7a0:	e0bffb15 	stw	r2,-20(fp)
 200d7a4:	00000b06 	br	200d7d4 <xQueueTakeMutexRecursive+0x80>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 200d7a8:	e17ffe17 	ldw	r5,-8(fp)
 200d7ac:	e13ffc17 	ldw	r4,-16(fp)
 200d7b0:	200ddd40 	call	200ddd4 <xQueueSemaphoreTake>
 200d7b4:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
 200d7b8:	e0bffb17 	ldw	r2,-20(fp)
 200d7bc:	10000526 	beq	r2,zero,200d7d4 <xQueueTakeMutexRecursive+0x80>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 200d7c0:	e0bffc17 	ldw	r2,-16(fp)
 200d7c4:	10800317 	ldw	r2,12(r2)
 200d7c8:	10c00044 	addi	r3,r2,1
 200d7cc:	e0bffc17 	ldw	r2,-16(fp)
 200d7d0:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 200d7d4:	e0bffb17 	ldw	r2,-20(fp)
	}
 200d7d8:	e6ffff04 	addi	sp,fp,-4
 200d7dc:	dfc00217 	ldw	ra,8(sp)
 200d7e0:	df000117 	ldw	fp,4(sp)
 200d7e4:	dc000017 	ldw	r16,0(sp)
 200d7e8:	dec00304 	addi	sp,sp,12
 200d7ec:	f800283a 	ret

0200d7f0 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 200d7f0:	defffb04 	addi	sp,sp,-20
 200d7f4:	dfc00415 	stw	ra,16(sp)
 200d7f8:	df000315 	stw	fp,12(sp)
 200d7fc:	df000304 	addi	fp,sp,12
 200d800:	e13ffe15 	stw	r4,-8(fp)
 200d804:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 200d808:	01800084 	movi	r6,2
 200d80c:	000b883a 	mov	r5,zero
 200d810:	e13ffe17 	ldw	r4,-8(fp)
 200d814:	200d4e00 	call	200d4e0 <xQueueGenericCreate>
 200d818:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
 200d81c:	e0bffd17 	ldw	r2,-12(fp)
 200d820:	10000326 	beq	r2,zero,200d830 <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 200d824:	e0bffd17 	ldw	r2,-12(fp)
 200d828:	e0ffff17 	ldw	r3,-4(fp)
 200d82c:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 200d830:	e0bffd17 	ldw	r2,-12(fp)
	}
 200d834:	e037883a 	mov	sp,fp
 200d838:	dfc00117 	ldw	ra,4(sp)
 200d83c:	df000017 	ldw	fp,0(sp)
 200d840:	dec00204 	addi	sp,sp,8
 200d844:	f800283a 	ret

0200d848 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 200d848:	defff504 	addi	sp,sp,-44
 200d84c:	dfc00a15 	stw	ra,40(sp)
 200d850:	df000915 	stw	fp,36(sp)
 200d854:	df000904 	addi	fp,sp,36
 200d858:	e13ffc15 	stw	r4,-16(fp)
 200d85c:	e17ffd15 	stw	r5,-12(fp)
 200d860:	e1bffe15 	stw	r6,-8(fp)
 200d864:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 200d868:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 200d86c:	e0bffc17 	ldw	r2,-16(fp)
 200d870:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200d874:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d878:	10000126 	beq	r2,zero,200d880 <xQueueGenericSend+0x38>
 200d87c:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 200d880:	e0bff817 	ldw	r2,-32(fp)
 200d884:	10c00e17 	ldw	r3,56(r2)
 200d888:	e0bff817 	ldw	r2,-32(fp)
 200d88c:	10800f17 	ldw	r2,60(r2)
 200d890:	18800336 	bltu	r3,r2,200d8a0 <xQueueGenericSend+0x58>
 200d894:	e0bfff17 	ldw	r2,-4(fp)
 200d898:	10800098 	cmpnei	r2,r2,2
 200d89c:	1000171e 	bne	r2,zero,200d8fc <xQueueGenericSend+0xb4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 200d8a0:	e1bfff17 	ldw	r6,-4(fp)
 200d8a4:	e17ffd17 	ldw	r5,-12(fp)
 200d8a8:	e13ff817 	ldw	r4,-32(fp)
 200d8ac:	200e5700 	call	200e570 <prvCopyDataToQueue>
 200d8b0:	e0bff915 	stw	r2,-28(fp)

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200d8b4:	e0bff817 	ldw	r2,-32(fp)
 200d8b8:	10800917 	ldw	r2,36(r2)
 200d8bc:	10000726 	beq	r2,zero,200d8dc <xQueueGenericSend+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200d8c0:	e0bff817 	ldw	r2,-32(fp)
 200d8c4:	10800904 	addi	r2,r2,36
 200d8c8:	1009883a 	mov	r4,r2
 200d8cc:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200d8d0:	10000526 	beq	r2,zero,200d8e8 <xQueueGenericSend+0xa0>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 200d8d4:	003b683a 	trap	0
 200d8d8:	00000306 	br	200d8e8 <xQueueGenericSend+0xa0>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 200d8dc:	e0bff917 	ldw	r2,-28(fp)
 200d8e0:	10000126 	beq	r2,zero,200d8e8 <xQueueGenericSend+0xa0>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 200d8e4:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 200d8e8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d8ec:	10000126 	beq	r2,zero,200d8f4 <xQueueGenericSend+0xac>
 200d8f0:	2010e300 	call	2010e30 <vTaskExitCritical>
				return pdPASS;
 200d8f4:	00800044 	movi	r2,1
 200d8f8:	00004706 	br	200da18 <xQueueGenericSend+0x1d0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 200d8fc:	e0bffe17 	ldw	r2,-8(fp)
 200d900:	1000051e 	bne	r2,zero,200d918 <xQueueGenericSend+0xd0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 200d904:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d908:	10000126 	beq	r2,zero,200d910 <xQueueGenericSend+0xc8>
 200d90c:	2010e300 	call	2010e30 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 200d910:	0005883a 	mov	r2,zero
 200d914:	00004006 	br	200da18 <xQueueGenericSend+0x1d0>
				}
				else if( xEntryTimeSet == pdFALSE )
 200d918:	e0bff717 	ldw	r2,-36(fp)
 200d91c:	1000051e 	bne	r2,zero,200d934 <xQueueGenericSend+0xec>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 200d920:	e0bffa04 	addi	r2,fp,-24
 200d924:	1009883a 	mov	r4,r2
 200d928:	20102dc0 	call	20102dc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200d92c:	00800044 	movi	r2,1
 200d930:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 200d934:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d938:	10000126 	beq	r2,zero,200d940 <xQueueGenericSend+0xf8>
 200d93c:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 200d940:	200f8840 	call	200f884 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200d944:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d948:	10000126 	beq	r2,zero,200d950 <xQueueGenericSend+0x108>
 200d94c:	2010de80 	call	2010de8 <vTaskEnterCritical>
 200d950:	e0bff817 	ldw	r2,-32(fp)
 200d954:	10801103 	ldbu	r2,68(r2)
 200d958:	10803fcc 	andi	r2,r2,255
 200d95c:	1080201c 	xori	r2,r2,128
 200d960:	10bfe004 	addi	r2,r2,-128
 200d964:	10bfffd8 	cmpnei	r2,r2,-1
 200d968:	1000021e 	bne	r2,zero,200d974 <xQueueGenericSend+0x12c>
 200d96c:	e0bff817 	ldw	r2,-32(fp)
 200d970:	10001105 	stb	zero,68(r2)
 200d974:	e0bff817 	ldw	r2,-32(fp)
 200d978:	10801143 	ldbu	r2,69(r2)
 200d97c:	10803fcc 	andi	r2,r2,255
 200d980:	1080201c 	xori	r2,r2,128
 200d984:	10bfe004 	addi	r2,r2,-128
 200d988:	10bfffd8 	cmpnei	r2,r2,-1
 200d98c:	1000021e 	bne	r2,zero,200d998 <xQueueGenericSend+0x150>
 200d990:	e0bff817 	ldw	r2,-32(fp)
 200d994:	10001145 	stb	zero,69(r2)
 200d998:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200d99c:	10000126 	beq	r2,zero,200d9a4 <xQueueGenericSend+0x15c>
 200d9a0:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200d9a4:	e0fffe04 	addi	r3,fp,-8
 200d9a8:	e0bffa04 	addi	r2,fp,-24
 200d9ac:	180b883a 	mov	r5,r3
 200d9b0:	1009883a 	mov	r4,r2
 200d9b4:	20103180 	call	2010318 <xTaskCheckForTimeOut>
 200d9b8:	1000131e 	bne	r2,zero,200da08 <xQueueGenericSend+0x1c0>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 200d9bc:	e13ff817 	ldw	r4,-32(fp)
 200d9c0:	200e9540 	call	200e954 <prvIsQueueFull>
 200d9c4:	10000c26 	beq	r2,zero,200d9f8 <xQueueGenericSend+0x1b0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 200d9c8:	e0bff817 	ldw	r2,-32(fp)
 200d9cc:	10800404 	addi	r2,r2,16
 200d9d0:	e0fffe17 	ldw	r3,-8(fp)
 200d9d4:	180b883a 	mov	r5,r3
 200d9d8:	1009883a 	mov	r4,r2
 200d9dc:	200ffac0 	call	200ffac <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 200d9e0:	e13ff817 	ldw	r4,-32(fp)
 200d9e4:	200e7980 	call	200e798 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 200d9e8:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200d9ec:	103fa11e 	bne	r2,zero,200d874 <__alt_mem_mem_0+0xfcfed874>
				{
					portYIELD_WITHIN_API();
 200d9f0:	003b683a 	trap	0
 200d9f4:	003f9f06 	br	200d874 <__alt_mem_mem_0+0xfcfed874>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 200d9f8:	e13ff817 	ldw	r4,-32(fp)
 200d9fc:	200e7980 	call	200e798 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 200da00:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200da04:	003f9b06 	br	200d874 <__alt_mem_mem_0+0xfcfed874>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 200da08:	e13ff817 	ldw	r4,-32(fp)
 200da0c:	200e7980 	call	200e798 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 200da10:	200f8b00 	call	200f8b0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 200da14:	0005883a 	mov	r2,zero
		}
	} /*lint -restore */
}
 200da18:	e037883a 	mov	sp,fp
 200da1c:	dfc00117 	ldw	ra,4(sp)
 200da20:	df000017 	ldw	fp,0(sp)
 200da24:	dec00204 	addi	sp,sp,8
 200da28:	f800283a 	ret

0200da2c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 200da2c:	defff504 	addi	sp,sp,-44
 200da30:	dfc00a15 	stw	ra,40(sp)
 200da34:	df000915 	stw	fp,36(sp)
 200da38:	df000904 	addi	fp,sp,36
 200da3c:	e13ffc15 	stw	r4,-16(fp)
 200da40:	e17ffd15 	stw	r5,-12(fp)
 200da44:	e1bffe15 	stw	r6,-8(fp)
 200da48:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 200da4c:	e0bffc17 	ldw	r2,-16(fp)
 200da50:	e0bff815 	stw	r2,-32(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200da54:	e03ff915 	stw	zero,-28(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 200da58:	e0bff817 	ldw	r2,-32(fp)
 200da5c:	10c00e17 	ldw	r3,56(r2)
 200da60:	e0bff817 	ldw	r2,-32(fp)
 200da64:	10800f17 	ldw	r2,60(r2)
 200da68:	18800336 	bltu	r3,r2,200da78 <xQueueGenericSendFromISR+0x4c>
 200da6c:	e0bfff17 	ldw	r2,-4(fp)
 200da70:	10800098 	cmpnei	r2,r2,2
 200da74:	1000231e 	bne	r2,zero,200db04 <xQueueGenericSendFromISR+0xd8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 200da78:	e0bff817 	ldw	r2,-32(fp)
 200da7c:	10801143 	ldbu	r2,69(r2)
 200da80:	e0bffa05 	stb	r2,-24(fp)
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 200da84:	e0bff817 	ldw	r2,-32(fp)
 200da88:	10800e17 	ldw	r2,56(r2)
 200da8c:	e0bffb15 	stw	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 200da90:	e1bfff17 	ldw	r6,-4(fp)
 200da94:	e17ffd17 	ldw	r5,-12(fp)
 200da98:	e13ff817 	ldw	r4,-32(fp)
 200da9c:	200e5700 	call	200e570 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 200daa0:	e0bffa07 	ldb	r2,-24(fp)
 200daa4:	10bfffd8 	cmpnei	r2,r2,-1
 200daa8:	10000e1e 	bne	r2,zero,200dae4 <xQueueGenericSendFromISR+0xb8>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200daac:	e0bff817 	ldw	r2,-32(fp)
 200dab0:	10800917 	ldw	r2,36(r2)
 200dab4:	10001026 	beq	r2,zero,200daf8 <xQueueGenericSendFromISR+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200dab8:	e0bff817 	ldw	r2,-32(fp)
 200dabc:	10800904 	addi	r2,r2,36
 200dac0:	1009883a 	mov	r4,r2
 200dac4:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200dac8:	10000b26 	beq	r2,zero,200daf8 <xQueueGenericSendFromISR+0xcc>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 200dacc:	e0bffe17 	ldw	r2,-8(fp)
 200dad0:	10000926 	beq	r2,zero,200daf8 <xQueueGenericSendFromISR+0xcc>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 200dad4:	e0bffe17 	ldw	r2,-8(fp)
 200dad8:	00c00044 	movi	r3,1
 200dadc:	10c00015 	stw	r3,0(r2)
 200dae0:	00000506 	br	200daf8 <xQueueGenericSendFromISR+0xcc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 200dae4:	e0bffa03 	ldbu	r2,-24(fp)
 200dae8:	10800044 	addi	r2,r2,1
 200daec:	1007883a 	mov	r3,r2
 200daf0:	e0bff817 	ldw	r2,-32(fp)
 200daf4:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 200daf8:	00800044 	movi	r2,1
 200dafc:	e0bff715 	stw	r2,-36(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
 200db00:	00000106 	br	200db08 <xQueueGenericSendFromISR+0xdc>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 200db04:	e03ff715 	stw	zero,-36(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200db08:	e0bff717 	ldw	r2,-36(fp)
}
 200db0c:	e037883a 	mov	sp,fp
 200db10:	dfc00117 	ldw	ra,4(sp)
 200db14:	df000017 	ldw	fp,0(sp)
 200db18:	dec00204 	addi	sp,sp,8
 200db1c:	f800283a 	ret

0200db20 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 200db20:	defff704 	addi	sp,sp,-36
 200db24:	dfc00815 	stw	ra,32(sp)
 200db28:	df000715 	stw	fp,28(sp)
 200db2c:	df000704 	addi	fp,sp,28
 200db30:	e13ffe15 	stw	r4,-8(fp)
 200db34:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 200db38:	e0bffe17 	ldw	r2,-8(fp)
 200db3c:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200db40:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200db44:	e0bffa17 	ldw	r2,-24(fp)
 200db48:	10800e17 	ldw	r2,56(r2)
 200db4c:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 200db50:	e0bffa17 	ldw	r2,-24(fp)
 200db54:	10800f17 	ldw	r2,60(r2)
 200db58:	e0fffc17 	ldw	r3,-16(fp)
 200db5c:	1880202e 	bgeu	r3,r2,200dbe0 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 200db60:	e0bffa17 	ldw	r2,-24(fp)
 200db64:	10801143 	ldbu	r2,69(r2)
 200db68:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 200db6c:	e0bffc17 	ldw	r2,-16(fp)
 200db70:	10c00044 	addi	r3,r2,1
 200db74:	e0bffa17 	ldw	r2,-24(fp)
 200db78:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 200db7c:	e0bffd07 	ldb	r2,-12(fp)
 200db80:	10bfffd8 	cmpnei	r2,r2,-1
 200db84:	10000e1e 	bne	r2,zero,200dbc0 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200db88:	e0bffa17 	ldw	r2,-24(fp)
 200db8c:	10800917 	ldw	r2,36(r2)
 200db90:	10001026 	beq	r2,zero,200dbd4 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200db94:	e0bffa17 	ldw	r2,-24(fp)
 200db98:	10800904 	addi	r2,r2,36
 200db9c:	1009883a 	mov	r4,r2
 200dba0:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200dba4:	10000b26 	beq	r2,zero,200dbd4 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 200dba8:	e0bfff17 	ldw	r2,-4(fp)
 200dbac:	10000926 	beq	r2,zero,200dbd4 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 200dbb0:	e0bfff17 	ldw	r2,-4(fp)
 200dbb4:	00c00044 	movi	r3,1
 200dbb8:	10c00015 	stw	r3,0(r2)
 200dbbc:	00000506 	br	200dbd4 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 200dbc0:	e0bffd03 	ldbu	r2,-12(fp)
 200dbc4:	10800044 	addi	r2,r2,1
 200dbc8:	1007883a 	mov	r3,r2
 200dbcc:	e0bffa17 	ldw	r2,-24(fp)
 200dbd0:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 200dbd4:	00800044 	movi	r2,1
 200dbd8:	e0bff915 	stw	r2,-28(fp)
 200dbdc:	00000106 	br	200dbe4 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 200dbe0:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200dbe4:	e0bff917 	ldw	r2,-28(fp)
}
 200dbe8:	e037883a 	mov	sp,fp
 200dbec:	dfc00117 	ldw	ra,4(sp)
 200dbf0:	df000017 	ldw	fp,0(sp)
 200dbf4:	dec00204 	addi	sp,sp,8
 200dbf8:	f800283a 	ret

0200dbfc <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 200dbfc:	defff604 	addi	sp,sp,-40
 200dc00:	dfc00915 	stw	ra,36(sp)
 200dc04:	df000815 	stw	fp,32(sp)
 200dc08:	df000804 	addi	fp,sp,32
 200dc0c:	e13ffd15 	stw	r4,-12(fp)
 200dc10:	e17ffe15 	stw	r5,-8(fp)
 200dc14:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 200dc18:	e03ff815 	stw	zero,-32(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 200dc1c:	e0bffd17 	ldw	r2,-12(fp)
 200dc20:	e0bff915 	stw	r2,-28(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200dc24:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200dc28:	10000126 	beq	r2,zero,200dc30 <xQueueReceive+0x34>
 200dc2c:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200dc30:	e0bff917 	ldw	r2,-28(fp)
 200dc34:	10800e17 	ldw	r2,56(r2)
 200dc38:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 200dc3c:	e0bffa17 	ldw	r2,-24(fp)
 200dc40:	10001526 	beq	r2,zero,200dc98 <xQueueReceive+0x9c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 200dc44:	e17ffe17 	ldw	r5,-8(fp)
 200dc48:	e13ff917 	ldw	r4,-28(fp)
 200dc4c:	200e6fc0 	call	200e6fc <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 200dc50:	e0bffa17 	ldw	r2,-24(fp)
 200dc54:	10ffffc4 	addi	r3,r2,-1
 200dc58:	e0bff917 	ldw	r2,-28(fp)
 200dc5c:	10c00e15 	stw	r3,56(r2)

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200dc60:	e0bff917 	ldw	r2,-28(fp)
 200dc64:	10800417 	ldw	r2,16(r2)
 200dc68:	10000626 	beq	r2,zero,200dc84 <xQueueReceive+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200dc6c:	e0bff917 	ldw	r2,-28(fp)
 200dc70:	10800404 	addi	r2,r2,16
 200dc74:	1009883a 	mov	r4,r2
 200dc78:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200dc7c:	10000126 	beq	r2,zero,200dc84 <xQueueReceive+0x88>
					{
						queueYIELD_IF_USING_PREEMPTION();
 200dc80:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 200dc84:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200dc88:	10000126 	beq	r2,zero,200dc90 <xQueueReceive+0x94>
 200dc8c:	2010e300 	call	2010e30 <vTaskExitCritical>
				return pdPASS;
 200dc90:	00800044 	movi	r2,1
 200dc94:	00004a06 	br	200ddc0 <xQueueReceive+0x1c4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 200dc98:	e0bfff17 	ldw	r2,-4(fp)
 200dc9c:	1000051e 	bne	r2,zero,200dcb4 <xQueueReceive+0xb8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 200dca0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200dca4:	10000126 	beq	r2,zero,200dcac <xQueueReceive+0xb0>
 200dca8:	2010e300 	call	2010e30 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 200dcac:	0005883a 	mov	r2,zero
 200dcb0:	00004306 	br	200ddc0 <xQueueReceive+0x1c4>
				}
				else if( xEntryTimeSet == pdFALSE )
 200dcb4:	e0bff817 	ldw	r2,-32(fp)
 200dcb8:	1000051e 	bne	r2,zero,200dcd0 <xQueueReceive+0xd4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 200dcbc:	e0bffb04 	addi	r2,fp,-20
 200dcc0:	1009883a 	mov	r4,r2
 200dcc4:	20102dc0 	call	20102dc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200dcc8:	00800044 	movi	r2,1
 200dccc:	e0bff815 	stw	r2,-32(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 200dcd0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200dcd4:	10000126 	beq	r2,zero,200dcdc <xQueueReceive+0xe0>
 200dcd8:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 200dcdc:	200f8840 	call	200f884 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200dce0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200dce4:	10000126 	beq	r2,zero,200dcec <xQueueReceive+0xf0>
 200dce8:	2010de80 	call	2010de8 <vTaskEnterCritical>
 200dcec:	e0bff917 	ldw	r2,-28(fp)
 200dcf0:	10801103 	ldbu	r2,68(r2)
 200dcf4:	10803fcc 	andi	r2,r2,255
 200dcf8:	1080201c 	xori	r2,r2,128
 200dcfc:	10bfe004 	addi	r2,r2,-128
 200dd00:	10bfffd8 	cmpnei	r2,r2,-1
 200dd04:	1000021e 	bne	r2,zero,200dd10 <xQueueReceive+0x114>
 200dd08:	e0bff917 	ldw	r2,-28(fp)
 200dd0c:	10001105 	stb	zero,68(r2)
 200dd10:	e0bff917 	ldw	r2,-28(fp)
 200dd14:	10801143 	ldbu	r2,69(r2)
 200dd18:	10803fcc 	andi	r2,r2,255
 200dd1c:	1080201c 	xori	r2,r2,128
 200dd20:	10bfe004 	addi	r2,r2,-128
 200dd24:	10bfffd8 	cmpnei	r2,r2,-1
 200dd28:	1000021e 	bne	r2,zero,200dd34 <xQueueReceive+0x138>
 200dd2c:	e0bff917 	ldw	r2,-28(fp)
 200dd30:	10001145 	stb	zero,69(r2)
 200dd34:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200dd38:	10000126 	beq	r2,zero,200dd40 <xQueueReceive+0x144>
 200dd3c:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200dd40:	e0ffff04 	addi	r3,fp,-4
 200dd44:	e0bffb04 	addi	r2,fp,-20
 200dd48:	180b883a 	mov	r5,r3
 200dd4c:	1009883a 	mov	r4,r2
 200dd50:	20103180 	call	2010318 <xTaskCheckForTimeOut>
 200dd54:	1000131e 	bne	r2,zero,200dda4 <xQueueReceive+0x1a8>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200dd58:	e13ff917 	ldw	r4,-28(fp)
 200dd5c:	200e8ac0 	call	200e8ac <prvIsQueueEmpty>
 200dd60:	10000c26 	beq	r2,zero,200dd94 <xQueueReceive+0x198>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 200dd64:	e0bff917 	ldw	r2,-28(fp)
 200dd68:	10800904 	addi	r2,r2,36
 200dd6c:	e0ffff17 	ldw	r3,-4(fp)
 200dd70:	180b883a 	mov	r5,r3
 200dd74:	1009883a 	mov	r4,r2
 200dd78:	200ffac0 	call	200ffac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 200dd7c:	e13ff917 	ldw	r4,-28(fp)
 200dd80:	200e7980 	call	200e798 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 200dd84:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200dd88:	103fa61e 	bne	r2,zero,200dc24 <__alt_mem_mem_0+0xfcfedc24>
				{
					portYIELD_WITHIN_API();
 200dd8c:	003b683a 	trap	0
 200dd90:	003fa406 	br	200dc24 <__alt_mem_mem_0+0xfcfedc24>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 200dd94:	e13ff917 	ldw	r4,-28(fp)
 200dd98:	200e7980 	call	200e798 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 200dd9c:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200dda0:	003fa006 	br	200dc24 <__alt_mem_mem_0+0xfcfedc24>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 200dda4:	e13ff917 	ldw	r4,-28(fp)
 200dda8:	200e7980 	call	200e798 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 200ddac:	200f8b00 	call	200f8b0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200ddb0:	e13ff917 	ldw	r4,-28(fp)
 200ddb4:	200e8ac0 	call	200e8ac <prvIsQueueEmpty>
 200ddb8:	103f9a26 	beq	r2,zero,200dc24 <__alt_mem_mem_0+0xfcfedc24>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 200ddbc:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 200ddc0:	e037883a 	mov	sp,fp
 200ddc4:	dfc00117 	ldw	ra,4(sp)
 200ddc8:	df000017 	ldw	fp,0(sp)
 200ddcc:	dec00204 	addi	sp,sp,8
 200ddd0:	f800283a 	ret

0200ddd4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
 200ddd4:	defff504 	addi	sp,sp,-44
 200ddd8:	dfc00a15 	stw	ra,40(sp)
 200dddc:	df000915 	stw	fp,36(sp)
 200dde0:	df000904 	addi	fp,sp,36
 200dde4:	e13ffe15 	stw	r4,-8(fp)
 200dde8:	e17fff15 	stw	r5,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 200ddec:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 200ddf0:	e0bffe17 	ldw	r2,-8(fp)
 200ddf4:	e0bff915 	stw	r2,-28(fp)

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
 200ddf8:	e03ff815 	stw	zero,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200ddfc:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200de00:	10000126 	beq	r2,zero,200de08 <xQueueSemaphoreTake+0x34>
 200de04:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 200de08:	e0bff917 	ldw	r2,-28(fp)
 200de0c:	10800e17 	ldw	r2,56(r2)
 200de10:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 200de14:	e0bffa17 	ldw	r2,-24(fp)
 200de18:	10001926 	beq	r2,zero,200de80 <xQueueSemaphoreTake+0xac>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 200de1c:	e0bffa17 	ldw	r2,-24(fp)
 200de20:	10ffffc4 	addi	r3,r2,-1
 200de24:	e0bff917 	ldw	r2,-28(fp)
 200de28:	10c00e15 	stw	r3,56(r2)

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 200de2c:	e0bff917 	ldw	r2,-28(fp)
 200de30:	10800017 	ldw	r2,0(r2)
 200de34:	1000041e 	bne	r2,zero,200de48 <xQueueSemaphoreTake+0x74>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 200de38:	2010ed00 	call	2010ed0 <pvTaskIncrementMutexHeldCount>
 200de3c:	1007883a 	mov	r3,r2
 200de40:	e0bff917 	ldw	r2,-28(fp)
 200de44:	10c00215 	stw	r3,8(r2)
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200de48:	e0bff917 	ldw	r2,-28(fp)
 200de4c:	10800417 	ldw	r2,16(r2)
 200de50:	10000626 	beq	r2,zero,200de6c <xQueueSemaphoreTake+0x98>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200de54:	e0bff917 	ldw	r2,-28(fp)
 200de58:	10800404 	addi	r2,r2,16
 200de5c:	1009883a 	mov	r4,r2
 200de60:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200de64:	10000126 	beq	r2,zero,200de6c <xQueueSemaphoreTake+0x98>
					{
						queueYIELD_IF_USING_PREEMPTION();
 200de68:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 200de6c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200de70:	10000126 	beq	r2,zero,200de78 <xQueueSemaphoreTake+0xa4>
 200de74:	2010e300 	call	2010e30 <vTaskExitCritical>
				return pdPASS;
 200de78:	00800044 	movi	r2,1
 200de7c:	00006806 	br	200e020 <xQueueSemaphoreTake+0x24c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 200de80:	e0bfff17 	ldw	r2,-4(fp)
 200de84:	1000051e 	bne	r2,zero,200de9c <xQueueSemaphoreTake+0xc8>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
 200de88:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200de8c:	10000126 	beq	r2,zero,200de94 <xQueueSemaphoreTake+0xc0>
 200de90:	2010e300 	call	2010e30 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 200de94:	0005883a 	mov	r2,zero
 200de98:	00006106 	br	200e020 <xQueueSemaphoreTake+0x24c>
				}
				else if( xEntryTimeSet == pdFALSE )
 200de9c:	e0bff717 	ldw	r2,-36(fp)
 200dea0:	1000051e 	bne	r2,zero,200deb8 <xQueueSemaphoreTake+0xe4>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 200dea4:	e0bffc04 	addi	r2,fp,-16
 200dea8:	1009883a 	mov	r4,r2
 200deac:	20102dc0 	call	20102dc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200deb0:	00800044 	movi	r2,1
 200deb4:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 200deb8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200debc:	10000126 	beq	r2,zero,200dec4 <xQueueSemaphoreTake+0xf0>
 200dec0:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
 200dec4:	200f8840 	call	200f884 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200dec8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200decc:	10000126 	beq	r2,zero,200ded4 <xQueueSemaphoreTake+0x100>
 200ded0:	2010de80 	call	2010de8 <vTaskEnterCritical>
 200ded4:	e0bff917 	ldw	r2,-28(fp)
 200ded8:	10801103 	ldbu	r2,68(r2)
 200dedc:	10803fcc 	andi	r2,r2,255
 200dee0:	1080201c 	xori	r2,r2,128
 200dee4:	10bfe004 	addi	r2,r2,-128
 200dee8:	10bfffd8 	cmpnei	r2,r2,-1
 200deec:	1000021e 	bne	r2,zero,200def8 <xQueueSemaphoreTake+0x124>
 200def0:	e0bff917 	ldw	r2,-28(fp)
 200def4:	10001105 	stb	zero,68(r2)
 200def8:	e0bff917 	ldw	r2,-28(fp)
 200defc:	10801143 	ldbu	r2,69(r2)
 200df00:	10803fcc 	andi	r2,r2,255
 200df04:	1080201c 	xori	r2,r2,128
 200df08:	10bfe004 	addi	r2,r2,-128
 200df0c:	10bfffd8 	cmpnei	r2,r2,-1
 200df10:	1000021e 	bne	r2,zero,200df1c <xQueueSemaphoreTake+0x148>
 200df14:	e0bff917 	ldw	r2,-28(fp)
 200df18:	10001145 	stb	zero,69(r2)
 200df1c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200df20:	10000126 	beq	r2,zero,200df28 <xQueueSemaphoreTake+0x154>
 200df24:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200df28:	e0ffff04 	addi	r3,fp,-4
 200df2c:	e0bffc04 	addi	r2,fp,-16
 200df30:	180b883a 	mov	r5,r3
 200df34:	1009883a 	mov	r4,r2
 200df38:	20103180 	call	2010318 <xTaskCheckForTimeOut>
 200df3c:	1000211e 	bne	r2,zero,200dfc4 <xQueueSemaphoreTake+0x1f0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200df40:	e13ff917 	ldw	r4,-28(fp)
 200df44:	200e8ac0 	call	200e8ac <prvIsQueueEmpty>
 200df48:	10001a26 	beq	r2,zero,200dfb4 <xQueueSemaphoreTake+0x1e0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 200df4c:	e0bff917 	ldw	r2,-28(fp)
 200df50:	10800017 	ldw	r2,0(r2)
 200df54:	10000b1e 	bne	r2,zero,200df84 <xQueueSemaphoreTake+0x1b0>
					{
						taskENTER_CRITICAL();
 200df58:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200df5c:	10000126 	beq	r2,zero,200df64 <xQueueSemaphoreTake+0x190>
 200df60:	2010de80 	call	2010de8 <vTaskEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 200df64:	e0bff917 	ldw	r2,-28(fp)
 200df68:	10800217 	ldw	r2,8(r2)
 200df6c:	1009883a 	mov	r4,r2
 200df70:	2010a6c0 	call	2010a6c <xTaskPriorityInherit>
 200df74:	e0bff815 	stw	r2,-32(fp)
						}
						taskEXIT_CRITICAL();
 200df78:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200df7c:	10000126 	beq	r2,zero,200df84 <xQueueSemaphoreTake+0x1b0>
 200df80:	2010e300 	call	2010e30 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 200df84:	e0bff917 	ldw	r2,-28(fp)
 200df88:	10800904 	addi	r2,r2,36
 200df8c:	e0ffff17 	ldw	r3,-4(fp)
 200df90:	180b883a 	mov	r5,r3
 200df94:	1009883a 	mov	r4,r2
 200df98:	200ffac0 	call	200ffac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 200df9c:	e13ff917 	ldw	r4,-28(fp)
 200dfa0:	200e7980 	call	200e798 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 200dfa4:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200dfa8:	103f941e 	bne	r2,zero,200ddfc <__alt_mem_mem_0+0xfcfeddfc>
				{
					portYIELD_WITHIN_API();
 200dfac:	003b683a 	trap	0
 200dfb0:	003f9206 	br	200ddfc <__alt_mem_mem_0+0xfcfeddfc>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
 200dfb4:	e13ff917 	ldw	r4,-28(fp)
 200dfb8:	200e7980 	call	200e798 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 200dfbc:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200dfc0:	003f8e06 	br	200ddfc <__alt_mem_mem_0+0xfcfeddfc>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
 200dfc4:	e13ff917 	ldw	r4,-28(fp)
 200dfc8:	200e7980 	call	200e798 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 200dfcc:	200f8b00 	call	200f8b0 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200dfd0:	e13ff917 	ldw	r4,-28(fp)
 200dfd4:	200e8ac0 	call	200e8ac <prvIsQueueEmpty>
 200dfd8:	103f8826 	beq	r2,zero,200ddfc <__alt_mem_mem_0+0xfcfeddfc>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
 200dfdc:	e0bff817 	ldw	r2,-32(fp)
 200dfe0:	10000e26 	beq	r2,zero,200e01c <xQueueSemaphoreTake+0x248>
					{
						taskENTER_CRITICAL();
 200dfe4:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200dfe8:	10000126 	beq	r2,zero,200dff0 <xQueueSemaphoreTake+0x21c>
 200dfec:	2010de80 	call	2010de8 <vTaskEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 200dff0:	e13ff917 	ldw	r4,-28(fp)
 200dff4:	200e5200 	call	200e520 <prvGetDisinheritPriorityAfterTimeout>
 200dff8:	e0bffb15 	stw	r2,-20(fp)
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 200dffc:	e0bff917 	ldw	r2,-28(fp)
 200e000:	10800217 	ldw	r2,8(r2)
 200e004:	e17ffb17 	ldw	r5,-20(fp)
 200e008:	1009883a 	mov	r4,r2
 200e00c:	2010ca80 	call	2010ca8 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
 200e010:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e014:	10000126 	beq	r2,zero,200e01c <xQueueSemaphoreTake+0x248>
 200e018:	2010e300 	call	2010e30 <vTaskExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 200e01c:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 200e020:	e037883a 	mov	sp,fp
 200e024:	dfc00117 	ldw	ra,4(sp)
 200e028:	df000017 	ldw	fp,0(sp)
 200e02c:	dec00204 	addi	sp,sp,8
 200e030:	f800283a 	ret

0200e034 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 200e034:	defff504 	addi	sp,sp,-44
 200e038:	dfc00a15 	stw	ra,40(sp)
 200e03c:	df000915 	stw	fp,36(sp)
 200e040:	df000904 	addi	fp,sp,36
 200e044:	e13ffd15 	stw	r4,-12(fp)
 200e048:	e17ffe15 	stw	r5,-8(fp)
 200e04c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 200e050:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 200e054:	e0bffd17 	ldw	r2,-12(fp)
 200e058:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200e05c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e060:	10000126 	beq	r2,zero,200e068 <xQueuePeek+0x34>
 200e064:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200e068:	e0bff817 	ldw	r2,-32(fp)
 200e06c:	10800e17 	ldw	r2,56(r2)
 200e070:	e0bff915 	stw	r2,-28(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 200e074:	e0bff917 	ldw	r2,-28(fp)
 200e078:	10001726 	beq	r2,zero,200e0d8 <xQueuePeek+0xa4>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 200e07c:	e0bff817 	ldw	r2,-32(fp)
 200e080:	10800317 	ldw	r2,12(r2)
 200e084:	e0bffa15 	stw	r2,-24(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 200e088:	e17ffe17 	ldw	r5,-8(fp)
 200e08c:	e13ff817 	ldw	r4,-32(fp)
 200e090:	200e6fc0 	call	200e6fc <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 200e094:	e0bff817 	ldw	r2,-32(fp)
 200e098:	e0fffa17 	ldw	r3,-24(fp)
 200e09c:	10c00315 	stw	r3,12(r2)

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200e0a0:	e0bff817 	ldw	r2,-32(fp)
 200e0a4:	10800917 	ldw	r2,36(r2)
 200e0a8:	10000626 	beq	r2,zero,200e0c4 <xQueuePeek+0x90>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200e0ac:	e0bff817 	ldw	r2,-32(fp)
 200e0b0:	10800904 	addi	r2,r2,36
 200e0b4:	1009883a 	mov	r4,r2
 200e0b8:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200e0bc:	10000126 	beq	r2,zero,200e0c4 <xQueuePeek+0x90>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
 200e0c0:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 200e0c4:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e0c8:	10000126 	beq	r2,zero,200e0d0 <xQueuePeek+0x9c>
 200e0cc:	2010e300 	call	2010e30 <vTaskExitCritical>
				return pdPASS;
 200e0d0:	00800044 	movi	r2,1
 200e0d4:	00004a06 	br	200e200 <xQueuePeek+0x1cc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 200e0d8:	e0bfff17 	ldw	r2,-4(fp)
 200e0dc:	1000051e 	bne	r2,zero,200e0f4 <xQueuePeek+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 200e0e0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e0e4:	10000126 	beq	r2,zero,200e0ec <xQueuePeek+0xb8>
 200e0e8:	2010e300 	call	2010e30 <vTaskExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 200e0ec:	0005883a 	mov	r2,zero
 200e0f0:	00004306 	br	200e200 <xQueuePeek+0x1cc>
				}
				else if( xEntryTimeSet == pdFALSE )
 200e0f4:	e0bff717 	ldw	r2,-36(fp)
 200e0f8:	1000051e 	bne	r2,zero,200e110 <xQueuePeek+0xdc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 200e0fc:	e0bffb04 	addi	r2,fp,-20
 200e100:	1009883a 	mov	r4,r2
 200e104:	20102dc0 	call	20102dc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200e108:	00800044 	movi	r2,1
 200e10c:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 200e110:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e114:	10000126 	beq	r2,zero,200e11c <xQueuePeek+0xe8>
 200e118:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 200e11c:	200f8840 	call	200f884 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200e120:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e124:	10000126 	beq	r2,zero,200e12c <xQueuePeek+0xf8>
 200e128:	2010de80 	call	2010de8 <vTaskEnterCritical>
 200e12c:	e0bff817 	ldw	r2,-32(fp)
 200e130:	10801103 	ldbu	r2,68(r2)
 200e134:	10803fcc 	andi	r2,r2,255
 200e138:	1080201c 	xori	r2,r2,128
 200e13c:	10bfe004 	addi	r2,r2,-128
 200e140:	10bfffd8 	cmpnei	r2,r2,-1
 200e144:	1000021e 	bne	r2,zero,200e150 <xQueuePeek+0x11c>
 200e148:	e0bff817 	ldw	r2,-32(fp)
 200e14c:	10001105 	stb	zero,68(r2)
 200e150:	e0bff817 	ldw	r2,-32(fp)
 200e154:	10801143 	ldbu	r2,69(r2)
 200e158:	10803fcc 	andi	r2,r2,255
 200e15c:	1080201c 	xori	r2,r2,128
 200e160:	10bfe004 	addi	r2,r2,-128
 200e164:	10bfffd8 	cmpnei	r2,r2,-1
 200e168:	1000021e 	bne	r2,zero,200e174 <xQueuePeek+0x140>
 200e16c:	e0bff817 	ldw	r2,-32(fp)
 200e170:	10001145 	stb	zero,69(r2)
 200e174:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e178:	10000126 	beq	r2,zero,200e180 <xQueuePeek+0x14c>
 200e17c:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200e180:	e0ffff04 	addi	r3,fp,-4
 200e184:	e0bffb04 	addi	r2,fp,-20
 200e188:	180b883a 	mov	r5,r3
 200e18c:	1009883a 	mov	r4,r2
 200e190:	20103180 	call	2010318 <xTaskCheckForTimeOut>
 200e194:	1000131e 	bne	r2,zero,200e1e4 <xQueuePeek+0x1b0>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200e198:	e13ff817 	ldw	r4,-32(fp)
 200e19c:	200e8ac0 	call	200e8ac <prvIsQueueEmpty>
 200e1a0:	10000c26 	beq	r2,zero,200e1d4 <xQueuePeek+0x1a0>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 200e1a4:	e0bff817 	ldw	r2,-32(fp)
 200e1a8:	10800904 	addi	r2,r2,36
 200e1ac:	e0ffff17 	ldw	r3,-4(fp)
 200e1b0:	180b883a 	mov	r5,r3
 200e1b4:	1009883a 	mov	r4,r2
 200e1b8:	200ffac0 	call	200ffac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 200e1bc:	e13ff817 	ldw	r4,-32(fp)
 200e1c0:	200e7980 	call	200e798 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 200e1c4:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200e1c8:	103fa41e 	bne	r2,zero,200e05c <__alt_mem_mem_0+0xfcfee05c>
				{
					portYIELD_WITHIN_API();
 200e1cc:	003b683a 	trap	0
 200e1d0:	003fa206 	br	200e05c <__alt_mem_mem_0+0xfcfee05c>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
 200e1d4:	e13ff817 	ldw	r4,-32(fp)
 200e1d8:	200e7980 	call	200e798 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 200e1dc:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200e1e0:	003f9e06 	br	200e05c <__alt_mem_mem_0+0xfcfee05c>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
 200e1e4:	e13ff817 	ldw	r4,-32(fp)
 200e1e8:	200e7980 	call	200e798 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 200e1ec:	200f8b00 	call	200f8b0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200e1f0:	e13ff817 	ldw	r4,-32(fp)
 200e1f4:	200e8ac0 	call	200e8ac <prvIsQueueEmpty>
 200e1f8:	103f9826 	beq	r2,zero,200e05c <__alt_mem_mem_0+0xfcfee05c>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 200e1fc:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 200e200:	e037883a 	mov	sp,fp
 200e204:	dfc00117 	ldw	ra,4(sp)
 200e208:	df000017 	ldw	fp,0(sp)
 200e20c:	dec00204 	addi	sp,sp,8
 200e210:	f800283a 	ret

0200e214 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 200e214:	defff604 	addi	sp,sp,-40
 200e218:	dfc00915 	stw	ra,36(sp)
 200e21c:	df000815 	stw	fp,32(sp)
 200e220:	df000804 	addi	fp,sp,32
 200e224:	e13ffd15 	stw	r4,-12(fp)
 200e228:	e17ffe15 	stw	r5,-8(fp)
 200e22c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 200e230:	e0bffd17 	ldw	r2,-12(fp)
 200e234:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200e238:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200e23c:	e0bff917 	ldw	r2,-28(fp)
 200e240:	10800e17 	ldw	r2,56(r2)
 200e244:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 200e248:	e0bffb17 	ldw	r2,-20(fp)
 200e24c:	10002326 	beq	r2,zero,200e2dc <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
 200e250:	e0bff917 	ldw	r2,-28(fp)
 200e254:	10801103 	ldbu	r2,68(r2)
 200e258:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 200e25c:	e17ffe17 	ldw	r5,-8(fp)
 200e260:	e13ff917 	ldw	r4,-28(fp)
 200e264:	200e6fc0 	call	200e6fc <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 200e268:	e0bffb17 	ldw	r2,-20(fp)
 200e26c:	10ffffc4 	addi	r3,r2,-1
 200e270:	e0bff917 	ldw	r2,-28(fp)
 200e274:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
 200e278:	e0bffc07 	ldb	r2,-16(fp)
 200e27c:	10bfffd8 	cmpnei	r2,r2,-1
 200e280:	10000e1e 	bne	r2,zero,200e2bc <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200e284:	e0bff917 	ldw	r2,-28(fp)
 200e288:	10800417 	ldw	r2,16(r2)
 200e28c:	10001026 	beq	r2,zero,200e2d0 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200e290:	e0bff917 	ldw	r2,-28(fp)
 200e294:	10800404 	addi	r2,r2,16
 200e298:	1009883a 	mov	r4,r2
 200e29c:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200e2a0:	10000b26 	beq	r2,zero,200e2d0 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 200e2a4:	e0bfff17 	ldw	r2,-4(fp)
 200e2a8:	10000926 	beq	r2,zero,200e2d0 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 200e2ac:	e0bfff17 	ldw	r2,-4(fp)
 200e2b0:	00c00044 	movi	r3,1
 200e2b4:	10c00015 	stw	r3,0(r2)
 200e2b8:	00000506 	br	200e2d0 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 200e2bc:	e0bffc03 	ldbu	r2,-16(fp)
 200e2c0:	10800044 	addi	r2,r2,1
 200e2c4:	1007883a 	mov	r3,r2
 200e2c8:	e0bff917 	ldw	r2,-28(fp)
 200e2cc:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
 200e2d0:	00800044 	movi	r2,1
 200e2d4:	e0bff815 	stw	r2,-32(fp)
 200e2d8:	00000106 	br	200e2e0 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
 200e2dc:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200e2e0:	e0bff817 	ldw	r2,-32(fp)
}
 200e2e4:	e037883a 	mov	sp,fp
 200e2e8:	dfc00117 	ldw	ra,4(sp)
 200e2ec:	df000017 	ldw	fp,0(sp)
 200e2f0:	dec00204 	addi	sp,sp,8
 200e2f4:	f800283a 	ret

0200e2f8 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 200e2f8:	defff804 	addi	sp,sp,-32
 200e2fc:	dfc00715 	stw	ra,28(sp)
 200e300:	df000615 	stw	fp,24(sp)
 200e304:	df000604 	addi	fp,sp,24
 200e308:	e13ffe15 	stw	r4,-8(fp)
 200e30c:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 200e310:	e0bffe17 	ldw	r2,-8(fp)
 200e314:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200e318:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 200e31c:	e0bffb17 	ldw	r2,-20(fp)
 200e320:	10800e17 	ldw	r2,56(r2)
 200e324:	10000c26 	beq	r2,zero,200e358 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 200e328:	e0bffb17 	ldw	r2,-20(fp)
 200e32c:	10800317 	ldw	r2,12(r2)
 200e330:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 200e334:	e17fff17 	ldw	r5,-4(fp)
 200e338:	e13ffb17 	ldw	r4,-20(fp)
 200e33c:	200e6fc0 	call	200e6fc <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 200e340:	e0bffb17 	ldw	r2,-20(fp)
 200e344:	e0fffd17 	ldw	r3,-12(fp)
 200e348:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
 200e34c:	00800044 	movi	r2,1
 200e350:	e0bffa15 	stw	r2,-24(fp)
 200e354:	00000106 	br	200e35c <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
 200e358:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200e35c:	e0bffa17 	ldw	r2,-24(fp)
}
 200e360:	e037883a 	mov	sp,fp
 200e364:	dfc00117 	ldw	ra,4(sp)
 200e368:	df000017 	ldw	fp,0(sp)
 200e36c:	dec00204 	addi	sp,sp,8
 200e370:	f800283a 	ret

0200e374 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 200e374:	defffc04 	addi	sp,sp,-16
 200e378:	dfc00315 	stw	ra,12(sp)
 200e37c:	df000215 	stw	fp,8(sp)
 200e380:	df000204 	addi	fp,sp,8
 200e384:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 200e388:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e38c:	10000126 	beq	r2,zero,200e394 <uxQueueMessagesWaiting+0x20>
 200e390:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 200e394:	e0bfff17 	ldw	r2,-4(fp)
 200e398:	10800e17 	ldw	r2,56(r2)
 200e39c:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 200e3a0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e3a4:	10000126 	beq	r2,zero,200e3ac <uxQueueMessagesWaiting+0x38>
 200e3a8:	2010e300 	call	2010e30 <vTaskExitCritical>

	return uxReturn;
 200e3ac:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 200e3b0:	e037883a 	mov	sp,fp
 200e3b4:	dfc00117 	ldw	ra,4(sp)
 200e3b8:	df000017 	ldw	fp,0(sp)
 200e3bc:	dec00204 	addi	sp,sp,8
 200e3c0:	f800283a 	ret

0200e3c4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 200e3c4:	defffb04 	addi	sp,sp,-20
 200e3c8:	dfc00415 	stw	ra,16(sp)
 200e3cc:	df000315 	stw	fp,12(sp)
 200e3d0:	df000304 	addi	fp,sp,12
 200e3d4:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 200e3d8:	e0bfff17 	ldw	r2,-4(fp)
 200e3dc:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 200e3e0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e3e4:	10000126 	beq	r2,zero,200e3ec <uxQueueSpacesAvailable+0x28>
 200e3e8:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 200e3ec:	e0bffd17 	ldw	r2,-12(fp)
 200e3f0:	10c00f17 	ldw	r3,60(r2)
 200e3f4:	e0bffd17 	ldw	r2,-12(fp)
 200e3f8:	10800e17 	ldw	r2,56(r2)
 200e3fc:	1885c83a 	sub	r2,r3,r2
 200e400:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 200e404:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e408:	10000126 	beq	r2,zero,200e410 <uxQueueSpacesAvailable+0x4c>
 200e40c:	2010e300 	call	2010e30 <vTaskExitCritical>

	return uxReturn;
 200e410:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 200e414:	e037883a 	mov	sp,fp
 200e418:	dfc00117 	ldw	ra,4(sp)
 200e41c:	df000017 	ldw	fp,0(sp)
 200e420:	dec00204 	addi	sp,sp,8
 200e424:	f800283a 	ret

0200e428 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 200e428:	defffc04 	addi	sp,sp,-16
 200e42c:	df000315 	stw	fp,12(sp)
 200e430:	df000304 	addi	fp,sp,12
 200e434:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 200e438:	e0bfff17 	ldw	r2,-4(fp)
 200e43c:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
 200e440:	e0bffd17 	ldw	r2,-12(fp)
 200e444:	10800e17 	ldw	r2,56(r2)
 200e448:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
 200e44c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 200e450:	e037883a 	mov	sp,fp
 200e454:	df000017 	ldw	fp,0(sp)
 200e458:	dec00104 	addi	sp,sp,4
 200e45c:	f800283a 	ret

0200e460 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 200e460:	defffc04 	addi	sp,sp,-16
 200e464:	dfc00315 	stw	ra,12(sp)
 200e468:	df000215 	stw	fp,8(sp)
 200e46c:	df000204 	addi	fp,sp,8
 200e470:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = xQueue;
 200e474:	e0bfff17 	ldw	r2,-4(fp)
 200e478:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
 200e47c:	e13ffe17 	ldw	r4,-8(fp)
 200e480:	202d7300 	call	202d730 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 200e484:	0001883a 	nop
 200e488:	e037883a 	mov	sp,fp
 200e48c:	dfc00117 	ldw	ra,4(sp)
 200e490:	df000017 	ldw	fp,0(sp)
 200e494:	dec00204 	addi	sp,sp,8
 200e498:	f800283a 	ret

0200e49c <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
 200e49c:	defffe04 	addi	sp,sp,-8
 200e4a0:	df000115 	stw	fp,4(sp)
 200e4a4:	df000104 	addi	fp,sp,4
 200e4a8:	e13fff15 	stw	r4,-4(fp)
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 200e4ac:	e0bfff17 	ldw	r2,-4(fp)
 200e4b0:	10801217 	ldw	r2,72(r2)
	}
 200e4b4:	e037883a 	mov	sp,fp
 200e4b8:	df000017 	ldw	fp,0(sp)
 200e4bc:	dec00104 	addi	sp,sp,4
 200e4c0:	f800283a 	ret

0200e4c4 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
 200e4c4:	defffd04 	addi	sp,sp,-12
 200e4c8:	df000215 	stw	fp,8(sp)
 200e4cc:	df000204 	addi	fp,sp,8
 200e4d0:	e13ffe15 	stw	r4,-8(fp)
 200e4d4:	e17fff15 	stw	r5,-4(fp)
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 200e4d8:	e0bffe17 	ldw	r2,-8(fp)
 200e4dc:	e0ffff17 	ldw	r3,-4(fp)
 200e4e0:	10c01215 	stw	r3,72(r2)
	}
 200e4e4:	0001883a 	nop
 200e4e8:	e037883a 	mov	sp,fp
 200e4ec:	df000017 	ldw	fp,0(sp)
 200e4f0:	dec00104 	addi	sp,sp,4
 200e4f4:	f800283a 	ret

0200e4f8 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
 200e4f8:	defffe04 	addi	sp,sp,-8
 200e4fc:	df000115 	stw	fp,4(sp)
 200e500:	df000104 	addi	fp,sp,4
 200e504:	e13fff15 	stw	r4,-4(fp)
		return ( ( Queue_t * ) xQueue )->ucQueueType;
 200e508:	e0bfff17 	ldw	r2,-4(fp)
 200e50c:	10801303 	ldbu	r2,76(r2)
	}
 200e510:	e037883a 	mov	sp,fp
 200e514:	df000017 	ldw	fp,0(sp)
 200e518:	dec00104 	addi	sp,sp,4
 200e51c:	f800283a 	ret

0200e520 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 200e520:	defffd04 	addi	sp,sp,-12
 200e524:	df000215 	stw	fp,8(sp)
 200e528:	df000204 	addi	fp,sp,8
 200e52c:	e13fff15 	stw	r4,-4(fp)
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 200e530:	e0bfff17 	ldw	r2,-4(fp)
 200e534:	10800917 	ldw	r2,36(r2)
 200e538:	10000726 	beq	r2,zero,200e558 <prvGetDisinheritPriorityAfterTimeout+0x38>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 200e53c:	e0bfff17 	ldw	r2,-4(fp)
 200e540:	10800c17 	ldw	r2,48(r2)
 200e544:	10800017 	ldw	r2,0(r2)
 200e548:	00c00144 	movi	r3,5
 200e54c:	1885c83a 	sub	r2,r3,r2
 200e550:	e0bffe15 	stw	r2,-8(fp)
 200e554:	00000106 	br	200e55c <prvGetDisinheritPriorityAfterTimeout+0x3c>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 200e558:	e03ffe15 	stw	zero,-8(fp)
		}

		return uxHighestPriorityOfWaitingTasks;
 200e55c:	e0bffe17 	ldw	r2,-8(fp)
	}
 200e560:	e037883a 	mov	sp,fp
 200e564:	df000017 	ldw	fp,0(sp)
 200e568:	dec00104 	addi	sp,sp,4
 200e56c:	f800283a 	ret

0200e570 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 200e570:	defff904 	addi	sp,sp,-28
 200e574:	dfc00615 	stw	ra,24(sp)
 200e578:	df000515 	stw	fp,20(sp)
 200e57c:	df000504 	addi	fp,sp,20
 200e580:	e13ffd15 	stw	r4,-12(fp)
 200e584:	e17ffe15 	stw	r5,-8(fp)
 200e588:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
 200e58c:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200e590:	e0bffd17 	ldw	r2,-12(fp)
 200e594:	10800e17 	ldw	r2,56(r2)
 200e598:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 200e59c:	e0bffd17 	ldw	r2,-12(fp)
 200e5a0:	10801017 	ldw	r2,64(r2)
 200e5a4:	10000b1e 	bne	r2,zero,200e5d4 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 200e5a8:	e0bffd17 	ldw	r2,-12(fp)
 200e5ac:	10800017 	ldw	r2,0(r2)
 200e5b0:	1000481e 	bne	r2,zero,200e6d4 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 200e5b4:	e0bffd17 	ldw	r2,-12(fp)
 200e5b8:	10800217 	ldw	r2,8(r2)
 200e5bc:	1009883a 	mov	r4,r2
 200e5c0:	2010bac0 	call	2010bac <xTaskPriorityDisinherit>
 200e5c4:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 200e5c8:	e0bffd17 	ldw	r2,-12(fp)
 200e5cc:	10000215 	stw	zero,8(r2)
 200e5d0:	00004006 	br	200e6d4 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 200e5d4:	e0bfff17 	ldw	r2,-4(fp)
 200e5d8:	1000191e 	bne	r2,zero,200e640 <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 200e5dc:	e0bffd17 	ldw	r2,-12(fp)
 200e5e0:	10c00117 	ldw	r3,4(r2)
 200e5e4:	e0bffd17 	ldw	r2,-12(fp)
 200e5e8:	10801017 	ldw	r2,64(r2)
 200e5ec:	100d883a 	mov	r6,r2
 200e5f0:	e17ffe17 	ldw	r5,-8(fp)
 200e5f4:	1809883a 	mov	r4,r3
 200e5f8:	2005e580 	call	2005e58 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 200e5fc:	e0bffd17 	ldw	r2,-12(fp)
 200e600:	10c00117 	ldw	r3,4(r2)
 200e604:	e0bffd17 	ldw	r2,-12(fp)
 200e608:	10801017 	ldw	r2,64(r2)
 200e60c:	1887883a 	add	r3,r3,r2
 200e610:	e0bffd17 	ldw	r2,-12(fp)
 200e614:	10c00115 	stw	r3,4(r2)
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 200e618:	e0bffd17 	ldw	r2,-12(fp)
 200e61c:	10c00117 	ldw	r3,4(r2)
 200e620:	e0bffd17 	ldw	r2,-12(fp)
 200e624:	10800217 	ldw	r2,8(r2)
 200e628:	18802a36 	bltu	r3,r2,200e6d4 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 200e62c:	e0bffd17 	ldw	r2,-12(fp)
 200e630:	10c00017 	ldw	r3,0(r2)
 200e634:	e0bffd17 	ldw	r2,-12(fp)
 200e638:	10c00115 	stw	r3,4(r2)
 200e63c:	00002506 	br	200e6d4 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 200e640:	e0bffd17 	ldw	r2,-12(fp)
 200e644:	10c00317 	ldw	r3,12(r2)
 200e648:	e0bffd17 	ldw	r2,-12(fp)
 200e64c:	10801017 	ldw	r2,64(r2)
 200e650:	100d883a 	mov	r6,r2
 200e654:	e17ffe17 	ldw	r5,-8(fp)
 200e658:	1809883a 	mov	r4,r3
 200e65c:	2005e580 	call	2005e58 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 200e660:	e0bffd17 	ldw	r2,-12(fp)
 200e664:	10c00317 	ldw	r3,12(r2)
 200e668:	e0bffd17 	ldw	r2,-12(fp)
 200e66c:	10801017 	ldw	r2,64(r2)
 200e670:	0085c83a 	sub	r2,zero,r2
 200e674:	1887883a 	add	r3,r3,r2
 200e678:	e0bffd17 	ldw	r2,-12(fp)
 200e67c:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 200e680:	e0bffd17 	ldw	r2,-12(fp)
 200e684:	10c00317 	ldw	r3,12(r2)
 200e688:	e0bffd17 	ldw	r2,-12(fp)
 200e68c:	10800017 	ldw	r2,0(r2)
 200e690:	1880082e 	bgeu	r3,r2,200e6b4 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 200e694:	e0bffd17 	ldw	r2,-12(fp)
 200e698:	10c00217 	ldw	r3,8(r2)
 200e69c:	e0bffd17 	ldw	r2,-12(fp)
 200e6a0:	10801017 	ldw	r2,64(r2)
 200e6a4:	0085c83a 	sub	r2,zero,r2
 200e6a8:	1887883a 	add	r3,r3,r2
 200e6ac:	e0bffd17 	ldw	r2,-12(fp)
 200e6b0:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 200e6b4:	e0bfff17 	ldw	r2,-4(fp)
 200e6b8:	10800098 	cmpnei	r2,r2,2
 200e6bc:	1000051e 	bne	r2,zero,200e6d4 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 200e6c0:	e0bffc17 	ldw	r2,-16(fp)
 200e6c4:	10000326 	beq	r2,zero,200e6d4 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 200e6c8:	e0bffc17 	ldw	r2,-16(fp)
 200e6cc:	10bfffc4 	addi	r2,r2,-1
 200e6d0:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 200e6d4:	e0bffc17 	ldw	r2,-16(fp)
 200e6d8:	10c00044 	addi	r3,r2,1
 200e6dc:	e0bffd17 	ldw	r2,-12(fp)
 200e6e0:	10c00e15 	stw	r3,56(r2)

	return xReturn;
 200e6e4:	e0bffb17 	ldw	r2,-20(fp)
}
 200e6e8:	e037883a 	mov	sp,fp
 200e6ec:	dfc00117 	ldw	ra,4(sp)
 200e6f0:	df000017 	ldw	fp,0(sp)
 200e6f4:	dec00204 	addi	sp,sp,8
 200e6f8:	f800283a 	ret

0200e6fc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 200e6fc:	defffc04 	addi	sp,sp,-16
 200e700:	dfc00315 	stw	ra,12(sp)
 200e704:	df000215 	stw	fp,8(sp)
 200e708:	df000204 	addi	fp,sp,8
 200e70c:	e13ffe15 	stw	r4,-8(fp)
 200e710:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 200e714:	e0bffe17 	ldw	r2,-8(fp)
 200e718:	10801017 	ldw	r2,64(r2)
 200e71c:	10001826 	beq	r2,zero,200e780 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 200e720:	e0bffe17 	ldw	r2,-8(fp)
 200e724:	10c00317 	ldw	r3,12(r2)
 200e728:	e0bffe17 	ldw	r2,-8(fp)
 200e72c:	10801017 	ldw	r2,64(r2)
 200e730:	1887883a 	add	r3,r3,r2
 200e734:	e0bffe17 	ldw	r2,-8(fp)
 200e738:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 200e73c:	e0bffe17 	ldw	r2,-8(fp)
 200e740:	10c00317 	ldw	r3,12(r2)
 200e744:	e0bffe17 	ldw	r2,-8(fp)
 200e748:	10800217 	ldw	r2,8(r2)
 200e74c:	18800436 	bltu	r3,r2,200e760 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 200e750:	e0bffe17 	ldw	r2,-8(fp)
 200e754:	10c00017 	ldw	r3,0(r2)
 200e758:	e0bffe17 	ldw	r2,-8(fp)
 200e75c:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 200e760:	e0bffe17 	ldw	r2,-8(fp)
 200e764:	10c00317 	ldw	r3,12(r2)
 200e768:	e0bffe17 	ldw	r2,-8(fp)
 200e76c:	10801017 	ldw	r2,64(r2)
 200e770:	100d883a 	mov	r6,r2
 200e774:	180b883a 	mov	r5,r3
 200e778:	e13fff17 	ldw	r4,-4(fp)
 200e77c:	2005e580 	call	2005e58 <memcpy>
	}
}
 200e780:	0001883a 	nop
 200e784:	e037883a 	mov	sp,fp
 200e788:	dfc00117 	ldw	ra,4(sp)
 200e78c:	df000017 	ldw	fp,0(sp)
 200e790:	dec00204 	addi	sp,sp,8
 200e794:	f800283a 	ret

0200e798 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 200e798:	defffc04 	addi	sp,sp,-16
 200e79c:	dfc00315 	stw	ra,12(sp)
 200e7a0:	df000215 	stw	fp,8(sp)
 200e7a4:	df000204 	addi	fp,sp,8
 200e7a8:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 200e7ac:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e7b0:	10000126 	beq	r2,zero,200e7b8 <prvUnlockQueue+0x20>
 200e7b4:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 200e7b8:	e0bfff17 	ldw	r2,-4(fp)
 200e7bc:	10801143 	ldbu	r2,69(r2)
 200e7c0:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 200e7c4:	00000c06 	br	200e7f8 <prvUnlockQueue+0x60>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200e7c8:	e0bfff17 	ldw	r2,-4(fp)
 200e7cc:	10800917 	ldw	r2,36(r2)
 200e7d0:	10000c26 	beq	r2,zero,200e804 <prvUnlockQueue+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200e7d4:	e0bfff17 	ldw	r2,-4(fp)
 200e7d8:	10800904 	addi	r2,r2,36
 200e7dc:	1009883a 	mov	r4,r2
 200e7e0:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200e7e4:	10000126 	beq	r2,zero,200e7ec <prvUnlockQueue+0x54>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 200e7e8:	20104080 	call	2010408 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 200e7ec:	e0bffe03 	ldbu	r2,-8(fp)
 200e7f0:	10bfffc4 	addi	r2,r2,-1
 200e7f4:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 200e7f8:	e0bffe07 	ldb	r2,-8(fp)
 200e7fc:	00bff216 	blt	zero,r2,200e7c8 <__alt_mem_mem_0+0xfcfee7c8>
 200e800:	00000106 	br	200e808 <prvUnlockQueue+0x70>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 200e804:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 200e808:	e0bfff17 	ldw	r2,-4(fp)
 200e80c:	00ffffc4 	movi	r3,-1
 200e810:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
 200e814:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e818:	10000126 	beq	r2,zero,200e820 <prvUnlockQueue+0x88>
 200e81c:	2010e300 	call	2010e30 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 200e820:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e824:	10000126 	beq	r2,zero,200e82c <prvUnlockQueue+0x94>
 200e828:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 200e82c:	e0bfff17 	ldw	r2,-4(fp)
 200e830:	10801103 	ldbu	r2,68(r2)
 200e834:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
 200e838:	00000c06 	br	200e86c <prvUnlockQueue+0xd4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200e83c:	e0bfff17 	ldw	r2,-4(fp)
 200e840:	10800417 	ldw	r2,16(r2)
 200e844:	10000c26 	beq	r2,zero,200e878 <prvUnlockQueue+0xe0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200e848:	e0bfff17 	ldw	r2,-4(fp)
 200e84c:	10800404 	addi	r2,r2,16
 200e850:	1009883a 	mov	r4,r2
 200e854:	20100c40 	call	20100c4 <xTaskRemoveFromEventList>
 200e858:	10000126 	beq	r2,zero,200e860 <prvUnlockQueue+0xc8>
				{
					vTaskMissedYield();
 200e85c:	20104080 	call	2010408 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 200e860:	e0bffe43 	ldbu	r2,-7(fp)
 200e864:	10bfffc4 	addi	r2,r2,-1
 200e868:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
 200e86c:	e0bffe47 	ldb	r2,-7(fp)
 200e870:	00bff216 	blt	zero,r2,200e83c <__alt_mem_mem_0+0xfcfee83c>
 200e874:	00000106 	br	200e87c <prvUnlockQueue+0xe4>

				--cRxLock;
			}
			else
			{
				break;
 200e878:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 200e87c:	e0bfff17 	ldw	r2,-4(fp)
 200e880:	00ffffc4 	movi	r3,-1
 200e884:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
 200e888:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e88c:	10000126 	beq	r2,zero,200e894 <prvUnlockQueue+0xfc>
 200e890:	2010e300 	call	2010e30 <vTaskExitCritical>
}
 200e894:	0001883a 	nop
 200e898:	e037883a 	mov	sp,fp
 200e89c:	dfc00117 	ldw	ra,4(sp)
 200e8a0:	df000017 	ldw	fp,0(sp)
 200e8a4:	dec00204 	addi	sp,sp,8
 200e8a8:	f800283a 	ret

0200e8ac <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 200e8ac:	defffc04 	addi	sp,sp,-16
 200e8b0:	dfc00315 	stw	ra,12(sp)
 200e8b4:	df000215 	stw	fp,8(sp)
 200e8b8:	df000204 	addi	fp,sp,8
 200e8bc:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 200e8c0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e8c4:	10000126 	beq	r2,zero,200e8cc <prvIsQueueEmpty+0x20>
 200e8c8:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 200e8cc:	e0bfff17 	ldw	r2,-4(fp)
 200e8d0:	10800e17 	ldw	r2,56(r2)
 200e8d4:	1000031e 	bne	r2,zero,200e8e4 <prvIsQueueEmpty+0x38>
		{
			xReturn = pdTRUE;
 200e8d8:	00800044 	movi	r2,1
 200e8dc:	e0bffe15 	stw	r2,-8(fp)
 200e8e0:	00000106 	br	200e8e8 <prvIsQueueEmpty+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
 200e8e4:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 200e8e8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e8ec:	10000126 	beq	r2,zero,200e8f4 <prvIsQueueEmpty+0x48>
 200e8f0:	2010e300 	call	2010e30 <vTaskExitCritical>

	return xReturn;
 200e8f4:	e0bffe17 	ldw	r2,-8(fp)
}
 200e8f8:	e037883a 	mov	sp,fp
 200e8fc:	dfc00117 	ldw	ra,4(sp)
 200e900:	df000017 	ldw	fp,0(sp)
 200e904:	dec00204 	addi	sp,sp,8
 200e908:	f800283a 	ret

0200e90c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 200e90c:	defffc04 	addi	sp,sp,-16
 200e910:	df000315 	stw	fp,12(sp)
 200e914:	df000304 	addi	fp,sp,12
 200e918:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 200e91c:	e0bfff17 	ldw	r2,-4(fp)
 200e920:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 200e924:	e0bffe17 	ldw	r2,-8(fp)
 200e928:	10800e17 	ldw	r2,56(r2)
 200e92c:	1000031e 	bne	r2,zero,200e93c <xQueueIsQueueEmptyFromISR+0x30>
	{
		xReturn = pdTRUE;
 200e930:	00800044 	movi	r2,1
 200e934:	e0bffd15 	stw	r2,-12(fp)
 200e938:	00000106 	br	200e940 <xQueueIsQueueEmptyFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
 200e93c:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 200e940:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 200e944:	e037883a 	mov	sp,fp
 200e948:	df000017 	ldw	fp,0(sp)
 200e94c:	dec00104 	addi	sp,sp,4
 200e950:	f800283a 	ret

0200e954 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 200e954:	defffc04 	addi	sp,sp,-16
 200e958:	dfc00315 	stw	ra,12(sp)
 200e95c:	df000215 	stw	fp,8(sp)
 200e960:	df000204 	addi	fp,sp,8
 200e964:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 200e968:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e96c:	10000126 	beq	r2,zero,200e974 <prvIsQueueFull+0x20>
 200e970:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 200e974:	e0bfff17 	ldw	r2,-4(fp)
 200e978:	10c00e17 	ldw	r3,56(r2)
 200e97c:	e0bfff17 	ldw	r2,-4(fp)
 200e980:	10800f17 	ldw	r2,60(r2)
 200e984:	1880031e 	bne	r3,r2,200e994 <prvIsQueueFull+0x40>
		{
			xReturn = pdTRUE;
 200e988:	00800044 	movi	r2,1
 200e98c:	e0bffe15 	stw	r2,-8(fp)
 200e990:	00000106 	br	200e998 <prvIsQueueFull+0x44>
		}
		else
		{
			xReturn = pdFALSE;
 200e994:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 200e998:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200e99c:	10000126 	beq	r2,zero,200e9a4 <prvIsQueueFull+0x50>
 200e9a0:	2010e300 	call	2010e30 <vTaskExitCritical>

	return xReturn;
 200e9a4:	e0bffe17 	ldw	r2,-8(fp)
}
 200e9a8:	e037883a 	mov	sp,fp
 200e9ac:	dfc00117 	ldw	ra,4(sp)
 200e9b0:	df000017 	ldw	fp,0(sp)
 200e9b4:	dec00204 	addi	sp,sp,8
 200e9b8:	f800283a 	ret

0200e9bc <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 200e9bc:	defffc04 	addi	sp,sp,-16
 200e9c0:	df000315 	stw	fp,12(sp)
 200e9c4:	df000304 	addi	fp,sp,12
 200e9c8:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 200e9cc:	e0bfff17 	ldw	r2,-4(fp)
 200e9d0:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 200e9d4:	e0bffe17 	ldw	r2,-8(fp)
 200e9d8:	10c00e17 	ldw	r3,56(r2)
 200e9dc:	e0bffe17 	ldw	r2,-8(fp)
 200e9e0:	10800f17 	ldw	r2,60(r2)
 200e9e4:	1880031e 	bne	r3,r2,200e9f4 <xQueueIsQueueFullFromISR+0x38>
	{
		xReturn = pdTRUE;
 200e9e8:	00800044 	movi	r2,1
 200e9ec:	e0bffd15 	stw	r2,-12(fp)
 200e9f0:	00000106 	br	200e9f8 <xQueueIsQueueFullFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
 200e9f4:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 200e9f8:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 200e9fc:	e037883a 	mov	sp,fp
 200ea00:	df000017 	ldw	fp,0(sp)
 200ea04:	dec00104 	addi	sp,sp,4
 200ea08:	f800283a 	ret

0200ea0c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 200ea0c:	defffa04 	addi	sp,sp,-24
 200ea10:	dfc00515 	stw	ra,20(sp)
 200ea14:	df000415 	stw	fp,16(sp)
 200ea18:	df000404 	addi	fp,sp,16
 200ea1c:	e13ffd15 	stw	r4,-12(fp)
 200ea20:	e17ffe15 	stw	r5,-8(fp)
 200ea24:	e1bfff15 	stw	r6,-4(fp)
	Queue_t * const pxQueue = xQueue;
 200ea28:	e0bffd17 	ldw	r2,-12(fp)
 200ea2c:	e0bffc15 	stw	r2,-16(fp)
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 200ea30:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200ea34:	10000126 	beq	r2,zero,200ea3c <vQueueWaitForMessageRestricted+0x30>
 200ea38:	2010de80 	call	2010de8 <vTaskEnterCritical>
 200ea3c:	e0bffc17 	ldw	r2,-16(fp)
 200ea40:	10801103 	ldbu	r2,68(r2)
 200ea44:	10803fcc 	andi	r2,r2,255
 200ea48:	1080201c 	xori	r2,r2,128
 200ea4c:	10bfe004 	addi	r2,r2,-128
 200ea50:	10bfffd8 	cmpnei	r2,r2,-1
 200ea54:	1000021e 	bne	r2,zero,200ea60 <vQueueWaitForMessageRestricted+0x54>
 200ea58:	e0bffc17 	ldw	r2,-16(fp)
 200ea5c:	10001105 	stb	zero,68(r2)
 200ea60:	e0bffc17 	ldw	r2,-16(fp)
 200ea64:	10801143 	ldbu	r2,69(r2)
 200ea68:	10803fcc 	andi	r2,r2,255
 200ea6c:	1080201c 	xori	r2,r2,128
 200ea70:	10bfe004 	addi	r2,r2,-128
 200ea74:	10bfffd8 	cmpnei	r2,r2,-1
 200ea78:	1000021e 	bne	r2,zero,200ea84 <vQueueWaitForMessageRestricted+0x78>
 200ea7c:	e0bffc17 	ldw	r2,-16(fp)
 200ea80:	10001145 	stb	zero,69(r2)
 200ea84:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200ea88:	10000126 	beq	r2,zero,200ea90 <vQueueWaitForMessageRestricted+0x84>
 200ea8c:	2010e300 	call	2010e30 <vTaskExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 200ea90:	e0bffc17 	ldw	r2,-16(fp)
 200ea94:	10800e17 	ldw	r2,56(r2)
 200ea98:	1000061e 	bne	r2,zero,200eab4 <vQueueWaitForMessageRestricted+0xa8>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 200ea9c:	e0bffc17 	ldw	r2,-16(fp)
 200eaa0:	10800904 	addi	r2,r2,36
 200eaa4:	e1bfff17 	ldw	r6,-4(fp)
 200eaa8:	e17ffe17 	ldw	r5,-8(fp)
 200eaac:	1009883a 	mov	r4,r2
 200eab0:	20100600 	call	2010060 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 200eab4:	e13ffc17 	ldw	r4,-16(fp)
 200eab8:	200e7980 	call	200e798 <prvUnlockQueue>
	}
 200eabc:	0001883a 	nop
 200eac0:	e037883a 	mov	sp,fp
 200eac4:	dfc00117 	ldw	ra,4(sp)
 200eac8:	df000017 	ldw	fp,0(sp)
 200eacc:	dec00204 	addi	sp,sp,8
 200ead0:	f800283a 	ret

0200ead4 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 200ead4:	defff304 	addi	sp,sp,-52
 200ead8:	dfc00c15 	stw	ra,48(sp)
 200eadc:	df000b15 	stw	fp,44(sp)
 200eae0:	df000b04 	addi	fp,sp,44
 200eae4:	e13ffc15 	stw	r4,-16(fp)
 200eae8:	e17ffd15 	stw	r5,-12(fp)
 200eaec:	e1bffe15 	stw	r6,-8(fp)
 200eaf0:	e1ffff15 	stw	r7,-4(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 200eaf4:	e0bffe17 	ldw	r2,-8(fp)
 200eaf8:	1085883a 	add	r2,r2,r2
 200eafc:	1085883a 	add	r2,r2,r2
 200eb00:	1009883a 	mov	r4,r2
 200eb04:	202d6700 	call	202d670 <pvPortMalloc>
 200eb08:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
 200eb0c:	e0bffb17 	ldw	r2,-20(fp)
 200eb10:	10000c26 	beq	r2,zero,200eb44 <xTaskCreate+0x70>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 200eb14:	01001e04 	movi	r4,120
 200eb18:	202d6700 	call	202d670 <pvPortMalloc>
 200eb1c:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
 200eb20:	e0bff917 	ldw	r2,-28(fp)
 200eb24:	10000426 	beq	r2,zero,200eb38 <xTaskCreate+0x64>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 200eb28:	e0bff917 	ldw	r2,-28(fp)
 200eb2c:	e0fffb17 	ldw	r3,-20(fp)
 200eb30:	10c00c15 	stw	r3,48(r2)
 200eb34:	00000406 	br	200eb48 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 200eb38:	e13ffb17 	ldw	r4,-20(fp)
 200eb3c:	202d7300 	call	202d730 <vPortFree>
 200eb40:	00000106 	br	200eb48 <xTaskCreate+0x74>
				}
			}
			else
			{
				pxNewTCB = NULL;
 200eb44:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 200eb48:	e0bff917 	ldw	r2,-28(fp)
 200eb4c:	10001126 	beq	r2,zero,200eb94 <xTaskCreate+0xc0>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 200eb50:	d8000315 	stw	zero,12(sp)
 200eb54:	e0bff917 	ldw	r2,-28(fp)
 200eb58:	d8800215 	stw	r2,8(sp)
 200eb5c:	e0800317 	ldw	r2,12(fp)
 200eb60:	d8800115 	stw	r2,4(sp)
 200eb64:	e0800217 	ldw	r2,8(fp)
 200eb68:	d8800015 	stw	r2,0(sp)
 200eb6c:	e1ffff17 	ldw	r7,-4(fp)
 200eb70:	e1bffe17 	ldw	r6,-8(fp)
 200eb74:	e17ffd17 	ldw	r5,-12(fp)
 200eb78:	e13ffc17 	ldw	r4,-16(fp)
 200eb7c:	200ebb40 	call	200ebb4 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 200eb80:	e13ff917 	ldw	r4,-28(fp)
 200eb84:	200ed980 	call	200ed98 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 200eb88:	00800044 	movi	r2,1
 200eb8c:	e0bffa15 	stw	r2,-24(fp)
 200eb90:	00000206 	br	200eb9c <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 200eb94:	00bfffc4 	movi	r2,-1
 200eb98:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
 200eb9c:	e0bffa17 	ldw	r2,-24(fp)
	}
 200eba0:	e037883a 	mov	sp,fp
 200eba4:	dfc00117 	ldw	ra,4(sp)
 200eba8:	df000017 	ldw	fp,0(sp)
 200ebac:	dec00204 	addi	sp,sp,8
 200ebb0:	f800283a 	ret

0200ebb4 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 200ebb4:	defff804 	addi	sp,sp,-32
 200ebb8:	dfc00715 	stw	ra,28(sp)
 200ebbc:	df000615 	stw	fp,24(sp)
 200ebc0:	df000604 	addi	fp,sp,24
 200ebc4:	e13ffc15 	stw	r4,-16(fp)
 200ebc8:	e17ffd15 	stw	r5,-12(fp)
 200ebcc:	e1bffe15 	stw	r6,-8(fp)
 200ebd0:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 200ebd4:	e0800417 	ldw	r2,16(fp)
 200ebd8:	10c00c17 	ldw	r3,48(r2)
 200ebdc:	e0bffe17 	ldw	r2,-8(fp)
 200ebe0:	1085883a 	add	r2,r2,r2
 200ebe4:	1085883a 	add	r2,r2,r2
 200ebe8:	100d883a 	mov	r6,r2
 200ebec:	01402944 	movi	r5,165
 200ebf0:	1809883a 	mov	r4,r3
 200ebf4:	2005fa00 	call	2005fa0 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 200ebf8:	e0800417 	ldw	r2,16(fp)
 200ebfc:	10c00c17 	ldw	r3,48(r2)
 200ec00:	e13ffe17 	ldw	r4,-8(fp)
 200ec04:	00900034 	movhi	r2,16384
 200ec08:	10bfffc4 	addi	r2,r2,-1
 200ec0c:	2085883a 	add	r2,r4,r2
 200ec10:	1085883a 	add	r2,r2,r2
 200ec14:	1085883a 	add	r2,r2,r2
 200ec18:	1885883a 	add	r2,r3,r2
 200ec1c:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 200ec20:	e0fffb17 	ldw	r3,-20(fp)
 200ec24:	00bfff04 	movi	r2,-4
 200ec28:	1884703a 	and	r2,r3,r2
 200ec2c:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 200ec30:	e0bffd17 	ldw	r2,-12(fp)
 200ec34:	10001e26 	beq	r2,zero,200ecb0 <prvInitialiseNewTask+0xfc>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 200ec38:	e03ffa15 	stw	zero,-24(fp)
 200ec3c:	00001406 	br	200ec90 <prvInitialiseNewTask+0xdc>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 200ec40:	e0fffd17 	ldw	r3,-12(fp)
 200ec44:	e0bffa17 	ldw	r2,-24(fp)
 200ec48:	1885883a 	add	r2,r3,r2
 200ec4c:	10c00003 	ldbu	r3,0(r2)
 200ec50:	e1000417 	ldw	r4,16(fp)
 200ec54:	e0bffa17 	ldw	r2,-24(fp)
 200ec58:	2085883a 	add	r2,r4,r2
 200ec5c:	10800d04 	addi	r2,r2,52
 200ec60:	10c00005 	stb	r3,0(r2)

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 200ec64:	e0fffd17 	ldw	r3,-12(fp)
 200ec68:	e0bffa17 	ldw	r2,-24(fp)
 200ec6c:	1885883a 	add	r2,r3,r2
 200ec70:	10800003 	ldbu	r2,0(r2)
 200ec74:	10803fcc 	andi	r2,r2,255
 200ec78:	1080201c 	xori	r2,r2,128
 200ec7c:	10bfe004 	addi	r2,r2,-128
 200ec80:	10000726 	beq	r2,zero,200eca0 <prvInitialiseNewTask+0xec>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 200ec84:	e0bffa17 	ldw	r2,-24(fp)
 200ec88:	10800044 	addi	r2,r2,1
 200ec8c:	e0bffa15 	stw	r2,-24(fp)
 200ec90:	e0bffa17 	ldw	r2,-24(fp)
 200ec94:	10800a30 	cmpltui	r2,r2,40
 200ec98:	103fe91e 	bne	r2,zero,200ec40 <__alt_mem_mem_0+0xfcfeec40>
 200ec9c:	00000106 	br	200eca4 <prvInitialiseNewTask+0xf0>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
 200eca0:	0001883a 	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 200eca4:	e0800417 	ldw	r2,16(fp)
 200eca8:	100016c5 	stb	zero,91(r2)
 200ecac:	00000206 	br	200ecb8 <prvInitialiseNewTask+0x104>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 200ecb0:	e0800417 	ldw	r2,16(fp)
 200ecb4:	10000d05 	stb	zero,52(r2)
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 200ecb8:	e0800217 	ldw	r2,8(fp)
 200ecbc:	10800170 	cmpltui	r2,r2,5
 200ecc0:	1000021e 	bne	r2,zero,200eccc <prvInitialiseNewTask+0x118>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 200ecc4:	00800104 	movi	r2,4
 200ecc8:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 200eccc:	e0800417 	ldw	r2,16(fp)
 200ecd0:	e0c00217 	ldw	r3,8(fp)
 200ecd4:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 200ecd8:	e0800417 	ldw	r2,16(fp)
 200ecdc:	e0c00217 	ldw	r3,8(fp)
 200ece0:	10c01a15 	stw	r3,104(r2)
		pxNewTCB->uxMutexesHeld = 0;
 200ece4:	e0800417 	ldw	r2,16(fp)
 200ece8:	10001b15 	stw	zero,108(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 200ecec:	e0800417 	ldw	r2,16(fp)
 200ecf0:	10800104 	addi	r2,r2,4
 200ecf4:	1009883a 	mov	r4,r2
 200ecf8:	202d80c0 	call	202d80c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 200ecfc:	e0800417 	ldw	r2,16(fp)
 200ed00:	10800604 	addi	r2,r2,24
 200ed04:	1009883a 	mov	r4,r2
 200ed08:	202d80c0 	call	202d80c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 200ed0c:	e0800417 	ldw	r2,16(fp)
 200ed10:	e0c00417 	ldw	r3,16(fp)
 200ed14:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200ed18:	00c00144 	movi	r3,5
 200ed1c:	e0800217 	ldw	r2,8(fp)
 200ed20:	1887c83a 	sub	r3,r3,r2
 200ed24:	e0800417 	ldw	r2,16(fp)
 200ed28:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 200ed2c:	e0800417 	ldw	r2,16(fp)
 200ed30:	e0c00417 	ldw	r3,16(fp)
 200ed34:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 200ed38:	e0800417 	ldw	r2,16(fp)
 200ed3c:	10001715 	stw	zero,92(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 200ed40:	e0800417 	ldw	r2,16(fp)
 200ed44:	10001c15 	stw	zero,112(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 200ed48:	e0800417 	ldw	r2,16(fp)
 200ed4c:	10001d05 	stb	zero,116(r2)
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 200ed50:	e1bfff17 	ldw	r6,-4(fp)
 200ed54:	e17ffc17 	ldw	r5,-16(fp)
 200ed58:	e13ffb17 	ldw	r4,-20(fp)
 200ed5c:	202daec0 	call	202daec <pxPortInitialiseStack>
 200ed60:	1007883a 	mov	r3,r2
 200ed64:	e0800417 	ldw	r2,16(fp)
 200ed68:	10c00015 	stw	r3,0(r2)
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 200ed6c:	e0800317 	ldw	r2,12(fp)
 200ed70:	10000326 	beq	r2,zero,200ed80 <prvInitialiseNewTask+0x1cc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 200ed74:	e0800317 	ldw	r2,12(fp)
 200ed78:	e0c00417 	ldw	r3,16(fp)
 200ed7c:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 200ed80:	0001883a 	nop
 200ed84:	e037883a 	mov	sp,fp
 200ed88:	dfc00117 	ldw	ra,4(sp)
 200ed8c:	df000017 	ldw	fp,0(sp)
 200ed90:	dec00204 	addi	sp,sp,8
 200ed94:	f800283a 	ret

0200ed98 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 200ed98:	defffd04 	addi	sp,sp,-12
 200ed9c:	dfc00215 	stw	ra,8(sp)
 200eda0:	df000115 	stw	fp,4(sp)
 200eda4:	df000104 	addi	fp,sp,4
 200eda8:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 200edac:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200edb0:	10000126 	beq	r2,zero,200edb8 <prvAddNewTaskToReadyList+0x20>
 200edb4:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 200edb8:	d0a7ad17 	ldw	r2,-24908(gp)
 200edbc:	10800044 	addi	r2,r2,1
 200edc0:	d0a7ad15 	stw	r2,-24908(gp)
		if( pxCurrentTCB == NULL )
 200edc4:	d0a7a917 	ldw	r2,-24924(gp)
 200edc8:	1000071e 	bne	r2,zero,200ede8 <prvAddNewTaskToReadyList+0x50>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 200edcc:	e0bfff17 	ldw	r2,-4(fp)
 200edd0:	d0a7a915 	stw	r2,-24924(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 200edd4:	d0a7ad17 	ldw	r2,-24908(gp)
 200edd8:	10800058 	cmpnei	r2,r2,1
 200eddc:	10000b1e 	bne	r2,zero,200ee0c <prvAddNewTaskToReadyList+0x74>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 200ede0:	20104d80 	call	20104d8 <prvInitialiseTaskLists>
 200ede4:	00000906 	br	200ee0c <prvAddNewTaskToReadyList+0x74>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 200ede8:	d0a7b017 	ldw	r2,-24896(gp)
 200edec:	1000071e 	bne	r2,zero,200ee0c <prvAddNewTaskToReadyList+0x74>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 200edf0:	d0a7a917 	ldw	r2,-24924(gp)
 200edf4:	10800b17 	ldw	r2,44(r2)
 200edf8:	e0ffff17 	ldw	r3,-4(fp)
 200edfc:	18c00b17 	ldw	r3,44(r3)
 200ee00:	18800236 	bltu	r3,r2,200ee0c <prvAddNewTaskToReadyList+0x74>
				{
					pxCurrentTCB = pxNewTCB;
 200ee04:	e0bfff17 	ldw	r2,-4(fp)
 200ee08:	d0a7a915 	stw	r2,-24924(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 200ee0c:	d0a7b417 	ldw	r2,-24880(gp)
 200ee10:	10800044 	addi	r2,r2,1
 200ee14:	d0a7b415 	stw	r2,-24880(gp)

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 200ee18:	d0e7b417 	ldw	r3,-24880(gp)
 200ee1c:	e0bfff17 	ldw	r2,-4(fp)
 200ee20:	10c01815 	stw	r3,96(r2)
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 200ee24:	e0bfff17 	ldw	r2,-4(fp)
 200ee28:	10800b17 	ldw	r2,44(r2)
 200ee2c:	d0e7af17 	ldw	r3,-24900(gp)
 200ee30:	1880032e 	bgeu	r3,r2,200ee40 <prvAddNewTaskToReadyList+0xa8>
 200ee34:	e0bfff17 	ldw	r2,-4(fp)
 200ee38:	10800b17 	ldw	r2,44(r2)
 200ee3c:	d0a7af15 	stw	r2,-24900(gp)
 200ee40:	e0bfff17 	ldw	r2,-4(fp)
 200ee44:	10800b17 	ldw	r2,44(r2)
 200ee48:	10c00524 	muli	r3,r2,20
 200ee4c:	00808174 	movhi	r2,517
 200ee50:	10b34d04 	addi	r2,r2,-13004
 200ee54:	1887883a 	add	r3,r3,r2
 200ee58:	e0bfff17 	ldw	r2,-4(fp)
 200ee5c:	10800104 	addi	r2,r2,4
 200ee60:	100b883a 	mov	r5,r2
 200ee64:	1809883a 	mov	r4,r3
 200ee68:	202d8380 	call	202d838 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 200ee6c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200ee70:	10000126 	beq	r2,zero,200ee78 <prvAddNewTaskToReadyList+0xe0>
 200ee74:	2010e300 	call	2010e30 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
 200ee78:	d0a7b017 	ldw	r2,-24896(gp)
 200ee7c:	10000626 	beq	r2,zero,200ee98 <prvAddNewTaskToReadyList+0x100>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 200ee80:	d0a7a917 	ldw	r2,-24924(gp)
 200ee84:	10c00b17 	ldw	r3,44(r2)
 200ee88:	e0bfff17 	ldw	r2,-4(fp)
 200ee8c:	10800b17 	ldw	r2,44(r2)
 200ee90:	1880012e 	bgeu	r3,r2,200ee98 <prvAddNewTaskToReadyList+0x100>
		{
			taskYIELD_IF_USING_PREEMPTION();
 200ee94:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 200ee98:	0001883a 	nop
 200ee9c:	e037883a 	mov	sp,fp
 200eea0:	dfc00117 	ldw	ra,4(sp)
 200eea4:	df000017 	ldw	fp,0(sp)
 200eea8:	dec00204 	addi	sp,sp,8
 200eeac:	f800283a 	ret

0200eeb0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 200eeb0:	defffc04 	addi	sp,sp,-16
 200eeb4:	dfc00315 	stw	ra,12(sp)
 200eeb8:	df000215 	stw	fp,8(sp)
 200eebc:	df000204 	addi	fp,sp,8
 200eec0:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 200eec4:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200eec8:	10000126 	beq	r2,zero,200eed0 <vTaskDelete+0x20>
 200eecc:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 200eed0:	e0bfff17 	ldw	r2,-4(fp)
 200eed4:	1000021e 	bne	r2,zero,200eee0 <vTaskDelete+0x30>
 200eed8:	d0a7a917 	ldw	r2,-24924(gp)
 200eedc:	00000106 	br	200eee4 <vTaskDelete+0x34>
 200eee0:	e0bfff17 	ldw	r2,-4(fp)
 200eee4:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 200eee8:	e0bffe17 	ldw	r2,-8(fp)
 200eeec:	10800104 	addi	r2,r2,4
 200eef0:	1009883a 	mov	r4,r2
 200eef4:	202d99c0 	call	202d99c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 200eef8:	e0bffe17 	ldw	r2,-8(fp)
 200eefc:	10800a17 	ldw	r2,40(r2)
 200ef00:	10000426 	beq	r2,zero,200ef14 <vTaskDelete+0x64>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 200ef04:	e0bffe17 	ldw	r2,-8(fp)
 200ef08:	10800604 	addi	r2,r2,24
 200ef0c:	1009883a 	mov	r4,r2
 200ef10:	202d99c0 	call	202d99c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
 200ef14:	d0a7b417 	ldw	r2,-24880(gp)
 200ef18:	10800044 	addi	r2,r2,1
 200ef1c:	d0a7b415 	stw	r2,-24880(gp)

			if( pxTCB == pxCurrentTCB )
 200ef20:	d0a7a917 	ldw	r2,-24924(gp)
 200ef24:	e0fffe17 	ldw	r3,-8(fp)
 200ef28:	18800a1e 	bne	r3,r2,200ef54 <vTaskDelete+0xa4>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 200ef2c:	e0bffe17 	ldw	r2,-8(fp)
 200ef30:	10800104 	addi	r2,r2,4
 200ef34:	100b883a 	mov	r5,r2
 200ef38:	01008174 	movhi	r4,517
 200ef3c:	21337504 	addi	r4,r4,-12844
 200ef40:	202d8380 	call	202d838 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
 200ef44:	d0a7ac17 	ldw	r2,-24912(gp)
 200ef48:	10800044 	addi	r2,r2,1
 200ef4c:	d0a7ac15 	stw	r2,-24912(gp)
 200ef50:	00000606 	br	200ef6c <vTaskDelete+0xbc>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
 200ef54:	d0a7ad17 	ldw	r2,-24908(gp)
 200ef58:	10bfffc4 	addi	r2,r2,-1
 200ef5c:	d0a7ad15 	stw	r2,-24908(gp)
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
 200ef60:	e13ffe17 	ldw	r4,-8(fp)
 200ef64:	20109600 	call	2010960 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
 200ef68:	20109a40 	call	20109a4 <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
 200ef6c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200ef70:	10000126 	beq	r2,zero,200ef78 <vTaskDelete+0xc8>
 200ef74:	2010e300 	call	2010e30 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 200ef78:	d0a7b017 	ldw	r2,-24896(gp)
 200ef7c:	10000426 	beq	r2,zero,200ef90 <vTaskDelete+0xe0>
		{
			if( pxTCB == pxCurrentTCB )
 200ef80:	d0a7a917 	ldw	r2,-24924(gp)
 200ef84:	e0fffe17 	ldw	r3,-8(fp)
 200ef88:	1880011e 	bne	r3,r2,200ef90 <vTaskDelete+0xe0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 200ef8c:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 200ef90:	0001883a 	nop
 200ef94:	e037883a 	mov	sp,fp
 200ef98:	dfc00117 	ldw	ra,4(sp)
 200ef9c:	df000017 	ldw	fp,0(sp)
 200efa0:	dec00204 	addi	sp,sp,8
 200efa4:	f800283a 	ret

0200efa8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 200efa8:	defff804 	addi	sp,sp,-32
 200efac:	dfc00715 	stw	ra,28(sp)
 200efb0:	df000615 	stw	fp,24(sp)
 200efb4:	df000604 	addi	fp,sp,24
 200efb8:	e13ffe15 	stw	r4,-8(fp)
 200efbc:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 200efc0:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 200efc4:	200f8840 	call	200f884 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 200efc8:	d0a7ae17 	ldw	r2,-24904(gp)
 200efcc:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 200efd0:	e0bffe17 	ldw	r2,-8(fp)
 200efd4:	10c00017 	ldw	r3,0(r2)
 200efd8:	e0bfff17 	ldw	r2,-4(fp)
 200efdc:	1885883a 	add	r2,r3,r2
 200efe0:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
 200efe4:	e0bffe17 	ldw	r2,-8(fp)
 200efe8:	10800017 	ldw	r2,0(r2)
 200efec:	e0fffb17 	ldw	r3,-20(fp)
 200eff0:	18800a2e 	bgeu	r3,r2,200f01c <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 200eff4:	e0bffe17 	ldw	r2,-8(fp)
 200eff8:	10800017 	ldw	r2,0(r2)
 200effc:	e0fffc17 	ldw	r3,-16(fp)
 200f000:	18800f2e 	bgeu	r3,r2,200f040 <vTaskDelayUntil+0x98>
 200f004:	e0bffc17 	ldw	r2,-16(fp)
 200f008:	e0fffb17 	ldw	r3,-20(fp)
 200f00c:	18800c2e 	bgeu	r3,r2,200f040 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 200f010:	00800044 	movi	r2,1
 200f014:	e0bffa15 	stw	r2,-24(fp)
 200f018:	00000906 	br	200f040 <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 200f01c:	e0bffe17 	ldw	r2,-8(fp)
 200f020:	10800017 	ldw	r2,0(r2)
 200f024:	e0fffc17 	ldw	r3,-16(fp)
 200f028:	18800336 	bltu	r3,r2,200f038 <vTaskDelayUntil+0x90>
 200f02c:	e0bffc17 	ldw	r2,-16(fp)
 200f030:	e0fffb17 	ldw	r3,-20(fp)
 200f034:	1880022e 	bgeu	r3,r2,200f040 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 200f038:	00800044 	movi	r2,1
 200f03c:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 200f040:	e0bffe17 	ldw	r2,-8(fp)
 200f044:	e0fffc17 	ldw	r3,-16(fp)
 200f048:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
 200f04c:	e0bffa17 	ldw	r2,-24(fp)
 200f050:	10000626 	beq	r2,zero,200f06c <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 200f054:	e0fffc17 	ldw	r3,-16(fp)
 200f058:	e0bffb17 	ldw	r2,-20(fp)
 200f05c:	1885c83a 	sub	r2,r3,r2
 200f060:	000b883a 	mov	r5,zero
 200f064:	1009883a 	mov	r4,r2
 200f068:	20116bc0 	call	20116bc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 200f06c:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200f070:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 200f074:	e0bffd17 	ldw	r2,-12(fp)
 200f078:	1000011e 	bne	r2,zero,200f080 <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
 200f07c:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f080:	0001883a 	nop
 200f084:	e037883a 	mov	sp,fp
 200f088:	dfc00117 	ldw	ra,4(sp)
 200f08c:	df000017 	ldw	fp,0(sp)
 200f090:	dec00204 	addi	sp,sp,8
 200f094:	f800283a 	ret

0200f098 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 200f098:	defffc04 	addi	sp,sp,-16
 200f09c:	dfc00315 	stw	ra,12(sp)
 200f0a0:	df000215 	stw	fp,8(sp)
 200f0a4:	df000204 	addi	fp,sp,8
 200f0a8:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
 200f0ac:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 200f0b0:	e0bfff17 	ldw	r2,-4(fp)
 200f0b4:	10000626 	beq	r2,zero,200f0d0 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 200f0b8:	200f8840 	call	200f884 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 200f0bc:	000b883a 	mov	r5,zero
 200f0c0:	e13fff17 	ldw	r4,-4(fp)
 200f0c4:	20116bc0 	call	20116bc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 200f0c8:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200f0cc:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 200f0d0:	e0bffe17 	ldw	r2,-8(fp)
 200f0d4:	1000011e 	bne	r2,zero,200f0dc <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
 200f0d8:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f0dc:	0001883a 	nop
 200f0e0:	e037883a 	mov	sp,fp
 200f0e4:	dfc00117 	ldw	ra,4(sp)
 200f0e8:	df000017 	ldw	fp,0(sp)
 200f0ec:	dec00204 	addi	sp,sp,8
 200f0f0:	f800283a 	ret

0200f0f4 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
 200f0f4:	defff804 	addi	sp,sp,-32
 200f0f8:	dfc00715 	stw	ra,28(sp)
 200f0fc:	df000615 	stw	fp,24(sp)
 200f100:	df000604 	addi	fp,sp,24
 200f104:	e13fff15 	stw	r4,-4(fp)
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
 200f108:	e0bfff17 	ldw	r2,-4(fp)
 200f10c:	e0bffb15 	stw	r2,-20(fp)

		configASSERT( pxTCB );

		if( pxTCB == pxCurrentTCB )
 200f110:	d0a7a917 	ldw	r2,-24924(gp)
 200f114:	e0fffb17 	ldw	r3,-20(fp)
 200f118:	1880021e 	bne	r3,r2,200f124 <eTaskGetState+0x30>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
 200f11c:	e03ffa15 	stw	zero,-24(fp)
 200f120:	00003606 	br	200f1fc <eTaskGetState+0x108>
		}
		else
		{
			taskENTER_CRITICAL();
 200f124:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f128:	10000126 	beq	r2,zero,200f130 <eTaskGetState+0x3c>
 200f12c:	2010de80 	call	2010de8 <vTaskEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 200f130:	e0bffb17 	ldw	r2,-20(fp)
 200f134:	10800517 	ldw	r2,20(r2)
 200f138:	e0bffc15 	stw	r2,-16(fp)
				pxDelayedList = pxDelayedTaskList;
 200f13c:	d0a7aa17 	ldw	r2,-24920(gp)
 200f140:	e0bffd15 	stw	r2,-12(fp)
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 200f144:	d0a7ab17 	ldw	r2,-24916(gp)
 200f148:	e0bffe15 	stw	r2,-8(fp)
			}
			taskEXIT_CRITICAL();
 200f14c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f150:	10000126 	beq	r2,zero,200f158 <eTaskGetState+0x64>
 200f154:	2010e300 	call	2010e30 <vTaskExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 200f158:	e0fffc17 	ldw	r3,-16(fp)
 200f15c:	e0bffd17 	ldw	r2,-12(fp)
 200f160:	18800326 	beq	r3,r2,200f170 <eTaskGetState+0x7c>
 200f164:	e0fffc17 	ldw	r3,-16(fp)
 200f168:	e0bffe17 	ldw	r2,-8(fp)
 200f16c:	1880031e 	bne	r3,r2,200f17c <eTaskGetState+0x88>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
 200f170:	00800084 	movi	r2,2
 200f174:	e0bffa15 	stw	r2,-24(fp)
 200f178:	00002006 	br	200f1fc <eTaskGetState+0x108>
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
 200f17c:	e0fffc17 	ldw	r3,-16(fp)
 200f180:	00808174 	movhi	r2,517
 200f184:	10b37a04 	addi	r2,r2,-12824
 200f188:	1880111e 	bne	r3,r2,200f1d0 <eTaskGetState+0xdc>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 200f18c:	e0bffb17 	ldw	r2,-20(fp)
 200f190:	10800a17 	ldw	r2,40(r2)
 200f194:	10000b1e 	bne	r2,zero,200f1c4 <eTaskGetState+0xd0>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 200f198:	e0bffb17 	ldw	r2,-20(fp)
 200f19c:	10801d03 	ldbu	r2,116(r2)
 200f1a0:	10803fcc 	andi	r2,r2,255
 200f1a4:	10800058 	cmpnei	r2,r2,1
 200f1a8:	1000031e 	bne	r2,zero,200f1b8 <eTaskGetState+0xc4>
							{
								eReturn = eBlocked;
 200f1ac:	00800084 	movi	r2,2
 200f1b0:	e0bffa15 	stw	r2,-24(fp)
 200f1b4:	00001106 	br	200f1fc <eTaskGetState+0x108>
							}
							else
							{
								eReturn = eSuspended;
 200f1b8:	008000c4 	movi	r2,3
 200f1bc:	e0bffa15 	stw	r2,-24(fp)
 200f1c0:	00000e06 	br	200f1fc <eTaskGetState+0x108>
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
 200f1c4:	00800084 	movi	r2,2
 200f1c8:	e0bffa15 	stw	r2,-24(fp)
 200f1cc:	00000b06 	br	200f1fc <eTaskGetState+0x108>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 200f1d0:	e0fffc17 	ldw	r3,-16(fp)
 200f1d4:	00808174 	movhi	r2,517
 200f1d8:	10b37504 	addi	r2,r2,-12844
 200f1dc:	18800226 	beq	r3,r2,200f1e8 <eTaskGetState+0xf4>
 200f1e0:	e0bffc17 	ldw	r2,-16(fp)
 200f1e4:	1000031e 	bne	r2,zero,200f1f4 <eTaskGetState+0x100>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
 200f1e8:	00800104 	movi	r2,4
 200f1ec:	e0bffa15 	stw	r2,-24(fp)
 200f1f0:	00000206 	br	200f1fc <eTaskGetState+0x108>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
 200f1f4:	00800044 	movi	r2,1
 200f1f8:	e0bffa15 	stw	r2,-24(fp)
			}
		}

		return eReturn;
 200f1fc:	e0bffa17 	ldw	r2,-24(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 200f200:	e037883a 	mov	sp,fp
 200f204:	dfc00117 	ldw	ra,4(sp)
 200f208:	df000017 	ldw	fp,0(sp)
 200f20c:	dec00204 	addi	sp,sp,8
 200f210:	f800283a 	ret

0200f214 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
 200f214:	defffb04 	addi	sp,sp,-20
 200f218:	dfc00415 	stw	ra,16(sp)
 200f21c:	df000315 	stw	fp,12(sp)
 200f220:	df000304 	addi	fp,sp,12
 200f224:	e13fff15 	stw	r4,-4(fp)
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 200f228:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f22c:	10000126 	beq	r2,zero,200f234 <uxTaskPriorityGet+0x20>
 200f230:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 200f234:	e0bfff17 	ldw	r2,-4(fp)
 200f238:	1000021e 	bne	r2,zero,200f244 <uxTaskPriorityGet+0x30>
 200f23c:	d0a7a917 	ldw	r2,-24924(gp)
 200f240:	00000106 	br	200f248 <uxTaskPriorityGet+0x34>
 200f244:	e0bfff17 	ldw	r2,-4(fp)
 200f248:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 200f24c:	e0bffd17 	ldw	r2,-12(fp)
 200f250:	10800b17 	ldw	r2,44(r2)
 200f254:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
 200f258:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f25c:	10000126 	beq	r2,zero,200f264 <uxTaskPriorityGet+0x50>
 200f260:	2010e300 	call	2010e30 <vTaskExitCritical>

		return uxReturn;
 200f264:	e0bffe17 	ldw	r2,-8(fp)
	}
 200f268:	e037883a 	mov	sp,fp
 200f26c:	dfc00117 	ldw	ra,4(sp)
 200f270:	df000017 	ldw	fp,0(sp)
 200f274:	dec00204 	addi	sp,sp,8
 200f278:	f800283a 	ret

0200f27c <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
 200f27c:	defffb04 	addi	sp,sp,-20
 200f280:	df000415 	stw	fp,16(sp)
 200f284:	df000404 	addi	fp,sp,16
 200f288:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 200f28c:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 200f290:	e0bfff17 	ldw	r2,-4(fp)
 200f294:	1000021e 	bne	r2,zero,200f2a0 <uxTaskPriorityGetFromISR+0x24>
 200f298:	d0a7a917 	ldw	r2,-24924(gp)
 200f29c:	00000106 	br	200f2a4 <uxTaskPriorityGetFromISR+0x28>
 200f2a0:	e0bfff17 	ldw	r2,-4(fp)
 200f2a4:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 200f2a8:	e0bffd17 	ldw	r2,-12(fp)
 200f2ac:	10800b17 	ldw	r2,44(r2)
 200f2b0:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
 200f2b4:	e0bffe17 	ldw	r2,-8(fp)
	}
 200f2b8:	e037883a 	mov	sp,fp
 200f2bc:	df000017 	ldw	fp,0(sp)
 200f2c0:	dec00104 	addi	sp,sp,4
 200f2c4:	f800283a 	ret

0200f2c8 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 200f2c8:	defff804 	addi	sp,sp,-32
 200f2cc:	dfc00715 	stw	ra,28(sp)
 200f2d0:	df000615 	stw	fp,24(sp)
 200f2d4:	df000604 	addi	fp,sp,24
 200f2d8:	e13ffe15 	stw	r4,-8(fp)
 200f2dc:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 200f2e0:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 200f2e4:	e0bfff17 	ldw	r2,-4(fp)
 200f2e8:	10800170 	cmpltui	r2,r2,5
 200f2ec:	1000021e 	bne	r2,zero,200f2f8 <vTaskPrioritySet+0x30>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 200f2f0:	00800104 	movi	r2,4
 200f2f4:	e0bfff15 	stw	r2,-4(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 200f2f8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f2fc:	10000126 	beq	r2,zero,200f304 <vTaskPrioritySet+0x3c>
 200f300:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 200f304:	e0bffe17 	ldw	r2,-8(fp)
 200f308:	1000021e 	bne	r2,zero,200f314 <vTaskPrioritySet+0x4c>
 200f30c:	d0a7a917 	ldw	r2,-24924(gp)
 200f310:	00000106 	br	200f318 <vTaskPrioritySet+0x50>
 200f314:	e0bffe17 	ldw	r2,-8(fp)
 200f318:	e0bffb15 	stw	r2,-20(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 200f31c:	e0bffb17 	ldw	r2,-20(fp)
 200f320:	10801a17 	ldw	r2,104(r2)
 200f324:	e0bffc15 	stw	r2,-16(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 200f328:	e0fffc17 	ldw	r3,-16(fp)
 200f32c:	e0bfff17 	ldw	r2,-4(fp)
 200f330:	18804926 	beq	r3,r2,200f458 <vTaskPrioritySet+0x190>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 200f334:	e0bfff17 	ldw	r2,-4(fp)
 200f338:	e0fffc17 	ldw	r3,-16(fp)
 200f33c:	18800a2e 	bgeu	r3,r2,200f368 <vTaskPrioritySet+0xa0>
				{
					if( pxTCB != pxCurrentTCB )
 200f340:	d0a7a917 	ldw	r2,-24924(gp)
 200f344:	e0fffb17 	ldw	r3,-20(fp)
 200f348:	18800c26 	beq	r3,r2,200f37c <vTaskPrioritySet+0xb4>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 200f34c:	d0a7a917 	ldw	r2,-24924(gp)
 200f350:	10800b17 	ldw	r2,44(r2)
 200f354:	e0ffff17 	ldw	r3,-4(fp)
 200f358:	18800836 	bltu	r3,r2,200f37c <vTaskPrioritySet+0xb4>
						{
							xYieldRequired = pdTRUE;
 200f35c:	00800044 	movi	r2,1
 200f360:	e0bffa15 	stw	r2,-24(fp)
 200f364:	00000506 	br	200f37c <vTaskPrioritySet+0xb4>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 200f368:	d0a7a917 	ldw	r2,-24924(gp)
 200f36c:	e0fffb17 	ldw	r3,-20(fp)
 200f370:	1880021e 	bne	r3,r2,200f37c <vTaskPrioritySet+0xb4>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
 200f374:	00800044 	movi	r2,1
 200f378:	e0bffa15 	stw	r2,-24(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 200f37c:	e0bffb17 	ldw	r2,-20(fp)
 200f380:	10800b17 	ldw	r2,44(r2)
 200f384:	e0bffd15 	stw	r2,-12(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 200f388:	e0bffb17 	ldw	r2,-20(fp)
 200f38c:	10c01a17 	ldw	r3,104(r2)
 200f390:	e0bffb17 	ldw	r2,-20(fp)
 200f394:	10800b17 	ldw	r2,44(r2)
 200f398:	1880031e 	bne	r3,r2,200f3a8 <vTaskPrioritySet+0xe0>
					{
						pxTCB->uxPriority = uxNewPriority;
 200f39c:	e0bffb17 	ldw	r2,-20(fp)
 200f3a0:	e0ffff17 	ldw	r3,-4(fp)
 200f3a4:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 200f3a8:	e0bffb17 	ldw	r2,-20(fp)
 200f3ac:	e0ffff17 	ldw	r3,-4(fp)
 200f3b0:	10c01a15 	stw	r3,104(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 200f3b4:	e0bffb17 	ldw	r2,-20(fp)
 200f3b8:	10800617 	ldw	r2,24(r2)
 200f3bc:	10000516 	blt	r2,zero,200f3d4 <vTaskPrioritySet+0x10c>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200f3c0:	00c00144 	movi	r3,5
 200f3c4:	e0bfff17 	ldw	r2,-4(fp)
 200f3c8:	1887c83a 	sub	r3,r3,r2
 200f3cc:	e0bffb17 	ldw	r2,-20(fp)
 200f3d0:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 200f3d4:	e0bffb17 	ldw	r2,-20(fp)
 200f3d8:	10c00517 	ldw	r3,20(r2)
 200f3dc:	e0bffd17 	ldw	r2,-12(fp)
 200f3e0:	11000524 	muli	r4,r2,20
 200f3e4:	00808174 	movhi	r2,517
 200f3e8:	10b34d04 	addi	r2,r2,-13004
 200f3ec:	2085883a 	add	r2,r4,r2
 200f3f0:	1880161e 	bne	r3,r2,200f44c <vTaskPrioritySet+0x184>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 200f3f4:	e0bffb17 	ldw	r2,-20(fp)
 200f3f8:	10800104 	addi	r2,r2,4
 200f3fc:	1009883a 	mov	r4,r2
 200f400:	202d99c0 	call	202d99c <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 200f404:	e0bffb17 	ldw	r2,-20(fp)
 200f408:	10800b17 	ldw	r2,44(r2)
 200f40c:	d0e7af17 	ldw	r3,-24900(gp)
 200f410:	1880032e 	bgeu	r3,r2,200f420 <vTaskPrioritySet+0x158>
 200f414:	e0bffb17 	ldw	r2,-20(fp)
 200f418:	10800b17 	ldw	r2,44(r2)
 200f41c:	d0a7af15 	stw	r2,-24900(gp)
 200f420:	e0bffb17 	ldw	r2,-20(fp)
 200f424:	10800b17 	ldw	r2,44(r2)
 200f428:	10c00524 	muli	r3,r2,20
 200f42c:	00808174 	movhi	r2,517
 200f430:	10b34d04 	addi	r2,r2,-13004
 200f434:	1887883a 	add	r3,r3,r2
 200f438:	e0bffb17 	ldw	r2,-20(fp)
 200f43c:	10800104 	addi	r2,r2,4
 200f440:	100b883a 	mov	r5,r2
 200f444:	1809883a 	mov	r4,r3
 200f448:	202d8380 	call	202d838 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
 200f44c:	e0bffa17 	ldw	r2,-24(fp)
 200f450:	10000126 	beq	r2,zero,200f458 <vTaskPrioritySet+0x190>
				{
					taskYIELD_IF_USING_PREEMPTION();
 200f454:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 200f458:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f45c:	10000126 	beq	r2,zero,200f464 <vTaskPrioritySet+0x19c>
 200f460:	2010e300 	call	2010e30 <vTaskExitCritical>
	}
 200f464:	0001883a 	nop
 200f468:	e037883a 	mov	sp,fp
 200f46c:	dfc00117 	ldw	ra,4(sp)
 200f470:	df000017 	ldw	fp,0(sp)
 200f474:	dec00204 	addi	sp,sp,8
 200f478:	f800283a 	ret

0200f47c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 200f47c:	defffc04 	addi	sp,sp,-16
 200f480:	dfc00315 	stw	ra,12(sp)
 200f484:	df000215 	stw	fp,8(sp)
 200f488:	df000204 	addi	fp,sp,8
 200f48c:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 200f490:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f494:	10000126 	beq	r2,zero,200f49c <vTaskSuspend+0x20>
 200f498:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 200f49c:	e0bfff17 	ldw	r2,-4(fp)
 200f4a0:	1000021e 	bne	r2,zero,200f4ac <vTaskSuspend+0x30>
 200f4a4:	d0a7a917 	ldw	r2,-24924(gp)
 200f4a8:	00000106 	br	200f4b0 <vTaskSuspend+0x34>
 200f4ac:	e0bfff17 	ldw	r2,-4(fp)
 200f4b0:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 200f4b4:	e0bffe17 	ldw	r2,-8(fp)
 200f4b8:	10800104 	addi	r2,r2,4
 200f4bc:	1009883a 	mov	r4,r2
 200f4c0:	202d99c0 	call	202d99c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 200f4c4:	e0bffe17 	ldw	r2,-8(fp)
 200f4c8:	10800a17 	ldw	r2,40(r2)
 200f4cc:	10000426 	beq	r2,zero,200f4e0 <vTaskSuspend+0x64>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 200f4d0:	e0bffe17 	ldw	r2,-8(fp)
 200f4d4:	10800604 	addi	r2,r2,24
 200f4d8:	1009883a 	mov	r4,r2
 200f4dc:	202d99c0 	call	202d99c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 200f4e0:	e0bffe17 	ldw	r2,-8(fp)
 200f4e4:	10800104 	addi	r2,r2,4
 200f4e8:	100b883a 	mov	r5,r2
 200f4ec:	01008174 	movhi	r4,517
 200f4f0:	21337a04 	addi	r4,r4,-12824
 200f4f4:	202d8380 	call	202d838 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 200f4f8:	e0bffe17 	ldw	r2,-8(fp)
 200f4fc:	10801d03 	ldbu	r2,116(r2)
 200f500:	10803fcc 	andi	r2,r2,255
 200f504:	10800058 	cmpnei	r2,r2,1
 200f508:	1000021e 	bne	r2,zero,200f514 <vTaskSuspend+0x98>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 200f50c:	e0bffe17 	ldw	r2,-8(fp)
 200f510:	10001d05 	stb	zero,116(r2)
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
 200f514:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f518:	10000126 	beq	r2,zero,200f520 <vTaskSuspend+0xa4>
 200f51c:	2010e300 	call	2010e30 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
 200f520:	d0a7b017 	ldw	r2,-24896(gp)
 200f524:	10000726 	beq	r2,zero,200f544 <vTaskSuspend+0xc8>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 200f528:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f52c:	10000126 	beq	r2,zero,200f534 <vTaskSuspend+0xb8>
 200f530:	2010de80 	call	2010de8 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 200f534:	20109a40 	call	20109a4 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 200f538:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f53c:	10000126 	beq	r2,zero,200f544 <vTaskSuspend+0xc8>
 200f540:	2010e300 	call	2010e30 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 200f544:	d0a7a917 	ldw	r2,-24924(gp)
 200f548:	e0fffe17 	ldw	r3,-8(fp)
 200f54c:	18800c1e 	bne	r3,r2,200f580 <vTaskSuspend+0x104>
		{
			if( xSchedulerRunning != pdFALSE )
 200f550:	d0a7b017 	ldw	r2,-24896(gp)
 200f554:	10000226 	beq	r2,zero,200f560 <vTaskSuspend+0xe4>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 200f558:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f55c:	00000806 	br	200f580 <vTaskSuspend+0x104>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 200f560:	00808174 	movhi	r2,517
 200f564:	10b37a04 	addi	r2,r2,-12824
 200f568:	10c00017 	ldw	r3,0(r2)
 200f56c:	d0a7ad17 	ldw	r2,-24908(gp)
 200f570:	1880021e 	bne	r3,r2,200f57c <vTaskSuspend+0x100>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 200f574:	d027a915 	stw	zero,-24924(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f578:	00000106 	br	200f580 <vTaskSuspend+0x104>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 200f57c:	200fe500 	call	200fe50 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f580:	0001883a 	nop
 200f584:	e037883a 	mov	sp,fp
 200f588:	dfc00117 	ldw	ra,4(sp)
 200f58c:	df000017 	ldw	fp,0(sp)
 200f590:	dec00204 	addi	sp,sp,8
 200f594:	f800283a 	ret

0200f598 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
 200f598:	defffc04 	addi	sp,sp,-16
 200f59c:	df000315 	stw	fp,12(sp)
 200f5a0:	df000304 	addi	fp,sp,12
 200f5a4:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
 200f5a8:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = xTask;
 200f5ac:	e0bfff17 	ldw	r2,-4(fp)
 200f5b0:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 200f5b4:	e0bffe17 	ldw	r2,-8(fp)
 200f5b8:	10c00517 	ldw	r3,20(r2)
 200f5bc:	00808174 	movhi	r2,517
 200f5c0:	10b37a04 	addi	r2,r2,-12824
 200f5c4:	18800a1e 	bne	r3,r2,200f5f0 <prvTaskIsTaskSuspended+0x58>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 200f5c8:	e0bffe17 	ldw	r2,-8(fp)
 200f5cc:	10c00a17 	ldw	r3,40(r2)
 200f5d0:	00808174 	movhi	r2,517
 200f5d4:	10b37004 	addi	r2,r2,-12864
 200f5d8:	18800526 	beq	r3,r2,200f5f0 <prvTaskIsTaskSuspended+0x58>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 200f5dc:	e0bffe17 	ldw	r2,-8(fp)
 200f5e0:	10800a17 	ldw	r2,40(r2)
 200f5e4:	1000021e 	bne	r2,zero,200f5f0 <prvTaskIsTaskSuspended+0x58>
				{
					xReturn = pdTRUE;
 200f5e8:	00800044 	movi	r2,1
 200f5ec:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 200f5f0:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 200f5f4:	e037883a 	mov	sp,fp
 200f5f8:	df000017 	ldw	fp,0(sp)
 200f5fc:	dec00104 	addi	sp,sp,4
 200f600:	f800283a 	ret

0200f604 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 200f604:	defffc04 	addi	sp,sp,-16
 200f608:	dfc00315 	stw	ra,12(sp)
 200f60c:	df000215 	stw	fp,8(sp)
 200f610:	df000204 	addi	fp,sp,8
 200f614:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = xTaskToResume;
 200f618:	e0bfff17 	ldw	r2,-4(fp)
 200f61c:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 200f620:	d0a7a917 	ldw	r2,-24924(gp)
 200f624:	e0fffe17 	ldw	r3,-8(fp)
 200f628:	18802726 	beq	r3,r2,200f6c8 <vTaskResume+0xc4>
 200f62c:	e0bffe17 	ldw	r2,-8(fp)
 200f630:	10002526 	beq	r2,zero,200f6c8 <vTaskResume+0xc4>
		{
			taskENTER_CRITICAL();
 200f634:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f638:	10000126 	beq	r2,zero,200f640 <vTaskResume+0x3c>
 200f63c:	2010de80 	call	2010de8 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 200f640:	e13ffe17 	ldw	r4,-8(fp)
 200f644:	200f5980 	call	200f598 <prvTaskIsTaskSuspended>
 200f648:	10001c26 	beq	r2,zero,200f6bc <vTaskResume+0xb8>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 200f64c:	e0bffe17 	ldw	r2,-8(fp)
 200f650:	10800104 	addi	r2,r2,4
 200f654:	1009883a 	mov	r4,r2
 200f658:	202d99c0 	call	202d99c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 200f65c:	e0bffe17 	ldw	r2,-8(fp)
 200f660:	10800b17 	ldw	r2,44(r2)
 200f664:	d0e7af17 	ldw	r3,-24900(gp)
 200f668:	1880032e 	bgeu	r3,r2,200f678 <vTaskResume+0x74>
 200f66c:	e0bffe17 	ldw	r2,-8(fp)
 200f670:	10800b17 	ldw	r2,44(r2)
 200f674:	d0a7af15 	stw	r2,-24900(gp)
 200f678:	e0bffe17 	ldw	r2,-8(fp)
 200f67c:	10800b17 	ldw	r2,44(r2)
 200f680:	10c00524 	muli	r3,r2,20
 200f684:	00808174 	movhi	r2,517
 200f688:	10b34d04 	addi	r2,r2,-13004
 200f68c:	1887883a 	add	r3,r3,r2
 200f690:	e0bffe17 	ldw	r2,-8(fp)
 200f694:	10800104 	addi	r2,r2,4
 200f698:	100b883a 	mov	r5,r2
 200f69c:	1809883a 	mov	r4,r3
 200f6a0:	202d8380 	call	202d838 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 200f6a4:	e0bffe17 	ldw	r2,-8(fp)
 200f6a8:	10c00b17 	ldw	r3,44(r2)
 200f6ac:	d0a7a917 	ldw	r2,-24924(gp)
 200f6b0:	10800b17 	ldw	r2,44(r2)
 200f6b4:	18800136 	bltu	r3,r2,200f6bc <vTaskResume+0xb8>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 200f6b8:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 200f6bc:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f6c0:	10000126 	beq	r2,zero,200f6c8 <vTaskResume+0xc4>
 200f6c4:	2010e300 	call	2010e30 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f6c8:	0001883a 	nop
 200f6cc:	e037883a 	mov	sp,fp
 200f6d0:	dfc00117 	ldw	ra,4(sp)
 200f6d4:	df000017 	ldw	fp,0(sp)
 200f6d8:	dec00204 	addi	sp,sp,8
 200f6dc:	f800283a 	ret

0200f6e0 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 200f6e0:	defffa04 	addi	sp,sp,-24
 200f6e4:	dfc00515 	stw	ra,20(sp)
 200f6e8:	df000415 	stw	fp,16(sp)
 200f6ec:	df000404 	addi	fp,sp,16
 200f6f0:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
 200f6f4:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = xTaskToResume;
 200f6f8:	e0bfff17 	ldw	r2,-4(fp)
 200f6fc:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200f700:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 200f704:	e13ffd17 	ldw	r4,-12(fp)
 200f708:	200f5980 	call	200f598 <prvTaskIsTaskSuspended>
 200f70c:	10002626 	beq	r2,zero,200f7a8 <xTaskResumeFromISR+0xc8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 200f710:	d0a7b717 	ldw	r2,-24868(gp)
 200f714:	10001e1e 	bne	r2,zero,200f790 <xTaskResumeFromISR+0xb0>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 200f718:	e0bffd17 	ldw	r2,-12(fp)
 200f71c:	10c00b17 	ldw	r3,44(r2)
 200f720:	d0a7a917 	ldw	r2,-24924(gp)
 200f724:	10800b17 	ldw	r2,44(r2)
 200f728:	18800236 	bltu	r3,r2,200f734 <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
 200f72c:	00800044 	movi	r2,1
 200f730:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 200f734:	e0bffd17 	ldw	r2,-12(fp)
 200f738:	10800104 	addi	r2,r2,4
 200f73c:	1009883a 	mov	r4,r2
 200f740:	202d99c0 	call	202d99c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 200f744:	e0bffd17 	ldw	r2,-12(fp)
 200f748:	10800b17 	ldw	r2,44(r2)
 200f74c:	d0e7af17 	ldw	r3,-24900(gp)
 200f750:	1880032e 	bgeu	r3,r2,200f760 <xTaskResumeFromISR+0x80>
 200f754:	e0bffd17 	ldw	r2,-12(fp)
 200f758:	10800b17 	ldw	r2,44(r2)
 200f75c:	d0a7af15 	stw	r2,-24900(gp)
 200f760:	e0bffd17 	ldw	r2,-12(fp)
 200f764:	10800b17 	ldw	r2,44(r2)
 200f768:	10c00524 	muli	r3,r2,20
 200f76c:	00808174 	movhi	r2,517
 200f770:	10b34d04 	addi	r2,r2,-13004
 200f774:	1887883a 	add	r3,r3,r2
 200f778:	e0bffd17 	ldw	r2,-12(fp)
 200f77c:	10800104 	addi	r2,r2,4
 200f780:	100b883a 	mov	r5,r2
 200f784:	1809883a 	mov	r4,r3
 200f788:	202d8380 	call	202d838 <vListInsertEnd>
 200f78c:	00000606 	br	200f7a8 <xTaskResumeFromISR+0xc8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 200f790:	e0bffd17 	ldw	r2,-12(fp)
 200f794:	10800604 	addi	r2,r2,24
 200f798:	100b883a 	mov	r5,r2
 200f79c:	01008174 	movhi	r4,517
 200f7a0:	21337004 	addi	r4,r4,-12864
 200f7a4:	202d8380 	call	202d838 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
 200f7a8:	e0bffc17 	ldw	r2,-16(fp)
	}
 200f7ac:	e037883a 	mov	sp,fp
 200f7b0:	dfc00117 	ldw	ra,4(sp)
 200f7b4:	df000017 	ldw	fp,0(sp)
 200f7b8:	dec00204 	addi	sp,sp,8
 200f7bc:	f800283a 	ret

0200f7c0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 200f7c0:	defffb04 	addi	sp,sp,-20
 200f7c4:	dfc00415 	stw	ra,16(sp)
 200f7c8:	df000315 	stw	fp,12(sp)
 200f7cc:	df000304 	addi	fp,sp,12
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 200f7d0:	d0a7b604 	addi	r2,gp,-24872
 200f7d4:	d8800115 	stw	r2,4(sp)
 200f7d8:	d8000015 	stw	zero,0(sp)
 200f7dc:	000f883a 	mov	r7,zero
 200f7e0:	01840004 	movi	r6,4096
 200f7e4:	01408134 	movhi	r5,516
 200f7e8:	295b3104 	addi	r5,r5,27844
 200f7ec:	01008074 	movhi	r4,513
 200f7f0:	21012f04 	addi	r4,r4,1212
 200f7f4:	200ead40 	call	200ead4 <xTaskCreate>
 200f7f8:	e0bfff15 	stw	r2,-4(fp)
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 200f7fc:	e0bfff17 	ldw	r2,-4(fp)
 200f800:	10800058 	cmpnei	r2,r2,1
 200f804:	1000021e 	bne	r2,zero,200f810 <vTaskStartScheduler+0x50>
		{
			xReturn = xTimerCreateTimerTask();
 200f808:	20117a40 	call	20117a4 <xTimerCreateTimerTask>
 200f80c:	e0bfff15 	stw	r2,-4(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 200f810:	e0bfff17 	ldw	r2,-4(fp)
 200f814:	10800058 	cmpnei	r2,r2,1
 200f818:	1000071e 	bne	r2,zero,200f838 <vTaskStartScheduler+0x78>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 200f81c:	202da600 	call	202da60 <enh_alt_irq_disable_all>
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 200f820:	00bfffc4 	movi	r2,-1
 200f824:	d0a7b515 	stw	r2,-24876(gp)
		xSchedulerRunning = pdTRUE;
 200f828:	00800044 	movi	r2,1
 200f82c:	d0a7b015 	stw	r2,-24896(gp)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 200f830:	d027ae15 	stw	zero,-24904(gp)

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 200f834:	202dbcc0 	call	202dbcc <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 200f838:	0001883a 	nop
 200f83c:	e037883a 	mov	sp,fp
 200f840:	dfc00117 	ldw	ra,4(sp)
 200f844:	df000017 	ldw	fp,0(sp)
 200f848:	dec00204 	addi	sp,sp,8
 200f84c:	f800283a 	ret

0200f850 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 200f850:	defffe04 	addi	sp,sp,-8
 200f854:	dfc00115 	stw	ra,4(sp)
 200f858:	df000015 	stw	fp,0(sp)
 200f85c:	d839883a 	mov	fp,sp
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 200f860:	202da600 	call	202da60 <enh_alt_irq_disable_all>
	xSchedulerRunning = pdFALSE;
 200f864:	d027b015 	stw	zero,-24896(gp)
	vPortEndScheduler();
 200f868:	202dc040 	call	202dc04 <vPortEndScheduler>
}
 200f86c:	0001883a 	nop
 200f870:	e037883a 	mov	sp,fp
 200f874:	dfc00117 	ldw	ra,4(sp)
 200f878:	df000017 	ldw	fp,0(sp)
 200f87c:	dec00204 	addi	sp,sp,8
 200f880:	f800283a 	ret

0200f884 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 200f884:	deffff04 	addi	sp,sp,-4
 200f888:	df000015 	stw	fp,0(sp)
 200f88c:	d839883a 	mov	fp,sp
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
 200f890:	d0a7b717 	ldw	r2,-24868(gp)
 200f894:	10800044 	addi	r2,r2,1
 200f898:	d0a7b715 	stw	r2,-24868(gp)

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
 200f89c:	0001883a 	nop
 200f8a0:	e037883a 	mov	sp,fp
 200f8a4:	df000017 	ldw	fp,0(sp)
 200f8a8:	dec00104 	addi	sp,sp,4
 200f8ac:	f800283a 	ret

0200f8b0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 200f8b0:	defffb04 	addi	sp,sp,-20
 200f8b4:	dfc00415 	stw	ra,16(sp)
 200f8b8:	df000315 	stw	fp,12(sp)
 200f8bc:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
 200f8c0:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
 200f8c4:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 200f8c8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f8cc:	10000126 	beq	r2,zero,200f8d4 <xTaskResumeAll+0x24>
 200f8d0:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
 200f8d4:	d0a7b717 	ldw	r2,-24868(gp)
 200f8d8:	10bfffc4 	addi	r2,r2,-1
 200f8dc:	d0a7b715 	stw	r2,-24868(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 200f8e0:	d0a7b717 	ldw	r2,-24868(gp)
 200f8e4:	1000431e 	bne	r2,zero,200f9f4 <xTaskResumeAll+0x144>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 200f8e8:	d0a7ad17 	ldw	r2,-24908(gp)
 200f8ec:	10004126 	beq	r2,zero,200f9f4 <xTaskResumeAll+0x144>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 200f8f0:	00002606 	br	200f98c <xTaskResumeAll+0xdc>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 200f8f4:	00808174 	movhi	r2,517
 200f8f8:	10b37004 	addi	r2,r2,-12864
 200f8fc:	10800317 	ldw	r2,12(r2)
 200f900:	10800317 	ldw	r2,12(r2)
 200f904:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 200f908:	e0bffd17 	ldw	r2,-12(fp)
 200f90c:	10800604 	addi	r2,r2,24
 200f910:	1009883a 	mov	r4,r2
 200f914:	202d99c0 	call	202d99c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 200f918:	e0bffd17 	ldw	r2,-12(fp)
 200f91c:	10800104 	addi	r2,r2,4
 200f920:	1009883a 	mov	r4,r2
 200f924:	202d99c0 	call	202d99c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 200f928:	e0bffd17 	ldw	r2,-12(fp)
 200f92c:	10800b17 	ldw	r2,44(r2)
 200f930:	d0e7af17 	ldw	r3,-24900(gp)
 200f934:	1880032e 	bgeu	r3,r2,200f944 <xTaskResumeAll+0x94>
 200f938:	e0bffd17 	ldw	r2,-12(fp)
 200f93c:	10800b17 	ldw	r2,44(r2)
 200f940:	d0a7af15 	stw	r2,-24900(gp)
 200f944:	e0bffd17 	ldw	r2,-12(fp)
 200f948:	10800b17 	ldw	r2,44(r2)
 200f94c:	10c00524 	muli	r3,r2,20
 200f950:	00808174 	movhi	r2,517
 200f954:	10b34d04 	addi	r2,r2,-13004
 200f958:	1887883a 	add	r3,r3,r2
 200f95c:	e0bffd17 	ldw	r2,-12(fp)
 200f960:	10800104 	addi	r2,r2,4
 200f964:	100b883a 	mov	r5,r2
 200f968:	1809883a 	mov	r4,r3
 200f96c:	202d8380 	call	202d838 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 200f970:	e0bffd17 	ldw	r2,-12(fp)
 200f974:	10c00b17 	ldw	r3,44(r2)
 200f978:	d0a7a917 	ldw	r2,-24924(gp)
 200f97c:	10800b17 	ldw	r2,44(r2)
 200f980:	18800236 	bltu	r3,r2,200f98c <xTaskResumeAll+0xdc>
					{
						xYieldPending = pdTRUE;
 200f984:	00800044 	movi	r2,1
 200f988:	d0a7b215 	stw	r2,-24888(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 200f98c:	00808174 	movhi	r2,517
 200f990:	10b37004 	addi	r2,r2,-12864
 200f994:	10800017 	ldw	r2,0(r2)
 200f998:	103fd61e 	bne	r2,zero,200f8f4 <__alt_mem_mem_0+0xfcfef8f4>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 200f99c:	e0bffd17 	ldw	r2,-12(fp)
 200f9a0:	10000126 	beq	r2,zero,200f9a8 <xTaskResumeAll+0xf8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 200f9a4:	20109a40 	call	20109a4 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 200f9a8:	d0a7b117 	ldw	r2,-24892(gp)
 200f9ac:	e0bfff15 	stw	r2,-4(fp)

					if( xPendedCounts > ( TickType_t ) 0U )
 200f9b0:	e0bfff17 	ldw	r2,-4(fp)
 200f9b4:	10000a26 	beq	r2,zero,200f9e0 <xTaskResumeAll+0x130>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 200f9b8:	200fca00 	call	200fca0 <xTaskIncrementTick>
 200f9bc:	10000226 	beq	r2,zero,200f9c8 <xTaskResumeAll+0x118>
							{
								xYieldPending = pdTRUE;
 200f9c0:	00800044 	movi	r2,1
 200f9c4:	d0a7b215 	stw	r2,-24888(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
 200f9c8:	e0bfff17 	ldw	r2,-4(fp)
 200f9cc:	10bfffc4 	addi	r2,r2,-1
 200f9d0:	e0bfff15 	stw	r2,-4(fp)
						} while( xPendedCounts > ( TickType_t ) 0U );
 200f9d4:	e0bfff17 	ldw	r2,-4(fp)
 200f9d8:	103ff71e 	bne	r2,zero,200f9b8 <__alt_mem_mem_0+0xfcfef9b8>

						xPendedTicks = 0;
 200f9dc:	d027b115 	stw	zero,-24892(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 200f9e0:	d0a7b217 	ldw	r2,-24888(gp)
 200f9e4:	10000326 	beq	r2,zero,200f9f4 <xTaskResumeAll+0x144>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 200f9e8:	00800044 	movi	r2,1
 200f9ec:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 200f9f0:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 200f9f4:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 200f9f8:	10000126 	beq	r2,zero,200fa00 <xTaskResumeAll+0x150>
 200f9fc:	2010e300 	call	2010e30 <vTaskExitCritical>

	return xAlreadyYielded;
 200fa00:	e0bffe17 	ldw	r2,-8(fp)
}
 200fa04:	e037883a 	mov	sp,fp
 200fa08:	dfc00117 	ldw	ra,4(sp)
 200fa0c:	df000017 	ldw	fp,0(sp)
 200fa10:	dec00204 	addi	sp,sp,8
 200fa14:	f800283a 	ret

0200fa18 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 200fa18:	defffe04 	addi	sp,sp,-8
 200fa1c:	df000115 	stw	fp,4(sp)
 200fa20:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 200fa24:	d0a7ae17 	ldw	r2,-24904(gp)
 200fa28:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 200fa2c:	e0bfff17 	ldw	r2,-4(fp)
}
 200fa30:	e037883a 	mov	sp,fp
 200fa34:	df000017 	ldw	fp,0(sp)
 200fa38:	dec00104 	addi	sp,sp,4
 200fa3c:	f800283a 	ret

0200fa40 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 200fa40:	defffd04 	addi	sp,sp,-12
 200fa44:	df000215 	stw	fp,8(sp)
 200fa48:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 200fa4c:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
 200fa50:	d0a7ae17 	ldw	r2,-24904(gp)
 200fa54:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200fa58:	e0bfff17 	ldw	r2,-4(fp)
}
 200fa5c:	e037883a 	mov	sp,fp
 200fa60:	df000017 	ldw	fp,0(sp)
 200fa64:	dec00104 	addi	sp,sp,4
 200fa68:	f800283a 	ret

0200fa6c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 200fa6c:	deffff04 	addi	sp,sp,-4
 200fa70:	df000015 	stw	fp,0(sp)
 200fa74:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 200fa78:	d0a7ad17 	ldw	r2,-24908(gp)
}
 200fa7c:	e037883a 	mov	sp,fp
 200fa80:	df000017 	ldw	fp,0(sp)
 200fa84:	dec00104 	addi	sp,sp,4
 200fa88:	f800283a 	ret

0200fa8c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 200fa8c:	defffd04 	addi	sp,sp,-12
 200fa90:	df000215 	stw	fp,8(sp)
 200fa94:	df000204 	addi	fp,sp,8
 200fa98:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 200fa9c:	e0bfff17 	ldw	r2,-4(fp)
 200faa0:	1000021e 	bne	r2,zero,200faac <pcTaskGetName+0x20>
 200faa4:	d0a7a917 	ldw	r2,-24924(gp)
 200faa8:	00000106 	br	200fab0 <pcTaskGetName+0x24>
 200faac:	e0bfff17 	ldw	r2,-4(fp)
 200fab0:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
 200fab4:	e0bffe17 	ldw	r2,-8(fp)
 200fab8:	10800d04 	addi	r2,r2,52
}
 200fabc:	e037883a 	mov	sp,fp
 200fac0:	df000017 	ldw	fp,0(sp)
 200fac4:	dec00104 	addi	sp,sp,4
 200fac8:	f800283a 	ret

0200facc <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
 200facc:	defff904 	addi	sp,sp,-28
 200fad0:	dfc00615 	stw	ra,24(sp)
 200fad4:	df000515 	stw	fp,20(sp)
 200fad8:	df000504 	addi	fp,sp,20
 200fadc:	e13ffd15 	stw	r4,-12(fp)
 200fae0:	e17ffe15 	stw	r5,-8(fp)
 200fae4:	e1bfff15 	stw	r6,-4(fp)
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 200fae8:	e03ffb15 	stw	zero,-20(fp)
 200faec:	00800144 	movi	r2,5
 200faf0:	e0bffc15 	stw	r2,-16(fp)

		vTaskSuspendAll();
 200faf4:	200f8840 	call	200f884 <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
 200faf8:	d0a7ad17 	ldw	r2,-24908(gp)
 200fafc:	e0fffe17 	ldw	r3,-8(fp)
 200fb00:	18804d36 	bltu	r3,r2,200fc38 <uxTaskGetSystemState+0x16c>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
 200fb04:	e0bffc17 	ldw	r2,-16(fp)
 200fb08:	10bfffc4 	addi	r2,r2,-1
 200fb0c:	e0bffc15 	stw	r2,-16(fp)
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 200fb10:	e0bffb17 	ldw	r2,-20(fp)
 200fb14:	10800924 	muli	r2,r2,36
 200fb18:	e0fffd17 	ldw	r3,-12(fp)
 200fb1c:	1889883a 	add	r4,r3,r2
 200fb20:	e0bffc17 	ldw	r2,-16(fp)
 200fb24:	10c00524 	muli	r3,r2,20
 200fb28:	00808174 	movhi	r2,517
 200fb2c:	10b34d04 	addi	r2,r2,-13004
 200fb30:	1885883a 	add	r2,r3,r2
 200fb34:	01800044 	movi	r6,1
 200fb38:	100b883a 	mov	r5,r2
 200fb3c:	20107780 	call	2010778 <prvListTasksWithinSingleList>
 200fb40:	1007883a 	mov	r3,r2
 200fb44:	e0bffb17 	ldw	r2,-20(fp)
 200fb48:	10c5883a 	add	r2,r2,r3
 200fb4c:	e0bffb15 	stw	r2,-20(fp)

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200fb50:	e0bffc17 	ldw	r2,-16(fp)
 200fb54:	103feb1e 	bne	r2,zero,200fb04 <__alt_mem_mem_0+0xfcfefb04>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 200fb58:	e0bffb17 	ldw	r2,-20(fp)
 200fb5c:	10800924 	muli	r2,r2,36
 200fb60:	e0fffd17 	ldw	r3,-12(fp)
 200fb64:	1885883a 	add	r2,r3,r2
 200fb68:	d0e7aa17 	ldw	r3,-24920(gp)
 200fb6c:	01800084 	movi	r6,2
 200fb70:	180b883a 	mov	r5,r3
 200fb74:	1009883a 	mov	r4,r2
 200fb78:	20107780 	call	2010778 <prvListTasksWithinSingleList>
 200fb7c:	1007883a 	mov	r3,r2
 200fb80:	e0bffb17 	ldw	r2,-20(fp)
 200fb84:	10c5883a 	add	r2,r2,r3
 200fb88:	e0bffb15 	stw	r2,-20(fp)
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 200fb8c:	e0bffb17 	ldw	r2,-20(fp)
 200fb90:	10800924 	muli	r2,r2,36
 200fb94:	e0fffd17 	ldw	r3,-12(fp)
 200fb98:	1885883a 	add	r2,r3,r2
 200fb9c:	d0e7ab17 	ldw	r3,-24916(gp)
 200fba0:	01800084 	movi	r6,2
 200fba4:	180b883a 	mov	r5,r3
 200fba8:	1009883a 	mov	r4,r2
 200fbac:	20107780 	call	2010778 <prvListTasksWithinSingleList>
 200fbb0:	1007883a 	mov	r3,r2
 200fbb4:	e0bffb17 	ldw	r2,-20(fp)
 200fbb8:	10c5883a 	add	r2,r2,r3
 200fbbc:	e0bffb15 	stw	r2,-20(fp)

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 200fbc0:	e0bffb17 	ldw	r2,-20(fp)
 200fbc4:	10800924 	muli	r2,r2,36
 200fbc8:	e0fffd17 	ldw	r3,-12(fp)
 200fbcc:	1885883a 	add	r2,r3,r2
 200fbd0:	01800104 	movi	r6,4
 200fbd4:	01408174 	movhi	r5,517
 200fbd8:	29737504 	addi	r5,r5,-12844
 200fbdc:	1009883a 	mov	r4,r2
 200fbe0:	20107780 	call	2010778 <prvListTasksWithinSingleList>
 200fbe4:	1007883a 	mov	r3,r2
 200fbe8:	e0bffb17 	ldw	r2,-20(fp)
 200fbec:	10c5883a 	add	r2,r2,r3
 200fbf0:	e0bffb15 	stw	r2,-20(fp)

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 200fbf4:	e0bffb17 	ldw	r2,-20(fp)
 200fbf8:	10800924 	muli	r2,r2,36
 200fbfc:	e0fffd17 	ldw	r3,-12(fp)
 200fc00:	1885883a 	add	r2,r3,r2
 200fc04:	018000c4 	movi	r6,3
 200fc08:	01408174 	movhi	r5,517
 200fc0c:	29737a04 	addi	r5,r5,-12824
 200fc10:	1009883a 	mov	r4,r2
 200fc14:	20107780 	call	2010778 <prvListTasksWithinSingleList>
 200fc18:	1007883a 	mov	r3,r2
 200fc1c:	e0bffb17 	ldw	r2,-20(fp)
 200fc20:	10c5883a 	add	r2,r2,r3
 200fc24:	e0bffb15 	stw	r2,-20(fp)
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
 200fc28:	e0bfff17 	ldw	r2,-4(fp)
 200fc2c:	10000226 	beq	r2,zero,200fc38 <uxTaskGetSystemState+0x16c>
					{
						*pulTotalRunTime = 0;
 200fc30:	e0bfff17 	ldw	r2,-4(fp)
 200fc34:	10000015 	stw	zero,0(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
 200fc38:	200f8b00 	call	200f8b0 <xTaskResumeAll>

		return uxTask;
 200fc3c:	e0bffb17 	ldw	r2,-20(fp)
	}
 200fc40:	e037883a 	mov	sp,fp
 200fc44:	dfc00117 	ldw	ra,4(sp)
 200fc48:	df000017 	ldw	fp,0(sp)
 200fc4c:	dec00204 	addi	sp,sp,8
 200fc50:	f800283a 	ret

0200fc54 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 200fc54:	defffc04 	addi	sp,sp,-16
 200fc58:	dfc00315 	stw	ra,12(sp)
 200fc5c:	df000215 	stw	fp,8(sp)
 200fc60:	df000204 	addi	fp,sp,8
 200fc64:	e13fff15 	stw	r4,-4(fp)
BaseType_t xYieldRequired = pdFALSE;
 200fc68:	e03ffe15 	stw	zero,-8(fp)
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
 200fc6c:	200f8840 	call	200f884 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
 200fc70:	d0e7b117 	ldw	r3,-24892(gp)
 200fc74:	e0bfff17 	ldw	r2,-4(fp)
 200fc78:	1885883a 	add	r2,r3,r2
 200fc7c:	d0a7b115 	stw	r2,-24892(gp)
	xYieldRequired = xTaskResumeAll();
 200fc80:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 200fc84:	e0bffe15 	stw	r2,-8(fp)

	return xYieldRequired;
 200fc88:	e0bffe17 	ldw	r2,-8(fp)
}
 200fc8c:	e037883a 	mov	sp,fp
 200fc90:	dfc00117 	ldw	ra,4(sp)
 200fc94:	df000017 	ldw	fp,0(sp)
 200fc98:	dec00204 	addi	sp,sp,8
 200fc9c:	f800283a 	ret

0200fca0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 200fca0:	defff904 	addi	sp,sp,-28
 200fca4:	dfc00615 	stw	ra,24(sp)
 200fca8:	df000515 	stw	fp,20(sp)
 200fcac:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 200fcb0:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 200fcb4:	d0a7b717 	ldw	r2,-24868(gp)
 200fcb8:	10005c1e 	bne	r2,zero,200fe2c <xTaskIncrementTick+0x18c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 200fcbc:	d0a7ae17 	ldw	r2,-24904(gp)
 200fcc0:	10800044 	addi	r2,r2,1
 200fcc4:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 200fcc8:	e0bffc17 	ldw	r2,-16(fp)
 200fccc:	d0a7ae15 	stw	r2,-24904(gp)

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 200fcd0:	e0bffc17 	ldw	r2,-16(fp)
 200fcd4:	10000a1e 	bne	r2,zero,200fd00 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
 200fcd8:	d0a7aa17 	ldw	r2,-24920(gp)
 200fcdc:	e0bffd15 	stw	r2,-12(fp)
 200fce0:	d0a7ab17 	ldw	r2,-24916(gp)
 200fce4:	d0a7aa15 	stw	r2,-24920(gp)
 200fce8:	e0bffd17 	ldw	r2,-12(fp)
 200fcec:	d0a7ab15 	stw	r2,-24916(gp)
 200fcf0:	d0a7b317 	ldw	r2,-24884(gp)
 200fcf4:	10800044 	addi	r2,r2,1
 200fcf8:	d0a7b315 	stw	r2,-24884(gp)
 200fcfc:	20109a40 	call	20109a4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 200fd00:	d0a7b517 	ldw	r2,-24876(gp)
 200fd04:	e0fffc17 	ldw	r3,-16(fp)
 200fd08:	18803836 	bltu	r3,r2,200fdec <xTaskIncrementTick+0x14c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 200fd0c:	d0a7aa17 	ldw	r2,-24920(gp)
 200fd10:	10800017 	ldw	r2,0(r2)
 200fd14:	1000031e 	bne	r2,zero,200fd24 <xTaskIncrementTick+0x84>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200fd18:	00bfffc4 	movi	r2,-1
 200fd1c:	d0a7b515 	stw	r2,-24876(gp)
					break;
 200fd20:	00003206 	br	200fdec <xTaskIncrementTick+0x14c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 200fd24:	d0a7aa17 	ldw	r2,-24920(gp)
 200fd28:	10800317 	ldw	r2,12(r2)
 200fd2c:	10800317 	ldw	r2,12(r2)
 200fd30:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 200fd34:	e0bffe17 	ldw	r2,-8(fp)
 200fd38:	10800117 	ldw	r2,4(r2)
 200fd3c:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
 200fd40:	e0fffc17 	ldw	r3,-16(fp)
 200fd44:	e0bfff17 	ldw	r2,-4(fp)
 200fd48:	1880032e 	bgeu	r3,r2,200fd58 <xTaskIncrementTick+0xb8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 200fd4c:	e0bfff17 	ldw	r2,-4(fp)
 200fd50:	d0a7b515 	stw	r2,-24876(gp)
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 200fd54:	00002506 	br	200fdec <xTaskIncrementTick+0x14c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 200fd58:	e0bffe17 	ldw	r2,-8(fp)
 200fd5c:	10800104 	addi	r2,r2,4
 200fd60:	1009883a 	mov	r4,r2
 200fd64:	202d99c0 	call	202d99c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 200fd68:	e0bffe17 	ldw	r2,-8(fp)
 200fd6c:	10800a17 	ldw	r2,40(r2)
 200fd70:	10000426 	beq	r2,zero,200fd84 <xTaskIncrementTick+0xe4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 200fd74:	e0bffe17 	ldw	r2,-8(fp)
 200fd78:	10800604 	addi	r2,r2,24
 200fd7c:	1009883a 	mov	r4,r2
 200fd80:	202d99c0 	call	202d99c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 200fd84:	e0bffe17 	ldw	r2,-8(fp)
 200fd88:	10800b17 	ldw	r2,44(r2)
 200fd8c:	d0e7af17 	ldw	r3,-24900(gp)
 200fd90:	1880032e 	bgeu	r3,r2,200fda0 <xTaskIncrementTick+0x100>
 200fd94:	e0bffe17 	ldw	r2,-8(fp)
 200fd98:	10800b17 	ldw	r2,44(r2)
 200fd9c:	d0a7af15 	stw	r2,-24900(gp)
 200fda0:	e0bffe17 	ldw	r2,-8(fp)
 200fda4:	10800b17 	ldw	r2,44(r2)
 200fda8:	10c00524 	muli	r3,r2,20
 200fdac:	00808174 	movhi	r2,517
 200fdb0:	10b34d04 	addi	r2,r2,-13004
 200fdb4:	1887883a 	add	r3,r3,r2
 200fdb8:	e0bffe17 	ldw	r2,-8(fp)
 200fdbc:	10800104 	addi	r2,r2,4
 200fdc0:	100b883a 	mov	r5,r2
 200fdc4:	1809883a 	mov	r4,r3
 200fdc8:	202d8380 	call	202d838 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 200fdcc:	e0bffe17 	ldw	r2,-8(fp)
 200fdd0:	10c00b17 	ldw	r3,44(r2)
 200fdd4:	d0a7a917 	ldw	r2,-24924(gp)
 200fdd8:	10800b17 	ldw	r2,44(r2)
 200fddc:	18bfcb36 	bltu	r3,r2,200fd0c <__alt_mem_mem_0+0xfcfefd0c>
						{
							xSwitchRequired = pdTRUE;
 200fde0:	00800044 	movi	r2,1
 200fde4:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
 200fde8:	003fc806 	br	200fd0c <__alt_mem_mem_0+0xfcfefd0c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 200fdec:	d0a7a917 	ldw	r2,-24924(gp)
 200fdf0:	10c00b17 	ldw	r3,44(r2)
 200fdf4:	00808174 	movhi	r2,517
 200fdf8:	10b34d04 	addi	r2,r2,-13004
 200fdfc:	18c00524 	muli	r3,r3,20
 200fe00:	10c5883a 	add	r2,r2,r3
 200fe04:	10800017 	ldw	r2,0(r2)
 200fe08:	108000b0 	cmpltui	r2,r2,2
 200fe0c:	1000021e 	bne	r2,zero,200fe18 <xTaskIncrementTick+0x178>
			{
				xSwitchRequired = pdTRUE;
 200fe10:	00800044 	movi	r2,1
 200fe14:	e0bffb15 	stw	r2,-20(fp)
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 200fe18:	d0a7b217 	ldw	r2,-24888(gp)
 200fe1c:	10000626 	beq	r2,zero,200fe38 <xTaskIncrementTick+0x198>
			{
				xSwitchRequired = pdTRUE;
 200fe20:	00800044 	movi	r2,1
 200fe24:	e0bffb15 	stw	r2,-20(fp)
 200fe28:	00000306 	br	200fe38 <xTaskIncrementTick+0x198>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 200fe2c:	d0a7b117 	ldw	r2,-24892(gp)
 200fe30:	10800044 	addi	r2,r2,1
 200fe34:	d0a7b115 	stw	r2,-24892(gp)
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 200fe38:	e0bffb17 	ldw	r2,-20(fp)
}
 200fe3c:	e037883a 	mov	sp,fp
 200fe40:	dfc00117 	ldw	ra,4(sp)
 200fe44:	df000017 	ldw	fp,0(sp)
 200fe48:	dec00204 	addi	sp,sp,8
 200fe4c:	f800283a 	ret

0200fe50 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 200fe50:	defffa04 	addi	sp,sp,-24
 200fe54:	dfc00515 	stw	ra,20(sp)
 200fe58:	df000415 	stw	fp,16(sp)
 200fe5c:	df000404 	addi	fp,sp,16
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 200fe60:	d0a7b717 	ldw	r2,-24868(gp)
 200fe64:	10000326 	beq	r2,zero,200fe74 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 200fe68:	00800044 	movi	r2,1
 200fe6c:	d0a7b215 	stw	r2,-24888(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 200fe70:	00004806 	br	200ff94 <vTaskSwitchContext+0x144>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 200fe74:	d027b215 	stw	zero,-24888(gp)
			ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
 200fe78:	d0a7a917 	ldw	r2,-24924(gp)
 200fe7c:	10800c17 	ldw	r2,48(r2)
 200fe80:	e0bffd15 	stw	r2,-12(fp)
 200fe84:	00a969b4 	movhi	r2,42406
 200fe88:	10a96944 	addi	r2,r2,-23131
 200fe8c:	e0bffe15 	stw	r2,-8(fp)
 200fe90:	e0bffd17 	ldw	r2,-12(fp)
 200fe94:	10c00017 	ldw	r3,0(r2)
 200fe98:	e0bffe17 	ldw	r2,-8(fp)
 200fe9c:	18800f1e 	bne	r3,r2,200fedc <vTaskSwitchContext+0x8c>
 200fea0:	e0bffd17 	ldw	r2,-12(fp)
 200fea4:	10800104 	addi	r2,r2,4
 200fea8:	10c00017 	ldw	r3,0(r2)
 200feac:	e0bffe17 	ldw	r2,-8(fp)
 200feb0:	18800a1e 	bne	r3,r2,200fedc <vTaskSwitchContext+0x8c>
 200feb4:	e0bffd17 	ldw	r2,-12(fp)
 200feb8:	10800204 	addi	r2,r2,8
 200febc:	10c00017 	ldw	r3,0(r2)
 200fec0:	e0bffe17 	ldw	r2,-8(fp)
 200fec4:	1880051e 	bne	r3,r2,200fedc <vTaskSwitchContext+0x8c>
 200fec8:	e0bffd17 	ldw	r2,-12(fp)
 200fecc:	10800304 	addi	r2,r2,12
 200fed0:	10c00017 	ldw	r3,0(r2)
 200fed4:	e0bffe17 	ldw	r2,-8(fp)
 200fed8:	18800626 	beq	r3,r2,200fef4 <vTaskSwitchContext+0xa4>
 200fedc:	d0e7a917 	ldw	r3,-24924(gp)
 200fee0:	d0a7a917 	ldw	r2,-24924(gp)
 200fee4:	10800d04 	addi	r2,r2,52
 200fee8:	100b883a 	mov	r5,r2
 200feec:	1809883a 	mov	r4,r3
 200fef0:	20002ac0 	call	20002ac <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 200fef4:	d0a7af17 	ldw	r2,-24900(gp)
 200fef8:	e0bffc15 	stw	r2,-16(fp)
 200fefc:	00000306 	br	200ff0c <vTaskSwitchContext+0xbc>
 200ff00:	e0bffc17 	ldw	r2,-16(fp)
 200ff04:	10bfffc4 	addi	r2,r2,-1
 200ff08:	e0bffc15 	stw	r2,-16(fp)
 200ff0c:	00808174 	movhi	r2,517
 200ff10:	10b34d04 	addi	r2,r2,-13004
 200ff14:	e0fffc17 	ldw	r3,-16(fp)
 200ff18:	18c00524 	muli	r3,r3,20
 200ff1c:	10c5883a 	add	r2,r2,r3
 200ff20:	10800017 	ldw	r2,0(r2)
 200ff24:	103ff626 	beq	r2,zero,200ff00 <__alt_mem_mem_0+0xfcfeff00>
 200ff28:	e0bffc17 	ldw	r2,-16(fp)
 200ff2c:	10c00524 	muli	r3,r2,20
 200ff30:	00808174 	movhi	r2,517
 200ff34:	10b34d04 	addi	r2,r2,-13004
 200ff38:	1885883a 	add	r2,r3,r2
 200ff3c:	e0bfff15 	stw	r2,-4(fp)
 200ff40:	e0bfff17 	ldw	r2,-4(fp)
 200ff44:	10800117 	ldw	r2,4(r2)
 200ff48:	10c00117 	ldw	r3,4(r2)
 200ff4c:	e0bfff17 	ldw	r2,-4(fp)
 200ff50:	10c00115 	stw	r3,4(r2)
 200ff54:	e0bfff17 	ldw	r2,-4(fp)
 200ff58:	10c00117 	ldw	r3,4(r2)
 200ff5c:	e0bfff17 	ldw	r2,-4(fp)
 200ff60:	10800204 	addi	r2,r2,8
 200ff64:	1880051e 	bne	r3,r2,200ff7c <vTaskSwitchContext+0x12c>
 200ff68:	e0bfff17 	ldw	r2,-4(fp)
 200ff6c:	10800117 	ldw	r2,4(r2)
 200ff70:	10c00117 	ldw	r3,4(r2)
 200ff74:	e0bfff17 	ldw	r2,-4(fp)
 200ff78:	10c00115 	stw	r3,4(r2)
 200ff7c:	e0bfff17 	ldw	r2,-4(fp)
 200ff80:	10800117 	ldw	r2,4(r2)
 200ff84:	10800317 	ldw	r2,12(r2)
 200ff88:	d0a7a915 	stw	r2,-24924(gp)
 200ff8c:	e0bffc17 	ldw	r2,-16(fp)
 200ff90:	d0a7af15 	stw	r2,-24900(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 200ff94:	0001883a 	nop
 200ff98:	e037883a 	mov	sp,fp
 200ff9c:	dfc00117 	ldw	ra,4(sp)
 200ffa0:	df000017 	ldw	fp,0(sp)
 200ffa4:	dec00204 	addi	sp,sp,8
 200ffa8:	f800283a 	ret

0200ffac <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 200ffac:	defffc04 	addi	sp,sp,-16
 200ffb0:	dfc00315 	stw	ra,12(sp)
 200ffb4:	df000215 	stw	fp,8(sp)
 200ffb8:	df000204 	addi	fp,sp,8
 200ffbc:	e13ffe15 	stw	r4,-8(fp)
 200ffc0:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 200ffc4:	d0a7a917 	ldw	r2,-24924(gp)
 200ffc8:	10800604 	addi	r2,r2,24
 200ffcc:	100b883a 	mov	r5,r2
 200ffd0:	e13ffe17 	ldw	r4,-8(fp)
 200ffd4:	202d8c40 	call	202d8c4 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 200ffd8:	01400044 	movi	r5,1
 200ffdc:	e13fff17 	ldw	r4,-4(fp)
 200ffe0:	20116bc0 	call	20116bc <prvAddCurrentTaskToDelayedList>
}
 200ffe4:	0001883a 	nop
 200ffe8:	e037883a 	mov	sp,fp
 200ffec:	dfc00117 	ldw	ra,4(sp)
 200fff0:	df000017 	ldw	fp,0(sp)
 200fff4:	dec00204 	addi	sp,sp,8
 200fff8:	f800283a 	ret

0200fffc <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 200fffc:	defffb04 	addi	sp,sp,-20
 2010000:	dfc00415 	stw	ra,16(sp)
 2010004:	df000315 	stw	fp,12(sp)
 2010008:	df000304 	addi	fp,sp,12
 201000c:	e13ffd15 	stw	r4,-12(fp)
 2010010:	e17ffe15 	stw	r5,-8(fp)
 2010014:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 2010018:	d0a7a917 	ldw	r2,-24924(gp)
 201001c:	e0fffe17 	ldw	r3,-8(fp)
 2010020:	18e00034 	orhi	r3,r3,32768
 2010024:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2010028:	d0a7a917 	ldw	r2,-24924(gp)
 201002c:	10800604 	addi	r2,r2,24
 2010030:	100b883a 	mov	r5,r2
 2010034:	e13ffd17 	ldw	r4,-12(fp)
 2010038:	202d8380 	call	202d838 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 201003c:	01400044 	movi	r5,1
 2010040:	e13fff17 	ldw	r4,-4(fp)
 2010044:	20116bc0 	call	20116bc <prvAddCurrentTaskToDelayedList>
}
 2010048:	0001883a 	nop
 201004c:	e037883a 	mov	sp,fp
 2010050:	dfc00117 	ldw	ra,4(sp)
 2010054:	df000017 	ldw	fp,0(sp)
 2010058:	dec00204 	addi	sp,sp,8
 201005c:	f800283a 	ret

02010060 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 2010060:	defffb04 	addi	sp,sp,-20
 2010064:	dfc00415 	stw	ra,16(sp)
 2010068:	df000315 	stw	fp,12(sp)
 201006c:	df000304 	addi	fp,sp,12
 2010070:	e13ffd15 	stw	r4,-12(fp)
 2010074:	e17ffe15 	stw	r5,-8(fp)
 2010078:	e1bfff15 	stw	r6,-4(fp)

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 201007c:	d0a7a917 	ldw	r2,-24924(gp)
 2010080:	10800604 	addi	r2,r2,24
 2010084:	100b883a 	mov	r5,r2
 2010088:	e13ffd17 	ldw	r4,-12(fp)
 201008c:	202d8380 	call	202d838 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 2010090:	e0bfff17 	ldw	r2,-4(fp)
 2010094:	10000226 	beq	r2,zero,20100a0 <vTaskPlaceOnEventListRestricted+0x40>
		{
			xTicksToWait = portMAX_DELAY;
 2010098:	00bfffc4 	movi	r2,-1
 201009c:	e0bffe15 	stw	r2,-8(fp)
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 20100a0:	e17fff17 	ldw	r5,-4(fp)
 20100a4:	e13ffe17 	ldw	r4,-8(fp)
 20100a8:	20116bc0 	call	20116bc <prvAddCurrentTaskToDelayedList>
	}
 20100ac:	0001883a 	nop
 20100b0:	e037883a 	mov	sp,fp
 20100b4:	dfc00117 	ldw	ra,4(sp)
 20100b8:	df000017 	ldw	fp,0(sp)
 20100bc:	dec00204 	addi	sp,sp,8
 20100c0:	f800283a 	ret

020100c4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 20100c4:	defffb04 	addi	sp,sp,-20
 20100c8:	dfc00415 	stw	ra,16(sp)
 20100cc:	df000315 	stw	fp,12(sp)
 20100d0:	df000304 	addi	fp,sp,12
 20100d4:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20100d8:	e0bfff17 	ldw	r2,-4(fp)
 20100dc:	10800317 	ldw	r2,12(r2)
 20100e0:	10800317 	ldw	r2,12(r2)
 20100e4:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 20100e8:	e0bffe17 	ldw	r2,-8(fp)
 20100ec:	10800604 	addi	r2,r2,24
 20100f0:	1009883a 	mov	r4,r2
 20100f4:	202d99c0 	call	202d99c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 20100f8:	d0a7b717 	ldw	r2,-24868(gp)
 20100fc:	1000171e 	bne	r2,zero,201015c <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2010100:	e0bffe17 	ldw	r2,-8(fp)
 2010104:	10800104 	addi	r2,r2,4
 2010108:	1009883a 	mov	r4,r2
 201010c:	202d99c0 	call	202d99c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 2010110:	e0bffe17 	ldw	r2,-8(fp)
 2010114:	10800b17 	ldw	r2,44(r2)
 2010118:	d0e7af17 	ldw	r3,-24900(gp)
 201011c:	1880032e 	bgeu	r3,r2,201012c <xTaskRemoveFromEventList+0x68>
 2010120:	e0bffe17 	ldw	r2,-8(fp)
 2010124:	10800b17 	ldw	r2,44(r2)
 2010128:	d0a7af15 	stw	r2,-24900(gp)
 201012c:	e0bffe17 	ldw	r2,-8(fp)
 2010130:	10800b17 	ldw	r2,44(r2)
 2010134:	10c00524 	muli	r3,r2,20
 2010138:	00808174 	movhi	r2,517
 201013c:	10b34d04 	addi	r2,r2,-13004
 2010140:	1887883a 	add	r3,r3,r2
 2010144:	e0bffe17 	ldw	r2,-8(fp)
 2010148:	10800104 	addi	r2,r2,4
 201014c:	100b883a 	mov	r5,r2
 2010150:	1809883a 	mov	r4,r3
 2010154:	202d8380 	call	202d838 <vListInsertEnd>
 2010158:	00000606 	br	2010174 <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 201015c:	e0bffe17 	ldw	r2,-8(fp)
 2010160:	10800604 	addi	r2,r2,24
 2010164:	100b883a 	mov	r5,r2
 2010168:	01008174 	movhi	r4,517
 201016c:	21337004 	addi	r4,r4,-12864
 2010170:	202d8380 	call	202d838 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2010174:	e0bffe17 	ldw	r2,-8(fp)
 2010178:	10800b17 	ldw	r2,44(r2)
 201017c:	d0e7a917 	ldw	r3,-24924(gp)
 2010180:	18c00b17 	ldw	r3,44(r3)
 2010184:	1880052e 	bgeu	r3,r2,201019c <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 2010188:	00800044 	movi	r2,1
 201018c:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 2010190:	00800044 	movi	r2,1
 2010194:	d0a7b215 	stw	r2,-24888(gp)
 2010198:	00000106 	br	20101a0 <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
 201019c:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 20101a0:	e0bffd17 	ldw	r2,-12(fp)
}
 20101a4:	e037883a 	mov	sp,fp
 20101a8:	dfc00117 	ldw	ra,4(sp)
 20101ac:	df000017 	ldw	fp,0(sp)
 20101b0:	dec00204 	addi	sp,sp,8
 20101b4:	f800283a 	ret

020101b8 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 20101b8:	defffb04 	addi	sp,sp,-20
 20101bc:	dfc00415 	stw	ra,16(sp)
 20101c0:	df000315 	stw	fp,12(sp)
 20101c4:	df000304 	addi	fp,sp,12
 20101c8:	e13ffe15 	stw	r4,-8(fp)
 20101cc:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 20101d0:	e0bfff17 	ldw	r2,-4(fp)
 20101d4:	10e00034 	orhi	r3,r2,32768
 20101d8:	e0bffe17 	ldw	r2,-8(fp)
 20101dc:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20101e0:	e0bffe17 	ldw	r2,-8(fp)
 20101e4:	10800317 	ldw	r2,12(r2)
 20101e8:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 20101ec:	e13ffe17 	ldw	r4,-8(fp)
 20101f0:	202d99c0 	call	202d99c <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 20101f4:	e0bffd17 	ldw	r2,-12(fp)
 20101f8:	10800104 	addi	r2,r2,4
 20101fc:	1009883a 	mov	r4,r2
 2010200:	202d99c0 	call	202d99c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 2010204:	e0bffd17 	ldw	r2,-12(fp)
 2010208:	10800b17 	ldw	r2,44(r2)
 201020c:	d0e7af17 	ldw	r3,-24900(gp)
 2010210:	1880032e 	bgeu	r3,r2,2010220 <vTaskRemoveFromUnorderedEventList+0x68>
 2010214:	e0bffd17 	ldw	r2,-12(fp)
 2010218:	10800b17 	ldw	r2,44(r2)
 201021c:	d0a7af15 	stw	r2,-24900(gp)
 2010220:	e0bffd17 	ldw	r2,-12(fp)
 2010224:	10800b17 	ldw	r2,44(r2)
 2010228:	10c00524 	muli	r3,r2,20
 201022c:	00808174 	movhi	r2,517
 2010230:	10b34d04 	addi	r2,r2,-13004
 2010234:	1887883a 	add	r3,r3,r2
 2010238:	e0bffd17 	ldw	r2,-12(fp)
 201023c:	10800104 	addi	r2,r2,4
 2010240:	100b883a 	mov	r5,r2
 2010244:	1809883a 	mov	r4,r3
 2010248:	202d8380 	call	202d838 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 201024c:	e0bffd17 	ldw	r2,-12(fp)
 2010250:	10800b17 	ldw	r2,44(r2)
 2010254:	d0e7a917 	ldw	r3,-24924(gp)
 2010258:	18c00b17 	ldw	r3,44(r3)
 201025c:	1880022e 	bgeu	r3,r2,2010268 <vTaskRemoveFromUnorderedEventList+0xb0>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
 2010260:	00800044 	movi	r2,1
 2010264:	d0a7b215 	stw	r2,-24888(gp)
	}
}
 2010268:	0001883a 	nop
 201026c:	e037883a 	mov	sp,fp
 2010270:	dfc00117 	ldw	ra,4(sp)
 2010274:	df000017 	ldw	fp,0(sp)
 2010278:	dec00204 	addi	sp,sp,8
 201027c:	f800283a 	ret

02010280 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 2010280:	defffd04 	addi	sp,sp,-12
 2010284:	dfc00215 	stw	ra,8(sp)
 2010288:	df000115 	stw	fp,4(sp)
 201028c:	df000104 	addi	fp,sp,4
 2010290:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
 2010294:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2010298:	10000126 	beq	r2,zero,20102a0 <vTaskSetTimeOutState+0x20>
 201029c:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
 20102a0:	d0e7b317 	ldw	r3,-24884(gp)
 20102a4:	e0bfff17 	ldw	r2,-4(fp)
 20102a8:	10c00015 	stw	r3,0(r2)
		pxTimeOut->xTimeOnEntering = xTickCount;
 20102ac:	d0e7ae17 	ldw	r3,-24904(gp)
 20102b0:	e0bfff17 	ldw	r2,-4(fp)
 20102b4:	10c00115 	stw	r3,4(r2)
	}
	taskEXIT_CRITICAL();
 20102b8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20102bc:	10000126 	beq	r2,zero,20102c4 <vTaskSetTimeOutState+0x44>
 20102c0:	2010e300 	call	2010e30 <vTaskExitCritical>
}
 20102c4:	0001883a 	nop
 20102c8:	e037883a 	mov	sp,fp
 20102cc:	dfc00117 	ldw	ra,4(sp)
 20102d0:	df000017 	ldw	fp,0(sp)
 20102d4:	dec00204 	addi	sp,sp,8
 20102d8:	f800283a 	ret

020102dc <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 20102dc:	defffe04 	addi	sp,sp,-8
 20102e0:	df000115 	stw	fp,4(sp)
 20102e4:	df000104 	addi	fp,sp,4
 20102e8:	e13fff15 	stw	r4,-4(fp)
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 20102ec:	d0e7b317 	ldw	r3,-24884(gp)
 20102f0:	e0bfff17 	ldw	r2,-4(fp)
 20102f4:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
 20102f8:	d0e7ae17 	ldw	r3,-24904(gp)
 20102fc:	e0bfff17 	ldw	r2,-4(fp)
 2010300:	10c00115 	stw	r3,4(r2)
}
 2010304:	0001883a 	nop
 2010308:	e037883a 	mov	sp,fp
 201030c:	df000017 	ldw	fp,0(sp)
 2010310:	dec00104 	addi	sp,sp,4
 2010314:	f800283a 	ret

02010318 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 2010318:	defff904 	addi	sp,sp,-28
 201031c:	dfc00615 	stw	ra,24(sp)
 2010320:	df000515 	stw	fp,20(sp)
 2010324:	df000504 	addi	fp,sp,20
 2010328:	e13ffe15 	stw	r4,-8(fp)
 201032c:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 2010330:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2010334:	10000126 	beq	r2,zero,201033c <xTaskCheckForTimeOut+0x24>
 2010338:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 201033c:	d0a7ae17 	ldw	r2,-24904(gp)
 2010340:	e0bffc15 	stw	r2,-16(fp)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2010344:	e0bffe17 	ldw	r2,-8(fp)
 2010348:	10800117 	ldw	r2,4(r2)
 201034c:	e0fffc17 	ldw	r3,-16(fp)
 2010350:	1885c83a 	sub	r2,r3,r2
 2010354:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 2010358:	e0bfff17 	ldw	r2,-4(fp)
 201035c:	10800017 	ldw	r2,0(r2)
 2010360:	10bfffd8 	cmpnei	r2,r2,-1
 2010364:	1000021e 	bne	r2,zero,2010370 <xTaskCheckForTimeOut+0x58>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 2010368:	e03ffb15 	stw	zero,-20(fp)
 201036c:	00001d06 	br	20103e4 <xTaskCheckForTimeOut+0xcc>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 2010370:	e0bffe17 	ldw	r2,-8(fp)
 2010374:	10c00017 	ldw	r3,0(r2)
 2010378:	d0a7b317 	ldw	r2,-24884(gp)
 201037c:	18800726 	beq	r3,r2,201039c <xTaskCheckForTimeOut+0x84>
 2010380:	e0bffe17 	ldw	r2,-8(fp)
 2010384:	10800117 	ldw	r2,4(r2)
 2010388:	e0fffc17 	ldw	r3,-16(fp)
 201038c:	18800336 	bltu	r3,r2,201039c <xTaskCheckForTimeOut+0x84>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 2010390:	00800044 	movi	r2,1
 2010394:	e0bffb15 	stw	r2,-20(fp)
 2010398:	00001206 	br	20103e4 <xTaskCheckForTimeOut+0xcc>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 201039c:	e0bfff17 	ldw	r2,-4(fp)
 20103a0:	10800017 	ldw	r2,0(r2)
 20103a4:	e0fffd17 	ldw	r3,-12(fp)
 20103a8:	18800a2e 	bgeu	r3,r2,20103d4 <xTaskCheckForTimeOut+0xbc>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 20103ac:	e0bfff17 	ldw	r2,-4(fp)
 20103b0:	10c00017 	ldw	r3,0(r2)
 20103b4:	e0bffd17 	ldw	r2,-12(fp)
 20103b8:	1887c83a 	sub	r3,r3,r2
 20103bc:	e0bfff17 	ldw	r2,-4(fp)
 20103c0:	10c00015 	stw	r3,0(r2)
			vTaskInternalSetTimeOutState( pxTimeOut );
 20103c4:	e13ffe17 	ldw	r4,-8(fp)
 20103c8:	20102dc0 	call	20102dc <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 20103cc:	e03ffb15 	stw	zero,-20(fp)
 20103d0:	00000406 	br	20103e4 <xTaskCheckForTimeOut+0xcc>
		}
		else
		{
			*pxTicksToWait = 0;
 20103d4:	e0bfff17 	ldw	r2,-4(fp)
 20103d8:	10000015 	stw	zero,0(r2)
			xReturn = pdTRUE;
 20103dc:	00800044 	movi	r2,1
 20103e0:	e0bffb15 	stw	r2,-20(fp)
		}
	}
	taskEXIT_CRITICAL();
 20103e4:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20103e8:	10000126 	beq	r2,zero,20103f0 <xTaskCheckForTimeOut+0xd8>
 20103ec:	2010e300 	call	2010e30 <vTaskExitCritical>

	return xReturn;
 20103f0:	e0bffb17 	ldw	r2,-20(fp)
}
 20103f4:	e037883a 	mov	sp,fp
 20103f8:	dfc00117 	ldw	ra,4(sp)
 20103fc:	df000017 	ldw	fp,0(sp)
 2010400:	dec00204 	addi	sp,sp,8
 2010404:	f800283a 	ret

02010408 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 2010408:	deffff04 	addi	sp,sp,-4
 201040c:	df000015 	stw	fp,0(sp)
 2010410:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
 2010414:	00800044 	movi	r2,1
 2010418:	d0a7b215 	stw	r2,-24888(gp)
}
 201041c:	0001883a 	nop
 2010420:	e037883a 	mov	sp,fp
 2010424:	df000017 	ldw	fp,0(sp)
 2010428:	dec00104 	addi	sp,sp,4
 201042c:	f800283a 	ret

02010430 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
 2010430:	defffc04 	addi	sp,sp,-16
 2010434:	df000315 	stw	fp,12(sp)
 2010438:	df000304 	addi	fp,sp,12
 201043c:	e13fff15 	stw	r4,-4(fp)
	UBaseType_t uxReturn;
	TCB_t const *pxTCB;

		if( xTask != NULL )
 2010440:	e0bfff17 	ldw	r2,-4(fp)
 2010444:	10000626 	beq	r2,zero,2010460 <uxTaskGetTaskNumber+0x30>
		{
			pxTCB = xTask;
 2010448:	e0bfff17 	ldw	r2,-4(fp)
 201044c:	e0bffe15 	stw	r2,-8(fp)
			uxReturn = pxTCB->uxTaskNumber;
 2010450:	e0bffe17 	ldw	r2,-8(fp)
 2010454:	10801917 	ldw	r2,100(r2)
 2010458:	e0bffd15 	stw	r2,-12(fp)
 201045c:	00000106 	br	2010464 <uxTaskGetTaskNumber+0x34>
		}
		else
		{
			uxReturn = 0U;
 2010460:	e03ffd15 	stw	zero,-12(fp)
		}

		return uxReturn;
 2010464:	e0bffd17 	ldw	r2,-12(fp)
	}
 2010468:	e037883a 	mov	sp,fp
 201046c:	df000017 	ldw	fp,0(sp)
 2010470:	dec00104 	addi	sp,sp,4
 2010474:	f800283a 	ret

02010478 <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
 2010478:	defffc04 	addi	sp,sp,-16
 201047c:	df000315 	stw	fp,12(sp)
 2010480:	df000304 	addi	fp,sp,12
 2010484:	e13ffe15 	stw	r4,-8(fp)
 2010488:	e17fff15 	stw	r5,-4(fp)
	TCB_t * pxTCB;

		if( xTask != NULL )
 201048c:	e0bffe17 	ldw	r2,-8(fp)
 2010490:	10000526 	beq	r2,zero,20104a8 <vTaskSetTaskNumber+0x30>
		{
			pxTCB = xTask;
 2010494:	e0bffe17 	ldw	r2,-8(fp)
 2010498:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->uxTaskNumber = uxHandle;
 201049c:	e0bffd17 	ldw	r2,-12(fp)
 20104a0:	e0ffff17 	ldw	r3,-4(fp)
 20104a4:	10c01915 	stw	r3,100(r2)
		}
	}
 20104a8:	0001883a 	nop
 20104ac:	e037883a 	mov	sp,fp
 20104b0:	df000017 	ldw	fp,0(sp)
 20104b4:	dec00104 	addi	sp,sp,4
 20104b8:	f800283a 	ret

020104bc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 20104bc:	defffd04 	addi	sp,sp,-12
 20104c0:	dfc00215 	stw	ra,8(sp)
 20104c4:	df000115 	stw	fp,4(sp)
 20104c8:	df000104 	addi	fp,sp,4
 20104cc:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 20104d0:	20105900 	call	2010590 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 20104d4:	003ffe06 	br	20104d0 <__alt_mem_mem_0+0xfcff04d0>

020104d8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 20104d8:	defffd04 	addi	sp,sp,-12
 20104dc:	dfc00215 	stw	ra,8(sp)
 20104e0:	df000115 	stw	fp,4(sp)
 20104e4:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 20104e8:	e03fff15 	stw	zero,-4(fp)
 20104ec:	00000a06 	br	2010518 <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 20104f0:	e0bfff17 	ldw	r2,-4(fp)
 20104f4:	10c00524 	muli	r3,r2,20
 20104f8:	00808174 	movhi	r2,517
 20104fc:	10b34d04 	addi	r2,r2,-13004
 2010500:	1885883a 	add	r2,r3,r2
 2010504:	1009883a 	mov	r4,r2
 2010508:	202d7a40 	call	202d7a4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 201050c:	e0bfff17 	ldw	r2,-4(fp)
 2010510:	10800044 	addi	r2,r2,1
 2010514:	e0bfff15 	stw	r2,-4(fp)
 2010518:	e0bfff17 	ldw	r2,-4(fp)
 201051c:	10800170 	cmpltui	r2,r2,5
 2010520:	103ff31e 	bne	r2,zero,20104f0 <__alt_mem_mem_0+0xfcff04f0>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 2010524:	01008174 	movhi	r4,517
 2010528:	21336604 	addi	r4,r4,-12904
 201052c:	202d7a40 	call	202d7a4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 2010530:	01008174 	movhi	r4,517
 2010534:	21336b04 	addi	r4,r4,-12884
 2010538:	202d7a40 	call	202d7a4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 201053c:	01008174 	movhi	r4,517
 2010540:	21337004 	addi	r4,r4,-12864
 2010544:	202d7a40 	call	202d7a4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 2010548:	01008174 	movhi	r4,517
 201054c:	21337504 	addi	r4,r4,-12844
 2010550:	202d7a40 	call	202d7a4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 2010554:	01008174 	movhi	r4,517
 2010558:	21337a04 	addi	r4,r4,-12824
 201055c:	202d7a40 	call	202d7a4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 2010560:	00808174 	movhi	r2,517
 2010564:	10b36604 	addi	r2,r2,-12904
 2010568:	d0a7aa15 	stw	r2,-24920(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 201056c:	00808174 	movhi	r2,517
 2010570:	10b36b04 	addi	r2,r2,-12884
 2010574:	d0a7ab15 	stw	r2,-24916(gp)
}
 2010578:	0001883a 	nop
 201057c:	e037883a 	mov	sp,fp
 2010580:	dfc00117 	ldw	ra,4(sp)
 2010584:	df000017 	ldw	fp,0(sp)
 2010588:	dec00204 	addi	sp,sp,8
 201058c:	f800283a 	ret

02010590 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 2010590:	defffd04 	addi	sp,sp,-12
 2010594:	dfc00215 	stw	ra,8(sp)
 2010598:	df000115 	stw	fp,4(sp)
 201059c:	df000104 	addi	fp,sp,4
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 20105a0:	00001706 	br	2010600 <prvCheckTasksWaitingTermination+0x70>
		{
			taskENTER_CRITICAL();
 20105a4:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20105a8:	10000126 	beq	r2,zero,20105b0 <prvCheckTasksWaitingTermination+0x20>
 20105ac:	2010de80 	call	2010de8 <vTaskEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20105b0:	00808174 	movhi	r2,517
 20105b4:	10b37504 	addi	r2,r2,-12844
 20105b8:	10800317 	ldw	r2,12(r2)
 20105bc:	10800317 	ldw	r2,12(r2)
 20105c0:	e0bfff15 	stw	r2,-4(fp)
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 20105c4:	e0bfff17 	ldw	r2,-4(fp)
 20105c8:	10800104 	addi	r2,r2,4
 20105cc:	1009883a 	mov	r4,r2
 20105d0:	202d99c0 	call	202d99c <uxListRemove>
				--uxCurrentNumberOfTasks;
 20105d4:	d0a7ad17 	ldw	r2,-24908(gp)
 20105d8:	10bfffc4 	addi	r2,r2,-1
 20105dc:	d0a7ad15 	stw	r2,-24908(gp)
				--uxDeletedTasksWaitingCleanUp;
 20105e0:	d0a7ac17 	ldw	r2,-24912(gp)
 20105e4:	10bfffc4 	addi	r2,r2,-1
 20105e8:	d0a7ac15 	stw	r2,-24912(gp)
			}
			taskEXIT_CRITICAL();
 20105ec:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20105f0:	10000126 	beq	r2,zero,20105f8 <prvCheckTasksWaitingTermination+0x68>
 20105f4:	2010e300 	call	2010e30 <vTaskExitCritical>

			prvDeleteTCB( pxTCB );
 20105f8:	e13fff17 	ldw	r4,-4(fp)
 20105fc:	20109600 	call	2010960 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 2010600:	d0a7ac17 	ldw	r2,-24912(gp)
 2010604:	103fe71e 	bne	r2,zero,20105a4 <__alt_mem_mem_0+0xfcff05a4>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 2010608:	0001883a 	nop
 201060c:	e037883a 	mov	sp,fp
 2010610:	dfc00117 	ldw	ra,4(sp)
 2010614:	df000017 	ldw	fp,0(sp)
 2010618:	dec00204 	addi	sp,sp,8
 201061c:	f800283a 	ret

02010620 <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
 2010620:	defff904 	addi	sp,sp,-28
 2010624:	dfc00615 	stw	ra,24(sp)
 2010628:	df000515 	stw	fp,20(sp)
 201062c:	df000504 	addi	fp,sp,20
 2010630:	e13ffc15 	stw	r4,-16(fp)
 2010634:	e17ffd15 	stw	r5,-12(fp)
 2010638:	e1bffe15 	stw	r6,-8(fp)
 201063c:	e1ffff15 	stw	r7,-4(fp)
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
 2010640:	e0bffc17 	ldw	r2,-16(fp)
 2010644:	1000021e 	bne	r2,zero,2010650 <vTaskGetInfo+0x30>
 2010648:	d0a7a917 	ldw	r2,-24924(gp)
 201064c:	00000106 	br	2010654 <vTaskGetInfo+0x34>
 2010650:	e0bffc17 	ldw	r2,-16(fp)
 2010654:	e0bffb15 	stw	r2,-20(fp)

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 2010658:	e0bffd17 	ldw	r2,-12(fp)
 201065c:	e0fffb17 	ldw	r3,-20(fp)
 2010660:	10c00015 	stw	r3,0(r2)
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 2010664:	e0bffb17 	ldw	r2,-20(fp)
 2010668:	10c00d04 	addi	r3,r2,52
 201066c:	e0bffd17 	ldw	r2,-12(fp)
 2010670:	10c00115 	stw	r3,4(r2)
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 2010674:	e0bffb17 	ldw	r2,-20(fp)
 2010678:	10c00b17 	ldw	r3,44(r2)
 201067c:	e0bffd17 	ldw	r2,-12(fp)
 2010680:	10c00415 	stw	r3,16(r2)
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 2010684:	e0bffb17 	ldw	r2,-20(fp)
 2010688:	10c00c17 	ldw	r3,48(r2)
 201068c:	e0bffd17 	ldw	r2,-12(fp)
 2010690:	10c00715 	stw	r3,28(r2)
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 2010694:	e0bffb17 	ldw	r2,-20(fp)
 2010698:	10c01817 	ldw	r3,96(r2)
 201069c:	e0bffd17 	ldw	r2,-12(fp)
 20106a0:	10c00215 	stw	r3,8(r2)

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 20106a4:	e0bffb17 	ldw	r2,-20(fp)
 20106a8:	10c01a17 	ldw	r3,104(r2)
 20106ac:	e0bffd17 	ldw	r2,-12(fp)
 20106b0:	10c00515 	stw	r3,20(r2)
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
 20106b4:	e0bffd17 	ldw	r2,-12(fp)
 20106b8:	10000615 	stw	zero,24(r2)
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the
		value of eState passed into this function is eInvalid - otherwise the
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
 20106bc:	e0bfff17 	ldw	r2,-4(fp)
 20106c0:	10800160 	cmpeqi	r2,r2,5
 20106c4:	1000151e 	bne	r2,zero,201071c <vTaskGetInfo+0xfc>
		{
			if( pxTCB == pxCurrentTCB )
 20106c8:	d0a7a917 	ldw	r2,-24924(gp)
 20106cc:	e0fffb17 	ldw	r3,-20(fp)
 20106d0:	1880031e 	bne	r3,r2,20106e0 <vTaskGetInfo+0xc0>
			{
				pxTaskStatus->eCurrentState = eRunning;
 20106d4:	e0bffd17 	ldw	r2,-12(fp)
 20106d8:	10000315 	stw	zero,12(r2)
 20106dc:	00001406 	br	2010730 <vTaskGetInfo+0x110>
			}
			else
			{
				pxTaskStatus->eCurrentState = eState;
 20106e0:	e0bffd17 	ldw	r2,-12(fp)
 20106e4:	e0ffff17 	ldw	r3,-4(fp)
 20106e8:	10c00315 	stw	r3,12(r2)
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a
					chance it is actually just blocked indefinitely - so really
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
 20106ec:	e0bfff17 	ldw	r2,-4(fp)
 20106f0:	108000d8 	cmpnei	r2,r2,3
 20106f4:	10000e1e 	bne	r2,zero,2010730 <vTaskGetInfo+0x110>
					{
						vTaskSuspendAll();
 20106f8:	200f8840 	call	200f884 <vTaskSuspendAll>
						{
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 20106fc:	e0bffb17 	ldw	r2,-20(fp)
 2010700:	10800a17 	ldw	r2,40(r2)
 2010704:	10000326 	beq	r2,zero,2010714 <vTaskGetInfo+0xf4>
							{
								pxTaskStatus->eCurrentState = eBlocked;
 2010708:	e0bffd17 	ldw	r2,-12(fp)
 201070c:	00c00084 	movi	r3,2
 2010710:	10c00315 	stw	r3,12(r2)
							}
						}
						( void ) xTaskResumeAll();
 2010714:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 2010718:	00000506 	br	2010730 <vTaskGetInfo+0x110>
				#endif /* INCLUDE_vTaskSuspend */
			}
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
 201071c:	e13ffb17 	ldw	r4,-20(fp)
 2010720:	200f0f40 	call	200f0f4 <eTaskGetState>
 2010724:	1007883a 	mov	r3,r2
 2010728:	e0bffd17 	ldw	r2,-12(fp)
 201072c:	10c00315 	stw	r3,12(r2)
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
 2010730:	e0bffe17 	ldw	r2,-8(fp)
 2010734:	10000826 	beq	r2,zero,2010758 <vTaskGetInfo+0x138>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 2010738:	e0bffb17 	ldw	r2,-20(fp)
 201073c:	10800c17 	ldw	r2,48(r2)
 2010740:	1009883a 	mov	r4,r2
 2010744:	20108a00 	call	20108a0 <prvTaskCheckFreeStackSpace>
 2010748:	1007883a 	mov	r3,r2
 201074c:	e0bffd17 	ldw	r2,-12(fp)
 2010750:	10c00815 	stw	r3,32(r2)
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
		}
	}
 2010754:	00000206 	br	2010760 <vTaskGetInfo+0x140>
			}
			#endif
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
 2010758:	e0bffd17 	ldw	r2,-12(fp)
 201075c:	10000815 	stw	zero,32(r2)
		}
	}
 2010760:	0001883a 	nop
 2010764:	e037883a 	mov	sp,fp
 2010768:	dfc00117 	ldw	ra,4(sp)
 201076c:	df000017 	ldw	fp,0(sp)
 2010770:	dec00204 	addi	sp,sp,8
 2010774:	f800283a 	ret

02010778 <prvListTasksWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
 2010778:	defff604 	addi	sp,sp,-40
 201077c:	dfc00915 	stw	ra,36(sp)
 2010780:	df000815 	stw	fp,32(sp)
 2010784:	df000804 	addi	fp,sp,32
 2010788:	e13ffd15 	stw	r4,-12(fp)
 201078c:	e17ffe15 	stw	r5,-8(fp)
 2010790:	e1bfff15 	stw	r6,-4(fp)
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 2010794:	e03ff815 	stw	zero,-32(fp)

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 2010798:	e0bffe17 	ldw	r2,-8(fp)
 201079c:	10800017 	ldw	r2,0(r2)
 20107a0:	10003926 	beq	r2,zero,2010888 <prvListTasksWithinSingleList+0x110>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20107a4:	e0bffe17 	ldw	r2,-8(fp)
 20107a8:	e0bff915 	stw	r2,-28(fp)
 20107ac:	e0bff917 	ldw	r2,-28(fp)
 20107b0:	10800117 	ldw	r2,4(r2)
 20107b4:	10c00117 	ldw	r3,4(r2)
 20107b8:	e0bff917 	ldw	r2,-28(fp)
 20107bc:	10c00115 	stw	r3,4(r2)
 20107c0:	e0bff917 	ldw	r2,-28(fp)
 20107c4:	10c00117 	ldw	r3,4(r2)
 20107c8:	e0bff917 	ldw	r2,-28(fp)
 20107cc:	10800204 	addi	r2,r2,8
 20107d0:	1880051e 	bne	r3,r2,20107e8 <prvListTasksWithinSingleList+0x70>
 20107d4:	e0bff917 	ldw	r2,-28(fp)
 20107d8:	10800117 	ldw	r2,4(r2)
 20107dc:	10c00117 	ldw	r3,4(r2)
 20107e0:	e0bff917 	ldw	r2,-28(fp)
 20107e4:	10c00115 	stw	r3,4(r2)
 20107e8:	e0bff917 	ldw	r2,-28(fp)
 20107ec:	10800117 	ldw	r2,4(r2)
 20107f0:	10800317 	ldw	r2,12(r2)
 20107f4:	e0bffa15 	stw	r2,-24(fp)
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20107f8:	e0bffe17 	ldw	r2,-8(fp)
 20107fc:	e0bffb15 	stw	r2,-20(fp)
 2010800:	e0bffb17 	ldw	r2,-20(fp)
 2010804:	10800117 	ldw	r2,4(r2)
 2010808:	10c00117 	ldw	r3,4(r2)
 201080c:	e0bffb17 	ldw	r2,-20(fp)
 2010810:	10c00115 	stw	r3,4(r2)
 2010814:	e0bffb17 	ldw	r2,-20(fp)
 2010818:	10c00117 	ldw	r3,4(r2)
 201081c:	e0bffb17 	ldw	r2,-20(fp)
 2010820:	10800204 	addi	r2,r2,8
 2010824:	1880051e 	bne	r3,r2,201083c <prvListTasksWithinSingleList+0xc4>
 2010828:	e0bffb17 	ldw	r2,-20(fp)
 201082c:	10800117 	ldw	r2,4(r2)
 2010830:	10c00117 	ldw	r3,4(r2)
 2010834:	e0bffb17 	ldw	r2,-20(fp)
 2010838:	10c00115 	stw	r3,4(r2)
 201083c:	e0bffb17 	ldw	r2,-20(fp)
 2010840:	10800117 	ldw	r2,4(r2)
 2010844:	10800317 	ldw	r2,12(r2)
 2010848:	e0bffc15 	stw	r2,-16(fp)
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 201084c:	e0bff817 	ldw	r2,-32(fp)
 2010850:	10800924 	muli	r2,r2,36
 2010854:	e0fffd17 	ldw	r3,-12(fp)
 2010858:	1885883a 	add	r2,r3,r2
 201085c:	e1ffff17 	ldw	r7,-4(fp)
 2010860:	01800044 	movi	r6,1
 2010864:	100b883a 	mov	r5,r2
 2010868:	e13ffc17 	ldw	r4,-16(fp)
 201086c:	20106200 	call	2010620 <vTaskGetInfo>
				uxTask++;
 2010870:	e0bff817 	ldw	r2,-32(fp)
 2010874:	10800044 	addi	r2,r2,1
 2010878:	e0bff815 	stw	r2,-32(fp)
			} while( pxNextTCB != pxFirstTCB );
 201087c:	e0fffc17 	ldw	r3,-16(fp)
 2010880:	e0bffa17 	ldw	r2,-24(fp)
 2010884:	18bfdc1e 	bne	r3,r2,20107f8 <__alt_mem_mem_0+0xfcff07f8>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
 2010888:	e0bff817 	ldw	r2,-32(fp)
	}
 201088c:	e037883a 	mov	sp,fp
 2010890:	dfc00117 	ldw	ra,4(sp)
 2010894:	df000017 	ldw	fp,0(sp)
 2010898:	dec00204 	addi	sp,sp,8
 201089c:	f800283a 	ret

020108a0 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
 20108a0:	defffd04 	addi	sp,sp,-12
 20108a4:	df000215 	stw	fp,8(sp)
 20108a8:	df000204 	addi	fp,sp,8
 20108ac:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
 20108b0:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 20108b4:	00000606 	br	20108d0 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
 20108b8:	e0bfff17 	ldw	r2,-4(fp)
 20108bc:	10800044 	addi	r2,r2,1
 20108c0:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
 20108c4:	e0bffe17 	ldw	r2,-8(fp)
 20108c8:	10800044 	addi	r2,r2,1
 20108cc:	e0bffe15 	stw	r2,-8(fp)

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 20108d0:	e0bfff17 	ldw	r2,-4(fp)
 20108d4:	10800003 	ldbu	r2,0(r2)
 20108d8:	10803fcc 	andi	r2,r2,255
 20108dc:	10802960 	cmpeqi	r2,r2,165
 20108e0:	103ff51e 	bne	r2,zero,20108b8 <__alt_mem_mem_0+0xfcff08b8>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 20108e4:	e0bffe17 	ldw	r2,-8(fp)
 20108e8:	1004d0ba 	srli	r2,r2,2
 20108ec:	e0bffe15 	stw	r2,-8(fp)

		return ( configSTACK_DEPTH_TYPE ) ulCount;
 20108f0:	e0bffe17 	ldw	r2,-8(fp)
	}
 20108f4:	e037883a 	mov	sp,fp
 20108f8:	df000017 	ldw	fp,0(sp)
 20108fc:	dec00104 	addi	sp,sp,4
 2010900:	f800283a 	ret

02010904 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
 2010904:	defffa04 	addi	sp,sp,-24
 2010908:	dfc00515 	stw	ra,20(sp)
 201090c:	df000415 	stw	fp,16(sp)
 2010910:	df000404 	addi	fp,sp,16
 2010914:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
 2010918:	e0bfff17 	ldw	r2,-4(fp)
 201091c:	1000021e 	bne	r2,zero,2010928 <uxTaskGetStackHighWaterMark+0x24>
 2010920:	d0a7a917 	ldw	r2,-24924(gp)
 2010924:	00000106 	br	201092c <uxTaskGetStackHighWaterMark+0x28>
 2010928:	e0bfff17 	ldw	r2,-4(fp)
 201092c:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 2010930:	e0bffc17 	ldw	r2,-16(fp)
 2010934:	10800c17 	ldw	r2,48(r2)
 2010938:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 201093c:	e13ffd17 	ldw	r4,-12(fp)
 2010940:	20108a00 	call	20108a0 <prvTaskCheckFreeStackSpace>
 2010944:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
 2010948:	e0bffe17 	ldw	r2,-8(fp)
	}
 201094c:	e037883a 	mov	sp,fp
 2010950:	dfc00117 	ldw	ra,4(sp)
 2010954:	df000017 	ldw	fp,0(sp)
 2010958:	dec00204 	addi	sp,sp,8
 201095c:	f800283a 	ret

02010960 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 2010960:	defffd04 	addi	sp,sp,-12
 2010964:	dfc00215 	stw	ra,8(sp)
 2010968:	df000115 	stw	fp,4(sp)
 201096c:	df000104 	addi	fp,sp,4
 2010970:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 2010974:	e0bfff17 	ldw	r2,-4(fp)
 2010978:	10800c17 	ldw	r2,48(r2)
 201097c:	1009883a 	mov	r4,r2
 2010980:	202d7300 	call	202d730 <vPortFree>
			vPortFree( pxTCB );
 2010984:	e13fff17 	ldw	r4,-4(fp)
 2010988:	202d7300 	call	202d730 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 201098c:	0001883a 	nop
 2010990:	e037883a 	mov	sp,fp
 2010994:	dfc00117 	ldw	ra,4(sp)
 2010998:	df000017 	ldw	fp,0(sp)
 201099c:	dec00204 	addi	sp,sp,8
 20109a0:	f800283a 	ret

020109a4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 20109a4:	defffe04 	addi	sp,sp,-8
 20109a8:	df000115 	stw	fp,4(sp)
 20109ac:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 20109b0:	d0a7aa17 	ldw	r2,-24920(gp)
 20109b4:	10800017 	ldw	r2,0(r2)
 20109b8:	1000031e 	bne	r2,zero,20109c8 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 20109bc:	00bfffc4 	movi	r2,-1
 20109c0:	d0a7b515 	stw	r2,-24876(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 20109c4:	00000706 	br	20109e4 <prvResetNextTaskUnblockTime+0x40>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20109c8:	d0a7aa17 	ldw	r2,-24920(gp)
 20109cc:	10800317 	ldw	r2,12(r2)
 20109d0:	10800317 	ldw	r2,12(r2)
 20109d4:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 20109d8:	e0bfff17 	ldw	r2,-4(fp)
 20109dc:	10800117 	ldw	r2,4(r2)
 20109e0:	d0a7b515 	stw	r2,-24876(gp)
	}
}
 20109e4:	0001883a 	nop
 20109e8:	e037883a 	mov	sp,fp
 20109ec:	df000017 	ldw	fp,0(sp)
 20109f0:	dec00104 	addi	sp,sp,4
 20109f4:	f800283a 	ret

020109f8 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 20109f8:	defffe04 	addi	sp,sp,-8
 20109fc:	df000115 	stw	fp,4(sp)
 2010a00:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 2010a04:	d0a7a917 	ldw	r2,-24924(gp)
 2010a08:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
 2010a0c:	e0bfff17 	ldw	r2,-4(fp)
	}
 2010a10:	e037883a 	mov	sp,fp
 2010a14:	df000017 	ldw	fp,0(sp)
 2010a18:	dec00104 	addi	sp,sp,4
 2010a1c:	f800283a 	ret

02010a20 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 2010a20:	defffe04 	addi	sp,sp,-8
 2010a24:	df000115 	stw	fp,4(sp)
 2010a28:	df000104 	addi	fp,sp,4
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 2010a2c:	d0a7b017 	ldw	r2,-24896(gp)
 2010a30:	1000031e 	bne	r2,zero,2010a40 <xTaskGetSchedulerState+0x20>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 2010a34:	00800044 	movi	r2,1
 2010a38:	e0bfff15 	stw	r2,-4(fp)
 2010a3c:	00000606 	br	2010a58 <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2010a40:	d0a7b717 	ldw	r2,-24868(gp)
 2010a44:	1000031e 	bne	r2,zero,2010a54 <xTaskGetSchedulerState+0x34>
			{
				xReturn = taskSCHEDULER_RUNNING;
 2010a48:	00800084 	movi	r2,2
 2010a4c:	e0bfff15 	stw	r2,-4(fp)
 2010a50:	00000106 	br	2010a58 <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 2010a54:	e03fff15 	stw	zero,-4(fp)
			}
		}

		return xReturn;
 2010a58:	e0bfff17 	ldw	r2,-4(fp)
	}
 2010a5c:	e037883a 	mov	sp,fp
 2010a60:	df000017 	ldw	fp,0(sp)
 2010a64:	dec00104 	addi	sp,sp,4
 2010a68:	f800283a 	ret

02010a6c <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 2010a6c:	defffb04 	addi	sp,sp,-20
 2010a70:	dfc00415 	stw	ra,16(sp)
 2010a74:	df000315 	stw	fp,12(sp)
 2010a78:	df000304 	addi	fp,sp,12
 2010a7c:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 2010a80:	e0bfff17 	ldw	r2,-4(fp)
 2010a84:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 2010a88:	e03ffd15 	stw	zero,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
 2010a8c:	e0bfff17 	ldw	r2,-4(fp)
 2010a90:	10004026 	beq	r2,zero,2010b94 <xTaskPriorityInherit+0x128>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 2010a94:	e0bffe17 	ldw	r2,-8(fp)
 2010a98:	10c00b17 	ldw	r3,44(r2)
 2010a9c:	d0a7a917 	ldw	r2,-24924(gp)
 2010aa0:	10800b17 	ldw	r2,44(r2)
 2010aa4:	1880342e 	bgeu	r3,r2,2010b78 <xTaskPriorityInherit+0x10c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 2010aa8:	e0bffe17 	ldw	r2,-8(fp)
 2010aac:	10800617 	ldw	r2,24(r2)
 2010ab0:	10000616 	blt	r2,zero,2010acc <xTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2010ab4:	d0a7a917 	ldw	r2,-24924(gp)
 2010ab8:	10800b17 	ldw	r2,44(r2)
 2010abc:	00c00144 	movi	r3,5
 2010ac0:	1887c83a 	sub	r3,r3,r2
 2010ac4:	e0bffe17 	ldw	r2,-8(fp)
 2010ac8:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 2010acc:	e0bffe17 	ldw	r2,-8(fp)
 2010ad0:	10c00517 	ldw	r3,20(r2)
 2010ad4:	e0bffe17 	ldw	r2,-8(fp)
 2010ad8:	10800b17 	ldw	r2,44(r2)
 2010adc:	11000524 	muli	r4,r2,20
 2010ae0:	00808174 	movhi	r2,517
 2010ae4:	10b34d04 	addi	r2,r2,-13004
 2010ae8:	2085883a 	add	r2,r4,r2
 2010aec:	18801b1e 	bne	r3,r2,2010b5c <xTaskPriorityInherit+0xf0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2010af0:	e0bffe17 	ldw	r2,-8(fp)
 2010af4:	10800104 	addi	r2,r2,4
 2010af8:	1009883a 	mov	r4,r2
 2010afc:	202d99c0 	call	202d99c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 2010b00:	d0a7a917 	ldw	r2,-24924(gp)
 2010b04:	10c00b17 	ldw	r3,44(r2)
 2010b08:	e0bffe17 	ldw	r2,-8(fp)
 2010b0c:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxMutexHolderTCB );
 2010b10:	e0bffe17 	ldw	r2,-8(fp)
 2010b14:	10800b17 	ldw	r2,44(r2)
 2010b18:	d0e7af17 	ldw	r3,-24900(gp)
 2010b1c:	1880032e 	bgeu	r3,r2,2010b2c <xTaskPriorityInherit+0xc0>
 2010b20:	e0bffe17 	ldw	r2,-8(fp)
 2010b24:	10800b17 	ldw	r2,44(r2)
 2010b28:	d0a7af15 	stw	r2,-24900(gp)
 2010b2c:	e0bffe17 	ldw	r2,-8(fp)
 2010b30:	10800b17 	ldw	r2,44(r2)
 2010b34:	10c00524 	muli	r3,r2,20
 2010b38:	00808174 	movhi	r2,517
 2010b3c:	10b34d04 	addi	r2,r2,-13004
 2010b40:	1887883a 	add	r3,r3,r2
 2010b44:	e0bffe17 	ldw	r2,-8(fp)
 2010b48:	10800104 	addi	r2,r2,4
 2010b4c:	100b883a 	mov	r5,r2
 2010b50:	1809883a 	mov	r4,r3
 2010b54:	202d8380 	call	202d838 <vListInsertEnd>
 2010b58:	00000406 	br	2010b6c <xTaskPriorityInherit+0x100>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 2010b5c:	d0a7a917 	ldw	r2,-24924(gp)
 2010b60:	10c00b17 	ldw	r3,44(r2)
 2010b64:	e0bffe17 	ldw	r2,-8(fp)
 2010b68:	10c00b15 	stw	r3,44(r2)
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
 2010b6c:	00800044 	movi	r2,1
 2010b70:	e0bffd15 	stw	r2,-12(fp)
 2010b74:	00000706 	br	2010b94 <xTaskPriorityInherit+0x128>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 2010b78:	e0bffe17 	ldw	r2,-8(fp)
 2010b7c:	10c01a17 	ldw	r3,104(r2)
 2010b80:	d0a7a917 	ldw	r2,-24924(gp)
 2010b84:	10800b17 	ldw	r2,44(r2)
 2010b88:	1880022e 	bgeu	r3,r2,2010b94 <xTaskPriorityInherit+0x128>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
 2010b8c:	00800044 	movi	r2,1
 2010b90:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 2010b94:	e0bffd17 	ldw	r2,-12(fp)
	}
 2010b98:	e037883a 	mov	sp,fp
 2010b9c:	dfc00117 	ldw	ra,4(sp)
 2010ba0:	df000017 	ldw	fp,0(sp)
 2010ba4:	dec00204 	addi	sp,sp,8
 2010ba8:	f800283a 	ret

02010bac <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 2010bac:	defffb04 	addi	sp,sp,-20
 2010bb0:	dfc00415 	stw	ra,16(sp)
 2010bb4:	df000315 	stw	fp,12(sp)
 2010bb8:	df000304 	addi	fp,sp,12
 2010bbc:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 2010bc0:	e0bfff17 	ldw	r2,-4(fp)
 2010bc4:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 2010bc8:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
 2010bcc:	e0bfff17 	ldw	r2,-4(fp)
 2010bd0:	10002f26 	beq	r2,zero,2010c90 <xTaskPriorityDisinherit+0xe4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 2010bd4:	e0bffe17 	ldw	r2,-8(fp)
 2010bd8:	10801b17 	ldw	r2,108(r2)
 2010bdc:	10ffffc4 	addi	r3,r2,-1
 2010be0:	e0bffe17 	ldw	r2,-8(fp)
 2010be4:	10c01b15 	stw	r3,108(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 2010be8:	e0bffe17 	ldw	r2,-8(fp)
 2010bec:	10c00b17 	ldw	r3,44(r2)
 2010bf0:	e0bffe17 	ldw	r2,-8(fp)
 2010bf4:	10801a17 	ldw	r2,104(r2)
 2010bf8:	18802526 	beq	r3,r2,2010c90 <xTaskPriorityDisinherit+0xe4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 2010bfc:	e0bffe17 	ldw	r2,-8(fp)
 2010c00:	10801b17 	ldw	r2,108(r2)
 2010c04:	1000221e 	bne	r2,zero,2010c90 <xTaskPriorityDisinherit+0xe4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2010c08:	e0bffe17 	ldw	r2,-8(fp)
 2010c0c:	10800104 	addi	r2,r2,4
 2010c10:	1009883a 	mov	r4,r2
 2010c14:	202d99c0 	call	202d99c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 2010c18:	e0bffe17 	ldw	r2,-8(fp)
 2010c1c:	10c01a17 	ldw	r3,104(r2)
 2010c20:	e0bffe17 	ldw	r2,-8(fp)
 2010c24:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2010c28:	e0bffe17 	ldw	r2,-8(fp)
 2010c2c:	10800b17 	ldw	r2,44(r2)
 2010c30:	00c00144 	movi	r3,5
 2010c34:	1887c83a 	sub	r3,r3,r2
 2010c38:	e0bffe17 	ldw	r2,-8(fp)
 2010c3c:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
 2010c40:	e0bffe17 	ldw	r2,-8(fp)
 2010c44:	10800b17 	ldw	r2,44(r2)
 2010c48:	d0e7af17 	ldw	r3,-24900(gp)
 2010c4c:	1880032e 	bgeu	r3,r2,2010c5c <xTaskPriorityDisinherit+0xb0>
 2010c50:	e0bffe17 	ldw	r2,-8(fp)
 2010c54:	10800b17 	ldw	r2,44(r2)
 2010c58:	d0a7af15 	stw	r2,-24900(gp)
 2010c5c:	e0bffe17 	ldw	r2,-8(fp)
 2010c60:	10800b17 	ldw	r2,44(r2)
 2010c64:	10c00524 	muli	r3,r2,20
 2010c68:	00808174 	movhi	r2,517
 2010c6c:	10b34d04 	addi	r2,r2,-13004
 2010c70:	1887883a 	add	r3,r3,r2
 2010c74:	e0bffe17 	ldw	r2,-8(fp)
 2010c78:	10800104 	addi	r2,r2,4
 2010c7c:	100b883a 	mov	r5,r2
 2010c80:	1809883a 	mov	r4,r3
 2010c84:	202d8380 	call	202d838 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 2010c88:	00800044 	movi	r2,1
 2010c8c:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 2010c90:	e0bffd17 	ldw	r2,-12(fp)
	}
 2010c94:	e037883a 	mov	sp,fp
 2010c98:	dfc00117 	ldw	ra,4(sp)
 2010c9c:	df000017 	ldw	fp,0(sp)
 2010ca0:	dec00204 	addi	sp,sp,8
 2010ca4:	f800283a 	ret

02010ca8 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
 2010ca8:	defff804 	addi	sp,sp,-32
 2010cac:	dfc00715 	stw	ra,28(sp)
 2010cb0:	df000615 	stw	fp,24(sp)
 2010cb4:	df000604 	addi	fp,sp,24
 2010cb8:	e13ffe15 	stw	r4,-8(fp)
 2010cbc:	e17fff15 	stw	r5,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 2010cc0:	e0bffe17 	ldw	r2,-8(fp)
 2010cc4:	e0bffb15 	stw	r2,-20(fp)
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 2010cc8:	00800044 	movi	r2,1
 2010ccc:	e0bffc15 	stw	r2,-16(fp)

		if( pxMutexHolder != NULL )
 2010cd0:	e0bffe17 	ldw	r2,-8(fp)
 2010cd4:	10003e26 	beq	r2,zero,2010dd0 <vTaskPriorityDisinheritAfterTimeout+0x128>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 2010cd8:	e0bffb17 	ldw	r2,-20(fp)
 2010cdc:	10c01a17 	ldw	r3,104(r2)
 2010ce0:	e0bfff17 	ldw	r2,-4(fp)
 2010ce4:	1880032e 	bgeu	r3,r2,2010cf4 <vTaskPriorityDisinheritAfterTimeout+0x4c>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 2010ce8:	e0bfff17 	ldw	r2,-4(fp)
 2010cec:	e0bffa15 	stw	r2,-24(fp)
 2010cf0:	00000306 	br	2010d00 <vTaskPriorityDisinheritAfterTimeout+0x58>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
 2010cf4:	e0bffb17 	ldw	r2,-20(fp)
 2010cf8:	10801a17 	ldw	r2,104(r2)
 2010cfc:	e0bffa15 	stw	r2,-24(fp)
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
 2010d00:	e0bffb17 	ldw	r2,-20(fp)
 2010d04:	10c00b17 	ldw	r3,44(r2)
 2010d08:	e0bffa17 	ldw	r2,-24(fp)
 2010d0c:	18803026 	beq	r3,r2,2010dd0 <vTaskPriorityDisinheritAfterTimeout+0x128>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 2010d10:	e0bffb17 	ldw	r2,-20(fp)
 2010d14:	10c01b17 	ldw	r3,108(r2)
 2010d18:	e0bffc17 	ldw	r2,-16(fp)
 2010d1c:	18802c1e 	bne	r3,r2,2010dd0 <vTaskPriorityDisinheritAfterTimeout+0x128>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 2010d20:	e0bffb17 	ldw	r2,-20(fp)
 2010d24:	10800b17 	ldw	r2,44(r2)
 2010d28:	e0bffd15 	stw	r2,-12(fp)
					pxTCB->uxPriority = uxPriorityToUse;
 2010d2c:	e0bffb17 	ldw	r2,-20(fp)
 2010d30:	e0fffa17 	ldw	r3,-24(fp)
 2010d34:	10c00b15 	stw	r3,44(r2)

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 2010d38:	e0bffb17 	ldw	r2,-20(fp)
 2010d3c:	10800617 	ldw	r2,24(r2)
 2010d40:	10000516 	blt	r2,zero,2010d58 <vTaskPriorityDisinheritAfterTimeout+0xb0>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2010d44:	00c00144 	movi	r3,5
 2010d48:	e0bffa17 	ldw	r2,-24(fp)
 2010d4c:	1887c83a 	sub	r3,r3,r2
 2010d50:	e0bffb17 	ldw	r2,-20(fp)
 2010d54:	10c00615 	stw	r3,24(r2)
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 2010d58:	e0bffb17 	ldw	r2,-20(fp)
 2010d5c:	10c00517 	ldw	r3,20(r2)
 2010d60:	e0bffd17 	ldw	r2,-12(fp)
 2010d64:	11000524 	muli	r4,r2,20
 2010d68:	00808174 	movhi	r2,517
 2010d6c:	10b34d04 	addi	r2,r2,-13004
 2010d70:	2085883a 	add	r2,r4,r2
 2010d74:	1880161e 	bne	r3,r2,2010dd0 <vTaskPriorityDisinheritAfterTimeout+0x128>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2010d78:	e0bffb17 	ldw	r2,-20(fp)
 2010d7c:	10800104 	addi	r2,r2,4
 2010d80:	1009883a 	mov	r4,r2
 2010d84:	202d99c0 	call	202d99c <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
 2010d88:	e0bffb17 	ldw	r2,-20(fp)
 2010d8c:	10800b17 	ldw	r2,44(r2)
 2010d90:	d0e7af17 	ldw	r3,-24900(gp)
 2010d94:	1880032e 	bgeu	r3,r2,2010da4 <vTaskPriorityDisinheritAfterTimeout+0xfc>
 2010d98:	e0bffb17 	ldw	r2,-20(fp)
 2010d9c:	10800b17 	ldw	r2,44(r2)
 2010da0:	d0a7af15 	stw	r2,-24900(gp)
 2010da4:	e0bffb17 	ldw	r2,-20(fp)
 2010da8:	10800b17 	ldw	r2,44(r2)
 2010dac:	10c00524 	muli	r3,r2,20
 2010db0:	00808174 	movhi	r2,517
 2010db4:	10b34d04 	addi	r2,r2,-13004
 2010db8:	1887883a 	add	r3,r3,r2
 2010dbc:	e0bffb17 	ldw	r2,-20(fp)
 2010dc0:	10800104 	addi	r2,r2,4
 2010dc4:	100b883a 	mov	r5,r2
 2010dc8:	1809883a 	mov	r4,r3
 2010dcc:	202d8380 	call	202d838 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2010dd0:	0001883a 	nop
 2010dd4:	e037883a 	mov	sp,fp
 2010dd8:	dfc00117 	ldw	ra,4(sp)
 2010ddc:	df000017 	ldw	fp,0(sp)
 2010de0:	dec00204 	addi	sp,sp,8
 2010de4:	f800283a 	ret

02010de8 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
 2010de8:	defffe04 	addi	sp,sp,-8
 2010dec:	dfc00115 	stw	ra,4(sp)
 2010df0:	df000015 	stw	fp,0(sp)
 2010df4:	d839883a 	mov	fp,sp
		portDISABLE_INTERRUPTS();
 2010df8:	202da600 	call	202da60 <enh_alt_irq_disable_all>

		if( xSchedulerRunning != pdFALSE )
 2010dfc:	d0a7b017 	ldw	r2,-24896(gp)
 2010e00:	10000526 	beq	r2,zero,2010e18 <vTaskEnterCritical+0x30>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
 2010e04:	d0a7a917 	ldw	r2,-24924(gp)
 2010e08:	10c01717 	ldw	r3,92(r2)
 2010e0c:	18c00044 	addi	r3,r3,1
 2010e10:	10c01715 	stw	r3,92(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
 2010e14:	d0a7a917 	ldw	r2,-24924(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2010e18:	0001883a 	nop
 2010e1c:	e037883a 	mov	sp,fp
 2010e20:	dfc00117 	ldw	ra,4(sp)
 2010e24:	df000017 	ldw	fp,0(sp)
 2010e28:	dec00204 	addi	sp,sp,8
 2010e2c:	f800283a 	ret

02010e30 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
 2010e30:	defffe04 	addi	sp,sp,-8
 2010e34:	dfc00115 	stw	ra,4(sp)
 2010e38:	df000015 	stw	fp,0(sp)
 2010e3c:	d839883a 	mov	fp,sp
		if( xSchedulerRunning != pdFALSE )
 2010e40:	d0a7b017 	ldw	r2,-24896(gp)
 2010e44:	10000b26 	beq	r2,zero,2010e74 <vTaskExitCritical+0x44>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
 2010e48:	d0a7a917 	ldw	r2,-24924(gp)
 2010e4c:	10801717 	ldw	r2,92(r2)
 2010e50:	10000826 	beq	r2,zero,2010e74 <vTaskExitCritical+0x44>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
 2010e54:	d0a7a917 	ldw	r2,-24924(gp)
 2010e58:	10c01717 	ldw	r3,92(r2)
 2010e5c:	18ffffc4 	addi	r3,r3,-1
 2010e60:	10c01715 	stw	r3,92(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
 2010e64:	d0a7a917 	ldw	r2,-24924(gp)
 2010e68:	10801717 	ldw	r2,92(r2)
 2010e6c:	1000011e 	bne	r2,zero,2010e74 <vTaskExitCritical+0x44>
				{
					portENABLE_INTERRUPTS();
 2010e70:	202dab00 	call	202dab0 <enh_alt_irq_enable_all>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2010e74:	0001883a 	nop
 2010e78:	e037883a 	mov	sp,fp
 2010e7c:	dfc00117 	ldw	ra,4(sp)
 2010e80:	df000017 	ldw	fp,0(sp)
 2010e84:	dec00204 	addi	sp,sp,8
 2010e88:	f800283a 	ret

02010e8c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 2010e8c:	defffe04 	addi	sp,sp,-8
 2010e90:	df000115 	stw	fp,4(sp)
 2010e94:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 2010e98:	d0a7a917 	ldw	r2,-24924(gp)
 2010e9c:	10800617 	ldw	r2,24(r2)
 2010ea0:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2010ea4:	d0a7a917 	ldw	r2,-24924(gp)
 2010ea8:	d0e7a917 	ldw	r3,-24924(gp)
 2010eac:	18c00b17 	ldw	r3,44(r3)
 2010eb0:	01000144 	movi	r4,5
 2010eb4:	20c7c83a 	sub	r3,r4,r3
 2010eb8:	10c00615 	stw	r3,24(r2)

	return uxReturn;
 2010ebc:	e0bfff17 	ldw	r2,-4(fp)
}
 2010ec0:	e037883a 	mov	sp,fp
 2010ec4:	df000017 	ldw	fp,0(sp)
 2010ec8:	dec00104 	addi	sp,sp,4
 2010ecc:	f800283a 	ret

02010ed0 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
 2010ed0:	deffff04 	addi	sp,sp,-4
 2010ed4:	df000015 	stw	fp,0(sp)
 2010ed8:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 2010edc:	d0a7a917 	ldw	r2,-24924(gp)
 2010ee0:	10000426 	beq	r2,zero,2010ef4 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 2010ee4:	d0a7a917 	ldw	r2,-24924(gp)
 2010ee8:	10c01b17 	ldw	r3,108(r2)
 2010eec:	18c00044 	addi	r3,r3,1
 2010ef0:	10c01b15 	stw	r3,108(r2)
		}

		return pxCurrentTCB;
 2010ef4:	d0a7a917 	ldw	r2,-24924(gp)
	}
 2010ef8:	e037883a 	mov	sp,fp
 2010efc:	df000017 	ldw	fp,0(sp)
 2010f00:	dec00104 	addi	sp,sp,4
 2010f04:	f800283a 	ret

02010f08 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 2010f08:	defffb04 	addi	sp,sp,-20
 2010f0c:	dfc00415 	stw	ra,16(sp)
 2010f10:	df000315 	stw	fp,12(sp)
 2010f14:	df000304 	addi	fp,sp,12
 2010f18:	e13ffe15 	stw	r4,-8(fp)
 2010f1c:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 2010f20:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2010f24:	10000126 	beq	r2,zero,2010f2c <ulTaskNotifyTake+0x24>
 2010f28:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 2010f2c:	d0a7a917 	ldw	r2,-24924(gp)
 2010f30:	10801c17 	ldw	r2,112(r2)
 2010f34:	1000091e 	bne	r2,zero,2010f5c <ulTaskNotifyTake+0x54>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 2010f38:	d0a7a917 	ldw	r2,-24924(gp)
 2010f3c:	00c00044 	movi	r3,1
 2010f40:	10c01d05 	stb	r3,116(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 2010f44:	e0bfff17 	ldw	r2,-4(fp)
 2010f48:	10000426 	beq	r2,zero,2010f5c <ulTaskNotifyTake+0x54>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2010f4c:	01400044 	movi	r5,1
 2010f50:	e13fff17 	ldw	r4,-4(fp)
 2010f54:	20116bc0 	call	20116bc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 2010f58:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 2010f5c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2010f60:	10000126 	beq	r2,zero,2010f68 <ulTaskNotifyTake+0x60>
 2010f64:	2010e300 	call	2010e30 <vTaskExitCritical>

		taskENTER_CRITICAL();
 2010f68:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2010f6c:	10000126 	beq	r2,zero,2010f74 <ulTaskNotifyTake+0x6c>
 2010f70:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 2010f74:	d0a7a917 	ldw	r2,-24924(gp)
 2010f78:	10801c17 	ldw	r2,112(r2)
 2010f7c:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
 2010f80:	e0bffd17 	ldw	r2,-12(fp)
 2010f84:	10000926 	beq	r2,zero,2010fac <ulTaskNotifyTake+0xa4>
			{
				if( xClearCountOnExit != pdFALSE )
 2010f88:	e0bffe17 	ldw	r2,-8(fp)
 2010f8c:	10000326 	beq	r2,zero,2010f9c <ulTaskNotifyTake+0x94>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 2010f90:	d0a7a917 	ldw	r2,-24924(gp)
 2010f94:	10001c15 	stw	zero,112(r2)
 2010f98:	00000406 	br	2010fac <ulTaskNotifyTake+0xa4>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 2010f9c:	d0a7a917 	ldw	r2,-24924(gp)
 2010fa0:	e0fffd17 	ldw	r3,-12(fp)
 2010fa4:	18ffffc4 	addi	r3,r3,-1
 2010fa8:	10c01c15 	stw	r3,112(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 2010fac:	d0a7a917 	ldw	r2,-24924(gp)
 2010fb0:	10001d05 	stb	zero,116(r2)
		}
		taskEXIT_CRITICAL();
 2010fb4:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2010fb8:	10000126 	beq	r2,zero,2010fc0 <ulTaskNotifyTake+0xb8>
 2010fbc:	2010e300 	call	2010e30 <vTaskExitCritical>

		return ulReturn;
 2010fc0:	e0bffd17 	ldw	r2,-12(fp)
	}
 2010fc4:	e037883a 	mov	sp,fp
 2010fc8:	dfc00117 	ldw	ra,4(sp)
 2010fcc:	df000017 	ldw	fp,0(sp)
 2010fd0:	dec00204 	addi	sp,sp,8
 2010fd4:	f800283a 	ret

02010fd8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 2010fd8:	defff904 	addi	sp,sp,-28
 2010fdc:	dfc00615 	stw	ra,24(sp)
 2010fe0:	df000515 	stw	fp,20(sp)
 2010fe4:	df000504 	addi	fp,sp,20
 2010fe8:	e13ffc15 	stw	r4,-16(fp)
 2010fec:	e17ffd15 	stw	r5,-12(fp)
 2010ff0:	e1bffe15 	stw	r6,-8(fp)
 2010ff4:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 2010ff8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2010ffc:	10000126 	beq	r2,zero,2011004 <xTaskNotifyWait+0x2c>
 2011000:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 2011004:	d0a7a917 	ldw	r2,-24924(gp)
 2011008:	10801d03 	ldbu	r2,116(r2)
 201100c:	10803fcc 	andi	r2,r2,255
 2011010:	108000a0 	cmpeqi	r2,r2,2
 2011014:	10000f1e 	bne	r2,zero,2011054 <xTaskNotifyWait+0x7c>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 2011018:	d0a7a917 	ldw	r2,-24924(gp)
 201101c:	11001c17 	ldw	r4,112(r2)
 2011020:	e0fffc17 	ldw	r3,-16(fp)
 2011024:	00c6303a 	nor	r3,zero,r3
 2011028:	20c6703a 	and	r3,r4,r3
 201102c:	10c01c15 	stw	r3,112(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 2011030:	d0a7a917 	ldw	r2,-24924(gp)
 2011034:	00c00044 	movi	r3,1
 2011038:	10c01d05 	stb	r3,116(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 201103c:	e0bfff17 	ldw	r2,-4(fp)
 2011040:	10000426 	beq	r2,zero,2011054 <xTaskNotifyWait+0x7c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2011044:	01400044 	movi	r5,1
 2011048:	e13fff17 	ldw	r4,-4(fp)
 201104c:	20116bc0 	call	20116bc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 2011050:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 2011054:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011058:	10000126 	beq	r2,zero,2011060 <xTaskNotifyWait+0x88>
 201105c:	2010e300 	call	2010e30 <vTaskExitCritical>

		taskENTER_CRITICAL();
 2011060:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011064:	10000126 	beq	r2,zero,201106c <xTaskNotifyWait+0x94>
 2011068:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 201106c:	e0bffe17 	ldw	r2,-8(fp)
 2011070:	10000426 	beq	r2,zero,2011084 <xTaskNotifyWait+0xac>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 2011074:	d0a7a917 	ldw	r2,-24924(gp)
 2011078:	10c01c17 	ldw	r3,112(r2)
 201107c:	e0bffe17 	ldw	r2,-8(fp)
 2011080:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 2011084:	d0a7a917 	ldw	r2,-24924(gp)
 2011088:	10801d03 	ldbu	r2,116(r2)
 201108c:	10803fcc 	andi	r2,r2,255
 2011090:	108000a0 	cmpeqi	r2,r2,2
 2011094:	1000021e 	bne	r2,zero,20110a0 <xTaskNotifyWait+0xc8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 2011098:	e03ffb15 	stw	zero,-20(fp)
 201109c:	00000806 	br	20110c0 <xTaskNotifyWait+0xe8>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 20110a0:	d0a7a917 	ldw	r2,-24924(gp)
 20110a4:	11001c17 	ldw	r4,112(r2)
 20110a8:	e0fffd17 	ldw	r3,-12(fp)
 20110ac:	00c6303a 	nor	r3,zero,r3
 20110b0:	20c6703a 	and	r3,r4,r3
 20110b4:	10c01c15 	stw	r3,112(r2)
				xReturn = pdTRUE;
 20110b8:	00800044 	movi	r2,1
 20110bc:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 20110c0:	d0a7a917 	ldw	r2,-24924(gp)
 20110c4:	10001d05 	stb	zero,116(r2)
		}
		taskEXIT_CRITICAL();
 20110c8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20110cc:	10000126 	beq	r2,zero,20110d4 <xTaskNotifyWait+0xfc>
 20110d0:	2010e300 	call	2010e30 <vTaskExitCritical>

		return xReturn;
 20110d4:	e0bffb17 	ldw	r2,-20(fp)
	}
 20110d8:	e037883a 	mov	sp,fp
 20110dc:	dfc00117 	ldw	ra,4(sp)
 20110e0:	df000017 	ldw	fp,0(sp)
 20110e4:	dec00204 	addi	sp,sp,8
 20110e8:	f800283a 	ret

020110ec <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 20110ec:	defff704 	addi	sp,sp,-36
 20110f0:	dfc00815 	stw	ra,32(sp)
 20110f4:	df000715 	stw	fp,28(sp)
 20110f8:	df000704 	addi	fp,sp,28
 20110fc:	e13ffc15 	stw	r4,-16(fp)
 2011100:	e17ffd15 	stw	r5,-12(fp)
 2011104:	e1bffe15 	stw	r6,-8(fp)
 2011108:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 201110c:	00800044 	movi	r2,1
 2011110:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
 2011114:	e0bffc17 	ldw	r2,-16(fp)
 2011118:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
 201111c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011120:	10000126 	beq	r2,zero,2011128 <xTaskGenericNotify+0x3c>
 2011124:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 2011128:	e0bfff17 	ldw	r2,-4(fp)
 201112c:	10000426 	beq	r2,zero,2011140 <xTaskGenericNotify+0x54>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 2011130:	e0bffa17 	ldw	r2,-24(fp)
 2011134:	10c01c17 	ldw	r3,112(r2)
 2011138:	e0bfff17 	ldw	r2,-4(fp)
 201113c:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 2011140:	e0bffa17 	ldw	r2,-24(fp)
 2011144:	10801d03 	ldbu	r2,116(r2)
 2011148:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 201114c:	e0bffa17 	ldw	r2,-24(fp)
 2011150:	00c00084 	movi	r3,2
 2011154:	10c01d05 	stb	r3,116(r2)

			switch( eAction )
 2011158:	e0bffe17 	ldw	r2,-8(fp)
 201115c:	10800168 	cmpgeui	r2,r2,5
 2011160:	1000261e 	bne	r2,zero,20111fc <xTaskGenericNotify+0x110>
 2011164:	e0bffe17 	ldw	r2,-8(fp)
 2011168:	100690ba 	slli	r3,r2,2
 201116c:	00808074 	movhi	r2,513
 2011170:	10846004 	addi	r2,r2,4480
 2011174:	1885883a 	add	r2,r3,r2
 2011178:	10800017 	ldw	r2,0(r2)
 201117c:	1000683a 	jmp	r2
 2011180:	02011204 	movi	r8,1096
 2011184:	02011194 	movui	r8,1094
 2011188:	020111b0 	cmpltui	r8,zero,1094
 201118c:	020111c8 	cmpgei	r8,zero,1095
 2011190:	020111d8 	cmpnei	r8,zero,1095
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 2011194:	e0bffa17 	ldw	r2,-24(fp)
 2011198:	10c01c17 	ldw	r3,112(r2)
 201119c:	e0bffd17 	ldw	r2,-12(fp)
 20111a0:	1886b03a 	or	r3,r3,r2
 20111a4:	e0bffa17 	ldw	r2,-24(fp)
 20111a8:	10c01c15 	stw	r3,112(r2)
					break;
 20111ac:	00001606 	br	2011208 <xTaskGenericNotify+0x11c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 20111b0:	e0bffa17 	ldw	r2,-24(fp)
 20111b4:	10801c17 	ldw	r2,112(r2)
 20111b8:	10c00044 	addi	r3,r2,1
 20111bc:	e0bffa17 	ldw	r2,-24(fp)
 20111c0:	10c01c15 	stw	r3,112(r2)
					break;
 20111c4:	00001006 	br	2011208 <xTaskGenericNotify+0x11c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 20111c8:	e0bffa17 	ldw	r2,-24(fp)
 20111cc:	e0fffd17 	ldw	r3,-12(fp)
 20111d0:	10c01c15 	stw	r3,112(r2)
					break;
 20111d4:	00000c06 	br	2011208 <xTaskGenericNotify+0x11c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 20111d8:	e0bffb03 	ldbu	r2,-20(fp)
 20111dc:	108000a0 	cmpeqi	r2,r2,2
 20111e0:	1000041e 	bne	r2,zero,20111f4 <xTaskGenericNotify+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
 20111e4:	e0bffa17 	ldw	r2,-24(fp)
 20111e8:	e0fffd17 	ldw	r3,-12(fp)
 20111ec:	10c01c15 	stw	r3,112(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 20111f0:	00000506 	br	2011208 <xTaskGenericNotify+0x11c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 20111f4:	e03ff915 	stw	zero,-28(fp)
					}
					break;
 20111f8:	00000306 	br	2011208 <xTaskGenericNotify+0x11c>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
 20111fc:	0001883a 	nop
 2011200:	00000106 	br	2011208 <xTaskGenericNotify+0x11c>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
 2011204:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 2011208:	e0bffb03 	ldbu	r2,-20(fp)
 201120c:	10800058 	cmpnei	r2,r2,1
 2011210:	10001c1e 	bne	r2,zero,2011284 <xTaskGenericNotify+0x198>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2011214:	e0bffa17 	ldw	r2,-24(fp)
 2011218:	10800104 	addi	r2,r2,4
 201121c:	1009883a 	mov	r4,r2
 2011220:	202d99c0 	call	202d99c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 2011224:	e0bffa17 	ldw	r2,-24(fp)
 2011228:	10800b17 	ldw	r2,44(r2)
 201122c:	d0e7af17 	ldw	r3,-24900(gp)
 2011230:	1880032e 	bgeu	r3,r2,2011240 <xTaskGenericNotify+0x154>
 2011234:	e0bffa17 	ldw	r2,-24(fp)
 2011238:	10800b17 	ldw	r2,44(r2)
 201123c:	d0a7af15 	stw	r2,-24900(gp)
 2011240:	e0bffa17 	ldw	r2,-24(fp)
 2011244:	10800b17 	ldw	r2,44(r2)
 2011248:	10c00524 	muli	r3,r2,20
 201124c:	00808174 	movhi	r2,517
 2011250:	10b34d04 	addi	r2,r2,-13004
 2011254:	1887883a 	add	r3,r3,r2
 2011258:	e0bffa17 	ldw	r2,-24(fp)
 201125c:	10800104 	addi	r2,r2,4
 2011260:	100b883a 	mov	r5,r2
 2011264:	1809883a 	mov	r4,r3
 2011268:	202d8380 	call	202d838 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 201126c:	e0bffa17 	ldw	r2,-24(fp)
 2011270:	10800b17 	ldw	r2,44(r2)
 2011274:	d0e7a917 	ldw	r3,-24924(gp)
 2011278:	18c00b17 	ldw	r3,44(r3)
 201127c:	1880012e 	bgeu	r3,r2,2011284 <xTaskGenericNotify+0x198>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 2011280:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 2011284:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011288:	10000126 	beq	r2,zero,2011290 <xTaskGenericNotify+0x1a4>
 201128c:	2010e300 	call	2010e30 <vTaskExitCritical>

		return xReturn;
 2011290:	e0bff917 	ldw	r2,-28(fp)
	}
 2011294:	e037883a 	mov	sp,fp
 2011298:	dfc00117 	ldw	ra,4(sp)
 201129c:	df000017 	ldw	fp,0(sp)
 20112a0:	dec00204 	addi	sp,sp,8
 20112a4:	f800283a 	ret

020112a8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 20112a8:	defff604 	addi	sp,sp,-40
 20112ac:	dfc00915 	stw	ra,36(sp)
 20112b0:	df000815 	stw	fp,32(sp)
 20112b4:	df000804 	addi	fp,sp,32
 20112b8:	e13ffc15 	stw	r4,-16(fp)
 20112bc:	e17ffd15 	stw	r5,-12(fp)
 20112c0:	e1bffe15 	stw	r6,-8(fp)
 20112c4:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
 20112c8:	00800044 	movi	r2,1
 20112cc:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 20112d0:	e0bffc17 	ldw	r2,-16(fp)
 20112d4:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 20112d8:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
 20112dc:	e0bfff17 	ldw	r2,-4(fp)
 20112e0:	10000426 	beq	r2,zero,20112f4 <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 20112e4:	e0bff917 	ldw	r2,-28(fp)
 20112e8:	10c01c17 	ldw	r3,112(r2)
 20112ec:	e0bfff17 	ldw	r2,-4(fp)
 20112f0:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 20112f4:	e0bff917 	ldw	r2,-28(fp)
 20112f8:	10801d03 	ldbu	r2,116(r2)
 20112fc:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 2011300:	e0bff917 	ldw	r2,-28(fp)
 2011304:	00c00084 	movi	r3,2
 2011308:	10c01d05 	stb	r3,116(r2)

			switch( eAction )
 201130c:	e0bffe17 	ldw	r2,-8(fp)
 2011310:	10800168 	cmpgeui	r2,r2,5
 2011314:	1000261e 	bne	r2,zero,20113b0 <xTaskGenericNotifyFromISR+0x108>
 2011318:	e0bffe17 	ldw	r2,-8(fp)
 201131c:	100690ba 	slli	r3,r2,2
 2011320:	00808074 	movhi	r2,513
 2011324:	1084cd04 	addi	r2,r2,4916
 2011328:	1885883a 	add	r2,r3,r2
 201132c:	10800017 	ldw	r2,0(r2)
 2011330:	1000683a 	jmp	r2
 2011334:	020113b8 	rdprs	r8,zero,1102
 2011338:	02011348 	cmpgei	r8,zero,1101
 201133c:	02011364 	muli	r8,zero,1101
 2011340:	0201137c 	xorhi	r8,zero,1101
 2011344:	0201138c 	andi	r8,zero,1102
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 2011348:	e0bff917 	ldw	r2,-28(fp)
 201134c:	10c01c17 	ldw	r3,112(r2)
 2011350:	e0bffd17 	ldw	r2,-12(fp)
 2011354:	1886b03a 	or	r3,r3,r2
 2011358:	e0bff917 	ldw	r2,-28(fp)
 201135c:	10c01c15 	stw	r3,112(r2)
					break;
 2011360:	00001606 	br	20113bc <xTaskGenericNotifyFromISR+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 2011364:	e0bff917 	ldw	r2,-28(fp)
 2011368:	10801c17 	ldw	r2,112(r2)
 201136c:	10c00044 	addi	r3,r2,1
 2011370:	e0bff917 	ldw	r2,-28(fp)
 2011374:	10c01c15 	stw	r3,112(r2)
					break;
 2011378:	00001006 	br	20113bc <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 201137c:	e0bff917 	ldw	r2,-28(fp)
 2011380:	e0fffd17 	ldw	r3,-12(fp)
 2011384:	10c01c15 	stw	r3,112(r2)
					break;
 2011388:	00000c06 	br	20113bc <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 201138c:	e0bffb03 	ldbu	r2,-20(fp)
 2011390:	108000a0 	cmpeqi	r2,r2,2
 2011394:	1000041e 	bne	r2,zero,20113a8 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 2011398:	e0bff917 	ldw	r2,-28(fp)
 201139c:	e0fffd17 	ldw	r3,-12(fp)
 20113a0:	10c01c15 	stw	r3,112(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 20113a4:	00000506 	br	20113bc <xTaskGenericNotifyFromISR+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 20113a8:	e03ff815 	stw	zero,-32(fp)
					}
					break;
 20113ac:	00000306 	br	20113bc <xTaskGenericNotifyFromISR+0x114>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
 20113b0:	0001883a 	nop
 20113b4:	00000106 	br	20113bc <xTaskGenericNotifyFromISR+0x114>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
 20113b8:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 20113bc:	e0bffb03 	ldbu	r2,-20(fp)
 20113c0:	10800058 	cmpnei	r2,r2,1
 20113c4:	10002b1e 	bne	r2,zero,2011474 <xTaskGenericNotifyFromISR+0x1cc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 20113c8:	d0a7b717 	ldw	r2,-24868(gp)
 20113cc:	1000171e 	bne	r2,zero,201142c <xTaskGenericNotifyFromISR+0x184>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 20113d0:	e0bff917 	ldw	r2,-28(fp)
 20113d4:	10800104 	addi	r2,r2,4
 20113d8:	1009883a 	mov	r4,r2
 20113dc:	202d99c0 	call	202d99c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 20113e0:	e0bff917 	ldw	r2,-28(fp)
 20113e4:	10800b17 	ldw	r2,44(r2)
 20113e8:	d0e7af17 	ldw	r3,-24900(gp)
 20113ec:	1880032e 	bgeu	r3,r2,20113fc <xTaskGenericNotifyFromISR+0x154>
 20113f0:	e0bff917 	ldw	r2,-28(fp)
 20113f4:	10800b17 	ldw	r2,44(r2)
 20113f8:	d0a7af15 	stw	r2,-24900(gp)
 20113fc:	e0bff917 	ldw	r2,-28(fp)
 2011400:	10800b17 	ldw	r2,44(r2)
 2011404:	10c00524 	muli	r3,r2,20
 2011408:	00808174 	movhi	r2,517
 201140c:	10b34d04 	addi	r2,r2,-13004
 2011410:	1887883a 	add	r3,r3,r2
 2011414:	e0bff917 	ldw	r2,-28(fp)
 2011418:	10800104 	addi	r2,r2,4
 201141c:	100b883a 	mov	r5,r2
 2011420:	1809883a 	mov	r4,r3
 2011424:	202d8380 	call	202d838 <vListInsertEnd>
 2011428:	00000606 	br	2011444 <xTaskGenericNotifyFromISR+0x19c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 201142c:	e0bff917 	ldw	r2,-28(fp)
 2011430:	10800604 	addi	r2,r2,24
 2011434:	100b883a 	mov	r5,r2
 2011438:	01008174 	movhi	r4,517
 201143c:	21337004 	addi	r4,r4,-12864
 2011440:	202d8380 	call	202d838 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 2011444:	e0bff917 	ldw	r2,-28(fp)
 2011448:	10800b17 	ldw	r2,44(r2)
 201144c:	d0e7a917 	ldw	r3,-24924(gp)
 2011450:	18c00b17 	ldw	r3,44(r3)
 2011454:	1880072e 	bgeu	r3,r2,2011474 <xTaskGenericNotifyFromISR+0x1cc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 2011458:	e0800217 	ldw	r2,8(fp)
 201145c:	10000326 	beq	r2,zero,201146c <xTaskGenericNotifyFromISR+0x1c4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 2011460:	e0800217 	ldw	r2,8(fp)
 2011464:	00c00044 	movi	r3,1
 2011468:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 201146c:	00800044 	movi	r2,1
 2011470:	d0a7b215 	stw	r2,-24888(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
 2011474:	e0bff817 	ldw	r2,-32(fp)
	}
 2011478:	e037883a 	mov	sp,fp
 201147c:	dfc00117 	ldw	ra,4(sp)
 2011480:	df000017 	ldw	fp,0(sp)
 2011484:	dec00204 	addi	sp,sp,8
 2011488:	f800283a 	ret

0201148c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 201148c:	defff904 	addi	sp,sp,-28
 2011490:	dfc00615 	stw	ra,24(sp)
 2011494:	df000515 	stw	fp,20(sp)
 2011498:	df000504 	addi	fp,sp,20
 201149c:	e13ffe15 	stw	r4,-8(fp)
 20114a0:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 20114a4:	e0bffe17 	ldw	r2,-8(fp)
 20114a8:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 20114ac:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 20114b0:	e0bffb17 	ldw	r2,-20(fp)
 20114b4:	10801d03 	ldbu	r2,116(r2)
 20114b8:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 20114bc:	e0bffb17 	ldw	r2,-20(fp)
 20114c0:	00c00084 	movi	r3,2
 20114c4:	10c01d05 	stb	r3,116(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 20114c8:	e0bffb17 	ldw	r2,-20(fp)
 20114cc:	10801c17 	ldw	r2,112(r2)
 20114d0:	10c00044 	addi	r3,r2,1
 20114d4:	e0bffb17 	ldw	r2,-20(fp)
 20114d8:	10c01c15 	stw	r3,112(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 20114dc:	e0bffd03 	ldbu	r2,-12(fp)
 20114e0:	10800058 	cmpnei	r2,r2,1
 20114e4:	10002b1e 	bne	r2,zero,2011594 <vTaskNotifyGiveFromISR+0x108>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 20114e8:	d0a7b717 	ldw	r2,-24868(gp)
 20114ec:	1000171e 	bne	r2,zero,201154c <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 20114f0:	e0bffb17 	ldw	r2,-20(fp)
 20114f4:	10800104 	addi	r2,r2,4
 20114f8:	1009883a 	mov	r4,r2
 20114fc:	202d99c0 	call	202d99c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 2011500:	e0bffb17 	ldw	r2,-20(fp)
 2011504:	10800b17 	ldw	r2,44(r2)
 2011508:	d0e7af17 	ldw	r3,-24900(gp)
 201150c:	1880032e 	bgeu	r3,r2,201151c <vTaskNotifyGiveFromISR+0x90>
 2011510:	e0bffb17 	ldw	r2,-20(fp)
 2011514:	10800b17 	ldw	r2,44(r2)
 2011518:	d0a7af15 	stw	r2,-24900(gp)
 201151c:	e0bffb17 	ldw	r2,-20(fp)
 2011520:	10800b17 	ldw	r2,44(r2)
 2011524:	10c00524 	muli	r3,r2,20
 2011528:	00808174 	movhi	r2,517
 201152c:	10b34d04 	addi	r2,r2,-13004
 2011530:	1887883a 	add	r3,r3,r2
 2011534:	e0bffb17 	ldw	r2,-20(fp)
 2011538:	10800104 	addi	r2,r2,4
 201153c:	100b883a 	mov	r5,r2
 2011540:	1809883a 	mov	r4,r3
 2011544:	202d8380 	call	202d838 <vListInsertEnd>
 2011548:	00000606 	br	2011564 <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 201154c:	e0bffb17 	ldw	r2,-20(fp)
 2011550:	10800604 	addi	r2,r2,24
 2011554:	100b883a 	mov	r5,r2
 2011558:	01008174 	movhi	r4,517
 201155c:	21337004 	addi	r4,r4,-12864
 2011560:	202d8380 	call	202d838 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 2011564:	e0bffb17 	ldw	r2,-20(fp)
 2011568:	10800b17 	ldw	r2,44(r2)
 201156c:	d0e7a917 	ldw	r3,-24924(gp)
 2011570:	18c00b17 	ldw	r3,44(r3)
 2011574:	1880072e 	bgeu	r3,r2,2011594 <vTaskNotifyGiveFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 2011578:	e0bfff17 	ldw	r2,-4(fp)
 201157c:	10000326 	beq	r2,zero,201158c <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 2011580:	e0bfff17 	ldw	r2,-4(fp)
 2011584:	00c00044 	movi	r3,1
 2011588:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 201158c:	00800044 	movi	r2,1
 2011590:	d0a7b215 	stw	r2,-24888(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 2011594:	0001883a 	nop
 2011598:	e037883a 	mov	sp,fp
 201159c:	dfc00117 	ldw	ra,4(sp)
 20115a0:	df000017 	ldw	fp,0(sp)
 20115a4:	dec00204 	addi	sp,sp,8
 20115a8:	f800283a 	ret

020115ac <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
 20115ac:	defffb04 	addi	sp,sp,-20
 20115b0:	dfc00415 	stw	ra,16(sp)
 20115b4:	df000315 	stw	fp,12(sp)
 20115b8:	df000304 	addi	fp,sp,12
 20115bc:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 20115c0:	e0bfff17 	ldw	r2,-4(fp)
 20115c4:	1000021e 	bne	r2,zero,20115d0 <xTaskNotifyStateClear+0x24>
 20115c8:	d0a7a917 	ldw	r2,-24924(gp)
 20115cc:	00000106 	br	20115d4 <xTaskNotifyStateClear+0x28>
 20115d0:	e0bfff17 	ldw	r2,-4(fp)
 20115d4:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
 20115d8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20115dc:	10000126 	beq	r2,zero,20115e4 <xTaskNotifyStateClear+0x38>
 20115e0:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 20115e4:	e0bffe17 	ldw	r2,-8(fp)
 20115e8:	10801d03 	ldbu	r2,116(r2)
 20115ec:	10803fcc 	andi	r2,r2,255
 20115f0:	10800098 	cmpnei	r2,r2,2
 20115f4:	1000051e 	bne	r2,zero,201160c <xTaskNotifyStateClear+0x60>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 20115f8:	e0bffe17 	ldw	r2,-8(fp)
 20115fc:	10001d05 	stb	zero,116(r2)
				xReturn = pdPASS;
 2011600:	00800044 	movi	r2,1
 2011604:	e0bffd15 	stw	r2,-12(fp)
 2011608:	00000106 	br	2011610 <xTaskNotifyStateClear+0x64>
			}
			else
			{
				xReturn = pdFAIL;
 201160c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
 2011610:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011614:	10000126 	beq	r2,zero,201161c <xTaskNotifyStateClear+0x70>
 2011618:	2010e300 	call	2010e30 <vTaskExitCritical>

		return xReturn;
 201161c:	e0bffd17 	ldw	r2,-12(fp)
	}
 2011620:	e037883a 	mov	sp,fp
 2011624:	dfc00117 	ldw	ra,4(sp)
 2011628:	df000017 	ldw	fp,0(sp)
 201162c:	dec00204 	addi	sp,sp,8
 2011630:	f800283a 	ret

02011634 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
 2011634:	defffa04 	addi	sp,sp,-24
 2011638:	dfc00515 	stw	ra,20(sp)
 201163c:	df000415 	stw	fp,16(sp)
 2011640:	df000404 	addi	fp,sp,16
 2011644:	e13ffe15 	stw	r4,-8(fp)
 2011648:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 201164c:	e0bffe17 	ldw	r2,-8(fp)
 2011650:	1000021e 	bne	r2,zero,201165c <ulTaskNotifyValueClear+0x28>
 2011654:	d0a7a917 	ldw	r2,-24924(gp)
 2011658:	00000106 	br	2011660 <ulTaskNotifyValueClear+0x2c>
 201165c:	e0bffe17 	ldw	r2,-8(fp)
 2011660:	e0bffc15 	stw	r2,-16(fp)

		taskENTER_CRITICAL();
 2011664:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011668:	10000126 	beq	r2,zero,2011670 <ulTaskNotifyValueClear+0x3c>
 201166c:	2010de80 	call	2010de8 <vTaskEnterCritical>
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 2011670:	d0a7a917 	ldw	r2,-24924(gp)
 2011674:	10801c17 	ldw	r2,112(r2)
 2011678:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 201167c:	e0bffc17 	ldw	r2,-16(fp)
 2011680:	10c01c17 	ldw	r3,112(r2)
 2011684:	e0bfff17 	ldw	r2,-4(fp)
 2011688:	0084303a 	nor	r2,zero,r2
 201168c:	1886703a 	and	r3,r3,r2
 2011690:	e0bffc17 	ldw	r2,-16(fp)
 2011694:	10c01c15 	stw	r3,112(r2)
		}
		taskEXIT_CRITICAL();
 2011698:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 201169c:	10000126 	beq	r2,zero,20116a4 <ulTaskNotifyValueClear+0x70>
 20116a0:	2010e300 	call	2010e30 <vTaskExitCritical>

		return ulReturn;
 20116a4:	e0bffd17 	ldw	r2,-12(fp)
	}
 20116a8:	e037883a 	mov	sp,fp
 20116ac:	dfc00117 	ldw	ra,4(sp)
 20116b0:	df000017 	ldw	fp,0(sp)
 20116b4:	dec00204 	addi	sp,sp,8
 20116b8:	f800283a 	ret

020116bc <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 20116bc:	defffa04 	addi	sp,sp,-24
 20116c0:	dfc00515 	stw	ra,20(sp)
 20116c4:	df000415 	stw	fp,16(sp)
 20116c8:	df000404 	addi	fp,sp,16
 20116cc:	e13ffe15 	stw	r4,-8(fp)
 20116d0:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 20116d4:	d0a7ae17 	ldw	r2,-24904(gp)
 20116d8:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 20116dc:	d0a7a917 	ldw	r2,-24924(gp)
 20116e0:	10800104 	addi	r2,r2,4
 20116e4:	1009883a 	mov	r4,r2
 20116e8:	202d99c0 	call	202d99c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 20116ec:	e0bffe17 	ldw	r2,-8(fp)
 20116f0:	10bfffd8 	cmpnei	r2,r2,-1
 20116f4:	1000091e 	bne	r2,zero,201171c <prvAddCurrentTaskToDelayedList+0x60>
 20116f8:	e0bfff17 	ldw	r2,-4(fp)
 20116fc:	10000726 	beq	r2,zero,201171c <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 2011700:	d0a7a917 	ldw	r2,-24924(gp)
 2011704:	10800104 	addi	r2,r2,4
 2011708:	100b883a 	mov	r5,r2
 201170c:	01008174 	movhi	r4,517
 2011710:	21337a04 	addi	r4,r4,-12824
 2011714:	202d8380 	call	202d838 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 2011718:	00001c06 	br	201178c <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 201171c:	e0fffc17 	ldw	r3,-16(fp)
 2011720:	e0bffe17 	ldw	r2,-8(fp)
 2011724:	1885883a 	add	r2,r3,r2
 2011728:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 201172c:	d0a7a917 	ldw	r2,-24924(gp)
 2011730:	e0fffd17 	ldw	r3,-12(fp)
 2011734:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
 2011738:	e0fffd17 	ldw	r3,-12(fp)
 201173c:	e0bffc17 	ldw	r2,-16(fp)
 2011740:	1880072e 	bgeu	r3,r2,2011760 <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 2011744:	d0e7ab17 	ldw	r3,-24916(gp)
 2011748:	d0a7a917 	ldw	r2,-24924(gp)
 201174c:	10800104 	addi	r2,r2,4
 2011750:	100b883a 	mov	r5,r2
 2011754:	1809883a 	mov	r4,r3
 2011758:	202d8c40 	call	202d8c4 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 201175c:	00000b06 	br	201178c <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 2011760:	d0e7aa17 	ldw	r3,-24920(gp)
 2011764:	d0a7a917 	ldw	r2,-24924(gp)
 2011768:	10800104 	addi	r2,r2,4
 201176c:	100b883a 	mov	r5,r2
 2011770:	1809883a 	mov	r4,r3
 2011774:	202d8c40 	call	202d8c4 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 2011778:	d0a7b517 	ldw	r2,-24876(gp)
 201177c:	e0fffd17 	ldw	r3,-12(fp)
 2011780:	1880022e 	bgeu	r3,r2,201178c <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
 2011784:	e0bffd17 	ldw	r2,-12(fp)
 2011788:	d0a7b515 	stw	r2,-24876(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 201178c:	0001883a 	nop
 2011790:	e037883a 	mov	sp,fp
 2011794:	dfc00117 	ldw	ra,4(sp)
 2011798:	df000017 	ldw	fp,0(sp)
 201179c:	dec00204 	addi	sp,sp,8
 20117a0:	f800283a 	ret

020117a4 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 20117a4:	defffb04 	addi	sp,sp,-20
 20117a8:	dfc00415 	stw	ra,16(sp)
 20117ac:	df000315 	stw	fp,12(sp)
 20117b0:	df000304 	addi	fp,sp,12
BaseType_t xReturn = pdFAIL;
 20117b4:	e03fff15 	stw	zero,-4(fp)

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 20117b8:	201226c0 	call	201226c <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 20117bc:	d0a7ba17 	ldw	r2,-24856(gp)
 20117c0:	10000c26 	beq	r2,zero,20117f4 <xTimerCreateTimerTask+0x50>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
 20117c4:	d0a7bb04 	addi	r2,gp,-24852
 20117c8:	d8800115 	stw	r2,4(sp)
 20117cc:	00800144 	movi	r2,5
 20117d0:	d8800015 	stw	r2,0(sp)
 20117d4:	000f883a 	mov	r7,zero
 20117d8:	01840004 	movi	r6,4096
 20117dc:	01408134 	movhi	r5,516
 20117e0:	295b3304 	addi	r5,r5,27852
 20117e4:	01008074 	movhi	r4,513
 20117e8:	21072504 	addi	r4,r4,7316
 20117ec:	200ead40 	call	200ead4 <xTaskCreate>
 20117f0:	e0bfff15 	stw	r2,-4(fp)
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
 20117f4:	e0bfff17 	ldw	r2,-4(fp)
}
 20117f8:	e037883a 	mov	sp,fp
 20117fc:	dfc00117 	ldw	ra,4(sp)
 2011800:	df000017 	ldw	fp,0(sp)
 2011804:	dec00204 	addi	sp,sp,8
 2011808:	f800283a 	ret

0201180c <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
 201180c:	defff704 	addi	sp,sp,-36
 2011810:	dfc00815 	stw	ra,32(sp)
 2011814:	df000715 	stw	fp,28(sp)
 2011818:	df000704 	addi	fp,sp,28
 201181c:	e13ffc15 	stw	r4,-16(fp)
 2011820:	e17ffd15 	stw	r5,-12(fp)
 2011824:	e1bffe15 	stw	r6,-8(fp)
 2011828:	e1ffff15 	stw	r7,-4(fp)
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 201182c:	01000b04 	movi	r4,44
 2011830:	202d6700 	call	202d670 <pvPortMalloc>
 2011834:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewTimer != NULL )
 2011838:	e0bffb17 	ldw	r2,-20(fp)
 201183c:	10000b26 	beq	r2,zero,201186c <xTimerCreate+0x60>
		{
			/* Status is thus far zero as the timer is not created statically
			and has not been started.  The auto-reload bit may get set in
			prvInitialiseNewTimer. */
			pxNewTimer->ucStatus = 0x00;
 2011840:	e0bffb17 	ldw	r2,-20(fp)
 2011844:	10000a05 	stb	zero,40(r2)
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 2011848:	e0bffb17 	ldw	r2,-20(fp)
 201184c:	d8800115 	stw	r2,4(sp)
 2011850:	e0800217 	ldw	r2,8(fp)
 2011854:	d8800015 	stw	r2,0(sp)
 2011858:	e1ffff17 	ldw	r7,-4(fp)
 201185c:	e1bffe17 	ldw	r6,-8(fp)
 2011860:	e17ffd17 	ldw	r5,-12(fp)
 2011864:	e13ffc17 	ldw	r4,-16(fp)
 2011868:	20118840 	call	2011884 <prvInitialiseNewTimer>
		}

		return pxNewTimer;
 201186c:	e0bffb17 	ldw	r2,-20(fp)
	}
 2011870:	e037883a 	mov	sp,fp
 2011874:	dfc00117 	ldw	ra,4(sp)
 2011878:	df000017 	ldw	fp,0(sp)
 201187c:	dec00204 	addi	sp,sp,8
 2011880:	f800283a 	ret

02011884 <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
 2011884:	defffa04 	addi	sp,sp,-24
 2011888:	dfc00515 	stw	ra,20(sp)
 201188c:	df000415 	stw	fp,16(sp)
 2011890:	df000404 	addi	fp,sp,16
 2011894:	e13ffc15 	stw	r4,-16(fp)
 2011898:	e17ffd15 	stw	r5,-12(fp)
 201189c:	e1bffe15 	stw	r6,-8(fp)
 20118a0:	e1ffff15 	stw	r7,-4(fp)
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
 20118a4:	e0800317 	ldw	r2,12(fp)
 20118a8:	10001926 	beq	r2,zero,2011910 <prvInitialiseNewTimer+0x8c>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
 20118ac:	201226c0 	call	201226c <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
 20118b0:	e0800317 	ldw	r2,12(fp)
 20118b4:	e0fffc17 	ldw	r3,-16(fp)
 20118b8:	10c00015 	stw	r3,0(r2)
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 20118bc:	e0800317 	ldw	r2,12(fp)
 20118c0:	e0fffd17 	ldw	r3,-12(fp)
 20118c4:	10c00615 	stw	r3,24(r2)
		pxNewTimer->pvTimerID = pvTimerID;
 20118c8:	e0800317 	ldw	r2,12(fp)
 20118cc:	e0ffff17 	ldw	r3,-4(fp)
 20118d0:	10c00715 	stw	r3,28(r2)
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 20118d4:	e0800317 	ldw	r2,12(fp)
 20118d8:	e0c00217 	ldw	r3,8(fp)
 20118dc:	10c00815 	stw	r3,32(r2)
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 20118e0:	e0800317 	ldw	r2,12(fp)
 20118e4:	10800104 	addi	r2,r2,4
 20118e8:	1009883a 	mov	r4,r2
 20118ec:	202d80c0 	call	202d80c <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
 20118f0:	e0bffe17 	ldw	r2,-8(fp)
 20118f4:	10000626 	beq	r2,zero,2011910 <prvInitialiseNewTimer+0x8c>
		{
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 20118f8:	e0800317 	ldw	r2,12(fp)
 20118fc:	10800a03 	ldbu	r2,40(r2)
 2011900:	10800114 	ori	r2,r2,4
 2011904:	1007883a 	mov	r3,r2
 2011908:	e0800317 	ldw	r2,12(fp)
 201190c:	10c00a05 	stb	r3,40(r2)
		}
		traceTIMER_CREATE( pxNewTimer );
	}
}
 2011910:	0001883a 	nop
 2011914:	e037883a 	mov	sp,fp
 2011918:	dfc00117 	ldw	ra,4(sp)
 201191c:	df000017 	ldw	fp,0(sp)
 2011920:	dec00204 	addi	sp,sp,8
 2011924:	f800283a 	ret

02011928 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 2011928:	defff604 	addi	sp,sp,-40
 201192c:	dfc00915 	stw	ra,36(sp)
 2011930:	df000815 	stw	fp,32(sp)
 2011934:	df000804 	addi	fp,sp,32
 2011938:	e13ffc15 	stw	r4,-16(fp)
 201193c:	e17ffd15 	stw	r5,-12(fp)
 2011940:	e1bffe15 	stw	r6,-8(fp)
 2011944:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn = pdFAIL;
 2011948:	e03ff815 	stw	zero,-32(fp)

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 201194c:	d0a7ba17 	ldw	r2,-24856(gp)
 2011950:	10002626 	beq	r2,zero,20119ec <xTimerGenericCommand+0xc4>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 2011954:	e0bffd17 	ldw	r2,-12(fp)
 2011958:	e0bff915 	stw	r2,-28(fp)
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 201195c:	e0bffe17 	ldw	r2,-8(fp)
 2011960:	e0bffa15 	stw	r2,-24(fp)
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 2011964:	e0bffc17 	ldw	r2,-16(fp)
 2011968:	e0bffb15 	stw	r2,-20(fp)

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 201196c:	e0bffd17 	ldw	r2,-12(fp)
 2011970:	10800188 	cmpgei	r2,r2,6
 2011974:	1000151e 	bne	r2,zero,20119cc <xTimerGenericCommand+0xa4>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 2011978:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 201197c:	10800098 	cmpnei	r2,r2,2
 2011980:	1000091e 	bne	r2,zero,20119a8 <xTimerGenericCommand+0x80>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 2011984:	d0a7ba17 	ldw	r2,-24856(gp)
 2011988:	e0fff904 	addi	r3,fp,-28
 201198c:	000f883a 	mov	r7,zero
 2011990:	e1800217 	ldw	r6,8(fp)
 2011994:	180b883a 	mov	r5,r3
 2011998:	1009883a 	mov	r4,r2
 201199c:	200d8480 	call	200d848 <xQueueGenericSend>
 20119a0:	e0bff815 	stw	r2,-32(fp)
 20119a4:	00001106 	br	20119ec <xTimerGenericCommand+0xc4>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 20119a8:	d0a7ba17 	ldw	r2,-24856(gp)
 20119ac:	e0fff904 	addi	r3,fp,-28
 20119b0:	000f883a 	mov	r7,zero
 20119b4:	000d883a 	mov	r6,zero
 20119b8:	180b883a 	mov	r5,r3
 20119bc:	1009883a 	mov	r4,r2
 20119c0:	200d8480 	call	200d848 <xQueueGenericSend>
 20119c4:	e0bff815 	stw	r2,-32(fp)
 20119c8:	00000806 	br	20119ec <xTimerGenericCommand+0xc4>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 20119cc:	d0a7ba17 	ldw	r2,-24856(gp)
 20119d0:	e0fff904 	addi	r3,fp,-28
 20119d4:	000f883a 	mov	r7,zero
 20119d8:	e1bfff17 	ldw	r6,-4(fp)
 20119dc:	180b883a 	mov	r5,r3
 20119e0:	1009883a 	mov	r4,r2
 20119e4:	200da2c0 	call	200da2c <xQueueGenericSendFromISR>
 20119e8:	e0bff815 	stw	r2,-32(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 20119ec:	e0bff817 	ldw	r2,-32(fp)
}
 20119f0:	e037883a 	mov	sp,fp
 20119f4:	dfc00117 	ldw	ra,4(sp)
 20119f8:	df000017 	ldw	fp,0(sp)
 20119fc:	dec00204 	addi	sp,sp,8
 2011a00:	f800283a 	ret

02011a04 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
{
 2011a04:	deffff04 	addi	sp,sp,-4
 2011a08:	df000015 	stw	fp,0(sp)
 2011a0c:	d839883a 	mov	fp,sp
	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
	started, then xTimerTaskHandle will be NULL. */
	configASSERT( ( xTimerTaskHandle != NULL ) );
	return xTimerTaskHandle;
 2011a10:	d0a7bb17 	ldw	r2,-24852(gp)
}
 2011a14:	e037883a 	mov	sp,fp
 2011a18:	df000017 	ldw	fp,0(sp)
 2011a1c:	dec00104 	addi	sp,sp,4
 2011a20:	f800283a 	ret

02011a24 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
{
 2011a24:	defffd04 	addi	sp,sp,-12
 2011a28:	df000215 	stw	fp,8(sp)
 2011a2c:	df000204 	addi	fp,sp,8
 2011a30:	e13fff15 	stw	r4,-4(fp)
Timer_t *pxTimer = xTimer;
 2011a34:	e0bfff17 	ldw	r2,-4(fp)
 2011a38:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );
	return pxTimer->xTimerPeriodInTicks;
 2011a3c:	e0bffe17 	ldw	r2,-8(fp)
 2011a40:	10800617 	ldw	r2,24(r2)
}
 2011a44:	e037883a 	mov	sp,fp
 2011a48:	df000017 	ldw	fp,0(sp)
 2011a4c:	dec00104 	addi	sp,sp,4
 2011a50:	f800283a 	ret

02011a54 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
{
 2011a54:	defffb04 	addi	sp,sp,-20
 2011a58:	dfc00415 	stw	ra,16(sp)
 2011a5c:	df000315 	stw	fp,12(sp)
 2011a60:	df000304 	addi	fp,sp,12
 2011a64:	e13ffe15 	stw	r4,-8(fp)
 2011a68:	e17fff15 	stw	r5,-4(fp)
Timer_t * pxTimer =  xTimer;
 2011a6c:	e0bffe17 	ldw	r2,-8(fp)
 2011a70:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( xTimer );
	taskENTER_CRITICAL();
 2011a74:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011a78:	10000126 	beq	r2,zero,2011a80 <vTimerSetReloadMode+0x2c>
 2011a7c:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		if( uxAutoReload != pdFALSE )
 2011a80:	e0bfff17 	ldw	r2,-4(fp)
 2011a84:	10000726 	beq	r2,zero,2011aa4 <vTimerSetReloadMode+0x50>
		{
			pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 2011a88:	e0bffd17 	ldw	r2,-12(fp)
 2011a8c:	10800a03 	ldbu	r2,40(r2)
 2011a90:	10800114 	ori	r2,r2,4
 2011a94:	1007883a 	mov	r3,r2
 2011a98:	e0bffd17 	ldw	r2,-12(fp)
 2011a9c:	10c00a05 	stb	r3,40(r2)
 2011aa0:	00000706 	br	2011ac0 <vTimerSetReloadMode+0x6c>
		}
		else
		{
			pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
 2011aa4:	e0bffd17 	ldw	r2,-12(fp)
 2011aa8:	10c00a03 	ldbu	r3,40(r2)
 2011aac:	00bffec4 	movi	r2,-5
 2011ab0:	1884703a 	and	r2,r3,r2
 2011ab4:	1007883a 	mov	r3,r2
 2011ab8:	e0bffd17 	ldw	r2,-12(fp)
 2011abc:	10c00a05 	stb	r3,40(r2)
		}
	}
	taskEXIT_CRITICAL();
 2011ac0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011ac4:	10000126 	beq	r2,zero,2011acc <vTimerSetReloadMode+0x78>
 2011ac8:	2010e300 	call	2010e30 <vTaskExitCritical>
}
 2011acc:	0001883a 	nop
 2011ad0:	e037883a 	mov	sp,fp
 2011ad4:	dfc00117 	ldw	ra,4(sp)
 2011ad8:	df000017 	ldw	fp,0(sp)
 2011adc:	dec00204 	addi	sp,sp,8
 2011ae0:	f800283a 	ret

02011ae4 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
{
 2011ae4:	defffb04 	addi	sp,sp,-20
 2011ae8:	dfc00415 	stw	ra,16(sp)
 2011aec:	df000315 	stw	fp,12(sp)
 2011af0:	df000304 	addi	fp,sp,12
 2011af4:	e13fff15 	stw	r4,-4(fp)
Timer_t * pxTimer =  xTimer;
 2011af8:	e0bfff17 	ldw	r2,-4(fp)
 2011afc:	e0bffe15 	stw	r2,-8(fp)
UBaseType_t uxReturn;

	configASSERT( xTimer );
	taskENTER_CRITICAL();
 2011b00:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011b04:	10000126 	beq	r2,zero,2011b0c <uxTimerGetReloadMode+0x28>
 2011b08:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
 2011b0c:	e0bffe17 	ldw	r2,-8(fp)
 2011b10:	10800a03 	ldbu	r2,40(r2)
 2011b14:	10803fcc 	andi	r2,r2,255
 2011b18:	1080010c 	andi	r2,r2,4
 2011b1c:	1000021e 	bne	r2,zero,2011b28 <uxTimerGetReloadMode+0x44>
		{
			/* Not an auto-reload timer. */
			uxReturn = ( UBaseType_t ) pdFALSE;
 2011b20:	e03ffd15 	stw	zero,-12(fp)
 2011b24:	00000206 	br	2011b30 <uxTimerGetReloadMode+0x4c>
		}
		else
		{
			/* Is an auto-reload timer. */
			uxReturn = ( UBaseType_t ) pdTRUE;
 2011b28:	00800044 	movi	r2,1
 2011b2c:	e0bffd15 	stw	r2,-12(fp)
		}
	}
	taskEXIT_CRITICAL();
 2011b30:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2011b34:	10000126 	beq	r2,zero,2011b3c <uxTimerGetReloadMode+0x58>
 2011b38:	2010e300 	call	2010e30 <vTaskExitCritical>

	return uxReturn;
 2011b3c:	e0bffd17 	ldw	r2,-12(fp)
}
 2011b40:	e037883a 	mov	sp,fp
 2011b44:	dfc00117 	ldw	ra,4(sp)
 2011b48:	df000017 	ldw	fp,0(sp)
 2011b4c:	dec00204 	addi	sp,sp,8
 2011b50:	f800283a 	ret

02011b54 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
{
 2011b54:	defffc04 	addi	sp,sp,-16
 2011b58:	df000315 	stw	fp,12(sp)
 2011b5c:	df000304 	addi	fp,sp,12
 2011b60:	e13fff15 	stw	r4,-4(fp)
Timer_t * pxTimer =  xTimer;
 2011b64:	e0bfff17 	ldw	r2,-4(fp)
 2011b68:	e0bffd15 	stw	r2,-12(fp)
TickType_t xReturn;

	configASSERT( xTimer );
	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 2011b6c:	e0bffd17 	ldw	r2,-12(fp)
 2011b70:	10800117 	ldw	r2,4(r2)
 2011b74:	e0bffe15 	stw	r2,-8(fp)
	return xReturn;
 2011b78:	e0bffe17 	ldw	r2,-8(fp)
}
 2011b7c:	e037883a 	mov	sp,fp
 2011b80:	df000017 	ldw	fp,0(sp)
 2011b84:	dec00104 	addi	sp,sp,4
 2011b88:	f800283a 	ret

02011b8c <pcTimerGetName>:
/*-----------------------------------------------------------*/

const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 2011b8c:	defffd04 	addi	sp,sp,-12
 2011b90:	df000215 	stw	fp,8(sp)
 2011b94:	df000204 	addi	fp,sp,8
 2011b98:	e13fff15 	stw	r4,-4(fp)
Timer_t *pxTimer = xTimer;
 2011b9c:	e0bfff17 	ldw	r2,-4(fp)
 2011ba0:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );
	return pxTimer->pcTimerName;
 2011ba4:	e0bffe17 	ldw	r2,-8(fp)
 2011ba8:	10800017 	ldw	r2,0(r2)
}
 2011bac:	e037883a 	mov	sp,fp
 2011bb0:	df000017 	ldw	fp,0(sp)
 2011bb4:	dec00104 	addi	sp,sp,4
 2011bb8:	f800283a 	ret

02011bbc <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 2011bbc:	defff904 	addi	sp,sp,-28
 2011bc0:	dfc00615 	stw	ra,24(sp)
 2011bc4:	df000515 	stw	fp,20(sp)
 2011bc8:	df000504 	addi	fp,sp,20
 2011bcc:	e13ffe15 	stw	r4,-8(fp)
 2011bd0:	e17fff15 	stw	r5,-4(fp)
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 2011bd4:	d0a7b817 	ldw	r2,-24864(gp)
 2011bd8:	10800317 	ldw	r2,12(r2)
 2011bdc:	10800317 	ldw	r2,12(r2)
 2011be0:	e0bffc15 	stw	r2,-16(fp)

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 2011be4:	e0bffc17 	ldw	r2,-16(fp)
 2011be8:	10800104 	addi	r2,r2,4
 2011bec:	1009883a 	mov	r4,r2
 2011bf0:	202d99c0 	call	202d99c <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 2011bf4:	e0bffc17 	ldw	r2,-16(fp)
 2011bf8:	10800a03 	ldbu	r2,40(r2)
 2011bfc:	10803fcc 	andi	r2,r2,255
 2011c00:	1080010c 	andi	r2,r2,4
 2011c04:	10001226 	beq	r2,zero,2011c50 <prvProcessExpiredTimer+0x94>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 2011c08:	e0bffc17 	ldw	r2,-16(fp)
 2011c0c:	10c00617 	ldw	r3,24(r2)
 2011c10:	e0bffe17 	ldw	r2,-8(fp)
 2011c14:	1885883a 	add	r2,r3,r2
 2011c18:	e1fffe17 	ldw	r7,-8(fp)
 2011c1c:	e1bfff17 	ldw	r6,-4(fp)
 2011c20:	100b883a 	mov	r5,r2
 2011c24:	e13ffc17 	ldw	r4,-16(fp)
 2011c28:	2011e640 	call	2011e64 <prvInsertTimerInActiveList>
 2011c2c:	10000f26 	beq	r2,zero,2011c6c <prvProcessExpiredTimer+0xb0>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 2011c30:	d8000015 	stw	zero,0(sp)
 2011c34:	000f883a 	mov	r7,zero
 2011c38:	e1bffe17 	ldw	r6,-8(fp)
 2011c3c:	000b883a 	mov	r5,zero
 2011c40:	e13ffc17 	ldw	r4,-16(fp)
 2011c44:	20119280 	call	2011928 <xTimerGenericCommand>
 2011c48:	e0bffd15 	stw	r2,-12(fp)
 2011c4c:	00000706 	br	2011c6c <prvProcessExpiredTimer+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 2011c50:	e0bffc17 	ldw	r2,-16(fp)
 2011c54:	10c00a03 	ldbu	r3,40(r2)
 2011c58:	00bfff84 	movi	r2,-2
 2011c5c:	1884703a 	and	r2,r3,r2
 2011c60:	1007883a 	mov	r3,r2
 2011c64:	e0bffc17 	ldw	r2,-16(fp)
 2011c68:	10c00a05 	stb	r3,40(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 2011c6c:	e0bffc17 	ldw	r2,-16(fp)
 2011c70:	10800817 	ldw	r2,32(r2)
 2011c74:	e13ffc17 	ldw	r4,-16(fp)
 2011c78:	103ee83a 	callr	r2
}
 2011c7c:	0001883a 	nop
 2011c80:	e037883a 	mov	sp,fp
 2011c84:	dfc00117 	ldw	ra,4(sp)
 2011c88:	df000017 	ldw	fp,0(sp)
 2011c8c:	dec00204 	addi	sp,sp,8
 2011c90:	f800283a 	ret

02011c94 <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
 2011c94:	defffb04 	addi	sp,sp,-20
 2011c98:	dfc00415 	stw	ra,16(sp)
 2011c9c:	df000315 	stw	fp,12(sp)
 2011ca0:	df000304 	addi	fp,sp,12
 2011ca4:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 2011ca8:	e0bffe04 	addi	r2,fp,-8
 2011cac:	1009883a 	mov	r4,r2
 2011cb0:	2011d980 	call	2011d98 <prvGetNextExpireTime>
 2011cb4:	e0bffd15 	stw	r2,-12(fp)

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 2011cb8:	e0bffe17 	ldw	r2,-8(fp)
 2011cbc:	100b883a 	mov	r5,r2
 2011cc0:	e13ffd17 	ldw	r4,-12(fp)
 2011cc4:	2011cd00 	call	2011cd0 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 2011cc8:	2011f400 	call	2011f40 <prvProcessReceivedCommands>
	}
 2011ccc:	003ff606 	br	2011ca8 <__alt_mem_mem_0+0xfcff1ca8>

02011cd0 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 2011cd0:	defffa04 	addi	sp,sp,-24
 2011cd4:	dfc00515 	stw	ra,20(sp)
 2011cd8:	df000415 	stw	fp,16(sp)
 2011cdc:	df000404 	addi	fp,sp,16
 2011ce0:	e13ffe15 	stw	r4,-8(fp)
 2011ce4:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 2011ce8:	200f8840 	call	200f884 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 2011cec:	e0bffd04 	addi	r2,fp,-12
 2011cf0:	1009883a 	mov	r4,r2
 2011cf4:	2011e000 	call	2011e00 <prvSampleTimeNow>
 2011cf8:	e0bffc15 	stw	r2,-16(fp)
		if( xTimerListsWereSwitched == pdFALSE )
 2011cfc:	e0bffd17 	ldw	r2,-12(fp)
 2011d00:	10001e1e 	bne	r2,zero,2011d7c <prvProcessTimerOrBlockTask+0xac>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 2011d04:	e0bfff17 	ldw	r2,-4(fp)
 2011d08:	1000081e 	bne	r2,zero,2011d2c <prvProcessTimerOrBlockTask+0x5c>
 2011d0c:	e0bffe17 	ldw	r2,-8(fp)
 2011d10:	e0fffc17 	ldw	r3,-16(fp)
 2011d14:	18800536 	bltu	r3,r2,2011d2c <prvProcessTimerOrBlockTask+0x5c>
			{
				( void ) xTaskResumeAll();
 2011d18:	200f8b00 	call	200f8b0 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 2011d1c:	e17ffc17 	ldw	r5,-16(fp)
 2011d20:	e13ffe17 	ldw	r4,-8(fp)
 2011d24:	2011bbc0 	call	2011bbc <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 2011d28:	00001506 	br	2011d80 <prvProcessTimerOrBlockTask+0xb0>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
 2011d2c:	e0bfff17 	ldw	r2,-4(fp)
 2011d30:	10000726 	beq	r2,zero,2011d50 <prvProcessTimerOrBlockTask+0x80>
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 2011d34:	d0a7b917 	ldw	r2,-24860(gp)
 2011d38:	10800017 	ldw	r2,0(r2)
 2011d3c:	1000021e 	bne	r2,zero,2011d48 <prvProcessTimerOrBlockTask+0x78>
 2011d40:	00800044 	movi	r2,1
 2011d44:	00000106 	br	2011d4c <prvProcessTimerOrBlockTask+0x7c>
 2011d48:	0005883a 	mov	r2,zero
 2011d4c:	e0bfff15 	stw	r2,-4(fp)
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 2011d50:	d127ba17 	ldw	r4,-24856(gp)
 2011d54:	e0fffe17 	ldw	r3,-8(fp)
 2011d58:	e0bffc17 	ldw	r2,-16(fp)
 2011d5c:	1885c83a 	sub	r2,r3,r2
 2011d60:	e1bfff17 	ldw	r6,-4(fp)
 2011d64:	100b883a 	mov	r5,r2
 2011d68:	200ea0c0 	call	200ea0c <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 2011d6c:	200f8b00 	call	200f8b0 <xTaskResumeAll>
 2011d70:	1000031e 	bne	r2,zero,2011d80 <prvProcessTimerOrBlockTask+0xb0>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
 2011d74:	003b683a 	trap	0
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 2011d78:	00000106 	br	2011d80 <prvProcessTimerOrBlockTask+0xb0>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
 2011d7c:	200f8b00 	call	200f8b0 <xTaskResumeAll>
		}
	}
}
 2011d80:	0001883a 	nop
 2011d84:	e037883a 	mov	sp,fp
 2011d88:	dfc00117 	ldw	ra,4(sp)
 2011d8c:	df000017 	ldw	fp,0(sp)
 2011d90:	dec00204 	addi	sp,sp,8
 2011d94:	f800283a 	ret

02011d98 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 2011d98:	defffd04 	addi	sp,sp,-12
 2011d9c:	df000215 	stw	fp,8(sp)
 2011da0:	df000204 	addi	fp,sp,8
 2011da4:	e13fff15 	stw	r4,-4(fp)
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 2011da8:	d0a7b817 	ldw	r2,-24864(gp)
 2011dac:	10800017 	ldw	r2,0(r2)
 2011db0:	1000021e 	bne	r2,zero,2011dbc <prvGetNextExpireTime+0x24>
 2011db4:	00800044 	movi	r2,1
 2011db8:	00000106 	br	2011dc0 <prvGetNextExpireTime+0x28>
 2011dbc:	0005883a 	mov	r2,zero
 2011dc0:	e0ffff17 	ldw	r3,-4(fp)
 2011dc4:	18800015 	stw	r2,0(r3)
	if( *pxListWasEmpty == pdFALSE )
 2011dc8:	e0bfff17 	ldw	r2,-4(fp)
 2011dcc:	10800017 	ldw	r2,0(r2)
 2011dd0:	1000051e 	bne	r2,zero,2011de8 <prvGetNextExpireTime+0x50>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 2011dd4:	d0a7b817 	ldw	r2,-24864(gp)
 2011dd8:	10800317 	ldw	r2,12(r2)
 2011ddc:	10800017 	ldw	r2,0(r2)
 2011de0:	e0bffe15 	stw	r2,-8(fp)
 2011de4:	00000106 	br	2011dec <prvGetNextExpireTime+0x54>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 2011de8:	e03ffe15 	stw	zero,-8(fp)
	}

	return xNextExpireTime;
 2011dec:	e0bffe17 	ldw	r2,-8(fp)
}
 2011df0:	e037883a 	mov	sp,fp
 2011df4:	df000017 	ldw	fp,0(sp)
 2011df8:	dec00104 	addi	sp,sp,4
 2011dfc:	f800283a 	ret

02011e00 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 2011e00:	defffc04 	addi	sp,sp,-16
 2011e04:	dfc00315 	stw	ra,12(sp)
 2011e08:	df000215 	stw	fp,8(sp)
 2011e0c:	df000204 	addi	fp,sp,8
 2011e10:	e13fff15 	stw	r4,-4(fp)
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 2011e14:	200fa180 	call	200fa18 <xTaskGetTickCount>
 2011e18:	e0bffe15 	stw	r2,-8(fp)

	if( xTimeNow < xLastTime )
 2011e1c:	d0a7bc17 	ldw	r2,-24848(gp)
 2011e20:	e0fffe17 	ldw	r3,-8(fp)
 2011e24:	1880052e 	bgeu	r3,r2,2011e3c <prvSampleTimeNow+0x3c>
	{
		prvSwitchTimerLists();
 2011e28:	20121580 	call	2012158 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 2011e2c:	e0bfff17 	ldw	r2,-4(fp)
 2011e30:	00c00044 	movi	r3,1
 2011e34:	10c00015 	stw	r3,0(r2)
 2011e38:	00000206 	br	2011e44 <prvSampleTimeNow+0x44>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 2011e3c:	e0bfff17 	ldw	r2,-4(fp)
 2011e40:	10000015 	stw	zero,0(r2)
	}

	xLastTime = xTimeNow;
 2011e44:	e0bffe17 	ldw	r2,-8(fp)
 2011e48:	d0a7bc15 	stw	r2,-24848(gp)

	return xTimeNow;
 2011e4c:	e0bffe17 	ldw	r2,-8(fp)
}
 2011e50:	e037883a 	mov	sp,fp
 2011e54:	dfc00117 	ldw	ra,4(sp)
 2011e58:	df000017 	ldw	fp,0(sp)
 2011e5c:	dec00204 	addi	sp,sp,8
 2011e60:	f800283a 	ret

02011e64 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 2011e64:	defff904 	addi	sp,sp,-28
 2011e68:	dfc00615 	stw	ra,24(sp)
 2011e6c:	df000515 	stw	fp,20(sp)
 2011e70:	df000504 	addi	fp,sp,20
 2011e74:	e13ffc15 	stw	r4,-16(fp)
 2011e78:	e17ffd15 	stw	r5,-12(fp)
 2011e7c:	e1bffe15 	stw	r6,-8(fp)
 2011e80:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xProcessTimerNow = pdFALSE;
 2011e84:	e03ffb15 	stw	zero,-20(fp)

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 2011e88:	e0bffc17 	ldw	r2,-16(fp)
 2011e8c:	e0fffd17 	ldw	r3,-12(fp)
 2011e90:	10c00115 	stw	r3,4(r2)
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 2011e94:	e0bffc17 	ldw	r2,-16(fp)
 2011e98:	e0fffc17 	ldw	r3,-16(fp)
 2011e9c:	10c00415 	stw	r3,16(r2)

	if( xNextExpiryTime <= xTimeNow )
 2011ea0:	e0bffd17 	ldw	r2,-12(fp)
 2011ea4:	e0fffe17 	ldw	r3,-8(fp)
 2011ea8:	18801036 	bltu	r3,r2,2011eec <prvInsertTimerInActiveList+0x88>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2011eac:	e0fffe17 	ldw	r3,-8(fp)
 2011eb0:	e0bfff17 	ldw	r2,-4(fp)
 2011eb4:	1887c83a 	sub	r3,r3,r2
 2011eb8:	e0bffc17 	ldw	r2,-16(fp)
 2011ebc:	10800617 	ldw	r2,24(r2)
 2011ec0:	18800336 	bltu	r3,r2,2011ed0 <prvInsertTimerInActiveList+0x6c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 2011ec4:	00800044 	movi	r2,1
 2011ec8:	e0bffb15 	stw	r2,-20(fp)
 2011ecc:	00001606 	br	2011f28 <prvInsertTimerInActiveList+0xc4>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 2011ed0:	d0e7b917 	ldw	r3,-24860(gp)
 2011ed4:	e0bffc17 	ldw	r2,-16(fp)
 2011ed8:	10800104 	addi	r2,r2,4
 2011edc:	100b883a 	mov	r5,r2
 2011ee0:	1809883a 	mov	r4,r3
 2011ee4:	202d8c40 	call	202d8c4 <vListInsert>
 2011ee8:	00000f06 	br	2011f28 <prvInsertTimerInActiveList+0xc4>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 2011eec:	e0fffe17 	ldw	r3,-8(fp)
 2011ef0:	e0bfff17 	ldw	r2,-4(fp)
 2011ef4:	1880062e 	bgeu	r3,r2,2011f10 <prvInsertTimerInActiveList+0xac>
 2011ef8:	e0fffd17 	ldw	r3,-12(fp)
 2011efc:	e0bfff17 	ldw	r2,-4(fp)
 2011f00:	18800336 	bltu	r3,r2,2011f10 <prvInsertTimerInActiveList+0xac>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 2011f04:	00800044 	movi	r2,1
 2011f08:	e0bffb15 	stw	r2,-20(fp)
 2011f0c:	00000606 	br	2011f28 <prvInsertTimerInActiveList+0xc4>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 2011f10:	d0e7b817 	ldw	r3,-24864(gp)
 2011f14:	e0bffc17 	ldw	r2,-16(fp)
 2011f18:	10800104 	addi	r2,r2,4
 2011f1c:	100b883a 	mov	r5,r2
 2011f20:	1809883a 	mov	r4,r3
 2011f24:	202d8c40 	call	202d8c4 <vListInsert>
		}
	}

	return xProcessTimerNow;
 2011f28:	e0bffb17 	ldw	r2,-20(fp)
}
 2011f2c:	e037883a 	mov	sp,fp
 2011f30:	dfc00117 	ldw	ra,4(sp)
 2011f34:	df000017 	ldw	fp,0(sp)
 2011f38:	dec00204 	addi	sp,sp,8
 2011f3c:	f800283a 	ret

02011f40 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 2011f40:	defff604 	addi	sp,sp,-40
 2011f44:	dfc00915 	stw	ra,36(sp)
 2011f48:	df000815 	stw	fp,32(sp)
 2011f4c:	df000804 	addi	fp,sp,32
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 2011f50:	00007406 	br	2012124 <prvProcessReceivedCommands+0x1e4>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 2011f54:	e0bffc17 	ldw	r2,-16(fp)
 2011f58:	10007216 	blt	r2,zero,2012124 <prvProcessReceivedCommands+0x1e4>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 2011f5c:	e0bffe17 	ldw	r2,-8(fp)
 2011f60:	e0bff915 	stw	r2,-28(fp)

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 2011f64:	e0bff917 	ldw	r2,-28(fp)
 2011f68:	10800517 	ldw	r2,20(r2)
 2011f6c:	10000426 	beq	r2,zero,2011f80 <prvProcessReceivedCommands+0x40>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 2011f70:	e0bff917 	ldw	r2,-28(fp)
 2011f74:	10800104 	addi	r2,r2,4
 2011f78:	1009883a 	mov	r4,r2
 2011f7c:	202d99c0 	call	202d99c <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 2011f80:	e0bfff04 	addi	r2,fp,-4
 2011f84:	1009883a 	mov	r4,r2
 2011f88:	2011e000 	call	2011e00 <prvSampleTimeNow>
 2011f8c:	e0bffa15 	stw	r2,-24(fp)

			switch( xMessage.xMessageID )
 2011f90:	e0bffc17 	ldw	r2,-16(fp)
 2011f94:	10c002a8 	cmpgeui	r3,r2,10
 2011f98:	1800611e 	bne	r3,zero,2012120 <prvProcessReceivedCommands+0x1e0>
 2011f9c:	100690ba 	slli	r3,r2,2
 2011fa0:	00808074 	movhi	r2,513
 2011fa4:	1087ed04 	addi	r2,r2,8116
 2011fa8:	1885883a 	add	r2,r3,r2
 2011fac:	10800017 	ldw	r2,0(r2)
 2011fb0:	1000683a 	jmp	r2
 2011fb4:	02011fdc 	xori	r8,zero,1151
 2011fb8:	02011fdc 	xori	r8,zero,1151
 2011fbc:	02011fdc 	xori	r8,zero,1151
 2011fc0:	02012074 	movhi	r8,1153
 2011fc4:	02012094 	movui	r8,1154
 2011fc8:	020120e0 	cmpeqi	r8,zero,1155
 2011fcc:	02011fdc 	xori	r8,zero,1151
 2011fd0:	02011fdc 	xori	r8,zero,1151
 2011fd4:	02012074 	movhi	r8,1153
 2011fd8:	02012094 	movui	r8,1154
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 2011fdc:	e0bff917 	ldw	r2,-28(fp)
 2011fe0:	10800a03 	ldbu	r2,40(r2)
 2011fe4:	10800054 	ori	r2,r2,1
 2011fe8:	1007883a 	mov	r3,r2
 2011fec:	e0bff917 	ldw	r2,-28(fp)
 2011ff0:	10c00a05 	stb	r3,40(r2)
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 2011ff4:	e0fffd17 	ldw	r3,-12(fp)
 2011ff8:	e0bff917 	ldw	r2,-28(fp)
 2011ffc:	10800617 	ldw	r2,24(r2)
 2012000:	1885883a 	add	r2,r3,r2
 2012004:	e0fffd17 	ldw	r3,-12(fp)
 2012008:	180f883a 	mov	r7,r3
 201200c:	e1bffa17 	ldw	r6,-24(fp)
 2012010:	100b883a 	mov	r5,r2
 2012014:	e13ff917 	ldw	r4,-28(fp)
 2012018:	2011e640 	call	2011e64 <prvInsertTimerInActiveList>
 201201c:	10004126 	beq	r2,zero,2012124 <prvProcessReceivedCommands+0x1e4>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 2012020:	e0bff917 	ldw	r2,-28(fp)
 2012024:	10800817 	ldw	r2,32(r2)
 2012028:	e13ff917 	ldw	r4,-28(fp)
 201202c:	103ee83a 	callr	r2
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 2012030:	e0bff917 	ldw	r2,-28(fp)
 2012034:	10800a03 	ldbu	r2,40(r2)
 2012038:	10803fcc 	andi	r2,r2,255
 201203c:	1080010c 	andi	r2,r2,4
 2012040:	10003826 	beq	r2,zero,2012124 <prvProcessReceivedCommands+0x1e4>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 2012044:	e0fffd17 	ldw	r3,-12(fp)
 2012048:	e0bff917 	ldw	r2,-28(fp)
 201204c:	10800617 	ldw	r2,24(r2)
 2012050:	1885883a 	add	r2,r3,r2
 2012054:	d8000015 	stw	zero,0(sp)
 2012058:	000f883a 	mov	r7,zero
 201205c:	100d883a 	mov	r6,r2
 2012060:	000b883a 	mov	r5,zero
 2012064:	e13ff917 	ldw	r4,-28(fp)
 2012068:	20119280 	call	2011928 <xTimerGenericCommand>
 201206c:	e0bffb15 	stw	r2,-20(fp)
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
 2012070:	00002c06 	br	2012124 <prvProcessReceivedCommands+0x1e4>

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 2012074:	e0bff917 	ldw	r2,-28(fp)
 2012078:	10c00a03 	ldbu	r3,40(r2)
 201207c:	00bfff84 	movi	r2,-2
 2012080:	1884703a 	and	r2,r3,r2
 2012084:	1007883a 	mov	r3,r2
 2012088:	e0bff917 	ldw	r2,-28(fp)
 201208c:	10c00a05 	stb	r3,40(r2)
					break;
 2012090:	00002406 	br	2012124 <prvProcessReceivedCommands+0x1e4>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 2012094:	e0bff917 	ldw	r2,-28(fp)
 2012098:	10800a03 	ldbu	r2,40(r2)
 201209c:	10800054 	ori	r2,r2,1
 20120a0:	1007883a 	mov	r3,r2
 20120a4:	e0bff917 	ldw	r2,-28(fp)
 20120a8:	10c00a05 	stb	r3,40(r2)
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 20120ac:	e0fffd17 	ldw	r3,-12(fp)
 20120b0:	e0bff917 	ldw	r2,-28(fp)
 20120b4:	10c00615 	stw	r3,24(r2)
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 20120b8:	e0bff917 	ldw	r2,-28(fp)
 20120bc:	10c00617 	ldw	r3,24(r2)
 20120c0:	e0bffa17 	ldw	r2,-24(fp)
 20120c4:	1885883a 	add	r2,r3,r2
 20120c8:	e1fffa17 	ldw	r7,-24(fp)
 20120cc:	e1bffa17 	ldw	r6,-24(fp)
 20120d0:	100b883a 	mov	r5,r2
 20120d4:	e13ff917 	ldw	r4,-28(fp)
 20120d8:	2011e640 	call	2011e64 <prvInsertTimerInActiveList>
					break;
 20120dc:	00001106 	br	2012124 <prvProcessReceivedCommands+0x1e4>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 20120e0:	e0bff917 	ldw	r2,-28(fp)
 20120e4:	10800a03 	ldbu	r2,40(r2)
 20120e8:	10803fcc 	andi	r2,r2,255
 20120ec:	1080008c 	andi	r2,r2,2
 20120f0:	1000031e 	bne	r2,zero,2012100 <prvProcessReceivedCommands+0x1c0>
						{
							vPortFree( pxTimer );
 20120f4:	e13ff917 	ldw	r4,-28(fp)
 20120f8:	202d7300 	call	202d730 <vPortFree>
 20120fc:	00000906 	br	2012124 <prvProcessReceivedCommands+0x1e4>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 2012100:	e0bff917 	ldw	r2,-28(fp)
 2012104:	10c00a03 	ldbu	r3,40(r2)
 2012108:	00bfff84 	movi	r2,-2
 201210c:	1884703a 	and	r2,r3,r2
 2012110:	1007883a 	mov	r3,r2
 2012114:	e0bff917 	ldw	r2,-28(fp)
 2012118:	10c00a05 	stb	r3,40(r2)
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 201211c:	00000106 	br	2012124 <prvProcessReceivedCommands+0x1e4>

				default	:
					/* Don't expect to get here. */
					break;
 2012120:	0001883a 	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 2012124:	d0a7ba17 	ldw	r2,-24856(gp)
 2012128:	e0fffc04 	addi	r3,fp,-16
 201212c:	000d883a 	mov	r6,zero
 2012130:	180b883a 	mov	r5,r3
 2012134:	1009883a 	mov	r4,r2
 2012138:	200dbfc0 	call	200dbfc <xQueueReceive>
 201213c:	103f851e 	bne	r2,zero,2011f54 <__alt_mem_mem_0+0xfcff1f54>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
 2012140:	0001883a 	nop
 2012144:	e037883a 	mov	sp,fp
 2012148:	dfc00117 	ldw	ra,4(sp)
 201214c:	df000017 	ldw	fp,0(sp)
 2012150:	dec00204 	addi	sp,sp,8
 2012154:	f800283a 	ret

02012158 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 2012158:	defff804 	addi	sp,sp,-32
 201215c:	dfc00715 	stw	ra,28(sp)
 2012160:	df000615 	stw	fp,24(sp)
 2012164:	df000604 	addi	fp,sp,24

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 2012168:	00003106 	br	2012230 <prvSwitchTimerLists+0xd8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 201216c:	d0a7b817 	ldw	r2,-24864(gp)
 2012170:	10800317 	ldw	r2,12(r2)
 2012174:	10800017 	ldw	r2,0(r2)
 2012178:	e0bffb15 	stw	r2,-20(fp)

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 201217c:	d0a7b817 	ldw	r2,-24864(gp)
 2012180:	10800317 	ldw	r2,12(r2)
 2012184:	10800317 	ldw	r2,12(r2)
 2012188:	e0bffc15 	stw	r2,-16(fp)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 201218c:	e0bffc17 	ldw	r2,-16(fp)
 2012190:	10800104 	addi	r2,r2,4
 2012194:	1009883a 	mov	r4,r2
 2012198:	202d99c0 	call	202d99c <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 201219c:	e0bffc17 	ldw	r2,-16(fp)
 20121a0:	10800817 	ldw	r2,32(r2)
 20121a4:	e13ffc17 	ldw	r4,-16(fp)
 20121a8:	103ee83a 	callr	r2

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 20121ac:	e0bffc17 	ldw	r2,-16(fp)
 20121b0:	10800a03 	ldbu	r2,40(r2)
 20121b4:	10803fcc 	andi	r2,r2,255
 20121b8:	1080010c 	andi	r2,r2,4
 20121bc:	10001c26 	beq	r2,zero,2012230 <prvSwitchTimerLists+0xd8>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 20121c0:	e0bffc17 	ldw	r2,-16(fp)
 20121c4:	10c00617 	ldw	r3,24(r2)
 20121c8:	e0bffb17 	ldw	r2,-20(fp)
 20121cc:	1885883a 	add	r2,r3,r2
 20121d0:	e0bffd15 	stw	r2,-12(fp)
			if( xReloadTime > xNextExpireTime )
 20121d4:	e0bffd17 	ldw	r2,-12(fp)
 20121d8:	e0fffb17 	ldw	r3,-20(fp)
 20121dc:	18800d2e 	bgeu	r3,r2,2012214 <prvSwitchTimerLists+0xbc>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 20121e0:	e0bffc17 	ldw	r2,-16(fp)
 20121e4:	e0fffd17 	ldw	r3,-12(fp)
 20121e8:	10c00115 	stw	r3,4(r2)
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 20121ec:	e0bffc17 	ldw	r2,-16(fp)
 20121f0:	e0fffc17 	ldw	r3,-16(fp)
 20121f4:	10c00415 	stw	r3,16(r2)
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 20121f8:	d0e7b817 	ldw	r3,-24864(gp)
 20121fc:	e0bffc17 	ldw	r2,-16(fp)
 2012200:	10800104 	addi	r2,r2,4
 2012204:	100b883a 	mov	r5,r2
 2012208:	1809883a 	mov	r4,r3
 201220c:	202d8c40 	call	202d8c4 <vListInsert>
 2012210:	00000706 	br	2012230 <prvSwitchTimerLists+0xd8>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 2012214:	d8000015 	stw	zero,0(sp)
 2012218:	000f883a 	mov	r7,zero
 201221c:	e1bffb17 	ldw	r6,-20(fp)
 2012220:	000b883a 	mov	r5,zero
 2012224:	e13ffc17 	ldw	r4,-16(fp)
 2012228:	20119280 	call	2011928 <xTimerGenericCommand>
 201222c:	e0bffe15 	stw	r2,-8(fp)

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 2012230:	d0a7b817 	ldw	r2,-24864(gp)
 2012234:	10800017 	ldw	r2,0(r2)
 2012238:	103fcc1e 	bne	r2,zero,201216c <__alt_mem_mem_0+0xfcff216c>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 201223c:	d0a7b817 	ldw	r2,-24864(gp)
 2012240:	e0bfff15 	stw	r2,-4(fp)
	pxCurrentTimerList = pxOverflowTimerList;
 2012244:	d0a7b917 	ldw	r2,-24860(gp)
 2012248:	d0a7b815 	stw	r2,-24864(gp)
	pxOverflowTimerList = pxTemp;
 201224c:	e0bfff17 	ldw	r2,-4(fp)
 2012250:	d0a7b915 	stw	r2,-24860(gp)
}
 2012254:	0001883a 	nop
 2012258:	e037883a 	mov	sp,fp
 201225c:	dfc00117 	ldw	ra,4(sp)
 2012260:	df000017 	ldw	fp,0(sp)
 2012264:	dec00204 	addi	sp,sp,8
 2012268:	f800283a 	ret

0201226c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 201226c:	defffe04 	addi	sp,sp,-8
 2012270:	dfc00115 	stw	ra,4(sp)
 2012274:	df000015 	stw	fp,0(sp)
 2012278:	d839883a 	mov	fp,sp
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 201227c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2012280:	10000126 	beq	r2,zero,2012288 <prvCheckForValidListAndQueue+0x1c>
 2012284:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		if( xTimerQueue == NULL )
 2012288:	d0a7ba17 	ldw	r2,-24856(gp)
 201228c:	1000111e 	bne	r2,zero,20122d4 <prvCheckForValidListAndQueue+0x68>
		{
			vListInitialise( &xActiveTimerList1 );
 2012290:	01008174 	movhi	r4,517
 2012294:	21337f04 	addi	r4,r4,-12804
 2012298:	202d7a40 	call	202d7a4 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 201229c:	01008174 	movhi	r4,517
 20122a0:	21338404 	addi	r4,r4,-12784
 20122a4:	202d7a40 	call	202d7a4 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 20122a8:	00808174 	movhi	r2,517
 20122ac:	10b37f04 	addi	r2,r2,-12804
 20122b0:	d0a7b815 	stw	r2,-24864(gp)
			pxOverflowTimerList = &xActiveTimerList2;
 20122b4:	00808174 	movhi	r2,517
 20122b8:	10b38404 	addi	r2,r2,-12784
 20122bc:	d0a7b915 	stw	r2,-24860(gp)

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 20122c0:	000d883a 	mov	r6,zero
 20122c4:	01400304 	movi	r5,12
 20122c8:	01000284 	movi	r4,10
 20122cc:	200d4e00 	call	200d4e0 <xQueueGenericCreate>
 20122d0:	d0a7ba15 	stw	r2,-24856(gp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 20122d4:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20122d8:	10000126 	beq	r2,zero,20122e0 <prvCheckForValidListAndQueue+0x74>
 20122dc:	2010e300 	call	2010e30 <vTaskExitCritical>
}
 20122e0:	0001883a 	nop
 20122e4:	e037883a 	mov	sp,fp
 20122e8:	dfc00117 	ldw	ra,4(sp)
 20122ec:	df000017 	ldw	fp,0(sp)
 20122f0:	dec00204 	addi	sp,sp,8
 20122f4:	f800283a 	ret

020122f8 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
 20122f8:	defffb04 	addi	sp,sp,-20
 20122fc:	dfc00415 	stw	ra,16(sp)
 2012300:	df000315 	stw	fp,12(sp)
 2012304:	df000304 	addi	fp,sp,12
 2012308:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Timer_t *pxTimer = xTimer;
 201230c:	e0bfff17 	ldw	r2,-4(fp)
 2012310:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 2012314:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2012318:	10000126 	beq	r2,zero,2012320 <xTimerIsTimerActive+0x28>
 201231c:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
 2012320:	e0bffe17 	ldw	r2,-8(fp)
 2012324:	10800a03 	ldbu	r2,40(r2)
 2012328:	10803fcc 	andi	r2,r2,255
 201232c:	1080004c 	andi	r2,r2,1
 2012330:	1000021e 	bne	r2,zero,201233c <xTimerIsTimerActive+0x44>
		{
			xReturn = pdFALSE;
 2012334:	e03ffd15 	stw	zero,-12(fp)
 2012338:	00000206 	br	2012344 <xTimerIsTimerActive+0x4c>
		}
		else
		{
			xReturn = pdTRUE;
 201233c:	00800044 	movi	r2,1
 2012340:	e0bffd15 	stw	r2,-12(fp)
		}
	}
	taskEXIT_CRITICAL();
 2012344:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2012348:	10000126 	beq	r2,zero,2012350 <xTimerIsTimerActive+0x58>
 201234c:	2010e300 	call	2010e30 <vTaskExitCritical>

	return xReturn;
 2012350:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 Can't be pointer to const due to the typedef. */
 2012354:	e037883a 	mov	sp,fp
 2012358:	dfc00117 	ldw	ra,4(sp)
 201235c:	df000017 	ldw	fp,0(sp)
 2012360:	dec00204 	addi	sp,sp,8
 2012364:	f800283a 	ret

02012368 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
 2012368:	defffb04 	addi	sp,sp,-20
 201236c:	dfc00415 	stw	ra,16(sp)
 2012370:	df000315 	stw	fp,12(sp)
 2012374:	df000304 	addi	fp,sp,12
 2012378:	e13fff15 	stw	r4,-4(fp)
Timer_t * const pxTimer = xTimer;
 201237c:	e0bfff17 	ldw	r2,-4(fp)
 2012380:	e0bffd15 	stw	r2,-12(fp)
void *pvReturn;

	configASSERT( xTimer );

	taskENTER_CRITICAL();
 2012384:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2012388:	10000126 	beq	r2,zero,2012390 <pvTimerGetTimerID+0x28>
 201238c:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
 2012390:	e0bffd17 	ldw	r2,-12(fp)
 2012394:	10800717 	ldw	r2,28(r2)
 2012398:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 201239c:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20123a0:	10000126 	beq	r2,zero,20123a8 <pvTimerGetTimerID+0x40>
 20123a4:	2010e300 	call	2010e30 <vTaskExitCritical>

	return pvReturn;
 20123a8:	e0bffe17 	ldw	r2,-8(fp)
}
 20123ac:	e037883a 	mov	sp,fp
 20123b0:	dfc00117 	ldw	ra,4(sp)
 20123b4:	df000017 	ldw	fp,0(sp)
 20123b8:	dec00204 	addi	sp,sp,8
 20123bc:	f800283a 	ret

020123c0 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
 20123c0:	defffb04 	addi	sp,sp,-20
 20123c4:	dfc00415 	stw	ra,16(sp)
 20123c8:	df000315 	stw	fp,12(sp)
 20123cc:	df000304 	addi	fp,sp,12
 20123d0:	e13ffe15 	stw	r4,-8(fp)
 20123d4:	e17fff15 	stw	r5,-4(fp)
Timer_t * const pxTimer = xTimer;
 20123d8:	e0bffe17 	ldw	r2,-8(fp)
 20123dc:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( xTimer );

	taskENTER_CRITICAL();
 20123e0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20123e4:	10000126 	beq	r2,zero,20123ec <vTimerSetTimerID+0x2c>
 20123e8:	2010de80 	call	2010de8 <vTaskEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
 20123ec:	e0bffd17 	ldw	r2,-12(fp)
 20123f0:	e0ffff17 	ldw	r3,-4(fp)
 20123f4:	10c00715 	stw	r3,28(r2)
	}
	taskEXIT_CRITICAL();
 20123f8:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 20123fc:	10000126 	beq	r2,zero,2012404 <vTimerSetTimerID+0x44>
 2012400:	2010e300 	call	2010e30 <vTaskExitCritical>
}
 2012404:	0001883a 	nop
 2012408:	e037883a 	mov	sp,fp
 201240c:	dfc00117 	ldw	ra,4(sp)
 2012410:	df000017 	ldw	fp,0(sp)
 2012414:	dec00204 	addi	sp,sp,8
 2012418:	f800283a 	ret

0201241c <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
	{
 201241c:	defffe04 	addi	sp,sp,-8
 2012420:	df000115 	stw	fp,4(sp)
 2012424:	df000104 	addi	fp,sp,4
 2012428:	e13fff15 	stw	r4,-4(fp)
		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
 201242c:	e0bfff17 	ldw	r2,-4(fp)
 2012430:	10800917 	ldw	r2,36(r2)
	}
 2012434:	e037883a 	mov	sp,fp
 2012438:	df000017 	ldw	fp,0(sp)
 201243c:	dec00104 	addi	sp,sp,4
 2012440:	f800283a 	ret

02012444 <vTimerSetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
	{
 2012444:	defffd04 	addi	sp,sp,-12
 2012448:	df000215 	stw	fp,8(sp)
 201244c:	df000204 	addi	fp,sp,8
 2012450:	e13ffe15 	stw	r4,-8(fp)
 2012454:	e17fff15 	stw	r5,-4(fp)
		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
 2012458:	e0bffe17 	ldw	r2,-8(fp)
 201245c:	e0ffff17 	ldw	r3,-4(fp)
 2012460:	10c00915 	stw	r3,36(r2)
	}
 2012464:	0001883a 	nop
 2012468:	e037883a 	mov	sp,fp
 201246c:	df000017 	ldw	fp,0(sp)
 2012470:	dec00104 	addi	sp,sp,4
 2012474:	f800283a 	ret

02012478 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 2012478:	defffc04 	addi	sp,sp,-16
 201247c:	df000315 	stw	fp,12(sp)
 2012480:	df000304 	addi	fp,sp,12
 2012484:	e13ffd15 	stw	r4,-12(fp)
 2012488:	e17ffe15 	stw	r5,-8(fp)
 201248c:	e1bfff15 	stw	r6,-4(fp)
  return len;
 2012490:	e0bfff17 	ldw	r2,-4(fp)
}
 2012494:	e037883a 	mov	sp,fp
 2012498:	df000017 	ldw	fp,0(sp)
 201249c:	dec00104 	addi	sp,sp,4
 20124a0:	f800283a 	ret

020124a4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 20124a4:	defffd04 	addi	sp,sp,-12
 20124a8:	dfc00215 	stw	ra,8(sp)
 20124ac:	df000115 	stw	fp,4(sp)
 20124b0:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 20124b4:	00808134 	movhi	r2,516
 20124b8:	10993e04 	addi	r2,r2,25848
 20124bc:	e0bfff15 	stw	r2,-4(fp)
 20124c0:	00000606 	br	20124dc <_do_ctors+0x38>
        (*ctor) (); 
 20124c4:	e0bfff17 	ldw	r2,-4(fp)
 20124c8:	10800017 	ldw	r2,0(r2)
 20124cc:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 20124d0:	e0bfff17 	ldw	r2,-4(fp)
 20124d4:	10bfff04 	addi	r2,r2,-4
 20124d8:	e0bfff15 	stw	r2,-4(fp)
 20124dc:	e0ffff17 	ldw	r3,-4(fp)
 20124e0:	00808134 	movhi	r2,516
 20124e4:	10993f04 	addi	r2,r2,25852
 20124e8:	18bff62e 	bgeu	r3,r2,20124c4 <__alt_mem_mem_0+0xfcff24c4>
        (*ctor) (); 
}
 20124ec:	0001883a 	nop
 20124f0:	e037883a 	mov	sp,fp
 20124f4:	dfc00117 	ldw	ra,4(sp)
 20124f8:	df000017 	ldw	fp,0(sp)
 20124fc:	dec00204 	addi	sp,sp,8
 2012500:	f800283a 	ret

02012504 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 2012504:	defffd04 	addi	sp,sp,-12
 2012508:	dfc00215 	stw	ra,8(sp)
 201250c:	df000115 	stw	fp,4(sp)
 2012510:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 2012514:	00808134 	movhi	r2,516
 2012518:	10993e04 	addi	r2,r2,25848
 201251c:	e0bfff15 	stw	r2,-4(fp)
 2012520:	00000606 	br	201253c <_do_dtors+0x38>
        (*dtor) (); 
 2012524:	e0bfff17 	ldw	r2,-4(fp)
 2012528:	10800017 	ldw	r2,0(r2)
 201252c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 2012530:	e0bfff17 	ldw	r2,-4(fp)
 2012534:	10bfff04 	addi	r2,r2,-4
 2012538:	e0bfff15 	stw	r2,-4(fp)
 201253c:	e0ffff17 	ldw	r3,-4(fp)
 2012540:	00808134 	movhi	r2,516
 2012544:	10993f04 	addi	r2,r2,25852
 2012548:	18bff62e 	bgeu	r3,r2,2012524 <__alt_mem_mem_0+0xfcff2524>
        (*dtor) (); 
}
 201254c:	0001883a 	nop
 2012550:	e037883a 	mov	sp,fp
 2012554:	dfc00117 	ldw	ra,4(sp)
 2012558:	df000017 	ldw	fp,0(sp)
 201255c:	dec00204 	addi	sp,sp,8
 2012560:	f800283a 	ret

02012564 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2012564:	defffe04 	addi	sp,sp,-8
 2012568:	dfc00115 	stw	ra,4(sp)
 201256c:	df000015 	stw	fp,0(sp)
 2012570:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2012574:	d0a01b17 	ldw	r2,-32660(gp)
 2012578:	10000326 	beq	r2,zero,2012588 <alt_get_errno+0x24>
 201257c:	d0a01b17 	ldw	r2,-32660(gp)
 2012580:	103ee83a 	callr	r2
 2012584:	00000106 	br	201258c <alt_get_errno+0x28>
 2012588:	d0a7a404 	addi	r2,gp,-24944
}
 201258c:	e037883a 	mov	sp,fp
 2012590:	dfc00117 	ldw	ra,4(sp)
 2012594:	df000017 	ldw	fp,0(sp)
 2012598:	dec00204 	addi	sp,sp,8
 201259c:	f800283a 	ret

020125a0 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 20125a0:	defffb04 	addi	sp,sp,-20
 20125a4:	dfc00415 	stw	ra,16(sp)
 20125a8:	df000315 	stw	fp,12(sp)
 20125ac:	df000304 	addi	fp,sp,12
 20125b0:	e13ffe15 	stw	r4,-8(fp)
 20125b4:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 20125b8:	e0bffe17 	ldw	r2,-8(fp)
 20125bc:	10000616 	blt	r2,zero,20125d8 <fstat+0x38>
 20125c0:	e0bffe17 	ldw	r2,-8(fp)
 20125c4:	10c00324 	muli	r3,r2,12
 20125c8:	00808174 	movhi	r2,517
 20125cc:	10a61a04 	addi	r2,r2,-26520
 20125d0:	1885883a 	add	r2,r3,r2
 20125d4:	00000106 	br	20125dc <fstat+0x3c>
 20125d8:	0005883a 	mov	r2,zero
 20125dc:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 20125e0:	e0bffd17 	ldw	r2,-12(fp)
 20125e4:	10001026 	beq	r2,zero,2012628 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 20125e8:	e0bffd17 	ldw	r2,-12(fp)
 20125ec:	10800017 	ldw	r2,0(r2)
 20125f0:	10800817 	ldw	r2,32(r2)
 20125f4:	10000726 	beq	r2,zero,2012614 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 20125f8:	e0bffd17 	ldw	r2,-12(fp)
 20125fc:	10800017 	ldw	r2,0(r2)
 2012600:	10800817 	ldw	r2,32(r2)
 2012604:	e17fff17 	ldw	r5,-4(fp)
 2012608:	e13ffd17 	ldw	r4,-12(fp)
 201260c:	103ee83a 	callr	r2
 2012610:	00000a06 	br	201263c <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 2012614:	e0bfff17 	ldw	r2,-4(fp)
 2012618:	00c80004 	movi	r3,8192
 201261c:	10c00115 	stw	r3,4(r2)
      return 0;
 2012620:	0005883a 	mov	r2,zero
 2012624:	00000506 	br	201263c <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 2012628:	20125640 	call	2012564 <alt_get_errno>
 201262c:	1007883a 	mov	r3,r2
 2012630:	00801444 	movi	r2,81
 2012634:	18800015 	stw	r2,0(r3)
    return -1;
 2012638:	00bfffc4 	movi	r2,-1
  }
}
 201263c:	e037883a 	mov	sp,fp
 2012640:	dfc00117 	ldw	ra,4(sp)
 2012644:	df000017 	ldw	fp,0(sp)
 2012648:	dec00204 	addi	sp,sp,8
 201264c:	f800283a 	ret

02012650 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 2012650:	defff904 	addi	sp,sp,-28
 2012654:	dfc00615 	stw	ra,24(sp)
 2012658:	df000515 	stw	fp,20(sp)
 201265c:	df000504 	addi	fp,sp,20
 2012660:	e13ffc15 	stw	r4,-16(fp)
 2012664:	e17ffd15 	stw	r5,-12(fp)
 2012668:	e1bffe15 	stw	r6,-8(fp)
 201266c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 2012670:	e1bfff17 	ldw	r6,-4(fp)
 2012674:	e17ffe17 	ldw	r5,-8(fp)
 2012678:	e13ffd17 	ldw	r4,-12(fp)
 201267c:	2012b6c0 	call	2012b6c <open>
 2012680:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 2012684:	e0bffb17 	ldw	r2,-20(fp)
 2012688:	10001c16 	blt	r2,zero,20126fc <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 201268c:	00808174 	movhi	r2,517
 2012690:	10a61a04 	addi	r2,r2,-26520
 2012694:	e0fffb17 	ldw	r3,-20(fp)
 2012698:	18c00324 	muli	r3,r3,12
 201269c:	10c5883a 	add	r2,r2,r3
 20126a0:	10c00017 	ldw	r3,0(r2)
 20126a4:	e0bffc17 	ldw	r2,-16(fp)
 20126a8:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 20126ac:	00808174 	movhi	r2,517
 20126b0:	10a61a04 	addi	r2,r2,-26520
 20126b4:	e0fffb17 	ldw	r3,-20(fp)
 20126b8:	18c00324 	muli	r3,r3,12
 20126bc:	10c5883a 	add	r2,r2,r3
 20126c0:	10800104 	addi	r2,r2,4
 20126c4:	10c00017 	ldw	r3,0(r2)
 20126c8:	e0bffc17 	ldw	r2,-16(fp)
 20126cc:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 20126d0:	00808174 	movhi	r2,517
 20126d4:	10a61a04 	addi	r2,r2,-26520
 20126d8:	e0fffb17 	ldw	r3,-20(fp)
 20126dc:	18c00324 	muli	r3,r3,12
 20126e0:	10c5883a 	add	r2,r2,r3
 20126e4:	10800204 	addi	r2,r2,8
 20126e8:	10c00017 	ldw	r3,0(r2)
 20126ec:	e0bffc17 	ldw	r2,-16(fp)
 20126f0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 20126f4:	e13ffb17 	ldw	r4,-20(fp)
 20126f8:	2012f280 	call	2012f28 <alt_release_fd>
  }
} 
 20126fc:	0001883a 	nop
 2012700:	e037883a 	mov	sp,fp
 2012704:	dfc00117 	ldw	ra,4(sp)
 2012708:	df000017 	ldw	fp,0(sp)
 201270c:	dec00204 	addi	sp,sp,8
 2012710:	f800283a 	ret

02012714 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 2012714:	defffb04 	addi	sp,sp,-20
 2012718:	dfc00415 	stw	ra,16(sp)
 201271c:	df000315 	stw	fp,12(sp)
 2012720:	df000304 	addi	fp,sp,12
 2012724:	e13ffd15 	stw	r4,-12(fp)
 2012728:	e17ffe15 	stw	r5,-8(fp)
 201272c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 2012730:	01c07fc4 	movi	r7,511
 2012734:	01800044 	movi	r6,1
 2012738:	e17ffd17 	ldw	r5,-12(fp)
 201273c:	01008174 	movhi	r4,517
 2012740:	21261d04 	addi	r4,r4,-26508
 2012744:	20126500 	call	2012650 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 2012748:	01c07fc4 	movi	r7,511
 201274c:	000d883a 	mov	r6,zero
 2012750:	e17ffe17 	ldw	r5,-8(fp)
 2012754:	01008174 	movhi	r4,517
 2012758:	21261a04 	addi	r4,r4,-26520
 201275c:	20126500 	call	2012650 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 2012760:	01c07fc4 	movi	r7,511
 2012764:	01800044 	movi	r6,1
 2012768:	e17fff17 	ldw	r5,-4(fp)
 201276c:	01008174 	movhi	r4,517
 2012770:	21262004 	addi	r4,r4,-26496
 2012774:	20126500 	call	2012650 <alt_open_fd>
}  
 2012778:	0001883a 	nop
 201277c:	e037883a 	mov	sp,fp
 2012780:	dfc00117 	ldw	ra,4(sp)
 2012784:	df000017 	ldw	fp,0(sp)
 2012788:	dec00204 	addi	sp,sp,8
 201278c:	f800283a 	ret

02012790 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2012790:	defffe04 	addi	sp,sp,-8
 2012794:	dfc00115 	stw	ra,4(sp)
 2012798:	df000015 	stw	fp,0(sp)
 201279c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20127a0:	d0a01b17 	ldw	r2,-32660(gp)
 20127a4:	10000326 	beq	r2,zero,20127b4 <alt_get_errno+0x24>
 20127a8:	d0a01b17 	ldw	r2,-32660(gp)
 20127ac:	103ee83a 	callr	r2
 20127b0:	00000106 	br	20127b8 <alt_get_errno+0x28>
 20127b4:	d0a7a404 	addi	r2,gp,-24944
}
 20127b8:	e037883a 	mov	sp,fp
 20127bc:	dfc00117 	ldw	ra,4(sp)
 20127c0:	df000017 	ldw	fp,0(sp)
 20127c4:	dec00204 	addi	sp,sp,8
 20127c8:	f800283a 	ret

020127cc <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 20127cc:	deffed04 	addi	sp,sp,-76
 20127d0:	dfc01215 	stw	ra,72(sp)
 20127d4:	df001115 	stw	fp,68(sp)
 20127d8:	df001104 	addi	fp,sp,68
 20127dc:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 20127e0:	e0bfff17 	ldw	r2,-4(fp)
 20127e4:	10000616 	blt	r2,zero,2012800 <isatty+0x34>
 20127e8:	e0bfff17 	ldw	r2,-4(fp)
 20127ec:	10c00324 	muli	r3,r2,12
 20127f0:	00808174 	movhi	r2,517
 20127f4:	10a61a04 	addi	r2,r2,-26520
 20127f8:	1885883a 	add	r2,r3,r2
 20127fc:	00000106 	br	2012804 <isatty+0x38>
 2012800:	0005883a 	mov	r2,zero
 2012804:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 2012808:	e0bfef17 	ldw	r2,-68(fp)
 201280c:	10000e26 	beq	r2,zero,2012848 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 2012810:	e0bfef17 	ldw	r2,-68(fp)
 2012814:	10800017 	ldw	r2,0(r2)
 2012818:	10800817 	ldw	r2,32(r2)
 201281c:	1000021e 	bne	r2,zero,2012828 <isatty+0x5c>
    {
      return 1;
 2012820:	00800044 	movi	r2,1
 2012824:	00000d06 	br	201285c <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 2012828:	e0bff004 	addi	r2,fp,-64
 201282c:	100b883a 	mov	r5,r2
 2012830:	e13fff17 	ldw	r4,-4(fp)
 2012834:	20125a00 	call	20125a0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 2012838:	e0bff117 	ldw	r2,-60(fp)
 201283c:	10880020 	cmpeqi	r2,r2,8192
 2012840:	10803fcc 	andi	r2,r2,255
 2012844:	00000506 	br	201285c <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 2012848:	20127900 	call	2012790 <alt_get_errno>
 201284c:	1007883a 	mov	r3,r2
 2012850:	00801444 	movi	r2,81
 2012854:	18800015 	stw	r2,0(r3)
    return 0;
 2012858:	0005883a 	mov	r2,zero
  }
}
 201285c:	e037883a 	mov	sp,fp
 2012860:	dfc00117 	ldw	ra,4(sp)
 2012864:	df000017 	ldw	fp,0(sp)
 2012868:	dec00204 	addi	sp,sp,8
 201286c:	f800283a 	ret

02012870 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 2012870:	defffc04 	addi	sp,sp,-16
 2012874:	df000315 	stw	fp,12(sp)
 2012878:	df000304 	addi	fp,sp,12
 201287c:	e13ffd15 	stw	r4,-12(fp)
 2012880:	e17ffe15 	stw	r5,-8(fp)
 2012884:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 2012888:	e0fffe17 	ldw	r3,-8(fp)
 201288c:	e0bffd17 	ldw	r2,-12(fp)
 2012890:	18800c26 	beq	r3,r2,20128c4 <alt_load_section+0x54>
  {
    while( to != end )
 2012894:	00000806 	br	20128b8 <alt_load_section+0x48>
    {
      *to++ = *from++;
 2012898:	e0bffe17 	ldw	r2,-8(fp)
 201289c:	10c00104 	addi	r3,r2,4
 20128a0:	e0fffe15 	stw	r3,-8(fp)
 20128a4:	e0fffd17 	ldw	r3,-12(fp)
 20128a8:	19000104 	addi	r4,r3,4
 20128ac:	e13ffd15 	stw	r4,-12(fp)
 20128b0:	18c00017 	ldw	r3,0(r3)
 20128b4:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 20128b8:	e0fffe17 	ldw	r3,-8(fp)
 20128bc:	e0bfff17 	ldw	r2,-4(fp)
 20128c0:	18bff51e 	bne	r3,r2,2012898 <__alt_mem_mem_0+0xfcff2898>
    {
      *to++ = *from++;
    }
  }
}
 20128c4:	0001883a 	nop
 20128c8:	e037883a 	mov	sp,fp
 20128cc:	df000017 	ldw	fp,0(sp)
 20128d0:	dec00104 	addi	sp,sp,4
 20128d4:	f800283a 	ret

020128d8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 20128d8:	defffe04 	addi	sp,sp,-8
 20128dc:	dfc00115 	stw	ra,4(sp)
 20128e0:	df000015 	stw	fp,0(sp)
 20128e4:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 20128e8:	01808174 	movhi	r6,517
 20128ec:	31ab6004 	addi	r6,r6,-21120
 20128f0:	01408174 	movhi	r5,517
 20128f4:	2963e704 	addi	r5,r5,-28772
 20128f8:	01008174 	movhi	r4,517
 20128fc:	212b6004 	addi	r4,r4,-21120
 2012900:	20128700 	call	2012870 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 2012904:	01808034 	movhi	r6,512
 2012908:	31809204 	addi	r6,r6,584
 201290c:	01408034 	movhi	r5,512
 2012910:	29400804 	addi	r5,r5,32
 2012914:	01008034 	movhi	r4,512
 2012918:	21000804 	addi	r4,r4,32
 201291c:	20128700 	call	2012870 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 2012920:	01808174 	movhi	r6,517
 2012924:	31a3e704 	addi	r6,r6,-28772
 2012928:	01408134 	movhi	r5,516
 201292c:	29593f04 	addi	r5,r5,25852
 2012930:	01008134 	movhi	r4,516
 2012934:	21193f04 	addi	r4,r4,25852
 2012938:	20128700 	call	2012870 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 201293c:	202e0dc0 	call	202e0dc <alt_dcache_flush_all>
  alt_icache_flush_all();
 2012940:	202e4540 	call	202e454 <alt_icache_flush_all>
}
 2012944:	0001883a 	nop
 2012948:	e037883a 	mov	sp,fp
 201294c:	dfc00117 	ldw	ra,4(sp)
 2012950:	df000017 	ldw	fp,0(sp)
 2012954:	dec00204 	addi	sp,sp,8
 2012958:	f800283a 	ret

0201295c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 201295c:	defffe04 	addi	sp,sp,-8
 2012960:	dfc00115 	stw	ra,4(sp)
 2012964:	df000015 	stw	fp,0(sp)
 2012968:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 201296c:	d0a01b17 	ldw	r2,-32660(gp)
 2012970:	10000326 	beq	r2,zero,2012980 <alt_get_errno+0x24>
 2012974:	d0a01b17 	ldw	r2,-32660(gp)
 2012978:	103ee83a 	callr	r2
 201297c:	00000106 	br	2012984 <alt_get_errno+0x28>
 2012980:	d0a7a404 	addi	r2,gp,-24944
}
 2012984:	e037883a 	mov	sp,fp
 2012988:	dfc00117 	ldw	ra,4(sp)
 201298c:	df000017 	ldw	fp,0(sp)
 2012990:	dec00204 	addi	sp,sp,8
 2012994:	f800283a 	ret

02012998 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 2012998:	defff904 	addi	sp,sp,-28
 201299c:	dfc00615 	stw	ra,24(sp)
 20129a0:	df000515 	stw	fp,20(sp)
 20129a4:	df000504 	addi	fp,sp,20
 20129a8:	e13ffd15 	stw	r4,-12(fp)
 20129ac:	e17ffe15 	stw	r5,-8(fp)
 20129b0:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 20129b4:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 20129b8:	e0bffd17 	ldw	r2,-12(fp)
 20129bc:	10000616 	blt	r2,zero,20129d8 <lseek+0x40>
 20129c0:	e0bffd17 	ldw	r2,-12(fp)
 20129c4:	10c00324 	muli	r3,r2,12
 20129c8:	00808174 	movhi	r2,517
 20129cc:	10a61a04 	addi	r2,r2,-26520
 20129d0:	1885883a 	add	r2,r3,r2
 20129d4:	00000106 	br	20129dc <lseek+0x44>
 20129d8:	0005883a 	mov	r2,zero
 20129dc:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 20129e0:	e0bffc17 	ldw	r2,-16(fp)
 20129e4:	10001026 	beq	r2,zero,2012a28 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 20129e8:	e0bffc17 	ldw	r2,-16(fp)
 20129ec:	10800017 	ldw	r2,0(r2)
 20129f0:	10800717 	ldw	r2,28(r2)
 20129f4:	10000926 	beq	r2,zero,2012a1c <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 20129f8:	e0bffc17 	ldw	r2,-16(fp)
 20129fc:	10800017 	ldw	r2,0(r2)
 2012a00:	10800717 	ldw	r2,28(r2)
 2012a04:	e1bfff17 	ldw	r6,-4(fp)
 2012a08:	e17ffe17 	ldw	r5,-8(fp)
 2012a0c:	e13ffc17 	ldw	r4,-16(fp)
 2012a10:	103ee83a 	callr	r2
 2012a14:	e0bffb15 	stw	r2,-20(fp)
 2012a18:	00000506 	br	2012a30 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 2012a1c:	00bfde84 	movi	r2,-134
 2012a20:	e0bffb15 	stw	r2,-20(fp)
 2012a24:	00000206 	br	2012a30 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 2012a28:	00bfebc4 	movi	r2,-81
 2012a2c:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 2012a30:	e0bffb17 	ldw	r2,-20(fp)
 2012a34:	1000070e 	bge	r2,zero,2012a54 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 2012a38:	201295c0 	call	201295c <alt_get_errno>
 2012a3c:	1007883a 	mov	r3,r2
 2012a40:	e0bffb17 	ldw	r2,-20(fp)
 2012a44:	0085c83a 	sub	r2,zero,r2
 2012a48:	18800015 	stw	r2,0(r3)
    rc = -1;
 2012a4c:	00bfffc4 	movi	r2,-1
 2012a50:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 2012a54:	e0bffb17 	ldw	r2,-20(fp)
}
 2012a58:	e037883a 	mov	sp,fp
 2012a5c:	dfc00117 	ldw	ra,4(sp)
 2012a60:	df000017 	ldw	fp,0(sp)
 2012a64:	dec00204 	addi	sp,sp,8
 2012a68:	f800283a 	ret

02012a6c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2012a6c:	defffe04 	addi	sp,sp,-8
 2012a70:	dfc00115 	stw	ra,4(sp)
 2012a74:	df000015 	stw	fp,0(sp)
 2012a78:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2012a7c:	d0a01b17 	ldw	r2,-32660(gp)
 2012a80:	10000326 	beq	r2,zero,2012a90 <alt_get_errno+0x24>
 2012a84:	d0a01b17 	ldw	r2,-32660(gp)
 2012a88:	103ee83a 	callr	r2
 2012a8c:	00000106 	br	2012a94 <alt_get_errno+0x28>
 2012a90:	d0a7a404 	addi	r2,gp,-24944
}
 2012a94:	e037883a 	mov	sp,fp
 2012a98:	dfc00117 	ldw	ra,4(sp)
 2012a9c:	df000017 	ldw	fp,0(sp)
 2012aa0:	dec00204 	addi	sp,sp,8
 2012aa4:	f800283a 	ret

02012aa8 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 2012aa8:	defffd04 	addi	sp,sp,-12
 2012aac:	df000215 	stw	fp,8(sp)
 2012ab0:	df000204 	addi	fp,sp,8
 2012ab4:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 2012ab8:	e0bfff17 	ldw	r2,-4(fp)
 2012abc:	10800217 	ldw	r2,8(r2)
 2012ac0:	10d00034 	orhi	r3,r2,16384
 2012ac4:	e0bfff17 	ldw	r2,-4(fp)
 2012ac8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 2012acc:	e03ffe15 	stw	zero,-8(fp)
 2012ad0:	00001d06 	br	2012b48 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 2012ad4:	00808174 	movhi	r2,517
 2012ad8:	10a61a04 	addi	r2,r2,-26520
 2012adc:	e0fffe17 	ldw	r3,-8(fp)
 2012ae0:	18c00324 	muli	r3,r3,12
 2012ae4:	10c5883a 	add	r2,r2,r3
 2012ae8:	10c00017 	ldw	r3,0(r2)
 2012aec:	e0bfff17 	ldw	r2,-4(fp)
 2012af0:	10800017 	ldw	r2,0(r2)
 2012af4:	1880111e 	bne	r3,r2,2012b3c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 2012af8:	00808174 	movhi	r2,517
 2012afc:	10a61a04 	addi	r2,r2,-26520
 2012b00:	e0fffe17 	ldw	r3,-8(fp)
 2012b04:	18c00324 	muli	r3,r3,12
 2012b08:	10c5883a 	add	r2,r2,r3
 2012b0c:	10800204 	addi	r2,r2,8
 2012b10:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 2012b14:	1000090e 	bge	r2,zero,2012b3c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 2012b18:	e0bffe17 	ldw	r2,-8(fp)
 2012b1c:	10c00324 	muli	r3,r2,12
 2012b20:	00808174 	movhi	r2,517
 2012b24:	10a61a04 	addi	r2,r2,-26520
 2012b28:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 2012b2c:	e0bfff17 	ldw	r2,-4(fp)
 2012b30:	18800226 	beq	r3,r2,2012b3c <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 2012b34:	00bffcc4 	movi	r2,-13
 2012b38:	00000806 	br	2012b5c <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 2012b3c:	e0bffe17 	ldw	r2,-8(fp)
 2012b40:	10800044 	addi	r2,r2,1
 2012b44:	e0bffe15 	stw	r2,-8(fp)
 2012b48:	d0a00a17 	ldw	r2,-32728(gp)
 2012b4c:	1007883a 	mov	r3,r2
 2012b50:	e0bffe17 	ldw	r2,-8(fp)
 2012b54:	18bfdf2e 	bgeu	r3,r2,2012ad4 <__alt_mem_mem_0+0xfcff2ad4>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 2012b58:	0005883a 	mov	r2,zero
}
 2012b5c:	e037883a 	mov	sp,fp
 2012b60:	df000017 	ldw	fp,0(sp)
 2012b64:	dec00104 	addi	sp,sp,4
 2012b68:	f800283a 	ret

02012b6c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 2012b6c:	defff604 	addi	sp,sp,-40
 2012b70:	dfc00915 	stw	ra,36(sp)
 2012b74:	df000815 	stw	fp,32(sp)
 2012b78:	df000804 	addi	fp,sp,32
 2012b7c:	e13ffd15 	stw	r4,-12(fp)
 2012b80:	e17ffe15 	stw	r5,-8(fp)
 2012b84:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 2012b88:	00bfffc4 	movi	r2,-1
 2012b8c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 2012b90:	00bffb44 	movi	r2,-19
 2012b94:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 2012b98:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 2012b9c:	d1600804 	addi	r5,gp,-32736
 2012ba0:	e13ffd17 	ldw	r4,-12(fp)
 2012ba4:	202e1dc0 	call	202e1dc <alt_find_dev>
 2012ba8:	e0bff815 	stw	r2,-32(fp)
 2012bac:	e0bff817 	ldw	r2,-32(fp)
 2012bb0:	1000051e 	bne	r2,zero,2012bc8 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 2012bb4:	e13ffd17 	ldw	r4,-12(fp)
 2012bb8:	202e26c0 	call	202e26c <alt_find_file>
 2012bbc:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 2012bc0:	00800044 	movi	r2,1
 2012bc4:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 2012bc8:	e0bff817 	ldw	r2,-32(fp)
 2012bcc:	10002926 	beq	r2,zero,2012c74 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 2012bd0:	e13ff817 	ldw	r4,-32(fp)
 2012bd4:	202e3740 	call	202e374 <alt_get_fd>
 2012bd8:	e0bff915 	stw	r2,-28(fp)
 2012bdc:	e0bff917 	ldw	r2,-28(fp)
 2012be0:	1000030e 	bge	r2,zero,2012bf0 <open+0x84>
    {
      status = index;
 2012be4:	e0bff917 	ldw	r2,-28(fp)
 2012be8:	e0bffa15 	stw	r2,-24(fp)
 2012bec:	00002306 	br	2012c7c <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 2012bf0:	e0bff917 	ldw	r2,-28(fp)
 2012bf4:	10c00324 	muli	r3,r2,12
 2012bf8:	00808174 	movhi	r2,517
 2012bfc:	10a61a04 	addi	r2,r2,-26520
 2012c00:	1885883a 	add	r2,r3,r2
 2012c04:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 2012c08:	e0fffe17 	ldw	r3,-8(fp)
 2012c0c:	00900034 	movhi	r2,16384
 2012c10:	10bfffc4 	addi	r2,r2,-1
 2012c14:	1886703a 	and	r3,r3,r2
 2012c18:	e0bffc17 	ldw	r2,-16(fp)
 2012c1c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 2012c20:	e0bffb17 	ldw	r2,-20(fp)
 2012c24:	1000051e 	bne	r2,zero,2012c3c <open+0xd0>
 2012c28:	e13ffc17 	ldw	r4,-16(fp)
 2012c2c:	2012aa80 	call	2012aa8 <alt_file_locked>
 2012c30:	e0bffa15 	stw	r2,-24(fp)
 2012c34:	e0bffa17 	ldw	r2,-24(fp)
 2012c38:	10001016 	blt	r2,zero,2012c7c <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 2012c3c:	e0bff817 	ldw	r2,-32(fp)
 2012c40:	10800317 	ldw	r2,12(r2)
 2012c44:	10000826 	beq	r2,zero,2012c68 <open+0xfc>
 2012c48:	e0bff817 	ldw	r2,-32(fp)
 2012c4c:	10800317 	ldw	r2,12(r2)
 2012c50:	e1ffff17 	ldw	r7,-4(fp)
 2012c54:	e1bffe17 	ldw	r6,-8(fp)
 2012c58:	e17ffd17 	ldw	r5,-12(fp)
 2012c5c:	e13ffc17 	ldw	r4,-16(fp)
 2012c60:	103ee83a 	callr	r2
 2012c64:	00000106 	br	2012c6c <open+0x100>
 2012c68:	0005883a 	mov	r2,zero
 2012c6c:	e0bffa15 	stw	r2,-24(fp)
 2012c70:	00000206 	br	2012c7c <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 2012c74:	00bffb44 	movi	r2,-19
 2012c78:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 2012c7c:	e0bffa17 	ldw	r2,-24(fp)
 2012c80:	1000090e 	bge	r2,zero,2012ca8 <open+0x13c>
  {
    alt_release_fd (index);  
 2012c84:	e13ff917 	ldw	r4,-28(fp)
 2012c88:	2012f280 	call	2012f28 <alt_release_fd>
    ALT_ERRNO = -status;
 2012c8c:	2012a6c0 	call	2012a6c <alt_get_errno>
 2012c90:	1007883a 	mov	r3,r2
 2012c94:	e0bffa17 	ldw	r2,-24(fp)
 2012c98:	0085c83a 	sub	r2,zero,r2
 2012c9c:	18800015 	stw	r2,0(r3)
    return -1;
 2012ca0:	00bfffc4 	movi	r2,-1
 2012ca4:	00000106 	br	2012cac <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 2012ca8:	e0bff917 	ldw	r2,-28(fp)
}
 2012cac:	e037883a 	mov	sp,fp
 2012cb0:	dfc00117 	ldw	ra,4(sp)
 2012cb4:	df000017 	ldw	fp,0(sp)
 2012cb8:	dec00204 	addi	sp,sp,8
 2012cbc:	f800283a 	ret

02012cc0 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
 2012cc0:	defff204 	addi	sp,sp,-56
 2012cc4:	dfc00a15 	stw	ra,40(sp)
 2012cc8:	df000915 	stw	fp,36(sp)
 2012ccc:	df000904 	addi	fp,sp,36
 2012cd0:	e13fff15 	stw	r4,-4(fp)
 2012cd4:	e1400215 	stw	r5,8(fp)
 2012cd8:	e1800315 	stw	r6,12(fp)
 2012cdc:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
 2012ce0:	e0800204 	addi	r2,fp,8
 2012ce4:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
 2012ce8:	e0bfff17 	ldw	r2,-4(fp)
 2012cec:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
 2012cf0:	00006f06 	br	2012eb0 <alt_printf+0x1f0>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
 2012cf4:	e0bff807 	ldb	r2,-32(fp)
 2012cf8:	10800960 	cmpeqi	r2,r2,37
 2012cfc:	1000041e 	bne	r2,zero,2012d10 <alt_printf+0x50>
        {
            alt_putchar(c);
 2012d00:	e0bff807 	ldb	r2,-32(fp)
 2012d04:	1009883a 	mov	r4,r2
 2012d08:	2012eec0 	call	2012eec <alt_putchar>
 2012d0c:	00006806 	br	2012eb0 <alt_printf+0x1f0>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
 2012d10:	e0bff717 	ldw	r2,-36(fp)
 2012d14:	10c00044 	addi	r3,r2,1
 2012d18:	e0fff715 	stw	r3,-36(fp)
 2012d1c:	10800003 	ldbu	r2,0(r2)
 2012d20:	e0bff805 	stb	r2,-32(fp)
 2012d24:	e0bff807 	ldb	r2,-32(fp)
 2012d28:	10006926 	beq	r2,zero,2012ed0 <alt_printf+0x210>
            {
                if (c == '%')
 2012d2c:	e0bff807 	ldb	r2,-32(fp)
 2012d30:	10800958 	cmpnei	r2,r2,37
 2012d34:	1000041e 	bne	r2,zero,2012d48 <alt_printf+0x88>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
 2012d38:	e0bff807 	ldb	r2,-32(fp)
 2012d3c:	1009883a 	mov	r4,r2
 2012d40:	2012eec0 	call	2012eec <alt_putchar>
 2012d44:	00005a06 	br	2012eb0 <alt_printf+0x1f0>
                } 
                else if (c == 'c')
 2012d48:	e0bff807 	ldb	r2,-32(fp)
 2012d4c:	108018d8 	cmpnei	r2,r2,99
 2012d50:	1000081e 	bne	r2,zero,2012d74 <alt_printf+0xb4>
                {
                    int v = va_arg(args, int);
 2012d54:	e0bffe17 	ldw	r2,-8(fp)
 2012d58:	10c00104 	addi	r3,r2,4
 2012d5c:	e0fffe15 	stw	r3,-8(fp)
 2012d60:	10800017 	ldw	r2,0(r2)
 2012d64:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
 2012d68:	e13ffd17 	ldw	r4,-12(fp)
 2012d6c:	2012eec0 	call	2012eec <alt_putchar>
 2012d70:	00004f06 	br	2012eb0 <alt_printf+0x1f0>
                }
                else if (c == 'x')
 2012d74:	e0bff807 	ldb	r2,-32(fp)
 2012d78:	10801e18 	cmpnei	r2,r2,120
 2012d7c:	1000341e 	bne	r2,zero,2012e50 <alt_printf+0x190>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
 2012d80:	e0bffe17 	ldw	r2,-8(fp)
 2012d84:	10c00104 	addi	r3,r2,4
 2012d88:	e0fffe15 	stw	r3,-8(fp)
 2012d8c:	10800017 	ldw	r2,0(r2)
 2012d90:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
 2012d94:	e0bffb17 	ldw	r2,-20(fp)
 2012d98:	1000031e 	bne	r2,zero,2012da8 <alt_printf+0xe8>
                    {
                        alt_putchar('0');
 2012d9c:	01000c04 	movi	r4,48
 2012da0:	2012eec0 	call	2012eec <alt_putchar>
                        continue;
 2012da4:	00004206 	br	2012eb0 <alt_printf+0x1f0>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
 2012da8:	00800704 	movi	r2,28
 2012dac:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
 2012db0:	00000306 	br	2012dc0 <alt_printf+0x100>
                        digit_shift -= 4;
 2012db4:	e0bff917 	ldw	r2,-28(fp)
 2012db8:	10bfff04 	addi	r2,r2,-4
 2012dbc:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
 2012dc0:	00c003c4 	movi	r3,15
 2012dc4:	e0bff917 	ldw	r2,-28(fp)
 2012dc8:	1884983a 	sll	r2,r3,r2
 2012dcc:	1007883a 	mov	r3,r2
 2012dd0:	e0bffb17 	ldw	r2,-20(fp)
 2012dd4:	1884703a 	and	r2,r3,r2
 2012dd8:	103ff626 	beq	r2,zero,2012db4 <__alt_mem_mem_0+0xfcff2db4>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 2012ddc:	00001906 	br	2012e44 <alt_printf+0x184>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
 2012de0:	00c003c4 	movi	r3,15
 2012de4:	e0bff917 	ldw	r2,-28(fp)
 2012de8:	1884983a 	sll	r2,r3,r2
 2012dec:	1007883a 	mov	r3,r2
 2012df0:	e0bffb17 	ldw	r2,-20(fp)
 2012df4:	1886703a 	and	r3,r3,r2
 2012df8:	e0bff917 	ldw	r2,-28(fp)
 2012dfc:	1884d83a 	srl	r2,r3,r2
 2012e00:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
 2012e04:	e0bffc17 	ldw	r2,-16(fp)
 2012e08:	108002a8 	cmpgeui	r2,r2,10
 2012e0c:	1000041e 	bne	r2,zero,2012e20 <alt_printf+0x160>
                            c = '0' + digit;
 2012e10:	e0bffc17 	ldw	r2,-16(fp)
 2012e14:	10800c04 	addi	r2,r2,48
 2012e18:	e0bff805 	stb	r2,-32(fp)
 2012e1c:	00000306 	br	2012e2c <alt_printf+0x16c>
                        else
                            c = 'a' + digit - 10;
 2012e20:	e0bffc17 	ldw	r2,-16(fp)
 2012e24:	108015c4 	addi	r2,r2,87
 2012e28:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
 2012e2c:	e0bff807 	ldb	r2,-32(fp)
 2012e30:	1009883a 	mov	r4,r2
 2012e34:	2012eec0 	call	2012eec <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 2012e38:	e0bff917 	ldw	r2,-28(fp)
 2012e3c:	10bfff04 	addi	r2,r2,-4
 2012e40:	e0bff915 	stw	r2,-28(fp)
 2012e44:	e0bff917 	ldw	r2,-28(fp)
 2012e48:	103fe50e 	bge	r2,zero,2012de0 <__alt_mem_mem_0+0xfcff2de0>
 2012e4c:	00001806 	br	2012eb0 <alt_printf+0x1f0>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
 2012e50:	e0bff807 	ldb	r2,-32(fp)
 2012e54:	10801cd8 	cmpnei	r2,r2,115
 2012e58:	1000151e 	bne	r2,zero,2012eb0 <alt_printf+0x1f0>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
 2012e5c:	e0bffe17 	ldw	r2,-8(fp)
 2012e60:	10c00104 	addi	r3,r2,4
 2012e64:	e0fffe15 	stw	r3,-8(fp)
 2012e68:	10800017 	ldw	r2,0(r2)
 2012e6c:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
 2012e70:	00000906 	br	2012e98 <alt_printf+0x1d8>
                      alt_putchar(*s++);
 2012e74:	e0bffa17 	ldw	r2,-24(fp)
 2012e78:	10c00044 	addi	r3,r2,1
 2012e7c:	e0fffa15 	stw	r3,-24(fp)
 2012e80:	10800003 	ldbu	r2,0(r2)
 2012e84:	10803fcc 	andi	r2,r2,255
 2012e88:	1080201c 	xori	r2,r2,128
 2012e8c:	10bfe004 	addi	r2,r2,-128
 2012e90:	1009883a 	mov	r4,r2
 2012e94:	2012eec0 	call	2012eec <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
 2012e98:	e0bffa17 	ldw	r2,-24(fp)
 2012e9c:	10800003 	ldbu	r2,0(r2)
 2012ea0:	10803fcc 	andi	r2,r2,255
 2012ea4:	1080201c 	xori	r2,r2,128
 2012ea8:	10bfe004 	addi	r2,r2,-128
 2012eac:	103ff11e 	bne	r2,zero,2012e74 <__alt_mem_mem_0+0xfcff2e74>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
 2012eb0:	e0bff717 	ldw	r2,-36(fp)
 2012eb4:	10c00044 	addi	r3,r2,1
 2012eb8:	e0fff715 	stw	r3,-36(fp)
 2012ebc:	10800003 	ldbu	r2,0(r2)
 2012ec0:	e0bff805 	stb	r2,-32(fp)
 2012ec4:	e0bff807 	ldb	r2,-32(fp)
 2012ec8:	103f8a1e 	bne	r2,zero,2012cf4 <__alt_mem_mem_0+0xfcff2cf4>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
 2012ecc:	00000106 	br	2012ed4 <alt_printf+0x214>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
 2012ed0:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
 2012ed4:	0001883a 	nop
 2012ed8:	e037883a 	mov	sp,fp
 2012edc:	dfc00117 	ldw	ra,4(sp)
 2012ee0:	df000017 	ldw	fp,0(sp)
 2012ee4:	dec00504 	addi	sp,sp,20
 2012ee8:	f800283a 	ret

02012eec <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
 2012eec:	defffd04 	addi	sp,sp,-12
 2012ef0:	dfc00215 	stw	ra,8(sp)
 2012ef4:	df000115 	stw	fp,4(sp)
 2012ef8:	df000104 	addi	fp,sp,4
 2012efc:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
 2012f00:	d0a00117 	ldw	r2,-32764(gp)
 2012f04:	10800217 	ldw	r2,8(r2)
 2012f08:	100b883a 	mov	r5,r2
 2012f0c:	e13fff17 	ldw	r4,-4(fp)
 2012f10:	20425440 	call	2042544 <putc>
#endif
#endif
}
 2012f14:	e037883a 	mov	sp,fp
 2012f18:	dfc00117 	ldw	ra,4(sp)
 2012f1c:	df000017 	ldw	fp,0(sp)
 2012f20:	dec00204 	addi	sp,sp,8
 2012f24:	f800283a 	ret

02012f28 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 2012f28:	defffe04 	addi	sp,sp,-8
 2012f2c:	df000115 	stw	fp,4(sp)
 2012f30:	df000104 	addi	fp,sp,4
 2012f34:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 2012f38:	e0bfff17 	ldw	r2,-4(fp)
 2012f3c:	108000d0 	cmplti	r2,r2,3
 2012f40:	10000d1e 	bne	r2,zero,2012f78 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 2012f44:	00808174 	movhi	r2,517
 2012f48:	10a61a04 	addi	r2,r2,-26520
 2012f4c:	e0ffff17 	ldw	r3,-4(fp)
 2012f50:	18c00324 	muli	r3,r3,12
 2012f54:	10c5883a 	add	r2,r2,r3
 2012f58:	10800204 	addi	r2,r2,8
 2012f5c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 2012f60:	00808174 	movhi	r2,517
 2012f64:	10a61a04 	addi	r2,r2,-26520
 2012f68:	e0ffff17 	ldw	r3,-4(fp)
 2012f6c:	18c00324 	muli	r3,r3,12
 2012f70:	10c5883a 	add	r2,r2,r3
 2012f74:	10000015 	stw	zero,0(r2)
  }
}
 2012f78:	0001883a 	nop
 2012f7c:	e037883a 	mov	sp,fp
 2012f80:	df000017 	ldw	fp,0(sp)
 2012f84:	dec00104 	addi	sp,sp,4
 2012f88:	f800283a 	ret

02012f8c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 2012f8c:	defff904 	addi	sp,sp,-28
 2012f90:	df000615 	stw	fp,24(sp)
 2012f94:	df000604 	addi	fp,sp,24
 2012f98:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2012f9c:	0005303a 	rdctl	r2,status
 2012fa0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2012fa4:	e0fffe17 	ldw	r3,-8(fp)
 2012fa8:	00bfff84 	movi	r2,-2
 2012fac:	1884703a 	and	r2,r3,r2
 2012fb0:	1001703a 	wrctl	status,r2
  
  return context;
 2012fb4:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 2012fb8:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 2012fbc:	d0a00b17 	ldw	r2,-32724(gp)
 2012fc0:	10c000c4 	addi	r3,r2,3
 2012fc4:	00bfff04 	movi	r2,-4
 2012fc8:	1884703a 	and	r2,r3,r2
 2012fcc:	d0a00b15 	stw	r2,-32724(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 2012fd0:	d0e00b17 	ldw	r3,-32724(gp)
 2012fd4:	e0bfff17 	ldw	r2,-4(fp)
 2012fd8:	1887883a 	add	r3,r3,r2
 2012fdc:	00810034 	movhi	r2,1024
 2012fe0:	10800004 	addi	r2,r2,0
 2012fe4:	10c0062e 	bgeu	r2,r3,2013000 <sbrk+0x74>
 2012fe8:	e0bffb17 	ldw	r2,-20(fp)
 2012fec:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2012ff0:	e0bffa17 	ldw	r2,-24(fp)
 2012ff4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 2012ff8:	00bfffc4 	movi	r2,-1
 2012ffc:	00000b06 	br	201302c <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 2013000:	d0a00b17 	ldw	r2,-32724(gp)
 2013004:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 2013008:	d0e00b17 	ldw	r3,-32724(gp)
 201300c:	e0bfff17 	ldw	r2,-4(fp)
 2013010:	1885883a 	add	r2,r3,r2
 2013014:	d0a00b15 	stw	r2,-32724(gp)
 2013018:	e0bffb17 	ldw	r2,-20(fp)
 201301c:	e0bffc15 	stw	r2,-16(fp)
 2013020:	e0bffc17 	ldw	r2,-16(fp)
 2013024:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 2013028:	e0bffd17 	ldw	r2,-12(fp)
} 
 201302c:	e037883a 	mov	sp,fp
 2013030:	df000017 	ldw	fp,0(sp)
 2013034:	dec00104 	addi	sp,sp,4
 2013038:	f800283a 	ret

0201303c <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 201303c:	defffd04 	addi	sp,sp,-12
 2013040:	dfc00215 	stw	ra,8(sp)
 2013044:	df000115 	stw	fp,4(sp)
 2013048:	df000104 	addi	fp,sp,4
 201304c:	e13fff15 	stw	r4,-4(fp)
	if (fd < ALT_MAX_FD)
 2013050:	e0bfff17 	ldw	r2,-4(fp)
 2013054:	10800408 	cmpgei	r2,r2,16
 2013058:	1000031e 	bne	r2,zero,2013068 <close+0x2c>
		return ALT_CLOSE (fd);
 201305c:	e13fff17 	ldw	r4,-4(fp)
 2013060:	202dfe40 	call	202dfe4 <alt_close>
 2013064:	00000206 	br	2013070 <close+0x34>
#if LWIP_SOCKET
	else
		return lwip_close((long) fd);
 2013068:	e13fff17 	ldw	r4,-4(fp)
 201306c:	202f4540 	call	202f454 <lwip_close>
#else
	else
		return -1;
#endif
}
 2013070:	e037883a 	mov	sp,fp
 2013074:	dfc00117 	ldw	ra,4(sp)
 2013078:	df000017 	ldw	fp,0(sp)
 201307c:	dec00204 	addi	sp,sp,8
 2013080:	f800283a 	ret

02013084 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 2013084:	defff904 	addi	sp,sp,-28
 2013088:	dfc00615 	stw	ra,24(sp)
 201308c:	df000515 	stw	fp,20(sp)
 2013090:	df000504 	addi	fp,sp,20
 2013094:	e13ffd15 	stw	r4,-12(fp)
 2013098:	e17ffe15 	stw	r5,-8(fp)
 201309c:	e1bfff15 	stw	r6,-4(fp)
	if (fd < ALT_MAX_FD)
 20130a0:	e0bffd17 	ldw	r2,-12(fp)
 20130a4:	10800408 	cmpgei	r2,r2,16
 20130a8:	1000051e 	bne	r2,zero,20130c0 <read+0x3c>
		return ALT_READ (fd, ptr, len);
 20130ac:	e1bfff17 	ldw	r6,-4(fp)
 20130b0:	e17ffe17 	ldw	r5,-8(fp)
 20130b4:	e13ffd17 	ldw	r4,-12(fp)
 20130b8:	202e7640 	call	202e764 <alt_read>
 20130bc:	00000706 	br	20130dc <read+0x58>
#if LWIP_SOCKET
	else
		return recvfrom(fd, ptr, len, 0, NULL, NULL);
 20130c0:	d8000115 	stw	zero,4(sp)
 20130c4:	d8000015 	stw	zero,0(sp)
 20130c8:	000f883a 	mov	r7,zero
 20130cc:	e1bfff17 	ldw	r6,-4(fp)
 20130d0:	e17ffe17 	ldw	r5,-8(fp)
 20130d4:	e13ffd17 	ldw	r4,-12(fp)
 20130d8:	202fe1c0 	call	202fe1c <lwip_recvfrom>
#else
	else
		return -1;
#endif
}
 20130dc:	e037883a 	mov	sp,fp
 20130e0:	dfc00117 	ldw	ra,4(sp)
 20130e4:	df000017 	ldw	fp,0(sp)
 20130e8:	dec00204 	addi	sp,sp,8
 20130ec:	f800283a 	ret

020130f0 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 20130f0:	defffb04 	addi	sp,sp,-20
 20130f4:	dfc00415 	stw	ra,16(sp)
 20130f8:	df000315 	stw	fp,12(sp)
 20130fc:	df000304 	addi	fp,sp,12
 2013100:	e13ffd15 	stw	r4,-12(fp)
 2013104:	e17ffe15 	stw	r5,-8(fp)
 2013108:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 201310c:	e0bffd17 	ldw	r2,-12(fp)
 2013110:	10800408 	cmpgei	r2,r2,16
 2013114:	1000051e 	bne	r2,zero,201312c <write+0x3c>
    return ALT_WRITE(fd, ptr, len);
 2013118:	e1bfff17 	ldw	r6,-4(fp)
 201311c:	e17ffe17 	ldw	r5,-8(fp)
 2013120:	e13ffd17 	ldw	r4,-12(fp)
 2013124:	202eaa00 	call	202eaa0 <alt_write>
 2013128:	00000506 	br	2013140 <write+0x50>
#if LWIP_SOCKET
  else
    return send (fd, (void*) ptr, len, 0);
 201312c:	000f883a 	mov	r7,zero
 2013130:	e1bfff17 	ldw	r6,-4(fp)
 2013134:	e17ffe17 	ldw	r5,-8(fp)
 2013138:	e13ffd17 	ldw	r4,-12(fp)
 201313c:	20304040 	call	2030404 <lwip_send>
#else
	else
		return -1;
#endif
}
 2013140:	e037883a 	mov	sp,fp
 2013144:	dfc00117 	ldw	ra,4(sp)
 2013148:	df000017 	ldw	fp,0(sp)
 201314c:	dec00204 	addi	sp,sp,8
 2013150:	f800283a 	ret

02013154 <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
 2013154:	defffc04 	addi	sp,sp,-16
 2013158:	dfc00315 	stw	ra,12(sp)
 201315c:	df000215 	stw	fp,8(sp)
 2013160:	df000204 	addi	fp,sp,8
 2013164:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif = netif->state;
 2013168:	e0bfff17 	ldw	r2,-4(fp)
 201316c:	10800917 	ldw	r2,36(r2)
 2013170:	e0bffe15 	stw	r2,-8(fp)

	/* set MAC hardware address length */
	netif->hwaddr_len = ETHARP_HWADDR_LEN;
 2013174:	e0bfff17 	ldw	r2,-4(fp)
 2013178:	00c00184 	movi	r3,6
 201317c:	10c00f05 	stb	r3,60(r2)

	/* maximum transfer unit */
	netif->mtu = IP_FRAG_MAX_MTU;
 2013180:	e0bfff17 	ldw	r2,-4(fp)
 2013184:	00c17704 	movi	r3,1500
 2013188:	10c00d0d 	sth	r3,52(r2)

	/* device capabilities */
	/* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
	netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
 201318c:	e0bfff17 	ldw	r2,-4(fp)
 2013190:	00c00384 	movi	r3,14
 2013194:	10c00f45 	stb	r3,61(r2)

	tse_mac_init(netif->num, ethernetif);
 2013198:	e0bfff17 	ldw	r2,-4(fp)
 201319c:	10801003 	ldbu	r2,64(r2)
 20131a0:	10803fcc 	andi	r2,r2,255
 20131a4:	e17ffe17 	ldw	r5,-8(fp)
 20131a8:	1009883a 	mov	r4,r2
 20131ac:	2013f9c0 	call	2013f9c <tse_mac_init>
}
 20131b0:	0001883a 	nop
 20131b4:	e037883a 	mov	sp,fp
 20131b8:	dfc00117 	ldw	ra,4(sp)
 20131bc:	df000017 	ldw	fp,0(sp)
 20131c0:	dec00204 	addi	sp,sp,8
 20131c4:	f800283a 	ret

020131c8 <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
 20131c8:	defffa04 	addi	sp,sp,-24
 20131cc:	dfc00515 	stw	ra,20(sp)
 20131d0:	df000415 	stw	fp,16(sp)
 20131d4:	df000404 	addi	fp,sp,16
 20131d8:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif = netif->state;
 20131dc:	e0bfff17 	ldw	r2,-4(fp)
 20131e0:	10800917 	ldw	r2,36(r2)
 20131e4:	e0bffd15 	stw	r2,-12(fp)
	struct pbuf *p, *nextPkt;

	if(ethernetif->lwipRxCount <= 0)
 20131e8:	e0bffd17 	ldw	r2,-12(fp)
 20131ec:	10801517 	ldw	r2,84(r2)
 20131f0:	00800216 	blt	zero,r2,20131fc <low_level_input+0x34>
		return NULL;
 20131f4:	0005883a 	mov	r2,zero
 20131f8:	00004306 	br	2013308 <low_level_input+0x140>

	//  Dump current packet if there is no memory for the next packet.
	//  The lwipRxPbuf must contain pointers to pbufs at all times.
	nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
 20131fc:	01806084 	movi	r6,386
 2013200:	01417b04 	movi	r5,1516
 2013204:	0009883a 	mov	r4,zero
 2013208:	201c9740 	call	201c974 <pbuf_alloc>
 201320c:	e0bffe15 	stw	r2,-8(fp)
	if(nextPkt == NULL)
 2013210:	e0bffe17 	ldw	r2,-8(fp)
 2013214:	1000101e 	bne	r2,zero,2013258 <low_level_input+0x90>
	{
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("no pbuf available\n"));

		LINK_STATS_INC(link.memerr);
 2013218:	008085f4 	movhi	r2,535
 201321c:	10bd8204 	addi	r2,r2,-2552
 2013220:	10800617 	ldw	r2,24(r2)
 2013224:	10c00044 	addi	r3,r2,1
 2013228:	008085f4 	movhi	r2,535
 201322c:	10bd8204 	addi	r2,r2,-2552
 2013230:	10c00615 	stw	r3,24(r2)
		LINK_STATS_INC(link.drop);
 2013234:	008085f4 	movhi	r2,535
 2013238:	10bd8204 	addi	r2,r2,-2552
 201323c:	10800317 	ldw	r2,12(r2)
 2013240:	10c00044 	addi	r3,r2,1
 2013244:	008085f4 	movhi	r2,535
 2013248:	10bd8204 	addi	r2,r2,-2552
 201324c:	10c00315 	stw	r3,12(r2)
		return NULL;
 2013250:	0005883a 	mov	r2,zero
 2013254:	00002c06 	br	2013308 <low_level_input+0x140>
	}

	nextPkt = (void*)(((alt_u32)nextPkt));
	nextPkt->payload = (void*)(((alt_u32)nextPkt->payload));
 2013258:	e0bffe17 	ldw	r2,-8(fp)
 201325c:	10c00117 	ldw	r3,4(r2)
 2013260:	e0bffe17 	ldw	r2,-8(fp)
 2013264:	10c00115 	stw	r3,4(r2)

	enh_alt_irq_disable_all();
 2013268:	202da600 	call	202da60 <enh_alt_irq_disable_all>

	p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndex];
 201326c:	e0bffd17 	ldw	r2,-12(fp)
 2013270:	10801417 	ldw	r2,80(r2)
 2013274:	e0fffd17 	ldw	r3,-12(fp)
 2013278:	108001c4 	addi	r2,r2,7
 201327c:	1085883a 	add	r2,r2,r2
 2013280:	1085883a 	add	r2,r2,r2
 2013284:	1885883a 	add	r2,r3,r2
 2013288:	10800017 	ldw	r2,0(r2)
 201328c:	e0bffc15 	stw	r2,-16(fp)
	ethernetif->lwipRxPbuf[ethernetif->lwipRxIndex] = nextPkt;
 2013290:	e0bffd17 	ldw	r2,-12(fp)
 2013294:	10801417 	ldw	r2,80(r2)
 2013298:	e0fffd17 	ldw	r3,-12(fp)
 201329c:	108001c4 	addi	r2,r2,7
 20132a0:	1085883a 	add	r2,r2,r2
 20132a4:	1085883a 	add	r2,r2,r2
 20132a8:	1885883a 	add	r2,r3,r2
 20132ac:	e0fffe17 	ldw	r3,-8(fp)
 20132b0:	10c00015 	stw	r3,0(r2)
	if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
 20132b4:	e0bffd17 	ldw	r2,-12(fp)
 20132b8:	10801417 	ldw	r2,80(r2)
 20132bc:	10800044 	addi	r2,r2,1
 20132c0:	e0fffd17 	ldw	r3,-12(fp)
 20132c4:	18801415 	stw	r2,80(r3)
 20132c8:	10800310 	cmplti	r2,r2,12
 20132cc:	1000021e 	bne	r2,zero,20132d8 <low_level_input+0x110>
		ethernetif->lwipRxIndex = 0;
 20132d0:	e0bffd17 	ldw	r2,-12(fp)
 20132d4:	10001415 	stw	zero,80(r2)

	--ethernetif->lwipRxCount;
 20132d8:	e0bffd17 	ldw	r2,-12(fp)
 20132dc:	10801517 	ldw	r2,84(r2)
 20132e0:	10ffffc4 	addi	r3,r2,-1
 20132e4:	e0bffd17 	ldw	r2,-12(fp)
 20132e8:	10c01515 	stw	r3,84(r2)

	enh_alt_irq_enable_all();
 20132ec:	202dab00 	call	202dab0 <enh_alt_irq_enable_all>

	LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
	LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );

	if( p->len == 0 )
 20132f0:	e0bffc17 	ldw	r2,-16(fp)
 20132f4:	1080028b 	ldhu	r2,10(r2)
 20132f8:	10bfffcc 	andi	r2,r2,65535
 20132fc:	1000011e 	bne	r2,zero,2013304 <low_level_input+0x13c>
		p = NULL;
 2013300:	e03ffc15 	stw	zero,-16(fp)

	return p;
 2013304:	e0bffc17 	ldw	r2,-16(fp)
}
 2013308:	e037883a 	mov	sp,fp
 201330c:	dfc00117 	ldw	ra,4(sp)
 2013310:	df000017 	ldw	fp,0(sp)
 2013314:	dec00204 	addi	sp,sp,8
 2013318:	f800283a 	ret

0201331c <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
int
ethernetif_input(struct netif *netif)
{
 201331c:	defffa04 	addi	sp,sp,-24
 2013320:	dfc00515 	stw	ra,20(sp)
 2013324:	df000415 	stw	fp,16(sp)
 2013328:	df000404 	addi	fp,sp,16
 201332c:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif;
	struct eth_hdr *ethhdr;
	struct pbuf *p;

	ethernetif = netif->state;
 2013330:	e0bfff17 	ldw	r2,-4(fp)
 2013334:	10800917 	ldw	r2,36(r2)
 2013338:	e0bffc15 	stw	r2,-16(fp)

	/* move received packet into a new pbuf */
	p = low_level_input(netif);
 201333c:	e13fff17 	ldw	r4,-4(fp)
 2013340:	20131c80 	call	20131c8 <low_level_input>
 2013344:	e0bffd15 	stw	r2,-12(fp)

	/* no packet could be read, silently ignore this */
	if (p == NULL) return -1;
 2013348:	e0bffd17 	ldw	r2,-12(fp)
 201334c:	1000021e 	bne	r2,zero,2013358 <ethernetif_input+0x3c>
 2013350:	00bfffc4 	movi	r2,-1
 2013354:	00002b06 	br	2013404 <ethernetif_input+0xe8>

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = p->payload;
 2013358:	e0bffd17 	ldw	r2,-12(fp)
 201335c:	10800117 	ldw	r2,4(r2)
 2013360:	e0bffe15 	stw	r2,-8(fp)

	LINK_STATS_INC(link.recv);
 2013364:	008085f4 	movhi	r2,535
 2013368:	10bd8204 	addi	r2,r2,-2552
 201336c:	10800117 	ldw	r2,4(r2)
 2013370:	10c00044 	addi	r3,r2,1
 2013374:	008085f4 	movhi	r2,535
 2013378:	10bd8204 	addi	r2,r2,-2552
 201337c:	10c00115 	stw	r3,4(r2)
		pbuf_free(p);
		p = NULL;
		break;
	}
#else
	switch (htons(ethhdr->type)) {
 2013380:	e0bffe17 	ldw	r2,-8(fp)
 2013384:	10c00383 	ldbu	r3,14(r2)
 2013388:	108003c3 	ldbu	r2,15(r2)
 201338c:	1004923a 	slli	r2,r2,8
 2013390:	10c4b03a 	or	r2,r2,r3
 2013394:	10bfffcc 	andi	r2,r2,65535
 2013398:	1004d23a 	srli	r2,r2,8
 201339c:	10ffffcc 	andi	r3,r2,65535
 20133a0:	e0bffe17 	ldw	r2,-8(fp)
 20133a4:	11000383 	ldbu	r4,14(r2)
 20133a8:	108003c3 	ldbu	r2,15(r2)
 20133ac:	1004923a 	slli	r2,r2,8
 20133b0:	1104b03a 	or	r2,r2,r4
 20133b4:	10bfffcc 	andi	r2,r2,65535
 20133b8:	1004923a 	slli	r2,r2,8
 20133bc:	10bfffcc 	andi	r2,r2,65535
 20133c0:	1884b03a 	or	r2,r3,r2
 20133c4:	10c20020 	cmpeqi	r3,r2,2048
 20133c8:	1800021e 	bne	r3,zero,20133d4 <ethernetif_input+0xb8>
 20133cc:	108201a0 	cmpeqi	r2,r2,2054
 20133d0:	10000626 	beq	r2,zero,20133ec <ethernetif_input+0xd0>
#if PPPOE_SUPPORT
	/* PPPoE packet? */
	case ETHTYPE_PPPOEDISC:
	case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
		netif->input(p, netif);
 20133d4:	e0bfff17 	ldw	r2,-4(fp)
 20133d8:	10800417 	ldw	r2,16(r2)
 20133dc:	e17fff17 	ldw	r5,-4(fp)
 20133e0:	e13ffd17 	ldw	r4,-12(fp)
 20133e4:	103ee83a 	callr	r2
		break;
 20133e8:	00000406 	br	20133fc <ethernetif_input+0xe0>

	default:
		pbuf_free( p );
 20133ec:	e13ffd17 	ldw	r4,-12(fp)
 20133f0:	201d2f40 	call	201d2f4 <pbuf_free>
		p = NULL;
 20133f4:	e03ffd15 	stw	zero,-12(fp)
		break;
 20133f8:	0001883a 	nop
	}
#endif

	// return the waiting packet count
	return ethernetif->lwipRxCount;
 20133fc:	e0bffc17 	ldw	r2,-16(fp)
 2013400:	10801517 	ldw	r2,84(r2)
}
 2013404:	e037883a 	mov	sp,fp
 2013408:	dfc00117 	ldw	ra,4(sp)
 201340c:	df000017 	ldw	fp,0(sp)
 2013410:	dec00204 	addi	sp,sp,8
 2013414:	f800283a 	ret

02013418 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
 2013418:	defff904 	addi	sp,sp,-28
 201341c:	dfc00615 	stw	ra,24(sp)
 2013420:	df000515 	stw	fp,20(sp)
 2013424:	df000504 	addi	fp,sp,20
 2013428:	e13fff15 	stw	r4,-4(fp)
	err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);
	char *tmpptr;

	LWIP_ASSERT("netif != NULL", (netif != NULL));

	ethernetif = mem_malloc(sizeof(struct ethernetif));
 201342c:	01001804 	movi	r4,96
 2013430:	201b1d40 	call	201b1d4 <mem_malloc>
 2013434:	e0bffc15 	stw	r2,-16(fp)
	if (ethernetif == NULL) {
 2013438:	e0bffc17 	ldw	r2,-16(fp)
 201343c:	1000021e 	bne	r2,zero,2013448 <ethernetif_init+0x30>
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("ethernetif_init: out of memory\n"));
		return ERR_MEM;
 2013440:	00bfffc4 	movi	r2,-1
 2013444:	00005b06 	br	20135b4 <ethernetif_init+0x19c>
	}

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	if (get_hostname(netif->num, (const char**)&tmpptr) == ERR_OK)
 2013448:	e0bfff17 	ldw	r2,-4(fp)
 201344c:	10801003 	ldbu	r2,64(r2)
 2013450:	10803fcc 	andi	r2,r2,255
 2013454:	e0fffe04 	addi	r3,fp,-8
 2013458:	180b883a 	mov	r5,r3
 201345c:	1009883a 	mov	r4,r2
 2013460:	200082c0 	call	200082c <get_hostname>
 2013464:	1000041e 	bne	r2,zero,2013478 <ethernetif_init+0x60>
		netif->hostname = tmpptr;
 2013468:	e0fffe17 	ldw	r3,-8(fp)
 201346c:	e0bfff17 	ldw	r2,-4(fp)
 2013470:	10c00c15 	stw	r3,48(r2)
 2013474:	00000406 	br	2013488 <ethernetif_init+0x70>
	else
		netif->hostname = "lwip";
 2013478:	e0ffff17 	ldw	r3,-4(fp)
 201347c:	00808134 	movhi	r2,516
 2013480:	109b3804 	addi	r2,r2,27872
 2013484:	18800c15 	stw	r2,48(r3)
	 * of bits per second.
	 */
	NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

	// pointer abuse, don't worry ;)
	netif->state = ethernetif;
 2013488:	e0bfff17 	ldw	r2,-4(fp)
 201348c:	e0fffc17 	ldw	r3,-16(fp)
 2013490:	10c00915 	stw	r3,36(r2)
	if (get_iface_name(netif->num, (char*)&tmpptr) == ERR_OK) {
 2013494:	e0bfff17 	ldw	r2,-4(fp)
 2013498:	10801003 	ldbu	r2,64(r2)
 201349c:	10803fcc 	andi	r2,r2,255
 20134a0:	e0fffe04 	addi	r3,fp,-8
 20134a4:	180b883a 	mov	r5,r3
 20134a8:	1009883a 	mov	r4,r2
 20134ac:	20008640 	call	2000864 <get_iface_name>
 20134b0:	1000081e 	bne	r2,zero,20134d4 <ethernetif_init+0xbc>
		netif->name[0] = ((char*)&tmpptr)[0];
 20134b4:	e0bffe04 	addi	r2,fp,-8
 20134b8:	10c00003 	ldbu	r3,0(r2)
 20134bc:	e0bfff17 	ldw	r2,-4(fp)
 20134c0:	10c00f85 	stb	r3,62(r2)
		netif->name[1] = ((char*)&tmpptr)[1];
 20134c4:	e0fffe43 	ldbu	r3,-7(fp)
 20134c8:	e0bfff17 	ldw	r2,-4(fp)
 20134cc:	10c00fc5 	stb	r3,63(r2)
 20134d0:	00000606 	br	20134ec <ethernetif_init+0xd4>
	} else {
		netif->name[0] = 'e';
 20134d4:	e0bfff17 	ldw	r2,-4(fp)
 20134d8:	00c01944 	movi	r3,101
 20134dc:	10c00f85 	stb	r3,62(r2)
		netif->name[1] = 't';
 20134e0:	e0bfff17 	ldw	r2,-4(fp)
 20134e4:	00c01d04 	movi	r3,116
 20134e8:	10c00fc5 	stb	r3,63(r2)

	/* We directly use etharp_output() here to save a function call.
	 * You can instead declare your own function an call etharp_output()
	 * from it if you have to do some checks before sending (e.g. if link
	 * is available...) */
	netif->output = etharp_output;
 20134ec:	e0ffff17 	ldw	r3,-4(fp)
 20134f0:	008080b4 	movhi	r2,514
 20134f4:	10a5c404 	addi	r2,r2,-26864
 20134f8:	18800515 	stw	r2,20(r3)
	netif->linkoutput = tse_mac_raw_send;
 20134fc:	e0ffff17 	ldw	r3,-4(fp)
 2013500:	00808074 	movhi	r2,513
 2013504:	10925304 	addi	r2,r2,18764
 2013508:	18800615 	stw	r2,24(r3)

	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
 201350c:	e0bfff17 	ldw	r2,-4(fp)
 2013510:	10c00d84 	addi	r3,r2,54
 2013514:	e0bffc17 	ldw	r2,-16(fp)
 2013518:	10c00015 	stw	r3,0(r2)

	/* initialize the rx buffer for access by the TSE ISR */
	for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
 201351c:	e03ffb15 	stw	zero,-20(fp)
 2013520:	00001806 	br	2013584 <ethernetif_init+0x16c>
	{
		p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
 2013524:	01806084 	movi	r6,386
 2013528:	01417b04 	movi	r5,1516
 201352c:	0009883a 	mov	r4,zero
 2013530:	201c9740 	call	201c974 <pbuf_alloc>
 2013534:	e0bffd15 	stw	r2,-12(fp)
		if (p == NULL)
 2013538:	e0bffd17 	ldw	r2,-12(fp)
 201353c:	1000021e 	bne	r2,zero,2013548 <ethernetif_init+0x130>
			return ERR_MEM;
 2013540:	00bfffc4 	movi	r2,-1
 2013544:	00001b06 	br	20135b4 <ethernetif_init+0x19c>
		p = (void*)(((alt_u32) p));
		p->payload = (void*)(((alt_u32) p->payload));
 2013548:	e0bffd17 	ldw	r2,-12(fp)
 201354c:	10c00117 	ldw	r3,4(r2)
 2013550:	e0bffd17 	ldw	r2,-12(fp)
 2013554:	10c00115 	stw	r3,4(r2)
		ethernetif->lwipRxPbuf[idx] = p;
 2013558:	e0fffc17 	ldw	r3,-16(fp)
 201355c:	e0bffb17 	ldw	r2,-20(fp)
 2013560:	108001c4 	addi	r2,r2,7
 2013564:	1085883a 	add	r2,r2,r2
 2013568:	1085883a 	add	r2,r2,r2
 201356c:	1885883a 	add	r2,r3,r2
 2013570:	e0fffd17 	ldw	r3,-12(fp)
 2013574:	10c00015 	stw	r3,0(r2)
	netif->linkoutput = tse_mac_raw_send;

	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);

	/* initialize the rx buffer for access by the TSE ISR */
	for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
 2013578:	e0bffb17 	ldw	r2,-20(fp)
 201357c:	10800044 	addi	r2,r2,1
 2013580:	e0bffb15 	stw	r2,-20(fp)
 2013584:	e0bffb17 	ldw	r2,-20(fp)
 2013588:	10800310 	cmplti	r2,r2,12
 201358c:	103fe51e 	bne	r2,zero,2013524 <__alt_mem_mem_0+0xfcff3524>
			return ERR_MEM;
		p = (void*)(((alt_u32) p));
		p->payload = (void*)(((alt_u32) p->payload));
		ethernetif->lwipRxPbuf[idx] = p;
	}
	ethernetif->lwipRxCount = 0;
 2013590:	e0bffc17 	ldw	r2,-16(fp)
 2013594:	10001515 	stw	zero,84(r2)
	ethernetif->lwipRxIndex = 0;
 2013598:	e0bffc17 	ldw	r2,-16(fp)
 201359c:	10001415 	stw	zero,80(r2)
	ethernetif->lwipRxIndexIsr = 0;
 20135a0:	e0bffc17 	ldw	r2,-16(fp)
 20135a4:	10001315 	stw	zero,76(r2)

	/* initialize the low level hardware */
	low_level_init(netif);
 20135a8:	e13fff17 	ldw	r4,-4(fp)
 20135ac:	20131540 	call	2013154 <low_level_init>

	return ERR_OK;
 20135b0:	0005883a 	mov	r2,zero
}
 20135b4:	e037883a 	mov	sp,fp
 20135b8:	dfc00117 	ldw	ra,4(sp)
 20135bc:	df000017 	ldw	fp,0(sp)
 20135c0:	dec00204 	addi	sp,sp,8
 20135c4:	f800283a 	ret

020135c8 <lwip_initialize>:
}
#endif

// Function which initializes the LwIP TCP/IP stack
void lwip_initialize(int waitForAll)
{
 20135c8:	defffa04 	addi	sp,sp,-24
 20135cc:	dfc00515 	stw	ra,20(sp)
 20135d0:	df000415 	stw	fp,16(sp)
 20135d4:	df000404 	addi	fp,sp,16
 20135d8:	e13fff15 	stw	r4,-4(fp)
	int idx;
	int upCount = 0;
 20135dc:	e03ffd15 	stw	zero,-12(fp)
	int activeCount = 0;
 20135e0:	e03ffe15 	stw	zero,-8(fp)
		return;
	}
#endif

	// Initialize the TCP/IP stack and give our configuration function as callback
	tcpip_init(lwip_handle_interfaces, NULL);
 20135e4:	000b883a 	mov	r5,zero
 20135e8:	01008074 	movhi	r4,513
 20135ec:	210dda04 	addi	r4,r4,14184
 20135f0:	20343780 	call	2034378 <tcpip_init>

	for (idx = 0; idx < PHY_COUNT; ++idx)
 20135f4:	e03ffc15 	stw	zero,-16(fp)
 20135f8:	00000906 	br	2013620 <lwip_initialize+0x58>
		if (is_interface_active(idx))
 20135fc:	e13ffc17 	ldw	r4,-16(fp)
 2013600:	20008ac0 	call	20008ac <is_interface_active>
 2013604:	10000326 	beq	r2,zero,2013614 <lwip_initialize+0x4c>
			++activeCount;
 2013608:	e0bffe17 	ldw	r2,-8(fp)
 201360c:	10800044 	addi	r2,r2,1
 2013610:	e0bffe15 	stw	r2,-8(fp)
#endif

	// Initialize the TCP/IP stack and give our configuration function as callback
	tcpip_init(lwip_handle_interfaces, NULL);

	for (idx = 0; idx < PHY_COUNT; ++idx)
 2013614:	e0bffc17 	ldw	r2,-16(fp)
 2013618:	10800044 	addi	r2,r2,1
 201361c:	e0bffc15 	stw	r2,-16(fp)
 2013620:	e0bffc17 	ldw	r2,-16(fp)
 2013624:	00bff50e 	bge	zero,r2,20135fc <__alt_mem_mem_0+0xfcff35fc>
		if (is_interface_active(idx))
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
 2013628:	00001d06 	br	20136a0 <lwip_initialize+0xd8>
	{
		for (idx = 0; idx < PHY_COUNT; ++idx)
 201362c:	e03ffc15 	stw	zero,-16(fp)
 2013630:	00001706 	br	2013690 <lwip_initialize+0xc8>
		{
			if (is_interface_active(idx) && netif_is_up(&eth_tse[idx]))
 2013634:	e13ffc17 	ldw	r4,-16(fp)
 2013638:	20008ac0 	call	20008ac <is_interface_active>
 201363c:	10001126 	beq	r2,zero,2013684 <lwip_initialize+0xbc>
 2013640:	00808574 	movhi	r2,533
 2013644:	10b50c04 	addi	r2,r2,-11216
 2013648:	e0fffc17 	ldw	r3,-16(fp)
 201364c:	18c01324 	muli	r3,r3,76
 2013650:	10c5883a 	add	r2,r2,r3
 2013654:	10800f44 	addi	r2,r2,61
 2013658:	10800003 	ldbu	r2,0(r2)
 201365c:	10803fcc 	andi	r2,r2,255
 2013660:	1080004c 	andi	r2,r2,1
 2013664:	10000726 	beq	r2,zero,2013684 <lwip_initialize+0xbc>
			{
				printf("[lwip_eth%d] up\r\n", idx);
 2013668:	e17ffc17 	ldw	r5,-16(fp)
 201366c:	01008134 	movhi	r4,516
 2013670:	211b3a04 	addi	r4,r4,27880
 2013674:	20009e40 	call	20009e4 <printf>
				++upCount;
 2013678:	e0bffd17 	ldw	r2,-12(fp)
 201367c:	10800044 	addi	r2,r2,1
 2013680:	e0bffd15 	stw	r2,-12(fp)
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
	{
		for (idx = 0; idx < PHY_COUNT; ++idx)
 2013684:	e0bffc17 	ldw	r2,-16(fp)
 2013688:	10800044 	addi	r2,r2,1
 201368c:	e0bffc15 	stw	r2,-16(fp)
 2013690:	e0bffc17 	ldw	r2,-16(fp)
 2013694:	00bfe70e 	bge	zero,r2,2013634 <__alt_mem_mem_0+0xfcff3634>
				printf("[lwip_eth%d] up\r\n", idx);
				++upCount;
			}
		}

		mssleep(10);
 2013698:	0109c404 	movi	r4,10000
 201369c:	202ea340 	call	202ea34 <usleep>
	for (idx = 0; idx < PHY_COUNT; ++idx)
		if (is_interface_active(idx))
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
 20136a0:	e0bfff17 	ldw	r2,-4(fp)
 20136a4:	10000326 	beq	r2,zero,20136b4 <lwip_initialize+0xec>
 20136a8:	e0fffe17 	ldw	r3,-8(fp)
 20136ac:	e0bffd17 	ldw	r2,-12(fp)
 20136b0:	18bfde1e 	bne	r3,r2,201362c <__alt_mem_mem_0+0xfcff362c>
 20136b4:	e0bfff17 	ldw	r2,-4(fp)
 20136b8:	1000021e 	bne	r2,zero,20136c4 <lwip_initialize+0xfc>
 20136bc:	e0bffd17 	ldw	r2,-12(fp)
 20136c0:	103fda26 	beq	r2,zero,201362c <__alt_mem_mem_0+0xfcff362c>
			}
		}

		mssleep(10);
	}
}
 20136c4:	0001883a 	nop
 20136c8:	e037883a 	mov	sp,fp
 20136cc:	dfc00117 	ldw	ra,4(sp)
 20136d0:	df000017 	ldw	fp,0(sp)
 20136d4:	dec00204 	addi	sp,sp,8
 20136d8:	f800283a 	ret

020136dc <lwip_wait_for_an>:
#endif

#define MAX_RETRY_COUNT			3

int lwip_wait_for_an(int idx, struct ethernetif *ethernetif)
{
 20136dc:	defffb04 	addi	sp,sp,-20
 20136e0:	dfc00415 	stw	ra,16(sp)
 20136e4:	df000315 	stw	fp,12(sp)
 20136e8:	df000304 	addi	fp,sp,12
 20136ec:	e13ffe15 	stw	r4,-8(fp)
 20136f0:	e17fff15 	stw	r5,-4(fp)
	int retryCount = MAX_RETRY_COUNT;
 20136f4:	008000c4 	movi	r2,3
 20136f8:	e0bffd15 	stw	r2,-12(fp)

	while (ethernetif->link_alive != 1 && --retryCount) {
 20136fc:	00000b06 	br	201372c <lwip_wait_for_an+0x50>
		mssleep(100 * (MAX_RETRY_COUNT - retryCount));
 2013700:	00c000c4 	movi	r3,3
 2013704:	e0bffd17 	ldw	r2,-12(fp)
 2013708:	1887c83a 	sub	r3,r3,r2
 201370c:	008000b4 	movhi	r2,2
 2013710:	10a1a804 	addi	r2,r2,-31072
 2013714:	1885383a 	mul	r2,r3,r2
 2013718:	1009883a 	mov	r4,r2
 201371c:	202ea340 	call	202ea34 <usleep>
		tse_mac_init(idx, ethernetif);
 2013720:	e17fff17 	ldw	r5,-4(fp)
 2013724:	e13ffe17 	ldw	r4,-8(fp)
 2013728:	2013f9c0 	call	2013f9c <tse_mac_init>

int lwip_wait_for_an(int idx, struct ethernetif *ethernetif)
{
	int retryCount = MAX_RETRY_COUNT;

	while (ethernetif->link_alive != 1 && --retryCount) {
 201372c:	e0bfff17 	ldw	r2,-4(fp)
 2013730:	10800217 	ldw	r2,8(r2)
 2013734:	10800060 	cmpeqi	r2,r2,1
 2013738:	1000051e 	bne	r2,zero,2013750 <lwip_wait_for_an+0x74>
 201373c:	e0bffd17 	ldw	r2,-12(fp)
 2013740:	10bfffc4 	addi	r2,r2,-1
 2013744:	e0bffd15 	stw	r2,-12(fp)
 2013748:	e0bffd17 	ldw	r2,-12(fp)
 201374c:	103fec1e 	bne	r2,zero,2013700 <__alt_mem_mem_0+0xfcff3700>
		mssleep(100 * (MAX_RETRY_COUNT - retryCount));
		tse_mac_init(idx, ethernetif);
	}

	return retryCount;
 2013750:	e0bffd17 	ldw	r2,-12(fp)
}
 2013754:	e037883a 	mov	sp,fp
 2013758:	dfc00117 	ldw	ra,4(sp)
 201375c:	df000017 	ldw	fp,0(sp)
 2013760:	dec00204 	addi	sp,sp,8
 2013764:	f800283a 	ret

02013768 <lwip_handle_interfaces>:

void lwip_handle_interfaces(__unused void *params)
{
 2013768:	deffe904 	addi	sp,sp,-92
 201376c:	dfc01615 	stw	ra,88(sp)
 2013770:	df001515 	stw	fp,84(sp)
 2013774:	df001504 	addi	fp,sp,84
 2013778:	e13fff15 	stw	r4,-4(fp)
	int idx;
	int active_macs = 0;
 201377c:	e03fef15 	stw	zero,-68(fp)
	char tmpbuf[OS_MAX_TASK_NAME_LEN];

	ip_addr_t ip = {0}, subnet = {0}, gateway = {0};
 2013780:	e03ffb15 	stw	zero,-20(fp)
 2013784:	e03ffc15 	stw	zero,-16(fp)
 2013788:	e03ffd15 	stw	zero,-12(fp)
	int dhcp;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 201378c:	e03fee15 	stw	zero,-72(fp)
 2013790:	00008006 	br	2013994 <lwip_handle_interfaces+0x22c>
	{
		struct netif *eth = &eth_tse[idx];
 2013794:	e0bfee17 	ldw	r2,-72(fp)
 2013798:	10c01324 	muli	r3,r2,76
 201379c:	00808574 	movhi	r2,533
 20137a0:	10b50c04 	addi	r2,r2,-11216
 20137a4:	1885883a 	add	r2,r3,r2
 20137a8:	e0bff015 	stw	r2,-64(fp)

		// Load platform specific MAC address into netif
		if (get_mac_addr(idx, eth, eth->hwaddr) != EXIT_SUCCESS)
 20137ac:	e0bff017 	ldw	r2,-64(fp)
 20137b0:	10800d84 	addi	r2,r2,54
 20137b4:	100d883a 	mov	r6,r2
 20137b8:	e17ff017 	ldw	r5,-64(fp)
 20137bc:	e13fee17 	ldw	r4,-72(fp)
 20137c0:	20006580 	call	2000658 <get_mac_addr>
 20137c4:	10000326 	beq	r2,zero,20137d4 <lwip_handle_interfaces+0x6c>
			printf("[LwIP] Failed to get MAC address\n");
 20137c8:	01008134 	movhi	r4,516
 20137cc:	211b3f04 	addi	r4,r4,27900
 20137d0:	20426cc0 	call	20426cc <puts>

		// Get the requested IP configuration for the given interface
		if (get_ip_addr(idx, &ip, &subnet, &gateway, &dhcp) != EXIT_SUCCESS)
 20137d4:	e17ffd04 	addi	r5,fp,-12
 20137d8:	e13ffc04 	addi	r4,fp,-16
 20137dc:	e0fffb04 	addi	r3,fp,-20
 20137e0:	e0bffe04 	addi	r2,fp,-8
 20137e4:	d8800015 	stw	r2,0(sp)
 20137e8:	280f883a 	mov	r7,r5
 20137ec:	200d883a 	mov	r6,r4
 20137f0:	180b883a 	mov	r5,r3
 20137f4:	e13fee17 	ldw	r4,-72(fp)
 20137f8:	20007740 	call	2000774 <get_ip_addr>
 20137fc:	10000326 	beq	r2,zero,201380c <lwip_handle_interfaces+0xa4>
			printf("[LwIP] Failed to get IP config\n");
 2013800:	01008134 	movhi	r4,516
 2013804:	211b4804 	addi	r4,r4,27936
 2013808:	20426cc0 	call	20426cc <puts>

		//  Initialize lwIP, Altera TSE and the ethernetif
#if NO_SYS
		if (netif_add(eth, &ip, &subnet, &gateway, eth->state, ethernetif_init, ethernet_input) == NULL)
#else
			if (netif_add(eth, &ip, &subnet, &gateway, eth->state, ethernetif_init, tcpip_input) == NULL)
 201380c:	e0bff017 	ldw	r2,-64(fp)
 2013810:	10c00917 	ldw	r3,36(r2)
 2013814:	e1bffd04 	addi	r6,fp,-12
 2013818:	e17ffc04 	addi	r5,fp,-16
 201381c:	e13ffb04 	addi	r4,fp,-20
 2013820:	008080f4 	movhi	r2,515
 2013824:	108f8a04 	addi	r2,r2,15912
 2013828:	d8800215 	stw	r2,8(sp)
 201382c:	00808074 	movhi	r2,513
 2013830:	108d0604 	addi	r2,r2,13336
 2013834:	d8800115 	stw	r2,4(sp)
 2013838:	d8c00015 	stw	r3,0(sp)
 201383c:	300f883a 	mov	r7,r6
 2013840:	280d883a 	mov	r6,r5
 2013844:	200b883a 	mov	r5,r4
 2013848:	e13ff017 	ldw	r4,-64(fp)
 201384c:	201bab80 	call	201bab8 <netif_add>
 2013850:	1000051e 	bne	r2,zero,2013868 <lwip_handle_interfaces+0x100>
#endif
			{
				printf("[eth%d] Fatal error initializing...\n", idx);
 2013854:	e17fee17 	ldw	r5,-72(fp)
 2013858:	01008134 	movhi	r4,516
 201385c:	211b5004 	addi	r4,r4,27968
 2013860:	20009e40 	call	20009e4 <printf>
				for(;;) ;
 2013864:	003fff06 	br	2013864 <__alt_mem_mem_0+0xfcff3864>
			}

		// check whether this interface should be used
		if (!is_interface_active(idx))
 2013868:	e13fee17 	ldw	r4,-72(fp)
 201386c:	20008ac0 	call	20008ac <is_interface_active>
 2013870:	10004426 	beq	r2,zero,2013984 <lwip_handle_interfaces+0x21c>
			continue;

		// update the active phy count
		++active_macs;
 2013874:	e0bfef17 	ldw	r2,-68(fp)
 2013878:	10800044 	addi	r2,r2,1
 201387c:	e0bfef15 	stw	r2,-68(fp)

		if (active_macs == 1)
 2013880:	e0bfef17 	ldw	r2,-68(fp)
 2013884:	10800058 	cmpnei	r2,r2,1
 2013888:	1000021e 	bne	r2,zero,2013894 <lwip_handle_interfaces+0x12c>
			netif_set_default(eth);
 201388c:	e13ff017 	ldw	r4,-64(fp)
 2013890:	201c1d00 	call	201c1d0 <netif_set_default>

		// Set status and link callback (link is not working?)
		netif_set_status_callback(eth, lwip_status_callback);
 2013894:	01408074 	movhi	r5,513
 2013898:	294f5b04 	addi	r5,r5,15724
 201389c:	e13ff017 	ldw	r4,-64(fp)
 20138a0:	201c3800 	call	201c380 <netif_set_status_callback>

		if (link_callback)
 20138a4:	d0a7bf17 	ldw	r2,-24836(gp)
 20138a8:	10000426 	beq	r2,zero,20138bc <lwip_handle_interfaces+0x154>
			netif_set_link_callback(eth, link_callback);
 20138ac:	d0a7bf17 	ldw	r2,-24836(gp)
 20138b0:	100b883a 	mov	r5,r2
 20138b4:	e13ff017 	ldw	r4,-64(fp)
 20138b8:	201c4dc0 	call	201c4dc <netif_set_link_callback>

		// Initialize Altera TSE in a loop if waiting for a link
		printf("Waiting for link... ");
 20138bc:	01008134 	movhi	r4,516
 20138c0:	211b5a04 	addi	r4,r4,28008
 20138c4:	20009e40 	call	20009e4 <printf>
		if (lwip_wait_for_an(idx, eth->state) < 0) {
 20138c8:	e0bff017 	ldw	r2,-64(fp)
 20138cc:	10800917 	ldw	r2,36(r2)
 20138d0:	100b883a 	mov	r5,r2
 20138d4:	e13fee17 	ldw	r4,-72(fp)
 20138d8:	20136dc0 	call	20136dc <lwip_wait_for_an>
 20138dc:	1000040e 	bge	r2,zero,20138f0 <lwip_handle_interfaces+0x188>
			printf("FAILED\n");
 20138e0:	01008134 	movhi	r4,516
 20138e4:	211b6004 	addi	r4,r4,28032
 20138e8:	20426cc0 	call	20426cc <puts>
			continue;
 20138ec:	00002606 	br	2013988 <lwip_handle_interfaces+0x220>
		}

		printf("OK\n");
 20138f0:	01008134 	movhi	r4,516
 20138f4:	211b6204 	addi	r4,r4,28040
 20138f8:	20426cc0 	call	20426cc <puts>

		// create input output task and start DHCP or static w/e
		snprintf(tmpbuf, OS_MAX_TASK_NAME_LEN, "LwIP %*sih", 2, eth->name);
 20138fc:	e0bff017 	ldw	r2,-64(fp)
 2013900:	10800f84 	addi	r2,r2,62
 2013904:	e0fff104 	addi	r3,fp,-60
 2013908:	d8800015 	stw	r2,0(sp)
 201390c:	01c00084 	movi	r7,2
 2013910:	01808134 	movhi	r6,516
 2013914:	319b6304 	addi	r6,r6,28044
 2013918:	01400a04 	movi	r5,40
 201391c:	1809883a 	mov	r4,r3
 2013920:	20427b80 	call	20427b8 <snprintf>
		tmpbuf[(OS_MAX_TASK_NAME_LEN - 1)] = 0;
 2013924:	e03ffac5 	stb	zero,-21(fp)

		// create input task, this must be started before we can do any DHCP request
		sys_thread_new(tmpbuf, lwip_handle_ethernet_input, eth, KB(32), TCPIP_THREAD_PRIO);// == NULL)
 2013928:	e0fff104 	addi	r3,fp,-60
 201392c:	008000c4 	movi	r2,3
 2013930:	d8800015 	stw	r2,0(sp)
 2013934:	01e00014 	movui	r7,32768
 2013938:	e1bff017 	ldw	r6,-64(fp)
 201393c:	01408074 	movhi	r5,513
 2013940:	294ef104 	addi	r5,r5,15300
 2013944:	1809883a 	mov	r4,r3
 2013948:	20155200 	call	2015520 <sys_thread_new>
			//printf("LwIP Couldn't create input / output task for ethernet\n");

		// wait previous DHCP to finish
		if (dhcp) {
 201394c:	e0bffe17 	ldw	r2,-8(fp)
 2013950:	10000926 	beq	r2,zero,2013978 <lwip_handle_interfaces+0x210>
			printf("[LwIP] Start DHCP request...\n");
 2013954:	01008134 	movhi	r4,516
 2013958:	211b6604 	addi	r4,r4,28056
 201395c:	20426cc0 	call	20426cc <puts>

			dhcp_start(eth);
 2013960:	e13ff017 	ldw	r4,-64(fp)
 2013964:	20162c00 	call	20162c0 <dhcp_start>

			// wait till we got our address
			printf("[LwIP] Waiting for DHCP IP address...\n");
 2013968:	01008134 	movhi	r4,516
 201396c:	211b6e04 	addi	r4,r4,28088
 2013970:	20426cc0 	call	20426cc <puts>
 2013974:	00000406 	br	2013988 <lwip_handle_interfaces+0x220>
		} else {
			// the static IP has already been set, just bring up the interface
			netif_set_up(eth);
 2013978:	e13ff017 	ldw	r4,-64(fp)
 201397c:	201c1fc0 	call	201c1fc <netif_set_up>
 2013980:	00000106 	br	2013988 <lwip_handle_interfaces+0x220>
				for(;;) ;
			}

		// check whether this interface should be used
		if (!is_interface_active(idx))
			continue;
 2013984:	0001883a 	nop
	char tmpbuf[OS_MAX_TASK_NAME_LEN];

	ip_addr_t ip = {0}, subnet = {0}, gateway = {0};
	int dhcp;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 2013988:	e0bfee17 	ldw	r2,-72(fp)
 201398c:	10800044 	addi	r2,r2,1
 2013990:	e0bfee15 	stw	r2,-72(fp)
 2013994:	e0bfee17 	ldw	r2,-72(fp)
 2013998:	00bf7e0e 	bge	zero,r2,2013794 <__alt_mem_mem_0+0xfcff3794>
		} else {
			// the static IP has already been set, just bring up the interface
			netif_set_up(eth);
		}
	}
}
 201399c:	0001883a 	nop
 20139a0:	e037883a 	mov	sp,fp
 20139a4:	dfc00117 	ldw	ra,4(sp)
 20139a8:	df000017 	ldw	fp,0(sp)
 20139ac:	dec00204 	addi	sp,sp,8
 20139b0:	f800283a 	ret

020139b4 <get_mac_count>:
 * \brief Get the number of MAC's available in the NIOS build
 *
 * \returns the number of MAC's in the NIOS build
 */
int get_mac_count(void)
{
 20139b4:	deffff04 	addi	sp,sp,-4
 20139b8:	df000015 	stw	fp,0(sp)
 20139bc:	d839883a 	mov	fp,sp
	return PHY_COUNT;
 20139c0:	00800044 	movi	r2,1
}
 20139c4:	e037883a 	mov	sp,fp
 20139c8:	df000017 	ldw	fp,0(sp)
 20139cc:	dec00104 	addi	sp,sp,4
 20139d0:	f800283a 	ret

020139d4 <get_mac_base>:
 * \param [in] idx the index of the MAC
 *
 * \returns the base address of the MAC
 */
volatile np_tse_mac* get_mac_base(int idx)
{
 20139d4:	defffe04 	addi	sp,sp,-8
 20139d8:	df000115 	stw	fp,4(sp)
 20139dc:	df000104 	addi	fp,sp,4
 20139e0:	e13fff15 	stw	r4,-4(fp)
	if (idx > PHY_COUNT)
 20139e4:	e0bfff17 	ldw	r2,-4(fp)
 20139e8:	10800090 	cmplti	r2,r2,2
 20139ec:	1000021e 	bne	r2,zero,20139f8 <get_mac_base+0x24>
		return NULL;
 20139f0:	0005883a 	mov	r2,zero
 20139f4:	00000606 	br	2013a10 <get_mac_base+0x3c>

	return (volatile np_tse_mac*)tse_mac_device[idx].tse_mac_base;
 20139f8:	00808174 	movhi	r2,517
 20139fc:	10aaaf04 	addi	r2,r2,-21828
 2013a00:	e0ffff17 	ldw	r3,-4(fp)
 2013a04:	18c01224 	muli	r3,r3,72
 2013a08:	10c5883a 	add	r2,r2,r3
 2013a0c:	10800017 	ldw	r2,0(r2)
}
 2013a10:	e037883a 	mov	sp,fp
 2013a14:	df000017 	ldw	fp,0(sp)
 2013a18:	dec00104 	addi	sp,sp,4
 2013a1c:	f800283a 	ret

02013a20 <get_netif>:
 * \brief Get the netif struct used by LwIP
 *
 * \return the reference to the netif used by LwIP
 */
struct netif* get_netif(int idx)
{
 2013a20:	defffe04 	addi	sp,sp,-8
 2013a24:	df000115 	stw	fp,4(sp)
 2013a28:	df000104 	addi	fp,sp,4
 2013a2c:	e13fff15 	stw	r4,-4(fp)
	if (idx > PHY_COUNT)
 2013a30:	e0bfff17 	ldw	r2,-4(fp)
 2013a34:	10800090 	cmplti	r2,r2,2
 2013a38:	1000021e 	bne	r2,zero,2013a44 <get_netif+0x24>
		return NULL;
 2013a3c:	0005883a 	mov	r2,zero
 2013a40:	00000506 	br	2013a58 <get_netif+0x38>

	return eth_tse + idx;
 2013a44:	e0bfff17 	ldw	r2,-4(fp)
 2013a48:	10c01324 	muli	r3,r2,76
 2013a4c:	00808574 	movhi	r2,533
 2013a50:	10b50c04 	addi	r2,r2,-11216
 2013a54:	1885883a 	add	r2,r3,r2
}
 2013a58:	e037883a 	mov	sp,fp
 2013a5c:	df000017 	ldw	fp,0(sp)
 2013a60:	dec00104 	addi	sp,sp,4
 2013a64:	f800283a 	ret

02013a68 <lwip_set_status_callback>:

netif_status_callback_fn lwip_set_status_callback(netif_status_callback_fn callback)
{
 2013a68:	defffd04 	addi	sp,sp,-12
 2013a6c:	df000215 	stw	fp,8(sp)
 2013a70:	df000204 	addi	fp,sp,8
 2013a74:	e13fff15 	stw	r4,-4(fp)
	netif_status_callback_fn old = status_callback;
 2013a78:	d0a7be17 	ldw	r2,-24840(gp)
 2013a7c:	e0bffe15 	stw	r2,-8(fp)

	status_callback = callback;
 2013a80:	e0bfff17 	ldw	r2,-4(fp)
 2013a84:	d0a7be15 	stw	r2,-24840(gp)

	return old;
 2013a88:	e0bffe17 	ldw	r2,-8(fp)
}
 2013a8c:	e037883a 	mov	sp,fp
 2013a90:	df000017 	ldw	fp,0(sp)
 2013a94:	dec00104 	addi	sp,sp,4
 2013a98:	f800283a 	ret

02013a9c <lwip_set_link_callback>:

netif_status_callback_fn lwip_set_link_callback(netif_status_callback_fn callback)
{
 2013a9c:	defffd04 	addi	sp,sp,-12
 2013aa0:	df000215 	stw	fp,8(sp)
 2013aa4:	df000204 	addi	fp,sp,8
 2013aa8:	e13fff15 	stw	r4,-4(fp)
	netif_status_callback_fn old = link_callback;
 2013aac:	d0a7bf17 	ldw	r2,-24836(gp)
 2013ab0:	e0bffe15 	stw	r2,-8(fp)

	link_callback = callback;
 2013ab4:	e0bfff17 	ldw	r2,-4(fp)
 2013ab8:	d0a7bf15 	stw	r2,-24836(gp)

	return old;
 2013abc:	e0bffe17 	ldw	r2,-8(fp)
}
 2013ac0:	e037883a 	mov	sp,fp
 2013ac4:	df000017 	ldw	fp,0(sp)
 2013ac8:	dec00104 	addi	sp,sp,4
 2013acc:	f800283a 	ret

02013ad0 <lwip_is_interface_up>:

#define REG_STATS_LS					(1 << 2)	// Link Status

int __attribute__((weak)) lwip_is_interface_up(__unused np_tse_mac* pmac)
{
 2013ad0:	defffd04 	addi	sp,sp,-12
 2013ad4:	df000215 	stw	fp,8(sp)
 2013ad8:	df000204 	addi	fp,sp,8
 2013adc:	e13fff15 	stw	r4,-4(fp)
	alt_u16 reg = IORD(&pmac->mdio1.STATUS, 0);
 2013ae0:	e0bfff17 	ldw	r2,-4(fp)
 2013ae4:	1080a104 	addi	r2,r2,644
 2013ae8:	10800037 	ldwio	r2,0(r2)
 2013aec:	e0bffe0d 	sth	r2,-8(fp)

	return ((reg & (REG_STATS_LS)) == REG_STATS_LS) ? ETH_INTERFACE_UP : ETH_INTERFACE_DOWN;
 2013af0:	e0bffe0b 	ldhu	r2,-8(fp)
 2013af4:	1080010c 	andi	r2,r2,4
 2013af8:	1004c03a 	cmpne	r2,r2,zero
 2013afc:	10803fcc 	andi	r2,r2,255
}
 2013b00:	e037883a 	mov	sp,fp
 2013b04:	df000017 	ldw	fp,0(sp)
 2013b08:	dec00104 	addi	sp,sp,4
 2013b0c:	f800283a 	ret

02013b10 <lwip_check_link_status>:

static void lwip_check_link_status(struct netif *netif, np_tse_mac* base)
{
 2013b10:	defffa04 	addi	sp,sp,-24
 2013b14:	dfc00515 	stw	ra,20(sp)
 2013b18:	df000415 	stw	fp,16(sp)
 2013b1c:	df000404 	addi	fp,sp,16
 2013b20:	e13ffe15 	stw	r4,-8(fp)
 2013b24:	e17fff15 	stw	r5,-4(fp)
	struct ethernetif *ethif = (struct ethernetif*)netif->state;
 2013b28:	e0bffe17 	ldw	r2,-8(fp)
 2013b2c:	10800917 	ldw	r2,36(r2)
 2013b30:	e0bffc15 	stw	r2,-16(fp)

	// check if the interface is up
	int cur_status = lwip_is_interface_up(base);
 2013b34:	e13fff17 	ldw	r4,-4(fp)
 2013b38:	2013ad00 	call	2013ad0 <lwip_is_interface_up>
 2013b3c:	e0bffd15 	stw	r2,-12(fp)

	// is there a state change in the ethernet connectivity
	if (cur_status != ethif->current_state)
 2013b40:	e0bffc17 	ldw	r2,-16(fp)
 2013b44:	10c01617 	ldw	r3,88(r2)
 2013b48:	e0bffd17 	ldw	r2,-12(fp)
 2013b4c:	18801726 	beq	r3,r2,2013bac <lwip_check_link_status+0x9c>
	{
		// check if the Auto-Negotiate is successful
		if (cur_status == ETH_INTERFACE_UP)
 2013b50:	e0bffd17 	ldw	r2,-12(fp)
 2013b54:	10800058 	cmpnei	r2,r2,1
 2013b58:	10000d1e 	bne	r2,zero,2013b90 <lwip_check_link_status+0x80>
		{
			// wait for auto-negotiate...
			if (lwip_wait_for_an(netif->num, ethif) > 0)
 2013b5c:	e0bffe17 	ldw	r2,-8(fp)
 2013b60:	10801003 	ldbu	r2,64(r2)
 2013b64:	10803fcc 	andi	r2,r2,255
 2013b68:	e17ffc17 	ldw	r5,-16(fp)
 2013b6c:	1009883a 	mov	r4,r2
 2013b70:	20136dc0 	call	20136dc <lwip_wait_for_an>
 2013b74:	00800d0e 	bge	zero,r2,2013bac <lwip_check_link_status+0x9c>
			{
				netif_set_link_up(netif);
 2013b78:	e13ffe17 	ldw	r4,-8(fp)
 2013b7c:	201c3bc0 	call	201c3bc <netif_set_link_up>
				ethif->current_state = cur_status;
 2013b80:	e0bffc17 	ldw	r2,-16(fp)
 2013b84:	e0fffd17 	ldw	r3,-12(fp)
 2013b88:	10c01615 	stw	r3,88(r2)

			netif_set_link_down(netif);
			ethif->current_state = cur_status;
		}
	}
}
 2013b8c:	00000706 	br	2013bac <lwip_check_link_status+0x9c>
			}
		}
		else
		{
			// bring down the link
			ethif->link_alive = 0;
 2013b90:	e0bffc17 	ldw	r2,-16(fp)
 2013b94:	10000215 	stw	zero,8(r2)

			netif_set_link_down(netif);
 2013b98:	e13ffe17 	ldw	r4,-8(fp)
 2013b9c:	201c4500 	call	201c450 <netif_set_link_down>
			ethif->current_state = cur_status;
 2013ba0:	e0bffc17 	ldw	r2,-16(fp)
 2013ba4:	e0fffd17 	ldw	r3,-12(fp)
 2013ba8:	10c01615 	stw	r3,88(r2)
		}
	}
}
 2013bac:	0001883a 	nop
 2013bb0:	e037883a 	mov	sp,fp
 2013bb4:	dfc00117 	ldw	ra,4(sp)
 2013bb8:	df000017 	ldw	fp,0(sp)
 2013bbc:	dec00204 	addi	sp,sp,8
 2013bc0:	f800283a 	ret

02013bc4 <lwip_handle_ethernet_input>:

#define NR_TEST_PACKETS						50000

// Input / monitor task per ethernet device
static void lwip_handle_ethernet_input(void *pvParameters)
{
 2013bc4:	defe7004 	addi	sp,sp,-1600
 2013bc8:	dfc18f15 	stw	ra,1596(sp)
 2013bcc:	df018e15 	stw	fp,1592(sp)
 2013bd0:	df018e04 	addi	fp,sp,1592
 2013bd4:	e13fff15 	stw	r4,-4(fp)
	sys_sem_t rcvsem;
	err_t err;
	np_tse_mac* base = NULL;
 2013bd8:	e03e7315 	stw	zero,-1588(fp)
	struct netif *cur_netif = (struct netif*)pvParameters;
 2013bdc:	e0bfff17 	ldw	r2,-4(fp)
 2013be0:	e0be7415 	stw	r2,-1584(fp)
	struct ethernetif *cur_ethif = (struct ethernetif*)cur_netif->state;
 2013be4:	e0be7417 	ldw	r2,-1584(fp)
 2013be8:	10800917 	ldw	r2,36(r2)
 2013bec:	e0be7515 	stw	r2,-1580(fp)
	int packets_waiting = 0;
 2013bf0:	e03e7215 	stw	zero,-1592(fp)

	/* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
	char buf2[1560]; // TODO remove
	int replug_state = 0; // TODO remove
 2013bf4:	e03e7615 	stw	zero,-1576(fp)

	err = sys_sem_new(&rcvsem, 0);
 2013bf8:	e0be7804 	addi	r2,fp,-1568
 2013bfc:	000b883a 	mov	r5,zero
 2013c00:	1009883a 	mov	r4,r2
 2013c04:	2014f380 	call	2014f38 <sys_sem_new>
 2013c08:	e0be7705 	stb	r2,-1572(fp)
	if (err != ERR_OK) {
 2013c0c:	e0be7707 	ldb	r2,-1572(fp)
 2013c10:	1000201e 	bne	r2,zero,2013c94 <lwip_handle_ethernet_input+0xd0>
		return;
	}

#if LWIP_RECEIVE_SEMAPHORE
	rcvsem = cur_ethif->tse_info->rx_semaphore;
 2013c14:	e0be7517 	ldw	r2,-1580(fp)
 2013c18:	10801717 	ldw	r2,92(r2)
 2013c1c:	10800817 	ldw	r2,32(r2)
 2013c20:	e0be7815 	stw	r2,-1568(fp)
#endif

	// get the actual MAC peripheral
	base = get_mac_base(cur_netif->num);
 2013c24:	e0be7417 	ldw	r2,-1584(fp)
 2013c28:	10801003 	ldbu	r2,64(r2)
 2013c2c:	10803fcc 	andi	r2,r2,255
 2013c30:	1009883a 	mov	r4,r2
 2013c34:	20139d40 	call	20139d4 <get_mac_base>
 2013c38:	e0be7315 	stw	r2,-1588(fp)
	if (!base)
 2013c3c:	e0be7317 	ldw	r2,-1588(fp)
 2013c40:	10001626 	beq	r2,zero,2013c9c <lwip_handle_ethernet_input+0xd8>
	// else we'll poll the function once every 100ms
		while (1) {
		// if we have a semaphore wait for it to be released by the SGDMA IRQ, or sleep for 1 ms
			// if we timeout also call ethernetif_input although most likely it would be useless
			// it is use full however to check the link status
		if (sys_sem_valid(&rcvsem))
 2013c44:	e0be7817 	ldw	r2,-1568(fp)
 2013c48:	10000526 	beq	r2,zero,2013c60 <lwip_handle_ethernet_input+0x9c>
			sys_arch_sem_wait(&rcvsem, 100);
 2013c4c:	e0be7804 	addi	r2,fp,-1568
 2013c50:	01401904 	movi	r5,100
 2013c54:	1009883a 	mov	r4,r2
 2013c58:	20150800 	call	2015080 <sys_arch_sem_wait>
 2013c5c:	00000406 	br	2013c70 <lwip_handle_ethernet_input+0xac>
		else if (packets_waiting <= 0)	// only sleep if there are no packets waiting
 2013c60:	e0be7217 	ldw	r2,-1592(fp)
 2013c64:	00800216 	blt	zero,r2,2013c70 <lwip_handle_ethernet_input+0xac>
			mssleep(1);					// sleep a bit to be nice to the CPU
 2013c68:	0100fa04 	movi	r4,1000
 2013c6c:	202ea340 	call	202ea34 <usleep>

			// Use semaphore or the timeout to call ethernet_input
			// this to avoid unnecessary load and faster responses ;)
		packets_waiting = ethernetif_input(cur_netif);
 2013c70:	e13e7417 	ldw	r4,-1584(fp)
 2013c74:	201331c0 	call	201331c <ethernetif_input>
 2013c78:	e0be7215 	stw	r2,-1592(fp)

		// check the link status if there are no packets waiting
		if (packets_waiting <= 0)
 2013c7c:	e0be7217 	ldw	r2,-1592(fp)
 2013c80:	00bff016 	blt	zero,r2,2013c44 <__alt_mem_mem_0+0xfcff3c44>
			lwip_check_link_status(cur_netif, base);
 2013c84:	e17e7317 	ldw	r5,-1588(fp)
 2013c88:	e13e7417 	ldw	r4,-1584(fp)
 2013c8c:	2013b100 	call	2013b10 <lwip_check_link_status>
	}
 2013c90:	003fec06 	br	2013c44 <__alt_mem_mem_0+0xfcff3c44>
	char buf2[1560]; // TODO remove
	int replug_state = 0; // TODO remove

	err = sys_sem_new(&rcvsem, 0);
	if (err != ERR_OK) {
		return;
 2013c94:	0001883a 	nop
 2013c98:	00000106 	br	2013ca0 <lwip_handle_ethernet_input+0xdc>
#endif

	// get the actual MAC peripheral
	base = get_mac_base(cur_netif->num);
	if (!base)
		return;
 2013c9c:	0001883a 	nop

		// check the link status if there are no packets waiting
		if (packets_waiting <= 0)
			lwip_check_link_status(cur_netif, base);
	}
}
 2013ca0:	e037883a 	mov	sp,fp
 2013ca4:	dfc00117 	ldw	ra,4(sp)
 2013ca8:	df000017 	ldw	fp,0(sp)
 2013cac:	dec00204 	addi	sp,sp,8
 2013cb0:	f800283a 	ret

02013cb4 <print_ipad>:

const char* print_ipad(alt_u32 ip, char* buf)
{
 2013cb4:	defff704 	addi	sp,sp,-36
 2013cb8:	dfc00815 	stw	ra,32(sp)
 2013cbc:	df000715 	stw	fp,28(sp)
 2013cc0:	df000704 	addi	fp,sp,28
 2013cc4:	e13ffe15 	stw	r4,-8(fp)
 2013cc8:	e17fff15 	stw	r5,-4(fp)
	alt_u8 bip[4];
	alt_u32 idx = 0;
 2013ccc:	e03ffc15 	stw	zero,-16(fp)

	for (; idx < sizeof(bip); idx++) {
 2013cd0:	00000c06 	br	2013d04 <print_ipad+0x50>
		bip[idx] = ip & 0xFF;
 2013cd4:	e0bffe17 	ldw	r2,-8(fp)
 2013cd8:	1009883a 	mov	r4,r2
 2013cdc:	e0fffd04 	addi	r3,fp,-12
 2013ce0:	e0bffc17 	ldw	r2,-16(fp)
 2013ce4:	1885883a 	add	r2,r3,r2
 2013ce8:	11000005 	stb	r4,0(r2)
		ip >>= 8;
 2013cec:	e0bffe17 	ldw	r2,-8(fp)
 2013cf0:	1004d23a 	srli	r2,r2,8
 2013cf4:	e0bffe15 	stw	r2,-8(fp)
const char* print_ipad(alt_u32 ip, char* buf)
{
	alt_u8 bip[4];
	alt_u32 idx = 0;

	for (; idx < sizeof(bip); idx++) {
 2013cf8:	e0bffc17 	ldw	r2,-16(fp)
 2013cfc:	10800044 	addi	r2,r2,1
 2013d00:	e0bffc15 	stw	r2,-16(fp)
 2013d04:	e0bffc17 	ldw	r2,-16(fp)
 2013d08:	10800130 	cmpltui	r2,r2,4
 2013d0c:	103ff11e 	bne	r2,zero,2013cd4 <__alt_mem_mem_0+0xfcff3cd4>
		bip[idx] = ip & 0xFF;
		ip >>= 8;
	}

	snprintf(buf, 17, "%d.%d.%d.%d", bip[0], bip[1], bip[2], bip[3]);
 2013d10:	e0bffd03 	ldbu	r2,-12(fp)
 2013d14:	11403fcc 	andi	r5,r2,255
 2013d18:	e0bffd43 	ldbu	r2,-11(fp)
 2013d1c:	10803fcc 	andi	r2,r2,255
 2013d20:	e0fffd83 	ldbu	r3,-10(fp)
 2013d24:	18c03fcc 	andi	r3,r3,255
 2013d28:	e13ffdc3 	ldbu	r4,-9(fp)
 2013d2c:	21003fcc 	andi	r4,r4,255
 2013d30:	d9000215 	stw	r4,8(sp)
 2013d34:	d8c00115 	stw	r3,4(sp)
 2013d38:	d8800015 	stw	r2,0(sp)
 2013d3c:	280f883a 	mov	r7,r5
 2013d40:	01808134 	movhi	r6,516
 2013d44:	319b7804 	addi	r6,r6,28128
 2013d48:	01400444 	movi	r5,17
 2013d4c:	e13fff17 	ldw	r4,-4(fp)
 2013d50:	20427b80 	call	20427b8 <snprintf>

	return buf;
 2013d54:	e0bfff17 	ldw	r2,-4(fp)
}
 2013d58:	e037883a 	mov	sp,fp
 2013d5c:	dfc00117 	ldw	ra,4(sp)
 2013d60:	df000017 	ldw	fp,0(sp)
 2013d64:	dec00204 	addi	sp,sp,8
 2013d68:	f800283a 	ret

02013d6c <lwip_status_callback>:

static void lwip_status_callback(struct netif *netif)
{
 2013d6c:	defffd04 	addi	sp,sp,-12
 2013d70:	dfc00215 	stw	ra,8(sp)
 2013d74:	df000115 	stw	fp,4(sp)
 2013d78:	df000104 	addi	fp,sp,4
 2013d7c:	e13fff15 	stw	r4,-4(fp)
	if (status_callback)
 2013d80:	d0a7be17 	ldw	r2,-24840(gp)
 2013d84:	10000326 	beq	r2,zero,2013d94 <lwip_status_callback+0x28>
		status_callback(netif);
 2013d88:	d0a7be17 	ldw	r2,-24840(gp)
 2013d8c:	e13fff17 	ldw	r4,-4(fp)
 2013d90:	103ee83a 	callr	r2
}
 2013d94:	0001883a 	nop
 2013d98:	e037883a 	mov	sp,fp
 2013d9c:	dfc00117 	ldw	ra,4(sp)
 2013da0:	df000017 	ldw	fp,0(sp)
 2013da4:	dec00204 	addi	sp,sp,8
 2013da8:	f800283a 	ret

02013dac <lwip_initialize_phys>:

void lwip_initialize_phys(void)
{
 2013dac:	defff604 	addi	sp,sp,-40
 2013db0:	dfc00915 	stw	ra,36(sp)
 2013db4:	df000815 	stw	fp,32(sp)
 2013db8:	df000804 	addi	fp,sp,32
	int idx, phyadd, phyid, phyid2;
	np_tse_mac *pmac;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 2013dbc:	e03ff815 	stw	zero,-32(fp)
 2013dc0:	00006e06 	br	2013f7c <lwip_initialize_phys+0x1d0>
	{
		// check whether this interface should be used
		if (!is_interface_active(idx))
 2013dc4:	e13ff817 	ldw	r4,-32(fp)
 2013dc8:	20008ac0 	call	20008ac <is_interface_active>
 2013dcc:	10006326 	beq	r2,zero,2013f5c <lwip_initialize_phys+0x1b0>
			continue;

		// the PHY is active... let's get the mac base
		pmac = get_mac_base(idx);
 2013dd0:	e13ff817 	ldw	r4,-32(fp)
 2013dd4:	20139d40 	call	20139d4 <get_mac_base>
 2013dd8:	e0bffd15 	stw	r2,-12(fp)
		if (!pmac)
 2013ddc:	e0bffd17 	ldw	r2,-12(fp)
 2013de0:	10006026 	beq	r2,zero,2013f64 <lwip_initialize_phys+0x1b8>
			continue;

		// search the PHY and it's ID
		for (phyadd = 0x00; phyadd < 0x20; ++phyadd)
 2013de4:	e03ff915 	stw	zero,-28(fp)
 2013de8:	00001206 	br	2013e34 <lwip_initialize_phys+0x88>
		{
			IOWR(&pmac->MDIO_ADDR1, 0, phyadd);
 2013dec:	e0bffd17 	ldw	r2,-12(fp)
 2013df0:	10801004 	addi	r2,r2,64
 2013df4:	e0fff917 	ldw	r3,-28(fp)
 2013df8:	10c00035 	stwio	r3,0(r2)

			phyid = IORD(&pmac->mdio1.PHY_ID1, 0);
 2013dfc:	e0bffd17 	ldw	r2,-12(fp)
 2013e00:	1080a204 	addi	r2,r2,648
 2013e04:	10800037 	ldwio	r2,0(r2)
 2013e08:	e0bffa15 	stw	r2,-24(fp)
			phyid2 = IORD(&pmac->mdio1.PHY_ID2, 0);
 2013e0c:	e0bffd17 	ldw	r2,-12(fp)
 2013e10:	1080a304 	addi	r2,r2,652
 2013e14:	10800037 	ldwio	r2,0(r2)
 2013e18:	e0bffb15 	stw	r2,-20(fp)

			if (phyid != phyid2)
 2013e1c:	e0fffa17 	ldw	r3,-24(fp)
 2013e20:	e0bffb17 	ldw	r2,-20(fp)
 2013e24:	1880071e 	bne	r3,r2,2013e44 <lwip_initialize_phys+0x98>
		pmac = get_mac_base(idx);
		if (!pmac)
			continue;

		// search the PHY and it's ID
		for (phyadd = 0x00; phyadd < 0x20; ++phyadd)
 2013e28:	e0bff917 	ldw	r2,-28(fp)
 2013e2c:	10800044 	addi	r2,r2,1
 2013e30:	e0bff915 	stw	r2,-28(fp)
 2013e34:	e0bff917 	ldw	r2,-28(fp)
 2013e38:	10800810 	cmplti	r2,r2,32
 2013e3c:	103feb1e 	bne	r2,zero,2013dec <__alt_mem_mem_0+0xfcff3dec>
 2013e40:	00000106 	br	2013e48 <lwip_initialize_phys+0x9c>

			phyid = IORD(&pmac->mdio1.PHY_ID1, 0);
			phyid2 = IORD(&pmac->mdio1.PHY_ID2, 0);

			if (phyid != phyid2)
				break;
 2013e44:	0001883a 	nop
		}

		// if we have the PHY we can initialize it if we can find the driver in the pphy_profiles array
		if (phyid != phyid2)
 2013e48:	e0fffa17 	ldw	r3,-24(fp)
 2013e4c:	e0bffb17 	ldw	r2,-20(fp)
 2013e50:	18804726 	beq	r3,r2,2013f70 <lwip_initialize_phys+0x1c4>
            extern alt_tse_phy_profile *pphy_profiles[];
            extern alt_u8 phy_profile_count;

            int i;

            for(i = 0; i < phy_profile_count; i++) {
 2013e54:	e03ffc15 	stw	zero,-16(fp)
 2013e58:	00003b06 	br	2013f48 <lwip_initialize_phys+0x19c>
                alt_u32 oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 2013e5c:	e0bffa17 	ldw	r2,-24(fp)
 2013e60:	100691ba 	slli	r3,r2,6
 2013e64:	e0bffb17 	ldw	r2,-20(fp)
 2013e68:	1005d2ba 	srai	r2,r2,10
 2013e6c:	10800fcc 	andi	r2,r2,63
 2013e70:	1884b03a 	or	r2,r3,r2
 2013e74:	e0bffe15 	stw	r2,-8(fp)
                alt_u8 model_number = (phyid2 >> 4) & 0x3f;
 2013e78:	e0bffb17 	ldw	r2,-20(fp)
 2013e7c:	1005d13a 	srai	r2,r2,4
 2013e80:	10800fcc 	andi	r2,r2,63
 2013e84:	e0bfff05 	stb	r2,-4(fp)
                // unused so far... alt_u8 revision_number = phyid2 & 0x0f;

                // if PHY match with PHY in profile we can call the initialize function
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 2013e88:	008085f4 	movhi	r2,535
 2013e8c:	10be3a04 	addi	r2,r2,-1816
 2013e90:	e0fffc17 	ldw	r3,-16(fp)
 2013e94:	18c7883a 	add	r3,r3,r3
 2013e98:	18c7883a 	add	r3,r3,r3
 2013e9c:	10c5883a 	add	r2,r2,r3
 2013ea0:	10800017 	ldw	r2,0(r2)
 2013ea4:	10c01417 	ldw	r3,80(r2)
 2013ea8:	e0bffe17 	ldw	r2,-8(fp)
 2013eac:	1880231e 	bne	r3,r2,2013f3c <lwip_initialize_phys+0x190>
 2013eb0:	008085f4 	movhi	r2,535
 2013eb4:	10be3a04 	addi	r2,r2,-1816
 2013eb8:	e0fffc17 	ldw	r3,-16(fp)
 2013ebc:	18c7883a 	add	r3,r3,r3
 2013ec0:	18c7883a 	add	r3,r3,r3
 2013ec4:	10c5883a 	add	r2,r2,r3
 2013ec8:	10800017 	ldw	r2,0(r2)
 2013ecc:	10801503 	ldbu	r2,84(r2)
 2013ed0:	10c03fcc 	andi	r3,r2,255
 2013ed4:	e0bfff03 	ldbu	r2,-4(fp)
 2013ed8:	1880181e 	bne	r3,r2,2013f3c <lwip_initialize_phys+0x190>
                {
                    if (pphy_profiles[i]->phy_cfg)
 2013edc:	008085f4 	movhi	r2,535
 2013ee0:	10be3a04 	addi	r2,r2,-1816
 2013ee4:	e0fffc17 	ldw	r3,-16(fp)
 2013ee8:	18c7883a 	add	r3,r3,r3
 2013eec:	18c7883a 	add	r3,r3,r3
 2013ef0:	10c5883a 	add	r2,r2,r3
 2013ef4:	10800017 	ldw	r2,0(r2)
 2013ef8:	10801717 	ldw	r2,92(r2)
 2013efc:	10001b26 	beq	r2,zero,2013f6c <lwip_initialize_phys+0x1c0>
                    {
                    	// initialize the PHY
                    	pphy_profiles[i]->phy_cfg(pmac);
 2013f00:	008085f4 	movhi	r2,535
 2013f04:	10be3a04 	addi	r2,r2,-1816
 2013f08:	e0fffc17 	ldw	r3,-16(fp)
 2013f0c:	18c7883a 	add	r3,r3,r3
 2013f10:	18c7883a 	add	r3,r3,r3
 2013f14:	10c5883a 	add	r2,r2,r3
 2013f18:	10800017 	ldw	r2,0(r2)
 2013f1c:	10801717 	ldw	r2,92(r2)
 2013f20:	e13ffd17 	ldw	r4,-12(fp)
 2013f24:	103ee83a 	callr	r2

                    	// and restart the Auto-Negotiation
                    	IOWR(&pmac->mdio1.CONTROL, 0, (1<<12 | 1<<9));
 2013f28:	e0bffd17 	ldw	r2,-12(fp)
 2013f2c:	1080a004 	addi	r2,r2,640
 2013f30:	00c48004 	movi	r3,4608
 2013f34:	10c00035 	stwio	r3,0(r2)
                    }

                    // and done for this PHY
                    break;
 2013f38:	00000c06 	br	2013f6c <lwip_initialize_phys+0x1c0>
            extern alt_tse_phy_profile *pphy_profiles[];
            extern alt_u8 phy_profile_count;

            int i;

            for(i = 0; i < phy_profile_count; i++) {
 2013f3c:	e0bffc17 	ldw	r2,-16(fp)
 2013f40:	10800044 	addi	r2,r2,1
 2013f44:	e0bffc15 	stw	r2,-16(fp)
 2013f48:	d0a80003 	ldbu	r2,-24576(gp)
 2013f4c:	10803fcc 	andi	r2,r2,255
 2013f50:	e0fffc17 	ldw	r3,-16(fp)
 2013f54:	18bfc116 	blt	r3,r2,2013e5c <__alt_mem_mem_0+0xfcff3e5c>
 2013f58:	00000506 	br	2013f70 <lwip_initialize_phys+0x1c4>

	for (idx = 0; idx < PHY_COUNT; ++idx)
	{
		// check whether this interface should be used
		if (!is_interface_active(idx))
			continue;
 2013f5c:	0001883a 	nop
 2013f60:	00000306 	br	2013f70 <lwip_initialize_phys+0x1c4>

		// the PHY is active... let's get the mac base
		pmac = get_mac_base(idx);
		if (!pmac)
			continue;
 2013f64:	0001883a 	nop
 2013f68:	00000106 	br	2013f70 <lwip_initialize_phys+0x1c4>
                    	// and restart the Auto-Negotiation
                    	IOWR(&pmac->mdio1.CONTROL, 0, (1<<12 | 1<<9));
                    }

                    // and done for this PHY
                    break;
 2013f6c:	0001883a 	nop
void lwip_initialize_phys(void)
{
	int idx, phyadd, phyid, phyid2;
	np_tse_mac *pmac;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 2013f70:	e0bff817 	ldw	r2,-32(fp)
 2013f74:	10800044 	addi	r2,r2,1
 2013f78:	e0bff815 	stw	r2,-32(fp)
 2013f7c:	e0bff817 	ldw	r2,-32(fp)
 2013f80:	00bf900e 	bge	zero,r2,2013dc4 <__alt_mem_mem_0+0xfcff3dc4>
                    break;
                }
            }
		}
	}
}
 2013f84:	0001883a 	nop
 2013f88:	e037883a 	mov	sp,fp
 2013f8c:	dfc00117 	ldw	ra,4(sp)
 2013f90:	df000017 	ldw	fp,0(sp)
 2013f94:	dec00204 	addi	sp,sp,8
 2013f98:	f800283a 	ret

02013f9c <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
 2013f9c:	defff004 	addi	sp,sp,-64
 2013fa0:	dfc00f15 	stw	ra,60(sp)
 2013fa4:	df000e15 	stw	fp,56(sp)
 2013fa8:	df000e04 	addi	fp,sp,56
 2013fac:	e13ffe15 	stw	r4,-8(fp)
 2013fb0:	e17fff15 	stw	r5,-4(fp)
	int speed, duplex, result;
	int x;

	alt_sgdma_dev *sgdma_tx_dev;
	alt_sgdma_dev *sgdma_rx_dev;
	alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 2013fb4:	00808574 	movhi	r2,533
 2013fb8:	10b51f04 	addi	r2,r2,-11140
 2013fbc:	e0fffe17 	ldw	r3,-8(fp)
 2013fc0:	18c00924 	muli	r3,r3,36
 2013fc4:	10c5883a 	add	r2,r2,r3
 2013fc8:	10800704 	addi	r2,r2,28
 2013fcc:	10800017 	ldw	r2,0(r2)
 2013fd0:	e0bff715 	stw	r2,-36(fp)
	np_tse_mac *mi_base;
	alt_tse_mac_info *pmac_info;

#if LWIP_RECEIVE_SEMAPHORE
	if (sys_sem_valid(&tse[iface].rx_semaphore)==0) {
 2013fd4:	e0bffe17 	ldw	r2,-8(fp)
 2013fd8:	10800924 	muli	r2,r2,36
 2013fdc:	10c00804 	addi	r3,r2,32
 2013fe0:	00808574 	movhi	r2,533
 2013fe4:	10b51f04 	addi	r2,r2,-11140
 2013fe8:	1885883a 	add	r2,r3,r2
 2013fec:	10000a26 	beq	r2,zero,2014018 <tse_mac_init+0x7c>
 2013ff0:	00808574 	movhi	r2,533
 2013ff4:	10b51f04 	addi	r2,r2,-11140
 2013ff8:	e0fffe17 	ldw	r3,-8(fp)
 2013ffc:	18c00924 	muli	r3,r3,36
 2014000:	10c5883a 	add	r2,r2,r3
 2014004:	10800804 	addi	r2,r2,32
 2014008:	10800017 	ldw	r2,0(r2)
 201400c:	10000226 	beq	r2,zero,2014018 <tse_mac_init+0x7c>
 2014010:	00800044 	movi	r2,1
 2014014:	00000106 	br	201401c <tse_mac_init+0x80>
 2014018:	0005883a 	mov	r2,zero
 201401c:	10001e1e 	bne	r2,zero,2014098 <tse_mac_init+0xfc>
		dprintf(("creating RX SGDMA semaphore\n"));
		// create a counting semaphore so we can 'release' the semaphore for each rx input buffer filled
		if (sys_sem_new(&tse[iface].rx_semaphore, LWIP_RX_ETH_BUFFER) != ERR_OK) {
 2014020:	e0bffe17 	ldw	r2,-8(fp)
 2014024:	10800924 	muli	r2,r2,36
 2014028:	10c00804 	addi	r3,r2,32
 201402c:	00808574 	movhi	r2,533
 2014030:	10b51f04 	addi	r2,r2,-11140
 2014034:	1885883a 	add	r2,r3,r2
 2014038:	01400304 	movi	r5,12
 201403c:	1009883a 	mov	r4,r2
 2014040:	2014f380 	call	2014f38 <sys_sem_new>
 2014044:	10803fcc 	andi	r2,r2,255
 2014048:	1080201c 	xori	r2,r2,128
 201404c:	10bfe004 	addi	r2,r2,-128
 2014050:	1000111e 	bne	r2,zero,2014098 <tse_mac_init+0xfc>
			dprintf(("[LwIP] Couldn't create the rx_semephore\n"));
		} else {
			// we got a semaphore, completely lock it
			for (x = 0; x < LWIP_RX_ETH_BUFFER; x++)
 2014054:	e03ff515 	stw	zero,-44(fp)
 2014058:	00000c06 	br	201408c <tse_mac_init+0xf0>
				sys_arch_sem_wait(&tse[iface].rx_semaphore, 1);
 201405c:	e0bffe17 	ldw	r2,-8(fp)
 2014060:	10800924 	muli	r2,r2,36
 2014064:	10c00804 	addi	r3,r2,32
 2014068:	00808574 	movhi	r2,533
 201406c:	10b51f04 	addi	r2,r2,-11140
 2014070:	1885883a 	add	r2,r3,r2
 2014074:	01400044 	movi	r5,1
 2014078:	1009883a 	mov	r4,r2
 201407c:	20150800 	call	2015080 <sys_arch_sem_wait>
		// create a counting semaphore so we can 'release' the semaphore for each rx input buffer filled
		if (sys_sem_new(&tse[iface].rx_semaphore, LWIP_RX_ETH_BUFFER) != ERR_OK) {
			dprintf(("[LwIP] Couldn't create the rx_semephore\n"));
		} else {
			// we got a semaphore, completely lock it
			for (x = 0; x < LWIP_RX_ETH_BUFFER; x++)
 2014080:	e0bff517 	ldw	r2,-44(fp)
 2014084:	10800044 	addi	r2,r2,1
 2014088:	e0bff515 	stw	r2,-44(fp)
 201408c:	e0bff517 	ldw	r2,-44(fp)
 2014090:	10800310 	cmplti	r2,r2,12
 2014094:	103ff11e 	bne	r2,zero,201405c <__alt_mem_mem_0+0xfcff405c>
	dprintf(("[tse_mac_init]\n"));
#ifdef PRINTIF
	dprintf(("tse_mac_init %d\n", iface));
#endif    
	// These lines were done in prep_tse_mac
	tse_hw = &tse_mac_device[iface];
 2014098:	e0bffe17 	ldw	r2,-8(fp)
 201409c:	10c01224 	muli	r3,r2,72
 20140a0:	00808174 	movhi	r2,517
 20140a4:	10aaaf04 	addi	r2,r2,-21828
 20140a8:	1885883a 	add	r2,r3,r2
 20140ac:	e0bff715 	stw	r2,-36(fp)
	tse[iface].tse = tse_hw;
 20140b0:	00808574 	movhi	r2,533
 20140b4:	10b51f04 	addi	r2,r2,-11140
 20140b8:	e0fffe17 	ldw	r3,-8(fp)
 20140bc:	18c00924 	muli	r3,r3,36
 20140c0:	10c5883a 	add	r2,r2,r3
 20140c4:	10800704 	addi	r2,r2,28
 20140c8:	e0fff717 	ldw	r3,-36(fp)
 20140cc:	10c00015 	stw	r3,0(r2)

	// Store ethernetif for access, and the tse in ethernetif for access in tse_mac_raw_send/tse_mac_rcv
	tse[iface].ethernetif = ethernetif;
 20140d0:	00808574 	movhi	r2,533
 20140d4:	10b51f04 	addi	r2,r2,-11140
 20140d8:	e0fffe17 	ldw	r3,-8(fp)
 20140dc:	18c00924 	muli	r3,r3,36
 20140e0:	10c5883a 	add	r2,r2,r3
 20140e4:	10800604 	addi	r2,r2,24
 20140e8:	e0ffff17 	ldw	r3,-4(fp)
 20140ec:	10c00015 	stw	r3,0(r2)
	ethernetif->iface = iface;
 20140f0:	e0bfff17 	ldw	r2,-4(fp)
 20140f4:	e0fffe17 	ldw	r3,-8(fp)
 20140f8:	10c00115 	stw	r3,4(r2)
	ethernetif->tse_info = &tse[iface];
 20140fc:	e0bffe17 	ldw	r2,-8(fp)
 2014100:	10c00924 	muli	r3,r2,36
 2014104:	00808574 	movhi	r2,533
 2014108:	10b51f04 	addi	r2,r2,-11140
 201410c:	1887883a 	add	r3,r3,r2
 2014110:	e0bfff17 	ldw	r2,-4(fp)
 2014114:	10c01715 	stw	r3,92(r2)

	if (tse_hw->ext_desc_mem == 1)
 2014118:	e0bff717 	ldw	r2,-36(fp)
 201411c:	10800783 	ldbu	r2,30(r2)
 2014120:	10803fcc 	andi	r2,r2,255
 2014124:	10800058 	cmpnei	r2,r2,1
 2014128:	10000b1e 	bne	r2,zero,2014158 <tse_mac_init+0x1bc>
	{
		tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 201412c:	e0bff717 	ldw	r2,-36(fp)
 2014130:	10800817 	ldw	r2,32(r2)
 2014134:	1009883a 	mov	r4,r2
 2014138:	00808574 	movhi	r2,533
 201413c:	10b51f04 	addi	r2,r2,-11140
 2014140:	e0fffe17 	ldw	r3,-8(fp)
 2014144:	18c00924 	muli	r3,r3,36
 2014148:	10c5883a 	add	r2,r2,r3
 201414c:	10800504 	addi	r2,r2,20
 2014150:	11000015 	stw	r4,0(r2)
 2014154:	00001206 	br	20141a0 <tse_mac_init+0x204>
	}
	else
	{
		unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 2014158:	01002804 	movi	r4,160
 201415c:	202ea040 	call	202ea04 <alt_uncached_malloc>
 2014160:	e0bff615 	stw	r2,-40(fp)

		while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 2014164:	00000306 	br	2014174 <tse_mac_init+0x1d8>
			temp_desc++;
 2014168:	e0bff617 	ldw	r2,-40(fp)
 201416c:	10800044 	addi	r2,r2,1
 2014170:	e0bff615 	stw	r2,-40(fp)
	}
	else
	{
		unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));

		while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 2014174:	e0bff617 	ldw	r2,-40(fp)
 2014178:	108007cc 	andi	r2,r2,31
 201417c:	103ffa1e 	bne	r2,zero,2014168 <__alt_mem_mem_0+0xfcff4168>
			temp_desc++;
		tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 2014180:	00808574 	movhi	r2,533
 2014184:	10b51f04 	addi	r2,r2,-11140
 2014188:	e0fffe17 	ldw	r3,-8(fp)
 201418c:	18c00924 	muli	r3,r3,36
 2014190:	10c5883a 	add	r2,r2,r3
 2014194:	10800504 	addi	r2,r2,20
 2014198:	e0fff617 	ldw	r3,-40(fp)
 201419c:	10c00015 	stw	r3,0(r2)
	}

	/* Get the Rx and Tx SGDMA addresses */
	sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 20141a0:	e0bff717 	ldw	r2,-36(fp)
 20141a4:	10800517 	ldw	r2,20(r2)
 20141a8:	1009883a 	mov	r4,r2
 20141ac:	202c3fc0 	call	202c3fc <alt_avalon_sgdma_open>
 20141b0:	e0bff815 	stw	r2,-32(fp)

	if (!sgdma_tx_dev)
 20141b4:	e0bff817 	ldw	r2,-32(fp)
 20141b8:	1000021e 	bne	r2,zero,20141c4 <tse_mac_init+0x228>
	{
		dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
		return ENP_RESOURCE;
 20141bc:	00bffa84 	movi	r2,-22
 20141c0:	00018f06 	br	2014800 <tse_mac_init+0x864>
	}

	sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 20141c4:	e0bff717 	ldw	r2,-36(fp)
 20141c8:	10800617 	ldw	r2,24(r2)
 20141cc:	1009883a 	mov	r4,r2
 20141d0:	202c3fc0 	call	202c3fc <alt_avalon_sgdma_open>
 20141d4:	e0bff915 	stw	r2,-28(fp)
	if (!sgdma_rx_dev)
 20141d8:	e0bff917 	ldw	r2,-28(fp)
 20141dc:	1000021e 	bne	r2,zero,20141e8 <tse_mac_init+0x24c>
	{
		dprintf(("[triple_speed_ethernet_init] Error opening RX SGDMA\n"));
		return ENP_RESOURCE;
 20141e0:	00bffa84 	movi	r2,-22
 20141e4:	00018606 	br	2014800 <tse_mac_init+0x864>
	}

	/* Initialize mtip_mac_trans_info structure with values from <system.h>*/

	tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 20141e8:	e0bffe17 	ldw	r2,-8(fp)
 20141ec:	10c00924 	muli	r3,r2,36
 20141f0:	00808574 	movhi	r2,533
 20141f4:	10b51f04 	addi	r2,r2,-11140
 20141f8:	1887883a 	add	r3,r3,r2
 20141fc:	e0bff717 	ldw	r2,-36(fp)
 2014200:	10800017 	ldw	r2,0(r2)
 2014204:	e13ff817 	ldw	r4,-32(fp)
 2014208:	e17ff917 	ldw	r5,-28(fp)
 201420c:	d8000015 	stw	zero,0(sp)
 2014210:	280f883a 	mov	r7,r5
 2014214:	200d883a 	mov	r6,r4
 2014218:	100b883a 	mov	r5,r2
 201421c:	1809883a 	mov	r4,r3
 2014220:	20344c80 	call	20344c8 <tse_mac_initTransInfo2>
			(unsigned int)sgdma_tx_dev,
			(unsigned int)sgdma_rx_dev,
			0);
	mi_base = tse[iface].mi.base;
 2014224:	00808574 	movhi	r2,533
 2014228:	10b51f04 	addi	r2,r2,-11140
 201422c:	e0fffe17 	ldw	r3,-8(fp)
 2014230:	18c00924 	muli	r3,r3,36
 2014234:	10c5883a 	add	r2,r2,r3
 2014238:	10800017 	ldw	r2,0(r2)
 201423c:	e0bffa15 	stw	r2,-24(fp)

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
 2014240:	00808574 	movhi	r2,533
 2014244:	10b51f04 	addi	r2,r2,-11140
 2014248:	e0fffe17 	ldw	r3,-8(fp)
 201424c:	18c00924 	muli	r3,r3,36
 2014250:	10c5883a 	add	r2,r2,r3
 2014254:	10800204 	addi	r2,r2,8
 2014258:	10800017 	ldw	r2,0(r2)
 201425c:	10800317 	ldw	r2,12(r2)
 2014260:	10800404 	addi	r2,r2,16
 2014264:	00c00074 	movhi	r3,1
 2014268:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 201426c:	00808574 	movhi	r2,533
 2014270:	10b51f04 	addi	r2,r2,-11140
 2014274:	e0fffe17 	ldw	r3,-8(fp)
 2014278:	18c00924 	muli	r3,r3,36
 201427c:	10c5883a 	add	r2,r2,r3
 2014280:	10800204 	addi	r2,r2,8
 2014284:	10800017 	ldw	r2,0(r2)
 2014288:	10800317 	ldw	r2,12(r2)
 201428c:	10800404 	addi	r2,r2,16
 2014290:	0007883a 	mov	r3,zero
 2014294:	10c00035 	stwio	r3,0(r2)

	/* reset the PHY if necessary */
	result = getPHYSpeed(tse[iface].mi.base);
 2014298:	00808574 	movhi	r2,533
 201429c:	10b51f04 	addi	r2,r2,-11140
 20142a0:	e0fffe17 	ldw	r3,-8(fp)
 20142a4:	18c00924 	muli	r3,r3,36
 20142a8:	10c5883a 	add	r2,r2,r3
 20142ac:	10800017 	ldw	r2,0(r2)
 20142b0:	1009883a 	mov	r4,r2
 20142b4:	20359540 	call	2035954 <getPHYSpeed>
 20142b8:	e0bffb15 	stw	r2,-20(fp)
	speed = (result >> 1) & 0x07;
 20142bc:	e0bffb17 	ldw	r2,-20(fp)
 20142c0:	1005d07a 	srai	r2,r2,1
 20142c4:	108001cc 	andi	r2,r2,7
 20142c8:	e0bffc15 	stw	r2,-16(fp)
	duplex = result & 0x01;
 20142cc:	e0bffb17 	ldw	r2,-20(fp)
 20142d0:	1080004c 	andi	r2,r2,1
 20142d4:	e0bff415 	stw	r2,-48(fp)

	/* reset the mac */
	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 20142d8:	00808574 	movhi	r2,533
 20142dc:	10b51f04 	addi	r2,r2,-11140
 20142e0:	e0fffe17 	ldw	r3,-8(fp)
 20142e4:	18c00924 	muli	r3,r3,36
 20142e8:	10c5883a 	add	r2,r2,r3
 20142ec:	10800017 	ldw	r2,0(r2)
 20142f0:	10800204 	addi	r2,r2,8
 20142f4:	00c800c4 	movi	r3,8195
 20142f8:	10c00035 	stwio	r3,0(r2)
			mmac_cc_SW_RESET_mask |
			mmac_cc_TX_ENA_mask |
			mmac_cc_RX_ENA_mask);

	x = 0;
 20142fc:	e03ff515 	stw	zero,-44(fp)
	while (IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) &
 2014300:	00000506 	br	2014318 <tse_mac_init+0x37c>
			ALTERA_TSEMAC_CMD_SW_RESET_MSK)
	{
		if( x++ > 10000 )
 2014304:	e0bff517 	ldw	r2,-44(fp)
 2014308:	10c00044 	addi	r3,r2,1
 201430c:	e0fff515 	stw	r3,-44(fp)
 2014310:	1089c450 	cmplti	r2,r2,10001
 2014314:	10000b26 	beq	r2,zero,2014344 <tse_mac_init+0x3a8>
			mmac_cc_SW_RESET_mask |
			mmac_cc_TX_ENA_mask |
			mmac_cc_RX_ENA_mask);

	x = 0;
	while (IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) &
 2014318:	00808574 	movhi	r2,533
 201431c:	10b51f04 	addi	r2,r2,-11140
 2014320:	e0fffe17 	ldw	r3,-8(fp)
 2014324:	18c00924 	muli	r3,r3,36
 2014328:	10c5883a 	add	r2,r2,r3
 201432c:	10800017 	ldw	r2,0(r2)
 2014330:	10800204 	addi	r2,r2,8
 2014334:	10800037 	ldwio	r2,0(r2)
 2014338:	1088000c 	andi	r2,r2,8192
 201433c:	103ff11e 	bne	r2,zero,2014304 <__alt_mem_mem_0+0xfcff4304>
 2014340:	00000106 	br	2014348 <tse_mac_init+0x3ac>
			ALTERA_TSEMAC_CMD_SW_RESET_MSK)
	{
		if( x++ > 10000 )
			break;
 2014344:	0001883a 	nop
	}

	if (x >= 10000)
		dprintf(("TSEMAC SW reset bit never cleared!\n"));

	dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 2014348:	00808574 	movhi	r2,533
 201434c:	10b51f04 	addi	r2,r2,-11140
 2014350:	e0fffe17 	ldw	r3,-8(fp)
 2014354:	18c00924 	muli	r3,r3,36
 2014358:	10c5883a 	add	r2,r2,r3
 201435c:	10800017 	ldw	r2,0(r2)
 2014360:	10800204 	addi	r2,r2,8
 2014364:	10800037 	ldwio	r2,0(r2)
 2014368:	e0bff315 	stw	r2,-52(fp)
		dprintf(("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat));
	else
		dprintf(("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat));

	/* Initialize MAC registers */
	IOWR_ALTERA_TSEMAC_FRM_LENGTH(mi_base, PBUF_POOL_BUFSIZE+ETH_PAD_SIZE);
 201436c:	e0bffa17 	ldw	r2,-24(fp)
 2014370:	10800504 	addi	r2,r2,20
 2014374:	00c17b84 	movi	r3,1518
 2014378:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(mi_base, 8);
 201437c:	e0bffa17 	ldw	r2,-24(fp)
 2014380:	10800b04 	addi	r2,r2,44
 2014384:	00c00204 	movi	r3,8
 2014388:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(mi_base, 8);
 201438c:	e0bffa17 	ldw	r2,-24(fp)
 2014390:	10800c04 	addi	r2,r2,48
 2014394:	00c00204 	movi	r3,8
 2014398:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(mi_base, 8);
 201439c:	e0bffa17 	ldw	r2,-24(fp)
 20143a0:	10800d04 	addi	r2,r2,52
 20143a4:	00c00204 	movi	r3,8
 20143a8:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(mi_base,  3);
 20143ac:	e0bffa17 	ldw	r2,-24(fp)
 20143b0:	10800e04 	addi	r2,r2,56
 20143b4:	00c000c4 	movi	r3,3
 20143b8:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(mi_base, tse_hw->tse_tx_depth - 16);
 20143bc:	e0bffa17 	ldw	r2,-24(fp)
 20143c0:	10800904 	addi	r2,r2,36
 20143c4:	e0fff717 	ldw	r3,-36(fp)
 20143c8:	18c0010b 	ldhu	r3,4(r3)
 20143cc:	18ffffcc 	andi	r3,r3,65535
 20143d0:	18fffc04 	addi	r3,r3,-16
 20143d4:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(mi_base,  0);
 20143d8:	e0bffa17 	ldw	r2,-24(fp)
 20143dc:	10800a04 	addi	r2,r2,40
 20143e0:	0007883a 	mov	r3,zero
 20143e4:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(mi_base, tse_hw->tse_rx_depth - 16);
 20143e8:	e0bffa17 	ldw	r2,-24(fp)
 20143ec:	10800704 	addi	r2,r2,28
 20143f0:	e0fff717 	ldw	r3,-36(fp)
 20143f4:	18c0018b 	ldhu	r3,6(r3)
 20143f8:	18ffffcc 	andi	r3,r3,65535
 20143fc:	18fffc04 	addi	r3,r3,-16
 2014400:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(mi_base,  0);
 2014404:	e0bffa17 	ldw	r2,-24(fp)
 2014408:	10800804 	addi	r2,r2,32
 201440c:	0007883a 	mov	r3,zero
 2014410:	10c00035 	stwio	r3,0(r2)

	/* Enable TX shift 16 for removing two bytes from the start of all transmitted frames */
	IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 2014414:	00808574 	movhi	r2,533
 2014418:	10b51f04 	addi	r2,r2,-11140
 201441c:	e0fffe17 	ldw	r3,-8(fp)
 2014420:	18c00924 	muli	r3,r3,36
 2014424:	10c5883a 	add	r2,r2,r3
 2014428:	10800017 	ldw	r2,0(r2)
 201442c:	10803a04 	addi	r2,r2,232
 2014430:	00c00134 	movhi	r3,4
 2014434:	10c00035 	stwio	r3,0(r2)

	/*
	 * check if the MAC supports the 16-bit shift option allowing us
	 * to send BIASed frames without copying. Used by the send function later.
	 */
	if ((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
 2014438:	00808574 	movhi	r2,533
 201443c:	10b51f04 	addi	r2,r2,-11140
 2014440:	e0fffe17 	ldw	r3,-8(fp)
 2014444:	18c00924 	muli	r3,r3,36
 2014448:	10c5883a 	add	r2,r2,r3
 201444c:	10800017 	ldw	r2,0(r2)
 2014450:	10803a04 	addi	r2,r2,232
 2014454:	10800037 	ldwio	r2,0(r2)
 2014458:	1080012c 	andhi	r2,r2,4
 201445c:	1000021e 	bne	r2,zero,2014468 <tse_mac_init+0x4cc>
	{
		dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
		return ERR_IF;
 2014460:	00bffd04 	movi	r2,-12
 2014464:	0000e606 	br	2014800 <tse_mac_init+0x864>
	}

	/* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
	IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 2014468:	00808574 	movhi	r2,533
 201446c:	10b51f04 	addi	r2,r2,-11140
 2014470:	e0fffe17 	ldw	r3,-8(fp)
 2014474:	18c00924 	muli	r3,r3,36
 2014478:	10c5883a 	add	r2,r2,r3
 201447c:	10800017 	ldw	r2,0(r2)
 2014480:	10803b04 	addi	r2,r2,236
 2014484:	00c08034 	movhi	r3,512
 2014488:	10c00035 	stwio	r3,0(r2)

	/* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */
	if ((IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK) == 0)
 201448c:	00808574 	movhi	r2,533
 2014490:	10b51f04 	addi	r2,r2,-11140
 2014494:	e0fffe17 	ldw	r3,-8(fp)
 2014498:	18c00924 	muli	r3,r3,36
 201449c:	10c5883a 	add	r2,r2,r3
 20144a0:	10800017 	ldw	r2,0(r2)
 20144a4:	10803b04 	addi	r2,r2,236
 20144a8:	10800037 	ldwio	r2,0(r2)
 20144ac:	1080802c 	andhi	r2,r2,512
 20144b0:	1000021e 	bne	r2,zero,20144bc <tse_mac_init+0x520>
	{
		dprintf(("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETH_PAD_SIZE));
		return ERR_IF;
 20144b4:	00bffd04 	movi	r2,-12
 20144b8:	0000d106 	br	2014800 <tse_mac_init+0x864>
	}

	/* Set the MAC address */
	IOWR_ALTERA_TSEMAC_MAC_0(mi_base,
 20144bc:	e0bffa17 	ldw	r2,-24(fp)
 20144c0:	10800304 	addi	r2,r2,12
 20144c4:	e0ffff17 	ldw	r3,-4(fp)
 20144c8:	18c00017 	ldw	r3,0(r3)
 20144cc:	18c00003 	ldbu	r3,0(r3)
 20144d0:	19003fcc 	andi	r4,r3,255
 20144d4:	e0ffff17 	ldw	r3,-4(fp)
 20144d8:	18c00017 	ldw	r3,0(r3)
 20144dc:	18c00043 	ldbu	r3,1(r3)
 20144e0:	18c03fcc 	andi	r3,r3,255
 20144e4:	1806923a 	slli	r3,r3,8
 20144e8:	20c8b03a 	or	r4,r4,r3
 20144ec:	e0ffff17 	ldw	r3,-4(fp)
 20144f0:	18c00017 	ldw	r3,0(r3)
 20144f4:	18c00083 	ldbu	r3,2(r3)
 20144f8:	18c03fcc 	andi	r3,r3,255
 20144fc:	1806943a 	slli	r3,r3,16
 2014500:	20c8b03a 	or	r4,r4,r3
 2014504:	e0ffff17 	ldw	r3,-4(fp)
 2014508:	18c00017 	ldw	r3,0(r3)
 201450c:	18c000c3 	ldbu	r3,3(r3)
 2014510:	18c03fcc 	andi	r3,r3,255
 2014514:	1806963a 	slli	r3,r3,24
 2014518:	20c6b03a 	or	r3,r4,r3
 201451c:	10c00035 	stwio	r3,0(r2)
			((int)((unsigned char) ethernetif->ethaddr->addr[0]) |
					(int)((unsigned char) ethernetif->ethaddr->addr[1] <<  8) |
					(int)((unsigned char) ethernetif->ethaddr->addr[2] << 16) |
					(int)((unsigned char) ethernetif->ethaddr->addr[3] << 24)));

	IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
 2014520:	e0bffa17 	ldw	r2,-24(fp)
 2014524:	10800404 	addi	r2,r2,16
 2014528:	e0ffff17 	ldw	r3,-4(fp)
 201452c:	18c00017 	ldw	r3,0(r3)
 2014530:	18c00103 	ldbu	r3,4(r3)
 2014534:	19003fcc 	andi	r4,r3,255
 2014538:	e0ffff17 	ldw	r3,-4(fp)
 201453c:	18c00017 	ldw	r3,0(r3)
 2014540:	18c00143 	ldbu	r3,5(r3)
 2014544:	18c03fcc 	andi	r3,r3,255
 2014548:	1806923a 	slli	r3,r3,8
 201454c:	20c6b03a 	or	r3,r4,r3
 2014550:	18ffffcc 	andi	r3,r3,65535
 2014554:	10c00035 	stwio	r3,0(r2)
			(((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
					(int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));

	/* enable MAC */
	dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 2014558:	00810034 	movhi	r2,1024
 201455c:	108080c4 	addi	r2,r2,515
 2014560:	e0bff315 	stw	r2,-52(fp)
			ALTERA_TSEMAC_CMD_LOOPBACK_MSK     |     // promiscuous mode
#endif
			ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
			ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */

	if ((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0)
 2014564:	e0bffb17 	ldw	r2,-20(fp)
 2014568:	1080022c 	andhi	r2,r2,8
 201456c:	1000461e 	bne	r2,zero,2014688 <tse_mac_init+0x6ec>
	{
		speed = (result >> 1) & 0x07;
 2014570:	e0bffb17 	ldw	r2,-20(fp)
 2014574:	1005d07a 	srai	r2,r2,1
 2014578:	108001cc 	andi	r2,r2,7
 201457c:	e0bffc15 	stw	r2,-16(fp)
		duplex = result & 0x01;
 2014580:	e0bffb17 	ldw	r2,-20(fp)
 2014584:	1080004c 	andi	r2,r2,1
 2014588:	e0bff415 	stw	r2,-48(fp)

		/* 1000 Mbps */
		if(speed == 0x01)
 201458c:	e0bffc17 	ldw	r2,-16(fp)
 2014590:	10800058 	cmpnei	r2,r2,1
 2014594:	1000121e 	bne	r2,zero,20145e0 <tse_mac_init+0x644>
		{
			dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2014598:	e0bff317 	ldw	r2,-52(fp)
 201459c:	10800214 	ori	r2,r2,8
 20145a0:	e0bff315 	stw	r2,-52(fp)
			dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 20145a4:	e0fff317 	ldw	r3,-52(fp)
 20145a8:	00bf8034 	movhi	r2,65024
 20145ac:	10bfffc4 	addi	r2,r2,-1
 20145b0:	1884703a 	and	r2,r3,r2
 20145b4:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 1000;
 20145b8:	00808574 	movhi	r2,533
 20145bc:	10b51f04 	addi	r2,r2,-11140
 20145c0:	e0fffe17 	ldw	r3,-8(fp)
 20145c4:	18c00924 	muli	r3,r3,36
 20145c8:	10c5883a 	add	r2,r2,r3
 20145cc:	10800604 	addi	r2,r2,24
 20145d0:	10800017 	ldw	r2,0(r2)
 20145d4:	00c0fa04 	movi	r3,1000
 20145d8:	10c00315 	stw	r3,12(r2)
 20145dc:	00003306 	br	20146ac <tse_mac_init+0x710>
		}
		/* 100 Mbps */
		else if(speed == 0x02)
 20145e0:	e0bffc17 	ldw	r2,-16(fp)
 20145e4:	10800098 	cmpnei	r2,r2,2
 20145e8:	1000131e 	bne	r2,zero,2014638 <tse_mac_init+0x69c>
		{
			dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 20145ec:	e0fff317 	ldw	r3,-52(fp)
 20145f0:	00bffdc4 	movi	r2,-9
 20145f4:	1884703a 	and	r2,r3,r2
 20145f8:	e0bff315 	stw	r2,-52(fp)
			dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 20145fc:	e0fff317 	ldw	r3,-52(fp)
 2014600:	00bf8034 	movhi	r2,65024
 2014604:	10bfffc4 	addi	r2,r2,-1
 2014608:	1884703a 	and	r2,r3,r2
 201460c:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 100;
 2014610:	00808574 	movhi	r2,533
 2014614:	10b51f04 	addi	r2,r2,-11140
 2014618:	e0fffe17 	ldw	r3,-8(fp)
 201461c:	18c00924 	muli	r3,r3,36
 2014620:	10c5883a 	add	r2,r2,r3
 2014624:	10800604 	addi	r2,r2,24
 2014628:	10800017 	ldw	r2,0(r2)
 201462c:	00c01904 	movi	r3,100
 2014630:	10c00315 	stw	r3,12(r2)
 2014634:	00001d06 	br	20146ac <tse_mac_init+0x710>
		}
		/* 10 Mbps */
		else if(speed == 0x04)
 2014638:	e0bffc17 	ldw	r2,-16(fp)
 201463c:	10800118 	cmpnei	r2,r2,4
 2014640:	10001a1e 	bne	r2,zero,20146ac <tse_mac_init+0x710>
		{
			dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2014644:	e0fff317 	ldw	r3,-52(fp)
 2014648:	00bffdc4 	movi	r2,-9
 201464c:	1884703a 	and	r2,r3,r2
 2014650:	e0bff315 	stw	r2,-52(fp)
			dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2014654:	e0bff317 	ldw	r2,-52(fp)
 2014658:	10808034 	orhi	r2,r2,512
 201465c:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 10;
 2014660:	00808574 	movhi	r2,533
 2014664:	10b51f04 	addi	r2,r2,-11140
 2014668:	e0fffe17 	ldw	r3,-8(fp)
 201466c:	18c00924 	muli	r3,r3,36
 2014670:	10c5883a 	add	r2,r2,r3
 2014674:	10800604 	addi	r2,r2,24
 2014678:	10800017 	ldw	r2,0(r2)
 201467c:	00c00284 	movi	r3,10
 2014680:	10c00315 	stw	r3,12(r2)
 2014684:	00000906 	br	20146ac <tse_mac_init+0x710>
		}
	}
	/* default to 100 Mbps if returned invalid speed */
	else
	{
		dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2014688:	e0fff317 	ldw	r3,-52(fp)
 201468c:	00bffdc4 	movi	r2,-9
 2014690:	1884703a 	and	r2,r3,r2
 2014694:	e0bff315 	stw	r2,-52(fp)
		dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2014698:	e0fff317 	ldw	r3,-52(fp)
 201469c:	00bf8034 	movhi	r2,65024
 20146a0:	10bfffc4 	addi	r2,r2,-1
 20146a4:	1884703a 	and	r2,r3,r2
 20146a8:	e0bff315 	stw	r2,-52(fp)
	}

	/* Half Duplex */
	if(duplex == TSE_PHY_DUPLEX_HALF)
 20146ac:	e0bff417 	ldw	r2,-48(fp)
 20146b0:	10000c1e 	bne	r2,zero,20146e4 <tse_mac_init+0x748>
	{
		dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 20146b4:	e0bff317 	ldw	r2,-52(fp)
 20146b8:	10810014 	ori	r2,r2,1024
 20146bc:	e0bff315 	stw	r2,-52(fp)
		tse[iface].ethernetif->full_duplex = 0;
 20146c0:	00808574 	movhi	r2,533
 20146c4:	10b51f04 	addi	r2,r2,-11140
 20146c8:	e0fffe17 	ldw	r3,-8(fp)
 20146cc:	18c00924 	muli	r3,r3,36
 20146d0:	10c5883a 	add	r2,r2,r3
 20146d4:	10800604 	addi	r2,r2,24
 20146d8:	10800017 	ldw	r2,0(r2)
 20146dc:	10000415 	stw	zero,16(r2)
 20146e0:	00000d06 	br	2014718 <tse_mac_init+0x77c>
	}
	/* Full Duplex */
	else
	{
		dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 20146e4:	e0fff317 	ldw	r3,-52(fp)
 20146e8:	00beffc4 	movi	r2,-1025
 20146ec:	1884703a 	and	r2,r3,r2
 20146f0:	e0bff315 	stw	r2,-52(fp)
		tse[iface].ethernetif->full_duplex = 1;
 20146f4:	00808574 	movhi	r2,533
 20146f8:	10b51f04 	addi	r2,r2,-11140
 20146fc:	e0fffe17 	ldw	r3,-8(fp)
 2014700:	18c00924 	muli	r3,r3,36
 2014704:	10c5883a 	add	r2,r2,r3
 2014708:	10800604 	addi	r2,r2,24
 201470c:	10800017 	ldw	r2,0(r2)
 2014710:	00c00044 	movi	r3,1
 2014714:	10c00415 	stw	r3,16(r2)
	}

	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 2014718:	00808574 	movhi	r2,533
 201471c:	10b51f04 	addi	r2,r2,-11140
 2014720:	e0fffe17 	ldw	r3,-8(fp)
 2014724:	18c00924 	muli	r3,r3,36
 2014728:	10c5883a 	add	r2,r2,r3
 201472c:	10800017 	ldw	r2,0(r2)
 2014730:	10800204 	addi	r2,r2,8
 2014734:	e0fff317 	ldw	r3,-52(fp)
 2014738:	10c00035 	stwio	r3,0(r2)
	dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n",
			IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));

	alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
 201473c:	00808574 	movhi	r2,533
 2014740:	10b51f04 	addi	r2,r2,-11140
 2014744:	e0fffe17 	ldw	r3,-8(fp)
 2014748:	18c00924 	muli	r3,r3,36
 201474c:	10c5883a 	add	r2,r2,r3
 2014750:	10800204 	addi	r2,r2,8
 2014754:	11000017 	ldw	r4,0(r2)
#ifndef ALTERA_TSE_IRQ_R
			(alt_avalon_sgdma_callback)&tse_sgdma_rx_isr,
#else
			(alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
			(alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
 2014758:	e0bffe17 	ldw	r2,-8(fp)
 201475c:	10c00924 	muli	r3,r2,36
 2014760:	00808574 	movhi	r2,533
 2014764:	10b51f04 	addi	r2,r2,-11140
 2014768:	1885883a 	add	r2,r3,r2

	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
	dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n",
			IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));

	alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
 201476c:	100f883a 	mov	r7,r2
 2014770:	01800604 	movi	r6,24
 2014774:	01408074 	movhi	r5,513
 2014778:	29522e04 	addi	r5,r5,18616
 201477c:	202c2900 	call	202c290 <alt_avalon_sgdma_register_callback>
#else
			(alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
			(alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));

	tse_sgdma_read_init(&tse[iface]);
 2014780:	e0bffe17 	ldw	r2,-8(fp)
 2014784:	10c00924 	muli	r3,r2,36
 2014788:	00808574 	movhi	r2,533
 201478c:	10b51f04 	addi	r2,r2,-11140
 2014790:	1885883a 	add	r2,r3,r2
 2014794:	1009883a 	mov	r4,r2
 2014798:	20148140 	call	2014814 <tse_sgdma_read_init>
	pmac_info = alt_tse_get_mac_info(mi_base);
 201479c:	e13ffa17 	ldw	r4,-24(fp)
 20147a0:	20357100 	call	2035710 <alt_tse_get_mac_info>
 20147a4:	e0bffd15 	stw	r2,-12(fp)
	alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
 20147a8:	e0bffd17 	ldw	r2,-12(fp)
 20147ac:	10c00117 	ldw	r3,4(r2)
 20147b0:	e0bffd17 	ldw	r2,-12(fp)
 20147b4:	10800117 	ldw	r2,4(r2)
 20147b8:	10800003 	ldbu	r2,0(r2)
 20147bc:	10803fcc 	andi	r2,r2,255
 20147c0:	100b883a 	mov	r5,r2
 20147c4:	1809883a 	mov	r4,r3
 20147c8:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
	ethernetif->link_alive = alt_tse_phy_rd_mdio_reg(pmac_info->pphy_info, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) != 0;// && (((IORD(&(mi_base->mdio1.reg10), 0) >> 4) & 0xF) <= 3);
 20147cc:	e0bffd17 	ldw	r2,-12(fp)
 20147d0:	10800117 	ldw	r2,4(r2)
 20147d4:	01c00044 	movi	r7,1
 20147d8:	01800144 	movi	r6,5
 20147dc:	01400044 	movi	r5,1
 20147e0:	1009883a 	mov	r4,r2
 20147e4:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 20147e8:	1004c03a 	cmpne	r2,r2,zero
 20147ec:	10c03fcc 	andi	r3,r2,255
 20147f0:	e0bfff17 	ldw	r2,-4(fp)
 20147f4:	10c00215 	stw	r3,8(r2)
	return ethernetif->link_alive;
 20147f8:	e0bfff17 	ldw	r2,-4(fp)
 20147fc:	10800217 	ldw	r2,8(r2)
}
 2014800:	e037883a 	mov	sp,fp
 2014804:	dfc00117 	ldw	ra,4(sp)
 2014808:	df000017 	ldw	fp,0(sp)
 201480c:	dec00204 	addi	sp,sp,8
 2014810:	f800283a 	ret

02014814 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
 2014814:	defffb04 	addi	sp,sp,-20
 2014818:	dfc00415 	stw	ra,16(sp)
 201481c:	df000315 	stw	fp,12(sp)
 2014820:	df000304 	addi	fp,sp,12
 2014824:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;
 2014828:	e0bfff17 	ldw	r2,-4(fp)
 201482c:	10800617 	ldw	r2,24(r2)
 2014830:	e0bffe15 	stw	r2,-8(fp)

	alt_avalon_sgdma_construct_stream_to_mem_desc(
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 2014834:	e0bfff17 	ldw	r2,-4(fp)
 2014838:	10800517 	ldw	r2,20(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 201483c:	11001004 	addi	r4,r2,64
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
 2014840:	e0bfff17 	ldw	r2,-4(fp)
 2014844:	10800517 	ldw	r2,20(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014848:	11401804 	addi	r5,r2,96
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
			(alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
 201484c:	e0bfff17 	ldw	r2,-4(fp)
 2014850:	10800617 	ldw	r2,24(r2)
 2014854:	10801317 	ldw	r2,76(r2)
 2014858:	e0fffe17 	ldw	r3,-8(fp)
 201485c:	108001c4 	addi	r2,r2,7
 2014860:	1085883a 	add	r2,r2,r2
 2014864:	1085883a 	add	r2,r2,r2
 2014868:	1885883a 	add	r2,r3,r2
 201486c:	10800017 	ldw	r2,0(r2)
 2014870:	10800117 	ldw	r2,4(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014874:	d8000015 	stw	zero,0(sp)
 2014878:	000f883a 	mov	r7,zero
 201487c:	100d883a 	mov	r6,r2
 2014880:	202c0ac0 	call	202c0ac <alt_avalon_sgdma_construct_stream_to_mem_desc>
			0,                                  // read until EOP
			0);          // don't write to constant address

	dprintf(("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n",0));

	tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 2014884:	e0ffff17 	ldw	r3,-4(fp)
 2014888:	e0bfff17 	ldw	r2,-4(fp)
 201488c:	10800517 	ldw	r2,20(r2)
 2014890:	10801004 	addi	r2,r2,64
 2014894:	100b883a 	mov	r5,r2
 2014898:	1809883a 	mov	r4,r3
 201489c:	203460c0 	call	203460c <tse_mac_aRxRead>

	return SUCCESS;
 20148a0:	0005883a 	mov	r2,zero
}
 20148a4:	e037883a 	mov	sp,fp
 20148a8:	dfc00117 	ldw	ra,4(sp)
 20148ac:	df000017 	ldw	fp,0(sp)
 20148b0:	dec00204 	addi	sp,sp,8
 20148b4:	f800283a 	ret

020148b8 <tse_sgdma_rx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
int tse_sgdma_rx_isr(void * context, __unused u_long intnum)
{
 20148b8:	defffb04 	addi	sp,sp,-20
 20148bc:	dfc00415 	stw	ra,16(sp)
 20148c0:	df000315 	stw	fp,12(sp)
 20148c4:	df000304 	addi	fp,sp,12
 20148c8:	e13ffe15 	stw	r4,-8(fp)
 20148cc:	e17fff15 	stw	r5,-4(fp)
	lwip_tse_info* tse_ptr = (lwip_tse_info *) context;
 20148d0:	e0bffe17 	ldw	r2,-8(fp)
 20148d4:	e0bffd15 	stw	r2,-12(fp)

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
 20148d8:	e0bffd17 	ldw	r2,-12(fp)
 20148dc:	10800217 	ldw	r2,8(r2)
 20148e0:	10800304 	addi	r2,r2,12
 20148e4:	10800404 	addi	r2,r2,16
 20148e8:	00e00034 	movhi	r3,32768
 20148ec:	10c00035 	stwio	r3,0(r2)

	// process the newly received data and cycle to the next free pbuf for receive
	tse_mac_rcv(tse_ptr->ethernetif);
 20148f0:	e0bffd17 	ldw	r2,-12(fp)
 20148f4:	10800617 	ldw	r2,24(r2)
 20148f8:	1009883a 	mov	r4,r2
 20148fc:	2014aac0 	call	2014aac <tse_mac_rcv>

	// start a new async read transaction
	tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 2014900:	e0fffd17 	ldw	r3,-12(fp)
 2014904:	e0bffd17 	ldw	r2,-12(fp)
 2014908:	10800517 	ldw	r2,20(r2)
 201490c:	10801004 	addi	r2,r2,64
 2014910:	100b883a 	mov	r5,r2
 2014914:	1809883a 	mov	r4,r3
 2014918:	203460c0 	call	203460c <tse_mac_aRxRead>

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base, ALTERA_TSE_SGDMA_INTR_MASK);
 201491c:	e0bffd17 	ldw	r2,-12(fp)
 2014920:	10800217 	ldw	r2,8(r2)
 2014924:	10800304 	addi	r2,r2,12
 2014928:	10800404 	addi	r2,r2,16
 201492c:	00c00604 	movi	r3,24
 2014930:	10c00035 	stwio	r3,0(r2)

	return SUCCESS;
 2014934:	0005883a 	mov	r2,zero
}
 2014938:	e037883a 	mov	sp,fp
 201493c:	dfc00117 	ldw	ra,4(sp)
 2014940:	df000017 	ldw	fp,0(sp)
 2014944:	dec00204 	addi	sp,sp,8
 2014948:	f800283a 	ret

0201494c <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
 201494c:	defe6a04 	addi	sp,sp,-1624
 2014950:	dfc19515 	stw	ra,1620(sp)
 2014954:	df019415 	stw	fp,1616(sp)
 2014958:	df019404 	addi	fp,sp,1616
 201495c:	e13ffe15 	stw	r4,-8(fp)
 2014960:	e17fff15 	stw	r5,-4(fp)
	alt_u32			   *ActualData;

	/* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
	char buf2[1560];

	ethernetif = netif->state;
 2014964:	e0bffe17 	ldw	r2,-8(fp)
 2014968:	10800917 	ldw	r2,36(r2)
 201496c:	e0be7215 	stw	r2,-1592(fp)
	tse_ptr = ethernetif->tse_info;
 2014970:	e0be7217 	ldw	r2,-1592(fp)
 2014974:	10801717 	ldw	r2,92(r2)
 2014978:	e0be7315 	stw	r2,-1588(fp)
	mi = &tse_ptr->mi;
 201497c:	e0be7317 	ldw	r2,-1588(fp)
 2014980:	e0be7415 	stw	r2,-1584(fp)

	for(p = pkt; p != NULL; p = p->next)
 2014984:	e0bfff17 	ldw	r2,-4(fp)
 2014988:	e0be7015 	stw	r2,-1600(fp)
 201498c:	00003806 	br	2014a70 <tse_mac_raw_send+0x124>
	{
		data = p->payload;
 2014990:	e0be7017 	ldw	r2,-1600(fp)
 2014994:	10800117 	ldw	r2,4(r2)
 2014998:	e0be7115 	stw	r2,-1596(fp)
		len = p->len;
 201499c:	e0be7017 	ldw	r2,-1600(fp)
 20149a0:	1080028b 	ldhu	r2,10(r2)
 20149a4:	10bfffcc 	andi	r2,r2,65535
 20149a8:	e0be7515 	stw	r2,-1580(fp)

		// just in case we have an unaligned buffer, this should never occur
		if(((unsigned long)data & 0x03) != 0)
 20149ac:	e0be7117 	ldw	r2,-1596(fp)
 20149b0:	108000cc 	andi	r2,r2,3
 20149b4:	10000726 	beq	r2,zero,20149d4 <tse_mac_raw_send+0x88>
			/*
			 * Copy data to temporary buffer <buf2>. This is done because of alignment
			 * issues. The SGDMA cannot copy the data directly from (data + ETH_PAD_SIZE)
			 * because it needs a 32-bit aligned address space.
			 */
			memcpy(buf2,data,len);
 20149b8:	e0be7804 	addi	r2,fp,-1568
 20149bc:	e1be7517 	ldw	r6,-1580(fp)
 20149c0:	e17e7117 	ldw	r5,-1596(fp)
 20149c4:	1009883a 	mov	r4,r2
 20149c8:	2005e580 	call	2005e58 <memcpy>
			data = (alt_u32 *)buf2;
 20149cc:	e0be7804 	addi	r2,fp,-1568
 20149d0:	e0be7115 	stw	r2,-1596(fp)
		}

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));
 20149d4:	e0be7117 	ldw	r2,-1596(fp)
 20149d8:	e0be7615 	stw	r2,-1576(fp)

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 20149dc:	e0be7317 	ldw	r2,-1588(fp)
 20149e0:	11000517 	ldw	r4,20(r2)
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 20149e4:	e0be7317 	ldw	r2,-1588(fp)
 20149e8:	10800517 	ldw	r2,20(r2)

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 20149ec:	11400804 	addi	r5,r2,32
 20149f0:	e0be7517 	ldw	r2,-1580(fp)
 20149f4:	11bfffcc 	andi	r6,r2,65535
 20149f8:	e0fe7017 	ldw	r3,-1600(fp)
 20149fc:	e0bfff17 	ldw	r2,-4(fp)
 2014a00:	1885003a 	cmpeq	r2,r3,r2
 2014a04:	10803fcc 	andi	r2,r2,255
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
				(alt_u32*)ActualData,                    // starting read address
				(len),                                   // # bytes
				0,                                       // don't read from constant address
				p == pkt,                                // generate sop
				p->next == NULL,                         // generate endofpacket signal
 2014a08:	e0fe7017 	ldw	r3,-1600(fp)
 2014a0c:	18c00017 	ldw	r3,0(r3)

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 2014a10:	1807003a 	cmpeq	r3,r3,zero
 2014a14:	18c03fcc 	andi	r3,r3,255
 2014a18:	d8000315 	stw	zero,12(sp)
 2014a1c:	d8c00215 	stw	r3,8(sp)
 2014a20:	d8800115 	stw	r2,4(sp)
 2014a24:	d8000015 	stw	zero,0(sp)
 2014a28:	300f883a 	mov	r7,r6
 2014a2c:	e1be7617 	ldw	r6,-1576(fp)
 2014a30:	202c1840 	call	202c184 <alt_avalon_sgdma_construct_mem_to_stream_desc>
				0,                                       // don't read from constant address
				p == pkt,                                // generate sop
				p->next == NULL,                         // generate endofpacket signal
				0);                                      // atlantic channel (don't know/don't care: set to 0)

		tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
 2014a34:	e0be7317 	ldw	r2,-1588(fp)
 2014a38:	10800517 	ldw	r2,20(r2)
 2014a3c:	100b883a 	mov	r5,r2
 2014a40:	e13e7417 	ldw	r4,-1584(fp)
 2014a44:	20345280 	call	2034528 <tse_mac_sTxWrite>
 2014a48:	e0be7715 	stw	r2,-1572(fp)

		if (tx_length != p->len)
			dprintf(("failed to send all bytes, send %d out of %d\r\n", tx_length, p->len));

		ethernetif->bytes_sent += tx_length;
 2014a4c:	e0be7217 	ldw	r2,-1592(fp)
 2014a50:	10c00517 	ldw	r3,20(r2)
 2014a54:	e0be7717 	ldw	r2,-1572(fp)
 2014a58:	1887883a 	add	r3,r3,r2
 2014a5c:	e0be7217 	ldw	r2,-1592(fp)
 2014a60:	10c00515 	stw	r3,20(r2)

	ethernetif = netif->state;
	tse_ptr = ethernetif->tse_info;
	mi = &tse_ptr->mi;

	for(p = pkt; p != NULL; p = p->next)
 2014a64:	e0be7017 	ldw	r2,-1600(fp)
 2014a68:	10800017 	ldw	r2,0(r2)
 2014a6c:	e0be7015 	stw	r2,-1600(fp)
 2014a70:	e0be7017 	ldw	r2,-1600(fp)
 2014a74:	103fc61e 	bne	r2,zero,2014990 <__alt_mem_mem_0+0xfcff4990>
			dprintf(("failed to send all bytes, send %d out of %d\r\n", tx_length, p->len));

		ethernetif->bytes_sent += tx_length;
	}

	LINK_STATS_INC(link.xmit);
 2014a78:	008085f4 	movhi	r2,535
 2014a7c:	10bd8204 	addi	r2,r2,-2552
 2014a80:	10800017 	ldw	r2,0(r2)
 2014a84:	10c00044 	addi	r3,r2,1
 2014a88:	008085f4 	movhi	r2,535
 2014a8c:	10bd8204 	addi	r2,r2,-2552
 2014a90:	10c00015 	stw	r3,0(r2)

	return ERR_OK;
 2014a94:	0005883a 	mov	r2,zero
}
 2014a98:	e037883a 	mov	sp,fp
 2014a9c:	dfc00117 	ldw	ra,4(sp)
 2014aa0:	df000017 	ldw	fp,0(sp)
 2014aa4:	dec00204 	addi	sp,sp,8
 2014aa8:	f800283a 	ret

02014aac <tse_mac_rcv>:
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{
 2014aac:	defff704 	addi	sp,sp,-36
 2014ab0:	dfc00815 	stw	ra,32(sp)
 2014ab4:	df000715 	stw	fp,28(sp)
 2014ab8:	df000704 	addi	fp,sp,28
 2014abc:	e13fff15 	stw	r4,-4(fp)
#if LWIP_RECEIVE_SEMAPHORE
	signed long switch_context = 0;
 2014ac0:	e03ffe15 	stw	zero,-8(fp)
	int pklen;
	lwip_tse_info* tse_ptr;
	alt_u32 *uncached_packet_payload;
	struct pbuf *p;

	tse_ptr = ethernetif->tse_info;
 2014ac4:	e0bfff17 	ldw	r2,-4(fp)
 2014ac8:	10801717 	ldw	r2,92(r2)
 2014acc:	e0bffa15 	stw	r2,-24(fp)
	pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
 2014ad0:	e0bffa17 	ldw	r2,-24(fp)
 2014ad4:	10800517 	ldw	r2,20(r2)
 2014ad8:	10801004 	addi	r2,r2,64
 2014adc:	10800704 	addi	r2,r2,28
 2014ae0:	1080002b 	ldhuio	r2,0(r2)
 2014ae4:	10bfffcc 	andi	r2,r2,65535
 2014ae8:	e0bffb15 	stw	r2,-20(fp)
	p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
 2014aec:	e0bfff17 	ldw	r2,-4(fp)
 2014af0:	10801317 	ldw	r2,76(r2)
 2014af4:	e0ffff17 	ldw	r3,-4(fp)
 2014af8:	108001c4 	addi	r2,r2,7
 2014afc:	1085883a 	add	r2,r2,r2
 2014b00:	1085883a 	add	r2,r2,r2
 2014b04:	1885883a 	add	r2,r3,r2
 2014b08:	10800017 	ldw	r2,0(r2)
 2014b0c:	e0bffc15 	stw	r2,-16(fp)
	p->tot_len = pklen;
 2014b10:	e0bffb17 	ldw	r2,-20(fp)
 2014b14:	1007883a 	mov	r3,r2
 2014b18:	e0bffc17 	ldw	r2,-16(fp)
 2014b1c:	10c0020d 	sth	r3,8(r2)
	p->len = pklen;
 2014b20:	e0bffb17 	ldw	r2,-20(fp)
 2014b24:	1007883a 	mov	r3,r2
 2014b28:	e0bffc17 	ldw	r2,-16(fp)
 2014b2c:	10c0028d 	sth	r3,10(r2)
	if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
 2014b30:	e0bffa17 	ldw	r2,-24(fp)
 2014b34:	10800517 	ldw	r2,20(r2)
 2014b38:	10801704 	addi	r2,r2,92
 2014b3c:	10800037 	ldwio	r2,0(r2)
 2014b40:	1005d43a 	srai	r2,r2,16
 2014b44:	10801fcc 	andi	r2,r2,127
 2014b48:	10002d1e 	bne	r2,zero,2014c00 <tse_mac_rcv+0x154>
	{
		enh_alt_irq_disable_all();
 2014b4c:	202da600 	call	202da60 <enh_alt_irq_disable_all>

		if (++ethernetif->lwipRxCount >= LWIP_RX_ETH_BUFFER)
 2014b50:	e0bfff17 	ldw	r2,-4(fp)
 2014b54:	10801517 	ldw	r2,84(r2)
 2014b58:	10800044 	addi	r2,r2,1
 2014b5c:	e0ffff17 	ldw	r3,-4(fp)
 2014b60:	18801515 	stw	r2,84(r3)
 2014b64:	10800310 	cmplti	r2,r2,12
 2014b68:	10000e1e 	bne	r2,zero,2014ba4 <tse_mac_rcv+0xf8>
		{
			LINK_STATS_INC(link.drop);
 2014b6c:	008085f4 	movhi	r2,535
 2014b70:	10bd8204 	addi	r2,r2,-2552
 2014b74:	10800317 	ldw	r2,12(r2)
 2014b78:	10c00044 	addi	r3,r2,1
 2014b7c:	008085f4 	movhi	r2,535
 2014b80:	10bd8204 	addi	r2,r2,-2552
 2014b84:	10c00315 	stw	r3,12(r2)
			--ethernetif->lwipRxCount;
 2014b88:	e0bfff17 	ldw	r2,-4(fp)
 2014b8c:	10801517 	ldw	r2,84(r2)
 2014b90:	10ffffc4 	addi	r3,r2,-1
 2014b94:	e0bfff17 	ldw	r2,-4(fp)
 2014b98:	10c01515 	stw	r3,84(r2)

			enh_alt_irq_enable_all();
 2014b9c:	202dab00 	call	202dab0 <enh_alt_irq_enable_all>
 2014ba0:	00001706 	br	2014c00 <tse_mac_rcv+0x154>

			dprintf(("No free buffers for RX on iface: %hhd\n", ethernetif->iface));
		}
		else
		{
			ethernetif->bytes_recv += pklen;
 2014ba4:	e0bfff17 	ldw	r2,-4(fp)
 2014ba8:	10c00617 	ldw	r3,24(r2)
 2014bac:	e0bffb17 	ldw	r2,-20(fp)
 2014bb0:	1887883a 	add	r3,r3,r2
 2014bb4:	e0bfff17 	ldw	r2,-4(fp)
 2014bb8:	10c00615 	stw	r3,24(r2)

			//  Set up DMA for the next pbuf in the buffer
			if (++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER)
 2014bbc:	e0bfff17 	ldw	r2,-4(fp)
 2014bc0:	10801317 	ldw	r2,76(r2)
 2014bc4:	10800044 	addi	r2,r2,1
 2014bc8:	e0ffff17 	ldw	r3,-4(fp)
 2014bcc:	18801315 	stw	r2,76(r3)
 2014bd0:	10800310 	cmplti	r2,r2,12
 2014bd4:	1000021e 	bne	r2,zero,2014be0 <tse_mac_rcv+0x134>
				ethernetif->lwipRxIndexIsr = 0;
 2014bd8:	e0bfff17 	ldw	r2,-4(fp)
 2014bdc:	10001315 	stw	zero,76(r2)

			enh_alt_irq_enable_all();
 2014be0:	202dab00 	call	202dab0 <enh_alt_irq_enable_all>

#if LWIP_RECEIVE_SEMAPHORE
			// we can't use the LwIP sys_signal_sem since this can't be used in an ISR
			// release the semaphore and check if a task with a higher priority then the current one is waiting for it
			xSemaphoreGiveFromISR(&ethernetif->tse_info->rx_semaphore, &switch_context);
 2014be4:	e0bfff17 	ldw	r2,-4(fp)
 2014be8:	10801717 	ldw	r2,92(r2)
 2014bec:	10800804 	addi	r2,r2,32
 2014bf0:	e0fffe04 	addi	r3,fp,-8
 2014bf4:	180b883a 	mov	r5,r3
 2014bf8:	1009883a 	mov	r4,r2
 2014bfc:	200db200 	call	200db20 <xQueueGiveFromISR>
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
 2014c00:	e0bfff17 	ldw	r2,-4(fp)
 2014c04:	10801317 	ldw	r2,76(r2)
 2014c08:	e0ffff17 	ldw	r3,-4(fp)
 2014c0c:	108001c4 	addi	r2,r2,7
 2014c10:	1085883a 	add	r2,r2,r2
 2014c14:	1085883a 	add	r2,r2,r2
 2014c18:	1885883a 	add	r2,r3,r2
 2014c1c:	10800017 	ldw	r2,0(r2)
 2014c20:	10800117 	ldw	r2,4(r2)
 2014c24:	e0bffd15 	stw	r2,-12(fp)
	alt_avalon_sgdma_construct_stream_to_mem_desc(
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],	// descriptor I want to work with
 2014c28:	e0bffa17 	ldw	r2,-24(fp)
 2014c2c:	10800517 	ldw	r2,20(r2)
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014c30:	10c01004 	addi	r3,r2,64
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],	// descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
 2014c34:	e0bffa17 	ldw	r2,-24(fp)
 2014c38:	10800517 	ldw	r2,20(r2)
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014c3c:	10801804 	addi	r2,r2,96
 2014c40:	d8000015 	stw	zero,0(sp)
 2014c44:	000f883a 	mov	r7,zero
 2014c48:	e1bffd17 	ldw	r6,-12(fp)
 2014c4c:	100b883a 	mov	r5,r2
 2014c50:	1809883a 	mov	r4,r3
 2014c54:	202c0ac0 	call	202c0ac <alt_avalon_sgdma_construct_stream_to_mem_desc>
			0,                                  											// read until EOP
			0);          																	// don't write to constant address

#if LWIP_RECEIVE_SEMAPHORE
	// if it's waiting we will force a context switch so this task will run right away
	portEND_SWITCHING_ISR(switch_context);
 2014c58:	e0bffe17 	ldw	r2,-8(fp)
 2014c5c:	10000126 	beq	r2,zero,2014c64 <tse_mac_rcv+0x1b8>
 2014c60:	200fe500 	call	200fe50 <vTaskSwitchContext>
#endif

	return ERR_OK;
 2014c64:	0005883a 	mov	r2,zero
}
 2014c68:	e037883a 	mov	sp,fp
 2014c6c:	dfc00117 	ldw	ra,4(sp)
 2014c70:	df000017 	ldw	fp,0(sp)
 2014c74:	dec00204 	addi	sp,sp,8
 2014c78:	f800283a 	ret

02014c7c <sys_init>:
#endif

/* Initialize this module (see description in sys.h) */
void
sys_init(void)
{
 2014c7c:	deffff04 	addi	sp,sp,-4
 2014c80:	df000015 	stw	fp,0(sp)
 2014c84:	d839883a 	mov	fp,sp
  /* initialize sys_arch_protect global mutex */
  sys_arch_protect_mutex = xSemaphoreCreateRecursiveMutex();
  LWIP_ASSERT("failed to create sys_arch_protect mutex",
    sys_arch_protect_mutex != NULL);
#endif /* SYS_LIGHTWEIGHT_PROT && LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
}
 2014c88:	0001883a 	nop
 2014c8c:	e037883a 	mov	sp,fp
 2014c90:	df000017 	ldw	fp,0(sp)
 2014c94:	dec00104 	addi	sp,sp,4
 2014c98:	f800283a 	ret

02014c9c <sys_now>:
#endif

#if LWIP_FREERTOS_SYS_NOW_FROM_FREERTOS
u32_t
sys_now(void)
{
 2014c9c:	defffe04 	addi	sp,sp,-8
 2014ca0:	dfc00115 	stw	ra,4(sp)
 2014ca4:	df000015 	stw	fp,0(sp)
 2014ca8:	d839883a 	mov	fp,sp
  return xTaskGetTickCount() * portTICK_PERIOD_MS;
 2014cac:	200fa180 	call	200fa18 <xTaskGetTickCount>
}
 2014cb0:	e037883a 	mov	sp,fp
 2014cb4:	dfc00117 	ldw	ra,4(sp)
 2014cb8:	df000017 	ldw	fp,0(sp)
 2014cbc:	dec00204 	addi	sp,sp,8
 2014cc0:	f800283a 	ret

02014cc4 <sys_jiffies>:
#endif

u32_t
sys_jiffies(void)
{
 2014cc4:	defffe04 	addi	sp,sp,-8
 2014cc8:	dfc00115 	stw	ra,4(sp)
 2014ccc:	df000015 	stw	fp,0(sp)
 2014cd0:	d839883a 	mov	fp,sp
  return xTaskGetTickCount();
 2014cd4:	200fa180 	call	200fa18 <xTaskGetTickCount>
}
 2014cd8:	e037883a 	mov	sp,fp
 2014cdc:	dfc00117 	ldw	ra,4(sp)
 2014ce0:	df000017 	ldw	fp,0(sp)
 2014ce4:	dec00204 	addi	sp,sp,8
 2014ce8:	f800283a 	ret

02014cec <sys_arch_protect>:

#if SYS_LIGHTWEIGHT_PROT

sys_prot_t
sys_arch_protect(void)
{
 2014cec:	defffe04 	addi	sp,sp,-8
 2014cf0:	dfc00115 	stw	ra,4(sp)
 2014cf4:	df000015 	stw	fp,0(sp)
 2014cf8:	d839883a 	mov	fp,sp
  LWIP_ASSERT("sys_arch_protect_mutex != NULL", sys_arch_protect_mutex != NULL);

  ret = xSemaphoreTakeRecursive(sys_arch_protect_mutex, portMAX_DELAY);
  LWIP_ASSERT("sys_arch_protect failed to take the mutex", ret == pdTRUE);
#else /* LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
  taskENTER_CRITICAL();
 2014cfc:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2014d00:	10000126 	beq	r2,zero,2014d08 <sys_arch_protect+0x1c>
 2014d04:	2010de80 	call	2010de8 <vTaskEnterCritical>
    sys_arch_protect_nesting++;
    LWIP_ASSERT("sys_arch_protect overflow", sys_arch_protect_nesting > ret);
    return ret;
  }
#else
  return 1;
 2014d08:	00800044 	movi	r2,1
#endif
}
 2014d0c:	e037883a 	mov	sp,fp
 2014d10:	dfc00117 	ldw	ra,4(sp)
 2014d14:	df000017 	ldw	fp,0(sp)
 2014d18:	dec00204 	addi	sp,sp,8
 2014d1c:	f800283a 	ret

02014d20 <sys_arch_unprotect>:

void
sys_arch_unprotect(sys_prot_t pval)
{
 2014d20:	defffd04 	addi	sp,sp,-12
 2014d24:	dfc00215 	stw	ra,8(sp)
 2014d28:	df000115 	stw	fp,4(sp)
 2014d2c:	df000104 	addi	fp,sp,4
 2014d30:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("sys_arch_protect_mutex != NULL", sys_arch_protect_mutex != NULL);

  ret = xSemaphoreGiveRecursive(sys_arch_protect_mutex);
  LWIP_ASSERT("sys_arch_unprotect failed to give the mutex", ret == pdTRUE);
#else /* LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
  taskEXIT_CRITICAL();
 2014d34:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 2014d38:	10000126 	beq	r2,zero,2014d40 <sys_arch_unprotect+0x20>
 2014d3c:	2010e300 	call	2010e30 <vTaskExitCritical>
#endif /* LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
  LWIP_UNUSED_ARG(pval);
}
 2014d40:	0001883a 	nop
 2014d44:	e037883a 	mov	sp,fp
 2014d48:	dfc00117 	ldw	ra,4(sp)
 2014d4c:	df000017 	ldw	fp,0(sp)
 2014d50:	dec00204 	addi	sp,sp,8
 2014d54:	f800283a 	ret

02014d58 <sys_arch_msleep>:

#endif /* SYS_LIGHTWEIGHT_PROT */

void
sys_arch_msleep(u32_t delay_ms)
{
 2014d58:	defffc04 	addi	sp,sp,-16
 2014d5c:	dfc00315 	stw	ra,12(sp)
 2014d60:	df000215 	stw	fp,8(sp)
 2014d64:	df000204 	addi	fp,sp,8
 2014d68:	e13fff15 	stw	r4,-4(fp)
  TickType_t delay_ticks = delay_ms / portTICK_RATE_MS;
 2014d6c:	e0bfff17 	ldw	r2,-4(fp)
 2014d70:	e0bffe15 	stw	r2,-8(fp)
  vTaskDelay(delay_ticks);
 2014d74:	e13ffe17 	ldw	r4,-8(fp)
 2014d78:	200f0980 	call	200f098 <vTaskDelay>
}
 2014d7c:	0001883a 	nop
 2014d80:	e037883a 	mov	sp,fp
 2014d84:	dfc00117 	ldw	ra,4(sp)
 2014d88:	df000017 	ldw	fp,0(sp)
 2014d8c:	dec00204 	addi	sp,sp,8
 2014d90:	f800283a 	ret

02014d94 <sys_mutex_new>:
#if !LWIP_COMPAT_MUTEX

/* Create a new mutex*/
err_t
sys_mutex_new(sys_mutex_t *mutex)
{
 2014d94:	defffd04 	addi	sp,sp,-12
 2014d98:	dfc00215 	stw	ra,8(sp)
 2014d9c:	df000115 	stw	fp,4(sp)
 2014da0:	df000104 	addi	fp,sp,4
 2014da4:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("mutex != NULL", mutex != NULL);

  mutex->mut = xSemaphoreCreateRecursiveMutex();
 2014da8:	01000104 	movi	r4,4
 2014dac:	200d6680 	call	200d668 <xQueueCreateMutex>
 2014db0:	1007883a 	mov	r3,r2
 2014db4:	e0bfff17 	ldw	r2,-4(fp)
 2014db8:	10c00015 	stw	r3,0(r2)
  if(mutex->mut == NULL) {
 2014dbc:	e0bfff17 	ldw	r2,-4(fp)
 2014dc0:	10800017 	ldw	r2,0(r2)
 2014dc4:	1000091e 	bne	r2,zero,2014dec <sys_mutex_new+0x58>
    SYS_STATS_INC(mutex.err);
 2014dc8:	008085f4 	movhi	r2,535
 2014dcc:	10bd8204 	addi	r2,r2,-2552
 2014dd0:	10806c17 	ldw	r2,432(r2)
 2014dd4:	10c00044 	addi	r3,r2,1
 2014dd8:	008085f4 	movhi	r2,535
 2014ddc:	10bd8204 	addi	r2,r2,-2552
 2014de0:	10c06c15 	stw	r3,432(r2)
    return ERR_MEM;
 2014de4:	00bfffc4 	movi	r2,-1
 2014de8:	00001506 	br	2014e40 <sys_mutex_new+0xac>
  }
  SYS_STATS_INC_USED(mutex);
 2014dec:	008085f4 	movhi	r2,535
 2014df0:	10bd8204 	addi	r2,r2,-2552
 2014df4:	10806a17 	ldw	r2,424(r2)
 2014df8:	10c00044 	addi	r3,r2,1
 2014dfc:	008085f4 	movhi	r2,535
 2014e00:	10bd8204 	addi	r2,r2,-2552
 2014e04:	10c06a15 	stw	r3,424(r2)
 2014e08:	008085f4 	movhi	r2,535
 2014e0c:	10bd8204 	addi	r2,r2,-2552
 2014e10:	10c06b17 	ldw	r3,428(r2)
 2014e14:	008085f4 	movhi	r2,535
 2014e18:	10bd8204 	addi	r2,r2,-2552
 2014e1c:	10806a17 	ldw	r2,424(r2)
 2014e20:	1880062e 	bgeu	r3,r2,2014e3c <sys_mutex_new+0xa8>
 2014e24:	008085f4 	movhi	r2,535
 2014e28:	10bd8204 	addi	r2,r2,-2552
 2014e2c:	10c06a17 	ldw	r3,424(r2)
 2014e30:	008085f4 	movhi	r2,535
 2014e34:	10bd8204 	addi	r2,r2,-2552
 2014e38:	10c06b15 	stw	r3,428(r2)
  return ERR_OK;
 2014e3c:	0005883a 	mov	r2,zero
}
 2014e40:	e037883a 	mov	sp,fp
 2014e44:	dfc00117 	ldw	ra,4(sp)
 2014e48:	df000017 	ldw	fp,0(sp)
 2014e4c:	dec00204 	addi	sp,sp,8
 2014e50:	f800283a 	ret

02014e54 <sys_mutex_lock>:

void
sys_mutex_lock(sys_mutex_t *mutex)
{
 2014e54:	defffc04 	addi	sp,sp,-16
 2014e58:	dfc00315 	stw	ra,12(sp)
 2014e5c:	df000215 	stw	fp,8(sp)
 2014e60:	df000204 	addi	fp,sp,8
 2014e64:	e13fff15 	stw	r4,-4(fp)
  BaseType_t ret;
  LWIP_ASSERT("mutex != NULL", mutex != NULL);
  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);

  ret = xSemaphoreTakeRecursive(mutex->mut, portMAX_DELAY);
 2014e68:	e0bfff17 	ldw	r2,-4(fp)
 2014e6c:	10800017 	ldw	r2,0(r2)
 2014e70:	017fffc4 	movi	r5,-1
 2014e74:	1009883a 	mov	r4,r2
 2014e78:	200d7540 	call	200d754 <xQueueTakeMutexRecursive>
 2014e7c:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ASSERT("failed to take the mutex", ret == pdTRUE);
}
 2014e80:	0001883a 	nop
 2014e84:	e037883a 	mov	sp,fp
 2014e88:	dfc00117 	ldw	ra,4(sp)
 2014e8c:	df000017 	ldw	fp,0(sp)
 2014e90:	dec00204 	addi	sp,sp,8
 2014e94:	f800283a 	ret

02014e98 <sys_mutex_unlock>:

void
sys_mutex_unlock(sys_mutex_t *mutex)
{
 2014e98:	defffc04 	addi	sp,sp,-16
 2014e9c:	dfc00315 	stw	ra,12(sp)
 2014ea0:	df000215 	stw	fp,8(sp)
 2014ea4:	df000204 	addi	fp,sp,8
 2014ea8:	e13fff15 	stw	r4,-4(fp)
  BaseType_t ret;
  LWIP_ASSERT("mutex != NULL", mutex != NULL);
  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);

  ret = xSemaphoreGiveRecursive(mutex->mut);
 2014eac:	e0bfff17 	ldw	r2,-4(fp)
 2014eb0:	10800017 	ldw	r2,0(r2)
 2014eb4:	1009883a 	mov	r4,r2
 2014eb8:	200d6c40 	call	200d6c4 <xQueueGiveMutexRecursive>
 2014ebc:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ASSERT("failed to give the mutex", ret == pdTRUE);
}
 2014ec0:	0001883a 	nop
 2014ec4:	e037883a 	mov	sp,fp
 2014ec8:	dfc00117 	ldw	ra,4(sp)
 2014ecc:	df000017 	ldw	fp,0(sp)
 2014ed0:	dec00204 	addi	sp,sp,8
 2014ed4:	f800283a 	ret

02014ed8 <sys_mutex_free>:

void
sys_mutex_free(sys_mutex_t *mutex)
{
 2014ed8:	defffd04 	addi	sp,sp,-12
 2014edc:	dfc00215 	stw	ra,8(sp)
 2014ee0:	df000115 	stw	fp,4(sp)
 2014ee4:	df000104 	addi	fp,sp,4
 2014ee8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("mutex != NULL", mutex != NULL);
  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);

  SYS_STATS_DEC(mutex.used);
 2014eec:	008085f4 	movhi	r2,535
 2014ef0:	10bd8204 	addi	r2,r2,-2552
 2014ef4:	10806a17 	ldw	r2,424(r2)
 2014ef8:	10ffffc4 	addi	r3,r2,-1
 2014efc:	008085f4 	movhi	r2,535
 2014f00:	10bd8204 	addi	r2,r2,-2552
 2014f04:	10c06a15 	stw	r3,424(r2)
  vSemaphoreDelete(mutex->mut);
 2014f08:	e0bfff17 	ldw	r2,-4(fp)
 2014f0c:	10800017 	ldw	r2,0(r2)
 2014f10:	1009883a 	mov	r4,r2
 2014f14:	200e4600 	call	200e460 <vQueueDelete>
  mutex->mut = NULL;
 2014f18:	e0bfff17 	ldw	r2,-4(fp)
 2014f1c:	10000015 	stw	zero,0(r2)
}
 2014f20:	0001883a 	nop
 2014f24:	e037883a 	mov	sp,fp
 2014f28:	dfc00117 	ldw	ra,4(sp)
 2014f2c:	df000017 	ldw	fp,0(sp)
 2014f30:	dec00204 	addi	sp,sp,8
 2014f34:	f800283a 	ret

02014f38 <sys_sem_new>:

#endif /* !LWIP_COMPAT_MUTEX */

err_t
sys_sem_new(sys_sem_t *sem, u8_t initial_count)
{
 2014f38:	defffb04 	addi	sp,sp,-20
 2014f3c:	dfc00415 	stw	ra,16(sp)
 2014f40:	df000315 	stw	fp,12(sp)
 2014f44:	df000304 	addi	fp,sp,12
 2014f48:	e13ffe15 	stw	r4,-8(fp)
 2014f4c:	2805883a 	mov	r2,r5
 2014f50:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("sem != NULL", sem != NULL);
  LWIP_ASSERT("initial_count invalid (not 0 or 1)",
    (initial_count == 0) || (initial_count == 1));

  sem->sem = xSemaphoreCreateBinary();
 2014f54:	018000c4 	movi	r6,3
 2014f58:	000b883a 	mov	r5,zero
 2014f5c:	01000044 	movi	r4,1
 2014f60:	200d4e00 	call	200d4e0 <xQueueGenericCreate>
 2014f64:	1007883a 	mov	r3,r2
 2014f68:	e0bffe17 	ldw	r2,-8(fp)
 2014f6c:	10c00015 	stw	r3,0(r2)
  if(sem->sem == NULL) {
 2014f70:	e0bffe17 	ldw	r2,-8(fp)
 2014f74:	10800017 	ldw	r2,0(r2)
 2014f78:	1000091e 	bne	r2,zero,2014fa0 <sys_sem_new+0x68>
    SYS_STATS_INC(sem.err);
 2014f7c:	008085f4 	movhi	r2,535
 2014f80:	10bd8204 	addi	r2,r2,-2552
 2014f84:	10806917 	ldw	r2,420(r2)
 2014f88:	10c00044 	addi	r3,r2,1
 2014f8c:	008085f4 	movhi	r2,535
 2014f90:	10bd8204 	addi	r2,r2,-2552
 2014f94:	10c06915 	stw	r3,420(r2)
    return ERR_MEM;
 2014f98:	00bfffc4 	movi	r2,-1
 2014f9c:	00002006 	br	2015020 <sys_sem_new+0xe8>
  }
  SYS_STATS_INC_USED(sem);
 2014fa0:	008085f4 	movhi	r2,535
 2014fa4:	10bd8204 	addi	r2,r2,-2552
 2014fa8:	10806717 	ldw	r2,412(r2)
 2014fac:	10c00044 	addi	r3,r2,1
 2014fb0:	008085f4 	movhi	r2,535
 2014fb4:	10bd8204 	addi	r2,r2,-2552
 2014fb8:	10c06715 	stw	r3,412(r2)
 2014fbc:	008085f4 	movhi	r2,535
 2014fc0:	10bd8204 	addi	r2,r2,-2552
 2014fc4:	10c06817 	ldw	r3,416(r2)
 2014fc8:	008085f4 	movhi	r2,535
 2014fcc:	10bd8204 	addi	r2,r2,-2552
 2014fd0:	10806717 	ldw	r2,412(r2)
 2014fd4:	1880062e 	bgeu	r3,r2,2014ff0 <sys_sem_new+0xb8>
 2014fd8:	008085f4 	movhi	r2,535
 2014fdc:	10bd8204 	addi	r2,r2,-2552
 2014fe0:	10c06717 	ldw	r3,412(r2)
 2014fe4:	008085f4 	movhi	r2,535
 2014fe8:	10bd8204 	addi	r2,r2,-2552
 2014fec:	10c06815 	stw	r3,416(r2)

  if(initial_count == 1) {
 2014ff0:	e0bfff03 	ldbu	r2,-4(fp)
 2014ff4:	10800058 	cmpnei	r2,r2,1
 2014ff8:	1000081e 	bne	r2,zero,201501c <sys_sem_new+0xe4>
    BaseType_t ret = xSemaphoreGive(sem->sem);
 2014ffc:	e0bffe17 	ldw	r2,-8(fp)
 2015000:	10800017 	ldw	r2,0(r2)
 2015004:	000f883a 	mov	r7,zero
 2015008:	000d883a 	mov	r6,zero
 201500c:	000b883a 	mov	r5,zero
 2015010:	1009883a 	mov	r4,r2
 2015014:	200d8480 	call	200d848 <xQueueGenericSend>
 2015018:	e0bffd15 	stw	r2,-12(fp)
    LWIP_ASSERT("sys_sem_new: initial give failed", ret == pdTRUE);
  }
  return ERR_OK;
 201501c:	0005883a 	mov	r2,zero
}
 2015020:	e037883a 	mov	sp,fp
 2015024:	dfc00117 	ldw	ra,4(sp)
 2015028:	df000017 	ldw	fp,0(sp)
 201502c:	dec00204 	addi	sp,sp,8
 2015030:	f800283a 	ret

02015034 <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t *sem)
{
 2015034:	defffc04 	addi	sp,sp,-16
 2015038:	dfc00315 	stw	ra,12(sp)
 201503c:	df000215 	stw	fp,8(sp)
 2015040:	df000204 	addi	fp,sp,8
 2015044:	e13fff15 	stw	r4,-4(fp)
  BaseType_t ret;
  LWIP_ASSERT("sem != NULL", sem != NULL);
  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);

  ret = xSemaphoreGive(sem->sem);
 2015048:	e0bfff17 	ldw	r2,-4(fp)
 201504c:	10800017 	ldw	r2,0(r2)
 2015050:	000f883a 	mov	r7,zero
 2015054:	000d883a 	mov	r6,zero
 2015058:	000b883a 	mov	r5,zero
 201505c:	1009883a 	mov	r4,r2
 2015060:	200d8480 	call	200d848 <xQueueGenericSend>
 2015064:	e0bffe15 	stw	r2,-8(fp)
  /* queue full is OK, this is a signal only... */
  LWIP_ASSERT("sys_sem_signal: sane return value",
    (ret == pdTRUE) || (ret == errQUEUE_FULL));
}
 2015068:	0001883a 	nop
 201506c:	e037883a 	mov	sp,fp
 2015070:	dfc00117 	ldw	ra,4(sp)
 2015074:	df000017 	ldw	fp,0(sp)
 2015078:	dec00204 	addi	sp,sp,8
 201507c:	f800283a 	ret

02015080 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout_ms)
{
 2015080:	defffa04 	addi	sp,sp,-24
 2015084:	dfc00515 	stw	ra,20(sp)
 2015088:	df000415 	stw	fp,16(sp)
 201508c:	df000404 	addi	fp,sp,16
 2015090:	e13ffe15 	stw	r4,-8(fp)
 2015094:	e17fff15 	stw	r5,-4(fp)
  BaseType_t ret;
  LWIP_ASSERT("sem != NULL", sem != NULL);
  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);

  if(!timeout_ms) {
 2015098:	e0bfff17 	ldw	r2,-4(fp)
 201509c:	1000071e 	bne	r2,zero,20150bc <sys_arch_sem_wait+0x3c>
    /* wait infinite */
    ret = xSemaphoreTake(sem->sem, portMAX_DELAY);
 20150a0:	e0bffe17 	ldw	r2,-8(fp)
 20150a4:	10800017 	ldw	r2,0(r2)
 20150a8:	017fffc4 	movi	r5,-1
 20150ac:	1009883a 	mov	r4,r2
 20150b0:	200ddd40 	call	200ddd4 <xQueueSemaphoreTake>
 20150b4:	e0bffd15 	stw	r2,-12(fp)
 20150b8:	00000c06 	br	20150ec <sys_arch_sem_wait+0x6c>
    LWIP_ASSERT("taking semaphore failed", ret == pdTRUE);
  } else {
    TickType_t timeout_ticks = timeout_ms / portTICK_RATE_MS;
 20150bc:	e0bfff17 	ldw	r2,-4(fp)
 20150c0:	e0bffc15 	stw	r2,-16(fp)
    ret = xSemaphoreTake(sem->sem, timeout_ticks);
 20150c4:	e0bffe17 	ldw	r2,-8(fp)
 20150c8:	10800017 	ldw	r2,0(r2)
 20150cc:	e17ffc17 	ldw	r5,-16(fp)
 20150d0:	1009883a 	mov	r4,r2
 20150d4:	200ddd40 	call	200ddd4 <xQueueSemaphoreTake>
 20150d8:	e0bffd15 	stw	r2,-12(fp)
    if (ret == errQUEUE_EMPTY) {
 20150dc:	e0bffd17 	ldw	r2,-12(fp)
 20150e0:	1000021e 	bne	r2,zero,20150ec <sys_arch_sem_wait+0x6c>
      /* timed out */
      return SYS_ARCH_TIMEOUT;
 20150e4:	00bfffc4 	movi	r2,-1
 20150e8:	00000106 	br	20150f0 <sys_arch_sem_wait+0x70>
  }

  /* Old versions of lwIP required us to return the time waited.
     This is not the case any more. Just returning != SYS_ARCH_TIMEOUT
     here is enough. */
  return 1;
 20150ec:	00800044 	movi	r2,1
}
 20150f0:	e037883a 	mov	sp,fp
 20150f4:	dfc00117 	ldw	ra,4(sp)
 20150f8:	df000017 	ldw	fp,0(sp)
 20150fc:	dec00204 	addi	sp,sp,8
 2015100:	f800283a 	ret

02015104 <sys_sem_free>:

void
sys_sem_free(sys_sem_t *sem)
{
 2015104:	defffd04 	addi	sp,sp,-12
 2015108:	dfc00215 	stw	ra,8(sp)
 201510c:	df000115 	stw	fp,4(sp)
 2015110:	df000104 	addi	fp,sp,4
 2015114:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("sem != NULL", sem != NULL);
  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);

  SYS_STATS_DEC(sem.used);
 2015118:	008085f4 	movhi	r2,535
 201511c:	10bd8204 	addi	r2,r2,-2552
 2015120:	10806717 	ldw	r2,412(r2)
 2015124:	10ffffc4 	addi	r3,r2,-1
 2015128:	008085f4 	movhi	r2,535
 201512c:	10bd8204 	addi	r2,r2,-2552
 2015130:	10c06715 	stw	r3,412(r2)
  vSemaphoreDelete(sem->sem);
 2015134:	e0bfff17 	ldw	r2,-4(fp)
 2015138:	10800017 	ldw	r2,0(r2)
 201513c:	1009883a 	mov	r4,r2
 2015140:	200e4600 	call	200e460 <vQueueDelete>
  sem->sem = NULL;
 2015144:	e0bfff17 	ldw	r2,-4(fp)
 2015148:	10000015 	stw	zero,0(r2)
}
 201514c:	0001883a 	nop
 2015150:	e037883a 	mov	sp,fp
 2015154:	dfc00117 	ldw	ra,4(sp)
 2015158:	df000017 	ldw	fp,0(sp)
 201515c:	dec00204 	addi	sp,sp,8
 2015160:	f800283a 	ret

02015164 <sys_mbox_new>:

err_t
sys_mbox_new(sys_mbox_t *mbox, int size)
{
 2015164:	defffc04 	addi	sp,sp,-16
 2015168:	dfc00315 	stw	ra,12(sp)
 201516c:	df000215 	stw	fp,8(sp)
 2015170:	df000204 	addi	fp,sp,8
 2015174:	e13ffe15 	stw	r4,-8(fp)
 2015178:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("mbox != NULL", mbox != NULL);
  LWIP_ASSERT("size > 0", size > 0);

  mbox->mbx = xQueueCreate((UBaseType_t)size, sizeof(void *));
 201517c:	e0bfff17 	ldw	r2,-4(fp)
 2015180:	000d883a 	mov	r6,zero
 2015184:	01400104 	movi	r5,4
 2015188:	1009883a 	mov	r4,r2
 201518c:	200d4e00 	call	200d4e0 <xQueueGenericCreate>
 2015190:	1007883a 	mov	r3,r2
 2015194:	e0bffe17 	ldw	r2,-8(fp)
 2015198:	10c00015 	stw	r3,0(r2)
  if(mbox->mbx == NULL) {
 201519c:	e0bffe17 	ldw	r2,-8(fp)
 20151a0:	10800017 	ldw	r2,0(r2)
 20151a4:	1000091e 	bne	r2,zero,20151cc <sys_mbox_new+0x68>
    SYS_STATS_INC(mbox.err);
 20151a8:	008085f4 	movhi	r2,535
 20151ac:	10bd8204 	addi	r2,r2,-2552
 20151b0:	10806f17 	ldw	r2,444(r2)
 20151b4:	10c00044 	addi	r3,r2,1
 20151b8:	008085f4 	movhi	r2,535
 20151bc:	10bd8204 	addi	r2,r2,-2552
 20151c0:	10c06f15 	stw	r3,444(r2)
    return ERR_MEM;
 20151c4:	00bfffc4 	movi	r2,-1
 20151c8:	00001506 	br	2015220 <sys_mbox_new+0xbc>
  }
  SYS_STATS_INC_USED(mbox);
 20151cc:	008085f4 	movhi	r2,535
 20151d0:	10bd8204 	addi	r2,r2,-2552
 20151d4:	10806d17 	ldw	r2,436(r2)
 20151d8:	10c00044 	addi	r3,r2,1
 20151dc:	008085f4 	movhi	r2,535
 20151e0:	10bd8204 	addi	r2,r2,-2552
 20151e4:	10c06d15 	stw	r3,436(r2)
 20151e8:	008085f4 	movhi	r2,535
 20151ec:	10bd8204 	addi	r2,r2,-2552
 20151f0:	10c06e17 	ldw	r3,440(r2)
 20151f4:	008085f4 	movhi	r2,535
 20151f8:	10bd8204 	addi	r2,r2,-2552
 20151fc:	10806d17 	ldw	r2,436(r2)
 2015200:	1880062e 	bgeu	r3,r2,201521c <sys_mbox_new+0xb8>
 2015204:	008085f4 	movhi	r2,535
 2015208:	10bd8204 	addi	r2,r2,-2552
 201520c:	10c06d17 	ldw	r3,436(r2)
 2015210:	008085f4 	movhi	r2,535
 2015214:	10bd8204 	addi	r2,r2,-2552
 2015218:	10c06e15 	stw	r3,440(r2)
  return ERR_OK;
 201521c:	0005883a 	mov	r2,zero
}
 2015220:	e037883a 	mov	sp,fp
 2015224:	dfc00117 	ldw	ra,4(sp)
 2015228:	df000017 	ldw	fp,0(sp)
 201522c:	dec00204 	addi	sp,sp,8
 2015230:	f800283a 	ret

02015234 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
 2015234:	defffb04 	addi	sp,sp,-20
 2015238:	dfc00415 	stw	ra,16(sp)
 201523c:	df000315 	stw	fp,12(sp)
 2015240:	df000304 	addi	fp,sp,12
 2015244:	e13ffe15 	stw	r4,-8(fp)
 2015248:	e17fff15 	stw	r5,-4(fp)
  BaseType_t ret;
  LWIP_ASSERT("mbox != NULL", mbox != NULL);
  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);

  ret = xQueueSendToBack(mbox->mbx, &msg, portMAX_DELAY);
 201524c:	e0bffe17 	ldw	r2,-8(fp)
 2015250:	10800017 	ldw	r2,0(r2)
 2015254:	e0ffff04 	addi	r3,fp,-4
 2015258:	000f883a 	mov	r7,zero
 201525c:	01bfffc4 	movi	r6,-1
 2015260:	180b883a 	mov	r5,r3
 2015264:	1009883a 	mov	r4,r2
 2015268:	200d8480 	call	200d848 <xQueueGenericSend>
 201526c:	e0bffd15 	stw	r2,-12(fp)
  LWIP_ASSERT("mbox post failed", ret == pdTRUE);
}
 2015270:	0001883a 	nop
 2015274:	e037883a 	mov	sp,fp
 2015278:	dfc00117 	ldw	ra,4(sp)
 201527c:	df000017 	ldw	fp,0(sp)
 2015280:	dec00204 	addi	sp,sp,8
 2015284:	f800283a 	ret

02015288 <sys_mbox_trypost>:

err_t
sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
 2015288:	defffb04 	addi	sp,sp,-20
 201528c:	dfc00415 	stw	ra,16(sp)
 2015290:	df000315 	stw	fp,12(sp)
 2015294:	df000304 	addi	fp,sp,12
 2015298:	e13ffe15 	stw	r4,-8(fp)
 201529c:	e17fff15 	stw	r5,-4(fp)
  BaseType_t ret;
  LWIP_ASSERT("mbox != NULL", mbox != NULL);
  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);

  ret = xQueueSendToBack(mbox->mbx, &msg, 0);
 20152a0:	e0bffe17 	ldw	r2,-8(fp)
 20152a4:	10800017 	ldw	r2,0(r2)
 20152a8:	e0ffff04 	addi	r3,fp,-4
 20152ac:	000f883a 	mov	r7,zero
 20152b0:	000d883a 	mov	r6,zero
 20152b4:	180b883a 	mov	r5,r3
 20152b8:	1009883a 	mov	r4,r2
 20152bc:	200d8480 	call	200d848 <xQueueGenericSend>
 20152c0:	e0bffd15 	stw	r2,-12(fp)
  if (ret == pdTRUE) {
 20152c4:	e0bffd17 	ldw	r2,-12(fp)
 20152c8:	10800058 	cmpnei	r2,r2,1
 20152cc:	1000021e 	bne	r2,zero,20152d8 <sys_mbox_trypost+0x50>
    return ERR_OK;
 20152d0:	0005883a 	mov	r2,zero
 20152d4:	00000806 	br	20152f8 <sys_mbox_trypost+0x70>
  } else {
    LWIP_ASSERT("mbox trypost failed", ret == errQUEUE_FULL);
    SYS_STATS_INC(mbox.err);
 20152d8:	008085f4 	movhi	r2,535
 20152dc:	10bd8204 	addi	r2,r2,-2552
 20152e0:	10806f17 	ldw	r2,444(r2)
 20152e4:	10c00044 	addi	r3,r2,1
 20152e8:	008085f4 	movhi	r2,535
 20152ec:	10bd8204 	addi	r2,r2,-2552
 20152f0:	10c06f15 	stw	r3,444(r2)
    return ERR_MEM;
 20152f4:	00bfffc4 	movi	r2,-1
  }
}
 20152f8:	e037883a 	mov	sp,fp
 20152fc:	dfc00117 	ldw	ra,4(sp)
 2015300:	df000017 	ldw	fp,0(sp)
 2015304:	dec00204 	addi	sp,sp,8
 2015308:	f800283a 	ret

0201530c <sys_mbox_trypost_fromisr>:

err_t
sys_mbox_trypost_fromisr(sys_mbox_t *mbox, void *msg)
{
 201530c:	defffa04 	addi	sp,sp,-24
 2015310:	dfc00515 	stw	ra,20(sp)
 2015314:	df000415 	stw	fp,16(sp)
 2015318:	df000404 	addi	fp,sp,16
 201531c:	e13ffe15 	stw	r4,-8(fp)
 2015320:	e17fff15 	stw	r5,-4(fp)
  BaseType_t ret;
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 2015324:	e03ffd15 	stw	zero,-12(fp)
  LWIP_ASSERT("mbox != NULL", mbox != NULL);
  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);

  ret = xQueueSendToBackFromISR(mbox->mbx, &msg, &xHigherPriorityTaskWoken);
 2015328:	e0bffe17 	ldw	r2,-8(fp)
 201532c:	10800017 	ldw	r2,0(r2)
 2015330:	e13ffd04 	addi	r4,fp,-12
 2015334:	e0ffff04 	addi	r3,fp,-4
 2015338:	000f883a 	mov	r7,zero
 201533c:	200d883a 	mov	r6,r4
 2015340:	180b883a 	mov	r5,r3
 2015344:	1009883a 	mov	r4,r2
 2015348:	200da2c0 	call	200da2c <xQueueGenericSendFromISR>
 201534c:	e0bffc15 	stw	r2,-16(fp)
  if (ret == pdTRUE) {
 2015350:	e0bffc17 	ldw	r2,-16(fp)
 2015354:	10800058 	cmpnei	r2,r2,1
 2015358:	1000071e 	bne	r2,zero,2015378 <sys_mbox_trypost_fromisr+0x6c>
    if (xHigherPriorityTaskWoken == pdTRUE) {
 201535c:	e0bffd17 	ldw	r2,-12(fp)
 2015360:	10800058 	cmpnei	r2,r2,1
 2015364:	1000021e 	bne	r2,zero,2015370 <sys_mbox_trypost_fromisr+0x64>
      return ERR_NEED_SCHED;
 2015368:	00801ec4 	movi	r2,123
 201536c:	00000a06 	br	2015398 <sys_mbox_trypost_fromisr+0x8c>
    }
    return ERR_OK;
 2015370:	0005883a 	mov	r2,zero
 2015374:	00000806 	br	2015398 <sys_mbox_trypost_fromisr+0x8c>
  } else {
    LWIP_ASSERT("mbox trypost failed", ret == errQUEUE_FULL);
    SYS_STATS_INC(mbox.err);
 2015378:	008085f4 	movhi	r2,535
 201537c:	10bd8204 	addi	r2,r2,-2552
 2015380:	10806f17 	ldw	r2,444(r2)
 2015384:	10c00044 	addi	r3,r2,1
 2015388:	008085f4 	movhi	r2,535
 201538c:	10bd8204 	addi	r2,r2,-2552
 2015390:	10c06f15 	stw	r3,444(r2)
    return ERR_MEM;
 2015394:	00bfffc4 	movi	r2,-1
  }
}
 2015398:	e037883a 	mov	sp,fp
 201539c:	dfc00117 	ldw	ra,4(sp)
 20153a0:	df000017 	ldw	fp,0(sp)
 20153a4:	dec00204 	addi	sp,sp,8
 20153a8:	f800283a 	ret

020153ac <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout_ms)
{
 20153ac:	defff804 	addi	sp,sp,-32
 20153b0:	dfc00715 	stw	ra,28(sp)
 20153b4:	df000615 	stw	fp,24(sp)
 20153b8:	df000604 	addi	fp,sp,24
 20153bc:	e13ffd15 	stw	r4,-12(fp)
 20153c0:	e17ffe15 	stw	r5,-8(fp)
 20153c4:	e1bfff15 	stw	r6,-4(fp)
  BaseType_t ret;
  void *msg_dummy;
  LWIP_ASSERT("mbox != NULL", mbox != NULL);
  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);

  if (!msg) {
 20153c8:	e0bffe17 	ldw	r2,-8(fp)
 20153cc:	1000021e 	bne	r2,zero,20153d8 <sys_arch_mbox_fetch+0x2c>
    msg = &msg_dummy;
 20153d0:	e0bffc04 	addi	r2,fp,-16
 20153d4:	e0bffe15 	stw	r2,-8(fp)
  }

  if (!timeout_ms) {
 20153d8:	e0bfff17 	ldw	r2,-4(fp)
 20153dc:	1000081e 	bne	r2,zero,2015400 <sys_arch_mbox_fetch+0x54>
    /* wait infinite */
    ret = xQueueReceive(mbox->mbx, &(*msg), portMAX_DELAY);
 20153e0:	e0bffd17 	ldw	r2,-12(fp)
 20153e4:	10800017 	ldw	r2,0(r2)
 20153e8:	01bfffc4 	movi	r6,-1
 20153ec:	e17ffe17 	ldw	r5,-8(fp)
 20153f0:	1009883a 	mov	r4,r2
 20153f4:	200dbfc0 	call	200dbfc <xQueueReceive>
 20153f8:	e0bffb15 	stw	r2,-20(fp)
 20153fc:	00000f06 	br	201543c <sys_arch_mbox_fetch+0x90>
    LWIP_ASSERT("mbox fetch failed", ret == pdTRUE);
  } else {
    TickType_t timeout_ticks = timeout_ms / portTICK_RATE_MS;
 2015400:	e0bfff17 	ldw	r2,-4(fp)
 2015404:	e0bffa15 	stw	r2,-24(fp)
    ret = xQueueReceive(mbox->mbx, &(*msg), timeout_ticks);
 2015408:	e0bffd17 	ldw	r2,-12(fp)
 201540c:	10800017 	ldw	r2,0(r2)
 2015410:	e1bffa17 	ldw	r6,-24(fp)
 2015414:	e17ffe17 	ldw	r5,-8(fp)
 2015418:	1009883a 	mov	r4,r2
 201541c:	200dbfc0 	call	200dbfc <xQueueReceive>
 2015420:	e0bffb15 	stw	r2,-20(fp)
    if (ret == errQUEUE_EMPTY) {
 2015424:	e0bffb17 	ldw	r2,-20(fp)
 2015428:	1000041e 	bne	r2,zero,201543c <sys_arch_mbox_fetch+0x90>
      /* timed out */
      *msg = NULL;
 201542c:	e0bffe17 	ldw	r2,-8(fp)
 2015430:	10000015 	stw	zero,0(r2)
      return SYS_ARCH_TIMEOUT;
 2015434:	00bfffc4 	movi	r2,-1
 2015438:	00000106 	br	2015440 <sys_arch_mbox_fetch+0x94>
  }

  /* Old versions of lwIP required us to return the time waited.
     This is not the case any more. Just returning != SYS_ARCH_TIMEOUT
     here is enough. */
  return 1;
 201543c:	00800044 	movi	r2,1
}
 2015440:	e037883a 	mov	sp,fp
 2015444:	dfc00117 	ldw	ra,4(sp)
 2015448:	df000017 	ldw	fp,0(sp)
 201544c:	dec00204 	addi	sp,sp,8
 2015450:	f800283a 	ret

02015454 <sys_arch_mbox_tryfetch>:

u32_t
sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
 2015454:	defffa04 	addi	sp,sp,-24
 2015458:	dfc00515 	stw	ra,20(sp)
 201545c:	df000415 	stw	fp,16(sp)
 2015460:	df000404 	addi	fp,sp,16
 2015464:	e13ffe15 	stw	r4,-8(fp)
 2015468:	e17fff15 	stw	r5,-4(fp)
  BaseType_t ret;
  void *msg_dummy;
  LWIP_ASSERT("mbox != NULL", mbox != NULL);
  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);

  if (!msg) {
 201546c:	e0bfff17 	ldw	r2,-4(fp)
 2015470:	1000021e 	bne	r2,zero,201547c <sys_arch_mbox_tryfetch+0x28>
    msg = &msg_dummy;
 2015474:	e0bffd04 	addi	r2,fp,-12
 2015478:	e0bfff15 	stw	r2,-4(fp)
  }

  ret = xQueueReceive(mbox->mbx, &(*msg), 0);
 201547c:	e0bffe17 	ldw	r2,-8(fp)
 2015480:	10800017 	ldw	r2,0(r2)
 2015484:	000d883a 	mov	r6,zero
 2015488:	e17fff17 	ldw	r5,-4(fp)
 201548c:	1009883a 	mov	r4,r2
 2015490:	200dbfc0 	call	200dbfc <xQueueReceive>
 2015494:	e0bffc15 	stw	r2,-16(fp)
  if (ret == errQUEUE_EMPTY) {
 2015498:	e0bffc17 	ldw	r2,-16(fp)
 201549c:	1000041e 	bne	r2,zero,20154b0 <sys_arch_mbox_tryfetch+0x5c>
    *msg = NULL;
 20154a0:	e0bfff17 	ldw	r2,-4(fp)
 20154a4:	10000015 	stw	zero,0(r2)
    return SYS_MBOX_EMPTY;
 20154a8:	00bfffc4 	movi	r2,-1
 20154ac:	00000106 	br	20154b4 <sys_arch_mbox_tryfetch+0x60>
  }
  LWIP_ASSERT("mbox fetch failed", ret == pdTRUE);

  return 0;
 20154b0:	0005883a 	mov	r2,zero
}
 20154b4:	e037883a 	mov	sp,fp
 20154b8:	dfc00117 	ldw	ra,4(sp)
 20154bc:	df000017 	ldw	fp,0(sp)
 20154c0:	dec00204 	addi	sp,sp,8
 20154c4:	f800283a 	ret

020154c8 <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t *mbox)
{
 20154c8:	defffd04 	addi	sp,sp,-12
 20154cc:	dfc00215 	stw	ra,8(sp)
 20154d0:	df000115 	stw	fp,4(sp)
 20154d4:	df000104 	addi	fp,sp,4
 20154d8:	e13fff15 	stw	r4,-4(fp)
      SYS_STATS_INC(mbox.err);
    }
  }
#endif

  vQueueDelete(mbox->mbx);
 20154dc:	e0bfff17 	ldw	r2,-4(fp)
 20154e0:	10800017 	ldw	r2,0(r2)
 20154e4:	1009883a 	mov	r4,r2
 20154e8:	200e4600 	call	200e460 <vQueueDelete>

  SYS_STATS_DEC(mbox.used);
 20154ec:	008085f4 	movhi	r2,535
 20154f0:	10bd8204 	addi	r2,r2,-2552
 20154f4:	10806d17 	ldw	r2,436(r2)
 20154f8:	10ffffc4 	addi	r3,r2,-1
 20154fc:	008085f4 	movhi	r2,535
 2015500:	10bd8204 	addi	r2,r2,-2552
 2015504:	10c06d15 	stw	r3,436(r2)
}
 2015508:	0001883a 	nop
 201550c:	e037883a 	mov	sp,fp
 2015510:	dfc00117 	ldw	ra,4(sp)
 2015514:	df000017 	ldw	fp,0(sp)
 2015518:	dec00204 	addi	sp,sp,8
 201551c:	f800283a 	ret

02015520 <sys_thread_new>:

sys_thread_t
sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
{
 2015520:	defff404 	addi	sp,sp,-48
 2015524:	dfc00b15 	stw	ra,44(sp)
 2015528:	df000a15 	stw	fp,40(sp)
 201552c:	df000a04 	addi	fp,sp,40
 2015530:	e13ffc15 	stw	r4,-16(fp)
 2015534:	e17ffd15 	stw	r5,-12(fp)
 2015538:	e1bffe15 	stw	r6,-8(fp)
 201553c:	e1ffff15 	stw	r7,-4(fp)

  LWIP_ASSERT("invalid stacksize", stacksize > 0);
#if LWIP_FREERTOS_THREAD_STACKSIZE_IS_STACKWORDS
  rtos_stacksize = (size_t)stacksize;
#else
  rtos_stacksize = (size_t)stacksize / sizeof(StackType_t);
 2015540:	e0bfff17 	ldw	r2,-4(fp)
 2015544:	1004d0ba 	srli	r2,r2,2
 2015548:	e0bff815 	stw	r2,-32(fp)
#endif

  /* lwIP's lwip_thread_fn matches FreeRTOS' TaskFunction_t, so we can pass the
     thread function without adaption here. */
  ret = xTaskCreate(thread, name, (configSTACK_DEPTH_TYPE)rtos_stacksize, arg, prio, &rtos_task);
 201554c:	e0800217 	ldw	r2,8(fp)
 2015550:	e0fffa04 	addi	r3,fp,-24
 2015554:	d8c00115 	stw	r3,4(sp)
 2015558:	d8800015 	stw	r2,0(sp)
 201555c:	e1fffe17 	ldw	r7,-8(fp)
 2015560:	e1bff817 	ldw	r6,-32(fp)
 2015564:	e17ffc17 	ldw	r5,-16(fp)
 2015568:	e13ffd17 	ldw	r4,-12(fp)
 201556c:	200ead40 	call	200ead4 <xTaskCreate>
 2015570:	e0bff915 	stw	r2,-28(fp)
  LWIP_ASSERT("task creation failed", ret == pdTRUE);

  lwip_thread.thread_handle = rtos_task;
 2015574:	e0bffa17 	ldw	r2,-24(fp)
 2015578:	e0bffb15 	stw	r2,-20(fp)
  return lwip_thread;
 201557c:	e0bffb17 	ldw	r2,-20(fp)
}
 2015580:	e037883a 	mov	sp,fp
 2015584:	dfc00117 	ldw	ra,4(sp)
 2015588:	df000017 	ldw	fp,0(sp)
 201558c:	dec00204 	addi	sp,sp,8
 2015590:	f800283a 	ret

02015594 <dhcp_inc_pcb_refcount>:
static void dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out);

/** Ensure DHCP PCB is allocated and bound */
static err_t
dhcp_inc_pcb_refcount(void)
{
 2015594:	defffe04 	addi	sp,sp,-8
 2015598:	dfc00115 	stw	ra,4(sp)
 201559c:	df000015 	stw	fp,0(sp)
 20155a0:	d839883a 	mov	fp,sp
  if (dhcp_pcb_refcount == 0) {
 20155a4:	d0a7c503 	ldbu	r2,-24812(gp)
 20155a8:	10803fcc 	andi	r2,r2,255
 20155ac:	10001b1e 	bne	r2,zero,201561c <dhcp_inc_pcb_refcount+0x88>
    LWIP_ASSERT("dhcp_inc_pcb_refcount(): memory leak", dhcp_pcb == NULL);

    /* allocate UDP PCB */
    dhcp_pcb = udp_new();
 20155b0:	202abe40 	call	202abe4 <udp_new>
 20155b4:	d0a7c415 	stw	r2,-24816(gp)

    if (dhcp_pcb == NULL) {
 20155b8:	d0a7c417 	ldw	r2,-24816(gp)
 20155bc:	1000021e 	bne	r2,zero,20155c8 <dhcp_inc_pcb_refcount+0x34>
      return ERR_MEM;
 20155c0:	00bfffc4 	movi	r2,-1
 20155c4:	00001906 	br	201562c <dhcp_inc_pcb_refcount+0x98>
    }

    ip_set_option(dhcp_pcb, SOF_BROADCAST);
 20155c8:	d0a7c417 	ldw	r2,-24816(gp)
 20155cc:	d0e7c417 	ldw	r3,-24816(gp)
 20155d0:	18c00243 	ldbu	r3,9(r3)
 20155d4:	18c00814 	ori	r3,r3,32
 20155d8:	10c00245 	stb	r3,9(r2)

    /* set up local and remote port for the pcb -> listen on all interfaces on all src/dest IPs */
    udp_bind(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_CLIENT);
 20155dc:	d0a7c417 	ldw	r2,-24816(gp)
 20155e0:	01801104 	movi	r6,68
 20155e4:	d1600e04 	addi	r5,gp,-32712
 20155e8:	1009883a 	mov	r4,r2
 20155ec:	202a75c0 	call	202a75c <udp_bind>
    udp_connect(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_SERVER);
 20155f0:	d0a7c417 	ldw	r2,-24816(gp)
 20155f4:	018010c4 	movi	r6,67
 20155f8:	d1600e04 	addi	r5,gp,-32712
 20155fc:	1009883a 	mov	r4,r2
 2015600:	202a9580 	call	202a958 <udp_connect>
    udp_recv(dhcp_pcb, dhcp_recv, NULL);
 2015604:	d0a7c417 	ldw	r2,-24816(gp)
 2015608:	000d883a 	mov	r6,zero
 201560c:	014080b4 	movhi	r5,514
 2015610:	29601c04 	addi	r5,r5,-32656
 2015614:	1009883a 	mov	r4,r2
 2015618:	202aae40 	call	202aae4 <udp_recv>
  }

  dhcp_pcb_refcount++;
 201561c:	d0a7c503 	ldbu	r2,-24812(gp)
 2015620:	10800044 	addi	r2,r2,1
 2015624:	d0a7c505 	stb	r2,-24812(gp)

  return ERR_OK;
 2015628:	0005883a 	mov	r2,zero
}
 201562c:	e037883a 	mov	sp,fp
 2015630:	dfc00117 	ldw	ra,4(sp)
 2015634:	df000017 	ldw	fp,0(sp)
 2015638:	dec00204 	addi	sp,sp,8
 201563c:	f800283a 	ret

02015640 <dhcp_dec_pcb_refcount>:

/** Free DHCP PCB if the last netif stops using it */
static void
dhcp_dec_pcb_refcount(void)
{
 2015640:	defffe04 	addi	sp,sp,-8
 2015644:	dfc00115 	stw	ra,4(sp)
 2015648:	df000015 	stw	fp,0(sp)
 201564c:	d839883a 	mov	fp,sp
  LWIP_ASSERT("dhcp_pcb_refcount(): refcount error", (dhcp_pcb_refcount > 0));
  dhcp_pcb_refcount--;
 2015650:	d0a7c503 	ldbu	r2,-24812(gp)
 2015654:	10bfffc4 	addi	r2,r2,-1
 2015658:	d0a7c505 	stb	r2,-24812(gp)

  if (dhcp_pcb_refcount == 0) {
 201565c:	d0a7c503 	ldbu	r2,-24812(gp)
 2015660:	10803fcc 	andi	r2,r2,255
 2015664:	1000041e 	bne	r2,zero,2015678 <dhcp_dec_pcb_refcount+0x38>
    udp_remove(dhcp_pcb);
 2015668:	d0a7c417 	ldw	r2,-24816(gp)
 201566c:	1009883a 	mov	r4,r2
 2015670:	202ab340 	call	202ab34 <udp_remove>
    dhcp_pcb = NULL;
 2015674:	d027c415 	stw	zero,-24816(gp)
  }
}
 2015678:	0001883a 	nop
 201567c:	e037883a 	mov	sp,fp
 2015680:	dfc00117 	ldw	ra,4(sp)
 2015684:	df000017 	ldw	fp,0(sp)
 2015688:	dec00204 	addi	sp,sp,8
 201568c:	f800283a 	ret

02015690 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
 2015690:	defffc04 	addi	sp,sp,-16
 2015694:	dfc00315 	stw	ra,12(sp)
 2015698:	df000215 	stw	fp,8(sp)
 201569c:	df000204 	addi	fp,sp,8
 20156a0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 20156a4:	e0bfff17 	ldw	r2,-4(fp)
 20156a8:	10800a17 	ldw	r2,40(r2)
 20156ac:	e0bffe15 	stw	r2,-8(fp)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n",
              (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Change to a defined state - set this before assigning the address
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
 20156b0:	01400304 	movi	r5,12
 20156b4:	e13ffe17 	ldw	r4,-8(fp)
 20156b8:	20175e40 	call	20175e4 <dhcp_set_state>
  /* remove IP address from interface (must no longer be used, as per RFC2131) */
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
 20156bc:	d1e00e04 	addi	r7,gp,-32712
 20156c0:	d1a00e04 	addi	r6,gp,-32712
 20156c4:	d1600e04 	addi	r5,gp,-32712
 20156c8:	e13fff17 	ldw	r4,-4(fp)
 20156cc:	201bff80 	call	201bff8 <netif_set_addr>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
 20156d0:	e13fff17 	ldw	r4,-4(fp)
 20156d4:	20167580 	call	2016758 <dhcp_discover>
}
 20156d8:	0001883a 	nop
 20156dc:	e037883a 	mov	sp,fp
 20156e0:	dfc00117 	ldw	ra,4(sp)
 20156e4:	df000017 	ldw	fp,0(sp)
 20156e8:	dec00204 	addi	sp,sp,8
 20156ec:	f800283a 	ret

020156f0 <dhcp_conflict_callback>:
* @param netif   network interface to handle conflict information on
* @param state   acd_callback_enum_t
 */
static void
dhcp_conflict_callback(struct netif *netif, acd_callback_enum_t state)
{
 20156f0:	defffa04 	addi	sp,sp,-24
 20156f4:	dfc00515 	stw	ra,20(sp)
 20156f8:	df000415 	stw	fp,16(sp)
 20156fc:	df000404 	addi	fp,sp,16
 2015700:	e13ffe15 	stw	r4,-8(fp)
 2015704:	e17fff15 	stw	r5,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2015708:	e0bffe17 	ldw	r2,-8(fp)
 201570c:	10800a17 	ldw	r2,40(r2)
 2015710:	e0bffc15 	stw	r2,-16(fp)
  u16_t msecs;

  switch (state) {
 2015714:	e0bfff17 	ldw	r2,-4(fp)
 2015718:	10c00060 	cmpeqi	r3,r2,1
 201571c:	1800071e 	bne	r3,zero,201573c <dhcp_conflict_callback+0x4c>
 2015720:	0080032e 	bgeu	zero,r2,2015730 <dhcp_conflict_callback+0x40>
 2015724:	108000a0 	cmpeqi	r2,r2,2
 2015728:	1000121e 	bne	r2,zero,2015774 <dhcp_conflict_callback+0x84>
      netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
      /* Let the DHCP server know we will not use the address */
      dhcp_decline(netif);
      break;
    default:
      break;
 201572c:	00001906 	br	2015794 <dhcp_conflict_callback+0xa4>
  struct dhcp *dhcp = netif_dhcp_data(netif);
  u16_t msecs;

  switch (state) {
    case ACD_IP_OK:
      dhcp_bind(netif);
 2015730:	e13ffe17 	ldw	r4,-8(fp)
 2015734:	201697c0 	call	201697c <dhcp_bind>
      break;
 2015738:	00001606 	br	2015794 <dhcp_conflict_callback+0xa4>
       * If the client detects that the address is already in use (e.g., through
       * the use of ARP), the client MUST send a DHCPDECLINE message to the
       * server and restarts the configuration process.  The client SHOULD wait
       * a minimum of ten seconds before restarting the configuration process to
       * avoid excessive network traffic in case of looping. */
       dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
 201573c:	01400304 	movi	r5,12
 2015740:	e13ffc17 	ldw	r4,-16(fp)
 2015744:	20175e40 	call	20175e4 <dhcp_set_state>
       msecs = 10 * 1000;
 2015748:	0089c404 	movi	r2,10000
 201574c:	e0bffd0d 	sth	r2,-12(fp)
       dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 2015750:	e0bffd0b 	ldhu	r2,-12(fp)
 2015754:	10807cc4 	addi	r2,r2,499
 2015758:	01407d04 	movi	r5,500
 201575c:	1009883a 	mov	r4,r2
 2015760:	200a9e40 	call	200a9e4 <__divsi3>
 2015764:	1007883a 	mov	r3,r2
 2015768:	e0bffc17 	ldw	r2,-16(fp)
 201576c:	10c0020d 	sth	r3,8(r2)
       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
      break;
 2015770:	00000806 	br	2015794 <dhcp_conflict_callback+0xa4>
    case ACD_DECLINE:
      /* remove IP address from interface
       * (prevents routing from selecting this interface) */
      netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
 2015774:	d1e00e04 	addi	r7,gp,-32712
 2015778:	d1a00e04 	addi	r6,gp,-32712
 201577c:	d1600e04 	addi	r5,gp,-32712
 2015780:	e13ffe17 	ldw	r4,-8(fp)
 2015784:	201bff80 	call	201bff8 <netif_set_addr>
      /* Let the DHCP server know we will not use the address */
      dhcp_decline(netif);
 2015788:	e13ffe17 	ldw	r4,-8(fp)
 201578c:	20166180 	call	2016618 <dhcp_decline>
      break;
 2015790:	0001883a 	nop
    default:
      break;
  }
}
 2015794:	0001883a 	nop
 2015798:	e037883a 	mov	sp,fp
 201579c:	dfc00117 	ldw	ra,4(sp)
 20157a0:	df000017 	ldw	fp,0(sp)
 20157a4:	dec00204 	addi	sp,sp,8
 20157a8:	f800283a 	ret

020157ac <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
 20157ac:	defffc04 	addi	sp,sp,-16
 20157b0:	dfc00315 	stw	ra,12(sp)
 20157b4:	df000215 	stw	fp,8(sp)
 20157b8:	df000204 	addi	fp,sp,8
 20157bc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 20157c0:	e0bfff17 	ldw	r2,-4(fp)
 20157c4:	10800a17 	ldw	r2,40(r2)
 20157c8:	e0bffe15 	stw	r2,-8(fp)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
              (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
 20157cc:	01400204 	movi	r5,8
 20157d0:	e13ffe17 	ldw	r4,-8(fp)
 20157d4:	20175e40 	call	20175e4 <dhcp_set_state>

  /* start ACD module */
  acd_start(netif, &dhcp->acd, dhcp->offered_ip_addr);
 20157d8:	e0bffe17 	ldw	r2,-8(fp)
 20157dc:	10c00d04 	addi	r3,r2,52
 20157e0:	e0bffe17 	ldw	r2,-8(fp)
 20157e4:	11800717 	ldw	r6,28(r2)
 20157e8:	180b883a 	mov	r5,r3
 20157ec:	e13fff17 	ldw	r4,-4(fp)
 20157f0:	203a4440 	call	203a444 <acd_start>
}
 20157f4:	0001883a 	nop
 20157f8:	e037883a 	mov	sp,fp
 20157fc:	dfc00117 	ldw	ra,4(sp)
 2015800:	df000017 	ldw	fp,0(sp)
 2015804:	dec00204 	addi	sp,sp,8
 2015808:	f800283a 	ret

0201580c <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif, struct dhcp_msg *msg_in)
{
 201580c:	defffb04 	addi	sp,sp,-20
 2015810:	dfc00415 	stw	ra,16(sp)
 2015814:	df000315 	stw	fp,12(sp)
 2015818:	df000304 	addi	fp,sp,12
 201581c:	e13ffe15 	stw	r4,-8(fp)
 2015820:	e17fff15 	stw	r5,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2015824:	e0bffe17 	ldw	r2,-8(fp)
 2015828:	10800a17 	ldw	r2,40(r2)
 201582c:	e0bffd15 	stw	r2,-12(fp)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
              (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
 2015830:	d0a7c5c3 	ldbu	r2,-24809(gp)
 2015834:	10803fcc 	andi	r2,r2,255
 2015838:	10001a26 	beq	r2,zero,20158a4 <dhcp_handle_offer+0x98>
    dhcp->request_timeout = 0; /* stop timer */
 201583c:	e0bffd17 	ldw	r2,-12(fp)
 2015840:	1000020d 	sth	zero,8(r2)

    ip_addr_set_ip4_u32(&dhcp->server_ip_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
 2015844:	00808574 	movhi	r2,533
 2015848:	10b52804 	addi	r2,r2,-11104
 201584c:	10800217 	ldw	r2,8(r2)
 2015850:	1009883a 	mov	r4,r2
 2015854:	20394b00 	call	20394b0 <lwip_htonl>
 2015858:	1007883a 	mov	r3,r2
 201585c:	e0bffd17 	ldw	r2,-12(fp)
 2015860:	10c00615 	stw	r3,24(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
                ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
    /* remember offered address */
    ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
 2015864:	e0bfff17 	ldw	r2,-4(fp)
 2015868:	10c00403 	ldbu	r3,16(r2)
 201586c:	11000443 	ldbu	r4,17(r2)
 2015870:	2008923a 	slli	r4,r4,8
 2015874:	20c6b03a 	or	r3,r4,r3
 2015878:	11000483 	ldbu	r4,18(r2)
 201587c:	2008943a 	slli	r4,r4,16
 2015880:	20c6b03a 	or	r3,r4,r3
 2015884:	108004c3 	ldbu	r2,19(r2)
 2015888:	1004963a 	slli	r2,r2,24
 201588c:	10c4b03a 	or	r2,r2,r3
 2015890:	1007883a 	mov	r3,r2
 2015894:	e0bffd17 	ldw	r2,-12(fp)
 2015898:	10c00715 	stw	r3,28(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
                ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
 201589c:	e13ffe17 	ldw	r4,-8(fp)
 20158a0:	20158bc0 	call	20158bc <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void *)netif));
  }
}
 20158a4:	0001883a 	nop
 20158a8:	e037883a 	mov	sp,fp
 20158ac:	dfc00117 	ldw	ra,4(sp)
 20158b0:	df000017 	ldw	fp,0(sp)
 20158b4:	dec00204 	addi	sp,sp,8
 20158b8:	f800283a 	ret

020158bc <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
 20158bc:	defff404 	addi	sp,sp,-48
 20158c0:	dfc00b15 	stw	ra,44(sp)
 20158c4:	df000a15 	stw	fp,40(sp)
 20158c8:	dc400915 	stw	r17,36(sp)
 20158cc:	dc000815 	stw	r16,32(sp)
 20158d0:	df000a04 	addi	fp,sp,40
 20158d4:	e13ffd15 	stw	r4,-12(fp)
  u16_t msecs;
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_ERROR("dhcp_select: netif != NULL", (netif != NULL), return ERR_ARG;);
 20158d8:	e0bffd17 	ldw	r2,-12(fp)
 20158dc:	1000021e 	bne	r2,zero,20158e8 <dhcp_select+0x2c>
 20158e0:	00bffc04 	movi	r2,-16
 20158e4:	0000bb06 	br	2015bd4 <dhcp_select+0x318>
  dhcp = netif_dhcp_data(netif);
 20158e8:	e0bffd17 	ldw	r2,-12(fp)
 20158ec:	10800a17 	ldw	r2,40(r2)
 20158f0:	e0bff915 	stw	r2,-28(fp)
  LWIP_ERROR("dhcp_select: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
 20158f4:	e0bff917 	ldw	r2,-28(fp)
 20158f8:	1000021e 	bne	r2,zero,2015904 <dhcp_select+0x48>
 20158fc:	00bffe84 	movi	r2,-6
 2015900:	0000b406 	br	2015bd4 <dhcp_select+0x318>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_STATE_REQUESTING);
 2015904:	01400044 	movi	r5,1
 2015908:	e13ff917 	ldw	r4,-28(fp)
 201590c:	20175e40 	call	20175e4 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
 2015910:	e0bffc84 	addi	r2,fp,-14
 2015914:	100f883a 	mov	r7,r2
 2015918:	018000c4 	movi	r6,3
 201591c:	e17ff917 	ldw	r5,-28(fp)
 2015920:	e13ffd17 	ldw	r4,-12(fp)
 2015924:	20183800 	call	2018380 <dhcp_create_msg>
 2015928:	e0bffa15 	stw	r2,-24(fp)
  if (p_out != NULL) {
 201592c:	e0bffa17 	ldw	r2,-24(fp)
 2015930:	10008426 	beq	r2,zero,2015b44 <dhcp_select+0x288>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 2015934:	e0bffa17 	ldw	r2,-24(fp)
 2015938:	10800117 	ldw	r2,4(r2)
 201593c:	e0bffb15 	stw	r2,-20(fp)
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 2015940:	e0bffc8b 	ldhu	r2,-14(fp)
 2015944:	10ffffcc 	andi	r3,r2,65535
 2015948:	e0bffb17 	ldw	r2,-20(fp)
 201594c:	10803c04 	addi	r2,r2,240
 2015950:	01c00084 	movi	r7,2
 2015954:	01800e44 	movi	r6,57
 2015958:	100b883a 	mov	r5,r2
 201595c:	1809883a 	mov	r4,r3
 2015960:	20176400 	call	2017640 <dhcp_option>
 2015964:	e0bffc8d 	sth	r2,-14(fp)
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 2015968:	e0bffc8b 	ldhu	r2,-14(fp)
 201596c:	10ffffcc 	andi	r3,r2,65535
 2015970:	e0bffb17 	ldw	r2,-20(fp)
 2015974:	11003c04 	addi	r4,r2,240
 2015978:	e0bffd17 	ldw	r2,-12(fp)
 201597c:	10800d0b 	ldhu	r2,52(r2)
 2015980:	10bfffcc 	andi	r2,r2,65535
 2015984:	100d883a 	mov	r6,r2
 2015988:	200b883a 	mov	r5,r4
 201598c:	1809883a 	mov	r4,r3
 2015990:	201770c0 	call	201770c <dhcp_option_short>
 2015994:	e0bffc8d 	sth	r2,-14(fp)

    /* MUST request the offered IP address */
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
 2015998:	e0bffc8b 	ldhu	r2,-14(fp)
 201599c:	10ffffcc 	andi	r3,r2,65535
 20159a0:	e0bffb17 	ldw	r2,-20(fp)
 20159a4:	10803c04 	addi	r2,r2,240
 20159a8:	01c00104 	movi	r7,4
 20159ac:	01800c84 	movi	r6,50
 20159b0:	100b883a 	mov	r5,r2
 20159b4:	1809883a 	mov	r4,r3
 20159b8:	20176400 	call	2017640 <dhcp_option>
 20159bc:	e0bffc8d 	sth	r2,-14(fp)
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 20159c0:	e0bffc8b 	ldhu	r2,-14(fp)
 20159c4:	143fffcc 	andi	r16,r2,65535
 20159c8:	e0bffb17 	ldw	r2,-20(fp)
 20159cc:	14403c04 	addi	r17,r2,240
 20159d0:	e0bff917 	ldw	r2,-28(fp)
 20159d4:	10800717 	ldw	r2,28(r2)
 20159d8:	1009883a 	mov	r4,r2
 20159dc:	20394b00 	call	20394b0 <lwip_htonl>
 20159e0:	100d883a 	mov	r6,r2
 20159e4:	880b883a 	mov	r5,r17
 20159e8:	8009883a 	mov	r4,r16
 20159ec:	20177840 	call	2017784 <dhcp_option_long>
 20159f0:	e0bffc8d 	sth	r2,-14(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
 20159f4:	e0bffc8b 	ldhu	r2,-14(fp)
 20159f8:	10ffffcc 	andi	r3,r2,65535
 20159fc:	e0bffb17 	ldw	r2,-20(fp)
 2015a00:	10803c04 	addi	r2,r2,240
 2015a04:	01c00104 	movi	r7,4
 2015a08:	01800d84 	movi	r6,54
 2015a0c:	100b883a 	mov	r5,r2
 2015a10:	1809883a 	mov	r4,r3
 2015a14:	20176400 	call	2017640 <dhcp_option>
 2015a18:	e0bffc8d 	sth	r2,-14(fp)
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
 2015a1c:	e0bffc8b 	ldhu	r2,-14(fp)
 2015a20:	143fffcc 	andi	r16,r2,65535
 2015a24:	e0bffb17 	ldw	r2,-20(fp)
 2015a28:	14403c04 	addi	r17,r2,240
 2015a2c:	e0bff917 	ldw	r2,-28(fp)
 2015a30:	10800617 	ldw	r2,24(r2)
 2015a34:	1009883a 	mov	r4,r2
 2015a38:	20394b00 	call	20394b0 <lwip_htonl>
 2015a3c:	100d883a 	mov	r6,r2
 2015a40:	880b883a 	mov	r5,r17
 2015a44:	8009883a 	mov	r4,r16
 2015a48:	20177840 	call	2017784 <dhcp_option_long>
 2015a4c:	e0bffc8d 	sth	r2,-14(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 2015a50:	e0bffc8b 	ldhu	r2,-14(fp)
 2015a54:	10ffffcc 	andi	r3,r2,65535
 2015a58:	e0bffb17 	ldw	r2,-20(fp)
 2015a5c:	10803c04 	addi	r2,r2,240
 2015a60:	01c000c4 	movi	r7,3
 2015a64:	01800dc4 	movi	r6,55
 2015a68:	100b883a 	mov	r5,r2
 2015a6c:	1809883a 	mov	r4,r3
 2015a70:	20176400 	call	2017640 <dhcp_option>
 2015a74:	e0bffc8d 	sth	r2,-14(fp)
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2015a78:	e03ff845 	stb	zero,-31(fp)
 2015a7c:	00000f06 	br	2015abc <dhcp_select+0x200>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 2015a80:	e0bffc8b 	ldhu	r2,-14(fp)
 2015a84:	113fffcc 	andi	r4,r2,65535
 2015a88:	e0bffb17 	ldw	r2,-20(fp)
 2015a8c:	11403c04 	addi	r5,r2,240
 2015a90:	e0fff843 	ldbu	r3,-31(fp)
 2015a94:	d0a00c04 	addi	r2,gp,-32720
 2015a98:	1885883a 	add	r2,r3,r2
 2015a9c:	10800003 	ldbu	r2,0(r2)
 2015aa0:	10803fcc 	andi	r2,r2,255
 2015aa4:	100d883a 	mov	r6,r2
 2015aa8:	20176b80 	call	20176b8 <dhcp_option_byte>
 2015aac:	e0bffc8d 	sth	r2,-14(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2015ab0:	e0bff843 	ldbu	r2,-31(fp)
 2015ab4:	10800044 	addi	r2,r2,1
 2015ab8:	e0bff845 	stb	r2,-31(fp)
 2015abc:	e0bff843 	ldbu	r2,-31(fp)
 2015ac0:	108000f0 	cmpltui	r2,r2,3
 2015ac4:	103fee1e 	bne	r2,zero,2015a80 <__alt_mem_mem_0+0xfcff5a80>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
    }

#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
 2015ac8:	e0bffc8b 	ldhu	r2,-14(fp)
 2015acc:	10ffffcc 	andi	r3,r2,65535
 2015ad0:	e0bffb17 	ldw	r2,-20(fp)
 2015ad4:	10803c04 	addi	r2,r2,240
 2015ad8:	e1bffd17 	ldw	r6,-12(fp)
 2015adc:	100b883a 	mov	r5,r2
 2015ae0:	1809883a 	mov	r4,r3
 2015ae4:	20178480 	call	2017848 <dhcp_option_hostname>
 2015ae8:	e0bffc8d 	sth	r2,-14(fp)
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REQUESTING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 2015aec:	e0bffc8b 	ldhu	r2,-14(fp)
 2015af0:	10ffffcc 	andi	r3,r2,65535
 2015af4:	e0bffb17 	ldw	r2,-20(fp)
 2015af8:	10803c04 	addi	r2,r2,240
 2015afc:	e1bffa17 	ldw	r6,-24(fp)
 2015b00:	100b883a 	mov	r5,r2
 2015b04:	1809883a 	mov	r4,r3
 2015b08:	20186e80 	call	20186e8 <dhcp_option_trailer>

    /* send broadcast to any DHCP server */
    result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
 2015b0c:	d0e7c417 	ldw	r3,-24816(gp)
 2015b10:	d0a00e04 	addi	r2,gp,-32712
 2015b14:	d8800115 	stw	r2,4(sp)
 2015b18:	e0bffd17 	ldw	r2,-12(fp)
 2015b1c:	d8800015 	stw	r2,0(sp)
 2015b20:	01c010c4 	movi	r7,67
 2015b24:	d1a00f04 	addi	r6,gp,-32708
 2015b28:	e17ffa17 	ldw	r5,-24(fp)
 2015b2c:	1809883a 	mov	r4,r3
 2015b30:	202a2a40 	call	202a2a4 <udp_sendto_if_src>
 2015b34:	e0bff805 	stb	r2,-32(fp)
    pbuf_free(p_out);
 2015b38:	e13ffa17 	ldw	r4,-24(fp)
 2015b3c:	201d2f40 	call	201d2f4 <pbuf_free>
 2015b40:	00000206 	br	2015b4c <dhcp_select+0x290>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
    result = ERR_MEM;
 2015b44:	00bfffc4 	movi	r2,-1
 2015b48:	e0bff805 	stb	r2,-32(fp)
  }
  if (dhcp->tries < 255) {
 2015b4c:	e0bff917 	ldw	r2,-28(fp)
 2015b50:	10800183 	ldbu	r2,6(r2)
 2015b54:	10803fcc 	andi	r2,r2,255
 2015b58:	10803fe0 	cmpeqi	r2,r2,255
 2015b5c:	1000061e 	bne	r2,zero,2015b78 <dhcp_select+0x2bc>
    dhcp->tries++;
 2015b60:	e0bff917 	ldw	r2,-28(fp)
 2015b64:	10800183 	ldbu	r2,6(r2)
 2015b68:	10800044 	addi	r2,r2,1
 2015b6c:	1007883a 	mov	r3,r2
 2015b70:	e0bff917 	ldw	r2,-28(fp)
 2015b74:	10c00185 	stb	r3,6(r2)
  }
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
 2015b78:	e0bff917 	ldw	r2,-28(fp)
 2015b7c:	10800183 	ldbu	r2,6(r2)
 2015b80:	10803fcc 	andi	r2,r2,255
 2015b84:	108001a8 	cmpgeui	r2,r2,6
 2015b88:	1000071e 	bne	r2,zero,2015ba8 <dhcp_select+0x2ec>
 2015b8c:	e0bff917 	ldw	r2,-28(fp)
 2015b90:	10800183 	ldbu	r2,6(r2)
 2015b94:	10803fcc 	andi	r2,r2,255
 2015b98:	00c00044 	movi	r3,1
 2015b9c:	1884983a 	sll	r2,r3,r2
 2015ba0:	1080fa24 	muli	r2,r2,1000
 2015ba4:	00000106 	br	2015bac <dhcp_select+0x2f0>
 2015ba8:	00ba9804 	movi	r2,-5536
 2015bac:	e0bffc0d 	sth	r2,-16(fp)
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 2015bb0:	e0bffc0b 	ldhu	r2,-16(fp)
 2015bb4:	10807cc4 	addi	r2,r2,499
 2015bb8:	01407d04 	movi	r5,500
 2015bbc:	1009883a 	mov	r4,r2
 2015bc0:	200a9e40 	call	200a9e4 <__divsi3>
 2015bc4:	1007883a 	mov	r3,r2
 2015bc8:	e0bff917 	ldw	r2,-28(fp)
 2015bcc:	10c0020d 	sth	r3,8(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2015bd0:	e0bff803 	ldbu	r2,-32(fp)
}
 2015bd4:	e6fffe04 	addi	sp,fp,-8
 2015bd8:	dfc00317 	ldw	ra,12(sp)
 2015bdc:	df000217 	ldw	fp,8(sp)
 2015be0:	dc400117 	ldw	r17,4(sp)
 2015be4:	dc000017 	ldw	r16,0(sp)
 2015be8:	dec00404 	addi	sp,sp,16
 2015bec:	f800283a 	ret

02015bf0 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 * Must be called once a minute (see @ref DHCP_COARSE_TIMER_SECS).
 */
void
dhcp_coarse_tmr(void)
{
 2015bf0:	defffc04 	addi	sp,sp,-16
 2015bf4:	dfc00315 	stw	ra,12(sp)
 2015bf8:	df000215 	stw	fp,8(sp)
 2015bfc:	df000204 	addi	fp,sp,8
  struct netif *netif;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  NETIF_FOREACH(netif) {
 2015c00:	d0a7dc17 	ldw	r2,-24720(gp)
 2015c04:	e0bffe15 	stw	r2,-8(fp)
 2015c08:	00004106 	br	2015d10 <dhcp_coarse_tmr+0x120>
    /* only act on DHCP configured interfaces */
    struct dhcp *dhcp = netif_dhcp_data(netif);
 2015c0c:	e0bffe17 	ldw	r2,-8(fp)
 2015c10:	10800a17 	ldw	r2,40(r2)
 2015c14:	e0bfff15 	stw	r2,-4(fp)
    if ((dhcp != NULL) && (dhcp->state != DHCP_STATE_OFF)) {
 2015c18:	e0bfff17 	ldw	r2,-4(fp)
 2015c1c:	10003926 	beq	r2,zero,2015d04 <dhcp_coarse_tmr+0x114>
 2015c20:	e0bfff17 	ldw	r2,-4(fp)
 2015c24:	10800143 	ldbu	r2,5(r2)
 2015c28:	10803fcc 	andi	r2,r2,255
 2015c2c:	10003526 	beq	r2,zero,2015d04 <dhcp_coarse_tmr+0x114>
      /* compare lease time to expire timeout */
      if (dhcp->t0_timeout && (++dhcp->lease_used == dhcp->t0_timeout)) {
 2015c30:	e0bfff17 	ldw	r2,-4(fp)
 2015c34:	1080050b 	ldhu	r2,20(r2)
 2015c38:	10bfffcc 	andi	r2,r2,65535
 2015c3c:	10001226 	beq	r2,zero,2015c88 <dhcp_coarse_tmr+0x98>
 2015c40:	e0bfff17 	ldw	r2,-4(fp)
 2015c44:	1080048b 	ldhu	r2,18(r2)
 2015c48:	10800044 	addi	r2,r2,1
 2015c4c:	1007883a 	mov	r3,r2
 2015c50:	e0bfff17 	ldw	r2,-4(fp)
 2015c54:	10c0048d 	sth	r3,18(r2)
 2015c58:	e0bfff17 	ldw	r2,-4(fp)
 2015c5c:	10c0048b 	ldhu	r3,18(r2)
 2015c60:	e0bfff17 	ldw	r2,-4(fp)
 2015c64:	1080050b 	ldhu	r2,20(r2)
 2015c68:	18ffffcc 	andi	r3,r3,65535
 2015c6c:	10bfffcc 	andi	r2,r2,65535
 2015c70:	1880051e 	bne	r3,r2,2015c88 <dhcp_coarse_tmr+0x98>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t0 timeout\n"));
        /* this clients' lease time has expired */
        dhcp_release_and_stop(netif);
 2015c74:	e13ffe17 	ldw	r4,-8(fp)
 2015c78:	20173640 	call	2017364 <dhcp_release_and_stop>
        dhcp_start(netif);
 2015c7c:	e13ffe17 	ldw	r4,-8(fp)
 2015c80:	20162c00 	call	20162c0 <dhcp_start>
 2015c84:	00001f06 	br	2015d04 <dhcp_coarse_tmr+0x114>
        /* timer is active (non zero), and triggers (zeroes) now? */
      } else if (dhcp->t2_rebind_time && (dhcp->t2_rebind_time-- == 1)) {
 2015c88:	e0bfff17 	ldw	r2,-4(fp)
 2015c8c:	1080040b 	ldhu	r2,16(r2)
 2015c90:	10bfffcc 	andi	r2,r2,65535
 2015c94:	10000c26 	beq	r2,zero,2015cc8 <dhcp_coarse_tmr+0xd8>
 2015c98:	e0bfff17 	ldw	r2,-4(fp)
 2015c9c:	1080040b 	ldhu	r2,16(r2)
 2015ca0:	10ffffc4 	addi	r3,r2,-1
 2015ca4:	1809883a 	mov	r4,r3
 2015ca8:	e0ffff17 	ldw	r3,-4(fp)
 2015cac:	1900040d 	sth	r4,16(r3)
 2015cb0:	10bfffcc 	andi	r2,r2,65535
 2015cb4:	10800058 	cmpnei	r2,r2,1
 2015cb8:	1000031e 	bne	r2,zero,2015cc8 <dhcp_coarse_tmr+0xd8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
 2015cbc:	e13ffe17 	ldw	r4,-8(fp)
 2015cc0:	2015fb40 	call	2015fb4 <dhcp_t2_timeout>
 2015cc4:	00000f06 	br	2015d04 <dhcp_coarse_tmr+0x114>
        /* timer is active (non zero), and triggers (zeroes) now */
      } else if (dhcp->t1_renew_time && (dhcp->t1_renew_time-- == 1)) {
 2015cc8:	e0bfff17 	ldw	r2,-4(fp)
 2015ccc:	1080038b 	ldhu	r2,14(r2)
 2015cd0:	10bfffcc 	andi	r2,r2,65535
 2015cd4:	10000b26 	beq	r2,zero,2015d04 <dhcp_coarse_tmr+0x114>
 2015cd8:	e0bfff17 	ldw	r2,-4(fp)
 2015cdc:	1080038b 	ldhu	r2,14(r2)
 2015ce0:	10ffffc4 	addi	r3,r2,-1
 2015ce4:	1809883a 	mov	r4,r3
 2015ce8:	e0ffff17 	ldw	r3,-4(fp)
 2015cec:	1900038d 	sth	r4,14(r3)
 2015cf0:	10bfffcc 	andi	r2,r2,65535
 2015cf4:	10800058 	cmpnei	r2,r2,1
 2015cf8:	1000021e 	bne	r2,zero,2015d04 <dhcp_coarse_tmr+0x114>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
 2015cfc:	e13ffe17 	ldw	r4,-8(fp)
 2015d00:	2015ee00 	call	2015ee0 <dhcp_t1_timeout>
dhcp_coarse_tmr(void)
{
  struct netif *netif;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  NETIF_FOREACH(netif) {
 2015d04:	e0bffe17 	ldw	r2,-8(fp)
 2015d08:	10800017 	ldw	r2,0(r2)
 2015d0c:	e0bffe15 	stw	r2,-8(fp)
 2015d10:	e0bffe17 	ldw	r2,-8(fp)
 2015d14:	103fbd1e 	bne	r2,zero,2015c0c <__alt_mem_mem_0+0xfcff5c0c>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
  }
}
 2015d18:	0001883a 	nop
 2015d1c:	e037883a 	mov	sp,fp
 2015d20:	dfc00117 	ldw	ra,4(sp)
 2015d24:	df000017 	ldw	fp,0(sp)
 2015d28:	dec00204 	addi	sp,sp,8
 2015d2c:	f800283a 	ret

02015d30 <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr(void)
{
 2015d30:	defffc04 	addi	sp,sp,-16
 2015d34:	dfc00315 	stw	ra,12(sp)
 2015d38:	df000215 	stw	fp,8(sp)
 2015d3c:	df000204 	addi	fp,sp,8
  struct netif *netif;
  /* loop through netif's */
  NETIF_FOREACH(netif) {
 2015d40:	d0a7dc17 	ldw	r2,-24720(gp)
 2015d44:	e0bffe15 	stw	r2,-8(fp)
 2015d48:	00002106 	br	2015dd0 <dhcp_fine_tmr+0xa0>
    struct dhcp *dhcp = netif_dhcp_data(netif);
 2015d4c:	e0bffe17 	ldw	r2,-8(fp)
 2015d50:	10800a17 	ldw	r2,40(r2)
 2015d54:	e0bfff15 	stw	r2,-4(fp)
    /* only act on DHCP configured interfaces */
    if (dhcp != NULL) {
 2015d58:	e0bfff17 	ldw	r2,-4(fp)
 2015d5c:	10001926 	beq	r2,zero,2015dc4 <dhcp_fine_tmr+0x94>
      /* timer is active (non zero), and is about to trigger now */
      if (dhcp->request_timeout > 1) {
 2015d60:	e0bfff17 	ldw	r2,-4(fp)
 2015d64:	1080020b 	ldhu	r2,8(r2)
 2015d68:	10bfffcc 	andi	r2,r2,65535
 2015d6c:	108000b0 	cmpltui	r2,r2,2
 2015d70:	1000071e 	bne	r2,zero,2015d90 <dhcp_fine_tmr+0x60>
        dhcp->request_timeout--;
 2015d74:	e0bfff17 	ldw	r2,-4(fp)
 2015d78:	1080020b 	ldhu	r2,8(r2)
 2015d7c:	10bfffc4 	addi	r2,r2,-1
 2015d80:	1007883a 	mov	r3,r2
 2015d84:	e0bfff17 	ldw	r2,-4(fp)
 2015d88:	10c0020d 	sth	r3,8(r2)
 2015d8c:	00000d06 	br	2015dc4 <dhcp_fine_tmr+0x94>
      } else if (dhcp->request_timeout == 1) {
 2015d90:	e0bfff17 	ldw	r2,-4(fp)
 2015d94:	1080020b 	ldhu	r2,8(r2)
 2015d98:	10bfffcc 	andi	r2,r2,65535
 2015d9c:	10800058 	cmpnei	r2,r2,1
 2015da0:	1000081e 	bne	r2,zero,2015dc4 <dhcp_fine_tmr+0x94>
        dhcp->request_timeout--;
 2015da4:	e0bfff17 	ldw	r2,-4(fp)
 2015da8:	1080020b 	ldhu	r2,8(r2)
 2015dac:	10bfffc4 	addi	r2,r2,-1
 2015db0:	1007883a 	mov	r3,r2
 2015db4:	e0bfff17 	ldw	r2,-4(fp)
 2015db8:	10c0020d 	sth	r3,8(r2)
        /* { dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
 2015dbc:	e13ffe17 	ldw	r4,-8(fp)
 2015dc0:	2015df00 	call	2015df0 <dhcp_timeout>
void
dhcp_fine_tmr(void)
{
  struct netif *netif;
  /* loop through netif's */
  NETIF_FOREACH(netif) {
 2015dc4:	e0bffe17 	ldw	r2,-8(fp)
 2015dc8:	10800017 	ldw	r2,0(r2)
 2015dcc:	e0bffe15 	stw	r2,-8(fp)
 2015dd0:	e0bffe17 	ldw	r2,-8(fp)
 2015dd4:	103fdd1e 	bne	r2,zero,2015d4c <__alt_mem_mem_0+0xfcff5d4c>
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
      }
    }
  }
}
 2015dd8:	0001883a 	nop
 2015ddc:	e037883a 	mov	sp,fp
 2015de0:	dfc00117 	ldw	ra,4(sp)
 2015de4:	df000017 	ldw	fp,0(sp)
 2015de8:	dec00204 	addi	sp,sp,8
 2015dec:	f800283a 	ret

02015df0 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
 2015df0:	defffc04 	addi	sp,sp,-16
 2015df4:	dfc00315 	stw	ra,12(sp)
 2015df8:	df000215 	stw	fp,8(sp)
 2015dfc:	df000204 	addi	fp,sp,8
 2015e00:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2015e04:	e0bfff17 	ldw	r2,-4(fp)
 2015e08:	10800a17 	ldw	r2,40(r2)
 2015e0c:	e0bffe15 	stw	r2,-8(fp)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
 2015e10:	e0bffe17 	ldw	r2,-8(fp)
 2015e14:	10800143 	ldbu	r2,5(r2)
 2015e18:	10803fcc 	andi	r2,r2,255
 2015e1c:	10800320 	cmpeqi	r2,r2,12
 2015e20:	1000051e 	bne	r2,zero,2015e38 <dhcp_timeout+0x48>
 2015e24:	e0bffe17 	ldw	r2,-8(fp)
 2015e28:	10800143 	ldbu	r2,5(r2)
 2015e2c:	10803fcc 	andi	r2,r2,255
 2015e30:	10800198 	cmpnei	r2,r2,6
 2015e34:	1000031e 	bne	r2,zero,2015e44 <dhcp_timeout+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
 2015e38:	e13fff17 	ldw	r4,-4(fp)
 2015e3c:	20167580 	call	2016758 <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015e40:	00002106 	br	2015ec8 <dhcp_timeout+0xd8>
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
    /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_STATE_REQUESTING) {
 2015e44:	e0bffe17 	ldw	r2,-8(fp)
 2015e48:	10800143 	ldbu	r2,5(r2)
 2015e4c:	10803fcc 	andi	r2,r2,255
 2015e50:	10800058 	cmpnei	r2,r2,1
 2015e54:	10000d1e 	bne	r2,zero,2015e8c <dhcp_timeout+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
 2015e58:	e0bffe17 	ldw	r2,-8(fp)
 2015e5c:	10800183 	ldbu	r2,6(r2)
 2015e60:	10803fcc 	andi	r2,r2,255
 2015e64:	108001a8 	cmpgeui	r2,r2,6
 2015e68:	1000031e 	bne	r2,zero,2015e78 <dhcp_timeout+0x88>
      dhcp_select(netif);
 2015e6c:	e13fff17 	ldw	r4,-4(fp)
 2015e70:	20158bc0 	call	20158bc <dhcp_select>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015e74:	00001406 	br	2015ec8 <dhcp_timeout+0xd8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
      dhcp_select(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release_and_stop(netif);
 2015e78:	e13fff17 	ldw	r4,-4(fp)
 2015e7c:	20173640 	call	2017364 <dhcp_release_and_stop>
      dhcp_start(netif);
 2015e80:	e13fff17 	ldw	r4,-4(fp)
 2015e84:	20162c00 	call	20162c0 <dhcp_start>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015e88:	00000f06 	br	2015ec8 <dhcp_timeout+0xd8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release_and_stop(netif);
      dhcp_start(netif);
    }
  } else if (dhcp->state == DHCP_STATE_REBOOTING) {
 2015e8c:	e0bffe17 	ldw	r2,-8(fp)
 2015e90:	10800143 	ldbu	r2,5(r2)
 2015e94:	10803fcc 	andi	r2,r2,255
 2015e98:	108000d8 	cmpnei	r2,r2,3
 2015e9c:	10000a1e 	bne	r2,zero,2015ec8 <dhcp_timeout+0xd8>
    if (dhcp->tries < REBOOT_TRIES) {
 2015ea0:	e0bffe17 	ldw	r2,-8(fp)
 2015ea4:	10800183 	ldbu	r2,6(r2)
 2015ea8:	10803fcc 	andi	r2,r2,255
 2015eac:	108000a8 	cmpgeui	r2,r2,2
 2015eb0:	1000031e 	bne	r2,zero,2015ec0 <dhcp_timeout+0xd0>
      dhcp_reboot(netif);
 2015eb4:	e13fff17 	ldw	r4,-4(fp)
 2015eb8:	20170c80 	call	20170c8 <dhcp_reboot>
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015ebc:	00000206 	br	2015ec8 <dhcp_timeout+0xd8>
    }
  } else if (dhcp->state == DHCP_STATE_REBOOTING) {
    if (dhcp->tries < REBOOT_TRIES) {
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
 2015ec0:	e13fff17 	ldw	r4,-4(fp)
 2015ec4:	20167580 	call	2016758 <dhcp_discover>
    }
  }
}
 2015ec8:	0001883a 	nop
 2015ecc:	e037883a 	mov	sp,fp
 2015ed0:	dfc00117 	ldw	ra,4(sp)
 2015ed4:	df000017 	ldw	fp,0(sp)
 2015ed8:	dec00204 	addi	sp,sp,8
 2015edc:	f800283a 	ret

02015ee0 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
 2015ee0:	defffc04 	addi	sp,sp,-16
 2015ee4:	dfc00315 	stw	ra,12(sp)
 2015ee8:	df000215 	stw	fp,8(sp)
 2015eec:	df000204 	addi	fp,sp,8
 2015ef0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2015ef4:	e0bfff17 	ldw	r2,-4(fp)
 2015ef8:	10800a17 	ldw	r2,40(r2)
 2015efc:	e0bffe15 	stw	r2,-8(fp)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 2015f00:	e0bffe17 	ldw	r2,-8(fp)
 2015f04:	10800143 	ldbu	r2,5(r2)
 2015f08:	10803fcc 	andi	r2,r2,255
 2015f0c:	10800060 	cmpeqi	r2,r2,1
 2015f10:	10000a1e 	bne	r2,zero,2015f3c <dhcp_t1_timeout+0x5c>
 2015f14:	e0bffe17 	ldw	r2,-8(fp)
 2015f18:	10800143 	ldbu	r2,5(r2)
 2015f1c:	10803fcc 	andi	r2,r2,255
 2015f20:	108002a0 	cmpeqi	r2,r2,10
 2015f24:	1000051e 	bne	r2,zero,2015f3c <dhcp_t1_timeout+0x5c>
      (dhcp->state == DHCP_STATE_RENEWING)) {
 2015f28:	e0bffe17 	ldw	r2,-8(fp)
 2015f2c:	10800143 	ldbu	r2,5(r2)
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif_dhcp_data(netif);

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 2015f30:	10803fcc 	andi	r2,r2,255
 2015f34:	10800158 	cmpnei	r2,r2,5
 2015f38:	1000181e 	bne	r2,zero,2015f9c <dhcp_t1_timeout+0xbc>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_STATE_RENEWING, not DHCP_STATE_BOUND */
    dhcp_renew(netif);
 2015f3c:	e13fff17 	ldw	r4,-4(fp)
 2015f40:	2016c480 	call	2016c48 <dhcp_renew>
    /* Calculate next timeout */
    if (((dhcp->t2_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
 2015f44:	e0bffe17 	ldw	r2,-8(fp)
 2015f48:	1080030b 	ldhu	r2,12(r2)
 2015f4c:	10ffffcc 	andi	r3,r2,65535
 2015f50:	e0bffe17 	ldw	r2,-8(fp)
 2015f54:	1080048b 	ldhu	r2,18(r2)
 2015f58:	10bfffcc 	andi	r2,r2,65535
 2015f5c:	1885c83a 	sub	r2,r3,r2
 2015f60:	10800090 	cmplti	r2,r2,2
 2015f64:	10000d1e 	bne	r2,zero,2015f9c <dhcp_t1_timeout+0xbc>
      dhcp->t1_renew_time = (u16_t)((dhcp->t2_timeout - dhcp->lease_used) / 2);
 2015f68:	e0bffe17 	ldw	r2,-8(fp)
 2015f6c:	1080030b 	ldhu	r2,12(r2)
 2015f70:	10ffffcc 	andi	r3,r2,65535
 2015f74:	e0bffe17 	ldw	r2,-8(fp)
 2015f78:	1080048b 	ldhu	r2,18(r2)
 2015f7c:	10bfffcc 	andi	r2,r2,65535
 2015f80:	1885c83a 	sub	r2,r3,r2
 2015f84:	1006d7fa 	srli	r3,r2,31
 2015f88:	1885883a 	add	r2,r3,r2
 2015f8c:	1005d07a 	srai	r2,r2,1
 2015f90:	1007883a 	mov	r3,r2
 2015f94:	e0bffe17 	ldw	r2,-8(fp)
 2015f98:	10c0038d 	sth	r3,14(r2)
    }
  }
}
 2015f9c:	0001883a 	nop
 2015fa0:	e037883a 	mov	sp,fp
 2015fa4:	dfc00117 	ldw	ra,4(sp)
 2015fa8:	df000017 	ldw	fp,0(sp)
 2015fac:	dec00204 	addi	sp,sp,8
 2015fb0:	f800283a 	ret

02015fb4 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
 2015fb4:	defffc04 	addi	sp,sp,-16
 2015fb8:	dfc00315 	stw	ra,12(sp)
 2015fbc:	df000215 	stw	fp,8(sp)
 2015fc0:	df000204 	addi	fp,sp,8
 2015fc4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2015fc8:	e0bfff17 	ldw	r2,-4(fp)
 2015fcc:	10800a17 	ldw	r2,40(r2)
 2015fd0:	e0bffe15 	stw	r2,-8(fp)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 2015fd4:	e0bffe17 	ldw	r2,-8(fp)
 2015fd8:	10800143 	ldbu	r2,5(r2)
 2015fdc:	10803fcc 	andi	r2,r2,255
 2015fe0:	10800060 	cmpeqi	r2,r2,1
 2015fe4:	10000f1e 	bne	r2,zero,2016024 <dhcp_t2_timeout+0x70>
 2015fe8:	e0bffe17 	ldw	r2,-8(fp)
 2015fec:	10800143 	ldbu	r2,5(r2)
 2015ff0:	10803fcc 	andi	r2,r2,255
 2015ff4:	108002a0 	cmpeqi	r2,r2,10
 2015ff8:	10000a1e 	bne	r2,zero,2016024 <dhcp_t2_timeout+0x70>
      (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
 2015ffc:	e0bffe17 	ldw	r2,-8(fp)
 2016000:	10800143 	ldbu	r2,5(r2)
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif_dhcp_data(netif);

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 2016004:	10803fcc 	andi	r2,r2,255
 2016008:	10800160 	cmpeqi	r2,r2,5
 201600c:	1000051e 	bne	r2,zero,2016024 <dhcp_t2_timeout+0x70>
      (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
 2016010:	e0bffe17 	ldw	r2,-8(fp)
 2016014:	10800143 	ldbu	r2,5(r2)
 2016018:	10803fcc 	andi	r2,r2,255
 201601c:	10800118 	cmpnei	r2,r2,4
 2016020:	1000181e 	bne	r2,zero,2016084 <dhcp_t2_timeout+0xd0>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_STATE_REBINDING, not DHCP_STATE_BOUND */
    dhcp_rebind(netif);
 2016024:	e13fff17 	ldw	r4,-4(fp)
 2016028:	2016e8c0 	call	2016e8c <dhcp_rebind>
    /* Calculate next timeout */
    if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
 201602c:	e0bffe17 	ldw	r2,-8(fp)
 2016030:	1080050b 	ldhu	r2,20(r2)
 2016034:	10ffffcc 	andi	r3,r2,65535
 2016038:	e0bffe17 	ldw	r2,-8(fp)
 201603c:	1080048b 	ldhu	r2,18(r2)
 2016040:	10bfffcc 	andi	r2,r2,65535
 2016044:	1885c83a 	sub	r2,r3,r2
 2016048:	10800090 	cmplti	r2,r2,2
 201604c:	10000d1e 	bne	r2,zero,2016084 <dhcp_t2_timeout+0xd0>
      dhcp->t2_rebind_time = (u16_t)((dhcp->t0_timeout - dhcp->lease_used) / 2);
 2016050:	e0bffe17 	ldw	r2,-8(fp)
 2016054:	1080050b 	ldhu	r2,20(r2)
 2016058:	10ffffcc 	andi	r3,r2,65535
 201605c:	e0bffe17 	ldw	r2,-8(fp)
 2016060:	1080048b 	ldhu	r2,18(r2)
 2016064:	10bfffcc 	andi	r2,r2,65535
 2016068:	1885c83a 	sub	r2,r3,r2
 201606c:	1006d7fa 	srli	r3,r2,31
 2016070:	1885883a 	add	r2,r3,r2
 2016074:	1005d07a 	srai	r2,r2,1
 2016078:	1007883a 	mov	r3,r2
 201607c:	e0bffe17 	ldw	r2,-8(fp)
 2016080:	10c0040d 	sth	r3,16(r2)
    }
  }
}
 2016084:	0001883a 	nop
 2016088:	e037883a 	mov	sp,fp
 201608c:	dfc00117 	ldw	ra,4(sp)
 2016090:	df000017 	ldw	fp,0(sp)
 2016094:	dec00204 	addi	sp,sp,8
 2016098:	f800283a 	ret

0201609c <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif, struct dhcp_msg *msg_in)
{
 201609c:	defffb04 	addi	sp,sp,-20
 20160a0:	dfc00415 	stw	ra,16(sp)
 20160a4:	df000315 	stw	fp,12(sp)
 20160a8:	df000304 	addi	fp,sp,12
 20160ac:	e13ffe15 	stw	r4,-8(fp)
 20160b0:	e17fff15 	stw	r5,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 20160b4:	e0bffe17 	ldw	r2,-8(fp)
 20160b8:	10800a17 	ldw	r2,40(r2)
 20160bc:	e0bffd15 	stw	r2,-12(fp)
#if LWIP_DHCP_GET_NTP_SRV
  ip4_addr_t ntp_server_addrs[LWIP_DHCP_MAX_NTP_SERVERS];
#endif

  /* clear options we might not get from the ACK */
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
 20160c0:	e0bffd17 	ldw	r2,-12(fp)
 20160c4:	10000815 	stw	zero,32(r2)
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
 20160c8:	e0bffd17 	ldw	r2,-12(fp)
 20160cc:	10000915 	stw	zero,36(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip4_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
 20160d0:	d0a7c603 	ldbu	r2,-24808(gp)
 20160d4:	10803fcc 	andi	r2,r2,255
 20160d8:	10000526 	beq	r2,zero,20160f0 <dhcp_handle_ack+0x54>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
 20160dc:	00808574 	movhi	r2,533
 20160e0:	10b52804 	addi	r2,r2,-11104
 20160e4:	10c00317 	ldw	r3,12(r2)
 20160e8:	e0bffd17 	ldw	r2,-12(fp)
 20160ec:	10c00a15 	stw	r3,40(r2)
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
 20160f0:	d0a7c643 	ldbu	r2,-24807(gp)
 20160f4:	10803fcc 	andi	r2,r2,255
 20160f8:	10000626 	beq	r2,zero,2016114 <dhcp_handle_ack+0x78>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
 20160fc:	00808574 	movhi	r2,533
 2016100:	10b52804 	addi	r2,r2,-11104
 2016104:	10c00417 	ldw	r3,16(r2)
 2016108:	e0bffd17 	ldw	r2,-12(fp)
 201610c:	10c00b15 	stw	r3,44(r2)
 2016110:	00000506 	br	2016128 <dhcp_handle_ack+0x8c>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
 2016114:	e0bffd17 	ldw	r2,-12(fp)
 2016118:	10800a17 	ldw	r2,40(r2)
 201611c:	1006d07a 	srli	r3,r2,1
 2016120:	e0bffd17 	ldw	r2,-12(fp)
 2016124:	10c00b15 	stw	r3,44(r2)
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
 2016128:	d0a7c683 	ldbu	r2,-24806(gp)
 201612c:	10803fcc 	andi	r2,r2,255
 2016130:	10000626 	beq	r2,zero,201614c <dhcp_handle_ack+0xb0>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
 2016134:	00808574 	movhi	r2,533
 2016138:	10b52804 	addi	r2,r2,-11104
 201613c:	10c00517 	ldw	r3,20(r2)
 2016140:	e0bffd17 	ldw	r2,-12(fp)
 2016144:	10c00c15 	stw	r3,48(r2)
 2016148:	00000606 	br	2016164 <dhcp_handle_ack+0xc8>
  } else {
    /* calculate safe periods for rebinding (offered_t0_lease * 0.875 -> 87.5%)*/
    dhcp->offered_t2_rebind = (dhcp->offered_t0_lease * 7U) / 8U;
 201614c:	e0bffd17 	ldw	r2,-12(fp)
 2016150:	10800a17 	ldw	r2,40(r2)
 2016154:	108001e4 	muli	r2,r2,7
 2016158:	1006d0fa 	srli	r3,r2,3
 201615c:	e0bffd17 	ldw	r2,-12(fp)
 2016160:	10c00c15 	stw	r3,48(r2)
  }

  /* (y)our internet address */
  ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
 2016164:	e0bfff17 	ldw	r2,-4(fp)
 2016168:	10c00403 	ldbu	r3,16(r2)
 201616c:	11000443 	ldbu	r4,17(r2)
 2016170:	2008923a 	slli	r4,r4,8
 2016174:	20c6b03a 	or	r3,r4,r3
 2016178:	11000483 	ldbu	r4,18(r2)
 201617c:	2008943a 	slli	r4,r4,16
 2016180:	20c6b03a 	or	r3,r4,r3
 2016184:	108004c3 	ldbu	r2,19(r2)
 2016188:	1004963a 	slli	r2,r2,24
 201618c:	10c4b03a 	or	r2,r2,r3
 2016190:	1007883a 	mov	r3,r2
 2016194:	e0bffd17 	ldw	r2,-12(fp)
 2016198:	10c00715 	stw	r3,28(r2)
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip4_addr_copy(dhcp->offered_si_addr, msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
 201619c:	d0a7c6c3 	ldbu	r2,-24805(gp)
 20161a0:	10803fcc 	andi	r2,r2,255
 20161a4:	10000c26 	beq	r2,zero,20161d8 <dhcp_handle_ack+0x13c>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
 20161a8:	00808574 	movhi	r2,533
 20161ac:	10b52804 	addi	r2,r2,-11104
 20161b0:	10800617 	ldw	r2,24(r2)
 20161b4:	1009883a 	mov	r4,r2
 20161b8:	20394b00 	call	20394b0 <lwip_htonl>
 20161bc:	1007883a 	mov	r3,r2
 20161c0:	e0bffd17 	ldw	r2,-12(fp)
 20161c4:	10c00815 	stw	r3,32(r2)
    dhcp->subnet_mask_given = 1;
 20161c8:	e0bffd17 	ldw	r2,-12(fp)
 20161cc:	00c00044 	movi	r3,1
 20161d0:	10c001c5 	stb	r3,7(r2)
 20161d4:	00000206 	br	20161e0 <dhcp_handle_ack+0x144>
  } else {
    dhcp->subnet_mask_given = 0;
 20161d8:	e0bffd17 	ldw	r2,-12(fp)
 20161dc:	100001c5 	stb	zero,7(r2)
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
 20161e0:	d0a7c703 	ldbu	r2,-24804(gp)
 20161e4:	10803fcc 	andi	r2,r2,255
 20161e8:	10000826 	beq	r2,zero,201620c <dhcp_handle_ack+0x170>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
 20161ec:	00808574 	movhi	r2,533
 20161f0:	10b52804 	addi	r2,r2,-11104
 20161f4:	10800717 	ldw	r2,28(r2)
 20161f8:	1009883a 	mov	r4,r2
 20161fc:	20394b00 	call	20394b0 <lwip_htonl>
 2016200:	1007883a 	mov	r3,r2
 2016204:	e0bffd17 	ldw	r2,-12(fp)
 2016208:	10c00915 	stw	r3,36(r2)
    ip_addr_t dns_addr;
    ip_addr_set_ip4_u32_val(dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
    dns_setserver(n, &dns_addr);
  }
#endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
}
 201620c:	0001883a 	nop
 2016210:	e037883a 	mov	sp,fp
 2016214:	dfc00117 	ldw	ra,4(sp)
 2016218:	df000017 	ldw	fp,0(sp)
 201621c:	dec00204 	addi	sp,sp,8
 2016220:	f800283a 	ret

02016224 <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
 2016224:	defffc04 	addi	sp,sp,-16
 2016228:	dfc00315 	stw	ra,12(sp)
 201622c:	df000215 	stw	fp,8(sp)
 2016230:	df000204 	addi	fp,sp,8
 2016234:	e13ffe15 	stw	r4,-8(fp)
 2016238:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
  LWIP_ASSERT("netif already has a struct dhcp set", netif_dhcp_data(netif) == NULL);

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
 201623c:	01801304 	movi	r6,76
 2016240:	000b883a 	mov	r5,zero
 2016244:	e13fff17 	ldw	r4,-4(fp)
 2016248:	2005fa00 	call	2005fa0 <memset>
  /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */
  netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
 201624c:	e0bffe17 	ldw	r2,-8(fp)
 2016250:	e0ffff17 	ldw	r3,-4(fp)
 2016254:	10c00a15 	stw	r3,40(r2)
}
 2016258:	0001883a 	nop
 201625c:	e037883a 	mov	sp,fp
 2016260:	dfc00117 	ldw	ra,4(sp)
 2016264:	df000017 	ldw	fp,0(sp)
 2016268:	dec00204 	addi	sp,sp,8
 201626c:	f800283a 	ret

02016270 <dhcp_cleanup>:
 *            struct dhcp since the memory is passed back to the heap.
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
 2016270:	defffd04 	addi	sp,sp,-12
 2016274:	dfc00215 	stw	ra,8(sp)
 2016278:	df000115 	stw	fp,4(sp)
 201627c:	df000104 	addi	fp,sp,4
 2016280:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("netif != NULL", netif != NULL);

  if (netif_dhcp_data(netif) != NULL) {
 2016284:	e0bfff17 	ldw	r2,-4(fp)
 2016288:	10800a17 	ldw	r2,40(r2)
 201628c:	10000626 	beq	r2,zero,20162a8 <dhcp_cleanup+0x38>
    mem_free(netif_dhcp_data(netif));
 2016290:	e0bfff17 	ldw	r2,-4(fp)
 2016294:	10800a17 	ldw	r2,40(r2)
 2016298:	1009883a 	mov	r4,r2
 201629c:	201acfc0 	call	201acfc <mem_free>
    netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, NULL);
 20162a0:	e0bfff17 	ldw	r2,-4(fp)
 20162a4:	10000a15 	stw	zero,40(r2)
  }
}
 20162a8:	0001883a 	nop
 20162ac:	e037883a 	mov	sp,fp
 20162b0:	dfc00117 	ldw	ra,4(sp)
 20162b4:	df000017 	ldw	fp,0(sp)
 20162b8:	dec00204 	addi	sp,sp,8
 20162bc:	f800283a 	ret

020162c0 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
 20162c0:	defffb04 	addi	sp,sp,-20
 20162c4:	dfc00415 	stw	ra,16(sp)
 20162c8:	df000315 	stw	fp,12(sp)
 20162cc:	df000304 	addi	fp,sp,12
 20162d0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  err_t result;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
 20162d4:	e0bfff17 	ldw	r2,-4(fp)
 20162d8:	1000021e 	bne	r2,zero,20162e4 <dhcp_start+0x24>
 20162dc:	00bffc04 	movi	r2,-16
 20162e0:	00004c06 	br	2016414 <dhcp_start+0x154>
  LWIP_ERROR("netif is not up, old style port?", netif_is_up(netif), return ERR_ARG;);
 20162e4:	e0bfff17 	ldw	r2,-4(fp)
 20162e8:	10800f43 	ldbu	r2,61(r2)
 20162ec:	10803fcc 	andi	r2,r2,255
 20162f0:	1080004c 	andi	r2,r2,1
 20162f4:	1000021e 	bne	r2,zero,2016300 <dhcp_start+0x40>
 20162f8:	00bffc04 	movi	r2,-16
 20162fc:	00004506 	br	2016414 <dhcp_start+0x154>
  dhcp = netif_dhcp_data(netif);
 2016300:	e0bfff17 	ldw	r2,-4(fp)
 2016304:	10800a17 	ldw	r2,40(r2)
 2016308:	e0bffd15 	stw	r2,-12(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
 201630c:	e0bfff17 	ldw	r2,-4(fp)
 2016310:	10800d0b 	ldhu	r2,52(r2)
 2016314:	10bfffcc 	andi	r2,r2,65535
 2016318:	10809028 	cmpgeui	r2,r2,576
 201631c:	1000021e 	bne	r2,zero,2016328 <dhcp_start+0x68>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
 2016320:	00bfffc4 	movi	r2,-1
 2016324:	00003b06 	br	2016414 <dhcp_start+0x154>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
 2016328:	e0bffd17 	ldw	r2,-12(fp)
 201632c:	10000b1e 	bne	r2,zero,201635c <dhcp_start+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): mallocing new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
 2016330:	01001304 	movi	r4,76
 2016334:	201b1d40 	call	201b1d4 <mem_malloc>
 2016338:	e0bffd15 	stw	r2,-12(fp)
    if (dhcp == NULL) {
 201633c:	e0bffd17 	ldw	r2,-12(fp)
 2016340:	1000021e 	bne	r2,zero,201634c <dhcp_start+0x8c>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
 2016344:	00bfffc4 	movi	r2,-1
 2016348:	00003206 	br	2016414 <dhcp_start+0x154>
    }

    /* store this dhcp client in the netif */
    netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
 201634c:	e0bfff17 	ldw	r2,-4(fp)
 2016350:	e0fffd17 	ldw	r3,-12(fp)
 2016354:	10c00a15 	stw	r3,40(r2)
 2016358:	00000506 	br	2016370 <dhcp_start+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
    /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));

    if (dhcp->pcb_allocated != 0) {
 201635c:	e0bffd17 	ldw	r2,-12(fp)
 2016360:	10800103 	ldbu	r2,4(r2)
 2016364:	10803fcc 	andi	r2,r2,255
 2016368:	10000126 	beq	r2,zero,2016370 <dhcp_start+0xb0>
      dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
 201636c:	20156400 	call	2015640 <dhcp_dec_pcb_refcount>
    }
    /* dhcp is cleared below, no need to reset flag*/
  }

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
 2016370:	01801304 	movi	r6,76
 2016374:	000b883a 	mov	r5,zero
 2016378:	e13ffd17 	ldw	r4,-12(fp)
 201637c:	2005fa00 	call	2005fa0 <memset>
  /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */


#if LWIP_DHCP_DOES_ACD_CHECK
  /* add acd struct to list*/
  acd_add(netif, &dhcp->acd, dhcp_conflict_callback);
 2016380:	e0bffd17 	ldw	r2,-12(fp)
 2016384:	10800d04 	addi	r2,r2,52
 2016388:	01808074 	movhi	r6,513
 201638c:	3195bc04 	addi	r6,r6,22256
 2016390:	100b883a 	mov	r5,r2
 2016394:	e13fff17 	ldw	r4,-4(fp)
 2016398:	203a3b80 	call	203a3b8 <acd_add>
#endif /* LWIP_DHCP_DOES_ACD_CHECK */


  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));

  if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
 201639c:	20155940 	call	2015594 <dhcp_inc_pcb_refcount>
 20163a0:	10803fcc 	andi	r2,r2,255
 20163a4:	1080201c 	xori	r2,r2,128
 20163a8:	10bfe004 	addi	r2,r2,-128
 20163ac:	10000226 	beq	r2,zero,20163b8 <dhcp_start+0xf8>
    return ERR_MEM;
 20163b0:	00bfffc4 	movi	r2,-1
 20163b4:	00001706 	br	2016414 <dhcp_start+0x154>
  }
  dhcp->pcb_allocated = 1;
 20163b8:	e0bffd17 	ldw	r2,-12(fp)
 20163bc:	00c00044 	movi	r3,1
 20163c0:	10c00105 	stb	r3,4(r2)

  if (!netif_is_link_up(netif)) {
 20163c4:	e0bfff17 	ldw	r2,-4(fp)
 20163c8:	10800f43 	ldbu	r2,61(r2)
 20163cc:	10803fcc 	andi	r2,r2,255
 20163d0:	1080010c 	andi	r2,r2,4
 20163d4:	1000051e 	bne	r2,zero,20163ec <dhcp_start+0x12c>
    /* set state INIT and wait for dhcp_network_changed() to call dhcp_discover() */
    dhcp_set_state(dhcp, DHCP_STATE_INIT);
 20163d8:	01400084 	movi	r5,2
 20163dc:	e13ffd17 	ldw	r4,-12(fp)
 20163e0:	20175e40 	call	20175e4 <dhcp_set_state>
    return ERR_OK;
 20163e4:	0005883a 	mov	r2,zero
 20163e8:	00000a06 	br	2016414 <dhcp_start+0x154>
  }

  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
 20163ec:	e13fff17 	ldw	r4,-4(fp)
 20163f0:	20167580 	call	2016758 <dhcp_discover>
 20163f4:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
 20163f8:	e0bffe07 	ldb	r2,-8(fp)
 20163fc:	10000426 	beq	r2,zero,2016410 <dhcp_start+0x150>
    /* free resources allocated above */
    dhcp_release_and_stop(netif);
 2016400:	e13fff17 	ldw	r4,-4(fp)
 2016404:	20173640 	call	2017364 <dhcp_release_and_stop>
    return ERR_MEM;
 2016408:	00bfffc4 	movi	r2,-1
 201640c:	00000106 	br	2016414 <dhcp_start+0x154>
  }
  return result;
 2016410:	e0bffe03 	ldbu	r2,-8(fp)
}
 2016414:	e037883a 	mov	sp,fp
 2016418:	dfc00117 	ldw	ra,4(sp)
 201641c:	df000017 	ldw	fp,0(sp)
 2016420:	dec00204 	addi	sp,sp,8
 2016424:	f800283a 	ret

02016428 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
 2016428:	deffe604 	addi	sp,sp,-104
 201642c:	dfc01915 	stw	ra,100(sp)
 2016430:	df001815 	stw	fp,96(sp)
 2016434:	df001804 	addi	fp,sp,96
 2016438:	e13fff15 	stw	r4,-4(fp)
  struct dhcp dhcp;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 201643c:	e0bfff17 	ldw	r2,-4(fp)
 2016440:	10004526 	beq	r2,zero,2016558 <dhcp_inform+0x130>

  if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
 2016444:	20155940 	call	2015594 <dhcp_inc_pcb_refcount>
 2016448:	10803fcc 	andi	r2,r2,255
 201644c:	1080201c 	xori	r2,r2,128
 2016450:	10bfe004 	addi	r2,r2,-128
 2016454:	1000421e 	bne	r2,zero,2016560 <dhcp_inform+0x138>
    return;
  }

  memset(&dhcp, 0, sizeof(struct dhcp));
 2016458:	e0bfeb04 	addi	r2,fp,-84
 201645c:	01801304 	movi	r6,76
 2016460:	000b883a 	mov	r5,zero
 2016464:	1009883a 	mov	r4,r2
 2016468:	2005fa00 	call	2005fa0 <memset>
  dhcp_set_state(&dhcp, DHCP_STATE_INFORMING);
 201646c:	e0bfeb04 	addi	r2,fp,-84
 2016470:	014001c4 	movi	r5,7
 2016474:	1009883a 	mov	r4,r2
 2016478:	20175e40 	call	20175e4 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, &dhcp, DHCP_INFORM, &options_out_len);
 201647c:	e0fffe04 	addi	r3,fp,-8
 2016480:	e0bfeb04 	addi	r2,fp,-84
 2016484:	180f883a 	mov	r7,r3
 2016488:	01800204 	movi	r6,8
 201648c:	100b883a 	mov	r5,r2
 2016490:	e13fff17 	ldw	r4,-4(fp)
 2016494:	20183800 	call	2018380 <dhcp_create_msg>
 2016498:	e0bfe915 	stw	r2,-92(fp)
  if (p_out != NULL) {
 201649c:	e0bfe917 	ldw	r2,-92(fp)
 20164a0:	10002b26 	beq	r2,zero,2016550 <dhcp_inform+0x128>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 20164a4:	e0bfe917 	ldw	r2,-92(fp)
 20164a8:	10800117 	ldw	r2,4(r2)
 20164ac:	e0bfea15 	stw	r2,-88(fp)
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 20164b0:	e0bffe0b 	ldhu	r2,-8(fp)
 20164b4:	10ffffcc 	andi	r3,r2,65535
 20164b8:	e0bfea17 	ldw	r2,-88(fp)
 20164bc:	10803c04 	addi	r2,r2,240
 20164c0:	01c00084 	movi	r7,2
 20164c4:	01800e44 	movi	r6,57
 20164c8:	100b883a 	mov	r5,r2
 20164cc:	1809883a 	mov	r4,r3
 20164d0:	20176400 	call	2017640 <dhcp_option>
 20164d4:	e0bffe0d 	sth	r2,-8(fp)
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 20164d8:	e0bffe0b 	ldhu	r2,-8(fp)
 20164dc:	10ffffcc 	andi	r3,r2,65535
 20164e0:	e0bfea17 	ldw	r2,-88(fp)
 20164e4:	11003c04 	addi	r4,r2,240
 20164e8:	e0bfff17 	ldw	r2,-4(fp)
 20164ec:	10800d0b 	ldhu	r2,52(r2)
 20164f0:	10bfffcc 	andi	r2,r2,65535
 20164f4:	100d883a 	mov	r6,r2
 20164f8:	200b883a 	mov	r5,r4
 20164fc:	1809883a 	mov	r4,r3
 2016500:	201770c0 	call	201770c <dhcp_option_short>
 2016504:	e0bffe0d 	sth	r2,-8(fp)

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, &dhcp, DHCP_STATE_INFORMING, msg_out, DHCP_INFORM, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 2016508:	e0bffe0b 	ldhu	r2,-8(fp)
 201650c:	10ffffcc 	andi	r3,r2,65535
 2016510:	e0bfea17 	ldw	r2,-88(fp)
 2016514:	10803c04 	addi	r2,r2,240
 2016518:	e1bfe917 	ldw	r6,-92(fp)
 201651c:	100b883a 	mov	r5,r2
 2016520:	1809883a 	mov	r4,r3
 2016524:	20186e80 	call	20186e8 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));

    udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
 2016528:	d0e7c417 	ldw	r3,-24816(gp)
 201652c:	e0bfff17 	ldw	r2,-4(fp)
 2016530:	d8800015 	stw	r2,0(sp)
 2016534:	01c010c4 	movi	r7,67
 2016538:	d1a00f04 	addi	r6,gp,-32708
 201653c:	e17fe917 	ldw	r5,-92(fp)
 2016540:	1809883a 	mov	r4,r3
 2016544:	202a1240 	call	202a124 <udp_sendto_if>

    pbuf_free(p_out);
 2016548:	e13fe917 	ldw	r4,-92(fp)
 201654c:	201d2f40 	call	201d2f4 <pbuf_free>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  dhcp_dec_pcb_refcount(); /* delete DHCP PCB if not needed any more */
 2016550:	20156400 	call	2015640 <dhcp_dec_pcb_refcount>
 2016554:	00000306 	br	2016564 <dhcp_inform+0x13c>
  struct dhcp dhcp;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 2016558:	0001883a 	nop
 201655c:	00000106 	br	2016564 <dhcp_inform+0x13c>

  if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
    return;
 2016560:	0001883a 	nop
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  dhcp_dec_pcb_refcount(); /* delete DHCP PCB if not needed any more */
}
 2016564:	e037883a 	mov	sp,fp
 2016568:	dfc00117 	ldw	ra,4(sp)
 201656c:	df000017 	ldw	fp,0(sp)
 2016570:	dec00204 	addi	sp,sp,8
 2016574:	f800283a 	ret

02016578 <dhcp_network_changed_link_up>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed_link_up(struct netif *netif)
{
 2016578:	defffc04 	addi	sp,sp,-16
 201657c:	dfc00315 	stw	ra,12(sp)
 2016580:	df000215 	stw	fp,8(sp)
 2016584:	df000204 	addi	fp,sp,8
 2016588:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 201658c:	e0bfff17 	ldw	r2,-4(fp)
 2016590:	10800a17 	ldw	r2,40(r2)
 2016594:	e0bffe15 	stw	r2,-8(fp)

  if (!dhcp) {
 2016598:	e0bffe17 	ldw	r2,-8(fp)
 201659c:	10001626 	beq	r2,zero,20165f8 <dhcp_network_changed_link_up+0x80>
    return;
  }
  switch (dhcp->state) {
 20165a0:	e0bffe17 	ldw	r2,-8(fp)
 20165a4:	10800143 	ldbu	r2,5(r2)
 20165a8:	10803fcc 	andi	r2,r2,255
 20165ac:	10c00188 	cmpgei	r3,r2,6
 20165b0:	1800041e 	bne	r3,zero,20165c4 <dhcp_network_changed_link_up+0x4c>
 20165b4:	10c000c8 	cmpgei	r3,r2,3
 20165b8:	1800041e 	bne	r3,zero,20165cc <dhcp_network_changed_link_up+0x54>
 20165bc:	10001026 	beq	r2,zero,2016600 <dhcp_network_changed_link_up+0x88>
 20165c0:	00000706 	br	20165e0 <dhcp_network_changed_link_up+0x68>
 20165c4:	108002a0 	cmpeqi	r2,r2,10
 20165c8:	10000526 	beq	r2,zero,20165e0 <dhcp_network_changed_link_up+0x68>
    case DHCP_STATE_REBINDING:
    case DHCP_STATE_RENEWING:
    case DHCP_STATE_BOUND:
    case DHCP_STATE_REBOOTING:
      dhcp->tries = 0;
 20165cc:	e0bffe17 	ldw	r2,-8(fp)
 20165d0:	10000185 	stb	zero,6(r2)
      dhcp_reboot(netif);
 20165d4:	e13fff17 	ldw	r4,-4(fp)
 20165d8:	20170c80 	call	20170c8 <dhcp_reboot>
      break;
 20165dc:	00000906 	br	2016604 <dhcp_network_changed_link_up+0x8c>
      LWIP_ASSERT("invalid dhcp->state", dhcp->state <= DHCP_STATE_BACKING_OFF);
      /* INIT/REQUESTING/CHECKING/BACKING_OFF restart with new 'rid' because the
         state changes, SELECTING: continue with current 'rid' as we stay in the
         same state */
      /* ensure we start with short timeouts, even if already discovering */
      dhcp->tries = 0;
 20165e0:	e0bffe17 	ldw	r2,-8(fp)
 20165e4:	10000185 	stb	zero,6(r2)
      dhcp_discover(netif);
 20165e8:	e13fff17 	ldw	r4,-4(fp)
 20165ec:	20167580 	call	2016758 <dhcp_discover>
      break;
 20165f0:	0001883a 	nop
 20165f4:	00000306 	br	2016604 <dhcp_network_changed_link_up+0x8c>
dhcp_network_changed_link_up(struct netif *netif)
{
  struct dhcp *dhcp = netif_dhcp_data(netif);

  if (!dhcp) {
    return;
 20165f8:	0001883a 	nop
 20165fc:	00000106 	br	2016604 <dhcp_network_changed_link_up+0x8c>
      dhcp->tries = 0;
      dhcp_reboot(netif);
      break;
    case DHCP_STATE_OFF:
      /* stay off */
      break;
 2016600:	0001883a 	nop
      /* ensure we start with short timeouts, even if already discovering */
      dhcp->tries = 0;
      dhcp_discover(netif);
      break;
  }
}
 2016604:	e037883a 	mov	sp,fp
 2016608:	dfc00117 	ldw	ra,4(sp)
 201660c:	df000017 	ldw	fp,0(sp)
 2016610:	dec00204 	addi	sp,sp,8
 2016614:	f800283a 	ret

02016618 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
 2016618:	defff404 	addi	sp,sp,-48
 201661c:	dfc00b15 	stw	ra,44(sp)
 2016620:	df000a15 	stw	fp,40(sp)
 2016624:	dc400915 	stw	r17,36(sp)
 2016628:	dc000815 	stw	r16,32(sp)
 201662c:	df000a04 	addi	fp,sp,40
 2016630:	e13ffd15 	stw	r4,-12(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2016634:	e0bffd17 	ldw	r2,-12(fp)
 2016638:	10800a17 	ldw	r2,40(r2)
 201663c:	e0bff915 	stw	r2,-28(fp)
  err_t result;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
 2016640:	01400304 	movi	r5,12
 2016644:	e13ff917 	ldw	r4,-28(fp)
 2016648:	20175e40 	call	20175e4 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DECLINE, &options_out_len);
 201664c:	e0bffc04 	addi	r2,fp,-16
 2016650:	100f883a 	mov	r7,r2
 2016654:	01800104 	movi	r6,4
 2016658:	e17ff917 	ldw	r5,-28(fp)
 201665c:	e13ffd17 	ldw	r4,-12(fp)
 2016660:	20183800 	call	2018380 <dhcp_create_msg>
 2016664:	e0bffa15 	stw	r2,-24(fp)
  if (p_out != NULL) {
 2016668:	e0bffa17 	ldw	r2,-24(fp)
 201666c:	10003026 	beq	r2,zero,2016730 <dhcp_decline+0x118>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 2016670:	e0bffa17 	ldw	r2,-24(fp)
 2016674:	10800117 	ldw	r2,4(r2)
 2016678:	e0bffb15 	stw	r2,-20(fp)
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
 201667c:	e0bffc0b 	ldhu	r2,-16(fp)
 2016680:	10ffffcc 	andi	r3,r2,65535
 2016684:	e0bffb17 	ldw	r2,-20(fp)
 2016688:	10803c04 	addi	r2,r2,240
 201668c:	01c00104 	movi	r7,4
 2016690:	01800c84 	movi	r6,50
 2016694:	100b883a 	mov	r5,r2
 2016698:	1809883a 	mov	r4,r3
 201669c:	20176400 	call	2017640 <dhcp_option>
 20166a0:	e0bffc0d 	sth	r2,-16(fp)
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 20166a4:	e0bffc0b 	ldhu	r2,-16(fp)
 20166a8:	143fffcc 	andi	r16,r2,65535
 20166ac:	e0bffb17 	ldw	r2,-20(fp)
 20166b0:	14403c04 	addi	r17,r2,240
 20166b4:	e0bff917 	ldw	r2,-28(fp)
 20166b8:	10800717 	ldw	r2,28(r2)
 20166bc:	1009883a 	mov	r4,r2
 20166c0:	20394b00 	call	20394b0 <lwip_htonl>
 20166c4:	100d883a 	mov	r6,r2
 20166c8:	880b883a 	mov	r5,r17
 20166cc:	8009883a 	mov	r4,r16
 20166d0:	20177840 	call	2017784 <dhcp_option_long>
 20166d4:	e0bffc0d 	sth	r2,-16(fp)

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_BACKING_OFF, msg_out, DHCP_DECLINE, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 20166d8:	e0bffc0b 	ldhu	r2,-16(fp)
 20166dc:	10ffffcc 	andi	r3,r2,65535
 20166e0:	e0bffb17 	ldw	r2,-20(fp)
 20166e4:	10803c04 	addi	r2,r2,240
 20166e8:	e1bffa17 	ldw	r6,-24(fp)
 20166ec:	100b883a 	mov	r5,r2
 20166f0:	1809883a 	mov	r4,r3
 20166f4:	20186e80 	call	20186e8 <dhcp_option_trailer>

    /* per section 4.4.4, broadcast DECLINE messages */
    result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
 20166f8:	d0e7c417 	ldw	r3,-24816(gp)
 20166fc:	d0a00e04 	addi	r2,gp,-32712
 2016700:	d8800115 	stw	r2,4(sp)
 2016704:	e0bffd17 	ldw	r2,-12(fp)
 2016708:	d8800015 	stw	r2,0(sp)
 201670c:	01c010c4 	movi	r7,67
 2016710:	d1a00f04 	addi	r6,gp,-32708
 2016714:	e17ffa17 	ldw	r5,-24(fp)
 2016718:	1809883a 	mov	r4,r3
 201671c:	202a2a40 	call	202a2a4 <udp_sendto_if_src>
 2016720:	e0bff805 	stb	r2,-32(fp)
    pbuf_free(p_out);
 2016724:	e13ffa17 	ldw	r4,-24(fp)
 2016728:	201d2f40 	call	201d2f4 <pbuf_free>
 201672c:	00000206 	br	2016738 <dhcp_decline+0x120>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_decline: could not allocate DHCP request\n"));
    result = ERR_MEM;
 2016730:	00bfffc4 	movi	r2,-1
 2016734:	e0bff805 	stb	r2,-32(fp)
  }
  return result;
 2016738:	e0bff803 	ldbu	r2,-32(fp)
}
 201673c:	e6fffe04 	addi	sp,fp,-8
 2016740:	dfc00317 	ldw	ra,12(sp)
 2016744:	df000217 	ldw	fp,8(sp)
 2016748:	dc400117 	ldw	r17,4(sp)
 201674c:	dc000017 	ldw	r16,0(sp)
 2016750:	dec00404 	addi	sp,sp,16
 2016754:	f800283a 	ret

02016758 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
 2016758:	defff504 	addi	sp,sp,-44
 201675c:	dfc00a15 	stw	ra,40(sp)
 2016760:	df000915 	stw	fp,36(sp)
 2016764:	df000904 	addi	fp,sp,36
 2016768:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 201676c:	e0bfff17 	ldw	r2,-4(fp)
 2016770:	10800a17 	ldw	r2,40(r2)
 2016774:	e0bffa15 	stw	r2,-24(fp)
  err_t result = ERR_OK;
 2016778:	e03ffb05 	stb	zero,-20(fp)
  if (dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES) {
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  ip4_addr_set_any(&dhcp->offered_ip_addr);
 201677c:	e0bffa17 	ldw	r2,-24(fp)
 2016780:	10000715 	stw	zero,28(r2)
  dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
 2016784:	01400184 	movi	r5,6
 2016788:	e13ffa17 	ldw	r4,-24(fp)
 201678c:	20175e40 	call	20175e4 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER, &options_out_len);
 2016790:	e0bffe84 	addi	r2,fp,-6
 2016794:	100f883a 	mov	r7,r2
 2016798:	01800044 	movi	r6,1
 201679c:	e17ffa17 	ldw	r5,-24(fp)
 20167a0:	e13fff17 	ldw	r4,-4(fp)
 20167a4:	20183800 	call	2018380 <dhcp_create_msg>
 20167a8:	e0bffc15 	stw	r2,-16(fp)
  if (p_out != NULL) {
 20167ac:	e0bffc17 	ldw	r2,-16(fp)
 20167b0:	10004b26 	beq	r2,zero,20168e0 <dhcp_discover+0x188>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 20167b4:	e0bffc17 	ldw	r2,-16(fp)
 20167b8:	10800117 	ldw	r2,4(r2)
 20167bc:	e0bffd15 	stw	r2,-12(fp)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 20167c0:	e0bffe8b 	ldhu	r2,-6(fp)
 20167c4:	10ffffcc 	andi	r3,r2,65535
 20167c8:	e0bffd17 	ldw	r2,-12(fp)
 20167cc:	10803c04 	addi	r2,r2,240
 20167d0:	01c00084 	movi	r7,2
 20167d4:	01800e44 	movi	r6,57
 20167d8:	100b883a 	mov	r5,r2
 20167dc:	1809883a 	mov	r4,r3
 20167e0:	20176400 	call	2017640 <dhcp_option>
 20167e4:	e0bffe8d 	sth	r2,-6(fp)
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 20167e8:	e0bffe8b 	ldhu	r2,-6(fp)
 20167ec:	10ffffcc 	andi	r3,r2,65535
 20167f0:	e0bffd17 	ldw	r2,-12(fp)
 20167f4:	11003c04 	addi	r4,r2,240
 20167f8:	e0bfff17 	ldw	r2,-4(fp)
 20167fc:	10800d0b 	ldhu	r2,52(r2)
 2016800:	10bfffcc 	andi	r2,r2,65535
 2016804:	100d883a 	mov	r6,r2
 2016808:	200b883a 	mov	r5,r4
 201680c:	1809883a 	mov	r4,r3
 2016810:	201770c0 	call	201770c <dhcp_option_short>
 2016814:	e0bffe8d 	sth	r2,-6(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 2016818:	e0bffe8b 	ldhu	r2,-6(fp)
 201681c:	10ffffcc 	andi	r3,r2,65535
 2016820:	e0bffd17 	ldw	r2,-12(fp)
 2016824:	10803c04 	addi	r2,r2,240
 2016828:	01c000c4 	movi	r7,3
 201682c:	01800dc4 	movi	r6,55
 2016830:	100b883a 	mov	r5,r2
 2016834:	1809883a 	mov	r4,r3
 2016838:	20176400 	call	2017640 <dhcp_option>
 201683c:	e0bffe8d 	sth	r2,-6(fp)
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2016840:	e03ff905 	stb	zero,-28(fp)
 2016844:	00000f06 	br	2016884 <dhcp_discover+0x12c>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 2016848:	e0bffe8b 	ldhu	r2,-6(fp)
 201684c:	113fffcc 	andi	r4,r2,65535
 2016850:	e0bffd17 	ldw	r2,-12(fp)
 2016854:	11403c04 	addi	r5,r2,240
 2016858:	e0fff903 	ldbu	r3,-28(fp)
 201685c:	d0a00c04 	addi	r2,gp,-32720
 2016860:	1885883a 	add	r2,r3,r2
 2016864:	10800003 	ldbu	r2,0(r2)
 2016868:	10803fcc 	andi	r2,r2,255
 201686c:	100d883a 	mov	r6,r2
 2016870:	20176b80 	call	20176b8 <dhcp_option_byte>
 2016874:	e0bffe8d 	sth	r2,-6(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2016878:	e0bff903 	ldbu	r2,-28(fp)
 201687c:	10800044 	addi	r2,r2,1
 2016880:	e0bff905 	stb	r2,-28(fp)
 2016884:	e0bff903 	ldbu	r2,-28(fp)
 2016888:	108000f0 	cmpltui	r2,r2,3
 201688c:	103fee1e 	bne	r2,zero,2016848 <__alt_mem_mem_0+0xfcff6848>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
    }
    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_SELECTING, msg_out, DHCP_DISCOVER, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 2016890:	e0bffe8b 	ldhu	r2,-6(fp)
 2016894:	10ffffcc 	andi	r3,r2,65535
 2016898:	e0bffd17 	ldw	r2,-12(fp)
 201689c:	10803c04 	addi	r2,r2,240
 20168a0:	e1bffc17 	ldw	r6,-16(fp)
 20168a4:	100b883a 	mov	r5,r2
 20168a8:	1809883a 	mov	r4,r3
 20168ac:	20186e80 	call	20186e8 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER)\n"));
    udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
 20168b0:	d0e7c417 	ldw	r3,-24816(gp)
 20168b4:	d0a00e04 	addi	r2,gp,-32712
 20168b8:	d8800115 	stw	r2,4(sp)
 20168bc:	e0bfff17 	ldw	r2,-4(fp)
 20168c0:	d8800015 	stw	r2,0(sp)
 20168c4:	01c010c4 	movi	r7,67
 20168c8:	d1a00f04 	addi	r6,gp,-32708
 20168cc:	e17ffc17 	ldw	r5,-16(fp)
 20168d0:	1809883a 	mov	r4,r3
 20168d4:	202a2a40 	call	202a2a4 <udp_sendto_if_src>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()\n"));
    pbuf_free(p_out);
 20168d8:	e13ffc17 	ldw	r4,-16(fp)
 20168dc:	201d2f40 	call	201d2f4 <pbuf_free>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }

  if (dhcp->tries < 255) {
 20168e0:	e0bffa17 	ldw	r2,-24(fp)
 20168e4:	10800183 	ldbu	r2,6(r2)
 20168e8:	10803fcc 	andi	r2,r2,255
 20168ec:	10803fe0 	cmpeqi	r2,r2,255
 20168f0:	1000061e 	bne	r2,zero,201690c <dhcp_discover+0x1b4>
    dhcp->tries++;
 20168f4:	e0bffa17 	ldw	r2,-24(fp)
 20168f8:	10800183 	ldbu	r2,6(r2)
 20168fc:	10800044 	addi	r2,r2,1
 2016900:	1007883a 	mov	r3,r2
 2016904:	e0bffa17 	ldw	r2,-24(fp)
 2016908:	10c00185 	stb	r3,6(r2)
  }
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
 201690c:	e0bffa17 	ldw	r2,-24(fp)
 2016910:	10800183 	ldbu	r2,6(r2)
 2016914:	10803fcc 	andi	r2,r2,255
 2016918:	108001a8 	cmpgeui	r2,r2,6
 201691c:	1000071e 	bne	r2,zero,201693c <dhcp_discover+0x1e4>
 2016920:	e0bffa17 	ldw	r2,-24(fp)
 2016924:	10800183 	ldbu	r2,6(r2)
 2016928:	10803fcc 	andi	r2,r2,255
 201692c:	00c00044 	movi	r3,1
 2016930:	1884983a 	sll	r2,r3,r2
 2016934:	1080fa24 	muli	r2,r2,1000
 2016938:	00000106 	br	2016940 <dhcp_discover+0x1e8>
 201693c:	00ba9804 	movi	r2,-5536
 2016940:	e0bffe0d 	sth	r2,-8(fp)
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 2016944:	e0bffe0b 	ldhu	r2,-8(fp)
 2016948:	10807cc4 	addi	r2,r2,499
 201694c:	01407d04 	movi	r5,500
 2016950:	1009883a 	mov	r4,r2
 2016954:	200a9e40 	call	200a9e4 <__divsi3>
 2016958:	1007883a 	mov	r3,r2
 201695c:	e0bffa17 	ldw	r2,-24(fp)
 2016960:	10c0020d 	sth	r3,8(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2016964:	e0bffb03 	ldbu	r2,-20(fp)
}
 2016968:	e037883a 	mov	sp,fp
 201696c:	dfc00117 	ldw	ra,4(sp)
 2016970:	df000017 	ldw	fp,0(sp)
 2016974:	dec00204 	addi	sp,sp,8
 2016978:	f800283a 	ret

0201697c <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
 201697c:	defff804 	addi	sp,sp,-32
 2016980:	dfc00715 	stw	ra,28(sp)
 2016984:	df000615 	stw	fp,24(sp)
 2016988:	df000604 	addi	fp,sp,24
 201698c:	e13fff15 	stw	r4,-4(fp)
  u32_t timeout;
  struct dhcp *dhcp;
  ip4_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
 2016990:	e0bfff17 	ldw	r2,-4(fp)
 2016994:	1000a426 	beq	r2,zero,2016c28 <dhcp_bind+0x2ac>
  dhcp = netif_dhcp_data(netif);
 2016998:	e0bfff17 	ldw	r2,-4(fp)
 201699c:	10800a17 	ldw	r2,40(r2)
 20169a0:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
 20169a4:	e0bffb17 	ldw	r2,-20(fp)
 20169a8:	1000a126 	beq	r2,zero,2016c30 <dhcp_bind+0x2b4>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* reset time used of lease */
  dhcp->lease_used = 0;
 20169ac:	e0bffb17 	ldw	r2,-20(fp)
 20169b0:	1000048d 	sth	zero,18(r2)

  if (dhcp->offered_t0_lease != 0xffffffffUL) {
 20169b4:	e0bffb17 	ldw	r2,-20(fp)
 20169b8:	10800a17 	ldw	r2,40(r2)
 20169bc:	10bfffe0 	cmpeqi	r2,r2,-1
 20169c0:	1000171e 	bne	r2,zero,2016a20 <dhcp_bind+0xa4>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t0 renewal timer %"U32_F" secs\n", dhcp->offered_t0_lease));
    timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 20169c4:	e0bffb17 	ldw	r2,-20(fp)
 20169c8:	10800a17 	ldw	r2,40(r2)
 20169cc:	10800784 	addi	r2,r2,30
 20169d0:	01400f04 	movi	r5,60
 20169d4:	1009883a 	mov	r4,r2
 20169d8:	200aadc0 	call	200aadc <__udivsi3>
 20169dc:	e0bffa15 	stw	r2,-24(fp)
    if (timeout > 0xffff) {
 20169e0:	e0bffa17 	ldw	r2,-24(fp)
 20169e4:	00ffffd4 	movui	r3,65535
 20169e8:	1880022e 	bgeu	r3,r2,20169f4 <dhcp_bind+0x78>
      timeout = 0xffff;
 20169ec:	00bfffd4 	movui	r2,65535
 20169f0:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t0_timeout = (u16_t)timeout;
 20169f4:	e0bffa17 	ldw	r2,-24(fp)
 20169f8:	1007883a 	mov	r3,r2
 20169fc:	e0bffb17 	ldw	r2,-20(fp)
 2016a00:	10c0050d 	sth	r3,20(r2)
    if (dhcp->t0_timeout == 0) {
 2016a04:	e0bffb17 	ldw	r2,-20(fp)
 2016a08:	1080050b 	ldhu	r2,20(r2)
 2016a0c:	10bfffcc 	andi	r2,r2,65535
 2016a10:	1000031e 	bne	r2,zero,2016a20 <dhcp_bind+0xa4>
      dhcp->t0_timeout = 1;
 2016a14:	e0bffb17 	ldw	r2,-20(fp)
 2016a18:	00c00044 	movi	r3,1
 2016a1c:	10c0050d 	sth	r3,20(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t0_lease * 1000));
  }

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
 2016a20:	e0bffb17 	ldw	r2,-20(fp)
 2016a24:	10800b17 	ldw	r2,44(r2)
 2016a28:	10bfffe0 	cmpeqi	r2,r2,-1
 2016a2c:	10001b1e 	bne	r2,zero,2016a9c <dhcp_bind+0x120>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 2016a30:	e0bffb17 	ldw	r2,-20(fp)
 2016a34:	10800b17 	ldw	r2,44(r2)
 2016a38:	10800784 	addi	r2,r2,30
 2016a3c:	01400f04 	movi	r5,60
 2016a40:	1009883a 	mov	r4,r2
 2016a44:	200aadc0 	call	200aadc <__udivsi3>
 2016a48:	e0bffa15 	stw	r2,-24(fp)
    if (timeout > 0xffff) {
 2016a4c:	e0bffa17 	ldw	r2,-24(fp)
 2016a50:	00ffffd4 	movui	r3,65535
 2016a54:	1880022e 	bgeu	r3,r2,2016a60 <dhcp_bind+0xe4>
      timeout = 0xffff;
 2016a58:	00bfffd4 	movui	r2,65535
 2016a5c:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
 2016a60:	e0bffa17 	ldw	r2,-24(fp)
 2016a64:	1007883a 	mov	r3,r2
 2016a68:	e0bffb17 	ldw	r2,-20(fp)
 2016a6c:	10c0028d 	sth	r3,10(r2)
    if (dhcp->t1_timeout == 0) {
 2016a70:	e0bffb17 	ldw	r2,-20(fp)
 2016a74:	1080028b 	ldhu	r2,10(r2)
 2016a78:	10bfffcc 	andi	r2,r2,65535
 2016a7c:	1000031e 	bne	r2,zero,2016a8c <dhcp_bind+0x110>
      dhcp->t1_timeout = 1;
 2016a80:	e0bffb17 	ldw	r2,-20(fp)
 2016a84:	00c00044 	movi	r3,1
 2016a88:	10c0028d 	sth	r3,10(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew * 1000));
    dhcp->t1_renew_time = dhcp->t1_timeout;
 2016a8c:	e0bffb17 	ldw	r2,-20(fp)
 2016a90:	10c0028b 	ldhu	r3,10(r2)
 2016a94:	e0bffb17 	ldw	r2,-20(fp)
 2016a98:	10c0038d 	sth	r3,14(r2)
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
 2016a9c:	e0bffb17 	ldw	r2,-20(fp)
 2016aa0:	10800c17 	ldw	r2,48(r2)
 2016aa4:	10bfffe0 	cmpeqi	r2,r2,-1
 2016aa8:	10001b1e 	bne	r2,zero,2016b18 <dhcp_bind+0x19c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 2016aac:	e0bffb17 	ldw	r2,-20(fp)
 2016ab0:	10800c17 	ldw	r2,48(r2)
 2016ab4:	10800784 	addi	r2,r2,30
 2016ab8:	01400f04 	movi	r5,60
 2016abc:	1009883a 	mov	r4,r2
 2016ac0:	200aadc0 	call	200aadc <__udivsi3>
 2016ac4:	e0bffa15 	stw	r2,-24(fp)
    if (timeout > 0xffff) {
 2016ac8:	e0bffa17 	ldw	r2,-24(fp)
 2016acc:	00ffffd4 	movui	r3,65535
 2016ad0:	1880022e 	bgeu	r3,r2,2016adc <dhcp_bind+0x160>
      timeout = 0xffff;
 2016ad4:	00bfffd4 	movui	r2,65535
 2016ad8:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
 2016adc:	e0bffa17 	ldw	r2,-24(fp)
 2016ae0:	1007883a 	mov	r3,r2
 2016ae4:	e0bffb17 	ldw	r2,-20(fp)
 2016ae8:	10c0030d 	sth	r3,12(r2)
    if (dhcp->t2_timeout == 0) {
 2016aec:	e0bffb17 	ldw	r2,-20(fp)
 2016af0:	1080030b 	ldhu	r2,12(r2)
 2016af4:	10bfffcc 	andi	r2,r2,65535
 2016af8:	1000031e 	bne	r2,zero,2016b08 <dhcp_bind+0x18c>
      dhcp->t2_timeout = 1;
 2016afc:	e0bffb17 	ldw	r2,-20(fp)
 2016b00:	00c00044 	movi	r3,1
 2016b04:	10c0030d 	sth	r3,12(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind * 1000));
    dhcp->t2_rebind_time = dhcp->t2_timeout;
 2016b08:	e0bffb17 	ldw	r2,-20(fp)
 2016b0c:	10c0030b 	ldhu	r3,12(r2)
 2016b10:	e0bffb17 	ldw	r2,-20(fp)
 2016b14:	10c0040d 	sth	r3,16(r2)
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
 2016b18:	e0bffb17 	ldw	r2,-20(fp)
 2016b1c:	10c0028b 	ldhu	r3,10(r2)
 2016b20:	e0bffb17 	ldw	r2,-20(fp)
 2016b24:	1080030b 	ldhu	r2,12(r2)
 2016b28:	18ffffcc 	andi	r3,r3,65535
 2016b2c:	10bfffcc 	andi	r2,r2,65535
 2016b30:	18800636 	bltu	r3,r2,2016b4c <dhcp_bind+0x1d0>
 2016b34:	e0bffb17 	ldw	r2,-20(fp)
 2016b38:	1080030b 	ldhu	r2,12(r2)
 2016b3c:	10bfffcc 	andi	r2,r2,65535
 2016b40:	10000226 	beq	r2,zero,2016b4c <dhcp_bind+0x1d0>
    dhcp->t1_timeout = 0;
 2016b44:	e0bffb17 	ldw	r2,-20(fp)
 2016b48:	1000028d 	sth	zero,10(r2)
  }

  if (dhcp->subnet_mask_given) {
 2016b4c:	e0bffb17 	ldw	r2,-20(fp)
 2016b50:	108001c3 	ldbu	r2,7(r2)
 2016b54:	10803fcc 	andi	r2,r2,255
 2016b58:	10000426 	beq	r2,zero,2016b6c <dhcp_bind+0x1f0>
    /* copy offered network mask */
    ip4_addr_copy(sn_mask, dhcp->offered_sn_mask);
 2016b5c:	e0bffb17 	ldw	r2,-20(fp)
 2016b60:	10800817 	ldw	r2,32(r2)
 2016b64:	e0bffd15 	stw	r2,-12(fp)
 2016b68:	00001506 	br	2016bc0 <dhcp_bind+0x244>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
 2016b6c:	e0bffb17 	ldw	r2,-20(fp)
 2016b70:	10800704 	addi	r2,r2,28
 2016b74:	10800003 	ldbu	r2,0(r2)
 2016b78:	e0bffc05 	stb	r2,-16(fp)
    if (first_octet <= 127) {
 2016b7c:	e0bffc03 	ldbu	r2,-16(fp)
 2016b80:	10803fcc 	andi	r2,r2,255
 2016b84:	1080201c 	xori	r2,r2,128
 2016b88:	10bfe004 	addi	r2,r2,-128
 2016b8c:	10000316 	blt	r2,zero,2016b9c <dhcp_bind+0x220>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
 2016b90:	00803fc4 	movi	r2,255
 2016b94:	e0bffd15 	stw	r2,-12(fp)
 2016b98:	00000906 	br	2016bc0 <dhcp_bind+0x244>
    } else if (first_octet >= 192) {
 2016b9c:	e0bffc03 	ldbu	r2,-16(fp)
 2016ba0:	10803030 	cmpltui	r2,r2,192
 2016ba4:	1000041e 	bne	r2,zero,2016bb8 <dhcp_bind+0x23c>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
 2016ba8:	00804034 	movhi	r2,256
 2016bac:	10bfffc4 	addi	r2,r2,-1
 2016bb0:	e0bffd15 	stw	r2,-12(fp)
 2016bb4:	00000206 	br	2016bc0 <dhcp_bind+0x244>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
 2016bb8:	00bfffd4 	movui	r2,65535
 2016bbc:	e0bffd15 	stw	r2,-12(fp)
    }
  }

  ip4_addr_copy(gw_addr, dhcp->offered_gw_addr);
 2016bc0:	e0bffb17 	ldw	r2,-20(fp)
 2016bc4:	10800917 	ldw	r2,36(r2)
 2016bc8:	e0bffe15 	stw	r2,-8(fp)
  /* gateway address not given? */
  if (ip4_addr_isany_val(gw_addr)) {
 2016bcc:	e0bffe17 	ldw	r2,-8(fp)
 2016bd0:	1000081e 	bne	r2,zero,2016bf4 <dhcp_bind+0x278>
    /* copy network address */
    ip4_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
 2016bd4:	e0bffb17 	ldw	r2,-20(fp)
 2016bd8:	10c00717 	ldw	r3,28(r2)
 2016bdc:	e0bffd17 	ldw	r2,-12(fp)
 2016be0:	1884703a 	and	r2,r3,r2
 2016be4:	e0bffe15 	stw	r2,-8(fp)
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
 2016be8:	e0bffe17 	ldw	r2,-8(fp)
 2016bec:	10804034 	orhi	r2,r2,256
 2016bf0:	e0bffe15 	stw	r2,-8(fp)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F" SN: 0x%08"X32_F" GW: 0x%08"X32_F"\n",
              ip4_addr_get_u32(&dhcp->offered_ip_addr), ip4_addr_get_u32(&sn_mask), ip4_addr_get_u32(&gw_addr)));
  /* netif is now bound to DHCP leased address - set this before assigning the address
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BOUND);
 2016bf4:	01400284 	movi	r5,10
 2016bf8:	e13ffb17 	ldw	r4,-20(fp)
 2016bfc:	20175e40 	call	20175e4 <dhcp_set_state>

  netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
 2016c00:	e0bffb17 	ldw	r2,-20(fp)
 2016c04:	10800704 	addi	r2,r2,28
 2016c08:	e13ffe04 	addi	r4,fp,-8
 2016c0c:	e0fffd04 	addi	r3,fp,-12
 2016c10:	200f883a 	mov	r7,r4
 2016c14:	180d883a 	mov	r6,r3
 2016c18:	100b883a 	mov	r5,r2
 2016c1c:	e13fff17 	ldw	r4,-4(fp)
 2016c20:	201bff80 	call	201bff8 <netif_set_addr>
 2016c24:	00000306 	br	2016c34 <dhcp_bind+0x2b8>
dhcp_bind(struct netif *netif)
{
  u32_t timeout;
  struct dhcp *dhcp;
  ip4_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
 2016c28:	0001883a 	nop
 2016c2c:	00000106 	br	2016c34 <dhcp_bind+0x2b8>
  dhcp = netif_dhcp_data(netif);
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
 2016c30:	0001883a 	nop
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BOUND);

  netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
  /* interface is used by routing now that an address is set */
}
 2016c34:	e037883a 	mov	sp,fp
 2016c38:	dfc00117 	ldw	ra,4(sp)
 2016c3c:	df000017 	ldw	fp,0(sp)
 2016c40:	dec00204 	addi	sp,sp,8
 2016c44:	f800283a 	ret

02016c48 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
 2016c48:	defff704 	addi	sp,sp,-36
 2016c4c:	dfc00815 	stw	ra,32(sp)
 2016c50:	df000715 	stw	fp,28(sp)
 2016c54:	df000704 	addi	fp,sp,28
 2016c58:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2016c5c:	e0bfff17 	ldw	r2,-4(fp)
 2016c60:	10800a17 	ldw	r2,40(r2)
 2016c64:	e0bffb15 	stw	r2,-20(fp)
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_RENEWING);
 2016c68:	01400144 	movi	r5,5
 2016c6c:	e13ffb17 	ldw	r4,-20(fp)
 2016c70:	20175e40 	call	20175e4 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
 2016c74:	e0bffe84 	addi	r2,fp,-6
 2016c78:	100f883a 	mov	r7,r2
 2016c7c:	018000c4 	movi	r6,3
 2016c80:	e17ffb17 	ldw	r5,-20(fp)
 2016c84:	e13fff17 	ldw	r4,-4(fp)
 2016c88:	20183800 	call	2018380 <dhcp_create_msg>
 2016c8c:	e0bffc15 	stw	r2,-16(fp)
  if (p_out != NULL) {
 2016c90:	e0bffc17 	ldw	r2,-16(fp)
 2016c94:	10005626 	beq	r2,zero,2016df0 <dhcp_renew+0x1a8>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 2016c98:	e0bffc17 	ldw	r2,-16(fp)
 2016c9c:	10800117 	ldw	r2,4(r2)
 2016ca0:	e0bffd15 	stw	r2,-12(fp)
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 2016ca4:	e0bffe8b 	ldhu	r2,-6(fp)
 2016ca8:	10ffffcc 	andi	r3,r2,65535
 2016cac:	e0bffd17 	ldw	r2,-12(fp)
 2016cb0:	10803c04 	addi	r2,r2,240
 2016cb4:	01c00084 	movi	r7,2
 2016cb8:	01800e44 	movi	r6,57
 2016cbc:	100b883a 	mov	r5,r2
 2016cc0:	1809883a 	mov	r4,r3
 2016cc4:	20176400 	call	2017640 <dhcp_option>
 2016cc8:	e0bffe8d 	sth	r2,-6(fp)
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 2016ccc:	e0bffe8b 	ldhu	r2,-6(fp)
 2016cd0:	10ffffcc 	andi	r3,r2,65535
 2016cd4:	e0bffd17 	ldw	r2,-12(fp)
 2016cd8:	11003c04 	addi	r4,r2,240
 2016cdc:	e0bfff17 	ldw	r2,-4(fp)
 2016ce0:	10800d0b 	ldhu	r2,52(r2)
 2016ce4:	10bfffcc 	andi	r2,r2,65535
 2016ce8:	100d883a 	mov	r6,r2
 2016cec:	200b883a 	mov	r5,r4
 2016cf0:	1809883a 	mov	r4,r3
 2016cf4:	201770c0 	call	201770c <dhcp_option_short>
 2016cf8:	e0bffe8d 	sth	r2,-6(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 2016cfc:	e0bffe8b 	ldhu	r2,-6(fp)
 2016d00:	10ffffcc 	andi	r3,r2,65535
 2016d04:	e0bffd17 	ldw	r2,-12(fp)
 2016d08:	10803c04 	addi	r2,r2,240
 2016d0c:	01c000c4 	movi	r7,3
 2016d10:	01800dc4 	movi	r6,55
 2016d14:	100b883a 	mov	r5,r2
 2016d18:	1809883a 	mov	r4,r3
 2016d1c:	20176400 	call	2017640 <dhcp_option>
 2016d20:	e0bffe8d 	sth	r2,-6(fp)
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2016d24:	e03ffa45 	stb	zero,-23(fp)
 2016d28:	00000f06 	br	2016d68 <dhcp_renew+0x120>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 2016d2c:	e0bffe8b 	ldhu	r2,-6(fp)
 2016d30:	113fffcc 	andi	r4,r2,65535
 2016d34:	e0bffd17 	ldw	r2,-12(fp)
 2016d38:	11403c04 	addi	r5,r2,240
 2016d3c:	e0fffa43 	ldbu	r3,-23(fp)
 2016d40:	d0a00c04 	addi	r2,gp,-32720
 2016d44:	1885883a 	add	r2,r3,r2
 2016d48:	10800003 	ldbu	r2,0(r2)
 2016d4c:	10803fcc 	andi	r2,r2,255
 2016d50:	100d883a 	mov	r6,r2
 2016d54:	20176b80 	call	20176b8 <dhcp_option_byte>
 2016d58:	e0bffe8d 	sth	r2,-6(fp)
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2016d5c:	e0bffa43 	ldbu	r2,-23(fp)
 2016d60:	10800044 	addi	r2,r2,1
 2016d64:	e0bffa45 	stb	r2,-23(fp)
 2016d68:	e0bffa43 	ldbu	r2,-23(fp)
 2016d6c:	108000f0 	cmpltui	r2,r2,3
 2016d70:	103fee1e 	bne	r2,zero,2016d2c <__alt_mem_mem_0+0xfcff6d2c>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
    }

#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
 2016d74:	e0bffe8b 	ldhu	r2,-6(fp)
 2016d78:	10ffffcc 	andi	r3,r2,65535
 2016d7c:	e0bffd17 	ldw	r2,-12(fp)
 2016d80:	10803c04 	addi	r2,r2,240
 2016d84:	e1bfff17 	ldw	r6,-4(fp)
 2016d88:	100b883a 	mov	r5,r2
 2016d8c:	1809883a 	mov	r4,r3
 2016d90:	20178480 	call	2017848 <dhcp_option_hostname>
 2016d94:	e0bffe8d 	sth	r2,-6(fp)
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_RENEWING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 2016d98:	e0bffe8b 	ldhu	r2,-6(fp)
 2016d9c:	10ffffcc 	andi	r3,r2,65535
 2016da0:	e0bffd17 	ldw	r2,-12(fp)
 2016da4:	10803c04 	addi	r2,r2,240
 2016da8:	e1bffc17 	ldw	r6,-16(fp)
 2016dac:	100b883a 	mov	r5,r2
 2016db0:	1809883a 	mov	r4,r3
 2016db4:	20186e80 	call	20186e8 <dhcp_option_trailer>

    result = udp_sendto_if(dhcp_pcb, p_out, &dhcp->server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
 2016db8:	d0e7c417 	ldw	r3,-24816(gp)
 2016dbc:	e0bffb17 	ldw	r2,-20(fp)
 2016dc0:	11000604 	addi	r4,r2,24
 2016dc4:	e0bfff17 	ldw	r2,-4(fp)
 2016dc8:	d8800015 	stw	r2,0(sp)
 2016dcc:	01c010c4 	movi	r7,67
 2016dd0:	200d883a 	mov	r6,r4
 2016dd4:	e17ffc17 	ldw	r5,-16(fp)
 2016dd8:	1809883a 	mov	r4,r3
 2016ddc:	202a1240 	call	202a124 <udp_sendto_if>
 2016de0:	e0bffa05 	stb	r2,-24(fp)
    pbuf_free(p_out);
 2016de4:	e13ffc17 	ldw	r4,-16(fp)
 2016de8:	201d2f40 	call	201d2f4 <pbuf_free>
 2016dec:	00000206 	br	2016df8 <dhcp_renew+0x1b0>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
    result = ERR_MEM;
 2016df0:	00bfffc4 	movi	r2,-1
 2016df4:	e0bffa05 	stb	r2,-24(fp)
  }
  if (dhcp->tries < 255) {
 2016df8:	e0bffb17 	ldw	r2,-20(fp)
 2016dfc:	10800183 	ldbu	r2,6(r2)
 2016e00:	10803fcc 	andi	r2,r2,255
 2016e04:	10803fe0 	cmpeqi	r2,r2,255
 2016e08:	1000061e 	bne	r2,zero,2016e24 <dhcp_renew+0x1dc>
    dhcp->tries++;
 2016e0c:	e0bffb17 	ldw	r2,-20(fp)
 2016e10:	10800183 	ldbu	r2,6(r2)
 2016e14:	10800044 	addi	r2,r2,1
 2016e18:	1007883a 	mov	r3,r2
 2016e1c:	e0bffb17 	ldw	r2,-20(fp)
 2016e20:	10c00185 	stb	r3,6(r2)
  }
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000);
 2016e24:	e0bffb17 	ldw	r2,-20(fp)
 2016e28:	10800183 	ldbu	r2,6(r2)
 2016e2c:	10803fcc 	andi	r2,r2,255
 2016e30:	108002a8 	cmpgeui	r2,r2,10
 2016e34:	1000051e 	bne	r2,zero,2016e4c <dhcp_renew+0x204>
 2016e38:	e0bffb17 	ldw	r2,-20(fp)
 2016e3c:	10800183 	ldbu	r2,6(r2)
 2016e40:	10803fcc 	andi	r2,r2,255
 2016e44:	1081f424 	muli	r2,r2,2000
 2016e48:	00000106 	br	2016e50 <dhcp_renew+0x208>
 2016e4c:	00938804 	movi	r2,20000
 2016e50:	e0bffe0d 	sth	r2,-8(fp)
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 2016e54:	e0bffe0b 	ldhu	r2,-8(fp)
 2016e58:	10807cc4 	addi	r2,r2,499
 2016e5c:	01407d04 	movi	r5,500
 2016e60:	1009883a 	mov	r4,r2
 2016e64:	200a9e40 	call	200a9e4 <__divsi3>
 2016e68:	1007883a 	mov	r3,r2
 2016e6c:	e0bffb17 	ldw	r2,-20(fp)
 2016e70:	10c0020d 	sth	r3,8(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2016e74:	e0bffa03 	ldbu	r2,-24(fp)
}
 2016e78:	e037883a 	mov	sp,fp
 2016e7c:	dfc00117 	ldw	ra,4(sp)
 2016e80:	df000017 	ldw	fp,0(sp)
 2016e84:	dec00204 	addi	sp,sp,8
 2016e88:	f800283a 	ret

02016e8c <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
 2016e8c:	defff704 	addi	sp,sp,-36
 2016e90:	dfc00815 	stw	ra,32(sp)
 2016e94:	df000715 	stw	fp,28(sp)
 2016e98:	df000704 	addi	fp,sp,28
 2016e9c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2016ea0:	e0bfff17 	ldw	r2,-4(fp)
 2016ea4:	10800a17 	ldw	r2,40(r2)
 2016ea8:	e0bffb15 	stw	r2,-20(fp)
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_REBINDING);
 2016eac:	01400104 	movi	r5,4
 2016eb0:	e13ffb17 	ldw	r4,-20(fp)
 2016eb4:	20175e40 	call	20175e4 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
 2016eb8:	e0bffe84 	addi	r2,fp,-6
 2016ebc:	100f883a 	mov	r7,r2
 2016ec0:	018000c4 	movi	r6,3
 2016ec4:	e17ffb17 	ldw	r5,-20(fp)
 2016ec8:	e13fff17 	ldw	r4,-4(fp)
 2016ecc:	20183800 	call	2018380 <dhcp_create_msg>
 2016ed0:	e0bffc15 	stw	r2,-16(fp)
  if (p_out != NULL) {
 2016ed4:	e0bffc17 	ldw	r2,-16(fp)
 2016ed8:	10005426 	beq	r2,zero,201702c <dhcp_rebind+0x1a0>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 2016edc:	e0bffc17 	ldw	r2,-16(fp)
 2016ee0:	10800117 	ldw	r2,4(r2)
 2016ee4:	e0bffd15 	stw	r2,-12(fp)
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 2016ee8:	e0bffe8b 	ldhu	r2,-6(fp)
 2016eec:	10ffffcc 	andi	r3,r2,65535
 2016ef0:	e0bffd17 	ldw	r2,-12(fp)
 2016ef4:	10803c04 	addi	r2,r2,240
 2016ef8:	01c00084 	movi	r7,2
 2016efc:	01800e44 	movi	r6,57
 2016f00:	100b883a 	mov	r5,r2
 2016f04:	1809883a 	mov	r4,r3
 2016f08:	20176400 	call	2017640 <dhcp_option>
 2016f0c:	e0bffe8d 	sth	r2,-6(fp)
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 2016f10:	e0bffe8b 	ldhu	r2,-6(fp)
 2016f14:	10ffffcc 	andi	r3,r2,65535
 2016f18:	e0bffd17 	ldw	r2,-12(fp)
 2016f1c:	11003c04 	addi	r4,r2,240
 2016f20:	e0bfff17 	ldw	r2,-4(fp)
 2016f24:	10800d0b 	ldhu	r2,52(r2)
 2016f28:	10bfffcc 	andi	r2,r2,65535
 2016f2c:	100d883a 	mov	r6,r2
 2016f30:	200b883a 	mov	r5,r4
 2016f34:	1809883a 	mov	r4,r3
 2016f38:	201770c0 	call	201770c <dhcp_option_short>
 2016f3c:	e0bffe8d 	sth	r2,-6(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 2016f40:	e0bffe8b 	ldhu	r2,-6(fp)
 2016f44:	10ffffcc 	andi	r3,r2,65535
 2016f48:	e0bffd17 	ldw	r2,-12(fp)
 2016f4c:	10803c04 	addi	r2,r2,240
 2016f50:	01c000c4 	movi	r7,3
 2016f54:	01800dc4 	movi	r6,55
 2016f58:	100b883a 	mov	r5,r2
 2016f5c:	1809883a 	mov	r4,r3
 2016f60:	20176400 	call	2017640 <dhcp_option>
 2016f64:	e0bffe8d 	sth	r2,-6(fp)
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2016f68:	e03ffa45 	stb	zero,-23(fp)
 2016f6c:	00000f06 	br	2016fac <dhcp_rebind+0x120>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 2016f70:	e0bffe8b 	ldhu	r2,-6(fp)
 2016f74:	113fffcc 	andi	r4,r2,65535
 2016f78:	e0bffd17 	ldw	r2,-12(fp)
 2016f7c:	11403c04 	addi	r5,r2,240
 2016f80:	e0fffa43 	ldbu	r3,-23(fp)
 2016f84:	d0a00c04 	addi	r2,gp,-32720
 2016f88:	1885883a 	add	r2,r3,r2
 2016f8c:	10800003 	ldbu	r2,0(r2)
 2016f90:	10803fcc 	andi	r2,r2,255
 2016f94:	100d883a 	mov	r6,r2
 2016f98:	20176b80 	call	20176b8 <dhcp_option_byte>
 2016f9c:	e0bffe8d 	sth	r2,-6(fp)
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2016fa0:	e0bffa43 	ldbu	r2,-23(fp)
 2016fa4:	10800044 	addi	r2,r2,1
 2016fa8:	e0bffa45 	stb	r2,-23(fp)
 2016fac:	e0bffa43 	ldbu	r2,-23(fp)
 2016fb0:	108000f0 	cmpltui	r2,r2,3
 2016fb4:	103fee1e 	bne	r2,zero,2016f70 <__alt_mem_mem_0+0xfcff6f70>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
    }

#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
 2016fb8:	e0bffe8b 	ldhu	r2,-6(fp)
 2016fbc:	10ffffcc 	andi	r3,r2,65535
 2016fc0:	e0bffd17 	ldw	r2,-12(fp)
 2016fc4:	10803c04 	addi	r2,r2,240
 2016fc8:	e1bfff17 	ldw	r6,-4(fp)
 2016fcc:	100b883a 	mov	r5,r2
 2016fd0:	1809883a 	mov	r4,r3
 2016fd4:	20178480 	call	2017848 <dhcp_option_hostname>
 2016fd8:	e0bffe8d 	sth	r2,-6(fp)
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REBINDING, msg_out, DHCP_DISCOVER, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 2016fdc:	e0bffe8b 	ldhu	r2,-6(fp)
 2016fe0:	10ffffcc 	andi	r3,r2,65535
 2016fe4:	e0bffd17 	ldw	r2,-12(fp)
 2016fe8:	10803c04 	addi	r2,r2,240
 2016fec:	e1bffc17 	ldw	r6,-16(fp)
 2016ff0:	100b883a 	mov	r5,r2
 2016ff4:	1809883a 	mov	r4,r3
 2016ff8:	20186e80 	call	20186e8 <dhcp_option_trailer>

    /* broadcast to server */
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
 2016ffc:	d0e7c417 	ldw	r3,-24816(gp)
 2017000:	e0bfff17 	ldw	r2,-4(fp)
 2017004:	d8800015 	stw	r2,0(sp)
 2017008:	01c010c4 	movi	r7,67
 201700c:	d1a00f04 	addi	r6,gp,-32708
 2017010:	e17ffc17 	ldw	r5,-16(fp)
 2017014:	1809883a 	mov	r4,r3
 2017018:	202a1240 	call	202a124 <udp_sendto_if>
 201701c:	e0bffa05 	stb	r2,-24(fp)
    pbuf_free(p_out);
 2017020:	e13ffc17 	ldw	r4,-16(fp)
 2017024:	201d2f40 	call	201d2f4 <pbuf_free>
 2017028:	00000206 	br	2017034 <dhcp_rebind+0x1a8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
    result = ERR_MEM;
 201702c:	00bfffc4 	movi	r2,-1
 2017030:	e0bffa05 	stb	r2,-24(fp)
  }
  if (dhcp->tries < 255) {
 2017034:	e0bffb17 	ldw	r2,-20(fp)
 2017038:	10800183 	ldbu	r2,6(r2)
 201703c:	10803fcc 	andi	r2,r2,255
 2017040:	10803fe0 	cmpeqi	r2,r2,255
 2017044:	1000061e 	bne	r2,zero,2017060 <dhcp_rebind+0x1d4>
    dhcp->tries++;
 2017048:	e0bffb17 	ldw	r2,-20(fp)
 201704c:	10800183 	ldbu	r2,6(r2)
 2017050:	10800044 	addi	r2,r2,1
 2017054:	1007883a 	mov	r3,r2
 2017058:	e0bffb17 	ldw	r2,-20(fp)
 201705c:	10c00185 	stb	r3,6(r2)
  }
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
 2017060:	e0bffb17 	ldw	r2,-20(fp)
 2017064:	10800183 	ldbu	r2,6(r2)
 2017068:	10803fcc 	andi	r2,r2,255
 201706c:	108002a8 	cmpgeui	r2,r2,10
 2017070:	1000051e 	bne	r2,zero,2017088 <dhcp_rebind+0x1fc>
 2017074:	e0bffb17 	ldw	r2,-20(fp)
 2017078:	10800183 	ldbu	r2,6(r2)
 201707c:	10803fcc 	andi	r2,r2,255
 2017080:	1080fa24 	muli	r2,r2,1000
 2017084:	00000106 	br	201708c <dhcp_rebind+0x200>
 2017088:	0089c404 	movi	r2,10000
 201708c:	e0bffe0d 	sth	r2,-8(fp)
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 2017090:	e0bffe0b 	ldhu	r2,-8(fp)
 2017094:	10807cc4 	addi	r2,r2,499
 2017098:	01407d04 	movi	r5,500
 201709c:	1009883a 	mov	r4,r2
 20170a0:	200a9e40 	call	200a9e4 <__divsi3>
 20170a4:	1007883a 	mov	r3,r2
 20170a8:	e0bffb17 	ldw	r2,-20(fp)
 20170ac:	10c0020d 	sth	r3,8(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 20170b0:	e0bffa03 	ldbu	r2,-24(fp)
}
 20170b4:	e037883a 	mov	sp,fp
 20170b8:	dfc00117 	ldw	ra,4(sp)
 20170bc:	df000017 	ldw	fp,0(sp)
 20170c0:	dec00204 	addi	sp,sp,8
 20170c4:	f800283a 	ret

020170c8 <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
 20170c8:	defff504 	addi	sp,sp,-44
 20170cc:	dfc00a15 	stw	ra,40(sp)
 20170d0:	df000915 	stw	fp,36(sp)
 20170d4:	dc400815 	stw	r17,32(sp)
 20170d8:	dc000715 	stw	r16,28(sp)
 20170dc:	df000904 	addi	fp,sp,36
 20170e0:	e13ffd15 	stw	r4,-12(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 20170e4:	e0bffd17 	ldw	r2,-12(fp)
 20170e8:	10800a17 	ldw	r2,40(r2)
 20170ec:	e0bff915 	stw	r2,-28(fp)
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_REBOOTING);
 20170f0:	014000c4 	movi	r5,3
 20170f4:	e13ff917 	ldw	r4,-28(fp)
 20170f8:	20175e40 	call	20175e4 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
 20170fc:	e0bffc84 	addi	r2,fp,-14
 2017100:	100f883a 	mov	r7,r2
 2017104:	018000c4 	movi	r6,3
 2017108:	e17ff917 	ldw	r5,-28(fp)
 201710c:	e13ffd17 	ldw	r4,-12(fp)
 2017110:	20183800 	call	2018380 <dhcp_create_msg>
 2017114:	e0bffa15 	stw	r2,-24(fp)
  if (p_out != NULL) {
 2017118:	e0bffa17 	ldw	r2,-24(fp)
 201711c:	10006826 	beq	r2,zero,20172c0 <dhcp_reboot+0x1f8>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 2017120:	e0bffa17 	ldw	r2,-24(fp)
 2017124:	10800117 	ldw	r2,4(r2)
 2017128:	e0bffb15 	stw	r2,-20(fp)
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 201712c:	e0bffc8b 	ldhu	r2,-14(fp)
 2017130:	10ffffcc 	andi	r3,r2,65535
 2017134:	e0bffb17 	ldw	r2,-20(fp)
 2017138:	10803c04 	addi	r2,r2,240
 201713c:	01c00084 	movi	r7,2
 2017140:	01800e44 	movi	r6,57
 2017144:	100b883a 	mov	r5,r2
 2017148:	1809883a 	mov	r4,r3
 201714c:	20176400 	call	2017640 <dhcp_option>
 2017150:	e0bffc8d 	sth	r2,-14(fp)
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
 2017154:	e0bffc8b 	ldhu	r2,-14(fp)
 2017158:	10ffffcc 	andi	r3,r2,65535
 201715c:	e0bffb17 	ldw	r2,-20(fp)
 2017160:	10803c04 	addi	r2,r2,240
 2017164:	01809004 	movi	r6,576
 2017168:	100b883a 	mov	r5,r2
 201716c:	1809883a 	mov	r4,r3
 2017170:	201770c0 	call	201770c <dhcp_option_short>
 2017174:	e0bffc8d 	sth	r2,-14(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
 2017178:	e0bffc8b 	ldhu	r2,-14(fp)
 201717c:	10ffffcc 	andi	r3,r2,65535
 2017180:	e0bffb17 	ldw	r2,-20(fp)
 2017184:	10803c04 	addi	r2,r2,240
 2017188:	01c00104 	movi	r7,4
 201718c:	01800c84 	movi	r6,50
 2017190:	100b883a 	mov	r5,r2
 2017194:	1809883a 	mov	r4,r3
 2017198:	20176400 	call	2017640 <dhcp_option>
 201719c:	e0bffc8d 	sth	r2,-14(fp)
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 20171a0:	e0bffc8b 	ldhu	r2,-14(fp)
 20171a4:	143fffcc 	andi	r16,r2,65535
 20171a8:	e0bffb17 	ldw	r2,-20(fp)
 20171ac:	14403c04 	addi	r17,r2,240
 20171b0:	e0bff917 	ldw	r2,-28(fp)
 20171b4:	10800717 	ldw	r2,28(r2)
 20171b8:	1009883a 	mov	r4,r2
 20171bc:	20394b00 	call	20394b0 <lwip_htonl>
 20171c0:	100d883a 	mov	r6,r2
 20171c4:	880b883a 	mov	r5,r17
 20171c8:	8009883a 	mov	r4,r16
 20171cc:	20177840 	call	2017784 <dhcp_option_long>
 20171d0:	e0bffc8d 	sth	r2,-14(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 20171d4:	e0bffc8b 	ldhu	r2,-14(fp)
 20171d8:	10ffffcc 	andi	r3,r2,65535
 20171dc:	e0bffb17 	ldw	r2,-20(fp)
 20171e0:	10803c04 	addi	r2,r2,240
 20171e4:	01c000c4 	movi	r7,3
 20171e8:	01800dc4 	movi	r6,55
 20171ec:	100b883a 	mov	r5,r2
 20171f0:	1809883a 	mov	r4,r3
 20171f4:	20176400 	call	2017640 <dhcp_option>
 20171f8:	e0bffc8d 	sth	r2,-14(fp)
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 20171fc:	e03ff845 	stb	zero,-31(fp)
 2017200:	00000f06 	br	2017240 <dhcp_reboot+0x178>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 2017204:	e0bffc8b 	ldhu	r2,-14(fp)
 2017208:	113fffcc 	andi	r4,r2,65535
 201720c:	e0bffb17 	ldw	r2,-20(fp)
 2017210:	11403c04 	addi	r5,r2,240
 2017214:	e0fff843 	ldbu	r3,-31(fp)
 2017218:	d0a00c04 	addi	r2,gp,-32720
 201721c:	1885883a 	add	r2,r3,r2
 2017220:	10800003 	ldbu	r2,0(r2)
 2017224:	10803fcc 	andi	r2,r2,255
 2017228:	100d883a 	mov	r6,r2
 201722c:	20176b80 	call	20176b8 <dhcp_option_byte>
 2017230:	e0bffc8d 	sth	r2,-14(fp)

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 2017234:	e0bff843 	ldbu	r2,-31(fp)
 2017238:	10800044 	addi	r2,r2,1
 201723c:	e0bff845 	stb	r2,-31(fp)
 2017240:	e0bff843 	ldbu	r2,-31(fp)
 2017244:	108000f0 	cmpltui	r2,r2,3
 2017248:	103fee1e 	bne	r2,zero,2017204 <__alt_mem_mem_0+0xfcff7204>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
    }

#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
 201724c:	e0bffc8b 	ldhu	r2,-14(fp)
 2017250:	10ffffcc 	andi	r3,r2,65535
 2017254:	e0bffb17 	ldw	r2,-20(fp)
 2017258:	10803c04 	addi	r2,r2,240
 201725c:	e1bffd17 	ldw	r6,-12(fp)
 2017260:	100b883a 	mov	r5,r2
 2017264:	1809883a 	mov	r4,r3
 2017268:	20178480 	call	2017848 <dhcp_option_hostname>
 201726c:	e0bffc8d 	sth	r2,-14(fp)
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REBOOTING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 2017270:	e0bffc8b 	ldhu	r2,-14(fp)
 2017274:	10ffffcc 	andi	r3,r2,65535
 2017278:	e0bffb17 	ldw	r2,-20(fp)
 201727c:	10803c04 	addi	r2,r2,240
 2017280:	e1bffa17 	ldw	r6,-24(fp)
 2017284:	100b883a 	mov	r5,r2
 2017288:	1809883a 	mov	r4,r3
 201728c:	20186e80 	call	20186e8 <dhcp_option_trailer>

    /* broadcast to server */
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
 2017290:	d0e7c417 	ldw	r3,-24816(gp)
 2017294:	e0bffd17 	ldw	r2,-12(fp)
 2017298:	d8800015 	stw	r2,0(sp)
 201729c:	01c010c4 	movi	r7,67
 20172a0:	d1a00f04 	addi	r6,gp,-32708
 20172a4:	e17ffa17 	ldw	r5,-24(fp)
 20172a8:	1809883a 	mov	r4,r3
 20172ac:	202a1240 	call	202a124 <udp_sendto_if>
 20172b0:	e0bff805 	stb	r2,-32(fp)
    pbuf_free(p_out);
 20172b4:	e13ffa17 	ldw	r4,-24(fp)
 20172b8:	201d2f40 	call	201d2f4 <pbuf_free>
 20172bc:	00000206 	br	20172c8 <dhcp_reboot+0x200>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
    result = ERR_MEM;
 20172c0:	00bfffc4 	movi	r2,-1
 20172c4:	e0bff805 	stb	r2,-32(fp)
  }
  if (dhcp->tries < 255) {
 20172c8:	e0bff917 	ldw	r2,-28(fp)
 20172cc:	10800183 	ldbu	r2,6(r2)
 20172d0:	10803fcc 	andi	r2,r2,255
 20172d4:	10803fe0 	cmpeqi	r2,r2,255
 20172d8:	1000061e 	bne	r2,zero,20172f4 <dhcp_reboot+0x22c>
    dhcp->tries++;
 20172dc:	e0bff917 	ldw	r2,-28(fp)
 20172e0:	10800183 	ldbu	r2,6(r2)
 20172e4:	10800044 	addi	r2,r2,1
 20172e8:	1007883a 	mov	r3,r2
 20172ec:	e0bff917 	ldw	r2,-28(fp)
 20172f0:	10c00185 	stb	r3,6(r2)
  }
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
 20172f4:	e0bff917 	ldw	r2,-28(fp)
 20172f8:	10800183 	ldbu	r2,6(r2)
 20172fc:	10803fcc 	andi	r2,r2,255
 2017300:	108002a8 	cmpgeui	r2,r2,10
 2017304:	1000051e 	bne	r2,zero,201731c <dhcp_reboot+0x254>
 2017308:	e0bff917 	ldw	r2,-28(fp)
 201730c:	10800183 	ldbu	r2,6(r2)
 2017310:	10803fcc 	andi	r2,r2,255
 2017314:	1080fa24 	muli	r2,r2,1000
 2017318:	00000106 	br	2017320 <dhcp_reboot+0x258>
 201731c:	0089c404 	movi	r2,10000
 2017320:	e0bffc0d 	sth	r2,-16(fp)
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 2017324:	e0bffc0b 	ldhu	r2,-16(fp)
 2017328:	10807cc4 	addi	r2,r2,499
 201732c:	01407d04 	movi	r5,500
 2017330:	1009883a 	mov	r4,r2
 2017334:	200a9e40 	call	200a9e4 <__divsi3>
 2017338:	1007883a 	mov	r3,r2
 201733c:	e0bff917 	ldw	r2,-28(fp)
 2017340:	10c0020d 	sth	r3,8(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2017344:	e0bff803 	ldbu	r2,-32(fp)
}
 2017348:	e6fffe04 	addi	sp,fp,-8
 201734c:	dfc00317 	ldw	ra,12(sp)
 2017350:	df000217 	ldw	fp,8(sp)
 2017354:	dc400117 	ldw	r17,4(sp)
 2017358:	dc000017 	ldw	r16,0(sp)
 201735c:	dec00404 	addi	sp,sp,16
 2017360:	f800283a 	ret

02017364 <dhcp_release_and_stop>:
 *
 * @param netif network interface
 */
void
dhcp_release_and_stop(struct netif *netif)
{
 2017364:	defff504 	addi	sp,sp,-44
 2017368:	dfc00a15 	stw	ra,40(sp)
 201736c:	df000915 	stw	fp,36(sp)
 2017370:	dc400815 	stw	r17,32(sp)
 2017374:	dc000715 	stw	r16,28(sp)
 2017378:	df000904 	addi	fp,sp,36
 201737c:	e13ffd15 	stw	r4,-12(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 2017380:	e0bffd17 	ldw	r2,-12(fp)
 2017384:	10800a17 	ldw	r2,40(r2)
 2017388:	e0bff815 	stw	r2,-32(fp)
  ip_addr_t server_ip_addr;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release_and_stop()\n"));
  if (dhcp == NULL) {
 201738c:	e0bff817 	ldw	r2,-32(fp)
 2017390:	10007026 	beq	r2,zero,2017554 <dhcp_release_and_stop+0x1f0>
    return;
  }

  /* already off? -> nothing to do */
  if (dhcp->state == DHCP_STATE_OFF) {
 2017394:	e0bff817 	ldw	r2,-32(fp)
 2017398:	10800143 	ldbu	r2,5(r2)
 201739c:	10803fcc 	andi	r2,r2,255
 20173a0:	10006e26 	beq	r2,zero,201755c <dhcp_release_and_stop+0x1f8>
    return;
  }

  ip_addr_copy(server_ip_addr, dhcp->server_ip_addr);
 20173a4:	e0bff817 	ldw	r2,-32(fp)
 20173a8:	10800617 	ldw	r2,24(r2)
 20173ac:	e0bffb15 	stw	r2,-20(fp)

  /* clean old DHCP offer */
  ip_addr_set_zero_ip4(&dhcp->server_ip_addr);
 20173b0:	e0bff817 	ldw	r2,-32(fp)
 20173b4:	10000615 	stw	zero,24(r2)
  ip4_addr_set_zero(&dhcp->offered_ip_addr);
 20173b8:	e0bff817 	ldw	r2,-32(fp)
 20173bc:	10000715 	stw	zero,28(r2)
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
 20173c0:	e0bff817 	ldw	r2,-32(fp)
 20173c4:	10000815 	stw	zero,32(r2)
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
 20173c8:	e0bff817 	ldw	r2,-32(fp)
 20173cc:	10000915 	stw	zero,36(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip4_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
 20173d0:	e0bff817 	ldw	r2,-32(fp)
 20173d4:	10000c15 	stw	zero,48(r2)
 20173d8:	e0bff817 	ldw	r2,-32(fp)
 20173dc:	10c00c17 	ldw	r3,48(r2)
 20173e0:	e0bff817 	ldw	r2,-32(fp)
 20173e4:	10c00b15 	stw	r3,44(r2)
 20173e8:	e0bff817 	ldw	r2,-32(fp)
 20173ec:	10c00b17 	ldw	r3,44(r2)
 20173f0:	e0bff817 	ldw	r2,-32(fp)
 20173f4:	10c00a15 	stw	r3,40(r2)
  dhcp->t1_renew_time = dhcp->t2_rebind_time = dhcp->lease_used = dhcp->t0_timeout = 0;
 20173f8:	e0bff817 	ldw	r2,-32(fp)
 20173fc:	1000050d 	sth	zero,20(r2)
 2017400:	e0bff817 	ldw	r2,-32(fp)
 2017404:	10c0050b 	ldhu	r3,20(r2)
 2017408:	e0bff817 	ldw	r2,-32(fp)
 201740c:	10c0048d 	sth	r3,18(r2)
 2017410:	e0bff817 	ldw	r2,-32(fp)
 2017414:	10c0048b 	ldhu	r3,18(r2)
 2017418:	e0bff817 	ldw	r2,-32(fp)
 201741c:	10c0040d 	sth	r3,16(r2)
 2017420:	e0bff817 	ldw	r2,-32(fp)
 2017424:	10c0040b 	ldhu	r3,16(r2)
 2017428:	e0bff817 	ldw	r2,-32(fp)
 201742c:	10c0038d 	sth	r3,14(r2)

  /* send release message when current IP was assigned via DHCP */
  if (dhcp_supplied_address(netif)) {
 2017430:	e13ffd17 	ldw	r4,-12(fp)
 2017434:	201879c0 	call	201879c <dhcp_supplied_address>
 2017438:	10803fcc 	andi	r2,r2,255
 201743c:	10003a26 	beq	r2,zero,2017528 <dhcp_release_and_stop+0x1c4>
    /* create and initialize the DHCP message header */
    struct pbuf *p_out;
    u16_t options_out_len;
    p_out = dhcp_create_msg(netif, dhcp, DHCP_RELEASE, &options_out_len);
 2017440:	e0bffc04 	addi	r2,fp,-16
 2017444:	100f883a 	mov	r7,r2
 2017448:	018001c4 	movi	r6,7
 201744c:	e17ff817 	ldw	r5,-32(fp)
 2017450:	e13ffd17 	ldw	r4,-12(fp)
 2017454:	20183800 	call	2018380 <dhcp_create_msg>
 2017458:	e0bff915 	stw	r2,-28(fp)
    if (p_out != NULL) {
 201745c:	e0bff917 	ldw	r2,-28(fp)
 2017460:	10002c26 	beq	r2,zero,2017514 <dhcp_release_and_stop+0x1b0>
      struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 2017464:	e0bff917 	ldw	r2,-28(fp)
 2017468:	10800117 	ldw	r2,4(r2)
 201746c:	e0bffa15 	stw	r2,-24(fp)
      options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
 2017470:	e0bffc0b 	ldhu	r2,-16(fp)
 2017474:	10ffffcc 	andi	r3,r2,65535
 2017478:	e0bffa17 	ldw	r2,-24(fp)
 201747c:	10803c04 	addi	r2,r2,240
 2017480:	01c00104 	movi	r7,4
 2017484:	01800d84 	movi	r6,54
 2017488:	100b883a 	mov	r5,r2
 201748c:	1809883a 	mov	r4,r3
 2017490:	20176400 	call	2017640 <dhcp_option>
 2017494:	e0bffc0d 	sth	r2,-16(fp)
      options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
 2017498:	e0bffc0b 	ldhu	r2,-16(fp)
 201749c:	143fffcc 	andi	r16,r2,65535
 20174a0:	e0bffa17 	ldw	r2,-24(fp)
 20174a4:	14403c04 	addi	r17,r2,240
 20174a8:	e0bffb17 	ldw	r2,-20(fp)
 20174ac:	1009883a 	mov	r4,r2
 20174b0:	20394b00 	call	20394b0 <lwip_htonl>
 20174b4:	100d883a 	mov	r6,r2
 20174b8:	880b883a 	mov	r5,r17
 20174bc:	8009883a 	mov	r4,r16
 20174c0:	20177840 	call	2017784 <dhcp_option_long>
 20174c4:	e0bffc0d 	sth	r2,-16(fp)

      LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, dhcp->state, msg_out, DHCP_RELEASE, &options_out_len);
      dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 20174c8:	e0bffc0b 	ldhu	r2,-16(fp)
 20174cc:	10ffffcc 	andi	r3,r2,65535
 20174d0:	e0bffa17 	ldw	r2,-24(fp)
 20174d4:	10803c04 	addi	r2,r2,240
 20174d8:	e1bff917 	ldw	r6,-28(fp)
 20174dc:	100b883a 	mov	r5,r2
 20174e0:	1809883a 	mov	r4,r3
 20174e4:	20186e80 	call	20186e8 <dhcp_option_trailer>

      udp_sendto_if(dhcp_pcb, p_out, &server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
 20174e8:	d0e7c417 	ldw	r3,-24816(gp)
 20174ec:	e13ffb04 	addi	r4,fp,-20
 20174f0:	e0bffd17 	ldw	r2,-12(fp)
 20174f4:	d8800015 	stw	r2,0(sp)
 20174f8:	01c010c4 	movi	r7,67
 20174fc:	200d883a 	mov	r6,r4
 2017500:	e17ff917 	ldw	r5,-28(fp)
 2017504:	1809883a 	mov	r4,r3
 2017508:	202a1240 	call	202a124 <udp_sendto_if>
      pbuf_free(p_out);
 201750c:	e13ff917 	ldw	r4,-28(fp)
 2017510:	201d2f40 	call	201d2f4 <pbuf_free>
      /* sending release failed, but that's not a problem since the correct behaviour of dhcp does not rely on release */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
    }

    /* remove IP address from interface (prevents routing from selecting this interface) */
    netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
 2017514:	d1e00e04 	addi	r7,gp,-32712
 2017518:	d1a00e04 	addi	r6,gp,-32712
 201751c:	d1600e04 	addi	r5,gp,-32712
 2017520:	e13ffd17 	ldw	r4,-12(fp)
 2017524:	201bff80 	call	201bff8 <netif_set_addr>
  }

  dhcp_set_state(dhcp, DHCP_STATE_OFF);
 2017528:	000b883a 	mov	r5,zero
 201752c:	e13ff817 	ldw	r4,-32(fp)
 2017530:	20175e40 	call	20175e4 <dhcp_set_state>

  if (dhcp->pcb_allocated != 0) {
 2017534:	e0bff817 	ldw	r2,-32(fp)
 2017538:	10800103 	ldbu	r2,4(r2)
 201753c:	10803fcc 	andi	r2,r2,255
 2017540:	10000726 	beq	r2,zero,2017560 <dhcp_release_and_stop+0x1fc>
    dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
 2017544:	20156400 	call	2015640 <dhcp_dec_pcb_refcount>
    dhcp->pcb_allocated = 0;
 2017548:	e0bff817 	ldw	r2,-32(fp)
 201754c:	10000105 	stb	zero,4(r2)
 2017550:	00000306 	br	2017560 <dhcp_release_and_stop+0x1fc>
  ip_addr_t server_ip_addr;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release_and_stop()\n"));
  if (dhcp == NULL) {
    return;
 2017554:	0001883a 	nop
 2017558:	00000106 	br	2017560 <dhcp_release_and_stop+0x1fc>
  }

  /* already off? -> nothing to do */
  if (dhcp->state == DHCP_STATE_OFF) {
    return;
 201755c:	0001883a 	nop

  if (dhcp->pcb_allocated != 0) {
    dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
    dhcp->pcb_allocated = 0;
  }
}
 2017560:	e6fffe04 	addi	sp,fp,-8
 2017564:	dfc00317 	ldw	ra,12(sp)
 2017568:	df000217 	ldw	fp,8(sp)
 201756c:	dc400117 	ldw	r17,4(sp)
 2017570:	dc000017 	ldw	r16,0(sp)
 2017574:	dec00404 	addi	sp,sp,16
 2017578:	f800283a 	ret

0201757c <dhcp_release>:
 * This function calls dhcp_release_and_stop() internally.
 * @deprecated Use dhcp_release_and_stop() instead.
 */
err_t
dhcp_release(struct netif *netif)
{
 201757c:	defffd04 	addi	sp,sp,-12
 2017580:	dfc00215 	stw	ra,8(sp)
 2017584:	df000115 	stw	fp,4(sp)
 2017588:	df000104 	addi	fp,sp,4
 201758c:	e13fff15 	stw	r4,-4(fp)
  dhcp_release_and_stop(netif);
 2017590:	e13fff17 	ldw	r4,-4(fp)
 2017594:	20173640 	call	2017364 <dhcp_release_and_stop>
  return ERR_OK;
 2017598:	0005883a 	mov	r2,zero
}
 201759c:	e037883a 	mov	sp,fp
 20175a0:	dfc00117 	ldw	ra,4(sp)
 20175a4:	df000017 	ldw	fp,0(sp)
 20175a8:	dec00204 	addi	sp,sp,8
 20175ac:	f800283a 	ret

020175b0 <dhcp_stop>:
 * This function calls dhcp_release_and_stop() internally.
 * @deprecated Use dhcp_release_and_stop() instead.
 */
void
dhcp_stop(struct netif *netif)
{
 20175b0:	defffd04 	addi	sp,sp,-12
 20175b4:	dfc00215 	stw	ra,8(sp)
 20175b8:	df000115 	stw	fp,4(sp)
 20175bc:	df000104 	addi	fp,sp,4
 20175c0:	e13fff15 	stw	r4,-4(fp)
  dhcp_release_and_stop(netif);
 20175c4:	e13fff17 	ldw	r4,-4(fp)
 20175c8:	20173640 	call	2017364 <dhcp_release_and_stop>
}
 20175cc:	0001883a 	nop
 20175d0:	e037883a 	mov	sp,fp
 20175d4:	dfc00117 	ldw	ra,4(sp)
 20175d8:	df000017 	ldw	fp,0(sp)
 20175dc:	dec00204 	addi	sp,sp,8
 20175e0:	f800283a 	ret

020175e4 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
 20175e4:	defffd04 	addi	sp,sp,-12
 20175e8:	df000215 	stw	fp,8(sp)
 20175ec:	df000204 	addi	fp,sp,8
 20175f0:	e13ffe15 	stw	r4,-8(fp)
 20175f4:	2805883a 	mov	r2,r5
 20175f8:	e0bfff05 	stb	r2,-4(fp)
  if (new_state != dhcp->state) {
 20175fc:	e0bffe17 	ldw	r2,-8(fp)
 2017600:	10800143 	ldbu	r2,5(r2)
 2017604:	10c03fcc 	andi	r3,r2,255
 2017608:	e0bfff03 	ldbu	r2,-4(fp)
 201760c:	18800726 	beq	r3,r2,201762c <dhcp_set_state+0x48>
    dhcp->state = new_state;
 2017610:	e0bffe17 	ldw	r2,-8(fp)
 2017614:	e0ffff03 	ldbu	r3,-4(fp)
 2017618:	10c00145 	stb	r3,5(r2)
    dhcp->tries = 0;
 201761c:	e0bffe17 	ldw	r2,-8(fp)
 2017620:	10000185 	stb	zero,6(r2)
    dhcp->request_timeout = 0;
 2017624:	e0bffe17 	ldw	r2,-8(fp)
 2017628:	1000020d 	sth	zero,8(r2)
  }
}
 201762c:	0001883a 	nop
 2017630:	e037883a 	mov	sp,fp
 2017634:	df000017 	ldw	fp,0(sp)
 2017638:	dec00104 	addi	sp,sp,4
 201763c:	f800283a 	ret

02017640 <dhcp_option>:
 * DHCP message.
 *
 */
static u16_t
dhcp_option(u16_t options_out_len, u8_t *options, u8_t option_type, u8_t option_len)
{
 2017640:	defffb04 	addi	sp,sp,-20
 2017644:	df000415 	stw	fp,16(sp)
 2017648:	df000404 	addi	fp,sp,16
 201764c:	e17ffd15 	stw	r5,-12(fp)
 2017650:	3007883a 	mov	r3,r6
 2017654:	3805883a 	mov	r2,r7
 2017658:	e13ffc0d 	sth	r4,-16(fp)
 201765c:	e0fffe05 	stb	r3,-8(fp)
 2017660:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option: options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  options[options_out_len++] = option_type;
 2017664:	e0bffc0b 	ldhu	r2,-16(fp)
 2017668:	10c00044 	addi	r3,r2,1
 201766c:	e0fffc0d 	sth	r3,-16(fp)
 2017670:	10bfffcc 	andi	r2,r2,65535
 2017674:	e0fffd17 	ldw	r3,-12(fp)
 2017678:	1885883a 	add	r2,r3,r2
 201767c:	e0fffe03 	ldbu	r3,-8(fp)
 2017680:	10c00005 	stb	r3,0(r2)
  options[options_out_len++] = option_len;
 2017684:	e0bffc0b 	ldhu	r2,-16(fp)
 2017688:	10c00044 	addi	r3,r2,1
 201768c:	e0fffc0d 	sth	r3,-16(fp)
 2017690:	10bfffcc 	andi	r2,r2,65535
 2017694:	e0fffd17 	ldw	r3,-12(fp)
 2017698:	1885883a 	add	r2,r3,r2
 201769c:	e0ffff03 	ldbu	r3,-4(fp)
 20176a0:	10c00005 	stb	r3,0(r2)
  return options_out_len;
 20176a4:	e0bffc0b 	ldhu	r2,-16(fp)
}
 20176a8:	e037883a 	mov	sp,fp
 20176ac:	df000017 	ldw	fp,0(sp)
 20176b0:	dec00104 	addi	sp,sp,4
 20176b4:	f800283a 	ret

020176b8 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static u16_t
dhcp_option_byte(u16_t options_out_len, u8_t *options, u8_t value)
{
 20176b8:	defffc04 	addi	sp,sp,-16
 20176bc:	df000315 	stw	fp,12(sp)
 20176c0:	df000304 	addi	fp,sp,12
 20176c4:	2007883a 	mov	r3,r4
 20176c8:	e17ffe15 	stw	r5,-8(fp)
 20176cc:	3005883a 	mov	r2,r6
 20176d0:	e0fffd0d 	sth	r3,-12(fp)
 20176d4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_byte: options_out_len < DHCP_OPTIONS_LEN", options_out_len < DHCP_OPTIONS_LEN);
  options[options_out_len++] = value;
 20176d8:	e0bffd0b 	ldhu	r2,-12(fp)
 20176dc:	10c00044 	addi	r3,r2,1
 20176e0:	e0fffd0d 	sth	r3,-12(fp)
 20176e4:	10bfffcc 	andi	r2,r2,65535
 20176e8:	e0fffe17 	ldw	r3,-8(fp)
 20176ec:	1885883a 	add	r2,r3,r2
 20176f0:	e0ffff03 	ldbu	r3,-4(fp)
 20176f4:	10c00005 	stb	r3,0(r2)
  return options_out_len;
 20176f8:	e0bffd0b 	ldhu	r2,-12(fp)
}
 20176fc:	e037883a 	mov	sp,fp
 2017700:	df000017 	ldw	fp,0(sp)
 2017704:	dec00104 	addi	sp,sp,4
 2017708:	f800283a 	ret

0201770c <dhcp_option_short>:

static u16_t
dhcp_option_short(u16_t options_out_len, u8_t *options, u16_t value)
{
 201770c:	defffc04 	addi	sp,sp,-16
 2017710:	df000315 	stw	fp,12(sp)
 2017714:	df000304 	addi	fp,sp,12
 2017718:	2007883a 	mov	r3,r4
 201771c:	e17ffe15 	stw	r5,-8(fp)
 2017720:	3005883a 	mov	r2,r6
 2017724:	e0fffd0d 	sth	r3,-12(fp)
 2017728:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_short: options_out_len + 2 <= DHCP_OPTIONS_LEN", options_out_len + 2U <= DHCP_OPTIONS_LEN);
  options[options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 201772c:	e0bffd0b 	ldhu	r2,-12(fp)
 2017730:	10c00044 	addi	r3,r2,1
 2017734:	e0fffd0d 	sth	r3,-12(fp)
 2017738:	10bfffcc 	andi	r2,r2,65535
 201773c:	e0fffe17 	ldw	r3,-8(fp)
 2017740:	1885883a 	add	r2,r3,r2
 2017744:	e0ffff0b 	ldhu	r3,-4(fp)
 2017748:	1806d23a 	srli	r3,r3,8
 201774c:	10c00005 	stb	r3,0(r2)
  options[options_out_len++] = (u8_t) (value & 0x00ffU);
 2017750:	e0bffd0b 	ldhu	r2,-12(fp)
 2017754:	10c00044 	addi	r3,r2,1
 2017758:	e0fffd0d 	sth	r3,-12(fp)
 201775c:	10bfffcc 	andi	r2,r2,65535
 2017760:	e0fffe17 	ldw	r3,-8(fp)
 2017764:	1885883a 	add	r2,r3,r2
 2017768:	e0ffff0b 	ldhu	r3,-4(fp)
 201776c:	10c00005 	stb	r3,0(r2)
  return options_out_len;
 2017770:	e0bffd0b 	ldhu	r2,-12(fp)
}
 2017774:	e037883a 	mov	sp,fp
 2017778:	df000017 	ldw	fp,0(sp)
 201777c:	dec00104 	addi	sp,sp,4
 2017780:	f800283a 	ret

02017784 <dhcp_option_long>:

static u16_t
dhcp_option_long(u16_t options_out_len, u8_t *options, u32_t value)
{
 2017784:	defffc04 	addi	sp,sp,-16
 2017788:	df000315 	stw	fp,12(sp)
 201778c:	df000304 	addi	fp,sp,12
 2017790:	2005883a 	mov	r2,r4
 2017794:	e17ffe15 	stw	r5,-8(fp)
 2017798:	e1bfff15 	stw	r6,-4(fp)
 201779c:	e0bffd0d 	sth	r2,-12(fp)
  LWIP_ASSERT("dhcp_option_long: options_out_len + 4 <= DHCP_OPTIONS_LEN", options_out_len + 4U <= DHCP_OPTIONS_LEN);
  options[options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 20177a0:	e0bffd0b 	ldhu	r2,-12(fp)
 20177a4:	10c00044 	addi	r3,r2,1
 20177a8:	e0fffd0d 	sth	r3,-12(fp)
 20177ac:	10bfffcc 	andi	r2,r2,65535
 20177b0:	e0fffe17 	ldw	r3,-8(fp)
 20177b4:	1885883a 	add	r2,r3,r2
 20177b8:	e0ffff17 	ldw	r3,-4(fp)
 20177bc:	1806d63a 	srli	r3,r3,24
 20177c0:	10c00005 	stb	r3,0(r2)
  options[options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 20177c4:	e0bffd0b 	ldhu	r2,-12(fp)
 20177c8:	10c00044 	addi	r3,r2,1
 20177cc:	e0fffd0d 	sth	r3,-12(fp)
 20177d0:	10bfffcc 	andi	r2,r2,65535
 20177d4:	e0fffe17 	ldw	r3,-8(fp)
 20177d8:	1885883a 	add	r2,r3,r2
 20177dc:	e0ffff17 	ldw	r3,-4(fp)
 20177e0:	18c03fec 	andhi	r3,r3,255
 20177e4:	1806d43a 	srli	r3,r3,16
 20177e8:	10c00005 	stb	r3,0(r2)
  options[options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 20177ec:	e0bffd0b 	ldhu	r2,-12(fp)
 20177f0:	10c00044 	addi	r3,r2,1
 20177f4:	e0fffd0d 	sth	r3,-12(fp)
 20177f8:	10bfffcc 	andi	r2,r2,65535
 20177fc:	e0fffe17 	ldw	r3,-8(fp)
 2017800:	1885883a 	add	r2,r3,r2
 2017804:	e0ffff17 	ldw	r3,-4(fp)
 2017808:	18ffc00c 	andi	r3,r3,65280
 201780c:	1806d23a 	srli	r3,r3,8
 2017810:	10c00005 	stb	r3,0(r2)
  options[options_out_len++] = (u8_t)((value & 0x000000ffUL));
 2017814:	e0bffd0b 	ldhu	r2,-12(fp)
 2017818:	10c00044 	addi	r3,r2,1
 201781c:	e0fffd0d 	sth	r3,-12(fp)
 2017820:	10bfffcc 	andi	r2,r2,65535
 2017824:	e0fffe17 	ldw	r3,-8(fp)
 2017828:	1885883a 	add	r2,r3,r2
 201782c:	e0ffff17 	ldw	r3,-4(fp)
 2017830:	10c00005 	stb	r3,0(r2)
  return options_out_len;
 2017834:	e0bffd0b 	ldhu	r2,-12(fp)
}
 2017838:	e037883a 	mov	sp,fp
 201783c:	df000017 	ldw	fp,0(sp)
 2017840:	dec00104 	addi	sp,sp,4
 2017844:	f800283a 	ret

02017848 <dhcp_option_hostname>:

#if LWIP_NETIF_HOSTNAME
static u16_t
dhcp_option_hostname(u16_t options_out_len, u8_t *options, struct netif *netif)
{
 2017848:	defff704 	addi	sp,sp,-36
 201784c:	dfc00815 	stw	ra,32(sp)
 2017850:	df000715 	stw	fp,28(sp)
 2017854:	df000704 	addi	fp,sp,28
 2017858:	2005883a 	mov	r2,r4
 201785c:	e17ffe15 	stw	r5,-8(fp)
 2017860:	e1bfff15 	stw	r6,-4(fp)
 2017864:	e0bffd0d 	sth	r2,-12(fp)
  if (netif->hostname != NULL) {
 2017868:	e0bfff17 	ldw	r2,-4(fp)
 201786c:	10800c17 	ldw	r2,48(r2)
 2017870:	10002b26 	beq	r2,zero,2017920 <dhcp_option_hostname+0xd8>
    size_t namelen = strlen(netif->hostname);
 2017874:	e0bfff17 	ldw	r2,-4(fp)
 2017878:	10800c17 	ldw	r2,48(r2)
 201787c:	1009883a 	mov	r4,r2
 2017880:	20073a40 	call	20073a4 <strlen>
 2017884:	e0bffb15 	stw	r2,-20(fp)
    if (namelen > 0) {
 2017888:	e0bffb17 	ldw	r2,-20(fp)
 201788c:	10002426 	beq	r2,zero,2017920 <dhcp_option_hostname+0xd8>
      size_t len;
      const char *p = netif->hostname;
 2017890:	e0bfff17 	ldw	r2,-4(fp)
 2017894:	10800c17 	ldw	r2,48(r2)
 2017898:	e0bffa15 	stw	r2,-24(fp)
      /* Shrink len to available bytes (need 2 bytes for OPTION_HOSTNAME
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - options_out_len - 3;
 201789c:	e0bffd0b 	ldhu	r2,-12(fp)
 20178a0:	00c01044 	movi	r3,65
 20178a4:	1885c83a 	sub	r2,r3,r2
 20178a8:	e0bffc15 	stw	r2,-16(fp)
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
      len = LWIP_MIN(namelen, available);
 20178ac:	e0fffb17 	ldw	r3,-20(fp)
 20178b0:	e0bffc17 	ldw	r2,-16(fp)
 20178b4:	1880012e 	bgeu	r3,r2,20178bc <dhcp_option_hostname+0x74>
 20178b8:	1805883a 	mov	r2,r3
 20178bc:	e0bff915 	stw	r2,-28(fp)
      LWIP_ASSERT("DHCP: hostname is too long!", len <= 0xFF);
      options_out_len = dhcp_option(options_out_len, options, DHCP_OPTION_HOSTNAME, (u8_t)len);
 20178c0:	e0fffd0b 	ldhu	r3,-12(fp)
 20178c4:	e0bff917 	ldw	r2,-28(fp)
 20178c8:	10803fcc 	andi	r2,r2,255
 20178cc:	100f883a 	mov	r7,r2
 20178d0:	01800304 	movi	r6,12
 20178d4:	e17ffe17 	ldw	r5,-8(fp)
 20178d8:	1809883a 	mov	r4,r3
 20178dc:	20176400 	call	2017640 <dhcp_option>
 20178e0:	e0bffd0d 	sth	r2,-12(fp)
      while (len--) {
 20178e4:	00000a06 	br	2017910 <dhcp_option_hostname+0xc8>
        options_out_len = dhcp_option_byte(options_out_len, options, *p++);
 20178e8:	e13ffd0b 	ldhu	r4,-12(fp)
 20178ec:	e0bffa17 	ldw	r2,-24(fp)
 20178f0:	10c00044 	addi	r3,r2,1
 20178f4:	e0fffa15 	stw	r3,-24(fp)
 20178f8:	10800003 	ldbu	r2,0(r2)
 20178fc:	10803fcc 	andi	r2,r2,255
 2017900:	100d883a 	mov	r6,r2
 2017904:	e17ffe17 	ldw	r5,-8(fp)
 2017908:	20176b80 	call	20176b8 <dhcp_option_byte>
 201790c:	e0bffd0d 	sth	r2,-12(fp)
      size_t available = DHCP_OPTIONS_LEN - options_out_len - 3;
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
      len = LWIP_MIN(namelen, available);
      LWIP_ASSERT("DHCP: hostname is too long!", len <= 0xFF);
      options_out_len = dhcp_option(options_out_len, options, DHCP_OPTION_HOSTNAME, (u8_t)len);
      while (len--) {
 2017910:	e0bff917 	ldw	r2,-28(fp)
 2017914:	10ffffc4 	addi	r3,r2,-1
 2017918:	e0fff915 	stw	r3,-28(fp)
 201791c:	103ff21e 	bne	r2,zero,20178e8 <__alt_mem_mem_0+0xfcff78e8>
        options_out_len = dhcp_option_byte(options_out_len, options, *p++);
      }
    }
  }
  return options_out_len;
 2017920:	e0bffd0b 	ldhu	r2,-12(fp)
}
 2017924:	e037883a 	mov	sp,fp
 2017928:	dfc00117 	ldw	ra,4(sp)
 201792c:	df000017 	ldw	fp,0(sp)
 2017930:	dec00204 	addi	sp,sp,8
 2017934:	f800283a 	ret

02017938 <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct pbuf *p, struct dhcp *dhcp)
{
 2017938:	deffee04 	addi	sp,sp,-72
 201793c:	dfc01115 	stw	ra,68(sp)
 2017940:	df001015 	stw	fp,64(sp)
 2017944:	df001004 	addi	fp,sp,64
 2017948:	e13ffe15 	stw	r4,-8(fp)
 201794c:	e17fff15 	stw	r5,-4(fp)
  u16_t offset_max;
  u16_t options_offset;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
 2017950:	e03ff415 	stw	zero,-48(fp)
  int parse_sname_as_options = 0;
 2017954:	e03ff515 	stw	zero,-44(fp)
#endif

  LWIP_UNUSED_ARG(dhcp);

  /* clear received options */
  dhcp_clear_all_options(dhcp);
 2017958:	01800204 	movi	r6,8
 201795c:	000b883a 	mov	r5,zero
 2017960:	d127c544 	addi	r4,gp,-24811
 2017964:	2005fa00 	call	2005fa0 <memset>
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
 2017968:	e0bffe17 	ldw	r2,-8(fp)
 201796c:	1080028b 	ldhu	r2,10(r2)
 2017970:	10bfffcc 	andi	r2,r2,65535
 2017974:	10800b28 	cmpgeui	r2,r2,44
 2017978:	1000021e 	bne	r2,zero,2017984 <dhcp_parse_reply+0x4c>
    return ERR_BUF;
 201797c:	00bfff84 	movi	r2,-2
 2017980:	0001b606 	br	201805c <dhcp_parse_reply+0x724>
  }
  msg_in = (struct dhcp_msg *)p->payload;
 2017984:	e0bffe17 	ldw	r2,-8(fp)
 2017988:	10800117 	ldw	r2,4(r2)
 201798c:	e0bff915 	stw	r2,-28(fp)
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
 2017990:	00803c04 	movi	r2,240
 2017994:	e0bff20d 	sth	r2,-56(fp)
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
 2017998:	e0bffe17 	ldw	r2,-8(fp)
 201799c:	1080020b 	ldhu	r2,8(r2)
 20179a0:	e0bff28d 	sth	r2,-54(fp)
again:
  q = p;
 20179a4:	e0bffe17 	ldw	r2,-8(fp)
 20179a8:	e0bff315 	stw	r2,-52(fp)
  options_offset = options_idx;
 20179ac:	e0bff20b 	ldhu	r2,-56(fp)
 20179b0:	e0bffa0d 	sth	r2,-24(fp)
  while ((q != NULL) && (options_idx >= q->len)) {
 20179b4:	00000d06 	br	20179ec <dhcp_parse_reply+0xb4>
    options_idx = (u16_t)(options_idx - q->len);
 20179b8:	e0bff317 	ldw	r2,-52(fp)
 20179bc:	1080028b 	ldhu	r2,10(r2)
 20179c0:	e0fff20b 	ldhu	r3,-56(fp)
 20179c4:	1885c83a 	sub	r2,r3,r2
 20179c8:	e0bff20d 	sth	r2,-56(fp)
    options_idx_max = (u16_t)(options_idx_max - q->len);
 20179cc:	e0bff317 	ldw	r2,-52(fp)
 20179d0:	1080028b 	ldhu	r2,10(r2)
 20179d4:	e0fff28b 	ldhu	r3,-54(fp)
 20179d8:	1885c83a 	sub	r2,r3,r2
 20179dc:	e0bff28d 	sth	r2,-54(fp)
    q = q->next;
 20179e0:	e0bff317 	ldw	r2,-52(fp)
 20179e4:	10800017 	ldw	r2,0(r2)
 20179e8:	e0bff315 	stw	r2,-52(fp)
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  options_offset = options_idx;
  while ((q != NULL) && (options_idx >= q->len)) {
 20179ec:	e0bff317 	ldw	r2,-52(fp)
 20179f0:	10000526 	beq	r2,zero,2017a08 <dhcp_parse_reply+0xd0>
 20179f4:	e0bff317 	ldw	r2,-52(fp)
 20179f8:	1080028b 	ldhu	r2,10(r2)
 20179fc:	10bfffcc 	andi	r2,r2,65535
 2017a00:	e0fff20b 	ldhu	r3,-56(fp)
 2017a04:	18bfec2e 	bgeu	r3,r2,20179b8 <__alt_mem_mem_0+0xfcff79b8>
    options_idx = (u16_t)(options_idx - q->len);
    options_idx_max = (u16_t)(options_idx_max - q->len);
    q = q->next;
  }
  if (q == NULL) {
 2017a08:	e0bff317 	ldw	r2,-52(fp)
 2017a0c:	1000021e 	bne	r2,zero,2017a18 <dhcp_parse_reply+0xe0>
    return ERR_BUF;
 2017a10:	00bfff84 	movi	r2,-2
 2017a14:	00019106 	br	201805c <dhcp_parse_reply+0x724>
  }
  offset = options_idx;
 2017a18:	e0bff20b 	ldhu	r2,-56(fp)
 2017a1c:	e0bff10d 	sth	r2,-60(fp)
  offset_max = options_idx_max;
 2017a20:	e0bff28b 	ldhu	r2,-54(fp)
 2017a24:	e0bff18d 	sth	r2,-58(fp)
  options = (u8_t *)q->payload;
 2017a28:	e0bff317 	ldw	r2,-52(fp)
 2017a2c:	10800117 	ldw	r2,4(r2)
 2017a30:	e0bff015 	stw	r2,-64(fp)
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
 2017a34:	00015106 	br	2017f7c <dhcp_parse_reply+0x644>
    u8_t op = options[offset];
 2017a38:	e0bff10b 	ldhu	r2,-60(fp)
 2017a3c:	e0fff017 	ldw	r3,-64(fp)
 2017a40:	1885883a 	add	r2,r3,r2
 2017a44:	10800003 	ldbu	r2,0(r2)
 2017a48:	e0bffa85 	stb	r2,-22(fp)
    u8_t len;
    u8_t decode_len = 0;
 2017a4c:	e03ff645 	stb	zero,-39(fp)
    int decode_idx = -1;
 2017a50:	00bfffc4 	movi	r2,-1
 2017a54:	e0bff715 	stw	r2,-36(fp)
    u16_t val_offset = (u16_t)(offset + 2);
 2017a58:	e0bff10b 	ldhu	r2,-60(fp)
 2017a5c:	10800084 	addi	r2,r2,2
 2017a60:	e0bff80d 	sth	r2,-32(fp)
    if (val_offset < offset) {
 2017a64:	e0fff80b 	ldhu	r3,-32(fp)
 2017a68:	e0bff10b 	ldhu	r2,-60(fp)
 2017a6c:	1880022e 	bgeu	r3,r2,2017a78 <dhcp_parse_reply+0x140>
      /* overflow */
      return ERR_BUF;
 2017a70:	00bfff84 	movi	r2,-2
 2017a74:	00017906 	br	201805c <dhcp_parse_reply+0x724>
    }
    /* len byte might be in the next pbuf */
    if ((offset + 1) < q->len) {
 2017a78:	e0bff10b 	ldhu	r2,-60(fp)
 2017a7c:	10c00044 	addi	r3,r2,1
 2017a80:	e0bff317 	ldw	r2,-52(fp)
 2017a84:	1080028b 	ldhu	r2,10(r2)
 2017a88:	10bfffcc 	andi	r2,r2,65535
 2017a8c:	1880070e 	bge	r3,r2,2017aac <dhcp_parse_reply+0x174>
      len = options[offset + 1];
 2017a90:	e0bff10b 	ldhu	r2,-60(fp)
 2017a94:	10800044 	addi	r2,r2,1
 2017a98:	e0fff017 	ldw	r3,-64(fp)
 2017a9c:	1885883a 	add	r2,r3,r2
 2017aa0:	10800003 	ldbu	r2,0(r2)
 2017aa4:	e0bff605 	stb	r2,-40(fp)
 2017aa8:	00000a06 	br	2017ad4 <dhcp_parse_reply+0x19c>
    } else {
      len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
 2017aac:	e0bff317 	ldw	r2,-52(fp)
 2017ab0:	10800017 	ldw	r2,0(r2)
 2017ab4:	10000526 	beq	r2,zero,2017acc <dhcp_parse_reply+0x194>
 2017ab8:	e0bff317 	ldw	r2,-52(fp)
 2017abc:	10800017 	ldw	r2,0(r2)
 2017ac0:	10800117 	ldw	r2,4(r2)
 2017ac4:	10800003 	ldbu	r2,0(r2)
 2017ac8:	00000106 	br	2017ad0 <dhcp_parse_reply+0x198>
 2017acc:	0005883a 	mov	r2,zero
 2017ad0:	e0bff605 	stb	r2,-40(fp)
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
 2017ad4:	e0bff603 	ldbu	r2,-40(fp)
 2017ad8:	e0bff645 	stb	r2,-39(fp)
    switch (op) {
 2017adc:	e0bffa83 	ldbu	r2,-22(fp)
 2017ae0:	10c00f28 	cmpgeui	r3,r2,60
 2017ae4:	18008c1e 	bne	r3,zero,2017d18 <dhcp_parse_reply+0x3e0>
 2017ae8:	100690ba 	slli	r3,r2,2
 2017aec:	00808074 	movhi	r2,513
 2017af0:	109ec004 	addi	r2,r2,31488
 2017af4:	1885883a 	add	r2,r3,r2
 2017af8:	10800017 	ldw	r2,0(r2)
 2017afc:	1000683a 	jmp	r2
 2017b00:	02017bf0 	cmpltui	r8,zero,1519
 2017b04:	02017c00 	call	2017c0 <__alt_mem_sdram_controller_0-0x1dfe840>
 2017b08:	02017d18 	cmpnei	r8,zero,1524
 2017b0c:	02017c20 	cmpeqi	r8,zero,1520
 2017b10:	02017d18 	cmpnei	r8,zero,1524
 2017b14:	02017d18 	cmpnei	r8,zero,1524
 2017b18:	02017d18 	cmpnei	r8,zero,1524
 2017b1c:	02017d18 	cmpnei	r8,zero,1524
 2017b20:	02017d18 	cmpnei	r8,zero,1524
 2017b24:	02017d18 	cmpnei	r8,zero,1524
 2017b28:	02017d18 	cmpnei	r8,zero,1524
 2017b2c:	02017d18 	cmpnei	r8,zero,1524
 2017b30:	02017d18 	cmpnei	r8,zero,1524
 2017b34:	02017d18 	cmpnei	r8,zero,1524
 2017b38:	02017d18 	cmpnei	r8,zero,1524
 2017b3c:	02017d18 	cmpnei	r8,zero,1524
 2017b40:	02017d18 	cmpnei	r8,zero,1524
 2017b44:	02017d18 	cmpnei	r8,zero,1524
 2017b48:	02017d18 	cmpnei	r8,zero,1524
 2017b4c:	02017d18 	cmpnei	r8,zero,1524
 2017b50:	02017d18 	cmpnei	r8,zero,1524
 2017b54:	02017d18 	cmpnei	r8,zero,1524
 2017b58:	02017d18 	cmpnei	r8,zero,1524
 2017b5c:	02017d18 	cmpnei	r8,zero,1524
 2017b60:	02017d18 	cmpnei	r8,zero,1524
 2017b64:	02017d18 	cmpnei	r8,zero,1524
 2017b68:	02017d18 	cmpnei	r8,zero,1524
 2017b6c:	02017d18 	cmpnei	r8,zero,1524
 2017b70:	02017d18 	cmpnei	r8,zero,1524
 2017b74:	02017d18 	cmpnei	r8,zero,1524
 2017b78:	02017d18 	cmpnei	r8,zero,1524
 2017b7c:	02017d18 	cmpnei	r8,zero,1524
 2017b80:	02017d18 	cmpnei	r8,zero,1524
 2017b84:	02017d18 	cmpnei	r8,zero,1524
 2017b88:	02017d18 	cmpnei	r8,zero,1524
 2017b8c:	02017d18 	cmpnei	r8,zero,1524
 2017b90:	02017d18 	cmpnei	r8,zero,1524
 2017b94:	02017d18 	cmpnei	r8,zero,1524
 2017b98:	02017d18 	cmpnei	r8,zero,1524
 2017b9c:	02017d18 	cmpnei	r8,zero,1524
 2017ba0:	02017d18 	cmpnei	r8,zero,1524
 2017ba4:	02017d18 	cmpnei	r8,zero,1524
 2017ba8:	02017d18 	cmpnei	r8,zero,1524
 2017bac:	02017d18 	cmpnei	r8,zero,1524
 2017bb0:	02017d18 	cmpnei	r8,zero,1524
 2017bb4:	02017d18 	cmpnei	r8,zero,1524
 2017bb8:	02017d18 	cmpnei	r8,zero,1524
 2017bbc:	02017d18 	cmpnei	r8,zero,1524
 2017bc0:	02017d18 	cmpnei	r8,zero,1524
 2017bc4:	02017d18 	cmpnei	r8,zero,1524
 2017bc8:	02017d18 	cmpnei	r8,zero,1524
 2017bcc:	02017c48 	cmpgei	r8,zero,1521
 2017bd0:	02017c68 	cmpgeui	r8,zero,1521
 2017bd4:	02017c98 	cmpnei	r8,zero,1522
 2017bd8:	02017cb8 	rdprs	r8,zero,1522
 2017bdc:	02017d18 	cmpnei	r8,zero,1524
 2017be0:	02017d18 	cmpnei	r8,zero,1524
 2017be4:	02017d18 	cmpnei	r8,zero,1524
 2017be8:	02017cd8 	cmpnei	r8,zero,1523
 2017bec:	02017cf8 	rdprs	r8,zero,1523
      /* case(DHCP_OPTION_END): handled above */
      case (DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
 2017bf0:	e03ff605 	stb	zero,-40(fp)
 2017bf4:	e0bff603 	ldbu	r2,-40(fp)
 2017bf8:	e0bff645 	stb	r2,-39(fp)
        /* will be increased below */
        break;
 2017bfc:	00004806 	br	2017d20 <dhcp_parse_reply+0x3e8>
      case (DHCP_OPTION_SUBNET_MASK):
        LWIP_DHCP_INPUT_ERROR("len == 4", len == 4, return ERR_VAL;);
 2017c00:	e0bff603 	ldbu	r2,-40(fp)
 2017c04:	10800120 	cmpeqi	r2,r2,4
 2017c08:	1000021e 	bne	r2,zero,2017c14 <dhcp_parse_reply+0x2dc>
 2017c0c:	00bffe84 	movi	r2,-6
 2017c10:	00011206 	br	201805c <dhcp_parse_reply+0x724>
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
 2017c14:	00800184 	movi	r2,6
 2017c18:	e0bff715 	stw	r2,-36(fp)
        break;
 2017c1c:	00004006 	br	2017d20 <dhcp_parse_reply+0x3e8>
      case (DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
 2017c20:	00800104 	movi	r2,4
 2017c24:	e0bff645 	stb	r2,-39(fp)
        LWIP_DHCP_INPUT_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 2017c28:	e0fff603 	ldbu	r3,-40(fp)
 2017c2c:	e0bff643 	ldbu	r2,-39(fp)
 2017c30:	1880022e 	bgeu	r3,r2,2017c3c <dhcp_parse_reply+0x304>
 2017c34:	00bffe84 	movi	r2,-6
 2017c38:	00010806 	br	201805c <dhcp_parse_reply+0x724>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
 2017c3c:	008001c4 	movi	r2,7
 2017c40:	e0bff715 	stw	r2,-36(fp)
        break;
 2017c44:	00003606 	br	2017d20 <dhcp_parse_reply+0x3e8>
        LWIP_DHCP_INPUT_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
        break;
#endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
      case (DHCP_OPTION_LEASE_TIME):
        LWIP_DHCP_INPUT_ERROR("len == 4", len == 4, return ERR_VAL;);
 2017c48:	e0bff603 	ldbu	r2,-40(fp)
 2017c4c:	10800120 	cmpeqi	r2,r2,4
 2017c50:	1000021e 	bne	r2,zero,2017c5c <dhcp_parse_reply+0x324>
 2017c54:	00bffe84 	movi	r2,-6
 2017c58:	00010006 	br	201805c <dhcp_parse_reply+0x724>
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
 2017c5c:	008000c4 	movi	r2,3
 2017c60:	e0bff715 	stw	r2,-36(fp)
        break;
 2017c64:	00002e06 	br	2017d20 <dhcp_parse_reply+0x3e8>
        LWIP_DHCP_INPUT_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_NTP_SERVER;
        break;
#endif /* LWIP_DHCP_GET_NTP_SRV*/
      case (DHCP_OPTION_OVERLOAD):
        LWIP_DHCP_INPUT_ERROR("len == 1", len == 1, return ERR_VAL;);
 2017c68:	e0bff603 	ldbu	r2,-40(fp)
 2017c6c:	10800060 	cmpeqi	r2,r2,1
 2017c70:	1000021e 	bne	r2,zero,2017c7c <dhcp_parse_reply+0x344>
 2017c74:	00bffe84 	movi	r2,-6
 2017c78:	0000f806 	br	201805c <dhcp_parse_reply+0x724>
        /* decode overload only in options, not in file/sname: invalid packet */
        LWIP_DHCP_INPUT_ERROR("overload in file/sname", options_offset == DHCP_OPTIONS_OFS, return ERR_VAL;);
 2017c7c:	e0bffa0b 	ldhu	r2,-24(fp)
 2017c80:	10803c20 	cmpeqi	r2,r2,240
 2017c84:	1000021e 	bne	r2,zero,2017c90 <dhcp_parse_reply+0x358>
 2017c88:	00bffe84 	movi	r2,-6
 2017c8c:	0000f306 	br	201805c <dhcp_parse_reply+0x724>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
 2017c90:	e03ff715 	stw	zero,-36(fp)
        break;
 2017c94:	00002206 	br	2017d20 <dhcp_parse_reply+0x3e8>
      case (DHCP_OPTION_MESSAGE_TYPE):
        LWIP_DHCP_INPUT_ERROR("len == 1", len == 1, return ERR_VAL;);
 2017c98:	e0bff603 	ldbu	r2,-40(fp)
 2017c9c:	10800060 	cmpeqi	r2,r2,1
 2017ca0:	1000021e 	bne	r2,zero,2017cac <dhcp_parse_reply+0x374>
 2017ca4:	00bffe84 	movi	r2,-6
 2017ca8:	0000ec06 	br	201805c <dhcp_parse_reply+0x724>
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
 2017cac:	00800044 	movi	r2,1
 2017cb0:	e0bff715 	stw	r2,-36(fp)
        break;
 2017cb4:	00001a06 	br	2017d20 <dhcp_parse_reply+0x3e8>
      case (DHCP_OPTION_SERVER_ID):
        LWIP_DHCP_INPUT_ERROR("len == 4", len == 4, return ERR_VAL;);
 2017cb8:	e0bff603 	ldbu	r2,-40(fp)
 2017cbc:	10800120 	cmpeqi	r2,r2,4
 2017cc0:	1000021e 	bne	r2,zero,2017ccc <dhcp_parse_reply+0x394>
 2017cc4:	00bffe84 	movi	r2,-6
 2017cc8:	0000e406 	br	201805c <dhcp_parse_reply+0x724>
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
 2017ccc:	00800084 	movi	r2,2
 2017cd0:	e0bff715 	stw	r2,-36(fp)
        break;
 2017cd4:	00001206 	br	2017d20 <dhcp_parse_reply+0x3e8>
      case (DHCP_OPTION_T1):
        LWIP_DHCP_INPUT_ERROR("len == 4", len == 4, return ERR_VAL;);
 2017cd8:	e0bff603 	ldbu	r2,-40(fp)
 2017cdc:	10800120 	cmpeqi	r2,r2,4
 2017ce0:	1000021e 	bne	r2,zero,2017cec <dhcp_parse_reply+0x3b4>
 2017ce4:	00bffe84 	movi	r2,-6
 2017ce8:	0000dc06 	br	201805c <dhcp_parse_reply+0x724>
        decode_idx = DHCP_OPTION_IDX_T1;
 2017cec:	00800104 	movi	r2,4
 2017cf0:	e0bff715 	stw	r2,-36(fp)
        break;
 2017cf4:	00000a06 	br	2017d20 <dhcp_parse_reply+0x3e8>
      case (DHCP_OPTION_T2):
        LWIP_DHCP_INPUT_ERROR("len == 4", len == 4, return ERR_VAL;);
 2017cf8:	e0bff603 	ldbu	r2,-40(fp)
 2017cfc:	10800120 	cmpeqi	r2,r2,4
 2017d00:	1000021e 	bne	r2,zero,2017d0c <dhcp_parse_reply+0x3d4>
 2017d04:	00bffe84 	movi	r2,-6
 2017d08:	0000d406 	br	201805c <dhcp_parse_reply+0x724>
        decode_idx = DHCP_OPTION_IDX_T2;
 2017d0c:	00800144 	movi	r2,5
 2017d10:	e0bff715 	stw	r2,-36(fp)
        break;
 2017d14:	00000206 	br	2017d20 <dhcp_parse_reply+0x3e8>
      default:
        decode_len = 0;
 2017d18:	e03ff645 	stb	zero,-39(fp)
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", (u16_t)op));
        LWIP_HOOK_DHCP_PARSE_OPTION(ip_current_netif(), dhcp, dhcp->state, msg_in,
                                    dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE) ? (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE) : 0,
                                    op, len, q, val_offset);
        break;
 2017d1c:	0001883a 	nop
    }
    if (op == DHCP_OPTION_PAD) {
 2017d20:	e0bffa83 	ldbu	r2,-22(fp)
 2017d24:	1000041e 	bne	r2,zero,2017d38 <dhcp_parse_reply+0x400>
      offset++;
 2017d28:	e0bff10b 	ldhu	r2,-60(fp)
 2017d2c:	10800044 	addi	r2,r2,1
 2017d30:	e0bff10d 	sth	r2,-60(fp)
 2017d34:	00007206 	br	2017f00 <dhcp_parse_reply+0x5c8>
    } else {
      if (offset + len + 2 > 0xFFFF) {
 2017d38:	e0fff10b 	ldhu	r3,-60(fp)
 2017d3c:	e0bff603 	ldbu	r2,-40(fp)
 2017d40:	1885883a 	add	r2,r3,r2
 2017d44:	10800084 	addi	r2,r2,2
 2017d48:	00ffffd4 	movui	r3,65535
 2017d4c:	1880020e 	bge	r3,r2,2017d58 <dhcp_parse_reply+0x420>
        /* overflow */
        return ERR_BUF;
 2017d50:	00bfff84 	movi	r2,-2
 2017d54:	0000c106 	br	201805c <dhcp_parse_reply+0x724>
      }
      offset = (u16_t)(offset + len + 2);
 2017d58:	e0fff603 	ldbu	r3,-40(fp)
 2017d5c:	e0bff10b 	ldhu	r2,-60(fp)
 2017d60:	1885883a 	add	r2,r3,r2
 2017d64:	10800084 	addi	r2,r2,2
 2017d68:	e0bff10d 	sth	r2,-60(fp)
      if (decode_len > 0) {
 2017d6c:	e0bff643 	ldbu	r2,-39(fp)
 2017d70:	10006326 	beq	r2,zero,2017f00 <dhcp_parse_reply+0x5c8>
        u32_t value = 0;
 2017d74:	e03ffd15 	stw	zero,-12(fp)
        u16_t copy_len;
decode_next:
        LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
        if (!dhcp_option_given(dhcp, decode_idx)) {
 2017d78:	e0fff717 	ldw	r3,-36(fp)
 2017d7c:	d0a7c544 	addi	r2,gp,-24811
 2017d80:	1885883a 	add	r2,r3,r2
 2017d84:	10800003 	ldbu	r2,0(r2)
 2017d88:	10803fcc 	andi	r2,r2,255
 2017d8c:	10005c1e 	bne	r2,zero,2017f00 <dhcp_parse_reply+0x5c8>
          copy_len = LWIP_MIN(decode_len, 4);
 2017d90:	e0bff643 	ldbu	r2,-39(fp)
 2017d94:	10800128 	cmpgeui	r2,r2,4
 2017d98:	1000021e 	bne	r2,zero,2017da4 <dhcp_parse_reply+0x46c>
 2017d9c:	e0bff643 	ldbu	r2,-39(fp)
 2017da0:	00000106 	br	2017da8 <dhcp_parse_reply+0x470>
 2017da4:	00800104 	movi	r2,4
 2017da8:	e0bffb0d 	sth	r2,-20(fp)
          if (pbuf_copy_partial(q, &value, copy_len, val_offset) != copy_len) {
 2017dac:	e0fffb0b 	ldhu	r3,-20(fp)
 2017db0:	e13ff80b 	ldhu	r4,-32(fp)
 2017db4:	e0bffd04 	addi	r2,fp,-12
 2017db8:	200f883a 	mov	r7,r4
 2017dbc:	180d883a 	mov	r6,r3
 2017dc0:	100b883a 	mov	r5,r2
 2017dc4:	e13ff317 	ldw	r4,-52(fp)
 2017dc8:	201d8500 	call	201d850 <pbuf_copy_partial>
 2017dcc:	10ffffcc 	andi	r3,r2,65535
 2017dd0:	e0bffb0b 	ldhu	r2,-20(fp)
 2017dd4:	18800226 	beq	r3,r2,2017de0 <dhcp_parse_reply+0x4a8>
            return ERR_BUF;
 2017dd8:	00bfff84 	movi	r2,-2
 2017ddc:	00009f06 	br	201805c <dhcp_parse_reply+0x724>
          }
          if (decode_len > 4) {
 2017de0:	e0bff643 	ldbu	r2,-39(fp)
 2017de4:	10800170 	cmpltui	r2,r2,5
 2017de8:	1000271e 	bne	r2,zero,2017e88 <dhcp_parse_reply+0x550>
            /* decode more than one u32_t */
            u16_t next_val_offset;
            LWIP_DHCP_INPUT_ERROR("decode_len %% 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
 2017dec:	e0bff643 	ldbu	r2,-39(fp)
 2017df0:	108000cc 	andi	r2,r2,3
 2017df4:	10803fcc 	andi	r2,r2,255
 2017df8:	10000226 	beq	r2,zero,2017e04 <dhcp_parse_reply+0x4cc>
 2017dfc:	00bffe84 	movi	r2,-6
 2017e00:	00009606 	br	201805c <dhcp_parse_reply+0x724>
            dhcp_got_option(dhcp, decode_idx);
 2017e04:	e0fff717 	ldw	r3,-36(fp)
 2017e08:	d0a7c544 	addi	r2,gp,-24811
 2017e0c:	1885883a 	add	r2,r3,r2
 2017e10:	00c00044 	movi	r3,1
 2017e14:	10c00005 	stb	r3,0(r2)
            dhcp_set_option_value(dhcp, decode_idx, lwip_htonl(value));
 2017e18:	e0bffd17 	ldw	r2,-12(fp)
 2017e1c:	1009883a 	mov	r4,r2
 2017e20:	20394b00 	call	20394b0 <lwip_htonl>
 2017e24:	1009883a 	mov	r4,r2
 2017e28:	00808574 	movhi	r2,533
 2017e2c:	10b52804 	addi	r2,r2,-11104
 2017e30:	e0fff717 	ldw	r3,-36(fp)
 2017e34:	18c7883a 	add	r3,r3,r3
 2017e38:	18c7883a 	add	r3,r3,r3
 2017e3c:	10c5883a 	add	r2,r2,r3
 2017e40:	11000015 	stw	r4,0(r2)
            decode_len = (u8_t)(decode_len - 4);
 2017e44:	e0bff643 	ldbu	r2,-39(fp)
 2017e48:	10bfff04 	addi	r2,r2,-4
 2017e4c:	e0bff645 	stb	r2,-39(fp)
            next_val_offset = (u16_t)(val_offset + 4);
 2017e50:	e0bff80b 	ldhu	r2,-32(fp)
 2017e54:	10800104 	addi	r2,r2,4
 2017e58:	e0bffb8d 	sth	r2,-18(fp)
            if (next_val_offset < val_offset) {
 2017e5c:	e0fffb8b 	ldhu	r3,-18(fp)
 2017e60:	e0bff80b 	ldhu	r2,-32(fp)
 2017e64:	1880022e 	bgeu	r3,r2,2017e70 <dhcp_parse_reply+0x538>
              /* overflow */
              return ERR_BUF;
 2017e68:	00bfff84 	movi	r2,-2
 2017e6c:	00007b06 	br	201805c <dhcp_parse_reply+0x724>
            }
            val_offset = next_val_offset;
 2017e70:	e0bffb8b 	ldhu	r2,-18(fp)
 2017e74:	e0bff80d 	sth	r2,-32(fp)
            decode_idx++;
 2017e78:	e0bff717 	ldw	r2,-36(fp)
 2017e7c:	10800044 	addi	r2,r2,1
 2017e80:	e0bff715 	stw	r2,-36(fp)
            goto decode_next;
 2017e84:	003fbc06 	br	2017d78 <__alt_mem_mem_0+0xfcff7d78>
          } else if (decode_len == 4) {
 2017e88:	e0bff643 	ldbu	r2,-39(fp)
 2017e8c:	10800118 	cmpnei	r2,r2,4
 2017e90:	1000051e 	bne	r2,zero,2017ea8 <dhcp_parse_reply+0x570>
            value = lwip_ntohl(value);
 2017e94:	e0bffd17 	ldw	r2,-12(fp)
 2017e98:	1009883a 	mov	r4,r2
 2017e9c:	20394b00 	call	20394b0 <lwip_htonl>
 2017ea0:	e0bffd15 	stw	r2,-12(fp)
 2017ea4:	00000906 	br	2017ecc <dhcp_parse_reply+0x594>
          } else {
            LWIP_DHCP_INPUT_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
 2017ea8:	e0bff643 	ldbu	r2,-39(fp)
 2017eac:	10800060 	cmpeqi	r2,r2,1
 2017eb0:	1000021e 	bne	r2,zero,2017ebc <dhcp_parse_reply+0x584>
 2017eb4:	00bffe84 	movi	r2,-6
 2017eb8:	00006806 	br	201805c <dhcp_parse_reply+0x724>
            value = ((u8_t *)&value)[0];
 2017ebc:	e0bffd04 	addi	r2,fp,-12
 2017ec0:	10800003 	ldbu	r2,0(r2)
 2017ec4:	10803fcc 	andi	r2,r2,255
 2017ec8:	e0bffd15 	stw	r2,-12(fp)
          }
          dhcp_got_option(dhcp, decode_idx);
 2017ecc:	e0fff717 	ldw	r3,-36(fp)
 2017ed0:	d0a7c544 	addi	r2,gp,-24811
 2017ed4:	1885883a 	add	r2,r3,r2
 2017ed8:	00c00044 	movi	r3,1
 2017edc:	10c00005 	stb	r3,0(r2)
          dhcp_set_option_value(dhcp, decode_idx, value);
 2017ee0:	e13ffd17 	ldw	r4,-12(fp)
 2017ee4:	00808574 	movhi	r2,533
 2017ee8:	10b52804 	addi	r2,r2,-11104
 2017eec:	e0fff717 	ldw	r3,-36(fp)
 2017ef0:	18c7883a 	add	r3,r3,r3
 2017ef4:	18c7883a 	add	r3,r3,r3
 2017ef8:	10c5883a 	add	r2,r2,r3
 2017efc:	11000015 	stw	r4,0(r2)
        }
      }
    }
    if (offset >= q->len) {
 2017f00:	e0bff317 	ldw	r2,-52(fp)
 2017f04:	1080028b 	ldhu	r2,10(r2)
 2017f08:	10bfffcc 	andi	r2,r2,65535
 2017f0c:	e0fff10b 	ldhu	r3,-60(fp)
 2017f10:	18801a36 	bltu	r3,r2,2017f7c <dhcp_parse_reply+0x644>
      offset = (u16_t)(offset - q->len);
 2017f14:	e0bff317 	ldw	r2,-52(fp)
 2017f18:	1080028b 	ldhu	r2,10(r2)
 2017f1c:	e0fff10b 	ldhu	r3,-60(fp)
 2017f20:	1885c83a 	sub	r2,r3,r2
 2017f24:	e0bff10d 	sth	r2,-60(fp)
      offset_max = (u16_t)(offset_max - q->len);
 2017f28:	e0bff317 	ldw	r2,-52(fp)
 2017f2c:	1080028b 	ldhu	r2,10(r2)
 2017f30:	e0fff18b 	ldhu	r3,-58(fp)
 2017f34:	1885c83a 	sub	r2,r3,r2
 2017f38:	e0bff18d 	sth	r2,-58(fp)
      if (offset < offset_max) {
 2017f3c:	e0fff10b 	ldhu	r3,-60(fp)
 2017f40:	e0bff18b 	ldhu	r2,-58(fp)
 2017f44:	18800b2e 	bgeu	r3,r2,2017f74 <dhcp_parse_reply+0x63c>
        q = q->next;
 2017f48:	e0bff317 	ldw	r2,-52(fp)
 2017f4c:	10800017 	ldw	r2,0(r2)
 2017f50:	e0bff315 	stw	r2,-52(fp)
        LWIP_DHCP_INPUT_ERROR("next pbuf was null", q != NULL, return ERR_VAL;);
 2017f54:	e0bff317 	ldw	r2,-52(fp)
 2017f58:	1000021e 	bne	r2,zero,2017f64 <dhcp_parse_reply+0x62c>
 2017f5c:	00bffe84 	movi	r2,-6
 2017f60:	00003e06 	br	201805c <dhcp_parse_reply+0x724>
        options = (u8_t *)q->payload;
 2017f64:	e0bff317 	ldw	r2,-52(fp)
 2017f68:	10800117 	ldw	r2,4(r2)
 2017f6c:	e0bff015 	stw	r2,-64(fp)
 2017f70:	00000206 	br	2017f7c <dhcp_parse_reply+0x644>
      } else {
        /* We've run out of bytes, probably no end marker. Don't proceed. */
        return ERR_BUF;
 2017f74:	00bfff84 	movi	r2,-2
 2017f78:	00003806 	br	201805c <dhcp_parse_reply+0x724>
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t *)q->payload;
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
 2017f7c:	e0bff317 	ldw	r2,-52(fp)
 2017f80:	10000a26 	beq	r2,zero,2017fac <dhcp_parse_reply+0x674>
 2017f84:	e0fff10b 	ldhu	r3,-60(fp)
 2017f88:	e0bff18b 	ldhu	r2,-58(fp)
 2017f8c:	1880072e 	bgeu	r3,r2,2017fac <dhcp_parse_reply+0x674>
 2017f90:	e0bff10b 	ldhu	r2,-60(fp)
 2017f94:	e0fff017 	ldw	r3,-64(fp)
 2017f98:	1885883a 	add	r2,r3,r2
 2017f9c:	10800003 	ldbu	r2,0(r2)
 2017fa0:	10803fcc 	andi	r2,r2,255
 2017fa4:	10803fd8 	cmpnei	r2,r2,255
 2017fa8:	103ea31e 	bne	r2,zero,2017a38 <__alt_mem_mem_0+0xfcff7a38>
        return ERR_BUF;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
 2017fac:	d0a7c543 	ldbu	r2,-24811(gp)
 2017fb0:	10803fcc 	andi	r2,r2,255
 2017fb4:	10001826 	beq	r2,zero,2018018 <dhcp_parse_reply+0x6e0>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 2017fb8:	00808574 	movhi	r2,533
 2017fbc:	10b52804 	addi	r2,r2,-11104
 2017fc0:	10800017 	ldw	r2,0(r2)
 2017fc4:	e0bffc15 	stw	r2,-16(fp)
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 2017fc8:	d027c545 	stb	zero,-24811(gp)
    if (overload == DHCP_OVERLOAD_FILE) {
 2017fcc:	e0bffc17 	ldw	r2,-16(fp)
 2017fd0:	10800058 	cmpnei	r2,r2,1
 2017fd4:	1000031e 	bne	r2,zero,2017fe4 <dhcp_parse_reply+0x6ac>
      parse_file_as_options = 1;
 2017fd8:	00800044 	movi	r2,1
 2017fdc:	e0bff415 	stw	r2,-48(fp)
 2017fe0:	00000d06 	br	2018018 <dhcp_parse_reply+0x6e0>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
 2017fe4:	e0bffc17 	ldw	r2,-16(fp)
 2017fe8:	10800098 	cmpnei	r2,r2,2
 2017fec:	1000031e 	bne	r2,zero,2017ffc <dhcp_parse_reply+0x6c4>
      parse_sname_as_options = 1;
 2017ff0:	00800044 	movi	r2,1
 2017ff4:	e0bff515 	stw	r2,-44(fp)
 2017ff8:	00000706 	br	2018018 <dhcp_parse_reply+0x6e0>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
 2017ffc:	e0bffc17 	ldw	r2,-16(fp)
 2018000:	108000d8 	cmpnei	r2,r2,3
 2018004:	1000041e 	bne	r2,zero,2018018 <dhcp_parse_reply+0x6e0>
      parse_sname_as_options = 1;
 2018008:	00800044 	movi	r2,1
 201800c:	e0bff515 	stw	r2,-44(fp)
      parse_file_as_options = 1;
 2018010:	00800044 	movi	r2,1
 2018014:	e0bff415 	stw	r2,-48(fp)
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("invalid overload option: %d\n", (int)overload));
    }
  }
  if (parse_file_as_options) {
 2018018:	e0bff417 	ldw	r2,-48(fp)
 201801c:	10000626 	beq	r2,zero,2018038 <dhcp_parse_reply+0x700>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
 2018020:	e03ff415 	stw	zero,-48(fp)
    options_idx = DHCP_FILE_OFS;
 2018024:	00801b04 	movi	r2,108
 2018028:	e0bff20d 	sth	r2,-56(fp)
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
 201802c:	00803b04 	movi	r2,236
 2018030:	e0bff28d 	sth	r2,-54(fp)
#if LWIP_DHCP_BOOTP_FILE
    file_overloaded = 1;
#endif
    goto again;
 2018034:	003e5b06 	br	20179a4 <__alt_mem_mem_0+0xfcff79a4>
  } else if (parse_sname_as_options) {
 2018038:	e0bff517 	ldw	r2,-44(fp)
 201803c:	10000626 	beq	r2,zero,2018058 <dhcp_parse_reply+0x720>
    parse_sname_as_options = 0;
 2018040:	e03ff515 	stw	zero,-44(fp)
    options_idx = DHCP_SNAME_OFS;
 2018044:	00800b04 	movi	r2,44
 2018048:	e0bff20d 	sth	r2,-56(fp)
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
 201804c:	00801b04 	movi	r2,108
 2018050:	e0bff28d 	sth	r2,-54(fp)
    goto again;
 2018054:	003e5306 	br	20179a4 <__alt_mem_mem_0+0xfcff79a4>
    }
    /* make sure the string is really NULL-terminated */
    dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
  }
#endif /* LWIP_DHCP_BOOTP_FILE */
  return ERR_OK;
 2018058:	0005883a 	mov	r2,zero
}
 201805c:	e037883a 	mov	sp,fp
 2018060:	dfc00117 	ldw	ra,4(sp)
 2018064:	df000017 	ldw	fp,0(sp)
 2018068:	dec00204 	addi	sp,sp,8
 201806c:	f800283a 	ret

02018070 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 2018070:	defff304 	addi	sp,sp,-52
 2018074:	dfc00c15 	stw	ra,48(sp)
 2018078:	df000b15 	stw	fp,44(sp)
 201807c:	df000b04 	addi	fp,sp,44
 2018080:	e13ffb15 	stw	r4,-20(fp)
 2018084:	e17ffc15 	stw	r5,-16(fp)
 2018088:	e1bffd15 	stw	r6,-12(fp)
 201808c:	e1fffe15 	stw	r7,-8(fp)
 2018090:	e0800217 	ldw	r2,8(fp)
 2018094:	e0bfff0d 	sth	r2,-4(fp)
  struct netif *netif = ip_current_input_netif();
 2018098:	008085f4 	movhi	r2,535
 201809c:	10be4204 	addi	r2,r2,-1784
 20180a0:	10800117 	ldw	r2,4(r2)
 20180a4:	e0bff615 	stw	r2,-40(fp)
  struct dhcp *dhcp = netif_dhcp_data(netif);
 20180a8:	e0bff617 	ldw	r2,-40(fp)
 20180ac:	10800a17 	ldw	r2,40(r2)
 20180b0:	e0bff715 	stw	r2,-36(fp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
 20180b4:	e0bffd17 	ldw	r2,-12(fp)
 20180b8:	10800117 	ldw	r2,4(r2)
 20180bc:	e0bff815 	stw	r2,-32(fp)
  struct dhcp_msg *msg_in;

  LWIP_UNUSED_ARG(arg);

  /* Caught DHCP message from netif that does not have DHCP enabled? -> not interested */
  if ((dhcp == NULL) || (dhcp->pcb_allocated == 0)) {
 20180c0:	e0bff717 	ldw	r2,-36(fp)
 20180c4:	1000a626 	beq	r2,zero,2018360 <dhcp_recv+0x2f0>
 20180c8:	e0bff717 	ldw	r2,-36(fp)
 20180cc:	10800103 	ldbu	r2,4(r2)
 20180d0:	10803fcc 	andi	r2,r2,255
 20180d4:	1000a226 	beq	r2,zero,2018360 <dhcp_recv+0x2f0>
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  if (p->len < DHCP_MIN_REPLY_LEN) {
 20180d8:	e0bffd17 	ldw	r2,-12(fp)
 20180dc:	1080028b 	ldhu	r2,10(r2)
 20180e0:	10bfffcc 	andi	r2,r2,65535
 20180e4:	10800b28 	cmpgeui	r2,r2,44
 20180e8:	10009226 	beq	r2,zero,2018334 <dhcp_recv+0x2c4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
 20180ec:	e0bff817 	ldw	r2,-32(fp)
 20180f0:	10800003 	ldbu	r2,0(r2)
 20180f4:	10803fcc 	andi	r2,r2,255
 20180f8:	108000a0 	cmpeqi	r2,r2,2
 20180fc:	10008f26 	beq	r2,zero,201833c <dhcp_recv+0x2cc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
 2018100:	e03ff505 	stb	zero,-44(fp)
 2018104:	00001006 	br	2018148 <dhcp_recv+0xd8>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 2018108:	e0bff503 	ldbu	r2,-44(fp)
 201810c:	e0fff617 	ldw	r3,-40(fp)
 2018110:	1885883a 	add	r2,r3,r2
 2018114:	10800d84 	addi	r2,r2,54
 2018118:	11000003 	ldbu	r4,0(r2)
 201811c:	e0bff503 	ldbu	r2,-44(fp)
 2018120:	e0fff817 	ldw	r3,-32(fp)
 2018124:	1885883a 	add	r2,r3,r2
 2018128:	10800704 	addi	r2,r2,28
 201812c:	10800003 	ldbu	r2,0(r2)
 2018130:	20c03fcc 	andi	r3,r4,255
 2018134:	10803fcc 	andi	r2,r2,255
 2018138:	1880821e 	bne	r3,r2,2018344 <dhcp_recv+0x2d4>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
 201813c:	e0bff503 	ldbu	r2,-44(fp)
 2018140:	10800044 	addi	r2,r2,1
 2018144:	e0bff505 	stb	r2,-44(fp)
 2018148:	e0bff617 	ldw	r2,-40(fp)
 201814c:	10800f03 	ldbu	r2,60(r2)
 2018150:	10803fcc 	andi	r2,r2,255
 2018154:	e0fff503 	ldbu	r3,-44(fp)
 2018158:	1880032e 	bgeu	r3,r2,2018168 <dhcp_recv+0xf8>
 201815c:	e0bff503 	ldbu	r2,-44(fp)
 2018160:	108001b0 	cmpltui	r2,r2,6
 2018164:	103fe81e 	bne	r2,zero,2018108 <__alt_mem_mem_0+0xfcff8108>
                   (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (lwip_ntohl(reply_msg->xid) != dhcp->xid) {
 2018168:	e0bff817 	ldw	r2,-32(fp)
 201816c:	10c00103 	ldbu	r3,4(r2)
 2018170:	11000143 	ldbu	r4,5(r2)
 2018174:	2008923a 	slli	r4,r4,8
 2018178:	20c6b03a 	or	r3,r4,r3
 201817c:	11000183 	ldbu	r4,6(r2)
 2018180:	2008943a 	slli	r4,r4,16
 2018184:	20c6b03a 	or	r3,r4,r3
 2018188:	108001c3 	ldbu	r2,7(r2)
 201818c:	1004963a 	slli	r2,r2,24
 2018190:	10c4b03a 	or	r2,r2,r3
 2018194:	1009883a 	mov	r4,r2
 2018198:	20394b00 	call	20394b0 <lwip_htonl>
 201819c:	1007883a 	mov	r3,r2
 20181a0:	e0bff717 	ldw	r2,-36(fp)
 20181a4:	10800017 	ldw	r2,0(r2)
 20181a8:	1880681e 	bne	r3,r2,201834c <dhcp_recv+0x2dc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n", lwip_ntohl(reply_msg->xid), dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(p, dhcp) != ERR_OK) {
 20181ac:	e17ff717 	ldw	r5,-36(fp)
 20181b0:	e13ffd17 	ldw	r4,-12(fp)
 20181b4:	20179380 	call	2017938 <dhcp_parse_reply>
 20181b8:	10803fcc 	andi	r2,r2,255
 20181bc:	1080201c 	xori	r2,r2,128
 20181c0:	10bfe004 	addi	r2,r2,-128
 20181c4:	1000631e 	bne	r2,zero,2018354 <dhcp_recv+0x2e4>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
 20181c8:	d0a7c583 	ldbu	r2,-24810(gp)
 20181cc:	10803fcc 	andi	r2,r2,255
 20181d0:	10006226 	beq	r2,zero,201835c <dhcp_recv+0x2ec>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  msg_in = (struct dhcp_msg *)p->payload;
 20181d4:	e0bffd17 	ldw	r2,-12(fp)
 20181d8:	10800117 	ldw	r2,4(r2)
 20181dc:	e0bff915 	stw	r2,-28(fp)
  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
 20181e0:	00808574 	movhi	r2,533
 20181e4:	10b52804 	addi	r2,r2,-11104
 20181e8:	10800117 	ldw	r2,4(r2)
 20181ec:	e0bffa05 	stb	r2,-24(fp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
 20181f0:	e0bffa03 	ldbu	r2,-24(fp)
 20181f4:	10800158 	cmpnei	r2,r2,5
 20181f8:	1000281e 	bne	r2,zero,201829c <dhcp_recv+0x22c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state or just reconnected to the network? */
    if ((dhcp->state == DHCP_STATE_REQUESTING) ||
 20181fc:	e0bff717 	ldw	r2,-36(fp)
 2018200:	10800143 	ldbu	r2,5(r2)
 2018204:	10803fcc 	andi	r2,r2,255
 2018208:	10800060 	cmpeqi	r2,r2,1
 201820c:	1000051e 	bne	r2,zero,2018224 <dhcp_recv+0x1b4>
        (dhcp->state == DHCP_STATE_REBOOTING)) {
 2018210:	e0bff717 	ldw	r2,-36(fp)
 2018214:	10800143 	ldbu	r2,5(r2)
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state or just reconnected to the network? */
    if ((dhcp->state == DHCP_STATE_REQUESTING) ||
 2018218:	10803fcc 	andi	r2,r2,255
 201821c:	108000d8 	cmpnei	r2,r2,3
 2018220:	10000e1e 	bne	r2,zero,201825c <dhcp_recv+0x1ec>
        (dhcp->state == DHCP_STATE_REBOOTING)) {
      dhcp_handle_ack(netif, msg_in);
 2018224:	e17ff917 	ldw	r5,-28(fp)
 2018228:	e13ff617 	ldw	r4,-40(fp)
 201822c:	201609c0 	call	201609c <dhcp_handle_ack>
#if LWIP_DHCP_DOES_ACD_CHECK
      if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
 2018230:	e0bff617 	ldw	r2,-40(fp)
 2018234:	10800f43 	ldbu	r2,61(r2)
 2018238:	10803fcc 	andi	r2,r2,255
 201823c:	1080020c 	andi	r2,r2,8
 2018240:	10000326 	beq	r2,zero,2018250 <dhcp_recv+0x1e0>
        /* check if the acknowledged lease address is already in use */
        dhcp_check(netif);
 2018244:	e13ff617 	ldw	r4,-40(fp)
 2018248:	20157ac0 	call	20157ac <dhcp_check>
    /* in requesting state or just reconnected to the network? */
    if ((dhcp->state == DHCP_STATE_REQUESTING) ||
        (dhcp->state == DHCP_STATE_REBOOTING)) {
      dhcp_handle_ack(netif, msg_in);
#if LWIP_DHCP_DOES_ACD_CHECK
      if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
 201824c:	00004406 	br	2018360 <dhcp_recv+0x2f0>
        /* check if the acknowledged lease address is already in use */
        dhcp_check(netif);
      } else {
        /* bind interface to the acknowledged lease address */
        dhcp_bind(netif);
 2018250:	e13ff617 	ldw	r4,-40(fp)
 2018254:	201697c0 	call	201697c <dhcp_bind>
    /* in requesting state or just reconnected to the network? */
    if ((dhcp->state == DHCP_STATE_REQUESTING) ||
        (dhcp->state == DHCP_STATE_REBOOTING)) {
      dhcp_handle_ack(netif, msg_in);
#if LWIP_DHCP_DOES_ACD_CHECK
      if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
 2018258:	00004106 	br	2018360 <dhcp_recv+0x2f0>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address and using it? */
    else if ((dhcp->state == DHCP_STATE_REBINDING) ||
 201825c:	e0bff717 	ldw	r2,-36(fp)
 2018260:	10800143 	ldbu	r2,5(r2)
 2018264:	10803fcc 	andi	r2,r2,255
 2018268:	10800120 	cmpeqi	r2,r2,4
 201826c:	1000051e 	bne	r2,zero,2018284 <dhcp_recv+0x214>
             (dhcp->state == DHCP_STATE_RENEWING)) {
 2018270:	e0bff717 	ldw	r2,-36(fp)
 2018274:	10800143 	ldbu	r2,5(r2)
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address and using it? */
    else if ((dhcp->state == DHCP_STATE_REBINDING) ||
 2018278:	10803fcc 	andi	r2,r2,255
 201827c:	10800158 	cmpnei	r2,r2,5
 2018280:	1000371e 	bne	r2,zero,2018360 <dhcp_recv+0x2f0>
             (dhcp->state == DHCP_STATE_RENEWING)) {
      dhcp_handle_ack(netif, msg_in);
 2018284:	e17ff917 	ldw	r5,-28(fp)
 2018288:	e13ff617 	ldw	r4,-40(fp)
 201828c:	201609c0 	call	201609c <dhcp_handle_ack>
      dhcp_bind(netif);
 2018290:	e13ff617 	ldw	r4,-40(fp)
 2018294:	201697c0 	call	201697c <dhcp_bind>
 2018298:	00003106 	br	2018360 <dhcp_recv+0x2f0>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 201829c:	e0bffa03 	ldbu	r2,-24(fp)
 20182a0:	10800198 	cmpnei	r2,r2,6
 20182a4:	1000171e 	bne	r2,zero,2018304 <dhcp_recv+0x294>
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
 20182a8:	e0bff717 	ldw	r2,-36(fp)
 20182ac:	10800143 	ldbu	r2,5(r2)
      dhcp_handle_ack(netif, msg_in);
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 20182b0:	10803fcc 	andi	r2,r2,255
 20182b4:	108000e0 	cmpeqi	r2,r2,3
 20182b8:	10000f1e 	bne	r2,zero,20182f8 <dhcp_recv+0x288>
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
 20182bc:	e0bff717 	ldw	r2,-36(fp)
 20182c0:	10800143 	ldbu	r2,5(r2)
 20182c4:	10803fcc 	andi	r2,r2,255
 20182c8:	10800060 	cmpeqi	r2,r2,1
 20182cc:	10000a1e 	bne	r2,zero,20182f8 <dhcp_recv+0x288>
            (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
 20182d0:	e0bff717 	ldw	r2,-36(fp)
 20182d4:	10800143 	ldbu	r2,5(r2)
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
 20182d8:	10803fcc 	andi	r2,r2,255
 20182dc:	10800120 	cmpeqi	r2,r2,4
 20182e0:	1000051e 	bne	r2,zero,20182f8 <dhcp_recv+0x288>
            (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
 20182e4:	e0bff717 	ldw	r2,-36(fp)
 20182e8:	10800143 	ldbu	r2,5(r2)
 20182ec:	10803fcc 	andi	r2,r2,255
 20182f0:	10800158 	cmpnei	r2,r2,5
 20182f4:	1000031e 	bne	r2,zero,2018304 <dhcp_recv+0x294>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
 20182f8:	e13ff617 	ldw	r4,-40(fp)
 20182fc:	20156900 	call	2015690 <dhcp_handle_nak>
 2018300:	00001706 	br	2018360 <dhcp_recv+0x2f0>
  }
  /* received a DHCP_OFFER in DHCP_STATE_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_STATE_SELECTING)) {
 2018304:	e0bffa03 	ldbu	r2,-24(fp)
 2018308:	10800098 	cmpnei	r2,r2,2
 201830c:	1000141e 	bne	r2,zero,2018360 <dhcp_recv+0x2f0>
 2018310:	e0bff717 	ldw	r2,-36(fp)
 2018314:	10800143 	ldbu	r2,5(r2)
 2018318:	10803fcc 	andi	r2,r2,255
 201831c:	10800198 	cmpnei	r2,r2,6
 2018320:	10000f1e 	bne	r2,zero,2018360 <dhcp_recv+0x2f0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_STATE_SELECTING state\n"));
    /* remember offered lease */
    dhcp_handle_offer(netif, msg_in);
 2018324:	e17ff917 	ldw	r5,-28(fp)
 2018328:	e13ff617 	ldw	r4,-40(fp)
 201832c:	201580c0 	call	201580c <dhcp_handle_offer>
 2018330:	00000b06 	br	2018360 <dhcp_recv+0x2f0>
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
 2018334:	0001883a 	nop
 2018338:	00000906 	br	2018360 <dhcp_recv+0x2f0>
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
 201833c:	0001883a 	nop
 2018340:	00000706 	br	2018360 <dhcp_recv+0x2f0>
  for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                  ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
                   (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
 2018344:	0001883a 	nop
 2018348:	00000506 	br	2018360 <dhcp_recv+0x2f0>
  }
  /* match transaction ID against what we expected */
  if (lwip_ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n", lwip_ntohl(reply_msg->xid), dhcp->xid));
    goto free_pbuf_and_return;
 201834c:	0001883a 	nop
 2018350:	00000306 	br	2018360 <dhcp_recv+0x2f0>
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(p, dhcp) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
 2018354:	0001883a 	nop
 2018358:	00000106 	br	2018360 <dhcp_recv+0x2f0>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
 201835c:	0001883a 	nop
    /* remember offered lease */
    dhcp_handle_offer(netif, msg_in);
  }

free_pbuf_and_return:
  pbuf_free(p);
 2018360:	e13ffd17 	ldw	r4,-12(fp)
 2018364:	201d2f40 	call	201d2f4 <pbuf_free>
}
 2018368:	0001883a 	nop
 201836c:	e037883a 	mov	sp,fp
 2018370:	dfc00117 	ldw	ra,4(sp)
 2018374:	df000017 	ldw	fp,0(sp)
 2018378:	dec00204 	addi	sp,sp,8
 201837c:	f800283a 	ret

02018380 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static struct pbuf *
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type, u16_t *options_out_len)
{
 2018380:	defff604 	addi	sp,sp,-40
 2018384:	dfc00915 	stw	ra,36(sp)
 2018388:	df000815 	stw	fp,32(sp)
 201838c:	df000804 	addi	fp,sp,32
 2018390:	e13ffc15 	stw	r4,-16(fp)
 2018394:	e17ffd15 	stw	r5,-12(fp)
 2018398:	3005883a 	mov	r2,r6
 201839c:	e1ffff15 	stw	r7,-4(fp)
 20183a0:	e0bffe05 	stb	r2,-8(fp)
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return NULL;);
 20183a4:	e0bffc17 	ldw	r2,-16(fp)
 20183a8:	1000021e 	bne	r2,zero,20183b4 <dhcp_create_msg+0x34>
 20183ac:	0005883a 	mov	r2,zero
 20183b0:	0000c806 	br	20186d4 <dhcp_create_msg+0x354>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return NULL;);
 20183b4:	e0bffd17 	ldw	r2,-12(fp)
 20183b8:	1000021e 	bne	r2,zero,20183c4 <dhcp_create_msg+0x44>
 20183bc:	0005883a 	mov	r2,zero
 20183c0:	0000c406 	br	20186d4 <dhcp_create_msg+0x354>
  p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 20183c4:	0180a004 	movi	r6,640
 20183c8:	01404d04 	movi	r5,308
 20183cc:	01000e04 	movi	r4,56
 20183d0:	201c9740 	call	201c974 <pbuf_alloc>
 20183d4:	e0bff915 	stw	r2,-28(fp)
  if (p_out == NULL) {
 20183d8:	e0bff917 	ldw	r2,-28(fp)
 20183dc:	1000021e 	bne	r2,zero,20183e8 <dhcp_create_msg+0x68>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_create_msg(): could not allocate pbuf\n"));
    return NULL;
 20183e0:	0005883a 	mov	r2,zero
 20183e4:	0000bb06 	br	20186d4 <dhcp_create_msg+0x354>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
              (p_out->len >= sizeof(struct dhcp_msg)));

  /* DHCP_REQUEST should reuse 'xid' from DHCPOFFER */
  if ((message_type != DHCP_REQUEST) || (dhcp->state == DHCP_STATE_REBOOTING)) {
 20183e8:	e0bffe03 	ldbu	r2,-8(fp)
 20183ec:	108000d8 	cmpnei	r2,r2,3
 20183f0:	1000051e 	bne	r2,zero,2018408 <dhcp_create_msg+0x88>
 20183f4:	e0bffd17 	ldw	r2,-12(fp)
 20183f8:	10800143 	ldbu	r2,5(r2)
 20183fc:	10803fcc 	andi	r2,r2,255
 2018400:	108000d8 	cmpnei	r2,r2,3
 2018404:	10000a1e 	bne	r2,zero,2018430 <dhcp_create_msg+0xb0>
    /* reuse transaction identifier in retransmissions */
    if (dhcp->tries == 0) {
 2018408:	e0bffd17 	ldw	r2,-12(fp)
 201840c:	10800183 	ldbu	r2,6(r2)
 2018410:	10803fcc 	andi	r2,r2,255
 2018414:	1000031e 	bne	r2,zero,2018424 <dhcp_create_msg+0xa4>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
      xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
      xid++;
 2018418:	d0a00d17 	ldw	r2,-32716(gp)
 201841c:	10800044 	addi	r2,r2,1
 2018420:	d0a00d15 	stw	r2,-32716(gp)
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    }
    dhcp->xid = xid;
 2018424:	d0e00d17 	ldw	r3,-32716(gp)
 2018428:	e0bffd17 	ldw	r2,-12(fp)
 201842c:	10c00015 	stw	r3,0(r2)
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  msg_out = (struct dhcp_msg *)p_out->payload;
 2018430:	e0bff917 	ldw	r2,-28(fp)
 2018434:	10800117 	ldw	r2,4(r2)
 2018438:	e0bffa15 	stw	r2,-24(fp)
  memset(msg_out, 0, sizeof(struct dhcp_msg));
 201843c:	01804d04 	movi	r6,308
 2018440:	000b883a 	mov	r5,zero
 2018444:	e13ffa17 	ldw	r4,-24(fp)
 2018448:	2005fa00 	call	2005fa0 <memset>

  msg_out->op = DHCP_BOOTREQUEST;
 201844c:	e0bffa17 	ldw	r2,-24(fp)
 2018450:	00c00044 	movi	r3,1
 2018454:	10c00005 	stb	r3,0(r2)
  /* @todo: make link layer independent */
  msg_out->htype = LWIP_IANA_HWTYPE_ETHERNET;
 2018458:	e0bffa17 	ldw	r2,-24(fp)
 201845c:	00c00044 	movi	r3,1
 2018460:	10c00045 	stb	r3,1(r2)
  msg_out->hlen = netif->hwaddr_len;
 2018464:	e0bffc17 	ldw	r2,-16(fp)
 2018468:	10c00f03 	ldbu	r3,60(r2)
 201846c:	e0bffa17 	ldw	r2,-24(fp)
 2018470:	10c00085 	stb	r3,2(r2)
  msg_out->xid = lwip_htonl(dhcp->xid);
 2018474:	e0bffd17 	ldw	r2,-12(fp)
 2018478:	10800017 	ldw	r2,0(r2)
 201847c:	1009883a 	mov	r4,r2
 2018480:	20394b00 	call	20394b0 <lwip_htonl>
 2018484:	1007883a 	mov	r3,r2
 2018488:	e0bffa17 	ldw	r2,-24(fp)
 201848c:	19803fcc 	andi	r6,r3,255
 2018490:	11000103 	ldbu	r4,4(r2)
 2018494:	2008703a 	and	r4,r4,zero
 2018498:	200b883a 	mov	r5,r4
 201849c:	3009883a 	mov	r4,r6
 20184a0:	2908b03a 	or	r4,r5,r4
 20184a4:	11000105 	stb	r4,4(r2)
 20184a8:	1808d23a 	srli	r4,r3,8
 20184ac:	21803fcc 	andi	r6,r4,255
 20184b0:	11000143 	ldbu	r4,5(r2)
 20184b4:	2008703a 	and	r4,r4,zero
 20184b8:	200b883a 	mov	r5,r4
 20184bc:	3009883a 	mov	r4,r6
 20184c0:	2908b03a 	or	r4,r5,r4
 20184c4:	11000145 	stb	r4,5(r2)
 20184c8:	1808d43a 	srli	r4,r3,16
 20184cc:	21803fcc 	andi	r6,r4,255
 20184d0:	11000183 	ldbu	r4,6(r2)
 20184d4:	2008703a 	and	r4,r4,zero
 20184d8:	200b883a 	mov	r5,r4
 20184dc:	3009883a 	mov	r4,r6
 20184e0:	2908b03a 	or	r4,r5,r4
 20184e4:	11000185 	stb	r4,6(r2)
 20184e8:	180ad63a 	srli	r5,r3,24
 20184ec:	10c001c3 	ldbu	r3,7(r2)
 20184f0:	1806703a 	and	r3,r3,zero
 20184f4:	1809883a 	mov	r4,r3
 20184f8:	2807883a 	mov	r3,r5
 20184fc:	20c6b03a 	or	r3,r4,r3
 2018500:	10c001c5 	stb	r3,7(r2)
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
 2018504:	e0bffe03 	ldbu	r2,-8(fp)
 2018508:	10800220 	cmpeqi	r2,r2,8
 201850c:	1000131e 	bne	r2,zero,201855c <dhcp_create_msg+0x1dc>
 2018510:	e0bffe03 	ldbu	r2,-8(fp)
 2018514:	10800120 	cmpeqi	r2,r2,4
 2018518:	1000101e 	bne	r2,zero,201855c <dhcp_create_msg+0x1dc>
 201851c:	e0bffe03 	ldbu	r2,-8(fp)
 2018520:	108001e0 	cmpeqi	r2,r2,7
 2018524:	10000d1e 	bne	r2,zero,201855c <dhcp_create_msg+0x1dc>
 2018528:	e0bffe03 	ldbu	r2,-8(fp)
 201852c:	108000d8 	cmpnei	r2,r2,3
 2018530:	10002c1e 	bne	r2,zero,20185e4 <dhcp_create_msg+0x264>
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
       ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
 2018534:	e0bffd17 	ldw	r2,-12(fp)
 2018538:	10800143 	ldbu	r2,5(r2)
  msg_out->xid = lwip_htonl(dhcp->xid);
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
 201853c:	10803fcc 	andi	r2,r2,255
 2018540:	10800160 	cmpeqi	r2,r2,5
 2018544:	1000051e 	bne	r2,zero,201855c <dhcp_create_msg+0x1dc>
       ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
 2018548:	e0bffd17 	ldw	r2,-12(fp)
 201854c:	10800143 	ldbu	r2,5(r2)
 2018550:	10803fcc 	andi	r2,r2,255
 2018554:	10800118 	cmpnei	r2,r2,4
 2018558:	1000221e 	bne	r2,zero,20185e4 <dhcp_create_msg+0x264>
    ip4_addr_copy(msg_out->ciaddr, *netif_ip4_addr(netif));
 201855c:	e0bffc17 	ldw	r2,-16(fp)
 2018560:	10800104 	addi	r2,r2,4
 2018564:	10c00017 	ldw	r3,0(r2)
 2018568:	e0bffa17 	ldw	r2,-24(fp)
 201856c:	19803fcc 	andi	r6,r3,255
 2018570:	11000303 	ldbu	r4,12(r2)
 2018574:	2008703a 	and	r4,r4,zero
 2018578:	200b883a 	mov	r5,r4
 201857c:	3009883a 	mov	r4,r6
 2018580:	2908b03a 	or	r4,r5,r4
 2018584:	11000305 	stb	r4,12(r2)
 2018588:	1808d23a 	srli	r4,r3,8
 201858c:	21803fcc 	andi	r6,r4,255
 2018590:	11000343 	ldbu	r4,13(r2)
 2018594:	2008703a 	and	r4,r4,zero
 2018598:	200b883a 	mov	r5,r4
 201859c:	3009883a 	mov	r4,r6
 20185a0:	2908b03a 	or	r4,r5,r4
 20185a4:	11000345 	stb	r4,13(r2)
 20185a8:	1808d43a 	srli	r4,r3,16
 20185ac:	21803fcc 	andi	r6,r4,255
 20185b0:	11000383 	ldbu	r4,14(r2)
 20185b4:	2008703a 	and	r4,r4,zero
 20185b8:	200b883a 	mov	r5,r4
 20185bc:	3009883a 	mov	r4,r6
 20185c0:	2908b03a 	or	r4,r5,r4
 20185c4:	11000385 	stb	r4,14(r2)
 20185c8:	180ad63a 	srli	r5,r3,24
 20185cc:	10c003c3 	ldbu	r3,15(r2)
 20185d0:	1806703a 	and	r3,r3,zero
 20185d4:	1809883a 	mov	r4,r3
 20185d8:	2807883a 	mov	r3,r5
 20185dc:	20c6b03a 	or	r3,r4,r3
 20185e0:	10c003c5 	stb	r3,15(r2)
  }
  for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
 20185e4:	e03ff80d 	sth	zero,-32(fp)
 20185e8:	00000d06 	br	2018620 <dhcp_create_msg+0x2a0>
    /* copy netif hardware address (padded with zeroes through memset already) */
    msg_out->chaddr[i] = netif->hwaddr[i];
 20185ec:	e0bff80b 	ldhu	r2,-32(fp)
 20185f0:	e0fff80b 	ldhu	r3,-32(fp)
 20185f4:	e13ffc17 	ldw	r4,-16(fp)
 20185f8:	20c7883a 	add	r3,r4,r3
 20185fc:	18c00d84 	addi	r3,r3,54
 2018600:	18c00003 	ldbu	r3,0(r3)
 2018604:	e13ffa17 	ldw	r4,-24(fp)
 2018608:	2085883a 	add	r2,r4,r2
 201860c:	10800704 	addi	r2,r2,28
 2018610:	10c00005 	stb	r3,0(r2)
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
       ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
    ip4_addr_copy(msg_out->ciaddr, *netif_ip4_addr(netif));
  }
  for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
 2018614:	e0bff80b 	ldhu	r2,-32(fp)
 2018618:	10800044 	addi	r2,r2,1
 201861c:	e0bff80d 	sth	r2,-32(fp)
 2018620:	e0bff80b 	ldhu	r2,-32(fp)
 2018624:	108001b0 	cmpltui	r2,r2,6
 2018628:	103ff01e 	bne	r2,zero,20185ec <__alt_mem_mem_0+0xfcff85ec>
    /* copy netif hardware address (padded with zeroes through memset already) */
    msg_out->chaddr[i] = netif->hwaddr[i];
  }
  msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 201862c:	e0bffa17 	ldw	r2,-24(fp)
 2018630:	10c03b03 	ldbu	r3,236(r2)
 2018634:	1806703a 	and	r3,r3,zero
 2018638:	18c018d4 	ori	r3,r3,99
 201863c:	10c03b05 	stb	r3,236(r2)
 2018640:	10c03b43 	ldbu	r3,237(r2)
 2018644:	1806703a 	and	r3,r3,zero
 2018648:	1809883a 	mov	r4,r3
 201864c:	00ffe084 	movi	r3,-126
 2018650:	20c6b03a 	or	r3,r4,r3
 2018654:	10c03b45 	stb	r3,237(r2)
 2018658:	10c03b83 	ldbu	r3,238(r2)
 201865c:	1806703a 	and	r3,r3,zero
 2018660:	18c014d4 	ori	r3,r3,83
 2018664:	10c03b85 	stb	r3,238(r2)
 2018668:	10c03bc3 	ldbu	r3,239(r2)
 201866c:	1806703a 	and	r3,r3,zero
 2018670:	18c018d4 	ori	r3,r3,99
 2018674:	10c03bc5 	stb	r3,239(r2)
  /* Add option MESSAGE_TYPE */
  options_out_len_loc = dhcp_option(0, msg_out->options, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
 2018678:	e0bffa17 	ldw	r2,-24(fp)
 201867c:	10803c04 	addi	r2,r2,240
 2018680:	01c00044 	movi	r7,1
 2018684:	01800d44 	movi	r6,53
 2018688:	100b883a 	mov	r5,r2
 201868c:	0009883a 	mov	r4,zero
 2018690:	20176400 	call	2017640 <dhcp_option>
 2018694:	e0bffb0d 	sth	r2,-20(fp)
  options_out_len_loc = dhcp_option_byte(options_out_len_loc, msg_out->options, message_type);
 2018698:	e0fffb0b 	ldhu	r3,-20(fp)
 201869c:	e0bffa17 	ldw	r2,-24(fp)
 20186a0:	10803c04 	addi	r2,r2,240
 20186a4:	e13ffe03 	ldbu	r4,-8(fp)
 20186a8:	200d883a 	mov	r6,r4
 20186ac:	100b883a 	mov	r5,r2
 20186b0:	1809883a 	mov	r4,r3
 20186b4:	20176b80 	call	20176b8 <dhcp_option_byte>
 20186b8:	e0bffb0d 	sth	r2,-20(fp)
  if (options_out_len) {
 20186bc:	e0bfff17 	ldw	r2,-4(fp)
 20186c0:	10000326 	beq	r2,zero,20186d0 <dhcp_create_msg+0x350>
    *options_out_len = options_out_len_loc;
 20186c4:	e0bfff17 	ldw	r2,-4(fp)
 20186c8:	e0fffb0b 	ldhu	r3,-20(fp)
 20186cc:	10c0000d 	sth	r3,0(r2)
  }
  return p_out;
 20186d0:	e0bff917 	ldw	r2,-28(fp)
}
 20186d4:	e037883a 	mov	sp,fp
 20186d8:	dfc00117 	ldw	ra,4(sp)
 20186dc:	df000017 	ldw	fp,0(sp)
 20186e0:	dec00204 	addi	sp,sp,8
 20186e4:	f800283a 	ret

020186e8 <dhcp_option_trailer>:
 * Adds the END option to the DHCP message, and if
 * necessary, up to three padding bytes.
 */
static void
dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out)
{
 20186e8:	defffb04 	addi	sp,sp,-20
 20186ec:	dfc00415 	stw	ra,16(sp)
 20186f0:	df000315 	stw	fp,12(sp)
 20186f4:	df000304 	addi	fp,sp,12
 20186f8:	2005883a 	mov	r2,r4
 20186fc:	e17ffe15 	stw	r5,-8(fp)
 2018700:	e1bfff15 	stw	r6,-4(fp)
 2018704:	e0bffd0d 	sth	r2,-12(fp)
  options[options_out_len++] = DHCP_OPTION_END;
 2018708:	e0bffd0b 	ldhu	r2,-12(fp)
 201870c:	10c00044 	addi	r3,r2,1
 2018710:	e0fffd0d 	sth	r3,-12(fp)
 2018714:	10bfffcc 	andi	r2,r2,65535
 2018718:	e0fffe17 	ldw	r3,-8(fp)
 201871c:	1885883a 	add	r2,r3,r2
 2018720:	00ffffc4 	movi	r3,-1
 2018724:	10c00005 	stb	r3,0(r2)
  /* packet is too small, or not 4 byte aligned? */
  while (((options_out_len < DHCP_MIN_OPTIONS_LEN) || (options_out_len & 3)) &&
 2018728:	00000706 	br	2018748 <dhcp_option_trailer+0x60>
         (options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    options[options_out_len++] = 0;
 201872c:	e0bffd0b 	ldhu	r2,-12(fp)
 2018730:	10c00044 	addi	r3,r2,1
 2018734:	e0fffd0d 	sth	r3,-12(fp)
 2018738:	10bfffcc 	andi	r2,r2,65535
 201873c:	e0fffe17 	ldw	r3,-8(fp)
 2018740:	1885883a 	add	r2,r3,r2
 2018744:	10000005 	stb	zero,0(r2)
static void
dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out)
{
  options[options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((options_out_len < DHCP_MIN_OPTIONS_LEN) || (options_out_len & 3)) &&
 2018748:	e0bffd0b 	ldhu	r2,-12(fp)
 201874c:	10801130 	cmpltui	r2,r2,68
 2018750:	1000031e 	bne	r2,zero,2018760 <dhcp_option_trailer+0x78>
 2018754:	e0bffd0b 	ldhu	r2,-12(fp)
 2018758:	108000cc 	andi	r2,r2,3
 201875c:	10000326 	beq	r2,zero,201876c <dhcp_option_trailer+0x84>
 2018760:	e0bffd0b 	ldhu	r2,-12(fp)
 2018764:	10801130 	cmpltui	r2,r2,68
 2018768:	103ff01e 	bne	r2,zero,201872c <__alt_mem_mem_0+0xfcff872c>
         (options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    options[options_out_len++] = 0;
  }
  /* shrink the pbuf to the actual content length */
  pbuf_realloc(p_out, (u16_t)(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + options_out_len));
 201876c:	e0bffd0b 	ldhu	r2,-12(fp)
 2018770:	10803c04 	addi	r2,r2,240
 2018774:	10bfffcc 	andi	r2,r2,65535
 2018778:	100b883a 	mov	r5,r2
 201877c:	e13fff17 	ldw	r4,-4(fp)
 2018780:	201cd3c0 	call	201cd3c <pbuf_realloc>
}
 2018784:	0001883a 	nop
 2018788:	e037883a 	mov	sp,fp
 201878c:	dfc00117 	ldw	ra,4(sp)
 2018790:	df000017 	ldw	fp,0(sp)
 2018794:	dec00204 	addi	sp,sp,8
 2018798:	f800283a 	ret

0201879c <dhcp_supplied_address>:
 * @return 1 if DHCP supplied netif->ip_addr (states BOUND or RENEWING),
 *         0 otherwise
 */
u8_t
dhcp_supplied_address(const struct netif *netif)
{
 201879c:	defffd04 	addi	sp,sp,-12
 20187a0:	df000215 	stw	fp,8(sp)
 20187a4:	df000204 	addi	fp,sp,8
 20187a8:	e13fff15 	stw	r4,-4(fp)
  if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
 20187ac:	e0bfff17 	ldw	r2,-4(fp)
 20187b0:	10001926 	beq	r2,zero,2018818 <dhcp_supplied_address+0x7c>
 20187b4:	e0bfff17 	ldw	r2,-4(fp)
 20187b8:	10800a17 	ldw	r2,40(r2)
 20187bc:	10001626 	beq	r2,zero,2018818 <dhcp_supplied_address+0x7c>
    struct dhcp *dhcp = netif_dhcp_data(netif);
 20187c0:	e0bfff17 	ldw	r2,-4(fp)
 20187c4:	10800a17 	ldw	r2,40(r2)
 20187c8:	e0bffe15 	stw	r2,-8(fp)
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
 20187cc:	e0bffe17 	ldw	r2,-8(fp)
 20187d0:	10800143 	ldbu	r2,5(r2)
 20187d4:	10803fcc 	andi	r2,r2,255
 20187d8:	108002a0 	cmpeqi	r2,r2,10
 20187dc:	10000a1e 	bne	r2,zero,2018808 <dhcp_supplied_address+0x6c>
 20187e0:	e0bffe17 	ldw	r2,-8(fp)
 20187e4:	10800143 	ldbu	r2,5(r2)
 20187e8:	10803fcc 	andi	r2,r2,255
 20187ec:	10800160 	cmpeqi	r2,r2,5
 20187f0:	1000051e 	bne	r2,zero,2018808 <dhcp_supplied_address+0x6c>
           (dhcp->state == DHCP_STATE_REBINDING);
 20187f4:	e0bffe17 	ldw	r2,-8(fp)
 20187f8:	10800143 	ldbu	r2,5(r2)
u8_t
dhcp_supplied_address(const struct netif *netif)
{
  if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
    struct dhcp *dhcp = netif_dhcp_data(netif);
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
 20187fc:	10803fcc 	andi	r2,r2,255
 2018800:	10800118 	cmpnei	r2,r2,4
 2018804:	1000021e 	bne	r2,zero,2018810 <dhcp_supplied_address+0x74>
 2018808:	00800044 	movi	r2,1
 201880c:	00000106 	br	2018814 <dhcp_supplied_address+0x78>
 2018810:	0005883a 	mov	r2,zero
 2018814:	00000106 	br	201881c <dhcp_supplied_address+0x80>
           (dhcp->state == DHCP_STATE_REBINDING);
  }
  return 0;
 2018818:	0005883a 	mov	r2,zero
}
 201881c:	e037883a 	mov	sp,fp
 2018820:	df000017 	ldw	fp,0(sp)
 2018824:	dec00104 	addi	sp,sp,4
 2018828:	f800283a 	ret

0201882c <free_etharp_q>:
 *
 * @param q a queue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
 201882c:	defffc04 	addi	sp,sp,-16
 2018830:	dfc00315 	stw	ra,12(sp)
 2018834:	df000215 	stw	fp,8(sp)
 2018838:	df000204 	addi	fp,sp,8
 201883c:	e13fff15 	stw	r4,-4(fp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  while (q) {
 2018840:	00000c06 	br	2018874 <free_etharp_q+0x48>
    r = q;
 2018844:	e0bfff17 	ldw	r2,-4(fp)
 2018848:	e0bffe15 	stw	r2,-8(fp)
    q = q->next;
 201884c:	e0bfff17 	ldw	r2,-4(fp)
 2018850:	10800017 	ldw	r2,0(r2)
 2018854:	e0bfff15 	stw	r2,-4(fp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
 2018858:	e0bffe17 	ldw	r2,-8(fp)
 201885c:	10800117 	ldw	r2,4(r2)
 2018860:	1009883a 	mov	r4,r2
 2018864:	201d2f40 	call	201d2f4 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
 2018868:	e17ffe17 	ldw	r5,-8(fp)
 201886c:	010002c4 	movi	r4,11
 2018870:	201b9640 	call	201b964 <memp_free>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  while (q) {
 2018874:	e0bfff17 	ldw	r2,-4(fp)
 2018878:	103ff21e 	bne	r2,zero,2018844 <__alt_mem_mem_0+0xfcff8844>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
 201887c:	0001883a 	nop
 2018880:	e037883a 	mov	sp,fp
 2018884:	dfc00117 	ldw	ra,4(sp)
 2018888:	df000017 	ldw	fp,0(sp)
 201888c:	dec00204 	addi	sp,sp,8
 2018890:	f800283a 	ret

02018894 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 2018894:	defffd04 	addi	sp,sp,-12
 2018898:	dfc00215 	stw	ra,8(sp)
 201889c:	df000115 	stw	fp,4(sp)
 20188a0:	df000104 	addi	fp,sp,4
 20188a4:	e13fff15 	stw	r4,-4(fp)
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 20188a8:	00808174 	movhi	r2,517
 20188ac:	10b38904 	addi	r2,r2,-12764
 20188b0:	e0ffff17 	ldw	r3,-4(fp)
 20188b4:	18c00624 	muli	r3,r3,24
 20188b8:	10c5883a 	add	r2,r2,r3
 20188bc:	10800017 	ldw	r2,0(r2)
 20188c0:	10000e26 	beq	r2,zero,20188fc <etharp_free_entry+0x68>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 20188c4:	00808174 	movhi	r2,517
 20188c8:	10b38904 	addi	r2,r2,-12764
 20188cc:	e0ffff17 	ldw	r3,-4(fp)
 20188d0:	18c00624 	muli	r3,r3,24
 20188d4:	10c5883a 	add	r2,r2,r3
 20188d8:	10800017 	ldw	r2,0(r2)
 20188dc:	1009883a 	mov	r4,r2
 20188e0:	201882c0 	call	201882c <free_etharp_q>
    arp_table[i].q = NULL;
 20188e4:	00808174 	movhi	r2,517
 20188e8:	10b38904 	addi	r2,r2,-12764
 20188ec:	e0ffff17 	ldw	r3,-4(fp)
 20188f0:	18c00624 	muli	r3,r3,24
 20188f4:	10c5883a 	add	r2,r2,r3
 20188f8:	10000015 	stw	zero,0(r2)
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 20188fc:	00808174 	movhi	r2,517
 2018900:	10b38904 	addi	r2,r2,-12764
 2018904:	e0ffff17 	ldw	r3,-4(fp)
 2018908:	18c00624 	muli	r3,r3,24
 201890c:	10c5883a 	add	r2,r2,r3
 2018910:	10800504 	addi	r2,r2,20
 2018914:	10000005 	stb	zero,0(r2)
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip4_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
 2018918:	0001883a 	nop
 201891c:	e037883a 	mov	sp,fp
 2018920:	dfc00117 	ldw	ra,4(sp)
 2018924:	df000017 	ldw	fp,0(sp)
 2018928:	dec00204 	addi	sp,sp,8
 201892c:	f800283a 	ret

02018930 <etharp_tmr>:
 * This function should be called every ARP_TMR_INTERVAL milliseconds (1 second),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 2018930:	defffc04 	addi	sp,sp,-16
 2018934:	dfc00315 	stw	ra,12(sp)
 2018938:	df000215 	stw	fp,8(sp)
 201893c:	df000204 	addi	fp,sp,8
  int i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 2018940:	e03ffe15 	stw	zero,-8(fp)
 2018944:	00007d06 	br	2018b3c <etharp_tmr+0x20c>
    u8_t state = arp_table[i].state;
 2018948:	00808174 	movhi	r2,517
 201894c:	10b38904 	addi	r2,r2,-12764
 2018950:	e0fffe17 	ldw	r3,-8(fp)
 2018954:	18c00624 	muli	r3,r3,24
 2018958:	10c5883a 	add	r2,r2,r3
 201895c:	10800504 	addi	r2,r2,20
 2018960:	10800003 	ldbu	r2,0(r2)
 2018964:	e0bfff05 	stb	r2,-4(fp)
    if (state != ETHARP_STATE_EMPTY
 2018968:	e0bfff03 	ldbu	r2,-4(fp)
 201896c:	10007026 	beq	r2,zero,2018b30 <etharp_tmr+0x200>
#if ETHARP_SUPPORT_STATIC_ENTRIES
        && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
       ) {
      arp_table[i].ctime++;
 2018970:	00808174 	movhi	r2,517
 2018974:	10b38904 	addi	r2,r2,-12764
 2018978:	e0fffe17 	ldw	r3,-8(fp)
 201897c:	18c00624 	muli	r3,r3,24
 2018980:	10c5883a 	add	r2,r2,r3
 2018984:	10800484 	addi	r2,r2,18
 2018988:	1080000b 	ldhu	r2,0(r2)
 201898c:	10800044 	addi	r2,r2,1
 2018990:	1009883a 	mov	r4,r2
 2018994:	00808174 	movhi	r2,517
 2018998:	10b38904 	addi	r2,r2,-12764
 201899c:	e0fffe17 	ldw	r3,-8(fp)
 20189a0:	18c00624 	muli	r3,r3,24
 20189a4:	10c5883a 	add	r2,r2,r3
 20189a8:	10800484 	addi	r2,r2,18
 20189ac:	1100000d 	sth	r4,0(r2)
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 20189b0:	00808174 	movhi	r2,517
 20189b4:	10b38904 	addi	r2,r2,-12764
 20189b8:	e0fffe17 	ldw	r3,-8(fp)
 20189bc:	18c00624 	muli	r3,r3,24
 20189c0:	10c5883a 	add	r2,r2,r3
 20189c4:	10800484 	addi	r2,r2,18
 20189c8:	1080000b 	ldhu	r2,0(r2)
 20189cc:	10bfffcc 	andi	r2,r2,65535
 20189d0:	10804b28 	cmpgeui	r2,r2,300
 20189d4:	1000141e 	bne	r2,zero,2018a28 <etharp_tmr+0xf8>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 20189d8:	00808174 	movhi	r2,517
 20189dc:	10b38904 	addi	r2,r2,-12764
 20189e0:	e0fffe17 	ldw	r3,-8(fp)
 20189e4:	18c00624 	muli	r3,r3,24
 20189e8:	10c5883a 	add	r2,r2,r3
 20189ec:	10800504 	addi	r2,r2,20
 20189f0:	10800003 	ldbu	r2,0(r2)
#if ETHARP_SUPPORT_STATIC_ENTRIES
        && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
       ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 20189f4:	10803fcc 	andi	r2,r2,255
 20189f8:	10800058 	cmpnei	r2,r2,1
 20189fc:	10000d1e 	bne	r2,zero,2018a34 <etharp_tmr+0x104>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
 2018a00:	00808174 	movhi	r2,517
 2018a04:	10b38904 	addi	r2,r2,-12764
 2018a08:	e0fffe17 	ldw	r3,-8(fp)
 2018a0c:	18c00624 	muli	r3,r3,24
 2018a10:	10c5883a 	add	r2,r2,r3
 2018a14:	10800484 	addi	r2,r2,18
 2018a18:	1080000b 	ldhu	r2,0(r2)
        && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
       ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 2018a1c:	10bfffcc 	andi	r2,r2,65535
 2018a20:	10800170 	cmpltui	r2,r2,5
 2018a24:	1000031e 	bne	r2,zero,2018a34 <etharp_tmr+0x104>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %d.\n",
                                   arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
 2018a28:	e13ffe17 	ldw	r4,-8(fp)
 2018a2c:	20188940 	call	2018894 <etharp_free_entry>
 2018a30:	00003f06 	br	2018b30 <etharp_tmr+0x200>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 2018a34:	00808174 	movhi	r2,517
 2018a38:	10b38904 	addi	r2,r2,-12764
 2018a3c:	e0fffe17 	ldw	r3,-8(fp)
 2018a40:	18c00624 	muli	r3,r3,24
 2018a44:	10c5883a 	add	r2,r2,r3
 2018a48:	10800504 	addi	r2,r2,20
 2018a4c:	10800003 	ldbu	r2,0(r2)
 2018a50:	10803fcc 	andi	r2,r2,255
 2018a54:	108000d8 	cmpnei	r2,r2,3
 2018a58:	1000091e 	bne	r2,zero,2018a80 <etharp_tmr+0x150>
        /* Don't send more than one request every 2 seconds. */
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 2018a5c:	00808174 	movhi	r2,517
 2018a60:	10b38904 	addi	r2,r2,-12764
 2018a64:	e0fffe17 	ldw	r3,-8(fp)
 2018a68:	18c00624 	muli	r3,r3,24
 2018a6c:	10c5883a 	add	r2,r2,r3
 2018a70:	10800504 	addi	r2,r2,20
 2018a74:	00c00104 	movi	r3,4
 2018a78:	10c00005 	stb	r3,0(r2)
 2018a7c:	00002c06 	br	2018b30 <etharp_tmr+0x200>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 2018a80:	00808174 	movhi	r2,517
 2018a84:	10b38904 	addi	r2,r2,-12764
 2018a88:	e0fffe17 	ldw	r3,-8(fp)
 2018a8c:	18c00624 	muli	r3,r3,24
 2018a90:	10c5883a 	add	r2,r2,r3
 2018a94:	10800504 	addi	r2,r2,20
 2018a98:	10800003 	ldbu	r2,0(r2)
 2018a9c:	10803fcc 	andi	r2,r2,255
 2018aa0:	10800118 	cmpnei	r2,r2,4
 2018aa4:	1000091e 	bne	r2,zero,2018acc <etharp_tmr+0x19c>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 2018aa8:	00808174 	movhi	r2,517
 2018aac:	10b38904 	addi	r2,r2,-12764
 2018ab0:	e0fffe17 	ldw	r3,-8(fp)
 2018ab4:	18c00624 	muli	r3,r3,24
 2018ab8:	10c5883a 	add	r2,r2,r3
 2018abc:	10800504 	addi	r2,r2,20
 2018ac0:	00c00084 	movi	r3,2
 2018ac4:	10c00005 	stb	r3,0(r2)
 2018ac8:	00001906 	br	2018b30 <etharp_tmr+0x200>
      } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 2018acc:	00808174 	movhi	r2,517
 2018ad0:	10b38904 	addi	r2,r2,-12764
 2018ad4:	e0fffe17 	ldw	r3,-8(fp)
 2018ad8:	18c00624 	muli	r3,r3,24
 2018adc:	10c5883a 	add	r2,r2,r3
 2018ae0:	10800504 	addi	r2,r2,20
 2018ae4:	10800003 	ldbu	r2,0(r2)
 2018ae8:	10803fcc 	andi	r2,r2,255
 2018aec:	10800058 	cmpnei	r2,r2,1
 2018af0:	10000f1e 	bne	r2,zero,2018b30 <etharp_tmr+0x200>
        /* still pending, resend an ARP query */
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 2018af4:	00808174 	movhi	r2,517
 2018af8:	10b38904 	addi	r2,r2,-12764
 2018afc:	e0fffe17 	ldw	r3,-8(fp)
 2018b00:	18c00624 	muli	r3,r3,24
 2018b04:	10c5883a 	add	r2,r2,r3
 2018b08:	10800204 	addi	r2,r2,8
 2018b0c:	11000017 	ldw	r4,0(r2)
 2018b10:	e0bffe17 	ldw	r2,-8(fp)
 2018b14:	10800624 	muli	r2,r2,24
 2018b18:	10c00104 	addi	r3,r2,4
 2018b1c:	00808174 	movhi	r2,517
 2018b20:	10b38904 	addi	r2,r2,-12764
 2018b24:	1885883a 	add	r2,r3,r2
 2018b28:	100b883a 	mov	r5,r2
 2018b2c:	201a0f40 	call	201a0f4 <etharp_request>
{
  int i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 2018b30:	e0bffe17 	ldw	r2,-8(fp)
 2018b34:	10800044 	addi	r2,r2,1
 2018b38:	e0bffe15 	stw	r2,-8(fp)
 2018b3c:	e0bffe17 	ldw	r2,-8(fp)
 2018b40:	10800650 	cmplti	r2,r2,25
 2018b44:	103f801e 	bne	r2,zero,2018948 <__alt_mem_mem_0+0xfcff8948>
        /* still pending, resend an ARP query */
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
      }
    }
  }
}
 2018b48:	0001883a 	nop
 2018b4c:	e037883a 	mov	sp,fp
 2018b50:	dfc00117 	ldw	ra,4(sp)
 2018b54:	df000017 	ldw	fp,0(sp)
 2018b58:	dec00204 	addi	sp,sp,8
 2018b5c:	f800283a 	ret

02018b60 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s16_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif *netif)
{
 2018b60:	defff604 	addi	sp,sp,-40
 2018b64:	dfc00915 	stw	ra,36(sp)
 2018b68:	df000815 	stw	fp,32(sp)
 2018b6c:	df000804 	addi	fp,sp,32
 2018b70:	e13ffd15 	stw	r4,-12(fp)
 2018b74:	2805883a 	mov	r2,r5
 2018b78:	e1bfff15 	stw	r6,-4(fp)
 2018b7c:	e0bffe05 	stb	r2,-8(fp)
  s16_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 2018b80:	00800644 	movi	r2,25
 2018b84:	e0bff80d 	sth	r2,-32(fp)
 2018b88:	00800644 	movi	r2,25
 2018b8c:	e0bff88d 	sth	r2,-30(fp)
  s16_t empty = ARP_TABLE_SIZE;
 2018b90:	00800644 	movi	r2,25
 2018b94:	e0bff90d 	sth	r2,-28(fp)
  s16_t i = 0;
 2018b98:	e03ff98d 	sth	zero,-26(fp)
  /* oldest entry with packets on queue */
  s16_t old_queue = ARP_TABLE_SIZE;
 2018b9c:	00800644 	movi	r2,25
 2018ba0:	e0bffa0d 	sth	r2,-24(fp)
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 2018ba4:	e03ffa8d 	sth	zero,-22(fp)
 2018ba8:	e03ffb0d 	sth	zero,-20(fp)
 2018bac:	e03ffb8d 	sth	zero,-18(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 2018bb0:	e03ff98d 	sth	zero,-26(fp)
 2018bb4:	00007906 	br	2018d9c <etharp_find_entry+0x23c>
    u8_t state = arp_table[i].state;
 2018bb8:	e0fff98f 	ldh	r3,-26(fp)
 2018bbc:	00808174 	movhi	r2,517
 2018bc0:	10b38904 	addi	r2,r2,-12764
 2018bc4:	18c00624 	muli	r3,r3,24
 2018bc8:	10c5883a 	add	r2,r2,r3
 2018bcc:	10800504 	addi	r2,r2,20
 2018bd0:	10800003 	ldbu	r2,0(r2)
 2018bd4:	e0bffc05 	stb	r2,-16(fp)
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 2018bd8:	e0bff90f 	ldh	r2,-28(fp)
 2018bdc:	10800658 	cmpnei	r2,r2,25
 2018be0:	1000051e 	bne	r2,zero,2018bf8 <etharp_find_entry+0x98>
 2018be4:	e0bffc03 	ldbu	r2,-16(fp)
 2018be8:	1000031e 	bne	r2,zero,2018bf8 <etharp_find_entry+0x98>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
      /* remember first empty entry */
      empty = i;
 2018bec:	e0bff98b 	ldhu	r2,-26(fp)
 2018bf0:	e0bff90d 	sth	r2,-28(fp)
 2018bf4:	00006606 	br	2018d90 <etharp_find_entry+0x230>
    } else if (state != ETHARP_STATE_EMPTY) {
 2018bf8:	e0bffc03 	ldbu	r2,-16(fp)
 2018bfc:	10006426 	beq	r2,zero,2018d90 <etharp_find_entry+0x230>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
                  state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 2018c00:	e0bffd17 	ldw	r2,-12(fp)
 2018c04:	10001726 	beq	r2,zero,2018c64 <etharp_find_entry+0x104>
 2018c08:	e0bffd17 	ldw	r2,-12(fp)
 2018c0c:	10c00017 	ldw	r3,0(r2)
 2018c10:	e13ff98f 	ldh	r4,-26(fp)
 2018c14:	00808174 	movhi	r2,517
 2018c18:	10b38904 	addi	r2,r2,-12764
 2018c1c:	21000624 	muli	r4,r4,24
 2018c20:	1105883a 	add	r2,r2,r4
 2018c24:	10800104 	addi	r2,r2,4
 2018c28:	10800017 	ldw	r2,0(r2)
 2018c2c:	18800d1e 	bne	r3,r2,2018c64 <etharp_find_entry+0x104>
#if ETHARP_TABLE_MATCH_NETIF
          && ((netif == NULL) || (netif == arp_table[i].netif))
 2018c30:	e0bfff17 	ldw	r2,-4(fp)
 2018c34:	10000926 	beq	r2,zero,2018c5c <etharp_find_entry+0xfc>
 2018c38:	e0fff98f 	ldh	r3,-26(fp)
 2018c3c:	00808174 	movhi	r2,517
 2018c40:	10b38904 	addi	r2,r2,-12764
 2018c44:	18c00624 	muli	r3,r3,24
 2018c48:	10c5883a 	add	r2,r2,r3
 2018c4c:	10800204 	addi	r2,r2,8
 2018c50:	10c00017 	ldw	r3,0(r2)
 2018c54:	e0bfff17 	ldw	r2,-4(fp)
 2018c58:	1880021e 	bne	r3,r2,2018c64 <etharp_find_entry+0x104>
#endif /* ETHARP_TABLE_MATCH_NETIF */
         ) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %d\n", (int)i));
        /* found exact IP address match, simply bail out */
        return i;
 2018c5c:	e0bff98b 	ldhu	r2,-26(fp)
 2018c60:	00009406 	br	2018eb4 <etharp_find_entry+0x354>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 2018c64:	e0bffc03 	ldbu	r2,-16(fp)
 2018c68:	10800058 	cmpnei	r2,r2,1
 2018c6c:	1000311e 	bne	r2,zero,2018d34 <etharp_find_entry+0x1d4>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 2018c70:	e0fff98f 	ldh	r3,-26(fp)
 2018c74:	00808174 	movhi	r2,517
 2018c78:	10b38904 	addi	r2,r2,-12764
 2018c7c:	18c00624 	muli	r3,r3,24
 2018c80:	10c5883a 	add	r2,r2,r3
 2018c84:	10800017 	ldw	r2,0(r2)
 2018c88:	10001526 	beq	r2,zero,2018ce0 <etharp_find_entry+0x180>
          if (arp_table[i].ctime >= age_queue) {
 2018c8c:	e0fff98f 	ldh	r3,-26(fp)
 2018c90:	00808174 	movhi	r2,517
 2018c94:	10b38904 	addi	r2,r2,-12764
 2018c98:	18c00624 	muli	r3,r3,24
 2018c9c:	10c5883a 	add	r2,r2,r3
 2018ca0:	10800484 	addi	r2,r2,18
 2018ca4:	1080000b 	ldhu	r2,0(r2)
 2018ca8:	10ffffcc 	andi	r3,r2,65535
 2018cac:	e0bffa8b 	ldhu	r2,-22(fp)
 2018cb0:	18803736 	bltu	r3,r2,2018d90 <etharp_find_entry+0x230>
            old_queue = i;
 2018cb4:	e0bff98b 	ldhu	r2,-26(fp)
 2018cb8:	e0bffa0d 	sth	r2,-24(fp)
            age_queue = arp_table[i].ctime;
 2018cbc:	e0fff98f 	ldh	r3,-26(fp)
 2018cc0:	00808174 	movhi	r2,517
 2018cc4:	10b38904 	addi	r2,r2,-12764
 2018cc8:	18c00624 	muli	r3,r3,24
 2018ccc:	10c5883a 	add	r2,r2,r3
 2018cd0:	10800484 	addi	r2,r2,18
 2018cd4:	1080000b 	ldhu	r2,0(r2)
 2018cd8:	e0bffa8d 	sth	r2,-22(fp)
 2018cdc:	00002c06 	br	2018d90 <etharp_find_entry+0x230>
          }
        } else
          /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 2018ce0:	e0fff98f 	ldh	r3,-26(fp)
 2018ce4:	00808174 	movhi	r2,517
 2018ce8:	10b38904 	addi	r2,r2,-12764
 2018cec:	18c00624 	muli	r3,r3,24
 2018cf0:	10c5883a 	add	r2,r2,r3
 2018cf4:	10800484 	addi	r2,r2,18
 2018cf8:	1080000b 	ldhu	r2,0(r2)
 2018cfc:	10ffffcc 	andi	r3,r2,65535
 2018d00:	e0bffb0b 	ldhu	r2,-20(fp)
 2018d04:	18802236 	bltu	r3,r2,2018d90 <etharp_find_entry+0x230>
            old_pending = i;
 2018d08:	e0bff98b 	ldhu	r2,-26(fp)
 2018d0c:	e0bff80d 	sth	r2,-32(fp)
            age_pending = arp_table[i].ctime;
 2018d10:	e0fff98f 	ldh	r3,-26(fp)
 2018d14:	00808174 	movhi	r2,517
 2018d18:	10b38904 	addi	r2,r2,-12764
 2018d1c:	18c00624 	muli	r3,r3,24
 2018d20:	10c5883a 	add	r2,r2,r3
 2018d24:	10800484 	addi	r2,r2,18
 2018d28:	1080000b 	ldhu	r2,0(r2)
 2018d2c:	e0bffb0d 	sth	r2,-20(fp)
 2018d30:	00001706 	br	2018d90 <etharp_find_entry+0x230>
          }
        }
        /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 2018d34:	e0bffc03 	ldbu	r2,-16(fp)
 2018d38:	108000b0 	cmpltui	r2,r2,2
 2018d3c:	1000141e 	bne	r2,zero,2018d90 <etharp_find_entry+0x230>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 2018d40:	e0fff98f 	ldh	r3,-26(fp)
 2018d44:	00808174 	movhi	r2,517
 2018d48:	10b38904 	addi	r2,r2,-12764
 2018d4c:	18c00624 	muli	r3,r3,24
 2018d50:	10c5883a 	add	r2,r2,r3
 2018d54:	10800484 	addi	r2,r2,18
 2018d58:	1080000b 	ldhu	r2,0(r2)
 2018d5c:	10ffffcc 	andi	r3,r2,65535
 2018d60:	e0bffb8b 	ldhu	r2,-18(fp)
 2018d64:	18800a36 	bltu	r3,r2,2018d90 <etharp_find_entry+0x230>
            old_stable = i;
 2018d68:	e0bff98b 	ldhu	r2,-26(fp)
 2018d6c:	e0bff88d 	sth	r2,-30(fp)
            age_stable = arp_table[i].ctime;
 2018d70:	e0fff98f 	ldh	r3,-26(fp)
 2018d74:	00808174 	movhi	r2,517
 2018d78:	10b38904 	addi	r2,r2,-12764
 2018d7c:	18c00624 	muli	r3,r3,24
 2018d80:	10c5883a 	add	r2,r2,r3
 2018d84:	10800484 	addi	r2,r2,18
 2018d88:	1080000b 	ldhu	r2,0(r2)
 2018d8c:	e0bffb8d 	sth	r2,-18(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 2018d90:	e0bff98b 	ldhu	r2,-26(fp)
 2018d94:	10800044 	addi	r2,r2,1
 2018d98:	e0bff98d 	sth	r2,-26(fp)
 2018d9c:	e0bff98f 	ldh	r2,-26(fp)
 2018da0:	10800650 	cmplti	r2,r2,25
 2018da4:	103f841e 	bne	r2,zero,2018bb8 <__alt_mem_mem_0+0xfcff8bb8>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 2018da8:	e0bffe03 	ldbu	r2,-8(fp)
 2018dac:	1080008c 	andi	r2,r2,2
 2018db0:	1000061e 	bne	r2,zero,2018dcc <etharp_find_entry+0x26c>
 2018db4:	e0bff90f 	ldh	r2,-28(fp)
 2018db8:	10800658 	cmpnei	r2,r2,25
 2018dbc:	1000051e 	bne	r2,zero,2018dd4 <etharp_find_entry+0x274>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 2018dc0:	e0bffe03 	ldbu	r2,-8(fp)
 2018dc4:	1080004c 	andi	r2,r2,1
 2018dc8:	1000021e 	bne	r2,zero,2018dd4 <etharp_find_entry+0x274>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s16_t)ERR_MEM;
 2018dcc:	00bfffc4 	movi	r2,-1
 2018dd0:	00003806 	br	2018eb4 <etharp_find_entry+0x354>
   *
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 2018dd4:	e0bff90f 	ldh	r2,-28(fp)
 2018dd8:	10800648 	cmpgei	r2,r2,25
 2018ddc:	1000031e 	bne	r2,zero,2018dec <etharp_find_entry+0x28c>
    i = empty;
 2018de0:	e0bff90b 	ldhu	r2,-28(fp)
 2018de4:	e0bff98d 	sth	r2,-26(fp)
 2018de8:	00001706 	br	2018e48 <etharp_find_entry+0x2e8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %d\n", (int)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
 2018dec:	e0bff88f 	ldh	r2,-30(fp)
 2018df0:	10800648 	cmpgei	r2,r2,25
 2018df4:	1000031e 	bne	r2,zero,2018e04 <etharp_find_entry+0x2a4>
      /* recycle oldest stable*/
      i = old_stable;
 2018df8:	e0bff88b 	ldhu	r2,-30(fp)
 2018dfc:	e0bff98d 	sth	r2,-26(fp)
 2018e00:	00000e06 	br	2018e3c <etharp_find_entry+0x2dc>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %d\n", (int)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
      /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
 2018e04:	e0bff80f 	ldh	r2,-32(fp)
 2018e08:	10800648 	cmpgei	r2,r2,25
 2018e0c:	1000031e 	bne	r2,zero,2018e1c <etharp_find_entry+0x2bc>
      /* recycle oldest pending */
      i = old_pending;
 2018e10:	e0bff80b 	ldhu	r2,-32(fp)
 2018e14:	e0bff98d 	sth	r2,-26(fp)
 2018e18:	00000806 	br	2018e3c <etharp_find_entry+0x2dc>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %d (without queue)\n", (int)i));
      /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
 2018e1c:	e0bffa0f 	ldh	r2,-24(fp)
 2018e20:	10800648 	cmpgei	r2,r2,25
 2018e24:	1000031e 	bne	r2,zero,2018e34 <etharp_find_entry+0x2d4>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
 2018e28:	e0bffa0b 	ldhu	r2,-24(fp)
 2018e2c:	e0bff98d 	sth	r2,-26(fp)
 2018e30:	00000206 	br	2018e3c <etharp_find_entry+0x2dc>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %d, freeing packet queue %p\n", (int)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s16_t)ERR_MEM;
 2018e34:	00bfffc4 	movi	r2,-1
 2018e38:	00001e06 	br	2018eb4 <etharp_find_entry+0x354>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
 2018e3c:	e0bff98f 	ldh	r2,-26(fp)
 2018e40:	1009883a 	mov	r4,r2
 2018e44:	20188940 	call	2018894 <etharp_free_entry>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
              arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 2018e48:	e0bffd17 	ldw	r2,-12(fp)
 2018e4c:	10000926 	beq	r2,zero,2018e74 <etharp_find_entry+0x314>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 2018e50:	e13ff98f 	ldh	r4,-26(fp)
 2018e54:	e0bffd17 	ldw	r2,-12(fp)
 2018e58:	10c00017 	ldw	r3,0(r2)
 2018e5c:	00808174 	movhi	r2,517
 2018e60:	10b38904 	addi	r2,r2,-12764
 2018e64:	21000624 	muli	r4,r4,24
 2018e68:	1105883a 	add	r2,r2,r4
 2018e6c:	10800104 	addi	r2,r2,4
 2018e70:	10c00015 	stw	r3,0(r2)
  }
  arp_table[i].ctime = 0;
 2018e74:	e0fff98f 	ldh	r3,-26(fp)
 2018e78:	00808174 	movhi	r2,517
 2018e7c:	10b38904 	addi	r2,r2,-12764
 2018e80:	18c00624 	muli	r3,r3,24
 2018e84:	10c5883a 	add	r2,r2,r3
 2018e88:	10800484 	addi	r2,r2,18
 2018e8c:	1000000d 	sth	zero,0(r2)
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
 2018e90:	e0fff98f 	ldh	r3,-26(fp)
 2018e94:	00808174 	movhi	r2,517
 2018e98:	10b38904 	addi	r2,r2,-12764
 2018e9c:	18c00624 	muli	r3,r3,24
 2018ea0:	10c5883a 	add	r2,r2,r3
 2018ea4:	10800204 	addi	r2,r2,8
 2018ea8:	e0ffff17 	ldw	r3,-4(fp)
 2018eac:	10c00015 	stw	r3,0(r2)
#endif /* ETHARP_TABLE_MATCH_NETIF */
  return (s16_t)i;
 2018eb0:	e0bff98b 	ldhu	r2,-26(fp)
}
 2018eb4:	e037883a 	mov	sp,fp
 2018eb8:	dfc00117 	ldw	ra,4(sp)
 2018ebc:	df000017 	ldw	fp,0(sp)
 2018ec0:	dec00204 	addi	sp,sp,8
 2018ec4:	f800283a 	ret

02018ec8 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 2018ec8:	defff604 	addi	sp,sp,-40
 2018ecc:	dfc00915 	stw	ra,36(sp)
 2018ed0:	df000815 	stw	fp,32(sp)
 2018ed4:	df000804 	addi	fp,sp,32
 2018ed8:	e13ffc15 	stw	r4,-16(fp)
 2018edc:	e17ffd15 	stw	r5,-12(fp)
 2018ee0:	e1bffe15 	stw	r6,-8(fp)
 2018ee4:	3805883a 	mov	r2,r7
 2018ee8:	e0bfff05 	stb	r2,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
              ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
              (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
              (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
 2018eec:	e0bffd17 	ldw	r2,-12(fp)
 2018ef0:	10000f26 	beq	r2,zero,2018f30 <etharp_update_arp_entry+0x68>
 2018ef4:	e0bffd17 	ldw	r2,-12(fp)
 2018ef8:	10800017 	ldw	r2,0(r2)
 2018efc:	10000c26 	beq	r2,zero,2018f30 <etharp_update_arp_entry+0x68>
      ip4_addr_isbroadcast(ipaddr, netif) ||
 2018f00:	e0bffd17 	ldw	r2,-12(fp)
 2018f04:	10800017 	ldw	r2,0(r2)
 2018f08:	e17ffc17 	ldw	r5,-16(fp)
 2018f0c:	1009883a 	mov	r4,r2
 2018f10:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
              ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
              (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
              (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
 2018f14:	10803fcc 	andi	r2,r2,255
 2018f18:	1000051e 	bne	r2,zero,2018f30 <etharp_update_arp_entry+0x68>
      ip4_addr_isbroadcast(ipaddr, netif) ||
      ip4_addr_ismulticast(ipaddr)) {
 2018f1c:	e0bffd17 	ldw	r2,-12(fp)
 2018f20:	10800017 	ldw	r2,0(r2)
 2018f24:	10803c0c 	andi	r2,r2,240
              ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
              (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
              (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
      ip4_addr_isbroadcast(ipaddr, netif) ||
 2018f28:	10803818 	cmpnei	r2,r2,224
 2018f2c:	1000021e 	bne	r2,zero,2018f38 <etharp_update_arp_entry+0x70>
      ip4_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 2018f30:	00bffc04 	movi	r2,-16
 2018f34:	00005406 	br	2019088 <etharp_update_arp_entry+0x1c0>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags, netif);
 2018f38:	e0bfff03 	ldbu	r2,-4(fp)
 2018f3c:	e1bffc17 	ldw	r6,-16(fp)
 2018f40:	100b883a 	mov	r5,r2
 2018f44:	e13ffd17 	ldw	r4,-12(fp)
 2018f48:	2018b600 	call	2018b60 <etharp_find_entry>
 2018f4c:	e0bff90d 	sth	r2,-28(fp)
  /* bail out if no entry could be found */
  if (i < 0) {
 2018f50:	e0bff90f 	ldh	r2,-28(fp)
 2018f54:	1000020e 	bge	r2,zero,2018f60 <etharp_update_arp_entry+0x98>
    return (err_t)i;
 2018f58:	e0bff90b 	ldhu	r2,-28(fp)
 2018f5c:	00004a06 	br	2019088 <etharp_update_arp_entry+0x1c0>
    return ERR_VAL;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 2018f60:	e0fff90f 	ldh	r3,-28(fp)
 2018f64:	00808174 	movhi	r2,517
 2018f68:	10b38904 	addi	r2,r2,-12764
 2018f6c:	18c00624 	muli	r3,r3,24
 2018f70:	10c5883a 	add	r2,r2,r3
 2018f74:	10800504 	addi	r2,r2,20
 2018f78:	00c00084 	movi	r3,2
 2018f7c:	10c00005 	stb	r3,0(r2)
  }

  /* record network interface */
  arp_table[i].netif = netif;
 2018f80:	e0fff90f 	ldh	r3,-28(fp)
 2018f84:	00808174 	movhi	r2,517
 2018f88:	10b38904 	addi	r2,r2,-12764
 2018f8c:	18c00624 	muli	r3,r3,24
 2018f90:	10c5883a 	add	r2,r2,r3
 2018f94:	10800204 	addi	r2,r2,8
 2018f98:	e0fffc17 	ldw	r3,-16(fp)
 2018f9c:	10c00015 	stw	r3,0(r2)
  /* insert in SNMP ARP index tree */
  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", i));
  /* update address */
  SMEMCPY(&arp_table[i].ethaddr, ethaddr, ETH_HWADDR_LEN);
 2018fa0:	e0bff90f 	ldh	r2,-28(fp)
 2018fa4:	10800624 	muli	r2,r2,24
 2018fa8:	10c00304 	addi	r3,r2,12
 2018fac:	00808174 	movhi	r2,517
 2018fb0:	10b38904 	addi	r2,r2,-12764
 2018fb4:	1885883a 	add	r2,r3,r2
 2018fb8:	01800184 	movi	r6,6
 2018fbc:	e17ffe17 	ldw	r5,-8(fp)
 2018fc0:	1009883a 	mov	r4,r2
 2018fc4:	2005e580 	call	2005e58 <memcpy>
  /* reset time stamp */
  arp_table[i].ctime = 0;
 2018fc8:	e0fff90f 	ldh	r3,-28(fp)
 2018fcc:	00808174 	movhi	r2,517
 2018fd0:	10b38904 	addi	r2,r2,-12764
 2018fd4:	18c00624 	muli	r3,r3,24
 2018fd8:	10c5883a 	add	r2,r2,r3
 2018fdc:	10800484 	addi	r2,r2,18
 2018fe0:	1000000d 	sth	zero,0(r2)
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 2018fe4:	00002006 	br	2019068 <etharp_update_arp_entry+0x1a0>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
 2018fe8:	e0fff90f 	ldh	r3,-28(fp)
 2018fec:	00808174 	movhi	r2,517
 2018ff0:	10b38904 	addi	r2,r2,-12764
 2018ff4:	18c00624 	muli	r3,r3,24
 2018ff8:	10c5883a 	add	r2,r2,r3
 2018ffc:	10800017 	ldw	r2,0(r2)
 2019000:	e0bffa15 	stw	r2,-24(fp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
 2019004:	e13ff90f 	ldh	r4,-28(fp)
 2019008:	e0bffa17 	ldw	r2,-24(fp)
 201900c:	10c00017 	ldw	r3,0(r2)
 2019010:	00808174 	movhi	r2,517
 2019014:	10b38904 	addi	r2,r2,-12764
 2019018:	21000624 	muli	r4,r4,24
 201901c:	1105883a 	add	r2,r2,r4
 2019020:	10c00015 	stw	r3,0(r2)
    /* get the packet pointer */
    p = q->p;
 2019024:	e0bffa17 	ldw	r2,-24(fp)
 2019028:	10800117 	ldw	r2,4(r2)
 201902c:	e0bffb15 	stw	r2,-20(fp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
 2019030:	e17ffa17 	ldw	r5,-24(fp)
 2019034:	010002c4 	movi	r4,11
 2019038:	201b9640 	call	201b964 <memp_free>
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr, ETHTYPE_IP);
 201903c:	e0bffc17 	ldw	r2,-16(fp)
 2019040:	10c00d84 	addi	r3,r2,54
 2019044:	00820004 	movi	r2,2048
 2019048:	d8800015 	stw	r2,0(sp)
 201904c:	e1fffe17 	ldw	r7,-8(fp)
 2019050:	180d883a 	mov	r6,r3
 2019054:	e17ffb17 	ldw	r5,-20(fp)
 2019058:	e13ffc17 	ldw	r4,-16(fp)
 201905c:	202afa40 	call	202afa4 <ethernet_output>
    /* free the queued IP packet */
    pbuf_free(p);
 2019060:	e13ffb17 	ldw	r4,-20(fp)
 2019064:	201d2f40 	call	201d2f4 <pbuf_free>
  SMEMCPY(&arp_table[i].ethaddr, ethaddr, ETH_HWADDR_LEN);
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 2019068:	e0fff90f 	ldh	r3,-28(fp)
 201906c:	00808174 	movhi	r2,517
 2019070:	10b38904 	addi	r2,r2,-12764
 2019074:	18c00624 	muli	r3,r3,24
 2019078:	10c5883a 	add	r2,r2,r3
 201907c:	10800017 	ldw	r2,0(r2)
 2019080:	103fd91e 	bne	r2,zero,2018fe8 <__alt_mem_mem_0+0xfcff8fe8>
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr, ETHTYPE_IP);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
 2019084:	0005883a 	mov	r2,zero
}
 2019088:	e037883a 	mov	sp,fp
 201908c:	dfc00117 	ldw	ra,4(sp)
 2019090:	df000017 	ldw	fp,0(sp)
 2019094:	dec00204 	addi	sp,sp,8
 2019098:	f800283a 	ret

0201909c <etharp_cleanup_netif>:
 *
 * @param netif points to a network interface
 */
void
etharp_cleanup_netif(struct netif *netif)
{
 201909c:	defffb04 	addi	sp,sp,-20
 20190a0:	dfc00415 	stw	ra,16(sp)
 20190a4:	df000315 	stw	fp,12(sp)
 20190a8:	df000304 	addi	fp,sp,12
 20190ac:	e13fff15 	stw	r4,-4(fp)
  int i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 20190b0:	e03ffd15 	stw	zero,-12(fp)
 20190b4:	00001806 	br	2019118 <etharp_cleanup_netif+0x7c>
    u8_t state = arp_table[i].state;
 20190b8:	00808174 	movhi	r2,517
 20190bc:	10b38904 	addi	r2,r2,-12764
 20190c0:	e0fffd17 	ldw	r3,-12(fp)
 20190c4:	18c00624 	muli	r3,r3,24
 20190c8:	10c5883a 	add	r2,r2,r3
 20190cc:	10800504 	addi	r2,r2,20
 20190d0:	10800003 	ldbu	r2,0(r2)
 20190d4:	e0bffe05 	stb	r2,-8(fp)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 20190d8:	e0bffe03 	ldbu	r2,-8(fp)
 20190dc:	10000b26 	beq	r2,zero,201910c <etharp_cleanup_netif+0x70>
 20190e0:	00808174 	movhi	r2,517
 20190e4:	10b38904 	addi	r2,r2,-12764
 20190e8:	e0fffd17 	ldw	r3,-12(fp)
 20190ec:	18c00624 	muli	r3,r3,24
 20190f0:	10c5883a 	add	r2,r2,r3
 20190f4:	10800204 	addi	r2,r2,8
 20190f8:	10c00017 	ldw	r3,0(r2)
 20190fc:	e0bfff17 	ldw	r2,-4(fp)
 2019100:	1880021e 	bne	r3,r2,201910c <etharp_cleanup_netif+0x70>
      etharp_free_entry(i);
 2019104:	e13ffd17 	ldw	r4,-12(fp)
 2019108:	20188940 	call	2018894 <etharp_free_entry>
void
etharp_cleanup_netif(struct netif *netif)
{
  int i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 201910c:	e0bffd17 	ldw	r2,-12(fp)
 2019110:	10800044 	addi	r2,r2,1
 2019114:	e0bffd15 	stw	r2,-12(fp)
 2019118:	e0bffd17 	ldw	r2,-12(fp)
 201911c:	10800650 	cmplti	r2,r2,25
 2019120:	103fe51e 	bne	r2,zero,20190b8 <__alt_mem_mem_0+0xfcff90b8>
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
 2019124:	0001883a 	nop
 2019128:	e037883a 	mov	sp,fp
 201912c:	dfc00117 	ldw	ra,4(sp)
 2019130:	df000017 	ldw	fp,0(sp)
 2019134:	dec00204 	addi	sp,sp,8
 2019138:	f800283a 	ret

0201913c <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
ssize_t
etharp_find_addr(struct netif *netif, const ip4_addr_t *ipaddr,
                 struct eth_addr **eth_ret, const ip4_addr_t **ip_ret)
{
 201913c:	defff904 	addi	sp,sp,-28
 2019140:	dfc00615 	stw	ra,24(sp)
 2019144:	df000515 	stw	fp,20(sp)
 2019148:	df000504 	addi	fp,sp,20
 201914c:	e13ffc15 	stw	r4,-16(fp)
 2019150:	e17ffd15 	stw	r5,-12(fp)
 2019154:	e1bffe15 	stw	r6,-8(fp)
 2019158:	e1ffff15 	stw	r7,-4(fp)
  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
              eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY, netif);
 201915c:	e1bffc17 	ldw	r6,-16(fp)
 2019160:	01400084 	movi	r5,2
 2019164:	e13ffd17 	ldw	r4,-12(fp)
 2019168:	2018b600 	call	2018b60 <etharp_find_entry>
 201916c:	e0bffb0d 	sth	r2,-20(fp)
  if ((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 2019170:	e0bffb0f 	ldh	r2,-20(fp)
 2019174:	10001c16 	blt	r2,zero,20191e8 <etharp_find_addr+0xac>
 2019178:	e0fffb0f 	ldh	r3,-20(fp)
 201917c:	00808174 	movhi	r2,517
 2019180:	10b38904 	addi	r2,r2,-12764
 2019184:	18c00624 	muli	r3,r3,24
 2019188:	10c5883a 	add	r2,r2,r3
 201918c:	10800504 	addi	r2,r2,20
 2019190:	10800003 	ldbu	r2,0(r2)
 2019194:	10803fcc 	andi	r2,r2,255
 2019198:	108000b0 	cmpltui	r2,r2,2
 201919c:	1000121e 	bne	r2,zero,20191e8 <etharp_find_addr+0xac>
    *eth_ret = &arp_table[i].ethaddr;
 20191a0:	e0bffb0f 	ldh	r2,-20(fp)
 20191a4:	10800624 	muli	r2,r2,24
 20191a8:	10c00304 	addi	r3,r2,12
 20191ac:	00808174 	movhi	r2,517
 20191b0:	10b38904 	addi	r2,r2,-12764
 20191b4:	1887883a 	add	r3,r3,r2
 20191b8:	e0bffe17 	ldw	r2,-8(fp)
 20191bc:	10c00015 	stw	r3,0(r2)
    *ip_ret = &arp_table[i].ipaddr;
 20191c0:	e0bffb0f 	ldh	r2,-20(fp)
 20191c4:	10800624 	muli	r2,r2,24
 20191c8:	10c00104 	addi	r3,r2,4
 20191cc:	00808174 	movhi	r2,517
 20191d0:	10b38904 	addi	r2,r2,-12764
 20191d4:	1887883a 	add	r3,r3,r2
 20191d8:	e0bfff17 	ldw	r2,-4(fp)
 20191dc:	10c00015 	stw	r3,0(r2)
    return i;
 20191e0:	e0bffb0f 	ldh	r2,-20(fp)
 20191e4:	00000106 	br	20191ec <etharp_find_addr+0xb0>
  }
  return -1;
 20191e8:	00bfffc4 	movi	r2,-1
}
 20191ec:	e037883a 	mov	sp,fp
 20191f0:	dfc00117 	ldw	ra,4(sp)
 20191f4:	df000017 	ldw	fp,0(sp)
 20191f8:	dec00204 	addi	sp,sp,8
 20191fc:	f800283a 	ret

02019200 <etharp_get_entry>:
 * @param eth_ret return value: ETH address
 * @return 1 on valid index, 0 otherwise
 */
int
etharp_get_entry(size_t i, ip4_addr_t **ipaddr, struct netif **netif, struct eth_addr **eth_ret)
{
 2019200:	defffb04 	addi	sp,sp,-20
 2019204:	df000415 	stw	fp,16(sp)
 2019208:	df000404 	addi	fp,sp,16
 201920c:	e13ffc15 	stw	r4,-16(fp)
 2019210:	e17ffd15 	stw	r5,-12(fp)
 2019214:	e1bffe15 	stw	r6,-8(fp)
 2019218:	e1ffff15 	stw	r7,-4(fp)
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);

  if ((i < ARP_TABLE_SIZE) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 201921c:	e0bffc17 	ldw	r2,-16(fp)
 2019220:	10800668 	cmpgeui	r2,r2,25
 2019224:	1000251e 	bne	r2,zero,20192bc <etharp_get_entry+0xbc>
 2019228:	00808174 	movhi	r2,517
 201922c:	10b38904 	addi	r2,r2,-12764
 2019230:	e0fffc17 	ldw	r3,-16(fp)
 2019234:	18c00624 	muli	r3,r3,24
 2019238:	10c5883a 	add	r2,r2,r3
 201923c:	10800504 	addi	r2,r2,20
 2019240:	10800003 	ldbu	r2,0(r2)
 2019244:	10803fcc 	andi	r2,r2,255
 2019248:	108000b0 	cmpltui	r2,r2,2
 201924c:	10001b1e 	bne	r2,zero,20192bc <etharp_get_entry+0xbc>
    *ipaddr  = &arp_table[i].ipaddr;
 2019250:	e0bffc17 	ldw	r2,-16(fp)
 2019254:	10800624 	muli	r2,r2,24
 2019258:	10c00104 	addi	r3,r2,4
 201925c:	00808174 	movhi	r2,517
 2019260:	10b38904 	addi	r2,r2,-12764
 2019264:	1887883a 	add	r3,r3,r2
 2019268:	e0bffd17 	ldw	r2,-12(fp)
 201926c:	10c00015 	stw	r3,0(r2)
    *netif   = arp_table[i].netif;
 2019270:	00808174 	movhi	r2,517
 2019274:	10b38904 	addi	r2,r2,-12764
 2019278:	e0fffc17 	ldw	r3,-16(fp)
 201927c:	18c00624 	muli	r3,r3,24
 2019280:	10c5883a 	add	r2,r2,r3
 2019284:	10800204 	addi	r2,r2,8
 2019288:	10c00017 	ldw	r3,0(r2)
 201928c:	e0bffe17 	ldw	r2,-8(fp)
 2019290:	10c00015 	stw	r3,0(r2)
    *eth_ret = &arp_table[i].ethaddr;
 2019294:	e0bffc17 	ldw	r2,-16(fp)
 2019298:	10800624 	muli	r2,r2,24
 201929c:	10c00304 	addi	r3,r2,12
 20192a0:	00808174 	movhi	r2,517
 20192a4:	10b38904 	addi	r2,r2,-12764
 20192a8:	1887883a 	add	r3,r3,r2
 20192ac:	e0bfff17 	ldw	r2,-4(fp)
 20192b0:	10c00015 	stw	r3,0(r2)
    return 1;
 20192b4:	00800044 	movi	r2,1
 20192b8:	00000106 	br	20192c0 <etharp_get_entry+0xc0>
  } else {
    return 0;
 20192bc:	0005883a 	mov	r2,zero
  }
}
 20192c0:	e037883a 	mov	sp,fp
 20192c4:	df000017 	ldw	fp,0(sp)
 20192c8:	dec00104 	addi	sp,sp,4
 20192cc:	f800283a 	ret

020192d0 <etharp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_input(struct pbuf *p, struct netif *netif)
{
 20192d0:	defff404 	addi	sp,sp,-48
 20192d4:	dfc00b15 	stw	ra,44(sp)
 20192d8:	df000a15 	stw	fp,40(sp)
 20192dc:	df000a04 	addi	fp,sp,40
 20192e0:	e13ffe15 	stw	r4,-8(fp)
 20192e4:	e17fff15 	stw	r5,-4(fp)
  ip4_addr_t sipaddr, dipaddr;
  u8_t for_us, from_us;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 20192e8:	e0bfff17 	ldw	r2,-4(fp)
 20192ec:	10009626 	beq	r2,zero,2019548 <etharp_input+0x278>

  hdr = (struct etharp_hdr *)p->payload;
 20192f0:	e0bffe17 	ldw	r2,-8(fp)
 20192f4:	10800117 	ldw	r2,4(r2)
 20192f8:	e0bffb15 	stw	r2,-20(fp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
 20192fc:	e0bffb17 	ldw	r2,-20(fp)
 2019300:	10c00003 	ldbu	r3,0(r2)
 2019304:	10800043 	ldbu	r2,1(r2)
 2019308:	1004923a 	slli	r2,r2,8
 201930c:	10c4b03a 	or	r2,r2,r3
 2019310:	10bfffcc 	andi	r2,r2,65535
 2019314:	10804018 	cmpnei	r2,r2,256
 2019318:	1000121e 	bne	r2,zero,2019364 <etharp_input+0x94>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 201931c:	e0bffb17 	ldw	r2,-20(fp)
 2019320:	10800103 	ldbu	r2,4(r2)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);

  hdr = (struct etharp_hdr *)p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
 2019324:	10803fcc 	andi	r2,r2,255
 2019328:	10800198 	cmpnei	r2,r2,6
 201932c:	10000d1e 	bne	r2,zero,2019364 <etharp_input+0x94>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 2019330:	e0bffb17 	ldw	r2,-20(fp)
 2019334:	10800143 	ldbu	r2,5(r2)

  hdr = (struct etharp_hdr *)p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 2019338:	10803fcc 	andi	r2,r2,255
 201933c:	10800118 	cmpnei	r2,r2,4
 2019340:	1000081e 	bne	r2,zero,2019364 <etharp_input+0x94>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 2019344:	e0bffb17 	ldw	r2,-20(fp)
 2019348:	10c00083 	ldbu	r3,2(r2)
 201934c:	108000c3 	ldbu	r2,3(r2)
 2019350:	1004923a 	slli	r2,r2,8
 2019354:	10c4b03a 	or	r2,r2,r3
  hdr = (struct etharp_hdr *)p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETH_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 2019358:	10bfffcc 	andi	r2,r2,65535
 201935c:	10800220 	cmpeqi	r2,r2,8
 2019360:	1000111e 	bne	r2,zero,20193a8 <etharp_input+0xd8>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                ("etharp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
                 hdr->hwtype, (u16_t)hdr->hwlen, hdr->proto, (u16_t)hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
 2019364:	008085f4 	movhi	r2,535
 2019368:	10bd8204 	addi	r2,r2,-2552
 201936c:	10801417 	ldw	r2,80(r2)
 2019370:	10c00044 	addi	r3,r2,1
 2019374:	008085f4 	movhi	r2,535
 2019378:	10bd8204 	addi	r2,r2,-2552
 201937c:	10c01415 	stw	r3,80(r2)
    ETHARP_STATS_INC(etharp.drop);
 2019380:	008085f4 	movhi	r2,535
 2019384:	10bd8204 	addi	r2,r2,-2552
 2019388:	10800f17 	ldw	r2,60(r2)
 201938c:	10c00044 	addi	r3,r2,1
 2019390:	008085f4 	movhi	r2,535
 2019394:	10bd8204 	addi	r2,r2,-2552
 2019398:	10c00f15 	stw	r3,60(r2)
    pbuf_free(p);
 201939c:	e13ffe17 	ldw	r4,-8(fp)
 20193a0:	201d2f40 	call	201d2f4 <pbuf_free>
    return;
 20193a4:	00006906 	br	201954c <etharp_input+0x27c>
  }
  ETHARP_STATS_INC(etharp.recv);
 20193a8:	008085f4 	movhi	r2,535
 20193ac:	10bd8204 	addi	r2,r2,-2552
 20193b0:	10800d17 	ldw	r2,52(r2)
 20193b4:	10c00044 	addi	r3,r2,1
 20193b8:	008085f4 	movhi	r2,535
 20193bc:	10bd8204 	addi	r2,r2,-2552
 20193c0:	10c00d15 	stw	r3,52(r2)
   * detect collisions.
   * acd_arp_reply ensures the detection of conflicts. It will handle possible
   * defending or retreating and will make sure a new IP address is selected.
   * etharp_input does not need to handle packets that originate "from_us".
   */
  acd_arp_reply(netif, hdr);
 20193c4:	e17ffb17 	ldw	r5,-20(fp)
 20193c8:	e13fff17 	ldw	r4,-4(fp)
 20193cc:	203a9440 	call	203a944 <acd_arp_reply>
#endif /* LWIP_ACD */

  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
 20193d0:	e0bffb17 	ldw	r2,-20(fp)
 20193d4:	10c00384 	addi	r3,r2,14
 20193d8:	e0bffc04 	addi	r2,fp,-16
 20193dc:	01800104 	movi	r6,4
 20193e0:	180b883a 	mov	r5,r3
 20193e4:	1009883a 	mov	r4,r2
 20193e8:	2005e580 	call	2005e58 <memcpy>
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
 20193ec:	e0bffb17 	ldw	r2,-20(fp)
 20193f0:	10c00604 	addi	r3,r2,24
 20193f4:	e0bffd04 	addi	r2,fp,-12
 20193f8:	01800104 	movi	r6,4
 20193fc:	180b883a 	mov	r5,r3
 2019400:	1009883a 	mov	r4,r2
 2019404:	2005e580 	call	2005e58 <memcpy>

  /* this interface is not configured? */
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 2019408:	e0bfff17 	ldw	r2,-4(fp)
 201940c:	10800104 	addi	r2,r2,4
 2019410:	10800017 	ldw	r2,0(r2)
 2019414:	1000031e 	bne	r2,zero,2019424 <etharp_input+0x154>
    for_us = 0;
 2019418:	e03ffa05 	stb	zero,-24(fp)
    from_us = 0;
 201941c:	e03ffa45 	stb	zero,-23(fp)
 2019420:	00000c06 	br	2019454 <etharp_input+0x184>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 2019424:	e0fffd17 	ldw	r3,-12(fp)
 2019428:	e0bfff17 	ldw	r2,-4(fp)
 201942c:	10800104 	addi	r2,r2,4
 2019430:	10800017 	ldw	r2,0(r2)
 2019434:	1885003a 	cmpeq	r2,r3,r2
 2019438:	e0bffa05 	stb	r2,-24(fp)
    /* ARP packet from us? */
    from_us = (u8_t)ip4_addr_cmp(&sipaddr, netif_ip4_addr(netif));
 201943c:	e0fffc17 	ldw	r3,-16(fp)
 2019440:	e0bfff17 	ldw	r2,-4(fp)
 2019444:	10800104 	addi	r2,r2,4
 2019448:	10800017 	ldw	r2,0(r2)
 201944c:	1885003a 	cmpeq	r2,r3,r2
 2019450:	e0bffa45 	stb	r2,-23(fp)
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 2019454:	e0bffb17 	ldw	r2,-20(fp)
 2019458:	11000204 	addi	r4,r2,8
 201945c:	e0bffa03 	ldbu	r2,-24(fp)
 2019460:	10000226 	beq	r2,zero,201946c <etharp_input+0x19c>
 2019464:	00800044 	movi	r2,1
 2019468:	00000106 	br	2019470 <etharp_input+0x1a0>
 201946c:	00800084 	movi	r2,2
 2019470:	e0fffc04 	addi	r3,fp,-16
 2019474:	100f883a 	mov	r7,r2
 2019478:	200d883a 	mov	r6,r4
 201947c:	180b883a 	mov	r5,r3
 2019480:	e13fff17 	ldw	r4,-4(fp)
 2019484:	2018ec80 	call	2018ec8 <etharp_update_arp_entry>
                          for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
 2019488:	e0bffb17 	ldw	r2,-20(fp)
 201948c:	10c00183 	ldbu	r3,6(r2)
 2019490:	108001c3 	ldbu	r2,7(r2)
 2019494:	1004923a 	slli	r2,r2,8
 2019498:	10c4b03a 	or	r2,r2,r3
 201949c:	10bfffcc 	andi	r2,r2,65535
 20194a0:	10c04020 	cmpeqi	r3,r2,256
 20194a4:	1800031e 	bne	r3,zero,20194b4 <etharp_input+0x1e4>
 20194a8:	10808020 	cmpeqi	r2,r2,512
 20194ac:	1000201e 	bne	r2,zero,2019530 <etharp_input+0x260>
 20194b0:	00001706 	br	2019510 <etharp_input+0x240>
       * reply. In any case, we time-stamp any existing ARP entry,
       * and possibly send out an IP packet that was queued on it. */

      LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP request\n"));
      /* ARP request for our address? */
      if (for_us && !from_us) {
 20194b4:	e0bffa03 	ldbu	r2,-24(fp)
 20194b8:	10001f26 	beq	r2,zero,2019538 <etharp_input+0x268>
 20194bc:	e0bffa43 	ldbu	r2,-23(fp)
 20194c0:	10001d1e 	bne	r2,zero,2019538 <etharp_input+0x268>
        /* send ARP response */
        etharp_raw(netif,
                   (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 20194c4:	e0bfff17 	ldw	r2,-4(fp)
 20194c8:	11400d84 	addi	r5,r2,54
 20194cc:	e0bffb17 	ldw	r2,-20(fp)
 20194d0:	11800204 	addi	r6,r2,8
                   (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 20194d4:	e0bfff17 	ldw	r2,-4(fp)
 20194d8:	11c00d84 	addi	r7,r2,54
 20194dc:	e0bfff17 	ldw	r2,-4(fp)
 20194e0:	10800104 	addi	r2,r2,4
                   &hdr->shwaddr, &sipaddr,
 20194e4:	e0fffb17 	ldw	r3,-20(fp)
 20194e8:	18c00204 	addi	r3,r3,8

      LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP request\n"));
      /* ARP request for our address? */
      if (for_us && !from_us) {
        /* send ARP response */
        etharp_raw(netif,
 20194ec:	01000084 	movi	r4,2
 20194f0:	d9000315 	stw	r4,12(sp)
 20194f4:	e13ffc04 	addi	r4,fp,-16
 20194f8:	d9000215 	stw	r4,8(sp)
 20194fc:	d8c00115 	stw	r3,4(sp)
 2019500:	d8800015 	stw	r2,0(sp)
 2019504:	e13fff17 	ldw	r4,-4(fp)
 2019508:	2019e980 	call	2019e98 <etharp_raw>
        /* request was not directed to us */
      } else {
        /* { for_us == 0 and netif->ip_addr.addr != 0 } */
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP request was not for us.\n"));
      }
      break;
 201950c:	00000a06 	br	2019538 <etharp_input+0x268>
      /* ARP reply. We already updated the ARP cache earlier. */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP reply\n"));
      break;
    default:
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP unknown opcode type %"S16_F"\n", lwip_htons(hdr->opcode)));
      ETHARP_STATS_INC(etharp.err);
 2019510:	008085f4 	movhi	r2,535
 2019514:	10bd8204 	addi	r2,r2,-2552
 2019518:	10801617 	ldw	r2,88(r2)
 201951c:	10c00044 	addi	r3,r2,1
 2019520:	008085f4 	movhi	r2,535
 2019524:	10bd8204 	addi	r2,r2,-2552
 2019528:	10c01615 	stw	r3,88(r2)
      break;
 201952c:	00000306 	br	201953c <etharp_input+0x26c>
      }
      break;
    case PP_HTONS(ARP_REPLY):
      /* ARP reply. We already updated the ARP cache earlier. */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP reply\n"));
      break;
 2019530:	0001883a 	nop
 2019534:	00000106 	br	201953c <etharp_input+0x26c>
        /* request was not directed to us */
      } else {
        /* { for_us == 0 and netif->ip_addr.addr != 0 } */
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP request was not for us.\n"));
      }
      break;
 2019538:	0001883a 	nop
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP unknown opcode type %"S16_F"\n", lwip_htons(hdr->opcode)));
      ETHARP_STATS_INC(etharp.err);
      break;
  }
  /* free ARP packet */
  pbuf_free(p);
 201953c:	e13ffe17 	ldw	r4,-8(fp)
 2019540:	201d2f40 	call	201d2f4 <pbuf_free>
 2019544:	00000106 	br	201954c <etharp_input+0x27c>
  ip4_addr_t sipaddr, dipaddr;
  u8_t for_us, from_us;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 2019548:	0001883a 	nop
      ETHARP_STATS_INC(etharp.err);
      break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
 201954c:	e037883a 	mov	sp,fp
 2019550:	dfc00117 	ldw	ra,4(sp)
 2019554:	df000017 	ldw	fp,0(sp)
 2019558:	dec00204 	addi	sp,sp,8
 201955c:	f800283a 	ret

02019560 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, netif_addr_idx_t arp_idx)
{
 2019560:	defffa04 	addi	sp,sp,-24
 2019564:	dfc00515 	stw	ra,20(sp)
 2019568:	df000415 	stw	fp,16(sp)
 201956c:	df000404 	addi	fp,sp,16
 2019570:	e13ffd15 	stw	r4,-12(fp)
 2019574:	e17ffe15 	stw	r5,-8(fp)
 2019578:	3005883a 	mov	r2,r6
 201957c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 2019580:	e0ffff03 	ldbu	r3,-4(fp)
 2019584:	00808174 	movhi	r2,517
 2019588:	10b38904 	addi	r2,r2,-12764
 201958c:	18c00624 	muli	r3,r3,24
 2019590:	10c5883a 	add	r2,r2,r3
 2019594:	10800504 	addi	r2,r2,20
 2019598:	10800003 	ldbu	r2,0(r2)
 201959c:	10803fcc 	andi	r2,r2,255
 20195a0:	10800098 	cmpnei	r2,r2,2
 20195a4:	1000461e 	bne	r2,zero,20196c0 <etharp_output_to_arp_index+0x160>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 20195a8:	e0ffff03 	ldbu	r3,-4(fp)
 20195ac:	00808174 	movhi	r2,517
 20195b0:	10b38904 	addi	r2,r2,-12764
 20195b4:	18c00624 	muli	r3,r3,24
 20195b8:	10c5883a 	add	r2,r2,r3
 20195bc:	10800484 	addi	r2,r2,18
 20195c0:	1080000b 	ldhu	r2,0(r2)
 20195c4:	10bfffcc 	andi	r2,r2,65535
 20195c8:	10804770 	cmpltui	r2,r2,285
 20195cc:	1000161e 	bne	r2,zero,2019628 <etharp_output_to_arp_index+0xc8>
      /* issue a standard request using broadcast */
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 20195d0:	e0bfff03 	ldbu	r2,-4(fp)
 20195d4:	10800624 	muli	r2,r2,24
 20195d8:	10c00104 	addi	r3,r2,4
 20195dc:	00808174 	movhi	r2,517
 20195e0:	10b38904 	addi	r2,r2,-12764
 20195e4:	1885883a 	add	r2,r3,r2
 20195e8:	100b883a 	mov	r5,r2
 20195ec:	e13ffd17 	ldw	r4,-12(fp)
 20195f0:	201a0f40 	call	201a0f4 <etharp_request>
 20195f4:	10803fcc 	andi	r2,r2,255
 20195f8:	1080201c 	xori	r2,r2,128
 20195fc:	10bfe004 	addi	r2,r2,-128
 2019600:	10002f1e 	bne	r2,zero,20196c0 <etharp_output_to_arp_index+0x160>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 2019604:	e0ffff03 	ldbu	r3,-4(fp)
 2019608:	00808174 	movhi	r2,517
 201960c:	10b38904 	addi	r2,r2,-12764
 2019610:	18c00624 	muli	r3,r3,24
 2019614:	10c5883a 	add	r2,r2,r3
 2019618:	10800504 	addi	r2,r2,20
 201961c:	00c000c4 	movi	r3,3
 2019620:	10c00005 	stb	r3,0(r2)
 2019624:	00002606 	br	20196c0 <etharp_output_to_arp_index+0x160>
      }
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 2019628:	e0ffff03 	ldbu	r3,-4(fp)
 201962c:	00808174 	movhi	r2,517
 2019630:	10b38904 	addi	r2,r2,-12764
 2019634:	18c00624 	muli	r3,r3,24
 2019638:	10c5883a 	add	r2,r2,r3
 201963c:	10800484 	addi	r2,r2,18
 2019640:	1080000b 	ldhu	r2,0(r2)
 2019644:	10bfffcc 	andi	r2,r2,65535
 2019648:	108043b0 	cmpltui	r2,r2,270
 201964c:	10001c1e 	bne	r2,zero,20196c0 <etharp_output_to_arp_index+0x160>
      /* issue a unicast request (for 15 seconds) to prevent unnecessary broadcast */
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 2019650:	e0bfff03 	ldbu	r2,-4(fp)
 2019654:	10800624 	muli	r2,r2,24
 2019658:	10c00104 	addi	r3,r2,4
 201965c:	00808174 	movhi	r2,517
 2019660:	10b38904 	addi	r2,r2,-12764
 2019664:	1889883a 	add	r4,r3,r2
 2019668:	e0bfff03 	ldbu	r2,-4(fp)
 201966c:	10800624 	muli	r2,r2,24
 2019670:	10c00304 	addi	r3,r2,12
 2019674:	00808174 	movhi	r2,517
 2019678:	10b38904 	addi	r2,r2,-12764
 201967c:	1885883a 	add	r2,r3,r2
 2019680:	100d883a 	mov	r6,r2
 2019684:	200b883a 	mov	r5,r4
 2019688:	e13ffd17 	ldw	r4,-12(fp)
 201968c:	201a07c0 	call	201a07c <etharp_request_dst>
 2019690:	10803fcc 	andi	r2,r2,255
 2019694:	1080201c 	xori	r2,r2,128
 2019698:	10bfe004 	addi	r2,r2,-128
 201969c:	1000081e 	bne	r2,zero,20196c0 <etharp_output_to_arp_index+0x160>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 20196a0:	e0ffff03 	ldbu	r3,-4(fp)
 20196a4:	00808174 	movhi	r2,517
 20196a8:	10b38904 	addi	r2,r2,-12764
 20196ac:	18c00624 	muli	r3,r3,24
 20196b0:	10c5883a 	add	r2,r2,r3
 20196b4:	10800504 	addi	r2,r2,20
 20196b8:	00c000c4 	movi	r3,3
 20196bc:	10c00005 	stb	r3,0(r2)
      }
    }
  }

  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 20196c0:	e0bffd17 	ldw	r2,-12(fp)
 20196c4:	11000d84 	addi	r4,r2,54
 20196c8:	e0bfff03 	ldbu	r2,-4(fp)
 20196cc:	10800624 	muli	r2,r2,24
 20196d0:	10c00304 	addi	r3,r2,12
 20196d4:	00808174 	movhi	r2,517
 20196d8:	10b38904 	addi	r2,r2,-12764
 20196dc:	1887883a 	add	r3,r3,r2
 20196e0:	00820004 	movi	r2,2048
 20196e4:	d8800015 	stw	r2,0(sp)
 20196e8:	180f883a 	mov	r7,r3
 20196ec:	200d883a 	mov	r6,r4
 20196f0:	e17ffe17 	ldw	r5,-8(fp)
 20196f4:	e13ffd17 	ldw	r4,-12(fp)
 20196f8:	202afa40 	call	202afa4 <ethernet_output>
}
 20196fc:	e037883a 	mov	sp,fp
 2019700:	dfc00117 	ldw	ra,4(sp)
 2019704:	df000017 	ldw	fp,0(sp)
 2019708:	dec00204 	addi	sp,sp,8
 201970c:	f800283a 	ret

02019710 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or ethernet_output().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr)
{
 2019710:	defff604 	addi	sp,sp,-40
 2019714:	dfc00915 	stw	ra,36(sp)
 2019718:	df000815 	stw	fp,32(sp)
 201971c:	df000804 	addi	fp,sp,32
 2019720:	e13ffd15 	stw	r4,-12(fp)
 2019724:	e17ffe15 	stw	r5,-8(fp)
 2019728:	e1bfff15 	stw	r6,-4(fp)
  const struct eth_addr *dest;
  struct eth_addr mcastaddr;
  const ip4_addr_t *dst_addr = ipaddr;
 201972c:	e0bfff17 	ldw	r2,-4(fp)
 2019730:	e0bffa15 	stw	r2,-24(fp)

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
 2019734:	e0bfff17 	ldw	r2,-4(fp)
 2019738:	10800017 	ldw	r2,0(r2)
 201973c:	e17ffd17 	ldw	r5,-12(fp)
 2019740:	1009883a 	mov	r4,r2
 2019744:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
 2019748:	10803fcc 	andi	r2,r2,255
 201974c:	10000326 	beq	r2,zero,201975c <etharp_output+0x4c>
    /* broadcast on Ethernet also */
    dest = (const struct eth_addr *)&ethbroadcast;
 2019750:	d0a01584 	addi	r2,gp,-32682
 2019754:	e0bff915 	stw	r2,-28(fp)
 2019758:	0000a106 	br	20199e0 <etharp_output+0x2d0>
    /* multicast destination IP address? */
  } else if (ip4_addr_ismulticast(ipaddr)) {
 201975c:	e0bfff17 	ldw	r2,-4(fp)
 2019760:	10800017 	ldw	r2,0(r2)
 2019764:	10803c0c 	andi	r2,r2,240
 2019768:	10803818 	cmpnei	r2,r2,224
 201976c:	1000151e 	bne	r2,zero,20197c4 <etharp_output+0xb4>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
 2019770:	00800044 	movi	r2,1
 2019774:	e0bffb85 	stb	r2,-18(fp)
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 2019778:	e03ffbc5 	stb	zero,-17(fp)
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 201977c:	00801784 	movi	r2,94
 2019780:	e0bffc05 	stb	r2,-16(fp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 2019784:	e0bfff17 	ldw	r2,-4(fp)
 2019788:	10800044 	addi	r2,r2,1
 201978c:	10800003 	ldbu	r2,0(r2)
 2019790:	10801fcc 	andi	r2,r2,127
 2019794:	e0bffc45 	stb	r2,-15(fp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 2019798:	e0bfff17 	ldw	r2,-4(fp)
 201979c:	10800084 	addi	r2,r2,2
 20197a0:	10800003 	ldbu	r2,0(r2)
 20197a4:	e0bffc85 	stb	r2,-14(fp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 20197a8:	e0bfff17 	ldw	r2,-4(fp)
 20197ac:	108000c4 	addi	r2,r2,3
 20197b0:	10800003 	ldbu	r2,0(r2)
 20197b4:	e0bffcc5 	stb	r2,-13(fp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 20197b8:	e0bffb84 	addi	r2,fp,-18
 20197bc:	e0bff915 	stw	r2,-28(fp)
 20197c0:	00008706 	br	20199e0 <etharp_output+0x2d0>
    /* unicast destination IP address? */
  } else {
    netif_addr_idx_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 20197c4:	e0bfff17 	ldw	r2,-4(fp)
 20197c8:	10c00017 	ldw	r3,0(r2)
 20197cc:	e0bffd17 	ldw	r2,-12(fp)
 20197d0:	10800104 	addi	r2,r2,4
 20197d4:	10800017 	ldw	r2,0(r2)
 20197d8:	1886f03a 	xor	r3,r3,r2
 20197dc:	e0bffd17 	ldw	r2,-12(fp)
 20197e0:	10800204 	addi	r2,r2,8
 20197e4:	10800017 	ldw	r2,0(r2)
 20197e8:	1884703a 	and	r2,r3,r2
 20197ec:	10000f26 	beq	r2,zero,201982c <etharp_output+0x11c>
        !ip4_addr_islinklocal(ipaddr)) {
 20197f0:	e0bfff17 	ldw	r2,-4(fp)
 20197f4:	10800017 	ldw	r2,0(r2)
 20197f8:	10ffffcc 	andi	r3,r2,65535
    /* unicast destination IP address? */
  } else {
    netif_addr_idx_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 20197fc:	00bfaa54 	movui	r2,65193
 2019800:	18800a26 	beq	r3,r2,201982c <etharp_output+0x11c>
        dst_addr = LWIP_HOOK_ETHARP_GET_GW(netif, ipaddr);
        if (dst_addr == NULL)
#endif /* LWIP_HOOK_ETHARP_GET_GW */
        {
          /* interface has default gateway? */
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 2019804:	e0bffd17 	ldw	r2,-12(fp)
 2019808:	10800304 	addi	r2,r2,12
 201980c:	10800017 	ldw	r2,0(r2)
 2019810:	10000426 	beq	r2,zero,2019824 <etharp_output+0x114>
            /* send to hardware address of default gateway IP address */
            dst_addr = netif_ip4_gw(netif);
 2019814:	e0bffd17 	ldw	r2,-12(fp)
 2019818:	10800304 	addi	r2,r2,12
 201981c:	e0bffa15 	stw	r2,-24(fp)
 2019820:	00000206 	br	201982c <etharp_output+0x11c>
            /* no default gateway available */
          } else {
            /* no route to destination error (default gateway missing) */
            return ERR_RTE;
 2019824:	00bfff04 	movi	r2,-4
 2019828:	00007606 	br	2019a04 <etharp_output+0x2f4>
          }
        }
      }
    }
#if LWIP_NETIF_HWADDRHINT
    if (netif->hints != NULL) {
 201982c:	e0bffd17 	ldw	r2,-12(fp)
 2019830:	10801217 	ldw	r2,72(r2)
 2019834:	10003126 	beq	r2,zero,20198fc <etharp_output+0x1ec>
      /* per-pcb cached entry was given */
      netif_addr_idx_t etharp_cached_entry = netif->hints->addr_hint;
 2019838:	e0bffd17 	ldw	r2,-12(fp)
 201983c:	10801217 	ldw	r2,72(r2)
 2019840:	10800003 	ldbu	r2,0(r2)
 2019844:	e0bffb45 	stb	r2,-19(fp)
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
 2019848:	e0bffb43 	ldbu	r2,-19(fp)
 201984c:	10800668 	cmpgeui	r2,r2,25
 2019850:	10002a1e 	bne	r2,zero,20198fc <etharp_output+0x1ec>
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 2019854:	e0fffb43 	ldbu	r3,-19(fp)
 2019858:	00808174 	movhi	r2,517
 201985c:	10b38904 	addi	r2,r2,-12764
 2019860:	18c00624 	muli	r3,r3,24
 2019864:	10c5883a 	add	r2,r2,r3
 2019868:	10800504 	addi	r2,r2,20
 201986c:	10800003 	ldbu	r2,0(r2)
 2019870:	10803fcc 	andi	r2,r2,255
 2019874:	108000b0 	cmpltui	r2,r2,2
 2019878:	1000201e 	bne	r2,zero,20198fc <etharp_output+0x1ec>
#if ETHARP_TABLE_MATCH_NETIF
            (arp_table[etharp_cached_entry].netif == netif) &&
 201987c:	e0fffb43 	ldbu	r3,-19(fp)
 2019880:	00808174 	movhi	r2,517
 2019884:	10b38904 	addi	r2,r2,-12764
 2019888:	18c00624 	muli	r3,r3,24
 201988c:	10c5883a 	add	r2,r2,r3
 2019890:	10800204 	addi	r2,r2,8
 2019894:	10c00017 	ldw	r3,0(r2)
    if (netif->hints != NULL) {
      /* per-pcb cached entry was given */
      netif_addr_idx_t etharp_cached_entry = netif->hints->addr_hint;
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 2019898:	e0bffd17 	ldw	r2,-12(fp)
 201989c:	1880171e 	bne	r3,r2,20198fc <etharp_output+0x1ec>
#if ETHARP_TABLE_MATCH_NETIF
            (arp_table[etharp_cached_entry].netif == netif) &&
#endif
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 20198a0:	e0bffa17 	ldw	r2,-24(fp)
 20198a4:	10c00017 	ldw	r3,0(r2)
 20198a8:	e13ffb43 	ldbu	r4,-19(fp)
 20198ac:	00808174 	movhi	r2,517
 20198b0:	10b38904 	addi	r2,r2,-12764
 20198b4:	21000624 	muli	r4,r4,24
 20198b8:	1105883a 	add	r2,r2,r4
 20198bc:	10800104 	addi	r2,r2,4
 20198c0:	10800017 	ldw	r2,0(r2)
      netif_addr_idx_t etharp_cached_entry = netif->hints->addr_hint;
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
#if ETHARP_TABLE_MATCH_NETIF
            (arp_table[etharp_cached_entry].netif == netif) &&
 20198c4:	18800d1e 	bne	r3,r2,20198fc <etharp_output+0x1ec>
#endif
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
 20198c8:	008085f4 	movhi	r2,535
 20198cc:	10bd8204 	addi	r2,r2,-2552
 20198d0:	10801717 	ldw	r2,92(r2)
 20198d4:	10c00044 	addi	r3,r2,1
 20198d8:	008085f4 	movhi	r2,535
 20198dc:	10bd8204 	addi	r2,r2,-2552
 20198e0:	10c01715 	stw	r3,92(r2)
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 20198e4:	e0bffb43 	ldbu	r2,-19(fp)
 20198e8:	100d883a 	mov	r6,r2
 20198ec:	e17ffe17 	ldw	r5,-8(fp)
 20198f0:	e13ffd17 	ldw	r4,-12(fp)
 20198f4:	20195600 	call	2019560 <etharp_output_to_arp_index>
 20198f8:	00004206 	br	2019a04 <etharp_output+0x2f4>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 20198fc:	e03ffb05 	stb	zero,-20(fp)
 2019900:	00002f06 	br	20199c0 <etharp_output+0x2b0>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 2019904:	e0fffb03 	ldbu	r3,-20(fp)
 2019908:	00808174 	movhi	r2,517
 201990c:	10b38904 	addi	r2,r2,-12764
 2019910:	18c00624 	muli	r3,r3,24
 2019914:	10c5883a 	add	r2,r2,r3
 2019918:	10800504 	addi	r2,r2,20
 201991c:	10800003 	ldbu	r2,0(r2)
 2019920:	10803fcc 	andi	r2,r2,255
 2019924:	108000b0 	cmpltui	r2,r2,2
 2019928:	1000221e 	bne	r2,zero,20199b4 <etharp_output+0x2a4>
#if ETHARP_TABLE_MATCH_NETIF
          (arp_table[i].netif == netif) &&
 201992c:	e0fffb03 	ldbu	r3,-20(fp)
 2019930:	00808174 	movhi	r2,517
 2019934:	10b38904 	addi	r2,r2,-12764
 2019938:	18c00624 	muli	r3,r3,24
 201993c:	10c5883a 	add	r2,r2,r3
 2019940:	10800204 	addi	r2,r2,8
 2019944:	10c00017 	ldw	r3,0(r2)
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 2019948:	e0bffd17 	ldw	r2,-12(fp)
 201994c:	1880191e 	bne	r3,r2,20199b4 <etharp_output+0x2a4>
#if ETHARP_TABLE_MATCH_NETIF
          (arp_table[i].netif == netif) &&
#endif
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 2019950:	e0bffa17 	ldw	r2,-24(fp)
 2019954:	10c00017 	ldw	r3,0(r2)
 2019958:	e13ffb03 	ldbu	r4,-20(fp)
 201995c:	00808174 	movhi	r2,517
 2019960:	10b38904 	addi	r2,r2,-12764
 2019964:	21000624 	muli	r4,r4,24
 2019968:	1105883a 	add	r2,r2,r4
 201996c:	10800104 	addi	r2,r2,4
 2019970:	10800017 	ldw	r2,0(r2)
    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
#if ETHARP_TABLE_MATCH_NETIF
          (arp_table[i].netif == netif) &&
 2019974:	18800f1e 	bne	r3,r2,20199b4 <etharp_output+0x2a4>
#endif
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_ADDRHINT(netif, i);
 2019978:	e0bffd17 	ldw	r2,-12(fp)
 201997c:	10000726 	beq	r2,zero,201999c <etharp_output+0x28c>
 2019980:	e0bffd17 	ldw	r2,-12(fp)
 2019984:	10801217 	ldw	r2,72(r2)
 2019988:	10000426 	beq	r2,zero,201999c <etharp_output+0x28c>
 201998c:	e0bffd17 	ldw	r2,-12(fp)
 2019990:	10801217 	ldw	r2,72(r2)
 2019994:	e0fffb03 	ldbu	r3,-20(fp)
 2019998:	10c00005 	stb	r3,0(r2)
        return etharp_output_to_arp_index(netif, q, i);
 201999c:	e0bffb03 	ldbu	r2,-20(fp)
 20199a0:	100d883a 	mov	r6,r2
 20199a4:	e17ffe17 	ldw	r5,-8(fp)
 20199a8:	e13ffd17 	ldw	r4,-12(fp)
 20199ac:	20195600 	call	2019560 <etharp_output_to_arp_index>
 20199b0:	00001406 	br	2019a04 <etharp_output+0x2f4>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 20199b4:	e0bffb03 	ldbu	r2,-20(fp)
 20199b8:	10800044 	addi	r2,r2,1
 20199bc:	e0bffb05 	stb	r2,-20(fp)
 20199c0:	e0bffb03 	ldbu	r2,-20(fp)
 20199c4:	10800670 	cmpltui	r2,r2,25
 20199c8:	103fce1e 	bne	r2,zero,2019904 <__alt_mem_mem_0+0xfcff9904>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
 20199cc:	e1bffe17 	ldw	r6,-8(fp)
 20199d0:	e17ffa17 	ldw	r5,-24(fp)
 20199d4:	e13ffd17 	ldw	r4,-12(fp)
 20199d8:	2019a180 	call	2019a18 <etharp_query>
 20199dc:	00000906 	br	2019a04 <etharp_output+0x2f4>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), dest, ETHTYPE_IP);
 20199e0:	e0bffd17 	ldw	r2,-12(fp)
 20199e4:	10c00d84 	addi	r3,r2,54
 20199e8:	00820004 	movi	r2,2048
 20199ec:	d8800015 	stw	r2,0(sp)
 20199f0:	e1fff917 	ldw	r7,-28(fp)
 20199f4:	180d883a 	mov	r6,r3
 20199f8:	e17ffe17 	ldw	r5,-8(fp)
 20199fc:	e13ffd17 	ldw	r4,-12(fp)
 2019a00:	202afa40 	call	202afa4 <ethernet_output>
}
 2019a04:	e037883a 	mov	sp,fp
 2019a08:	dfc00117 	ldw	ra,4(sp)
 2019a0c:	df000017 	ldw	fp,0(sp)
 2019a10:	dec00204 	addi	sp,sp,8
 2019a14:	f800283a 	ret

02019a18 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
{
 2019a18:	defff004 	addi	sp,sp,-64
 2019a1c:	dfc00f15 	stw	ra,60(sp)
 2019a20:	df000e15 	stw	fp,56(sp)
 2019a24:	df000e04 	addi	fp,sp,56
 2019a28:	e13ffd15 	stw	r4,-12(fp)
 2019a2c:	e17ffe15 	stw	r5,-8(fp)
 2019a30:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
 2019a34:	e0bffd17 	ldw	r2,-12(fp)
 2019a38:	10800d84 	addi	r2,r2,54
 2019a3c:	e0bff915 	stw	r2,-28(fp)
  err_t result = ERR_MEM;
 2019a40:	00bfffc4 	movi	r2,-1
 2019a44:	e0bff305 	stb	r2,-52(fp)
  int is_new_entry = 0;
 2019a48:	e03ff415 	stw	zero,-48(fp)
  s16_t i_err;
  netif_addr_idx_t i;

  /* non-unicast address? */
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 2019a4c:	e0bffe17 	ldw	r2,-8(fp)
 2019a50:	10800017 	ldw	r2,0(r2)
 2019a54:	e17ffd17 	ldw	r5,-12(fp)
 2019a58:	1009883a 	mov	r4,r2
 2019a5c:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
 2019a60:	10803fcc 	andi	r2,r2,255
 2019a64:	10000a1e 	bne	r2,zero,2019a90 <etharp_query+0x78>
      ip4_addr_ismulticast(ipaddr) ||
 2019a68:	e0bffe17 	ldw	r2,-8(fp)
 2019a6c:	10800017 	ldw	r2,0(r2)
 2019a70:	10803c0c 	andi	r2,r2,240
  int is_new_entry = 0;
  s16_t i_err;
  netif_addr_idx_t i;

  /* non-unicast address? */
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 2019a74:	10803820 	cmpeqi	r2,r2,224
 2019a78:	1000051e 	bne	r2,zero,2019a90 <etharp_query+0x78>
      ip4_addr_ismulticast(ipaddr) ||
 2019a7c:	e0bffe17 	ldw	r2,-8(fp)
 2019a80:	10000326 	beq	r2,zero,2019a90 <etharp_query+0x78>
      ip4_addr_isany(ipaddr)) {
 2019a84:	e0bffe17 	ldw	r2,-8(fp)
 2019a88:	10800017 	ldw	r2,0(r2)
 2019a8c:	1000021e 	bne	r2,zero,2019a98 <etharp_query+0x80>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 2019a90:	00bffc04 	movi	r2,-16
 2019a94:	0000fb06 	br	2019e84 <etharp_query+0x46c>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i_err = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 2019a98:	e1bffd17 	ldw	r6,-12(fp)
 2019a9c:	01400044 	movi	r5,1
 2019aa0:	e13ffe17 	ldw	r4,-8(fp)
 2019aa4:	2018b600 	call	2018b60 <etharp_find_entry>
 2019aa8:	e0bffa0d 	sth	r2,-24(fp)

  /* could not find or create entry? */
  if (i_err < 0) {
 2019aac:	e0bffa0f 	ldh	r2,-24(fp)
 2019ab0:	10000b0e 	bge	r2,zero,2019ae0 <etharp_query+0xc8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
 2019ab4:	e0bfff17 	ldw	r2,-4(fp)
 2019ab8:	10000726 	beq	r2,zero,2019ad8 <etharp_query+0xc0>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
 2019abc:	008085f4 	movhi	r2,535
 2019ac0:	10bd8204 	addi	r2,r2,-2552
 2019ac4:	10801217 	ldw	r2,72(r2)
 2019ac8:	10c00044 	addi	r3,r2,1
 2019acc:	008085f4 	movhi	r2,535
 2019ad0:	10bd8204 	addi	r2,r2,-2552
 2019ad4:	10c01215 	stw	r3,72(r2)
    }
    return (err_t)i_err;
 2019ad8:	e0bffa0b 	ldhu	r2,-24(fp)
 2019adc:	0000e906 	br	2019e84 <etharp_query+0x46c>
  }
  LWIP_ASSERT("type overflow", (size_t)i_err < NETIF_ADDR_IDX_MAX);
  i = (netif_addr_idx_t)i_err;
 2019ae0:	e0bffa0b 	ldhu	r2,-24(fp)
 2019ae4:	e0bffa85 	stb	r2,-22(fp)

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 2019ae8:	e0fffa83 	ldbu	r3,-22(fp)
 2019aec:	00808174 	movhi	r2,517
 2019af0:	10b38904 	addi	r2,r2,-12764
 2019af4:	18c00624 	muli	r3,r3,24
 2019af8:	10c5883a 	add	r2,r2,r3
 2019afc:	10800504 	addi	r2,r2,20
 2019b00:	10800003 	ldbu	r2,0(r2)
 2019b04:	10803fcc 	andi	r2,r2,255
 2019b08:	1000121e 	bne	r2,zero,2019b54 <etharp_query+0x13c>
    is_new_entry = 1;
 2019b0c:	00800044 	movi	r2,1
 2019b10:	e0bff415 	stw	r2,-48(fp)
    arp_table[i].state = ETHARP_STATE_PENDING;
 2019b14:	e0fffa83 	ldbu	r3,-22(fp)
 2019b18:	00808174 	movhi	r2,517
 2019b1c:	10b38904 	addi	r2,r2,-12764
 2019b20:	18c00624 	muli	r3,r3,24
 2019b24:	10c5883a 	add	r2,r2,r3
 2019b28:	10800504 	addi	r2,r2,20
 2019b2c:	00c00044 	movi	r3,1
 2019b30:	10c00005 	stb	r3,0(r2)
    /* record network interface for re-sending arp request in etharp_tmr */
    arp_table[i].netif = netif;
 2019b34:	e0fffa83 	ldbu	r3,-22(fp)
 2019b38:	00808174 	movhi	r2,517
 2019b3c:	10b38904 	addi	r2,r2,-12764
 2019b40:	18c00624 	muli	r3,r3,24
 2019b44:	10c5883a 	add	r2,r2,r3
 2019b48:	10800204 	addi	r2,r2,8
 2019b4c:	e0fffd17 	ldw	r3,-12(fp)
 2019b50:	10c00015 	stw	r3,0(r2)
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
              ((arp_table[i].state == ETHARP_STATE_PENDING) ||
               (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a new entry? or an implicit query request? */
  if (is_new_entry || (q == NULL)) {
 2019b54:	e0bff417 	ldw	r2,-48(fp)
 2019b58:	1000021e 	bne	r2,zero,2019b64 <etharp_query+0x14c>
 2019b5c:	e0bfff17 	ldw	r2,-4(fp)
 2019b60:	10001d1e 	bne	r2,zero,2019bd8 <etharp_query+0x1c0>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 2019b64:	e17ffe17 	ldw	r5,-8(fp)
 2019b68:	e13ffd17 	ldw	r4,-12(fp)
 2019b6c:	201a0f40 	call	201a0f4 <etharp_request>
 2019b70:	e0bff305 	stb	r2,-52(fp)
    if (result != ERR_OK) {
 2019b74:	e0bff307 	ldb	r2,-52(fp)
 2019b78:	1000131e 	bne	r2,zero,2019bc8 <etharp_query+0x1b0>
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    } else {
      /* ARP request successfully sent */
      if ((arp_table[i].state == ETHARP_STATE_PENDING) && !is_new_entry) {
 2019b7c:	e0fffa83 	ldbu	r3,-22(fp)
 2019b80:	00808174 	movhi	r2,517
 2019b84:	10b38904 	addi	r2,r2,-12764
 2019b88:	18c00624 	muli	r3,r3,24
 2019b8c:	10c5883a 	add	r2,r2,r3
 2019b90:	10800504 	addi	r2,r2,20
 2019b94:	10800003 	ldbu	r2,0(r2)
 2019b98:	10803fcc 	andi	r2,r2,255
 2019b9c:	10800058 	cmpnei	r2,r2,1
 2019ba0:	1000091e 	bne	r2,zero,2019bc8 <etharp_query+0x1b0>
 2019ba4:	e0bff417 	ldw	r2,-48(fp)
 2019ba8:	1000071e 	bne	r2,zero,2019bc8 <etharp_query+0x1b0>
        /* A new ARP request has been sent for a pending entry. Reset the ctime to
           not let it expire too fast. */
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: reset ctime for entry %"S16_F"\n", (s16_t)i));
        arp_table[i].ctime = 0;
 2019bac:	e0fffa83 	ldbu	r3,-22(fp)
 2019bb0:	00808174 	movhi	r2,517
 2019bb4:	10b38904 	addi	r2,r2,-12764
 2019bb8:	18c00624 	muli	r3,r3,24
 2019bbc:	10c5883a 	add	r2,r2,r3
 2019bc0:	10800484 	addi	r2,r2,18
 2019bc4:	1000000d 	sth	zero,0(r2)
      }
    }
    if (q == NULL) {
 2019bc8:	e0bfff17 	ldw	r2,-4(fp)
 2019bcc:	1000021e 	bne	r2,zero,2019bd8 <etharp_query+0x1c0>
      return result;
 2019bd0:	e0bff303 	ldbu	r2,-52(fp)
 2019bd4:	0000ab06 	br	2019e84 <etharp_query+0x46c>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 2019bd8:	e0fffa83 	ldbu	r3,-22(fp)
 2019bdc:	00808174 	movhi	r2,517
 2019be0:	10b38904 	addi	r2,r2,-12764
 2019be4:	18c00624 	muli	r3,r3,24
 2019be8:	10c5883a 	add	r2,r2,r3
 2019bec:	10800504 	addi	r2,r2,20
 2019bf0:	10800003 	ldbu	r2,0(r2)
 2019bf4:	10803fcc 	andi	r2,r2,255
 2019bf8:	108000b0 	cmpltui	r2,r2,2
 2019bfc:	1000181e 	bne	r2,zero,2019c60 <etharp_query+0x248>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_ADDRHINT(netif, i);
 2019c00:	e0bffd17 	ldw	r2,-12(fp)
 2019c04:	10000726 	beq	r2,zero,2019c24 <etharp_query+0x20c>
 2019c08:	e0bffd17 	ldw	r2,-12(fp)
 2019c0c:	10801217 	ldw	r2,72(r2)
 2019c10:	10000426 	beq	r2,zero,2019c24 <etharp_query+0x20c>
 2019c14:	e0bffd17 	ldw	r2,-12(fp)
 2019c18:	10801217 	ldw	r2,72(r2)
 2019c1c:	e0fffa83 	ldbu	r3,-22(fp)
 2019c20:	10c00005 	stb	r3,0(r2)
    /* send the packet */
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
 2019c24:	e0bffa83 	ldbu	r2,-22(fp)
 2019c28:	10800624 	muli	r2,r2,24
 2019c2c:	10c00304 	addi	r3,r2,12
 2019c30:	00808174 	movhi	r2,517
 2019c34:	10b38904 	addi	r2,r2,-12764
 2019c38:	1887883a 	add	r3,r3,r2
 2019c3c:	00820004 	movi	r2,2048
 2019c40:	d8800015 	stw	r2,0(sp)
 2019c44:	180f883a 	mov	r7,r3
 2019c48:	e1bff917 	ldw	r6,-28(fp)
 2019c4c:	e17fff17 	ldw	r5,-4(fp)
 2019c50:	e13ffd17 	ldw	r4,-12(fp)
 2019c54:	202afa40 	call	202afa4 <ethernet_output>
 2019c58:	e0bff305 	stb	r2,-52(fp)
 2019c5c:	00008806 	br	2019e80 <etharp_query+0x468>
    /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 2019c60:	e0fffa83 	ldbu	r3,-22(fp)
 2019c64:	00808174 	movhi	r2,517
 2019c68:	10b38904 	addi	r2,r2,-12764
 2019c6c:	18c00624 	muli	r3,r3,24
 2019c70:	10c5883a 	add	r2,r2,r3
 2019c74:	10800504 	addi	r2,r2,20
 2019c78:	10800003 	ldbu	r2,0(r2)
 2019c7c:	10803fcc 	andi	r2,r2,255
 2019c80:	10800058 	cmpnei	r2,r2,1
 2019c84:	10007e1e 	bne	r2,zero,2019e80 <etharp_query+0x468>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
 2019c88:	e03ff615 	stw	zero,-40(fp)
    /* IF q includes a pbuf that must be copied, copy the whole chain into a
     * new PBUF_RAM. See the definition of PBUF_NEEDS_COPY for details. */
    p = q;
 2019c8c:	e0bfff17 	ldw	r2,-4(fp)
 2019c90:	e0bff515 	stw	r2,-44(fp)
    while (p) {
 2019c94:	00000b06 	br	2019cc4 <etharp_query+0x2ac>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if (PBUF_NEEDS_COPY(p)) {
 2019c98:	e0bff517 	ldw	r2,-44(fp)
 2019c9c:	10800303 	ldbu	r2,12(r2)
 2019ca0:	10803fcc 	andi	r2,r2,255
 2019ca4:	1080100c 	andi	r2,r2,64
 2019ca8:	10000326 	beq	r2,zero,2019cb8 <etharp_query+0x2a0>
        copy_needed = 1;
 2019cac:	00800044 	movi	r2,1
 2019cb0:	e0bff615 	stw	r2,-40(fp)
        break;
 2019cb4:	00000506 	br	2019ccc <etharp_query+0x2b4>
      }
      p = p->next;
 2019cb8:	e0bff517 	ldw	r2,-44(fp)
 2019cbc:	10800017 	ldw	r2,0(r2)
 2019cc0:	e0bff515 	stw	r2,-44(fp)
    struct pbuf *p;
    int copy_needed = 0;
    /* IF q includes a pbuf that must be copied, copy the whole chain into a
     * new PBUF_RAM. See the definition of PBUF_NEEDS_COPY for details. */
    p = q;
    while (p) {
 2019cc4:	e0bff517 	ldw	r2,-44(fp)
 2019cc8:	103ff31e 	bne	r2,zero,2019c98 <__alt_mem_mem_0+0xfcff9c98>
        copy_needed = 1;
        break;
      }
      p = p->next;
    }
    if (copy_needed) {
 2019ccc:	e0bff617 	ldw	r2,-40(fp)
 2019cd0:	10000626 	beq	r2,zero,2019cec <etharp_query+0x2d4>
      /* copy the whole packet into new pbufs */
      p = pbuf_clone(PBUF_LINK, PBUF_RAM, q);
 2019cd4:	e1bfff17 	ldw	r6,-4(fp)
 2019cd8:	0140a004 	movi	r5,640
 2019cdc:	01000404 	movi	r4,16
 2019ce0:	201de800 	call	201de80 <pbuf_clone>
 2019ce4:	e0bff515 	stw	r2,-44(fp)
 2019ce8:	00000406 	br	2019cfc <etharp_query+0x2e4>
    } else {
      /* referencing the old pbuf is enough */
      p = q;
 2019cec:	e0bfff17 	ldw	r2,-4(fp)
 2019cf0:	e0bff515 	stw	r2,-44(fp)
      pbuf_ref(p);
 2019cf4:	e13ff517 	ldw	r4,-44(fp)
 2019cf8:	201d4780 	call	201d478 <pbuf_ref>
    }
    /* packet could be taken over? */
    if (p != NULL) {
 2019cfc:	e0bff517 	ldw	r2,-44(fp)
 2019d00:	10005626 	beq	r2,zero,2019e5c <etharp_query+0x444>
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
 2019d04:	010002c4 	movi	r4,11
 2019d08:	201b82c0 	call	201b82c <memp_malloc>
 2019d0c:	e0bffb15 	stw	r2,-20(fp)
      if (new_entry != NULL) {
 2019d10:	e0bffb17 	ldw	r2,-20(fp)
 2019d14:	10004c26 	beq	r2,zero,2019e48 <etharp_query+0x430>
        unsigned int qlen = 0;
 2019d18:	e03ff715 	stw	zero,-36(fp)
        new_entry->next = 0;
 2019d1c:	e0bffb17 	ldw	r2,-20(fp)
 2019d20:	10000015 	stw	zero,0(r2)
        new_entry->p = p;
 2019d24:	e0bffb17 	ldw	r2,-20(fp)
 2019d28:	e0fff517 	ldw	r3,-44(fp)
 2019d2c:	10c00115 	stw	r3,4(r2)
        if (arp_table[i].q != NULL) {
 2019d30:	e0fffa83 	ldbu	r3,-22(fp)
 2019d34:	00808174 	movhi	r2,517
 2019d38:	10b38904 	addi	r2,r2,-12764
 2019d3c:	18c00624 	muli	r3,r3,24
 2019d40:	10c5883a 	add	r2,r2,r3
 2019d44:	10800017 	ldw	r2,0(r2)
 2019d48:	10001826 	beq	r2,zero,2019dac <etharp_query+0x394>
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
 2019d4c:	e0fffa83 	ldbu	r3,-22(fp)
 2019d50:	00808174 	movhi	r2,517
 2019d54:	10b38904 	addi	r2,r2,-12764
 2019d58:	18c00624 	muli	r3,r3,24
 2019d5c:	10c5883a 	add	r2,r2,r3
 2019d60:	10800017 	ldw	r2,0(r2)
 2019d64:	e0bff815 	stw	r2,-32(fp)
          qlen++;
 2019d68:	e0bff717 	ldw	r2,-36(fp)
 2019d6c:	10800044 	addi	r2,r2,1
 2019d70:	e0bff715 	stw	r2,-36(fp)
          while (r->next != NULL) {
 2019d74:	00000606 	br	2019d90 <etharp_query+0x378>
            r = r->next;
 2019d78:	e0bff817 	ldw	r2,-32(fp)
 2019d7c:	10800017 	ldw	r2,0(r2)
 2019d80:	e0bff815 	stw	r2,-32(fp)
            qlen++;
 2019d84:	e0bff717 	ldw	r2,-36(fp)
 2019d88:	10800044 	addi	r2,r2,1
 2019d8c:	e0bff715 	stw	r2,-36(fp)
        if (arp_table[i].q != NULL) {
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          qlen++;
          while (r->next != NULL) {
 2019d90:	e0bff817 	ldw	r2,-32(fp)
 2019d94:	10800017 	ldw	r2,0(r2)
 2019d98:	103ff71e 	bne	r2,zero,2019d78 <__alt_mem_mem_0+0xfcff9d78>
            r = r->next;
            qlen++;
          }
          r->next = new_entry;
 2019d9c:	e0bff817 	ldw	r2,-32(fp)
 2019da0:	e0fffb17 	ldw	r3,-20(fp)
 2019da4:	10c00015 	stw	r3,0(r2)
 2019da8:	00000706 	br	2019dc8 <etharp_query+0x3b0>
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
 2019dac:	e0fffa83 	ldbu	r3,-22(fp)
 2019db0:	00808174 	movhi	r2,517
 2019db4:	10b38904 	addi	r2,r2,-12764
 2019db8:	18c00624 	muli	r3,r3,24
 2019dbc:	10c5883a 	add	r2,r2,r3
 2019dc0:	e0fffb17 	ldw	r3,-20(fp)
 2019dc4:	10c00015 	stw	r3,0(r2)
        }
#if ARP_QUEUE_LEN
        if (qlen >= ARP_QUEUE_LEN) {
 2019dc8:	e0bff717 	ldw	r2,-36(fp)
 2019dcc:	108000f0 	cmpltui	r2,r2,3
 2019dd0:	10001b1e 	bne	r2,zero,2019e40 <etharp_query+0x428>
          struct etharp_q_entry *old;
          old = arp_table[i].q;
 2019dd4:	e0fffa83 	ldbu	r3,-22(fp)
 2019dd8:	00808174 	movhi	r2,517
 2019ddc:	10b38904 	addi	r2,r2,-12764
 2019de0:	18c00624 	muli	r3,r3,24
 2019de4:	10c5883a 	add	r2,r2,r3
 2019de8:	10800017 	ldw	r2,0(r2)
 2019dec:	e0bffc15 	stw	r2,-16(fp)
          arp_table[i].q = arp_table[i].q->next;
 2019df0:	e13ffa83 	ldbu	r4,-22(fp)
 2019df4:	e0fffa83 	ldbu	r3,-22(fp)
 2019df8:	00808174 	movhi	r2,517
 2019dfc:	10b38904 	addi	r2,r2,-12764
 2019e00:	18c00624 	muli	r3,r3,24
 2019e04:	10c5883a 	add	r2,r2,r3
 2019e08:	10800017 	ldw	r2,0(r2)
 2019e0c:	10c00017 	ldw	r3,0(r2)
 2019e10:	00808174 	movhi	r2,517
 2019e14:	10b38904 	addi	r2,r2,-12764
 2019e18:	21000624 	muli	r4,r4,24
 2019e1c:	1105883a 	add	r2,r2,r4
 2019e20:	10c00015 	stw	r3,0(r2)
          pbuf_free(old->p);
 2019e24:	e0bffc17 	ldw	r2,-16(fp)
 2019e28:	10800117 	ldw	r2,4(r2)
 2019e2c:	1009883a 	mov	r4,r2
 2019e30:	201d2f40 	call	201d2f4 <pbuf_free>
          memp_free(MEMP_ARP_QUEUE, old);
 2019e34:	e17ffc17 	ldw	r5,-16(fp)
 2019e38:	010002c4 	movi	r4,11
 2019e3c:	201b9640 	call	201b964 <memp_free>
        }
#endif
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"U16_F"\n", (void *)q, i));
        result = ERR_OK;
 2019e40:	e03ff305 	stb	zero,-52(fp)
 2019e44:	00000e06 	br	2019e80 <etharp_query+0x468>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
 2019e48:	e13ff517 	ldw	r4,-44(fp)
 2019e4c:	201d2f40 	call	201d2f4 <pbuf_free>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
 2019e50:	00bfffc4 	movi	r2,-1
 2019e54:	e0bff305 	stb	r2,-52(fp)
 2019e58:	00000906 	br	2019e80 <etharp_query+0x468>
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"U16_F"\n", (void *)q, (u16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
 2019e5c:	008085f4 	movhi	r2,535
 2019e60:	10bd8204 	addi	r2,r2,-2552
 2019e64:	10801217 	ldw	r2,72(r2)
 2019e68:	10c00044 	addi	r3,r2,1
 2019e6c:	008085f4 	movhi	r2,535
 2019e70:	10bd8204 	addi	r2,r2,-2552
 2019e74:	10c01215 	stw	r3,72(r2)
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
 2019e78:	00bfffc4 	movi	r2,-1
 2019e7c:	e0bff305 	stb	r2,-52(fp)
    }
  }
  return result;
 2019e80:	e0bff303 	ldbu	r2,-52(fp)
}
 2019e84:	e037883a 	mov	sp,fp
 2019e88:	dfc00117 	ldw	ra,4(sp)
 2019e8c:	df000017 	ldw	fp,0(sp)
 2019e90:	dec00204 	addi	sp,sp,8
 2019e94:	f800283a 	ret

02019e98 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
 2019e98:	defff504 	addi	sp,sp,-44
 2019e9c:	dfc00a15 	stw	ra,40(sp)
 2019ea0:	df000915 	stw	fp,36(sp)
 2019ea4:	df000904 	addi	fp,sp,36
 2019ea8:	e13ffb15 	stw	r4,-20(fp)
 2019eac:	e17ffc15 	stw	r5,-16(fp)
 2019eb0:	e1bffd15 	stw	r6,-12(fp)
 2019eb4:	e1fffe15 	stw	r7,-8(fp)
 2019eb8:	e0800517 	ldw	r2,20(fp)
 2019ebc:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  err_t result = ERR_OK;
 2019ec0:	e03ff805 	stb	zero,-32(fp)
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
 2019ec4:	0180a004 	movi	r6,640
 2019ec8:	01400704 	movi	r5,28
 2019ecc:	01000404 	movi	r4,16
 2019ed0:	201c9740 	call	201c974 <pbuf_alloc>
 2019ed4:	e0bff915 	stw	r2,-28(fp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 2019ed8:	e0bff917 	ldw	r2,-28(fp)
 2019edc:	1000091e 	bne	r2,zero,2019f04 <etharp_raw+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
 2019ee0:	008085f4 	movhi	r2,535
 2019ee4:	10bd8204 	addi	r2,r2,-2552
 2019ee8:	10801217 	ldw	r2,72(r2)
 2019eec:	10c00044 	addi	r3,r2,1
 2019ef0:	008085f4 	movhi	r2,535
 2019ef4:	10bd8204 	addi	r2,r2,-2552
 2019ef8:	10c01215 	stw	r3,72(r2)
    return ERR_MEM;
 2019efc:	00bfffc4 	movi	r2,-1
 2019f00:	00005906 	br	201a068 <etharp_raw+0x1d0>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
 2019f04:	e0bff917 	ldw	r2,-28(fp)
 2019f08:	10800117 	ldw	r2,4(r2)
 2019f0c:	e0bffa15 	stw	r2,-24(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
 2019f10:	e0bfff0b 	ldhu	r2,-4(fp)
 2019f14:	1009883a 	mov	r4,r2
 2019f18:	20394740 	call	2039474 <lwip_htons>
 2019f1c:	100d883a 	mov	r6,r2
 2019f20:	e0bffa17 	ldw	r2,-24(fp)
 2019f24:	30ffffcc 	andi	r3,r6,65535
 2019f28:	19403fcc 	andi	r5,r3,255
 2019f2c:	10c00183 	ldbu	r3,6(r2)
 2019f30:	1806703a 	and	r3,r3,zero
 2019f34:	1809883a 	mov	r4,r3
 2019f38:	2807883a 	mov	r3,r5
 2019f3c:	20c6b03a 	or	r3,r4,r3
 2019f40:	10c00185 	stb	r3,6(r2)
 2019f44:	30ffffcc 	andi	r3,r6,65535
 2019f48:	1806d23a 	srli	r3,r3,8
 2019f4c:	197fffcc 	andi	r5,r3,65535
 2019f50:	10c001c3 	ldbu	r3,7(r2)
 2019f54:	1806703a 	and	r3,r3,zero
 2019f58:	1809883a 	mov	r4,r3
 2019f5c:	2807883a 	mov	r3,r5
 2019f60:	20c6b03a 	or	r3,r4,r3
 2019f64:	10c001c5 	stb	r3,7(r2)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  SMEMCPY(&hdr->shwaddr, hwsrc_addr, ETH_HWADDR_LEN);
 2019f68:	e0bffa17 	ldw	r2,-24(fp)
 2019f6c:	10800204 	addi	r2,r2,8
 2019f70:	01800184 	movi	r6,6
 2019f74:	e17ffe17 	ldw	r5,-8(fp)
 2019f78:	1009883a 	mov	r4,r2
 2019f7c:	2005e580 	call	2005e58 <memcpy>
  SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 2019f80:	e0bffa17 	ldw	r2,-24(fp)
 2019f84:	10800484 	addi	r2,r2,18
 2019f88:	01800184 	movi	r6,6
 2019f8c:	e1400317 	ldw	r5,12(fp)
 2019f90:	1009883a 	mov	r4,r2
 2019f94:	2005e580 	call	2005e58 <memcpy>
  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->sipaddr, ipsrc_addr);
 2019f98:	e0bffa17 	ldw	r2,-24(fp)
 2019f9c:	10800384 	addi	r2,r2,14
 2019fa0:	01800104 	movi	r6,4
 2019fa4:	e1400217 	ldw	r5,8(fp)
 2019fa8:	1009883a 	mov	r4,r2
 2019fac:	2005e580 	call	2005e58 <memcpy>
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
 2019fb0:	e0bffa17 	ldw	r2,-24(fp)
 2019fb4:	10800604 	addi	r2,r2,24
 2019fb8:	01800104 	movi	r6,4
 2019fbc:	e1400417 	ldw	r5,16(fp)
 2019fc0:	1009883a 	mov	r4,r2
 2019fc4:	2005e580 	call	2005e58 <memcpy>

  hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
 2019fc8:	e0bffa17 	ldw	r2,-24(fp)
 2019fcc:	10c00003 	ldbu	r3,0(r2)
 2019fd0:	1806703a 	and	r3,r3,zero
 2019fd4:	10c00005 	stb	r3,0(r2)
 2019fd8:	10c00043 	ldbu	r3,1(r2)
 2019fdc:	1806703a 	and	r3,r3,zero
 2019fe0:	18c00054 	ori	r3,r3,1
 2019fe4:	10c00045 	stb	r3,1(r2)
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 2019fe8:	e0bffa17 	ldw	r2,-24(fp)
 2019fec:	10c00083 	ldbu	r3,2(r2)
 2019ff0:	1806703a 	and	r3,r3,zero
 2019ff4:	18c00214 	ori	r3,r3,8
 2019ff8:	10c00085 	stb	r3,2(r2)
 2019ffc:	10c000c3 	ldbu	r3,3(r2)
 201a000:	1806703a 	and	r3,r3,zero
 201a004:	10c000c5 	stb	r3,3(r2)
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
 201a008:	e0bffa17 	ldw	r2,-24(fp)
 201a00c:	00c00184 	movi	r3,6
 201a010:	10c00105 	stb	r3,4(r2)
  hdr->protolen = sizeof(ip4_addr_t);
 201a014:	e0bffa17 	ldw	r2,-24(fp)
 201a018:	00c00104 	movi	r3,4
 201a01c:	10c00145 	stb	r3,5(r2)
  if (ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 201a020:	00820184 	movi	r2,2054
 201a024:	d8800015 	stw	r2,0(sp)
 201a028:	e1fffd17 	ldw	r7,-12(fp)
 201a02c:	e1bffc17 	ldw	r6,-16(fp)
 201a030:	e17ff917 	ldw	r5,-28(fp)
 201a034:	e13ffb17 	ldw	r4,-20(fp)
 201a038:	202afa40 	call	202afa4 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
 201a03c:	008085f4 	movhi	r2,535
 201a040:	10bd8204 	addi	r2,r2,-2552
 201a044:	10800c17 	ldw	r2,48(r2)
 201a048:	10c00044 	addi	r3,r2,1
 201a04c:	008085f4 	movhi	r2,535
 201a050:	10bd8204 	addi	r2,r2,-2552
 201a054:	10c00c15 	stw	r3,48(r2)
  /* free ARP query packet */
  pbuf_free(p);
 201a058:	e13ff917 	ldw	r4,-28(fp)
 201a05c:	201d2f40 	call	201d2f4 <pbuf_free>
  p = NULL;
 201a060:	e03ff915 	stw	zero,-28(fp)
  /* could not allocate pbuf for ARP request */

  return result;
 201a064:	e0bff803 	ldbu	r2,-32(fp)
}
 201a068:	e037883a 	mov	sp,fp
 201a06c:	dfc00117 	ldw	ra,4(sp)
 201a070:	df000017 	ldw	fp,0(sp)
 201a074:	dec00204 	addi	sp,sp,8
 201a078:	f800283a 	ret

0201a07c <etharp_request_dst>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr *hw_dst_addr)
{
 201a07c:	defff704 	addi	sp,sp,-36
 201a080:	dfc00815 	stw	ra,32(sp)
 201a084:	df000715 	stw	fp,28(sp)
 201a088:	df000704 	addi	fp,sp,28
 201a08c:	e13ffd15 	stw	r4,-12(fp)
 201a090:	e17ffe15 	stw	r5,-8(fp)
 201a094:	e1bfff15 	stw	r6,-4(fp)
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 201a098:	e0bffd17 	ldw	r2,-12(fp)
 201a09c:	11000d84 	addi	r4,r2,54
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 201a0a0:	e0bffd17 	ldw	r2,-12(fp)
 201a0a4:	11400d84 	addi	r5,r2,54
 201a0a8:	e0bffd17 	ldw	r2,-12(fp)
 201a0ac:	10800104 	addi	r2,r2,4
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr *hw_dst_addr)
{
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 201a0b0:	00c00044 	movi	r3,1
 201a0b4:	d8c00315 	stw	r3,12(sp)
 201a0b8:	e0fffe17 	ldw	r3,-8(fp)
 201a0bc:	d8c00215 	stw	r3,8(sp)
 201a0c0:	d0e01704 	addi	r3,gp,-32676
 201a0c4:	d8c00115 	stw	r3,4(sp)
 201a0c8:	d8800015 	stw	r2,0(sp)
 201a0cc:	280f883a 	mov	r7,r5
 201a0d0:	e1bfff17 	ldw	r6,-4(fp)
 201a0d4:	200b883a 	mov	r5,r4
 201a0d8:	e13ffd17 	ldw	r4,-12(fp)
 201a0dc:	2019e980 	call	2019e98 <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
                    ipaddr, ARP_REQUEST);
}
 201a0e0:	e037883a 	mov	sp,fp
 201a0e4:	dfc00117 	ldw	ra,4(sp)
 201a0e8:	df000017 	ldw	fp,0(sp)
 201a0ec:	dec00204 	addi	sp,sp,8
 201a0f0:	f800283a 	ret

0201a0f4 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
 201a0f4:	defffc04 	addi	sp,sp,-16
 201a0f8:	dfc00315 	stw	ra,12(sp)
 201a0fc:	df000215 	stw	fp,8(sp)
 201a100:	df000204 	addi	fp,sp,8
 201a104:	e13ffe15 	stw	r4,-8(fp)
 201a108:	e17fff15 	stw	r5,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 201a10c:	d1a01584 	addi	r6,gp,-32682
 201a110:	e17fff17 	ldw	r5,-4(fp)
 201a114:	e13ffe17 	ldw	r4,-8(fp)
 201a118:	201a07c0 	call	201a07c <etharp_request_dst>
}
 201a11c:	e037883a 	mov	sp,fp
 201a120:	dfc00117 	ldw	ra,4(sp)
 201a124:	df000017 	ldw	fp,0(sp)
 201a128:	dec00204 	addi	sp,sp,8
 201a12c:	f800283a 	ret

0201a130 <etharp_acd_probe>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_acd_probe(struct netif *netif, const ip4_addr_t *ipaddr)
{
 201a130:	defff804 	addi	sp,sp,-32
 201a134:	dfc00715 	stw	ra,28(sp)
 201a138:	df000615 	stw	fp,24(sp)
 201a13c:	df000604 	addi	fp,sp,24
 201a140:	e13ffe15 	stw	r4,-8(fp)
 201a144:	e17fff15 	stw	r5,-4(fp)
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 201a148:	e0bffe17 	ldw	r2,-8(fp)
 201a14c:	10c00d84 	addi	r3,r2,54
                    (struct eth_addr *)netif->hwaddr, IP4_ADDR_ANY4, &ethzero,
 201a150:	e0bffe17 	ldw	r2,-8(fp)
 201a154:	11000d84 	addi	r4,r2,54
 *         any other err_t on failure
 */
err_t
etharp_acd_probe(struct netif *netif, const ip4_addr_t *ipaddr)
{
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 201a158:	00800044 	movi	r2,1
 201a15c:	d8800315 	stw	r2,12(sp)
 201a160:	e0bfff17 	ldw	r2,-4(fp)
 201a164:	d8800215 	stw	r2,8(sp)
 201a168:	d0a01704 	addi	r2,gp,-32676
 201a16c:	d8800115 	stw	r2,4(sp)
 201a170:	d0a00e04 	addi	r2,gp,-32712
 201a174:	d8800015 	stw	r2,0(sp)
 201a178:	200f883a 	mov	r7,r4
 201a17c:	d1a01584 	addi	r6,gp,-32682
 201a180:	180b883a 	mov	r5,r3
 201a184:	e13ffe17 	ldw	r4,-8(fp)
 201a188:	2019e980 	call	2019e98 <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, IP4_ADDR_ANY4, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 201a18c:	e037883a 	mov	sp,fp
 201a190:	dfc00117 	ldw	ra,4(sp)
 201a194:	df000017 	ldw	fp,0(sp)
 201a198:	dec00204 	addi	sp,sp,8
 201a19c:	f800283a 	ret

0201a1a0 <etharp_acd_announce>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_acd_announce(struct netif *netif, const ip4_addr_t *ipaddr)
{
 201a1a0:	defff804 	addi	sp,sp,-32
 201a1a4:	dfc00715 	stw	ra,28(sp)
 201a1a8:	df000615 	stw	fp,24(sp)
 201a1ac:	df000604 	addi	fp,sp,24
 201a1b0:	e13ffe15 	stw	r4,-8(fp)
 201a1b4:	e17fff15 	stw	r5,-4(fp)
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 201a1b8:	e0bffe17 	ldw	r2,-8(fp)
 201a1bc:	10c00d84 	addi	r3,r2,54
                    (struct eth_addr *)netif->hwaddr, ipaddr, &ethzero,
 201a1c0:	e0bffe17 	ldw	r2,-8(fp)
 201a1c4:	11000d84 	addi	r4,r2,54
 *         any other err_t on failure
 */
err_t
etharp_acd_announce(struct netif *netif, const ip4_addr_t *ipaddr)
{
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 201a1c8:	00800044 	movi	r2,1
 201a1cc:	d8800315 	stw	r2,12(sp)
 201a1d0:	e0bfff17 	ldw	r2,-4(fp)
 201a1d4:	d8800215 	stw	r2,8(sp)
 201a1d8:	d0a01704 	addi	r2,gp,-32676
 201a1dc:	d8800115 	stw	r2,4(sp)
 201a1e0:	e0bfff17 	ldw	r2,-4(fp)
 201a1e4:	d8800015 	stw	r2,0(sp)
 201a1e8:	200f883a 	mov	r7,r4
 201a1ec:	d1a01584 	addi	r6,gp,-32682
 201a1f0:	180b883a 	mov	r5,r3
 201a1f4:	e13ffe17 	ldw	r4,-8(fp)
 201a1f8:	2019e980 	call	2019e98 <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, ipaddr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 201a1fc:	e037883a 	mov	sp,fp
 201a200:	dfc00117 	ldw	ra,4(sp)
 201a204:	df000017 	ldw	fp,0(sp)
 201a208:	dec00204 	addi	sp,sp,8
 201a20c:	f800283a 	ret

0201a210 <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 201a210:	defffc04 	addi	sp,sp,-16
 201a214:	df000315 	stw	fp,12(sp)
 201a218:	df000304 	addi	fp,sp,12
 201a21c:	e13ffe15 	stw	r4,-8(fp)
 201a220:	e17fff15 	stw	r5,-4(fp)
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
 201a224:	e0bffe17 	ldw	r2,-8(fp)
 201a228:	e0bffd15 	stw	r2,-12(fp)

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 201a22c:	e0bffe17 	ldw	r2,-8(fp)
 201a230:	10bfffe0 	cmpeqi	r2,r2,-1
 201a234:	1000021e 	bne	r2,zero,201a240 <ip4_addr_isbroadcast_u32+0x30>
 201a238:	e0bffe17 	ldw	r2,-8(fp)
 201a23c:	1000021e 	bne	r2,zero,201a248 <ip4_addr_isbroadcast_u32+0x38>
      (addr == IPADDR_ANY)) {
    return 1;
 201a240:	00800044 	movi	r2,1
 201a244:	00002606 	br	201a2e0 <ip4_addr_isbroadcast_u32+0xd0>
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 201a248:	e0bfff17 	ldw	r2,-4(fp)
 201a24c:	10800f43 	ldbu	r2,61(r2)
 201a250:	10803fcc 	andi	r2,r2,255
 201a254:	1080008c 	andi	r2,r2,2
 201a258:	1000021e 	bne	r2,zero,201a264 <ip4_addr_isbroadcast_u32+0x54>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 201a25c:	0005883a 	mov	r2,zero
 201a260:	00001f06 	br	201a2e0 <ip4_addr_isbroadcast_u32+0xd0>
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 201a264:	e0bfff17 	ldw	r2,-4(fp)
 201a268:	10800104 	addi	r2,r2,4
 201a26c:	10c00017 	ldw	r3,0(r2)
 201a270:	e0bffe17 	ldw	r2,-8(fp)
 201a274:	1880021e 	bne	r3,r2,201a280 <ip4_addr_isbroadcast_u32+0x70>
    return 0;
 201a278:	0005883a 	mov	r2,zero
 201a27c:	00001806 	br	201a2e0 <ip4_addr_isbroadcast_u32+0xd0>
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 201a280:	e0fffd17 	ldw	r3,-12(fp)
 201a284:	e0bfff17 	ldw	r2,-4(fp)
 201a288:	10800104 	addi	r2,r2,4
 201a28c:	10800017 	ldw	r2,0(r2)
 201a290:	1886f03a 	xor	r3,r3,r2
 201a294:	e0bfff17 	ldw	r2,-4(fp)
 201a298:	10800204 	addi	r2,r2,8
 201a29c:	10800017 	ldw	r2,0(r2)
 201a2a0:	1884703a 	and	r2,r3,r2
 201a2a4:	10000d1e 	bne	r2,zero,201a2dc <ip4_addr_isbroadcast_u32+0xcc>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 201a2a8:	e0bfff17 	ldw	r2,-4(fp)
 201a2ac:	10800204 	addi	r2,r2,8
 201a2b0:	10800017 	ldw	r2,0(r2)
 201a2b4:	0086303a 	nor	r3,zero,r2
 201a2b8:	e0bffe17 	ldw	r2,-8(fp)
 201a2bc:	1886703a 	and	r3,r3,r2
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
 201a2c0:	e0bfff17 	ldw	r2,-4(fp)
 201a2c4:	10800204 	addi	r2,r2,8
 201a2c8:	10800017 	ldw	r2,0(r2)
 201a2cc:	0084303a 	nor	r2,zero,r2
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
    return 0;
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 201a2d0:	1880021e 	bne	r3,r2,201a2dc <ip4_addr_isbroadcast_u32+0xcc>
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
    /* => network broadcast address */
    return 1;
 201a2d4:	00800044 	movi	r2,1
 201a2d8:	00000106 	br	201a2e0 <ip4_addr_isbroadcast_u32+0xd0>
  } else {
    return 0;
 201a2dc:	0005883a 	mov	r2,zero
  }
}
 201a2e0:	e037883a 	mov	sp,fp
 201a2e4:	df000017 	ldw	fp,0(sp)
 201a2e8:	dec00104 	addi	sp,sp,4
 201a2ec:	f800283a 	ret

0201a2f0 <ip4_addr_netmask_valid>:
 * @param netmask the IPv4 netmask to check (in network byte order!)
 * @return 1 if the netmask is valid, 0 if it is not
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
 201a2f0:	defffb04 	addi	sp,sp,-20
 201a2f4:	dfc00415 	stw	ra,16(sp)
 201a2f8:	df000315 	stw	fp,12(sp)
 201a2fc:	df000304 	addi	fp,sp,12
 201a300:	e13fff15 	stw	r4,-4(fp)
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
 201a304:	e13fff17 	ldw	r4,-4(fp)
 201a308:	20394b00 	call	20394b0 <lwip_htonl>
 201a30c:	e0bffe15 	stw	r2,-8(fp)

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
 201a310:	00a00034 	movhi	r2,32768
 201a314:	e0bffd15 	stw	r2,-12(fp)
 201a318:	00000706 	br	201a338 <ip4_addr_netmask_valid+0x48>
    if ((nm_hostorder & mask) == 0) {
 201a31c:	e0fffe17 	ldw	r3,-8(fp)
 201a320:	e0bffd17 	ldw	r2,-12(fp)
 201a324:	1884703a 	and	r2,r3,r2
 201a328:	10000626 	beq	r2,zero,201a344 <ip4_addr_netmask_valid+0x54>
{
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
 201a32c:	e0bffd17 	ldw	r2,-12(fp)
 201a330:	1004d07a 	srli	r2,r2,1
 201a334:	e0bffd15 	stw	r2,-12(fp)
 201a338:	e0bffd17 	ldw	r2,-12(fp)
 201a33c:	103ff71e 	bne	r2,zero,201a31c <__alt_mem_mem_0+0xfcffa31c>
 201a340:	00000b06 	br	201a370 <ip4_addr_netmask_valid+0x80>
    if ((nm_hostorder & mask) == 0) {
      break;
 201a344:	0001883a 	nop
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
 201a348:	00000906 	br	201a370 <ip4_addr_netmask_valid+0x80>
    if ((nm_hostorder & mask) != 0) {
 201a34c:	e0fffe17 	ldw	r3,-8(fp)
 201a350:	e0bffd17 	ldw	r2,-12(fp)
 201a354:	1884703a 	and	r2,r3,r2
 201a358:	10000226 	beq	r2,zero,201a364 <ip4_addr_netmask_valid+0x74>
      /* there is a one after the first zero -> invalid */
      return 0;
 201a35c:	0005883a 	mov	r2,zero
 201a360:	00000606 	br	201a37c <ip4_addr_netmask_valid+0x8c>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
 201a364:	e0bffd17 	ldw	r2,-12(fp)
 201a368:	1004d07a 	srli	r2,r2,1
 201a36c:	e0bffd15 	stw	r2,-12(fp)
 201a370:	e0bffd17 	ldw	r2,-12(fp)
 201a374:	103ff51e 	bne	r2,zero,201a34c <__alt_mem_mem_0+0xfcffa34c>
      /* there is a one after the first zero -> invalid */
      return 0;
    }
  }
  /* no one after the first zero -> valid */
  return 1;
 201a378:	00800044 	movi	r2,1
}
 201a37c:	e037883a 	mov	sp,fp
 201a380:	dfc00117 	ldw	ra,4(sp)
 201a384:	df000017 	ldw	fp,0(sp)
 201a388:	dec00204 	addi	sp,sp,8
 201a38c:	f800283a 	ret

0201a390 <ipaddr_addr>:
 * @param cp IP address in ascii representation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
 201a390:	defffc04 	addi	sp,sp,-16
 201a394:	dfc00315 	stw	ra,12(sp)
 201a398:	df000215 	stw	fp,8(sp)
 201a39c:	df000204 	addi	fp,sp,8
 201a3a0:	e13fff15 	stw	r4,-4(fp)
  ip4_addr_t val;

  if (ip4addr_aton(cp, &val)) {
 201a3a4:	e17ffe04 	addi	r5,fp,-8
 201a3a8:	e13fff17 	ldw	r4,-4(fp)
 201a3ac:	201a3d40 	call	201a3d4 <ip4addr_aton>
 201a3b0:	10000226 	beq	r2,zero,201a3bc <ipaddr_addr+0x2c>
    return ip4_addr_get_u32(&val);
 201a3b4:	e0bffe17 	ldw	r2,-8(fp)
 201a3b8:	00000106 	br	201a3c0 <ipaddr_addr+0x30>
  }
  return (IPADDR_NONE);
 201a3bc:	00bfffc4 	movi	r2,-1
}
 201a3c0:	e037883a 	mov	sp,fp
 201a3c4:	dfc00117 	ldw	ra,4(sp)
 201a3c8:	df000017 	ldw	fp,0(sp)
 201a3cc:	dec00204 	addi	sp,sp,8
 201a3d0:	f800283a 	ret

0201a3d4 <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
 201a3d4:	defff504 	addi	sp,sp,-44
 201a3d8:	dfc00a15 	stw	ra,40(sp)
 201a3dc:	df000915 	stw	fp,36(sp)
 201a3e0:	df000904 	addi	fp,sp,36
 201a3e4:	e13ffe15 	stw	r4,-8(fp)
 201a3e8:	e17fff15 	stw	r5,-4(fp)
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 201a3ec:	e0bffa04 	addi	r2,fp,-24
 201a3f0:	e0bff915 	stw	r2,-28(fp)

  c = *cp;
 201a3f4:	e0bffe17 	ldw	r2,-8(fp)
 201a3f8:	10800003 	ldbu	r2,0(r2)
 201a3fc:	e0bff845 	stb	r2,-31(fp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!lwip_isdigit(c)) {
 201a400:	d0e02017 	ldw	r3,-32640(gp)
 201a404:	e0bff843 	ldbu	r2,-31(fp)
 201a408:	10803fcc 	andi	r2,r2,255
 201a40c:	10800044 	addi	r2,r2,1
 201a410:	1885883a 	add	r2,r3,r2
 201a414:	10800003 	ldbu	r2,0(r2)
 201a418:	10803fcc 	andi	r2,r2,255
 201a41c:	1080010c 	andi	r2,r2,4
 201a420:	1000021e 	bne	r2,zero,201a42c <ip4addr_aton+0x58>
      return 0;
 201a424:	0005883a 	mov	r2,zero
 201a428:	0000e706 	br	201a7c8 <ip4addr_aton+0x3f4>
    }
    val = 0;
 201a42c:	e03ff715 	stw	zero,-36(fp)
    base = 10;
 201a430:	00800284 	movi	r2,10
 201a434:	e0bff805 	stb	r2,-32(fp)
    if (c == '0') {
 201a438:	e0bff847 	ldb	r2,-31(fp)
 201a43c:	10800c18 	cmpnei	r2,r2,48
 201a440:	1000171e 	bne	r2,zero,201a4a0 <ip4addr_aton+0xcc>
      c = *++cp;
 201a444:	e0bffe17 	ldw	r2,-8(fp)
 201a448:	10800044 	addi	r2,r2,1
 201a44c:	e0bffe15 	stw	r2,-8(fp)
 201a450:	e0bffe17 	ldw	r2,-8(fp)
 201a454:	10800003 	ldbu	r2,0(r2)
 201a458:	e0bff845 	stb	r2,-31(fp)
      if (c == 'x' || c == 'X') {
 201a45c:	e0bff847 	ldb	r2,-31(fp)
 201a460:	10801e20 	cmpeqi	r2,r2,120
 201a464:	1000031e 	bne	r2,zero,201a474 <ip4addr_aton+0xa0>
 201a468:	e0bff847 	ldb	r2,-31(fp)
 201a46c:	10801618 	cmpnei	r2,r2,88
 201a470:	1000091e 	bne	r2,zero,201a498 <ip4addr_aton+0xc4>
        base = 16;
 201a474:	00800404 	movi	r2,16
 201a478:	e0bff805 	stb	r2,-32(fp)
        c = *++cp;
 201a47c:	e0bffe17 	ldw	r2,-8(fp)
 201a480:	10800044 	addi	r2,r2,1
 201a484:	e0bffe15 	stw	r2,-8(fp)
 201a488:	e0bffe17 	ldw	r2,-8(fp)
 201a48c:	10800003 	ldbu	r2,0(r2)
 201a490:	e0bff845 	stb	r2,-31(fp)
 201a494:	00000206 	br	201a4a0 <ip4addr_aton+0xcc>
      } else {
        base = 8;
 201a498:	00800204 	movi	r2,8
 201a49c:	e0bff805 	stb	r2,-32(fp)
      }
    }
    for (;;) {
      if (lwip_isdigit(c)) {
 201a4a0:	d0e02017 	ldw	r3,-32640(gp)
 201a4a4:	e0bff843 	ldbu	r2,-31(fp)
 201a4a8:	10803fcc 	andi	r2,r2,255
 201a4ac:	10800044 	addi	r2,r2,1
 201a4b0:	1885883a 	add	r2,r3,r2
 201a4b4:	10800003 	ldbu	r2,0(r2)
 201a4b8:	10803fcc 	andi	r2,r2,255
 201a4bc:	1080010c 	andi	r2,r2,4
 201a4c0:	10001526 	beq	r2,zero,201a518 <ip4addr_aton+0x144>
        if((base == 8) && ((u32_t)(c - '0') >= 8))
 201a4c4:	e0bff803 	ldbu	r2,-32(fp)
 201a4c8:	10800218 	cmpnei	r2,r2,8
 201a4cc:	1000041e 	bne	r2,zero,201a4e0 <ip4addr_aton+0x10c>
 201a4d0:	e0bff847 	ldb	r2,-31(fp)
 201a4d4:	10bff404 	addi	r2,r2,-48
 201a4d8:	10800230 	cmpltui	r2,r2,8
 201a4dc:	10003526 	beq	r2,zero,201a5b4 <ip4addr_aton+0x1e0>
          break;
        val = (val * base) + (u32_t)(c - '0');
 201a4e0:	e0fff803 	ldbu	r3,-32(fp)
 201a4e4:	e0bff717 	ldw	r2,-36(fp)
 201a4e8:	1887383a 	mul	r3,r3,r2
 201a4ec:	e0bff847 	ldb	r2,-31(fp)
 201a4f0:	1885883a 	add	r2,r3,r2
 201a4f4:	10bff404 	addi	r2,r2,-48
 201a4f8:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
 201a4fc:	e0bffe17 	ldw	r2,-8(fp)
 201a500:	10800044 	addi	r2,r2,1
 201a504:	e0bffe15 	stw	r2,-8(fp)
 201a508:	e0bffe17 	ldw	r2,-8(fp)
 201a50c:	10800003 	ldbu	r2,0(r2)
 201a510:	e0bff845 	stb	r2,-31(fp)
 201a514:	003fe206 	br	201a4a0 <__alt_mem_mem_0+0xfcffa4a0>
      } else if (base == 16 && lwip_isxdigit(c)) {
 201a518:	e0bff803 	ldbu	r2,-32(fp)
 201a51c:	10800418 	cmpnei	r2,r2,16
 201a520:	1000251e 	bne	r2,zero,201a5b8 <ip4addr_aton+0x1e4>
 201a524:	d0e02017 	ldw	r3,-32640(gp)
 201a528:	e0bff843 	ldbu	r2,-31(fp)
 201a52c:	10803fcc 	andi	r2,r2,255
 201a530:	10800044 	addi	r2,r2,1
 201a534:	1885883a 	add	r2,r3,r2
 201a538:	10800003 	ldbu	r2,0(r2)
 201a53c:	10803fcc 	andi	r2,r2,255
 201a540:	1080110c 	andi	r2,r2,68
 201a544:	10001c26 	beq	r2,zero,201a5b8 <ip4addr_aton+0x1e4>
        val = (val << 4) | (u32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
 201a548:	e0bff717 	ldw	r2,-36(fp)
 201a54c:	1006913a 	slli	r3,r2,4
 201a550:	e0bff847 	ldb	r2,-31(fp)
 201a554:	11000284 	addi	r4,r2,10
 201a558:	d1602017 	ldw	r5,-32640(gp)
 201a55c:	e0bff843 	ldbu	r2,-31(fp)
 201a560:	10803fcc 	andi	r2,r2,255
 201a564:	10800044 	addi	r2,r2,1
 201a568:	2885883a 	add	r2,r5,r2
 201a56c:	10800003 	ldbu	r2,0(r2)
 201a570:	10803fcc 	andi	r2,r2,255
 201a574:	108000cc 	andi	r2,r2,3
 201a578:	10800098 	cmpnei	r2,r2,2
 201a57c:	1000021e 	bne	r2,zero,201a588 <ip4addr_aton+0x1b4>
 201a580:	00801844 	movi	r2,97
 201a584:	00000106 	br	201a58c <ip4addr_aton+0x1b8>
 201a588:	00801044 	movi	r2,65
 201a58c:	2085c83a 	sub	r2,r4,r2
 201a590:	1884b03a 	or	r2,r3,r2
 201a594:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
 201a598:	e0bffe17 	ldw	r2,-8(fp)
 201a59c:	10800044 	addi	r2,r2,1
 201a5a0:	e0bffe15 	stw	r2,-8(fp)
 201a5a4:	e0bffe17 	ldw	r2,-8(fp)
 201a5a8:	10800003 	ldbu	r2,0(r2)
 201a5ac:	e0bff845 	stb	r2,-31(fp)
      } else {
        break;
      }
    }
 201a5b0:	003fbb06 	br	201a4a0 <__alt_mem_mem_0+0xfcffa4a0>
      }
    }
    for (;;) {
      if (lwip_isdigit(c)) {
        if((base == 8) && ((u32_t)(c - '0') >= 8))
          break;
 201a5b4:	0001883a 	nop
        c = *++cp;
      } else {
        break;
      }
    }
    if (c == '.') {
 201a5b8:	e0bff847 	ldb	r2,-31(fp)
 201a5bc:	10800b98 	cmpnei	r2,r2,46
 201a5c0:	1000121e 	bne	r2,zero,201a60c <ip4addr_aton+0x238>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 201a5c4:	e0bffa04 	addi	r2,fp,-24
 201a5c8:	10800304 	addi	r2,r2,12
 201a5cc:	e0fff917 	ldw	r3,-28(fp)
 201a5d0:	18800236 	bltu	r3,r2,201a5dc <ip4addr_aton+0x208>
        return 0;
 201a5d4:	0005883a 	mov	r2,zero
 201a5d8:	00007b06 	br	201a7c8 <ip4addr_aton+0x3f4>
      }
      *pp++ = val;
 201a5dc:	e0bff917 	ldw	r2,-28(fp)
 201a5e0:	10c00104 	addi	r3,r2,4
 201a5e4:	e0fff915 	stw	r3,-28(fp)
 201a5e8:	e0fff717 	ldw	r3,-36(fp)
 201a5ec:	10c00015 	stw	r3,0(r2)
      c = *++cp;
 201a5f0:	e0bffe17 	ldw	r2,-8(fp)
 201a5f4:	10800044 	addi	r2,r2,1
 201a5f8:	e0bffe15 	stw	r2,-8(fp)
 201a5fc:	e0bffe17 	ldw	r2,-8(fp)
 201a600:	10800003 	ldbu	r2,0(r2)
 201a604:	e0bff845 	stb	r2,-31(fp)
    } else {
      break;
    }
  }
 201a608:	003f7d06 	br	201a400 <__alt_mem_mem_0+0xfcffa400>
        return 0;
      }
      *pp++ = val;
      c = *++cp;
    } else {
      break;
 201a60c:	0001883a 	nop
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !lwip_isspace(c)) {
 201a610:	e0bff847 	ldb	r2,-31(fp)
 201a614:	10000b26 	beq	r2,zero,201a644 <ip4addr_aton+0x270>
 201a618:	d0e02017 	ldw	r3,-32640(gp)
 201a61c:	e0bff843 	ldbu	r2,-31(fp)
 201a620:	10803fcc 	andi	r2,r2,255
 201a624:	10800044 	addi	r2,r2,1
 201a628:	1885883a 	add	r2,r3,r2
 201a62c:	10800003 	ldbu	r2,0(r2)
 201a630:	10803fcc 	andi	r2,r2,255
 201a634:	1080020c 	andi	r2,r2,8
 201a638:	1000021e 	bne	r2,zero,201a644 <ip4addr_aton+0x270>
    return 0;
 201a63c:	0005883a 	mov	r2,zero
 201a640:	00006106 	br	201a7c8 <ip4addr_aton+0x3f4>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 201a644:	e0fff917 	ldw	r3,-28(fp)
 201a648:	e0bffa04 	addi	r2,fp,-24
 201a64c:	1885c83a 	sub	r2,r3,r2
 201a650:	1005d0ba 	srai	r2,r2,2
 201a654:	10800044 	addi	r2,r2,1
 201a658:	10c00168 	cmpgeui	r3,r2,5
 201a65c:	18004f1e 	bne	r3,zero,201a79c <ip4addr_aton+0x3c8>
 201a660:	100690ba 	slli	r3,r2,2
 201a664:	008080b4 	movhi	r2,514
 201a668:	10a99e04 	addi	r2,r2,-22920
 201a66c:	1885883a 	add	r2,r3,r2
 201a670:	10800017 	ldw	r2,0(r2)
 201a674:	1000683a 	jmp	r2
 201a678:	0201a68c 	andi	r8,zero,1690
 201a67c:	0201a7a4 	muli	r8,zero,1694
 201a680:	0201a694 	movui	r8,1690
 201a684:	0201a6d4 	movui	r8,1691
 201a688:	0201a72c 	andhi	r8,zero,1692

    case 0:
      return 0;       /* initial nondigit */
 201a68c:	0005883a 	mov	r2,zero
 201a690:	00004d06 	br	201a7c8 <ip4addr_aton+0x3f4>

    case 1:             /* a -- 32 bits */
      break;

    case 2:             /* a.b -- 8.24 bits */
      if (val > 0xffffffUL) {
 201a694:	e0fff717 	ldw	r3,-36(fp)
 201a698:	00804034 	movhi	r2,256
 201a69c:	18800236 	bltu	r3,r2,201a6a8 <ip4addr_aton+0x2d4>
        return 0;
 201a6a0:	0005883a 	mov	r2,zero
 201a6a4:	00004806 	br	201a7c8 <ip4addr_aton+0x3f4>
      }
      if (parts[0] > 0xff) {
 201a6a8:	e0bffa17 	ldw	r2,-24(fp)
 201a6ac:	10804030 	cmpltui	r2,r2,256
 201a6b0:	1000021e 	bne	r2,zero,201a6bc <ip4addr_aton+0x2e8>
        return 0;
 201a6b4:	0005883a 	mov	r2,zero
 201a6b8:	00004306 	br	201a7c8 <ip4addr_aton+0x3f4>
      }
      val |= parts[0] << 24;
 201a6bc:	e0bffa17 	ldw	r2,-24(fp)
 201a6c0:	1004963a 	slli	r2,r2,24
 201a6c4:	e0fff717 	ldw	r3,-36(fp)
 201a6c8:	1884b03a 	or	r2,r3,r2
 201a6cc:	e0bff715 	stw	r2,-36(fp)
      break;
 201a6d0:	00003506 	br	201a7a8 <ip4addr_aton+0x3d4>

    case 3:             /* a.b.c -- 8.8.16 bits */
      if (val > 0xffff) {
 201a6d4:	e0bff717 	ldw	r2,-36(fp)
 201a6d8:	00ffffd4 	movui	r3,65535
 201a6dc:	1880022e 	bgeu	r3,r2,201a6e8 <ip4addr_aton+0x314>
        return 0;
 201a6e0:	0005883a 	mov	r2,zero
 201a6e4:	00003806 	br	201a7c8 <ip4addr_aton+0x3f4>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
 201a6e8:	e0bffa17 	ldw	r2,-24(fp)
 201a6ec:	10804028 	cmpgeui	r2,r2,256
 201a6f0:	1000031e 	bne	r2,zero,201a700 <ip4addr_aton+0x32c>
 201a6f4:	e0bffb17 	ldw	r2,-20(fp)
 201a6f8:	10804030 	cmpltui	r2,r2,256
 201a6fc:	1000021e 	bne	r2,zero,201a708 <ip4addr_aton+0x334>
        return 0;
 201a700:	0005883a 	mov	r2,zero
 201a704:	00003006 	br	201a7c8 <ip4addr_aton+0x3f4>
      }
      val |= (parts[0] << 24) | (parts[1] << 16);
 201a708:	e0bffa17 	ldw	r2,-24(fp)
 201a70c:	1006963a 	slli	r3,r2,24
 201a710:	e0bffb17 	ldw	r2,-20(fp)
 201a714:	1004943a 	slli	r2,r2,16
 201a718:	1884b03a 	or	r2,r3,r2
 201a71c:	e0fff717 	ldw	r3,-36(fp)
 201a720:	1884b03a 	or	r2,r3,r2
 201a724:	e0bff715 	stw	r2,-36(fp)
      break;
 201a728:	00001f06 	br	201a7a8 <ip4addr_aton+0x3d4>

    case 4:             /* a.b.c.d -- 8.8.8.8 bits */
      if (val > 0xff) {
 201a72c:	e0bff717 	ldw	r2,-36(fp)
 201a730:	10804030 	cmpltui	r2,r2,256
 201a734:	1000021e 	bne	r2,zero,201a740 <ip4addr_aton+0x36c>
        return 0;
 201a738:	0005883a 	mov	r2,zero
 201a73c:	00002206 	br	201a7c8 <ip4addr_aton+0x3f4>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
 201a740:	e0bffa17 	ldw	r2,-24(fp)
 201a744:	10804028 	cmpgeui	r2,r2,256
 201a748:	1000061e 	bne	r2,zero,201a764 <ip4addr_aton+0x390>
 201a74c:	e0bffb17 	ldw	r2,-20(fp)
 201a750:	10804028 	cmpgeui	r2,r2,256
 201a754:	1000031e 	bne	r2,zero,201a764 <ip4addr_aton+0x390>
 201a758:	e0bffc17 	ldw	r2,-16(fp)
 201a75c:	10804030 	cmpltui	r2,r2,256
 201a760:	1000021e 	bne	r2,zero,201a76c <ip4addr_aton+0x398>
        return 0;
 201a764:	0005883a 	mov	r2,zero
 201a768:	00001706 	br	201a7c8 <ip4addr_aton+0x3f4>
      }
      val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 201a76c:	e0bffa17 	ldw	r2,-24(fp)
 201a770:	1006963a 	slli	r3,r2,24
 201a774:	e0bffb17 	ldw	r2,-20(fp)
 201a778:	1004943a 	slli	r2,r2,16
 201a77c:	1886b03a 	or	r3,r3,r2
 201a780:	e0bffc17 	ldw	r2,-16(fp)
 201a784:	1004923a 	slli	r2,r2,8
 201a788:	1884b03a 	or	r2,r3,r2
 201a78c:	e0fff717 	ldw	r3,-36(fp)
 201a790:	1884b03a 	or	r2,r3,r2
 201a794:	e0bff715 	stw	r2,-36(fp)
      break;
 201a798:	00000306 	br	201a7a8 <ip4addr_aton+0x3d4>
    default:
      LWIP_ASSERT("unhandled", 0);
      break;
 201a79c:	0001883a 	nop
 201a7a0:	00000106 	br	201a7a8 <ip4addr_aton+0x3d4>

    case 0:
      return 0;       /* initial nondigit */

    case 1:             /* a -- 32 bits */
      break;
 201a7a4:	0001883a 	nop
      break;
    default:
      LWIP_ASSERT("unhandled", 0);
      break;
  }
  if (addr) {
 201a7a8:	e0bfff17 	ldw	r2,-4(fp)
 201a7ac:	10000526 	beq	r2,zero,201a7c4 <ip4addr_aton+0x3f0>
    ip4_addr_set_u32(addr, lwip_htonl(val));
 201a7b0:	e13ff717 	ldw	r4,-36(fp)
 201a7b4:	20394b00 	call	20394b0 <lwip_htonl>
 201a7b8:	1007883a 	mov	r3,r2
 201a7bc:	e0bfff17 	ldw	r2,-4(fp)
 201a7c0:	10c00015 	stw	r3,0(r2)
  }
  return 1;
 201a7c4:	00800044 	movi	r2,1
}
 201a7c8:	e037883a 	mov	sp,fp
 201a7cc:	dfc00117 	ldw	ra,4(sp)
 201a7d0:	df000017 	ldw	fp,0(sp)
 201a7d4:	dec00204 	addi	sp,sp,8
 201a7d8:	f800283a 	ret

0201a7dc <ip4addr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         representation of addr
 */
char *
ip4addr_ntoa(const ip4_addr_t *addr)
{
 201a7dc:	defffd04 	addi	sp,sp,-12
 201a7e0:	dfc00215 	stw	ra,8(sp)
 201a7e4:	df000115 	stw	fp,4(sp)
 201a7e8:	df000104 	addi	fp,sp,4
 201a7ec:	e13fff15 	stw	r4,-4(fp)
  static char str[IP4ADDR_STRLEN_MAX];
  return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
 201a7f0:	01800404 	movi	r6,16
 201a7f4:	01408174 	movhi	r5,517
 201a7f8:	29741f04 	addi	r5,r5,-12164
 201a7fc:	e13fff17 	ldw	r4,-4(fp)
 201a800:	201a8180 	call	201a818 <ip4addr_ntoa_r>
}
 201a804:	e037883a 	mov	sp,fp
 201a808:	dfc00117 	ldw	ra,4(sp)
 201a80c:	df000017 	ldw	fp,0(sp)
 201a810:	dec00204 	addi	sp,sp,8
 201a814:	f800283a 	ret

0201a818 <ip4addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *
ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
 201a818:	defff404 	addi	sp,sp,-48
 201a81c:	dfc00b15 	stw	ra,44(sp)
 201a820:	df000a15 	stw	fp,40(sp)
 201a824:	df000a04 	addi	fp,sp,40
 201a828:	e13ffd15 	stw	r4,-12(fp)
 201a82c:	e17ffe15 	stw	r5,-8(fp)
 201a830:	e1bfff15 	stw	r6,-4(fp)
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 201a834:	e03ff915 	stw	zero,-28(fp)

  s_addr = ip4_addr_get_u32(addr);
 201a838:	e0bffd17 	ldw	r2,-12(fp)
 201a83c:	10800017 	ldw	r2,0(r2)
 201a840:	e0bffb15 	stw	r2,-20(fp)

  rp = buf;
 201a844:	e0bffe17 	ldw	r2,-8(fp)
 201a848:	e0bff615 	stw	r2,-40(fp)
  ap = (u8_t *)&s_addr;
 201a84c:	e0bffb04 	addi	r2,fp,-20
 201a850:	e0bff715 	stw	r2,-36(fp)
  for (n = 0; n < 4; n++) {
 201a854:	e03ff805 	stb	zero,-32(fp)
 201a858:	00004606 	br	201a974 <ip4addr_ntoa_r+0x15c>
    i = 0;
 201a85c:	e03ff845 	stb	zero,-31(fp)
    do {
      rem = *ap % (u8_t)10;
 201a860:	e0bff717 	ldw	r2,-36(fp)
 201a864:	10800003 	ldbu	r2,0(r2)
 201a868:	10803fcc 	andi	r2,r2,255
 201a86c:	01400284 	movi	r5,10
 201a870:	1009883a 	mov	r4,r2
 201a874:	200ab400 	call	200ab40 <__umodsi3>
 201a878:	e0bffa05 	stb	r2,-24(fp)
      *ap /= (u8_t)10;
 201a87c:	e0bff717 	ldw	r2,-36(fp)
 201a880:	10800003 	ldbu	r2,0(r2)
 201a884:	10803fcc 	andi	r2,r2,255
 201a888:	01400284 	movi	r5,10
 201a88c:	1009883a 	mov	r4,r2
 201a890:	200aadc0 	call	200aadc <__udivsi3>
 201a894:	1007883a 	mov	r3,r2
 201a898:	e0bff717 	ldw	r2,-36(fp)
 201a89c:	10c00005 	stb	r3,0(r2)
      inv[i++] = (char)('0' + rem);
 201a8a0:	e0bff843 	ldbu	r2,-31(fp)
 201a8a4:	10c00044 	addi	r3,r2,1
 201a8a8:	e0fff845 	stb	r3,-31(fp)
 201a8ac:	10803fcc 	andi	r2,r2,255
 201a8b0:	e0fffa03 	ldbu	r3,-24(fp)
 201a8b4:	18c00c04 	addi	r3,r3,48
 201a8b8:	1809883a 	mov	r4,r3
 201a8bc:	e0fffc04 	addi	r3,fp,-16
 201a8c0:	1885883a 	add	r2,r3,r2
 201a8c4:	11000005 	stb	r4,0(r2)
    } while (*ap);
 201a8c8:	e0bff717 	ldw	r2,-36(fp)
 201a8cc:	10800003 	ldbu	r2,0(r2)
 201a8d0:	10803fcc 	andi	r2,r2,255
 201a8d4:	103fe21e 	bne	r2,zero,201a860 <__alt_mem_mem_0+0xfcffa860>
    while (i--) {
 201a8d8:	00000f06 	br	201a918 <ip4addr_ntoa_r+0x100>
      if (len++ >= buflen) {
 201a8dc:	e0bff917 	ldw	r2,-28(fp)
 201a8e0:	10c00044 	addi	r3,r2,1
 201a8e4:	e0fff915 	stw	r3,-28(fp)
 201a8e8:	e0ffff17 	ldw	r3,-4(fp)
 201a8ec:	10c00216 	blt	r2,r3,201a8f8 <ip4addr_ntoa_r+0xe0>
        return NULL;
 201a8f0:	0005883a 	mov	r2,zero
 201a8f4:	00002806 	br	201a998 <ip4addr_ntoa_r+0x180>
      }
      *rp++ = inv[i];
 201a8f8:	e0bff617 	ldw	r2,-40(fp)
 201a8fc:	10c00044 	addi	r3,r2,1
 201a900:	e0fff615 	stw	r3,-40(fp)
 201a904:	e0fff843 	ldbu	r3,-31(fp)
 201a908:	e13ffc04 	addi	r4,fp,-16
 201a90c:	20c7883a 	add	r3,r4,r3
 201a910:	18c00003 	ldbu	r3,0(r3)
 201a914:	10c00005 	stb	r3,0(r2)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = (char)('0' + rem);
    } while (*ap);
    while (i--) {
 201a918:	e0bff843 	ldbu	r2,-31(fp)
 201a91c:	10ffffc4 	addi	r3,r2,-1
 201a920:	e0fff845 	stb	r3,-31(fp)
 201a924:	10803fcc 	andi	r2,r2,255
 201a928:	103fec1e 	bne	r2,zero,201a8dc <__alt_mem_mem_0+0xfcffa8dc>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
 201a92c:	e0bff917 	ldw	r2,-28(fp)
 201a930:	10c00044 	addi	r3,r2,1
 201a934:	e0fff915 	stw	r3,-28(fp)
 201a938:	e0ffff17 	ldw	r3,-4(fp)
 201a93c:	10c00216 	blt	r2,r3,201a948 <ip4addr_ntoa_r+0x130>
      return NULL;
 201a940:	0005883a 	mov	r2,zero
 201a944:	00001406 	br	201a998 <ip4addr_ntoa_r+0x180>
    }
    *rp++ = '.';
 201a948:	e0bff617 	ldw	r2,-40(fp)
 201a94c:	10c00044 	addi	r3,r2,1
 201a950:	e0fff615 	stw	r3,-40(fp)
 201a954:	00c00b84 	movi	r3,46
 201a958:	10c00005 	stb	r3,0(r2)
    ap++;
 201a95c:	e0bff717 	ldw	r2,-36(fp)
 201a960:	10800044 	addi	r2,r2,1
 201a964:	e0bff715 	stw	r2,-36(fp)

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for (n = 0; n < 4; n++) {
 201a968:	e0bff803 	ldbu	r2,-32(fp)
 201a96c:	10800044 	addi	r2,r2,1
 201a970:	e0bff805 	stb	r2,-32(fp)
 201a974:	e0bff803 	ldbu	r2,-32(fp)
 201a978:	10800130 	cmpltui	r2,r2,4
 201a97c:	103fb71e 	bne	r2,zero,201a85c <__alt_mem_mem_0+0xfcffa85c>
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
 201a980:	e0bff617 	ldw	r2,-40(fp)
 201a984:	10bfffc4 	addi	r2,r2,-1
 201a988:	e0bff615 	stw	r2,-40(fp)
 201a98c:	e0bff617 	ldw	r2,-40(fp)
 201a990:	10000005 	stb	zero,0(r2)
  return buf;
 201a994:	e0bffe17 	ldw	r2,-8(fp)
}
 201a998:	e037883a 	mov	sp,fp
 201a99c:	dfc00117 	ldw	ra,4(sp)
 201a9a0:	df000017 	ldw	fp,0(sp)
 201a9a4:	dec00204 	addi	sp,sp,8
 201a9a8:	f800283a 	ret

0201a9ac <ptr_to_mem>:
#define mem_overflow_check_element(mem)
#endif /* MEM_OVERFLOW_CHECK */

static struct mem *
ptr_to_mem(mem_size_t ptr)
{
 201a9ac:	defffe04 	addi	sp,sp,-8
 201a9b0:	df000115 	stw	fp,4(sp)
 201a9b4:	df000104 	addi	fp,sp,4
 201a9b8:	2005883a 	mov	r2,r4
 201a9bc:	e0bfff0d 	sth	r2,-4(fp)
  return (struct mem *)(void *)&ram[ptr];
 201a9c0:	d0e7c817 	ldw	r3,-24800(gp)
 201a9c4:	e0bfff0b 	ldhu	r2,-4(fp)
 201a9c8:	1885883a 	add	r2,r3,r2
}
 201a9cc:	e037883a 	mov	sp,fp
 201a9d0:	df000017 	ldw	fp,0(sp)
 201a9d4:	dec00104 	addi	sp,sp,4
 201a9d8:	f800283a 	ret

0201a9dc <mem_to_ptr>:

static mem_size_t
mem_to_ptr(void *mem)
{
 201a9dc:	defffe04 	addi	sp,sp,-8
 201a9e0:	df000115 	stw	fp,4(sp)
 201a9e4:	df000104 	addi	fp,sp,4
 201a9e8:	e13fff15 	stw	r4,-4(fp)
  return (mem_size_t)((u8_t *)mem - ram);
 201a9ec:	e0bfff17 	ldw	r2,-4(fp)
 201a9f0:	d0e7c817 	ldw	r3,-24800(gp)
 201a9f4:	10c5c83a 	sub	r2,r2,r3
}
 201a9f8:	e037883a 	mov	sp,fp
 201a9fc:	df000017 	ldw	fp,0(sp)
 201aa00:	dec00104 	addi	sp,sp,4
 201aa04:	f800283a 	ret

0201aa08 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 201aa08:	defffa04 	addi	sp,sp,-24
 201aa0c:	dfc00515 	stw	ra,20(sp)
 201aa10:	df000415 	stw	fp,16(sp)
 201aa14:	dc000315 	stw	r16,12(sp)
 201aa18:	df000404 	addi	fp,sp,16
 201aa1c:	e13ffe15 	stw	r4,-8(fp)
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = ptr_to_mem(mem->next);
 201aa20:	e0bffe17 	ldw	r2,-8(fp)
 201aa24:	1080000b 	ldhu	r2,0(r2)
 201aa28:	10bfffcc 	andi	r2,r2,65535
 201aa2c:	1009883a 	mov	r4,r2
 201aa30:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201aa34:	e0bffc15 	stw	r2,-16(fp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 201aa38:	e0fffe17 	ldw	r3,-8(fp)
 201aa3c:	e0bffc17 	ldw	r2,-16(fp)
 201aa40:	18801e26 	beq	r3,r2,201aabc <plug_holes+0xb4>
 201aa44:	e0bffc17 	ldw	r2,-16(fp)
 201aa48:	10800103 	ldbu	r2,4(r2)
 201aa4c:	10803fcc 	andi	r2,r2,255
 201aa50:	10001a1e 	bne	r2,zero,201aabc <plug_holes+0xb4>
 201aa54:	d0a7c917 	ldw	r2,-24796(gp)
 201aa58:	e0fffc17 	ldw	r3,-16(fp)
 201aa5c:	18801726 	beq	r3,r2,201aabc <plug_holes+0xb4>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 201aa60:	d0e7cb17 	ldw	r3,-24788(gp)
 201aa64:	e0bffc17 	ldw	r2,-16(fp)
 201aa68:	1880021e 	bne	r3,r2,201aa74 <plug_holes+0x6c>
      lfree = mem;
 201aa6c:	e0bffe17 	ldw	r2,-8(fp)
 201aa70:	d0a7cb15 	stw	r2,-24788(gp)
    }
    mem->next = nmem->next;
 201aa74:	e0bffc17 	ldw	r2,-16(fp)
 201aa78:	10c0000b 	ldhu	r3,0(r2)
 201aa7c:	e0bffe17 	ldw	r2,-8(fp)
 201aa80:	10c0000d 	sth	r3,0(r2)
    if (nmem->next != MEM_SIZE_ALIGNED) {
 201aa84:	e0bffc17 	ldw	r2,-16(fp)
 201aa88:	1080000b 	ldhu	r2,0(r2)
 201aa8c:	10ffffcc 	andi	r3,r2,65535
 201aa90:	00a00014 	movui	r2,32768
 201aa94:	18800926 	beq	r3,r2,201aabc <plug_holes+0xb4>
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
 201aa98:	e0bffc17 	ldw	r2,-16(fp)
 201aa9c:	1080000b 	ldhu	r2,0(r2)
 201aaa0:	10bfffcc 	andi	r2,r2,65535
 201aaa4:	1009883a 	mov	r4,r2
 201aaa8:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201aaac:	1021883a 	mov	r16,r2
 201aab0:	e13ffe17 	ldw	r4,-8(fp)
 201aab4:	201a9dc0 	call	201a9dc <mem_to_ptr>
 201aab8:	8080008d 	sth	r2,2(r16)
    }
  }

  /* plug hole backward */
  pmem = ptr_to_mem(mem->prev);
 201aabc:	e0bffe17 	ldw	r2,-8(fp)
 201aac0:	1080008b 	ldhu	r2,2(r2)
 201aac4:	10bfffcc 	andi	r2,r2,65535
 201aac8:	1009883a 	mov	r4,r2
 201aacc:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201aad0:	e0bffd15 	stw	r2,-12(fp)
  if (pmem != mem && pmem->used == 0) {
 201aad4:	e0fffd17 	ldw	r3,-12(fp)
 201aad8:	e0bffe17 	ldw	r2,-8(fp)
 201aadc:	18801b26 	beq	r3,r2,201ab4c <plug_holes+0x144>
 201aae0:	e0bffd17 	ldw	r2,-12(fp)
 201aae4:	10800103 	ldbu	r2,4(r2)
 201aae8:	10803fcc 	andi	r2,r2,255
 201aaec:	1000171e 	bne	r2,zero,201ab4c <plug_holes+0x144>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 201aaf0:	d0e7cb17 	ldw	r3,-24788(gp)
 201aaf4:	e0bffe17 	ldw	r2,-8(fp)
 201aaf8:	1880021e 	bne	r3,r2,201ab04 <plug_holes+0xfc>
      lfree = pmem;
 201aafc:	e0bffd17 	ldw	r2,-12(fp)
 201ab00:	d0a7cb15 	stw	r2,-24788(gp)
    }
    pmem->next = mem->next;
 201ab04:	e0bffe17 	ldw	r2,-8(fp)
 201ab08:	10c0000b 	ldhu	r3,0(r2)
 201ab0c:	e0bffd17 	ldw	r2,-12(fp)
 201ab10:	10c0000d 	sth	r3,0(r2)
    if (mem->next != MEM_SIZE_ALIGNED) {
 201ab14:	e0bffe17 	ldw	r2,-8(fp)
 201ab18:	1080000b 	ldhu	r2,0(r2)
 201ab1c:	10ffffcc 	andi	r3,r2,65535
 201ab20:	00a00014 	movui	r2,32768
 201ab24:	18800926 	beq	r3,r2,201ab4c <plug_holes+0x144>
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
 201ab28:	e0bffe17 	ldw	r2,-8(fp)
 201ab2c:	1080000b 	ldhu	r2,0(r2)
 201ab30:	10bfffcc 	andi	r2,r2,65535
 201ab34:	1009883a 	mov	r4,r2
 201ab38:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201ab3c:	1021883a 	mov	r16,r2
 201ab40:	e13ffd17 	ldw	r4,-12(fp)
 201ab44:	201a9dc0 	call	201a9dc <mem_to_ptr>
 201ab48:	8080008d 	sth	r2,2(r16)
    }
  }
}
 201ab4c:	0001883a 	nop
 201ab50:	e6ffff04 	addi	sp,fp,-4
 201ab54:	dfc00217 	ldw	ra,8(sp)
 201ab58:	df000117 	ldw	fp,4(sp)
 201ab5c:	dc000017 	ldw	r16,0(sp)
 201ab60:	dec00304 	addi	sp,sp,12
 201ab64:	f800283a 	ret

0201ab68 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 201ab68:	defffd04 	addi	sp,sp,-12
 201ab6c:	dfc00215 	stw	ra,8(sp)
 201ab70:	df000115 	stw	fp,4(sp)
 201ab74:	df000104 	addi	fp,sp,4

  LWIP_ASSERT("Sanity check alignment",
              (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 201ab78:	00808574 	movhi	r2,533
 201ab7c:	10b53004 	addi	r2,r2,-11072
 201ab80:	10c000c4 	addi	r3,r2,3
 201ab84:	00bfff04 	movi	r2,-4
 201ab88:	1884703a 	and	r2,r3,r2
 201ab8c:	d0a7c815 	stw	r2,-24800(gp)
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
 201ab90:	d0a7c817 	ldw	r2,-24800(gp)
 201ab94:	e0bfff15 	stw	r2,-4(fp)
  mem->next = MEM_SIZE_ALIGNED;
 201ab98:	e0bfff17 	ldw	r2,-4(fp)
 201ab9c:	00e00004 	movi	r3,-32768
 201aba0:	10c0000d 	sth	r3,0(r2)
  mem->prev = 0;
 201aba4:	e0bfff17 	ldw	r2,-4(fp)
 201aba8:	1000008d 	sth	zero,2(r2)
  mem->used = 0;
 201abac:	e0bfff17 	ldw	r2,-4(fp)
 201abb0:	10000105 	stb	zero,4(r2)
  /* initialize the end of the heap */
  ram_end = ptr_to_mem(MEM_SIZE_ALIGNED);
 201abb4:	01200014 	movui	r4,32768
 201abb8:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201abbc:	d0a7c915 	stw	r2,-24796(gp)
  ram_end->used = 1;
 201abc0:	d0a7c917 	ldw	r2,-24796(gp)
 201abc4:	00c00044 	movi	r3,1
 201abc8:	10c00105 	stb	r3,4(r2)
  ram_end->next = MEM_SIZE_ALIGNED;
 201abcc:	d0a7c917 	ldw	r2,-24796(gp)
 201abd0:	00e00004 	movi	r3,-32768
 201abd4:	10c0000d 	sth	r3,0(r2)
  ram_end->prev = MEM_SIZE_ALIGNED;
 201abd8:	d0a7c917 	ldw	r2,-24796(gp)
 201abdc:	00e00004 	movi	r3,-32768
 201abe0:	10c0008d 	sth	r3,2(r2)
  MEM_SANITY();

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 201abe4:	d0a7c817 	ldw	r2,-24800(gp)
 201abe8:	d0a7cb15 	stw	r2,-24788(gp)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 201abec:	008085f4 	movhi	r2,535
 201abf0:	10bd8204 	addi	r2,r2,-2552
 201abf4:	00e00004 	movi	r3,-32768
 201abf8:	10c0550d 	sth	r3,340(r2)

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
 201abfc:	d127ca04 	addi	r4,gp,-24792
 201ac00:	2014d940 	call	2014d94 <sys_mutex_new>
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 201ac04:	0001883a 	nop
 201ac08:	e037883a 	mov	sp,fp
 201ac0c:	dfc00117 	ldw	ra,4(sp)
 201ac10:	df000017 	ldw	fp,0(sp)
 201ac14:	dec00204 	addi	sp,sp,8
 201ac18:	f800283a 	ret

0201ac1c <mem_link_valid>:
/* Check if a struct mem is correctly linked.
 * If not, double-free is a possible reason.
 */
static int
mem_link_valid(struct mem *mem)
{
 201ac1c:	defffa04 	addi	sp,sp,-24
 201ac20:	dfc00515 	stw	ra,20(sp)
 201ac24:	df000415 	stw	fp,16(sp)
 201ac28:	df000404 	addi	fp,sp,16
 201ac2c:	e13fff15 	stw	r4,-4(fp)
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
 201ac30:	e13fff17 	ldw	r4,-4(fp)
 201ac34:	201a9dc0 	call	201a9dc <mem_to_ptr>
 201ac38:	e0bffc0d 	sth	r2,-16(fp)
  nmem = ptr_to_mem(mem->next);
 201ac3c:	e0bfff17 	ldw	r2,-4(fp)
 201ac40:	1080000b 	ldhu	r2,0(r2)
 201ac44:	10bfffcc 	andi	r2,r2,65535
 201ac48:	1009883a 	mov	r4,r2
 201ac4c:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201ac50:	e0bffd15 	stw	r2,-12(fp)
  pmem = ptr_to_mem(mem->prev);
 201ac54:	e0bfff17 	ldw	r2,-4(fp)
 201ac58:	1080008b 	ldhu	r2,2(r2)
 201ac5c:	10bfffcc 	andi	r2,r2,65535
 201ac60:	1009883a 	mov	r4,r2
 201ac64:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201ac68:	e0bffe15 	stw	r2,-8(fp)
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 201ac6c:	e0bfff17 	ldw	r2,-4(fp)
 201ac70:	1080000b 	ldhu	r2,0(r2)
 201ac74:	10bfffcc 	andi	r2,r2,65535
 201ac78:	10a00068 	cmpgeui	r2,r2,32769
 201ac7c:	1000171e 	bne	r2,zero,201acdc <mem_link_valid+0xc0>
 201ac80:	e0bfff17 	ldw	r2,-4(fp)
 201ac84:	1080008b 	ldhu	r2,2(r2)
 201ac88:	10bfffcc 	andi	r2,r2,65535
 201ac8c:	10a00068 	cmpgeui	r2,r2,32769
 201ac90:	1000121e 	bne	r2,zero,201acdc <mem_link_valid+0xc0>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 201ac94:	e0bfff17 	ldw	r2,-4(fp)
 201ac98:	1080008b 	ldhu	r2,2(r2)
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
  nmem = ptr_to_mem(mem->next);
  pmem = ptr_to_mem(mem->prev);
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 201ac9c:	10ffffcc 	andi	r3,r2,65535
 201aca0:	e0bffc0b 	ldhu	r2,-16(fp)
 201aca4:	18800526 	beq	r3,r2,201acbc <mem_link_valid+0xa0>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 201aca8:	e0bffe17 	ldw	r2,-8(fp)
 201acac:	1080000b 	ldhu	r2,0(r2)
 201acb0:	10ffffcc 	andi	r3,r2,65535
 201acb4:	e0bffc0b 	ldhu	r2,-16(fp)
 201acb8:	1880081e 	bne	r3,r2,201acdc <mem_link_valid+0xc0>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 201acbc:	d0a7c917 	ldw	r2,-24796(gp)
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
  nmem = ptr_to_mem(mem->next);
  pmem = ptr_to_mem(mem->prev);
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 201acc0:	e0fffd17 	ldw	r3,-12(fp)
 201acc4:	18800726 	beq	r3,r2,201ace4 <mem_link_valid+0xc8>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 201acc8:	e0bffd17 	ldw	r2,-12(fp)
 201accc:	1080008b 	ldhu	r2,2(r2)
 201acd0:	10ffffcc 	andi	r3,r2,65535
 201acd4:	e0bffc0b 	ldhu	r2,-16(fp)
 201acd8:	18800226 	beq	r3,r2,201ace4 <mem_link_valid+0xc8>
    return 0;
 201acdc:	0005883a 	mov	r2,zero
 201ace0:	00000106 	br	201ace8 <mem_link_valid+0xcc>
  }
  return 1;
 201ace4:	00800044 	movi	r2,1
}
 201ace8:	e037883a 	mov	sp,fp
 201acec:	dfc00117 	ldw	ra,4(sp)
 201acf0:	df000017 	ldw	fp,0(sp)
 201acf4:	dec00204 	addi	sp,sp,8
 201acf8:	f800283a 	ret

0201acfc <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 201acfc:	defff804 	addi	sp,sp,-32
 201ad00:	dfc00715 	stw	ra,28(sp)
 201ad04:	df000615 	stw	fp,24(sp)
 201ad08:	df000604 	addi	fp,sp,24
 201ad0c:	e13fff15 	stw	r4,-4(fp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 201ad10:	e0bfff17 	ldw	r2,-4(fp)
 201ad14:	10006526 	beq	r2,zero,201aeac <mem_free+0x1b0>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
 201ad18:	e0bfff17 	ldw	r2,-4(fp)
 201ad1c:	108000cc 	andi	r2,r2,3
 201ad20:	10000c26 	beq	r2,zero,201ad54 <mem_free+0x58>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
 201ad24:	2014cec0 	call	2014cec <sys_arch_protect>
 201ad28:	e0bffa15 	stw	r2,-24(fp)
 201ad2c:	008085f4 	movhi	r2,535
 201ad30:	10bd8204 	addi	r2,r2,-2552
 201ad34:	10805717 	ldw	r2,348(r2)
 201ad38:	10c00044 	addi	r3,r2,1
 201ad3c:	008085f4 	movhi	r2,535
 201ad40:	10bd8204 	addi	r2,r2,-2552
 201ad44:	10c05715 	stw	r3,348(r2)
 201ad48:	e13ffa17 	ldw	r4,-24(fp)
 201ad4c:	2014d200 	call	2014d20 <sys_arch_unprotect>
    return;
 201ad50:	00005706 	br	201aeb0 <mem_free+0x1b4>
  }

  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 201ad54:	e0bfff17 	ldw	r2,-4(fp)
 201ad58:	10bffe04 	addi	r2,r2,-8
 201ad5c:	e0bffb15 	stw	r2,-20(fp)

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
 201ad60:	d0a7c817 	ldw	r2,-24800(gp)
 201ad64:	e0fffb17 	ldw	r3,-20(fp)
 201ad68:	18800436 	bltu	r3,r2,201ad7c <mem_free+0x80>
 201ad6c:	e0bfff17 	ldw	r2,-4(fp)
 201ad70:	10800304 	addi	r2,r2,12
 201ad74:	d0e7c917 	ldw	r3,-24796(gp)
 201ad78:	18800c2e 	bgeu	r3,r2,201adac <mem_free+0xb0>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
 201ad7c:	2014cec0 	call	2014cec <sys_arch_protect>
 201ad80:	e0bffe15 	stw	r2,-8(fp)
 201ad84:	008085f4 	movhi	r2,535
 201ad88:	10bd8204 	addi	r2,r2,-2552
 201ad8c:	10805717 	ldw	r2,348(r2)
 201ad90:	10c00044 	addi	r3,r2,1
 201ad94:	008085f4 	movhi	r2,535
 201ad98:	10bd8204 	addi	r2,r2,-2552
 201ad9c:	10c05715 	stw	r3,348(r2)
 201ada0:	e13ffe17 	ldw	r4,-8(fp)
 201ada4:	2014d200 	call	2014d20 <sys_arch_unprotect>
    return;
 201ada8:	00004106 	br	201aeb0 <mem_free+0x1b4>
  }
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 201adac:	d127ca04 	addi	r4,gp,-24792
 201adb0:	2014e540 	call	2014e54 <sys_mutex_lock>
  /* mem has to be in a used state */
  if (!mem->used) {
 201adb4:	e0bffb17 	ldw	r2,-20(fp)
 201adb8:	10800103 	ldbu	r2,4(r2)
 201adbc:	10803fcc 	andi	r2,r2,255
 201adc0:	10000e1e 	bne	r2,zero,201adfc <mem_free+0x100>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
    LWIP_MEM_FREE_UNPROTECT();
 201adc4:	d127ca04 	addi	r4,gp,-24792
 201adc8:	2014e980 	call	2014e98 <sys_mutex_unlock>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
 201adcc:	2014cec0 	call	2014cec <sys_arch_protect>
 201add0:	e0bffc15 	stw	r2,-16(fp)
 201add4:	008085f4 	movhi	r2,535
 201add8:	10bd8204 	addi	r2,r2,-2552
 201addc:	10805717 	ldw	r2,348(r2)
 201ade0:	10c00044 	addi	r3,r2,1
 201ade4:	008085f4 	movhi	r2,535
 201ade8:	10bd8204 	addi	r2,r2,-2552
 201adec:	10c05715 	stw	r3,348(r2)
 201adf0:	e13ffc17 	ldw	r4,-16(fp)
 201adf4:	2014d200 	call	2014d20 <sys_arch_unprotect>
    return;
 201adf8:	00002d06 	br	201aeb0 <mem_free+0x1b4>
  }

  if (!mem_link_valid(mem)) {
 201adfc:	e13ffb17 	ldw	r4,-20(fp)
 201ae00:	201ac1c0 	call	201ac1c <mem_link_valid>
 201ae04:	10000e1e 	bne	r2,zero,201ae40 <mem_free+0x144>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
    LWIP_MEM_FREE_UNPROTECT();
 201ae08:	d127ca04 	addi	r4,gp,-24792
 201ae0c:	2014e980 	call	2014e98 <sys_mutex_unlock>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
 201ae10:	2014cec0 	call	2014cec <sys_arch_protect>
 201ae14:	e0bffd15 	stw	r2,-12(fp)
 201ae18:	008085f4 	movhi	r2,535
 201ae1c:	10bd8204 	addi	r2,r2,-2552
 201ae20:	10805717 	ldw	r2,348(r2)
 201ae24:	10c00044 	addi	r3,r2,1
 201ae28:	008085f4 	movhi	r2,535
 201ae2c:	10bd8204 	addi	r2,r2,-2552
 201ae30:	10c05715 	stw	r3,348(r2)
 201ae34:	e13ffd17 	ldw	r4,-12(fp)
 201ae38:	2014d200 	call	2014d20 <sys_arch_unprotect>
    return;
 201ae3c:	00001c06 	br	201aeb0 <mem_free+0x1b4>
  }

  /* mem is now unused. */
  mem->used = 0;
 201ae40:	e0bffb17 	ldw	r2,-20(fp)
 201ae44:	10000105 	stb	zero,4(r2)

  if (mem < lfree) {
 201ae48:	d0a7cb17 	ldw	r2,-24788(gp)
 201ae4c:	e0fffb17 	ldw	r3,-20(fp)
 201ae50:	1880022e 	bgeu	r3,r2,201ae5c <mem_free+0x160>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 201ae54:	e0bffb17 	ldw	r2,-20(fp)
 201ae58:	d0a7cb15 	stw	r2,-24788(gp)
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 201ae5c:	008085f4 	movhi	r2,535
 201ae60:	10bd8204 	addi	r2,r2,-2552
 201ae64:	1080558b 	ldhu	r2,342(r2)
 201ae68:	e0fffb17 	ldw	r3,-20(fp)
 201ae6c:	d127c817 	ldw	r4,-24800(gp)
 201ae70:	1907c83a 	sub	r3,r3,r4
 201ae74:	1809883a 	mov	r4,r3
 201ae78:	e0fffb17 	ldw	r3,-20(fp)
 201ae7c:	18c0000b 	ldhu	r3,0(r3)
 201ae80:	20c7c83a 	sub	r3,r4,r3
 201ae84:	10c5883a 	add	r2,r2,r3
 201ae88:	1007883a 	mov	r3,r2
 201ae8c:	008085f4 	movhi	r2,535
 201ae90:	10bd8204 	addi	r2,r2,-2552
 201ae94:	10c0558d 	sth	r3,342(r2)

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 201ae98:	e13ffb17 	ldw	r4,-20(fp)
 201ae9c:	201aa080 	call	201aa08 <plug_holes>
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 201aea0:	d127ca04 	addi	r4,gp,-24792
 201aea4:	2014e980 	call	2014e98 <sys_mutex_unlock>
 201aea8:	00000106 	br	201aeb0 <mem_free+0x1b4>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
 201aeac:	0001883a 	nop
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 201aeb0:	e037883a 	mov	sp,fp
 201aeb4:	dfc00117 	ldw	ra,4(sp)
 201aeb8:	df000017 	ldw	fp,0(sp)
 201aebc:	dec00204 	addi	sp,sp,8
 201aec0:	f800283a 	ret

0201aec4 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
 201aec4:	defff604 	addi	sp,sp,-40
 201aec8:	dfc00915 	stw	ra,36(sp)
 201aecc:	df000815 	stw	fp,32(sp)
 201aed0:	df000804 	addi	fp,sp,32
 201aed4:	e13ffe15 	stw	r4,-8(fp)
 201aed8:	2805883a 	mov	r2,r5
 201aedc:	e0bfff0d 	sth	r2,-4(fp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
 201aee0:	e0bfff0b 	ldhu	r2,-4(fp)
 201aee4:	108000c4 	addi	r2,r2,3
 201aee8:	1007883a 	mov	r3,r2
 201aeec:	00bfff04 	movi	r2,-4
 201aef0:	1884703a 	and	r2,r3,r2
 201aef4:	e0bff80d 	sth	r2,-32(fp)
  if (newsize < MIN_SIZE_ALIGNED) {
 201aef8:	e0bff80b 	ldhu	r2,-32(fp)
 201aefc:	10800328 	cmpgeui	r2,r2,12
 201af00:	1000021e 	bne	r2,zero,201af0c <mem_trim+0x48>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 201af04:	00800304 	movi	r2,12
 201af08:	e0bff80d 	sth	r2,-32(fp)
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
 201af0c:	e0bff80b 	ldhu	r2,-32(fp)
 201af10:	10a00068 	cmpgeui	r2,r2,32769
 201af14:	1000031e 	bne	r2,zero,201af24 <mem_trim+0x60>
 201af18:	e0fff80b 	ldhu	r3,-32(fp)
 201af1c:	e0bfff0b 	ldhu	r2,-4(fp)
 201af20:	1880022e 	bgeu	r3,r2,201af2c <mem_trim+0x68>
    return NULL;
 201af24:	0005883a 	mov	r2,zero
 201af28:	0000a506 	br	201b1c0 <mem_trim+0x2fc>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 201af2c:	d0a7c817 	ldw	r2,-24800(gp)
 201af30:	e0fffe17 	ldw	r3,-8(fp)
 201af34:	18800336 	bltu	r3,r2,201af44 <mem_trim+0x80>
 201af38:	d0a7c917 	ldw	r2,-24796(gp)
 201af3c:	e0fffe17 	ldw	r3,-8(fp)
 201af40:	18800d36 	bltu	r3,r2,201af78 <mem_trim+0xb4>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
 201af44:	2014cec0 	call	2014cec <sys_arch_protect>
 201af48:	e0bffd15 	stw	r2,-12(fp)
 201af4c:	008085f4 	movhi	r2,535
 201af50:	10bd8204 	addi	r2,r2,-2552
 201af54:	10805717 	ldw	r2,348(r2)
 201af58:	10c00044 	addi	r3,r2,1
 201af5c:	008085f4 	movhi	r2,535
 201af60:	10bd8204 	addi	r2,r2,-2552
 201af64:	10c05715 	stw	r3,348(r2)
 201af68:	e13ffd17 	ldw	r4,-12(fp)
 201af6c:	2014d200 	call	2014d20 <sys_arch_unprotect>
    return rmem;
 201af70:	e0bffe17 	ldw	r2,-8(fp)
 201af74:	00009206 	br	201b1c0 <mem_trim+0x2fc>
  }
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 201af78:	e0bffe17 	ldw	r2,-8(fp)
 201af7c:	10bffe04 	addi	r2,r2,-8
 201af80:	e0bff915 	stw	r2,-28(fp)
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* ... and its offset pointer */
  ptr = mem_to_ptr(mem);
 201af84:	e13ff917 	ldw	r4,-28(fp)
 201af88:	201a9dc0 	call	201a9dc <mem_to_ptr>
 201af8c:	e0bffa0d 	sth	r2,-24(fp)

  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
 201af90:	e0bff917 	ldw	r2,-28(fp)
 201af94:	10c0000b 	ldhu	r3,0(r2)
 201af98:	e0bffa0b 	ldhu	r2,-24(fp)
 201af9c:	1885c83a 	sub	r2,r3,r2
 201afa0:	10bffe04 	addi	r2,r2,-8
 201afa4:	e0bffa8d 	sth	r2,-22(fp)
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 201afa8:	e0bff80b 	ldhu	r2,-32(fp)
 201afac:	e0fffa8b 	ldhu	r3,-22(fp)
 201afb0:	1880022e 	bgeu	r3,r2,201afbc <mem_trim+0xf8>
    /* not supported */
    return NULL;
 201afb4:	0005883a 	mov	r2,zero
 201afb8:	00008106 	br	201b1c0 <mem_trim+0x2fc>
  }
  if (newsize == size) {
 201afbc:	e0fff80b 	ldhu	r3,-32(fp)
 201afc0:	e0bffa8b 	ldhu	r2,-22(fp)
 201afc4:	1880021e 	bne	r3,r2,201afd0 <mem_trim+0x10c>
    /* No change in size, simply return */
    return rmem;
 201afc8:	e0bffe17 	ldw	r2,-8(fp)
 201afcc:	00007c06 	br	201b1c0 <mem_trim+0x2fc>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 201afd0:	d127ca04 	addi	r4,gp,-24792
 201afd4:	2014e540 	call	2014e54 <sys_mutex_lock>

  mem2 = ptr_to_mem(mem->next);
 201afd8:	e0bff917 	ldw	r2,-28(fp)
 201afdc:	1080000b 	ldhu	r2,0(r2)
 201afe0:	10bfffcc 	andi	r2,r2,65535
 201afe4:	1009883a 	mov	r4,r2
 201afe8:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201afec:	e0bffb15 	stw	r2,-20(fp)
  if (mem2->used == 0) {
 201aff0:	e0bffb17 	ldw	r2,-20(fp)
 201aff4:	10800103 	ldbu	r2,4(r2)
 201aff8:	10803fcc 	andi	r2,r2,255
 201affc:	1000371e 	bne	r2,zero,201b0dc <mem_trim+0x218>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
    /* remember the old next pointer */
    next = mem2->next;
 201b000:	e0bffb17 	ldw	r2,-20(fp)
 201b004:	1080000b 	ldhu	r2,0(r2)
 201b008:	e0bffc0d 	sth	r2,-16(fp)
    /* create new struct mem which is moved directly after the shrunk mem */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 201b00c:	e0fffa0b 	ldhu	r3,-24(fp)
 201b010:	e0bff80b 	ldhu	r2,-32(fp)
 201b014:	1885883a 	add	r2,r3,r2
 201b018:	10800204 	addi	r2,r2,8
 201b01c:	e0bffc8d 	sth	r2,-14(fp)
    if (lfree == mem2) {
 201b020:	d0e7cb17 	ldw	r3,-24788(gp)
 201b024:	e0bffb17 	ldw	r2,-20(fp)
 201b028:	1880041e 	bne	r3,r2,201b03c <mem_trim+0x178>
      lfree = ptr_to_mem(ptr2);
 201b02c:	e0bffc8b 	ldhu	r2,-14(fp)
 201b030:	1009883a 	mov	r4,r2
 201b034:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b038:	d0a7cb15 	stw	r2,-24788(gp)
    }
    mem2 = ptr_to_mem(ptr2);
 201b03c:	e0bffc8b 	ldhu	r2,-14(fp)
 201b040:	1009883a 	mov	r4,r2
 201b044:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b048:	e0bffb15 	stw	r2,-20(fp)
    mem2->used = 0;
 201b04c:	e0bffb17 	ldw	r2,-20(fp)
 201b050:	10000105 	stb	zero,4(r2)
    /* restore the next pointer */
    mem2->next = next;
 201b054:	e0bffb17 	ldw	r2,-20(fp)
 201b058:	e0fffc0b 	ldhu	r3,-16(fp)
 201b05c:	10c0000d 	sth	r3,0(r2)
    /* link it back to mem */
    mem2->prev = ptr;
 201b060:	e0bffb17 	ldw	r2,-20(fp)
 201b064:	e0fffa0b 	ldhu	r3,-24(fp)
 201b068:	10c0008d 	sth	r3,2(r2)
    /* link mem to it */
    mem->next = ptr2;
 201b06c:	e0bff917 	ldw	r2,-28(fp)
 201b070:	e0fffc8b 	ldhu	r3,-14(fp)
 201b074:	10c0000d 	sth	r3,0(r2)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 201b078:	e0bffb17 	ldw	r2,-20(fp)
 201b07c:	1080000b 	ldhu	r2,0(r2)
 201b080:	10ffffcc 	andi	r3,r2,65535
 201b084:	00a00014 	movui	r2,32768
 201b088:	18800826 	beq	r3,r2,201b0ac <mem_trim+0x1e8>
      ptr_to_mem(mem2->next)->prev = ptr2;
 201b08c:	e0bffb17 	ldw	r2,-20(fp)
 201b090:	1080000b 	ldhu	r2,0(r2)
 201b094:	10bfffcc 	andi	r2,r2,65535
 201b098:	1009883a 	mov	r4,r2
 201b09c:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b0a0:	1007883a 	mov	r3,r2
 201b0a4:	e0bffc8b 	ldhu	r2,-14(fp)
 201b0a8:	1880008d 	sth	r2,2(r3)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 201b0ac:	008085f4 	movhi	r2,535
 201b0b0:	10bd8204 	addi	r2,r2,-2552
 201b0b4:	1080558b 	ldhu	r2,342(r2)
 201b0b8:	e13ff80b 	ldhu	r4,-32(fp)
 201b0bc:	e0fffa8b 	ldhu	r3,-22(fp)
 201b0c0:	20c7c83a 	sub	r3,r4,r3
 201b0c4:	10c5883a 	add	r2,r2,r3
 201b0c8:	1007883a 	mov	r3,r2
 201b0cc:	008085f4 	movhi	r2,535
 201b0d0:	10bd8204 	addi	r2,r2,-2552
 201b0d4:	10c0558d 	sth	r3,342(r2)
 201b0d8:	00003606 	br	201b1b4 <mem_trim+0x2f0>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 201b0dc:	e0bff80b 	ldhu	r2,-32(fp)
 201b0e0:	10800504 	addi	r2,r2,20
 201b0e4:	e0fffa8b 	ldhu	r3,-22(fp)
 201b0e8:	18803236 	bltu	r3,r2,201b1b4 <mem_trim+0x2f0>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 201b0ec:	e0fffa0b 	ldhu	r3,-24(fp)
 201b0f0:	e0bff80b 	ldhu	r2,-32(fp)
 201b0f4:	1885883a 	add	r2,r3,r2
 201b0f8:	10800204 	addi	r2,r2,8
 201b0fc:	e0bffc8d 	sth	r2,-14(fp)
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
    mem2 = ptr_to_mem(ptr2);
 201b100:	e0bffc8b 	ldhu	r2,-14(fp)
 201b104:	1009883a 	mov	r4,r2
 201b108:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b10c:	e0bffb15 	stw	r2,-20(fp)
    if (mem2 < lfree) {
 201b110:	d0a7cb17 	ldw	r2,-24788(gp)
 201b114:	e0fffb17 	ldw	r3,-20(fp)
 201b118:	1880022e 	bgeu	r3,r2,201b124 <mem_trim+0x260>
      lfree = mem2;
 201b11c:	e0bffb17 	ldw	r2,-20(fp)
 201b120:	d0a7cb15 	stw	r2,-24788(gp)
    }
    mem2->used = 0;
 201b124:	e0bffb17 	ldw	r2,-20(fp)
 201b128:	10000105 	stb	zero,4(r2)
    mem2->next = mem->next;
 201b12c:	e0bff917 	ldw	r2,-28(fp)
 201b130:	10c0000b 	ldhu	r3,0(r2)
 201b134:	e0bffb17 	ldw	r2,-20(fp)
 201b138:	10c0000d 	sth	r3,0(r2)
    mem2->prev = ptr;
 201b13c:	e0bffb17 	ldw	r2,-20(fp)
 201b140:	e0fffa0b 	ldhu	r3,-24(fp)
 201b144:	10c0008d 	sth	r3,2(r2)
    mem->next = ptr2;
 201b148:	e0bff917 	ldw	r2,-28(fp)
 201b14c:	e0fffc8b 	ldhu	r3,-14(fp)
 201b150:	10c0000d 	sth	r3,0(r2)
    if (mem2->next != MEM_SIZE_ALIGNED) {
 201b154:	e0bffb17 	ldw	r2,-20(fp)
 201b158:	1080000b 	ldhu	r2,0(r2)
 201b15c:	10ffffcc 	andi	r3,r2,65535
 201b160:	00a00014 	movui	r2,32768
 201b164:	18800826 	beq	r3,r2,201b188 <mem_trim+0x2c4>
      ptr_to_mem(mem2->next)->prev = ptr2;
 201b168:	e0bffb17 	ldw	r2,-20(fp)
 201b16c:	1080000b 	ldhu	r2,0(r2)
 201b170:	10bfffcc 	andi	r2,r2,65535
 201b174:	1009883a 	mov	r4,r2
 201b178:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b17c:	1007883a 	mov	r3,r2
 201b180:	e0bffc8b 	ldhu	r2,-14(fp)
 201b184:	1880008d 	sth	r2,2(r3)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 201b188:	008085f4 	movhi	r2,535
 201b18c:	10bd8204 	addi	r2,r2,-2552
 201b190:	1080558b 	ldhu	r2,342(r2)
 201b194:	e13ff80b 	ldhu	r4,-32(fp)
 201b198:	e0fffa8b 	ldhu	r3,-22(fp)
 201b19c:	20c7c83a 	sub	r3,r4,r3
 201b1a0:	10c5883a 	add	r2,r2,r3
 201b1a4:	1007883a 	mov	r3,r2
 201b1a8:	008085f4 	movhi	r2,535
 201b1ac:	10bd8204 	addi	r2,r2,-2552
 201b1b0:	10c0558d 	sth	r3,342(r2)
#endif
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 201b1b4:	d127ca04 	addi	r4,gp,-24792
 201b1b8:	2014e980 	call	2014e98 <sys_mutex_unlock>
  return rmem;
 201b1bc:	e0bffe17 	ldw	r2,-8(fp)
}
 201b1c0:	e037883a 	mov	sp,fp
 201b1c4:	dfc00117 	ldw	ra,4(sp)
 201b1c8:	df000017 	ldw	fp,0(sp)
 201b1cc:	dec00204 	addi	sp,sp,8
 201b1d0:	f800283a 	ret

0201b1d4 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size_in)
{
 201b1d4:	defff704 	addi	sp,sp,-36
 201b1d8:	dfc00815 	stw	ra,32(sp)
 201b1dc:	df000715 	stw	fp,28(sp)
 201b1e0:	dc000615 	stw	r16,24(sp)
 201b1e4:	df000704 	addi	fp,sp,28
 201b1e8:	2005883a 	mov	r2,r4
 201b1ec:	e0bffe0d 	sth	r2,-8(fp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
 201b1f0:	e0bffe0b 	ldhu	r2,-8(fp)
 201b1f4:	1000021e 	bne	r2,zero,201b200 <mem_malloc+0x2c>
    return NULL;
 201b1f8:	0005883a 	mov	r2,zero
 201b1fc:	0000c006 	br	201b500 <mem_malloc+0x32c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
 201b200:	e0bffe0b 	ldhu	r2,-8(fp)
 201b204:	108000c4 	addi	r2,r2,3
 201b208:	1007883a 	mov	r3,r2
 201b20c:	00bfff04 	movi	r2,-4
 201b210:	1884703a 	and	r2,r3,r2
 201b214:	e0bff98d 	sth	r2,-26(fp)
  if (size < MIN_SIZE_ALIGNED) {
 201b218:	e0bff98b 	ldhu	r2,-26(fp)
 201b21c:	10800328 	cmpgeui	r2,r2,12
 201b220:	1000021e 	bne	r2,zero,201b22c <mem_malloc+0x58>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 201b224:	00800304 	movi	r2,12
 201b228:	e0bff98d 	sth	r2,-26(fp)
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
 201b22c:	e0bff98b 	ldhu	r2,-26(fp)
 201b230:	10a00068 	cmpgeui	r2,r2,32769
 201b234:	1000031e 	bne	r2,zero,201b244 <mem_malloc+0x70>
 201b238:	e0fff98b 	ldhu	r3,-26(fp)
 201b23c:	e0bffe0b 	ldhu	r2,-8(fp)
 201b240:	1880022e 	bgeu	r3,r2,201b24c <mem_malloc+0x78>
    return NULL;
 201b244:	0005883a 	mov	r2,zero
 201b248:	0000ad06 	br	201b500 <mem_malloc+0x32c>
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 201b24c:	d127ca04 	addi	r4,gp,-24792
 201b250:	2014e540 	call	2014e54 <sys_mutex_lock>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 201b254:	d0a7cb17 	ldw	r2,-24788(gp)
 201b258:	1009883a 	mov	r4,r2
 201b25c:	201a9dc0 	call	201a9dc <mem_to_ptr>
 201b260:	e0bff90d 	sth	r2,-28(fp)
 201b264:	00009706 	br	201b4c4 <mem_malloc+0x2f0>
         ptr = ptr_to_mem(ptr)->next) {
      mem = ptr_to_mem(ptr);
 201b268:	e0bff90b 	ldhu	r2,-28(fp)
 201b26c:	1009883a 	mov	r4,r2
 201b270:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b274:	e0bffb15 	stw	r2,-20(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 201b278:	e0bffb17 	ldw	r2,-20(fp)
 201b27c:	10800103 	ldbu	r2,4(r2)
 201b280:	10803fcc 	andi	r2,r2,255
 201b284:	10008a1e 	bne	r2,zero,201b4b0 <mem_malloc+0x2dc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 201b288:	e0bffb17 	ldw	r2,-20(fp)
 201b28c:	1080000b 	ldhu	r2,0(r2)
 201b290:	10ffffcc 	andi	r3,r2,65535
 201b294:	e0bff90b 	ldhu	r2,-28(fp)
 201b298:	1885c83a 	sub	r2,r3,r2
 201b29c:	10fffe04 	addi	r3,r2,-8
 201b2a0:	e0bff98b 	ldhu	r2,-26(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 201b2a4:	18808236 	bltu	r3,r2,201b4b0 <mem_malloc+0x2dc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 201b2a8:	e0bffb17 	ldw	r2,-20(fp)
 201b2ac:	1080000b 	ldhu	r2,0(r2)
 201b2b0:	10ffffcc 	andi	r3,r2,65535
 201b2b4:	e0bff90b 	ldhu	r2,-28(fp)
 201b2b8:	1885c83a 	sub	r2,r3,r2
 201b2bc:	10fffe04 	addi	r3,r2,-8
 201b2c0:	e0bff98b 	ldhu	r2,-26(fp)
 201b2c4:	10800504 	addi	r2,r2,20
 201b2c8:	18803f36 	bltu	r3,r2,201b3c8 <mem_malloc+0x1f4>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
 201b2cc:	e0fff90b 	ldhu	r3,-28(fp)
 201b2d0:	e0bff98b 	ldhu	r2,-26(fp)
 201b2d4:	1885883a 	add	r2,r3,r2
 201b2d8:	10800204 	addi	r2,r2,8
 201b2dc:	e0bffc0d 	sth	r2,-16(fp)
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
          /* create mem2 struct */
          mem2 = ptr_to_mem(ptr2);
 201b2e0:	e0bffc0b 	ldhu	r2,-16(fp)
 201b2e4:	1009883a 	mov	r4,r2
 201b2e8:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b2ec:	e0bffd15 	stw	r2,-12(fp)
          mem2->used = 0;
 201b2f0:	e0bffd17 	ldw	r2,-12(fp)
 201b2f4:	10000105 	stb	zero,4(r2)
          mem2->next = mem->next;
 201b2f8:	e0bffb17 	ldw	r2,-20(fp)
 201b2fc:	10c0000b 	ldhu	r3,0(r2)
 201b300:	e0bffd17 	ldw	r2,-12(fp)
 201b304:	10c0000d 	sth	r3,0(r2)
          mem2->prev = ptr;
 201b308:	e0bffd17 	ldw	r2,-12(fp)
 201b30c:	e0fff90b 	ldhu	r3,-28(fp)
 201b310:	10c0008d 	sth	r3,2(r2)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 201b314:	e0bffb17 	ldw	r2,-20(fp)
 201b318:	e0fffc0b 	ldhu	r3,-16(fp)
 201b31c:	10c0000d 	sth	r3,0(r2)
          mem->used = 1;
 201b320:	e0bffb17 	ldw	r2,-20(fp)
 201b324:	00c00044 	movi	r3,1
 201b328:	10c00105 	stb	r3,4(r2)

          if (mem2->next != MEM_SIZE_ALIGNED) {
 201b32c:	e0bffd17 	ldw	r2,-12(fp)
 201b330:	1080000b 	ldhu	r2,0(r2)
 201b334:	10ffffcc 	andi	r3,r2,65535
 201b338:	00a00014 	movui	r2,32768
 201b33c:	18800826 	beq	r3,r2,201b360 <mem_malloc+0x18c>
            ptr_to_mem(mem2->next)->prev = ptr2;
 201b340:	e0bffd17 	ldw	r2,-12(fp)
 201b344:	1080000b 	ldhu	r2,0(r2)
 201b348:	10bfffcc 	andi	r2,r2,65535
 201b34c:	1009883a 	mov	r4,r2
 201b350:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b354:	1007883a 	mov	r3,r2
 201b358:	e0bffc0b 	ldhu	r2,-16(fp)
 201b35c:	1880008d 	sth	r2,2(r3)
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 201b360:	008085f4 	movhi	r2,535
 201b364:	10bd8204 	addi	r2,r2,-2552
 201b368:	10c0558b 	ldhu	r3,342(r2)
 201b36c:	e0bff98b 	ldhu	r2,-26(fp)
 201b370:	1885883a 	add	r2,r3,r2
 201b374:	10800204 	addi	r2,r2,8
 201b378:	1007883a 	mov	r3,r2
 201b37c:	008085f4 	movhi	r2,535
 201b380:	10bd8204 	addi	r2,r2,-2552
 201b384:	10c0558d 	sth	r3,342(r2)
 201b388:	008085f4 	movhi	r2,535
 201b38c:	10bd8204 	addi	r2,r2,-2552
 201b390:	10c0560b 	ldhu	r3,344(r2)
 201b394:	008085f4 	movhi	r2,535
 201b398:	10bd8204 	addi	r2,r2,-2552
 201b39c:	1080558b 	ldhu	r2,342(r2)
 201b3a0:	18ffffcc 	andi	r3,r3,65535
 201b3a4:	10bfffcc 	andi	r2,r2,65535
 201b3a8:	1880272e 	bgeu	r3,r2,201b448 <mem_malloc+0x274>
 201b3ac:	008085f4 	movhi	r2,535
 201b3b0:	10bd8204 	addi	r2,r2,-2552
 201b3b4:	10c0558b 	ldhu	r3,342(r2)
 201b3b8:	008085f4 	movhi	r2,535
 201b3bc:	10bd8204 	addi	r2,r2,-2552
 201b3c0:	10c0560d 	sth	r3,344(r2)
 201b3c4:	00002006 	br	201b448 <mem_malloc+0x274>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 201b3c8:	e0bffb17 	ldw	r2,-20(fp)
 201b3cc:	00c00044 	movi	r3,1
 201b3d0:	10c00105 	stb	r3,4(r2)
          MEM_STATS_INC_USED(used, mem->next - mem_to_ptr(mem));
 201b3d4:	008085f4 	movhi	r2,535
 201b3d8:	10bd8204 	addi	r2,r2,-2552
 201b3dc:	10c0558b 	ldhu	r3,342(r2)
 201b3e0:	e0bffb17 	ldw	r2,-20(fp)
 201b3e4:	1080000b 	ldhu	r2,0(r2)
 201b3e8:	1885883a 	add	r2,r3,r2
 201b3ec:	1021883a 	mov	r16,r2
 201b3f0:	e13ffb17 	ldw	r4,-20(fp)
 201b3f4:	201a9dc0 	call	201a9dc <mem_to_ptr>
 201b3f8:	8085c83a 	sub	r2,r16,r2
 201b3fc:	1007883a 	mov	r3,r2
 201b400:	008085f4 	movhi	r2,535
 201b404:	10bd8204 	addi	r2,r2,-2552
 201b408:	10c0558d 	sth	r3,342(r2)
 201b40c:	008085f4 	movhi	r2,535
 201b410:	10bd8204 	addi	r2,r2,-2552
 201b414:	10c0560b 	ldhu	r3,344(r2)
 201b418:	008085f4 	movhi	r2,535
 201b41c:	10bd8204 	addi	r2,r2,-2552
 201b420:	1080558b 	ldhu	r2,342(r2)
 201b424:	18ffffcc 	andi	r3,r3,65535
 201b428:	10bfffcc 	andi	r2,r2,65535
 201b42c:	1880062e 	bgeu	r3,r2,201b448 <mem_malloc+0x274>
 201b430:	008085f4 	movhi	r2,535
 201b434:	10bd8204 	addi	r2,r2,-2552
 201b438:	10c0558b 	ldhu	r3,342(r2)
 201b43c:	008085f4 	movhi	r2,535
 201b440:	10bd8204 	addi	r2,r2,-2552
 201b444:	10c0560d 	sth	r3,344(r2)
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 201b448:	d0a7cb17 	ldw	r2,-24788(gp)
 201b44c:	e0fffb17 	ldw	r3,-20(fp)
 201b450:	1880121e 	bne	r3,r2,201b49c <mem_malloc+0x2c8>
          struct mem *cur = lfree;
 201b454:	d0a7cb17 	ldw	r2,-24788(gp)
 201b458:	e0bffa15 	stw	r2,-24(fp)
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 201b45c:	00000606 	br	201b478 <mem_malloc+0x2a4>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
 201b460:	e0bffa17 	ldw	r2,-24(fp)
 201b464:	1080000b 	ldhu	r2,0(r2)
 201b468:	10bfffcc 	andi	r2,r2,65535
 201b46c:	1009883a 	mov	r4,r2
 201b470:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b474:	e0bffa15 	stw	r2,-24(fp)
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 201b478:	e0bffa17 	ldw	r2,-24(fp)
 201b47c:	10800103 	ldbu	r2,4(r2)
 201b480:	10803fcc 	andi	r2,r2,255
 201b484:	10000326 	beq	r2,zero,201b494 <mem_malloc+0x2c0>
 201b488:	d0a7c917 	ldw	r2,-24796(gp)
 201b48c:	e0fffa17 	ldw	r3,-24(fp)
 201b490:	18bff31e 	bne	r3,r2,201b460 <__alt_mem_mem_0+0xfcffb460>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
          }
          lfree = cur;
 201b494:	e0bffa17 	ldw	r2,-24(fp)
 201b498:	d0a7cb15 	stw	r2,-24788(gp)
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
 201b49c:	d127ca04 	addi	r4,gp,-24792
 201b4a0:	2014e980 	call	2014e98 <sys_mutex_unlock>

#if MEM_OVERFLOW_CHECK
        mem_overflow_init_element(mem, size_in);
#endif
        MEM_SANITY();
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
 201b4a4:	e0bffb17 	ldw	r2,-20(fp)
 201b4a8:	10800204 	addi	r2,r2,8
 201b4ac:	00001406 	br	201b500 <mem_malloc+0x32c>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
         ptr = ptr_to_mem(ptr)->next) {
 201b4b0:	e0bff90b 	ldhu	r2,-28(fp)
 201b4b4:	1009883a 	mov	r4,r2
 201b4b8:	201a9ac0 	call	201a9ac <ptr_to_mem>
 201b4bc:	1080000b 	ldhu	r2,0(r2)
 201b4c0:	e0bff90d 	sth	r2,-28(fp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 201b4c4:	e0fff90b 	ldhu	r3,-28(fp)
 201b4c8:	e0bff98b 	ldhu	r2,-26(fp)
 201b4cc:	01200014 	movui	r4,32768
 201b4d0:	2085c83a 	sub	r2,r4,r2
 201b4d4:	18bf6436 	bltu	r3,r2,201b268 <__alt_mem_mem_0+0xfcffb268>
    }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while (local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
 201b4d8:	008085f4 	movhi	r2,535
 201b4dc:	10bd8204 	addi	r2,r2,-2552
 201b4e0:	10805417 	ldw	r2,336(r2)
 201b4e4:	10c00044 	addi	r3,r2,1
 201b4e8:	008085f4 	movhi	r2,535
 201b4ec:	10bd8204 	addi	r2,r2,-2552
 201b4f0:	10c05415 	stw	r3,336(r2)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 201b4f4:	d127ca04 	addi	r4,gp,-24792
 201b4f8:	2014e980 	call	2014e98 <sys_mutex_unlock>
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  return NULL;
 201b4fc:	0005883a 	mov	r2,zero
}
 201b500:	e6ffff04 	addi	sp,fp,-4
 201b504:	dfc00217 	ldw	ra,8(sp)
 201b508:	df000117 	ldw	fp,4(sp)
 201b50c:	dc000017 	ldw	r16,0(sp)
 201b510:	dec00304 	addi	sp,sp,12
 201b514:	f800283a 	ret

0201b518 <mem_calloc>:
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *
mem_calloc(mem_size_t count, mem_size_t size)
{
 201b518:	defffa04 	addi	sp,sp,-24
 201b51c:	dfc00515 	stw	ra,20(sp)
 201b520:	df000415 	stw	fp,16(sp)
 201b524:	df000404 	addi	fp,sp,16
 201b528:	2007883a 	mov	r3,r4
 201b52c:	2805883a 	mov	r2,r5
 201b530:	e0fffe0d 	sth	r3,-8(fp)
 201b534:	e0bfff0d 	sth	r2,-4(fp)
  void *p;
  size_t alloc_size = (size_t)count * (size_t)size;
 201b538:	e0fffe0b 	ldhu	r3,-8(fp)
 201b53c:	e0bfff0b 	ldhu	r2,-4(fp)
 201b540:	1885383a 	mul	r2,r3,r2
 201b544:	e0bffc15 	stw	r2,-16(fp)

  if ((size_t)(mem_size_t)alloc_size != alloc_size) {
 201b548:	e0bffc17 	ldw	r2,-16(fp)
 201b54c:	10ffffcc 	andi	r3,r2,65535
 201b550:	e0bffc17 	ldw	r2,-16(fp)
 201b554:	18800226 	beq	r3,r2,201b560 <mem_calloc+0x48>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_calloc: could not allocate %"SZT_F" bytes\n", alloc_size));
    return NULL;
 201b558:	0005883a 	mov	r2,zero
 201b55c:	00000c06 	br	201b590 <mem_calloc+0x78>
  }

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc((mem_size_t)alloc_size);
 201b560:	e0bffc17 	ldw	r2,-16(fp)
 201b564:	10bfffcc 	andi	r2,r2,65535
 201b568:	1009883a 	mov	r4,r2
 201b56c:	201b1d40 	call	201b1d4 <mem_malloc>
 201b570:	e0bffd15 	stw	r2,-12(fp)
  if (p) {
 201b574:	e0bffd17 	ldw	r2,-12(fp)
 201b578:	10000426 	beq	r2,zero,201b58c <mem_calloc+0x74>
    /* zero the memory */
    memset(p, 0, alloc_size);
 201b57c:	e1bffc17 	ldw	r6,-16(fp)
 201b580:	000b883a 	mov	r5,zero
 201b584:	e13ffd17 	ldw	r4,-12(fp)
 201b588:	2005fa00 	call	2005fa0 <memset>
  }
  return p;
 201b58c:	e0bffd17 	ldw	r2,-12(fp)
}
 201b590:	e037883a 	mov	sp,fp
 201b594:	dfc00117 	ldw	ra,4(sp)
 201b598:	df000017 	ldw	fp,0(sp)
 201b59c:	dec00204 	addi	sp,sp,8
 201b5a0:	f800283a 	ret

0201b5a4 <memp_init_pool>:
 *
 * @param desc pool to initialize
 */
void
memp_init_pool(const struct memp_desc *desc)
{
 201b5a4:	defffc04 	addi	sp,sp,-16
 201b5a8:	df000315 	stw	fp,12(sp)
 201b5ac:	df000304 	addi	fp,sp,12
 201b5b0:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(desc);
#else
  int i;
  struct memp *memp;

  *desc->tab = NULL;
 201b5b4:	e0bfff17 	ldw	r2,-4(fp)
 201b5b8:	10800317 	ldw	r2,12(r2)
 201b5bc:	10000015 	stw	zero,0(r2)
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
 201b5c0:	e0bfff17 	ldw	r2,-4(fp)
 201b5c4:	10800217 	ldw	r2,8(r2)
 201b5c8:	10c000c4 	addi	r3,r2,3
 201b5cc:	00bfff04 	movi	r2,-4
 201b5d0:	1884703a 	and	r2,r3,r2
 201b5d4:	e0bffe15 	stw	r2,-8(fp)
                                       + MEM_SANITY_REGION_AFTER_ALIGNED
#endif
                                      ));
#endif
  /* create a linked list of memp elements */
  for (i = 0; i < desc->num; ++i) {
 201b5d8:	e03ffd15 	stw	zero,-12(fp)
 201b5dc:	00001206 	br	201b628 <memp_init_pool+0x84>
    memp->next = *desc->tab;
 201b5e0:	e0bfff17 	ldw	r2,-4(fp)
 201b5e4:	10800317 	ldw	r2,12(r2)
 201b5e8:	10c00017 	ldw	r3,0(r2)
 201b5ec:	e0bffe17 	ldw	r2,-8(fp)
 201b5f0:	10c00015 	stw	r3,0(r2)
    *desc->tab = memp;
 201b5f4:	e0bfff17 	ldw	r2,-4(fp)
 201b5f8:	10800317 	ldw	r2,12(r2)
 201b5fc:	e0fffe17 	ldw	r3,-8(fp)
 201b600:	10c00015 	stw	r3,0(r2)
#if MEMP_OVERFLOW_CHECK
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */
    /* cast through void* to get rid of alignment warnings */
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 201b604:	e0bfff17 	ldw	r2,-4(fp)
 201b608:	1080010b 	ldhu	r2,4(r2)
 201b60c:	10bfffcc 	andi	r2,r2,65535
 201b610:	e0fffe17 	ldw	r3,-8(fp)
 201b614:	1885883a 	add	r2,r3,r2
 201b618:	e0bffe15 	stw	r2,-8(fp)
                                       + MEM_SANITY_REGION_AFTER_ALIGNED
#endif
                                      ));
#endif
  /* create a linked list of memp elements */
  for (i = 0; i < desc->num; ++i) {
 201b61c:	e0bffd17 	ldw	r2,-12(fp)
 201b620:	10800044 	addi	r2,r2,1
 201b624:	e0bffd15 	stw	r2,-12(fp)
 201b628:	e0bfff17 	ldw	r2,-4(fp)
 201b62c:	1080018b 	ldhu	r2,6(r2)
 201b630:	10bfffcc 	andi	r2,r2,65535
 201b634:	e0fffd17 	ldw	r3,-12(fp)
 201b638:	18bfe916 	blt	r3,r2,201b5e0 <__alt_mem_mem_0+0xfcffb5e0>
                                   + MEM_SANITY_REGION_AFTER_ALIGNED
#endif
                                  );
  }
#if MEMP_STATS
  desc->stats->avail = desc->num;
 201b63c:	e0bfff17 	ldw	r2,-4(fp)
 201b640:	10800017 	ldw	r2,0(r2)
 201b644:	e0ffff17 	ldw	r3,-4(fp)
 201b648:	18c0018b 	ldhu	r3,6(r3)
 201b64c:	10c0010d 	sth	r3,4(r2)
#endif /* !MEMP_MEM_MALLOC */

#if MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY)
  desc->stats->name  = desc->desc;
#endif /* MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY) */
}
 201b650:	0001883a 	nop
 201b654:	e037883a 	mov	sp,fp
 201b658:	df000017 	ldw	fp,0(sp)
 201b65c:	dec00104 	addi	sp,sp,4
 201b660:	f800283a 	ret

0201b664 <memp_init>:
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 201b664:	defffd04 	addi	sp,sp,-12
 201b668:	dfc00215 	stw	ra,8(sp)
 201b66c:	df000115 	stw	fp,4(sp)
 201b670:	df000104 	addi	fp,sp,4
  u16_t i;

  /* for every pool: */
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 201b674:	e03fff0d 	sth	zero,-4(fp)
 201b678:	00001c06 	br	201b6ec <memp_init+0x88>
    memp_init_pool(memp_pools[i]);
 201b67c:	e0ffff0b 	ldhu	r3,-4(fp)
 201b680:	00808134 	movhi	r2,516
 201b684:	109bb704 	addi	r2,r2,28380
 201b688:	18c7883a 	add	r3,r3,r3
 201b68c:	18c7883a 	add	r3,r3,r3
 201b690:	10c5883a 	add	r2,r2,r3
 201b694:	10800017 	ldw	r2,0(r2)
 201b698:	1009883a 	mov	r4,r2
 201b69c:	201b5a40 	call	201b5a4 <memp_init_pool>

#if LWIP_STATS && MEMP_STATS
    lwip_stats.memp[i] = memp_pools[i]->stats;
 201b6a0:	e17fff0b 	ldhu	r5,-4(fp)
 201b6a4:	e0ffff0b 	ldhu	r3,-4(fp)
 201b6a8:	00808134 	movhi	r2,516
 201b6ac:	109bb704 	addi	r2,r2,28380
 201b6b0:	18c7883a 	add	r3,r3,r3
 201b6b4:	18c7883a 	add	r3,r3,r3
 201b6b8:	10c5883a 	add	r2,r2,r3
 201b6bc:	10800017 	ldw	r2,0(r2)
 201b6c0:	11000017 	ldw	r4,0(r2)
 201b6c4:	008085f4 	movhi	r2,535
 201b6c8:	10bd8204 	addi	r2,r2,-2552
 201b6cc:	28c01604 	addi	r3,r5,88
 201b6d0:	18c7883a 	add	r3,r3,r3
 201b6d4:	18c7883a 	add	r3,r3,r3
 201b6d8:	10c5883a 	add	r2,r2,r3
 201b6dc:	11000015 	stw	r4,0(r2)
memp_init(void)
{
  u16_t i;

  /* for every pool: */
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 201b6e0:	e0bfff0b 	ldhu	r2,-4(fp)
 201b6e4:	10800044 	addi	r2,r2,1
 201b6e8:	e0bfff0d 	sth	r2,-4(fp)
 201b6ec:	e0bfff0b 	ldhu	r2,-4(fp)
 201b6f0:	108003f0 	cmpltui	r2,r2,15
 201b6f4:	103fe11e 	bne	r2,zero,201b67c <__alt_mem_mem_0+0xfcffb67c>

#if MEMP_OVERFLOW_CHECK >= 2
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
}
 201b6f8:	0001883a 	nop
 201b6fc:	e037883a 	mov	sp,fp
 201b700:	dfc00117 	ldw	ra,4(sp)
 201b704:	df000017 	ldw	fp,0(sp)
 201b708:	dec00204 	addi	sp,sp,8
 201b70c:	f800283a 	ret

0201b710 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 201b710:	defffb04 	addi	sp,sp,-20
 201b714:	dfc00415 	stw	ra,16(sp)
 201b718:	df000315 	stw	fp,12(sp)
 201b71c:	df000304 	addi	fp,sp,12
 201b720:	e13fff15 	stw	r4,-4(fp)

#if MEMP_MEM_MALLOC
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);
 201b724:	2014cec0 	call	2014cec <sys_arch_protect>
 201b728:	e0bffd15 	stw	r2,-12(fp)

  memp = *desc->tab;
 201b72c:	e0bfff17 	ldw	r2,-4(fp)
 201b730:	10800317 	ldw	r2,12(r2)
 201b734:	10800017 	ldw	r2,0(r2)
 201b738:	e0bffe15 	stw	r2,-8(fp)
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 201b73c:	e0bffe17 	ldw	r2,-8(fp)
 201b740:	10001d26 	beq	r2,zero,201b7b8 <do_memp_malloc_pool+0xa8>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 201b744:	e0bfff17 	ldw	r2,-4(fp)
 201b748:	10800317 	ldw	r2,12(r2)
 201b74c:	e0fffe17 	ldw	r3,-8(fp)
 201b750:	18c00017 	ldw	r3,0(r3)
 201b754:	10c00015 	stw	r3,0(r2)
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
#if MEMP_STATS
    desc->stats->used++;
 201b758:	e0bfff17 	ldw	r2,-4(fp)
 201b75c:	10800017 	ldw	r2,0(r2)
 201b760:	10c0018b 	ldhu	r3,6(r2)
 201b764:	18c00044 	addi	r3,r3,1
 201b768:	10c0018d 	sth	r3,6(r2)
    if (desc->stats->used > desc->stats->max) {
 201b76c:	e0bfff17 	ldw	r2,-4(fp)
 201b770:	10800017 	ldw	r2,0(r2)
 201b774:	1100018b 	ldhu	r4,6(r2)
 201b778:	e0bfff17 	ldw	r2,-4(fp)
 201b77c:	10800017 	ldw	r2,0(r2)
 201b780:	10c0020b 	ldhu	r3,8(r2)
 201b784:	20bfffcc 	andi	r2,r4,65535
 201b788:	18ffffcc 	andi	r3,r3,65535
 201b78c:	1880062e 	bgeu	r3,r2,201b7a8 <do_memp_malloc_pool+0x98>
      desc->stats->max = desc->stats->used;
 201b790:	e0bfff17 	ldw	r2,-4(fp)
 201b794:	10800017 	ldw	r2,0(r2)
 201b798:	e0ffff17 	ldw	r3,-4(fp)
 201b79c:	18c00017 	ldw	r3,0(r3)
 201b7a0:	18c0018b 	ldhu	r3,6(r3)
 201b7a4:	10c0020d 	sth	r3,8(r2)
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
 201b7a8:	e13ffd17 	ldw	r4,-12(fp)
 201b7ac:	2014d200 	call	2014d20 <sys_arch_unprotect>
    /* cast through u8_t* to get rid of alignment warnings */
    return ((u8_t *)memp + MEMP_SIZE);
 201b7b0:	e0bffe17 	ldw	r2,-8(fp)
 201b7b4:	00000806 	br	201b7d8 <do_memp_malloc_pool+0xc8>
  } else {
#if MEMP_STATS
    desc->stats->err++;
 201b7b8:	e0bfff17 	ldw	r2,-4(fp)
 201b7bc:	10800017 	ldw	r2,0(r2)
 201b7c0:	10c00017 	ldw	r3,0(r2)
 201b7c4:	18c00044 	addi	r3,r3,1
 201b7c8:	10c00015 	stw	r3,0(r2)
#endif
    SYS_ARCH_UNPROTECT(old_level);
 201b7cc:	e13ffd17 	ldw	r4,-12(fp)
 201b7d0:	2014d200 	call	2014d20 <sys_arch_unprotect>
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
 201b7d4:	0005883a 	mov	r2,zero
}
 201b7d8:	e037883a 	mov	sp,fp
 201b7dc:	dfc00117 	ldw	ra,4(sp)
 201b7e0:	df000017 	ldw	fp,0(sp)
 201b7e4:	dec00204 	addi	sp,sp,8
 201b7e8:	f800283a 	ret

0201b7ec <memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc_pool(const struct memp_desc *desc)
#else
memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 201b7ec:	defffd04 	addi	sp,sp,-12
 201b7f0:	dfc00215 	stw	ra,8(sp)
 201b7f4:	df000115 	stw	fp,4(sp)
 201b7f8:	df000104 	addi	fp,sp,4
 201b7fc:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("invalid pool desc", desc != NULL);
  if (desc == NULL) {
 201b800:	e0bfff17 	ldw	r2,-4(fp)
 201b804:	1000021e 	bne	r2,zero,201b810 <memp_malloc_pool+0x24>
    return NULL;
 201b808:	0005883a 	mov	r2,zero
 201b80c:	00000206 	br	201b818 <memp_malloc_pool+0x2c>
  }

#if !MEMP_OVERFLOW_CHECK
  return do_memp_malloc_pool(desc);
 201b810:	e13fff17 	ldw	r4,-4(fp)
 201b814:	201b7100 	call	201b710 <do_memp_malloc_pool>
#else
  return do_memp_malloc_pool_fn(desc, file, line);
#endif
}
 201b818:	e037883a 	mov	sp,fp
 201b81c:	dfc00117 	ldw	ra,4(sp)
 201b820:	df000017 	ldw	fp,0(sp)
 201b824:	dec00204 	addi	sp,sp,8
 201b828:	f800283a 	ret

0201b82c <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char *file, const int line)
#endif
{
 201b82c:	defffc04 	addi	sp,sp,-16
 201b830:	dfc00315 	stw	ra,12(sp)
 201b834:	df000215 	stw	fp,8(sp)
 201b838:	df000204 	addi	fp,sp,8
 201b83c:	e13fff15 	stw	r4,-4(fp)
  void *memp;
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 201b840:	e0bfff17 	ldw	r2,-4(fp)
 201b844:	108003f0 	cmpltui	r2,r2,15
 201b848:	1000021e 	bne	r2,zero,201b854 <memp_malloc+0x28>
 201b84c:	0005883a 	mov	r2,zero
 201b850:	00000b06 	br	201b880 <memp_malloc+0x54>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = do_memp_malloc_pool(memp_pools[type]);
 201b854:	00808134 	movhi	r2,516
 201b858:	109bb704 	addi	r2,r2,28380
 201b85c:	e0ffff17 	ldw	r3,-4(fp)
 201b860:	18c7883a 	add	r3,r3,r3
 201b864:	18c7883a 	add	r3,r3,r3
 201b868:	10c5883a 	add	r2,r2,r3
 201b86c:	10800017 	ldw	r2,0(r2)
 201b870:	1009883a 	mov	r4,r2
 201b874:	201b7100 	call	201b710 <do_memp_malloc_pool>
 201b878:	e0bffe15 	stw	r2,-8(fp)
#else
  memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
#endif

  return memp;
 201b87c:	e0bffe17 	ldw	r2,-8(fp)
}
 201b880:	e037883a 	mov	sp,fp
 201b884:	dfc00117 	ldw	ra,4(sp)
 201b888:	df000017 	ldw	fp,0(sp)
 201b88c:	dec00204 	addi	sp,sp,8
 201b890:	f800283a 	ret

0201b894 <do_memp_free_pool>:

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
 201b894:	defffa04 	addi	sp,sp,-24
 201b898:	dfc00515 	stw	ra,20(sp)
 201b89c:	df000415 	stw	fp,16(sp)
 201b8a0:	df000404 	addi	fp,sp,16
 201b8a4:	e13ffe15 	stw	r4,-8(fp)
 201b8a8:	e17fff15 	stw	r5,-4(fp)

  LWIP_ASSERT("memp_free: mem properly aligned",
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);
 201b8ac:	e0bfff17 	ldw	r2,-4(fp)
 201b8b0:	e0bffc15 	stw	r2,-16(fp)

  SYS_ARCH_PROTECT(old_level);
 201b8b4:	2014cec0 	call	2014cec <sys_arch_protect>
 201b8b8:	e0bffd15 	stw	r2,-12(fp)
#if MEMP_OVERFLOW_CHECK == 1
  memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

#if MEMP_STATS
  desc->stats->used--;
 201b8bc:	e0bffe17 	ldw	r2,-8(fp)
 201b8c0:	10800017 	ldw	r2,0(r2)
 201b8c4:	10c0018b 	ldhu	r3,6(r2)
 201b8c8:	18ffffc4 	addi	r3,r3,-1
 201b8cc:	10c0018d 	sth	r3,6(r2)
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 201b8d0:	e0bffe17 	ldw	r2,-8(fp)
 201b8d4:	10800317 	ldw	r2,12(r2)
 201b8d8:	10c00017 	ldw	r3,0(r2)
 201b8dc:	e0bffc17 	ldw	r2,-16(fp)
 201b8e0:	10c00015 	stw	r3,0(r2)
  *desc->tab = memp;
 201b8e4:	e0bffe17 	ldw	r2,-8(fp)
 201b8e8:	10800317 	ldw	r2,12(r2)
 201b8ec:	e0fffc17 	ldw	r3,-16(fp)
 201b8f0:	10c00015 	stw	r3,0(r2)

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
 201b8f4:	e13ffd17 	ldw	r4,-12(fp)
 201b8f8:	2014d200 	call	2014d20 <sys_arch_unprotect>
#endif /* !MEMP_MEM_MALLOC */
}
 201b8fc:	0001883a 	nop
 201b900:	e037883a 	mov	sp,fp
 201b904:	dfc00117 	ldw	ra,4(sp)
 201b908:	df000017 	ldw	fp,0(sp)
 201b90c:	dec00204 	addi	sp,sp,8
 201b910:	f800283a 	ret

0201b914 <memp_free_pool>:
 * @param desc the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
 201b914:	defffc04 	addi	sp,sp,-16
 201b918:	dfc00315 	stw	ra,12(sp)
 201b91c:	df000215 	stw	fp,8(sp)
 201b920:	df000204 	addi	fp,sp,8
 201b924:	e13ffe15 	stw	r4,-8(fp)
 201b928:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid pool desc", desc != NULL);
  if ((desc == NULL) || (mem == NULL)) {
 201b92c:	e0bffe17 	ldw	r2,-8(fp)
 201b930:	10000626 	beq	r2,zero,201b94c <memp_free_pool+0x38>
 201b934:	e0bfff17 	ldw	r2,-4(fp)
 201b938:	10000426 	beq	r2,zero,201b94c <memp_free_pool+0x38>
    return;
  }

  do_memp_free_pool(desc, mem);
 201b93c:	e17fff17 	ldw	r5,-4(fp)
 201b940:	e13ffe17 	ldw	r4,-8(fp)
 201b944:	201b8940 	call	201b894 <do_memp_free_pool>
 201b948:	00000106 	br	201b950 <memp_free_pool+0x3c>
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
  LWIP_ASSERT("invalid pool desc", desc != NULL);
  if ((desc == NULL) || (mem == NULL)) {
    return;
 201b94c:	0001883a 	nop
  }

  do_memp_free_pool(desc, mem);
}
 201b950:	e037883a 	mov	sp,fp
 201b954:	dfc00117 	ldw	ra,4(sp)
 201b958:	df000017 	ldw	fp,0(sp)
 201b95c:	dec00204 	addi	sp,sp,8
 201b960:	f800283a 	ret

0201b964 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 201b964:	defffc04 	addi	sp,sp,-16
 201b968:	dfc00315 	stw	ra,12(sp)
 201b96c:	df000215 	stw	fp,8(sp)
 201b970:	df000204 	addi	fp,sp,8
 201b974:	e13ffe15 	stw	r4,-8(fp)
 201b978:	e17fff15 	stw	r5,-4(fp)
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 201b97c:	e0bffe17 	ldw	r2,-8(fp)
 201b980:	108003f0 	cmpltui	r2,r2,15
 201b984:	10000d26 	beq	r2,zero,201b9bc <memp_free+0x58>

  if (mem == NULL) {
 201b988:	e0bfff17 	ldw	r2,-4(fp)
 201b98c:	10000d26 	beq	r2,zero,201b9c4 <memp_free+0x60>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 201b990:	00808134 	movhi	r2,516
 201b994:	109bb704 	addi	r2,r2,28380
 201b998:	e0fffe17 	ldw	r3,-8(fp)
 201b99c:	18c7883a 	add	r3,r3,r3
 201b9a0:	18c7883a 	add	r3,r3,r3
 201b9a4:	10c5883a 	add	r2,r2,r3
 201b9a8:	10800017 	ldw	r2,0(r2)
 201b9ac:	e17fff17 	ldw	r5,-4(fp)
 201b9b0:	1009883a 	mov	r4,r2
 201b9b4:	201b8940 	call	201b894 <do_memp_free_pool>
 201b9b8:	00000306 	br	201b9c8 <memp_free+0x64>
{
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 201b9bc:	0001883a 	nop
 201b9c0:	00000106 	br	201b9c8 <memp_free+0x64>

  if (mem == NULL) {
    return;
 201b9c4:	0001883a 	nop
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 201b9c8:	e037883a 	mov	sp,fp
 201b9cc:	dfc00117 	ldw	ra,4(sp)
 201b9d0:	df000017 	ldw	fp,0(sp)
 201b9d4:	dec00204 	addi	sp,sp,8
 201b9d8:	f800283a 	ret

0201b9dc <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 201b9dc:	deffff04 	addi	sp,sp,-4
 201b9e0:	df000015 	stw	fp,0(sp)
 201b9e4:	d839883a 	mov	fp,sp

  netif_set_link_up(&loop_netif);
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
 201b9e8:	0001883a 	nop
 201b9ec:	e037883a 	mov	sp,fp
 201b9f0:	df000017 	ldw	fp,0(sp)
 201b9f4:	dec00104 	addi	sp,sp,4
 201b9f8:	f800283a 	ret

0201b9fc <netif_input>:
 * Only works if the netif driver correctly sets
 * NETIF_FLAG_ETHARP and/or NETIF_FLAG_ETHERNET flag!
 */
err_t
netif_input(struct pbuf *p, struct netif *inp)
{
 201b9fc:	defffc04 	addi	sp,sp,-16
 201ba00:	dfc00315 	stw	ra,12(sp)
 201ba04:	df000215 	stw	fp,8(sp)
 201ba08:	df000204 	addi	fp,sp,8
 201ba0c:	e13ffe15 	stw	r4,-8(fp)
 201ba10:	e17fff15 	stw	r5,-4(fp)

  LWIP_ASSERT("netif_input: invalid pbuf", p != NULL);
  LWIP_ASSERT("netif_input: invalid netif", inp != NULL);

#if LWIP_ETHERNET
  if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 201ba14:	e0bfff17 	ldw	r2,-4(fp)
 201ba18:	10800f43 	ldbu	r2,61(r2)
 201ba1c:	10803fcc 	andi	r2,r2,255
 201ba20:	1080060c 	andi	r2,r2,24
 201ba24:	10000426 	beq	r2,zero,201ba38 <netif_input+0x3c>
    return ethernet_input(p, inp);
 201ba28:	e17fff17 	ldw	r5,-4(fp)
 201ba2c:	e13ffe17 	ldw	r4,-8(fp)
 201ba30:	202ad080 	call	202ad08 <ethernet_input>
 201ba34:	00000306 	br	201ba44 <netif_input+0x48>
  } else
#endif /* LWIP_ETHERNET */
    return ip_input(p, inp);
 201ba38:	e17fff17 	ldw	r5,-4(fp)
 201ba3c:	e13ffe17 	ldw	r4,-8(fp)
 201ba40:	203b7b40 	call	203b7b4 <ip4_input>
}
 201ba44:	e037883a 	mov	sp,fp
 201ba48:	dfc00117 	ldw	ra,4(sp)
 201ba4c:	df000017 	ldw	fp,0(sp)
 201ba50:	dec00204 	addi	sp,sp,8
 201ba54:	f800283a 	ret

0201ba58 <netif_add_noaddr>:
 *
 * Same as @ref netif_add but without IPv4 addresses
 */
struct netif *
netif_add_noaddr(struct netif *netif, void *state, netif_init_fn init, netif_input_fn input)
{
 201ba58:	defff704 	addi	sp,sp,-36
 201ba5c:	dfc00815 	stw	ra,32(sp)
 201ba60:	df000715 	stw	fp,28(sp)
 201ba64:	df000704 	addi	fp,sp,28
 201ba68:	e13ffc15 	stw	r4,-16(fp)
 201ba6c:	e17ffd15 	stw	r5,-12(fp)
 201ba70:	e1bffe15 	stw	r6,-8(fp)
 201ba74:	e1ffff15 	stw	r7,-4(fp)
  return netif_add(netif,
 201ba78:	e0bfff17 	ldw	r2,-4(fp)
 201ba7c:	d8800215 	stw	r2,8(sp)
 201ba80:	e0bffe17 	ldw	r2,-8(fp)
 201ba84:	d8800115 	stw	r2,4(sp)
 201ba88:	e0bffd17 	ldw	r2,-12(fp)
 201ba8c:	d8800015 	stw	r2,0(sp)
 201ba90:	000f883a 	mov	r7,zero
 201ba94:	000d883a 	mov	r6,zero
 201ba98:	000b883a 	mov	r5,zero
 201ba9c:	e13ffc17 	ldw	r4,-16(fp)
 201baa0:	201bab80 	call	201bab8 <netif_add>
#if LWIP_IPV4
                   NULL, NULL, NULL,
#endif /* LWIP_IPV4*/
                   state, init, input);
}
 201baa4:	e037883a 	mov	sp,fp
 201baa8:	dfc00117 	ldw	ra,4(sp)
 201baac:	df000017 	ldw	fp,0(sp)
 201bab0:	dec00204 	addi	sp,sp,8
 201bab4:	f800283a 	ret

0201bab8 <netif_add>:
netif_add(struct netif *netif,
#if LWIP_IPV4
          const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
          void *state, netif_init_fn init, netif_input_fn input)
{
 201bab8:	defff804 	addi	sp,sp,-32
 201babc:	dfc00715 	stw	ra,28(sp)
 201bac0:	df000615 	stw	fp,24(sp)
 201bac4:	df000604 	addi	fp,sp,24
 201bac8:	e13ffc15 	stw	r4,-16(fp)
 201bacc:	e17ffd15 	stw	r5,-12(fp)
 201bad0:	e1bffe15 	stw	r6,-8(fp)
 201bad4:	e1ffff15 	stw	r7,-4(fp)
    LWIP_ASSERT("single netif already set", 0);
    return NULL;
  }
#endif

  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
 201bad8:	e0bffc17 	ldw	r2,-16(fp)
 201badc:	1000021e 	bne	r2,zero,201bae8 <netif_add+0x30>
 201bae0:	0005883a 	mov	r2,zero
 201bae4:	00007706 	br	201bcc4 <netif_add+0x20c>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
 201bae8:	e0800317 	ldw	r2,12(fp)
 201baec:	1000021e 	bne	r2,zero,201baf8 <netif_add+0x40>
 201baf0:	0005883a 	mov	r2,zero
 201baf4:	00007306 	br	201bcc4 <netif_add+0x20c>

#if LWIP_IPV4
  if (ipaddr == NULL) {
 201baf8:	e0bffd17 	ldw	r2,-12(fp)
 201bafc:	1000021e 	bne	r2,zero,201bb08 <netif_add+0x50>
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
 201bb00:	d0a00e04 	addi	r2,gp,-32712
 201bb04:	e0bffd15 	stw	r2,-12(fp)
  }
  if (netmask == NULL) {
 201bb08:	e0bffe17 	ldw	r2,-8(fp)
 201bb0c:	1000021e 	bne	r2,zero,201bb18 <netif_add+0x60>
    netmask = ip_2_ip4(IP4_ADDR_ANY);
 201bb10:	d0a00e04 	addi	r2,gp,-32712
 201bb14:	e0bffe15 	stw	r2,-8(fp)
  }
  if (gw == NULL) {
 201bb18:	e0bfff17 	ldw	r2,-4(fp)
 201bb1c:	1000021e 	bne	r2,zero,201bb28 <netif_add+0x70>
    gw = ip_2_ip4(IP4_ADDR_ANY);
 201bb20:	d0a00e04 	addi	r2,gp,-32712
 201bb24:	e0bfff15 	stw	r2,-4(fp)
  }

  /* reset new interface configuration state */
  ip_addr_set_zero_ip4(&netif->ip_addr);
 201bb28:	e0bffc17 	ldw	r2,-16(fp)
 201bb2c:	10000115 	stw	zero,4(r2)
  ip_addr_set_zero_ip4(&netif->netmask);
 201bb30:	e0bffc17 	ldw	r2,-16(fp)
 201bb34:	10000215 	stw	zero,8(r2)
  ip_addr_set_zero_ip4(&netif->gw);
 201bb38:	e0bffc17 	ldw	r2,-16(fp)
 201bb3c:	10000315 	stw	zero,12(r2)
  netif->output = netif_null_output_ip4;
 201bb40:	e0fffc17 	ldw	r3,-16(fp)
 201bb44:	008080b4 	movhi	r2,514
 201bb48:	10b14604 	addi	r2,r2,-15080
 201bb4c:	18800515 	stw	r2,20(r3)
#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
  netif->mtu = 0;
 201bb50:	e0bffc17 	ldw	r2,-16(fp)
 201bb54:	10000d0d 	sth	zero,52(r2)
  netif->flags = 0;
 201bb58:	e0bffc17 	ldw	r2,-16(fp)
 201bb5c:	10000f45 	stb	zero,61(r2)
#ifdef netif_get_client_data
  memset(netif->client_data, 0, sizeof(netif->client_data));
 201bb60:	e0bffc17 	ldw	r2,-16(fp)
 201bb64:	10800a04 	addi	r2,r2,40
 201bb68:	01800204 	movi	r6,8
 201bb6c:	000b883a 	mov	r5,zero
 201bb70:	1009883a 	mov	r4,r2
 201bb74:	2005fa00 	call	2005fa0 <memset>
  netif->ip6_autoconfig_enabled = 1;
#endif /* LWIP_IPV6_AUTOCONFIG */
  nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
 201bb78:	e0bffc17 	ldw	r2,-16(fp)
 201bb7c:	10000715 	stw	zero,28(r2)
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 201bb80:	e0bffc17 	ldw	r2,-16(fp)
 201bb84:	10000815 	stw	zero,32(r2)
#if LWIP_IPV6 && LWIP_IPV6_MLD
  netif->mld_mac_filter = NULL;
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */

  /* remember netif specific state information data */
  netif->state = state;
 201bb88:	e0bffc17 	ldw	r2,-16(fp)
 201bb8c:	e0c00217 	ldw	r3,8(fp)
 201bb90:	10c00915 	stw	r3,36(r2)
  netif->num = netif_num;
 201bb94:	d0e7db03 	ldbu	r3,-24724(gp)
 201bb98:	e0bffc17 	ldw	r2,-16(fp)
 201bb9c:	10c01005 	stb	r3,64(r2)
  netif->input = input;
 201bba0:	e0bffc17 	ldw	r2,-16(fp)
 201bba4:	e0c00417 	ldw	r3,16(fp)
 201bba8:	10c00415 	stw	r3,16(r2)

#if LWIP_ACD
  netif->acd_list = NULL;
 201bbac:	e0bffc17 	ldw	r2,-16(fp)
 201bbb0:	10001115 	stw	zero,68(r2)
#endif /* LWIP_ACD */
  NETIF_RESET_HINTS(netif);
 201bbb4:	e0bffc17 	ldw	r2,-16(fp)
 201bbb8:	10001215 	stw	zero,72(r2)
  netif->reschedule_poll = 0;
#endif /* LWIP_NETIF_LOOPBACK_MULTITHREADING */
#endif /* ENABLE_LOOPBACK */

#if LWIP_IPV4
  netif_set_addr(netif, ipaddr, netmask, gw);
 201bbbc:	e1ffff17 	ldw	r7,-4(fp)
 201bbc0:	e1bffe17 	ldw	r6,-8(fp)
 201bbc4:	e17ffd17 	ldw	r5,-12(fp)
 201bbc8:	e13ffc17 	ldw	r4,-16(fp)
 201bbcc:	201bff80 	call	201bff8 <netif_set_addr>
#endif /* LWIP_IPV4 */

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 201bbd0:	e0800317 	ldw	r2,12(fp)
 201bbd4:	e13ffc17 	ldw	r4,-16(fp)
 201bbd8:	103ee83a 	callr	r2
 201bbdc:	10803fcc 	andi	r2,r2,255
 201bbe0:	1080201c 	xori	r2,r2,128
 201bbe4:	10bfe004 	addi	r2,r2,-128
 201bbe8:	10000226 	beq	r2,zero,201bbf4 <netif_add+0x13c>
    return NULL;
 201bbec:	0005883a 	mov	r2,zero
 201bbf0:	00003406 	br	201bcc4 <netif_add+0x20c>
     */
  {
    struct netif *netif2;
    int num_netifs;
    do {
      if (netif->num == 255) {
 201bbf4:	e0bffc17 	ldw	r2,-16(fp)
 201bbf8:	10801003 	ldbu	r2,64(r2)
 201bbfc:	10803fcc 	andi	r2,r2,255
 201bc00:	10803fd8 	cmpnei	r2,r2,255
 201bc04:	1000021e 	bne	r2,zero,201bc10 <netif_add+0x158>
        netif->num = 0;
 201bc08:	e0bffc17 	ldw	r2,-16(fp)
 201bc0c:	10001005 	stb	zero,64(r2)
      }
      num_netifs = 0;
 201bc10:	e03ffb15 	stw	zero,-20(fp)
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 201bc14:	d0a7dc17 	ldw	r2,-24720(gp)
 201bc18:	e0bffa15 	stw	r2,-24(fp)
 201bc1c:	00001406 	br	201bc70 <netif_add+0x1b8>
        LWIP_ASSERT("netif already added", netif2 != netif);
        num_netifs++;
 201bc20:	e0bffb17 	ldw	r2,-20(fp)
 201bc24:	10800044 	addi	r2,r2,1
 201bc28:	e0bffb15 	stw	r2,-20(fp)
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
        if (netif2->num == netif->num) {
 201bc2c:	e0bffa17 	ldw	r2,-24(fp)
 201bc30:	10c01003 	ldbu	r3,64(r2)
 201bc34:	e0bffc17 	ldw	r2,-16(fp)
 201bc38:	10801003 	ldbu	r2,64(r2)
 201bc3c:	18c03fcc 	andi	r3,r3,255
 201bc40:	10803fcc 	andi	r2,r2,255
 201bc44:	1880071e 	bne	r3,r2,201bc64 <netif_add+0x1ac>
          netif->num++;
 201bc48:	e0bffc17 	ldw	r2,-16(fp)
 201bc4c:	10801003 	ldbu	r2,64(r2)
 201bc50:	10800044 	addi	r2,r2,1
 201bc54:	1007883a 	mov	r3,r2
 201bc58:	e0bffc17 	ldw	r2,-16(fp)
 201bc5c:	10c01005 	stb	r3,64(r2)
          break;
 201bc60:	00000506 	br	201bc78 <netif_add+0x1c0>
    do {
      if (netif->num == 255) {
        netif->num = 0;
      }
      num_netifs = 0;
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 201bc64:	e0bffa17 	ldw	r2,-24(fp)
 201bc68:	10800017 	ldw	r2,0(r2)
 201bc6c:	e0bffa15 	stw	r2,-24(fp)
 201bc70:	e0bffa17 	ldw	r2,-24(fp)
 201bc74:	103fea1e 	bne	r2,zero,201bc20 <__alt_mem_mem_0+0xfcffbc20>
        if (netif2->num == netif->num) {
          netif->num++;
          break;
        }
      }
    } while (netif2 != NULL);
 201bc78:	e0bffa17 	ldw	r2,-24(fp)
 201bc7c:	103fdd1e 	bne	r2,zero,201bbf4 <__alt_mem_mem_0+0xfcffbbf4>
  }
  if (netif->num == 254) {
 201bc80:	e0bffc17 	ldw	r2,-16(fp)
 201bc84:	10801003 	ldbu	r2,64(r2)
 201bc88:	10803fcc 	andi	r2,r2,255
 201bc8c:	10803f98 	cmpnei	r2,r2,254
 201bc90:	1000021e 	bne	r2,zero,201bc9c <netif_add+0x1e4>
    netif_num = 0;
 201bc94:	d027db05 	stb	zero,-24724(gp)
 201bc98:	00000406 	br	201bcac <netif_add+0x1f4>
  } else {
    netif_num = (u8_t)(netif->num + 1);
 201bc9c:	e0bffc17 	ldw	r2,-16(fp)
 201bca0:	10801003 	ldbu	r2,64(r2)
 201bca4:	10800044 	addi	r2,r2,1
 201bca8:	d0a7db05 	stb	r2,-24724(gp)
  }

  /* add this netif to the list */
  netif->next = netif_list;
 201bcac:	d0e7dc17 	ldw	r3,-24720(gp)
 201bcb0:	e0bffc17 	ldw	r2,-16(fp)
 201bcb4:	10c00015 	stw	r3,0(r2)
  netif_list = netif;
 201bcb8:	e0bffc17 	ldw	r2,-16(fp)
 201bcbc:	d0a7dc15 	stw	r2,-24720(gp)
#endif /* LWIP_IPV4 */
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);

  return netif;
 201bcc0:	e0bffc17 	ldw	r2,-16(fp)
}
 201bcc4:	e037883a 	mov	sp,fp
 201bcc8:	dfc00117 	ldw	ra,4(sp)
 201bccc:	df000017 	ldw	fp,0(sp)
 201bcd0:	dec00204 	addi	sp,sp,8
 201bcd4:	f800283a 	ret

0201bcd8 <netif_do_ip_addr_changed>:

static void
netif_do_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 201bcd8:	defffc04 	addi	sp,sp,-16
 201bcdc:	dfc00315 	stw	ra,12(sp)
 201bce0:	df000215 	stw	fp,8(sp)
 201bce4:	df000204 	addi	fp,sp,8
 201bce8:	e13ffe15 	stw	r4,-8(fp)
 201bcec:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  tcp_netif_ip_addr_changed(old_addr, new_addr);
 201bcf0:	e17fff17 	ldw	r5,-4(fp)
 201bcf4:	e13ffe17 	ldw	r4,-8(fp)
 201bcf8:	2021ac40 	call	2021ac4 <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
  udp_netif_ip_addr_changed(old_addr, new_addr);
 201bcfc:	e17fff17 	ldw	r5,-4(fp)
 201bd00:	e13ffe17 	ldw	r4,-8(fp)
 201bd04:	202ac740 	call	202ac74 <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
  raw_netif_ip_addr_changed(old_addr, new_addr);
 201bd08:	e17fff17 	ldw	r5,-4(fp)
 201bd0c:	e13ffe17 	ldw	r4,-8(fp)
 201bd10:	201eccc0 	call	201eccc <raw_netif_ip_addr_changed>
#endif /* LWIP_RAW */
}
 201bd14:	0001883a 	nop
 201bd18:	e037883a 	mov	sp,fp
 201bd1c:	dfc00117 	ldw	ra,4(sp)
 201bd20:	df000017 	ldw	fp,0(sp)
 201bd24:	dec00204 	addi	sp,sp,8
 201bd28:	f800283a 	ret

0201bd2c <netif_do_set_ipaddr>:

#if LWIP_IPV4
static int
netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *old_addr)
{
 201bd2c:	defffa04 	addi	sp,sp,-24
 201bd30:	dfc00515 	stw	ra,20(sp)
 201bd34:	df000415 	stw	fp,16(sp)
 201bd38:	df000404 	addi	fp,sp,16
 201bd3c:	e13ffd15 	stw	r4,-12(fp)
 201bd40:	e17ffe15 	stw	r5,-8(fp)
 201bd44:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
  LWIP_ASSERT("invalid pointer", old_addr != NULL);

  /* address is actually being changed? */
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
 201bd48:	e0bffe17 	ldw	r2,-8(fp)
 201bd4c:	10c00017 	ldw	r3,0(r2)
 201bd50:	e0bffd17 	ldw	r2,-12(fp)
 201bd54:	10800104 	addi	r2,r2,4
 201bd58:	10800017 	ldw	r2,0(r2)
 201bd5c:	18802326 	beq	r3,r2,201bdec <netif_do_set_ipaddr+0xc0>
    ip_addr_t new_addr;
    *ip_2_ip4(&new_addr) = *ipaddr;
 201bd60:	e0bffe17 	ldw	r2,-8(fp)
 201bd64:	10800017 	ldw	r2,0(r2)
 201bd68:	e0bffc15 	stw	r2,-16(fp)
    IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);

    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
 201bd6c:	e0bffd17 	ldw	r2,-12(fp)
 201bd70:	10800104 	addi	r2,r2,4
 201bd74:	10c00017 	ldw	r3,0(r2)
 201bd78:	e0bfff17 	ldw	r2,-4(fp)
 201bd7c:	10c00015 	stw	r3,0(r2)

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    netif_do_ip_addr_changed(old_addr, &new_addr);
 201bd80:	e17ffc04 	addi	r5,fp,-16
 201bd84:	e13fff17 	ldw	r4,-4(fp)
 201bd88:	201bcd80 	call	201bcd8 <netif_do_ip_addr_changed>

#if LWIP_ACD
    acd_netif_ip_addr_changed(netif, old_addr, &new_addr);
 201bd8c:	e1bffc04 	addi	r6,fp,-16
 201bd90:	e17fff17 	ldw	r5,-4(fp)
 201bd94:	e13ffd17 	ldw	r4,-12(fp)
 201bd98:	203ac200 	call	203ac20 <acd_netif_ip_addr_changed>
#endif /* LWIP_ACD */

    mib2_remove_ip4(netif);
    mib2_remove_route_ip4(0, netif);
    /* set new IP address to netif */
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 201bd9c:	e0bffe17 	ldw	r2,-8(fp)
 201bda0:	10000326 	beq	r2,zero,201bdb0 <netif_do_set_ipaddr+0x84>
 201bda4:	e0bffe17 	ldw	r2,-8(fp)
 201bda8:	10800017 	ldw	r2,0(r2)
 201bdac:	00000106 	br	201bdb4 <netif_do_set_ipaddr+0x88>
 201bdb0:	0005883a 	mov	r2,zero
 201bdb4:	e0fffd17 	ldw	r3,-12(fp)
 201bdb8:	18800115 	stw	r2,4(r3)
    IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
    mib2_add_ip4(netif);
    mib2_add_route_ip4(0, netif);

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 201bdbc:	01400044 	movi	r5,1
 201bdc0:	e13ffd17 	ldw	r4,-12(fp)
 201bdc4:	201c2880 	call	201c288 <netif_issue_reports>

    NETIF_STATUS_CALLBACK(netif);
 201bdc8:	e0bffd17 	ldw	r2,-12(fp)
 201bdcc:	10800717 	ldw	r2,28(r2)
 201bdd0:	10000426 	beq	r2,zero,201bde4 <netif_do_set_ipaddr+0xb8>
 201bdd4:	e0bffd17 	ldw	r2,-12(fp)
 201bdd8:	10800717 	ldw	r2,28(r2)
 201bddc:	e13ffd17 	ldw	r4,-12(fp)
 201bde0:	103ee83a 	callr	r2
    return 1; /* address changed */
 201bde4:	00800044 	movi	r2,1
 201bde8:	00000106 	br	201bdf0 <netif_do_set_ipaddr+0xc4>
  }
  return 0; /* address unchanged */
 201bdec:	0005883a 	mov	r2,zero
}
 201bdf0:	e037883a 	mov	sp,fp
 201bdf4:	dfc00117 	ldw	ra,4(sp)
 201bdf8:	df000017 	ldw	fp,0(sp)
 201bdfc:	dec00204 	addi	sp,sp,8
 201be00:	f800283a 	ret

0201be04 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr)
{
 201be04:	defffb04 	addi	sp,sp,-20
 201be08:	dfc00415 	stw	ra,16(sp)
 201be0c:	df000315 	stw	fp,12(sp)
 201be10:	df000304 	addi	fp,sp,12
 201be14:	e13ffe15 	stw	r4,-8(fp)
 201be18:	e17fff15 	stw	r5,-4(fp)
  ip_addr_t old_addr;

  LWIP_ERROR("netif_set_ipaddr: invalid netif", netif != NULL, return);
 201be1c:	e0bffe17 	ldw	r2,-8(fp)
 201be20:	10000926 	beq	r2,zero,201be48 <netif_set_ipaddr+0x44>

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 201be24:	e0bfff17 	ldw	r2,-4(fp)
 201be28:	1000021e 	bne	r2,zero,201be34 <netif_set_ipaddr+0x30>
    ipaddr = IP4_ADDR_ANY4;
 201be2c:	d0a00e04 	addi	r2,gp,-32712
 201be30:	e0bfff15 	stw	r2,-4(fp)
  }

  LWIP_ASSERT_CORE_LOCKED();

  if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 201be34:	e1bffd04 	addi	r6,fp,-12
 201be38:	e17fff17 	ldw	r5,-4(fp)
 201be3c:	e13ffe17 	ldw	r4,-8(fp)
 201be40:	201bd2c0 	call	201bd2c <netif_do_set_ipaddr>
 201be44:	00000106 	br	201be4c <netif_set_ipaddr+0x48>
void
netif_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr)
{
  ip_addr_t old_addr;

  LWIP_ERROR("netif_set_ipaddr: invalid netif", netif != NULL, return);
 201be48:	0001883a 	nop
    netif_ext_callback_args_t args;
    args.ipv4_changed.old_address = &old_addr;
    netif_invoke_ext_callback(netif, LWIP_NSC_IPV4_ADDRESS_CHANGED, &args);
#endif
  }
}
 201be4c:	e037883a 	mov	sp,fp
 201be50:	dfc00117 	ldw	ra,4(sp)
 201be54:	df000017 	ldw	fp,0(sp)
 201be58:	dec00204 	addi	sp,sp,8
 201be5c:	f800283a 	ret

0201be60 <netif_do_set_netmask>:

static int
netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *old_nm)
{
 201be60:	defffc04 	addi	sp,sp,-16
 201be64:	df000315 	stw	fp,12(sp)
 201be68:	df000304 	addi	fp,sp,12
 201be6c:	e13ffd15 	stw	r4,-12(fp)
 201be70:	e17ffe15 	stw	r5,-8(fp)
 201be74:	e1bfff15 	stw	r6,-4(fp)
  /* address is actually being changed? */
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
 201be78:	e0bffe17 	ldw	r2,-8(fp)
 201be7c:	10c00017 	ldw	r3,0(r2)
 201be80:	e0bffd17 	ldw	r2,-12(fp)
 201be84:	10800204 	addi	r2,r2,8
 201be88:	10800017 	ldw	r2,0(r2)
 201be8c:	18800a26 	beq	r3,r2,201beb8 <netif_do_set_netmask+0x58>
#else
    LWIP_UNUSED_ARG(old_nm);
#endif
    mib2_remove_route_ip4(0, netif);
    /* set new netmask to netif */
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 201be90:	e0bffe17 	ldw	r2,-8(fp)
 201be94:	10000326 	beq	r2,zero,201bea4 <netif_do_set_netmask+0x44>
 201be98:	e0bffe17 	ldw	r2,-8(fp)
 201be9c:	10800017 	ldw	r2,0(r2)
 201bea0:	00000106 	br	201bea8 <netif_do_set_netmask+0x48>
 201bea4:	0005883a 	mov	r2,zero
 201bea8:	e0fffd17 	ldw	r3,-12(fp)
 201beac:	18800215 	stw	r2,8(r3)
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_netmask(netif)),
                ip4_addr2_16(netif_ip4_netmask(netif)),
                ip4_addr3_16(netif_ip4_netmask(netif)),
                ip4_addr4_16(netif_ip4_netmask(netif))));
    return 1; /* netmask changed */
 201beb0:	00800044 	movi	r2,1
 201beb4:	00000106 	br	201bebc <netif_do_set_netmask+0x5c>
  }
  return 0; /* netmask unchanged */
 201beb8:	0005883a 	mov	r2,zero
}
 201bebc:	e037883a 	mov	sp,fp
 201bec0:	df000017 	ldw	fp,0(sp)
 201bec4:	dec00104 	addi	sp,sp,4
 201bec8:	f800283a 	ret

0201becc <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, const ip4_addr_t *netmask)
{
 201becc:	defffb04 	addi	sp,sp,-20
 201bed0:	dfc00415 	stw	ra,16(sp)
 201bed4:	df000315 	stw	fp,12(sp)
 201bed8:	df000304 	addi	fp,sp,12
 201bedc:	e13ffe15 	stw	r4,-8(fp)
 201bee0:	e17fff15 	stw	r5,-4(fp)
#if LWIP_NETIF_EXT_STATUS_CALLBACK
  ip_addr_t old_nm_val;
  ip_addr_t *old_nm = &old_nm_val;
#else
  ip_addr_t *old_nm = NULL;
 201bee4:	e03ffd15 	stw	zero,-12(fp)
#endif
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_netmask: invalid netif", netif != NULL, return);
 201bee8:	e0bffe17 	ldw	r2,-8(fp)
 201beec:	10000926 	beq	r2,zero,201bf14 <netif_set_netmask+0x48>

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (netmask == NULL) {
 201bef0:	e0bfff17 	ldw	r2,-4(fp)
 201bef4:	1000021e 	bne	r2,zero,201bf00 <netif_set_netmask+0x34>
    netmask = IP4_ADDR_ANY4;
 201bef8:	d0a00e04 	addi	r2,gp,-32712
 201befc:	e0bfff15 	stw	r2,-4(fp)
  }

  if (netif_do_set_netmask(netif, netmask, old_nm)) {
 201bf00:	e1bffd17 	ldw	r6,-12(fp)
 201bf04:	e17fff17 	ldw	r5,-4(fp)
 201bf08:	e13ffe17 	ldw	r4,-8(fp)
 201bf0c:	201be600 	call	201be60 <netif_do_set_netmask>
 201bf10:	00000106 	br	201bf18 <netif_set_netmask+0x4c>
#else
  ip_addr_t *old_nm = NULL;
#endif
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_netmask: invalid netif", netif != NULL, return);
 201bf14:	0001883a 	nop
    netif_ext_callback_args_t args;
    args.ipv4_changed.old_netmask = old_nm;
    netif_invoke_ext_callback(netif, LWIP_NSC_IPV4_NETMASK_CHANGED, &args);
#endif
  }
}
 201bf18:	e037883a 	mov	sp,fp
 201bf1c:	dfc00117 	ldw	ra,4(sp)
 201bf20:	df000017 	ldw	fp,0(sp)
 201bf24:	dec00204 	addi	sp,sp,8
 201bf28:	f800283a 	ret

0201bf2c <netif_do_set_gw>:

static int
netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
{
 201bf2c:	defffc04 	addi	sp,sp,-16
 201bf30:	df000315 	stw	fp,12(sp)
 201bf34:	df000304 	addi	fp,sp,12
 201bf38:	e13ffd15 	stw	r4,-12(fp)
 201bf3c:	e17ffe15 	stw	r5,-8(fp)
 201bf40:	e1bfff15 	stw	r6,-4(fp)
  /* address is actually being changed? */
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
 201bf44:	e0bffe17 	ldw	r2,-8(fp)
 201bf48:	10c00017 	ldw	r3,0(r2)
 201bf4c:	e0bffd17 	ldw	r2,-12(fp)
 201bf50:	10800304 	addi	r2,r2,12
 201bf54:	10800017 	ldw	r2,0(r2)
 201bf58:	18800a26 	beq	r3,r2,201bf84 <netif_do_set_gw+0x58>
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
#else
    LWIP_UNUSED_ARG(old_gw);
#endif

    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 201bf5c:	e0bffe17 	ldw	r2,-8(fp)
 201bf60:	10000326 	beq	r2,zero,201bf70 <netif_do_set_gw+0x44>
 201bf64:	e0bffe17 	ldw	r2,-8(fp)
 201bf68:	10800017 	ldw	r2,0(r2)
 201bf6c:	00000106 	br	201bf74 <netif_do_set_gw+0x48>
 201bf70:	0005883a 	mov	r2,zero
 201bf74:	e0fffd17 	ldw	r3,-12(fp)
 201bf78:	18800315 	stw	r2,12(r3)
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_gw(netif)),
                ip4_addr2_16(netif_ip4_gw(netif)),
                ip4_addr3_16(netif_ip4_gw(netif)),
                ip4_addr4_16(netif_ip4_gw(netif))));
    return 1; /* gateway changed */
 201bf7c:	00800044 	movi	r2,1
 201bf80:	00000106 	br	201bf88 <netif_do_set_gw+0x5c>
  }
  return 0; /* gateway unchanged */
 201bf84:	0005883a 	mov	r2,zero
}
 201bf88:	e037883a 	mov	sp,fp
 201bf8c:	df000017 	ldw	fp,0(sp)
 201bf90:	dec00104 	addi	sp,sp,4
 201bf94:	f800283a 	ret

0201bf98 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, const ip4_addr_t *gw)
{
 201bf98:	defffb04 	addi	sp,sp,-20
 201bf9c:	dfc00415 	stw	ra,16(sp)
 201bfa0:	df000315 	stw	fp,12(sp)
 201bfa4:	df000304 	addi	fp,sp,12
 201bfa8:	e13ffe15 	stw	r4,-8(fp)
 201bfac:	e17fff15 	stw	r5,-4(fp)
#if LWIP_NETIF_EXT_STATUS_CALLBACK
  ip_addr_t old_gw_val;
  ip_addr_t *old_gw = &old_gw_val;
#else
  ip_addr_t *old_gw = NULL;
 201bfb0:	e03ffd15 	stw	zero,-12(fp)
#endif
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_gw: invalid netif", netif != NULL, return);
 201bfb4:	e0bffe17 	ldw	r2,-8(fp)
 201bfb8:	10000926 	beq	r2,zero,201bfe0 <netif_set_gw+0x48>

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (gw == NULL) {
 201bfbc:	e0bfff17 	ldw	r2,-4(fp)
 201bfc0:	1000021e 	bne	r2,zero,201bfcc <netif_set_gw+0x34>
    gw = IP4_ADDR_ANY4;
 201bfc4:	d0a00e04 	addi	r2,gp,-32712
 201bfc8:	e0bfff15 	stw	r2,-4(fp)
  }

  if (netif_do_set_gw(netif, gw, old_gw)) {
 201bfcc:	e1bffd17 	ldw	r6,-12(fp)
 201bfd0:	e17fff17 	ldw	r5,-4(fp)
 201bfd4:	e13ffe17 	ldw	r4,-8(fp)
 201bfd8:	201bf2c0 	call	201bf2c <netif_do_set_gw>
 201bfdc:	00000106 	br	201bfe4 <netif_set_gw+0x4c>
#else
  ip_addr_t *old_gw = NULL;
#endif
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_gw: invalid netif", netif != NULL, return);
 201bfe0:	0001883a 	nop
    netif_ext_callback_args_t args;
    args.ipv4_changed.old_gw = old_gw;
    netif_invoke_ext_callback(netif, LWIP_NSC_IPV4_GATEWAY_CHANGED, &args);
#endif
  }
}
 201bfe4:	e037883a 	mov	sp,fp
 201bfe8:	dfc00117 	ldw	ra,4(sp)
 201bfec:	df000017 	ldw	fp,0(sp)
 201bff0:	dec00204 	addi	sp,sp,8
 201bff4:	f800283a 	ret

0201bff8 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
               const ip4_addr_t *gw)
{
 201bff8:	defff604 	addi	sp,sp,-40
 201bffc:	dfc00915 	stw	ra,36(sp)
 201c000:	df000815 	stw	fp,32(sp)
 201c004:	df000804 	addi	fp,sp,32
 201c008:	e13ffc15 	stw	r4,-16(fp)
 201c00c:	e17ffd15 	stw	r5,-12(fp)
 201c010:	e1bffe15 	stw	r6,-8(fp)
 201c014:	e1ffff15 	stw	r7,-4(fp)
  ip_addr_t old_nm_val;
  ip_addr_t old_gw_val;
  ip_addr_t *old_nm = &old_nm_val;
  ip_addr_t *old_gw = &old_gw_val;
#else
  ip_addr_t *old_nm = NULL;
 201c018:	e03ff815 	stw	zero,-32(fp)
  ip_addr_t *old_gw = NULL;
 201c01c:	e03ff915 	stw	zero,-28(fp)
  int remove;

  LWIP_ASSERT_CORE_LOCKED();

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 201c020:	e0bffd17 	ldw	r2,-12(fp)
 201c024:	1000021e 	bne	r2,zero,201c030 <netif_set_addr+0x38>
    ipaddr = IP4_ADDR_ANY4;
 201c028:	d0a00e04 	addi	r2,gp,-32712
 201c02c:	e0bffd15 	stw	r2,-12(fp)
  }
  if (netmask == NULL) {
 201c030:	e0bffe17 	ldw	r2,-8(fp)
 201c034:	1000021e 	bne	r2,zero,201c040 <netif_set_addr+0x48>
    netmask = IP4_ADDR_ANY4;
 201c038:	d0a00e04 	addi	r2,gp,-32712
 201c03c:	e0bffe15 	stw	r2,-8(fp)
  }
  if (gw == NULL) {
 201c040:	e0bfff17 	ldw	r2,-4(fp)
 201c044:	1000021e 	bne	r2,zero,201c050 <netif_set_addr+0x58>
    gw = IP4_ADDR_ANY4;
 201c048:	d0a00e04 	addi	r2,gp,-32712
 201c04c:	e0bfff15 	stw	r2,-4(fp)
  }

  remove = ip4_addr_isany(ipaddr);
 201c050:	e0bffd17 	ldw	r2,-12(fp)
 201c054:	10000326 	beq	r2,zero,201c064 <netif_set_addr+0x6c>
 201c058:	e0bffd17 	ldw	r2,-12(fp)
 201c05c:	10800017 	ldw	r2,0(r2)
 201c060:	1000021e 	bne	r2,zero,201c06c <netif_set_addr+0x74>
 201c064:	00800044 	movi	r2,1
 201c068:	00000106 	br	201c070 <netif_set_addr+0x78>
 201c06c:	0005883a 	mov	r2,zero
 201c070:	e0bffa15 	stw	r2,-24(fp)
  if (remove) {
 201c074:	e0bffa17 	ldw	r2,-24(fp)
 201c078:	10000526 	beq	r2,zero,201c090 <netif_set_addr+0x98>
    /* when removing an address, we have to remove it *before* changing netmask/gw
       to ensure that tcp RST segment can be sent correctly */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 201c07c:	e0bffb04 	addi	r2,fp,-20
 201c080:	100d883a 	mov	r6,r2
 201c084:	e17ffd17 	ldw	r5,-12(fp)
 201c088:	e13ffc17 	ldw	r4,-16(fp)
 201c08c:	201bd2c0 	call	201bd2c <netif_do_set_ipaddr>
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
      cb_args.ipv4_changed.old_address = &old_addr;
#endif
    }
  }
  if (netif_do_set_netmask(netif, netmask, old_nm)) {
 201c090:	e1bff817 	ldw	r6,-32(fp)
 201c094:	e17ffe17 	ldw	r5,-8(fp)
 201c098:	e13ffc17 	ldw	r4,-16(fp)
 201c09c:	201be600 	call	201be60 <netif_do_set_netmask>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_NETMASK_CHANGED;
    cb_args.ipv4_changed.old_netmask = old_nm;
#endif
  }
  if (netif_do_set_gw(netif, gw, old_gw)) {
 201c0a0:	e1bff917 	ldw	r6,-28(fp)
 201c0a4:	e17fff17 	ldw	r5,-4(fp)
 201c0a8:	e13ffc17 	ldw	r4,-16(fp)
 201c0ac:	201bf2c0 	call	201bf2c <netif_do_set_gw>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_GATEWAY_CHANGED;
    cb_args.ipv4_changed.old_gw = old_gw;
#endif
  }
  if (!remove) {
 201c0b0:	e0bffa17 	ldw	r2,-24(fp)
 201c0b4:	1000051e 	bne	r2,zero,201c0cc <netif_set_addr+0xd4>
    /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 201c0b8:	e0bffb04 	addi	r2,fp,-20
 201c0bc:	100d883a 	mov	r6,r2
 201c0c0:	e17ffd17 	ldw	r5,-12(fp)
 201c0c4:	e13ffc17 	ldw	r4,-16(fp)
 201c0c8:	201bd2c0 	call	201bd2c <netif_do_set_ipaddr>
  }
  if (change_reason != LWIP_NSC_NONE) {
    netif_invoke_ext_callback(netif, change_reason, &cb_args);
  }
#endif
}
 201c0cc:	0001883a 	nop
 201c0d0:	e037883a 	mov	sp,fp
 201c0d4:	dfc00117 	ldw	ra,4(sp)
 201c0d8:	df000017 	ldw	fp,0(sp)
 201c0dc:	dec00204 	addi	sp,sp,8
 201c0e0:	f800283a 	ret

0201c0e4 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 201c0e4:	defffc04 	addi	sp,sp,-16
 201c0e8:	dfc00315 	stw	ra,12(sp)
 201c0ec:	df000215 	stw	fp,8(sp)
 201c0f0:	df000204 	addi	fp,sp,8
 201c0f4:	e13fff15 	stw	r4,-4(fp)
  int i;
#endif

  LWIP_ASSERT_CORE_LOCKED();

  if (netif == NULL) {
 201c0f8:	e0bfff17 	ldw	r2,-4(fp)
 201c0fc:	10002e26 	beq	r2,zero,201c1b8 <netif_remove+0xd4>
  }

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_REMOVED, NULL);

#if LWIP_IPV4
  if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 201c100:	e0bfff17 	ldw	r2,-4(fp)
 201c104:	10800104 	addi	r2,r2,4
 201c108:	10800017 	ldw	r2,0(r2)
 201c10c:	10000526 	beq	r2,zero,201c124 <netif_remove+0x40>
    netif_do_ip_addr_changed(netif_ip_addr4(netif), NULL);
 201c110:	e0bfff17 	ldw	r2,-4(fp)
 201c114:	10800104 	addi	r2,r2,4
 201c118:	000b883a 	mov	r5,zero
 201c11c:	1009883a 	mov	r4,r2
 201c120:	201bcd80 	call	201bcd8 <netif_do_ip_addr_changed>
#if LWIP_IPV6_MLD
  /* stop MLD processing */
  mld6_stop(netif);
#endif /* LWIP_IPV6_MLD */
#endif /* LWIP_IPV6 */
  if (netif_is_up(netif)) {
 201c124:	e0bfff17 	ldw	r2,-4(fp)
 201c128:	10800f43 	ldbu	r2,61(r2)
 201c12c:	10803fcc 	andi	r2,r2,255
 201c130:	1080004c 	andi	r2,r2,1
 201c134:	10000226 	beq	r2,zero,201c140 <netif_remove+0x5c>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 201c138:	e13fff17 	ldw	r4,-4(fp)
 201c13c:	201c2e00 	call	201c2e0 <netif_set_down>
  }

  mib2_remove_ip4(netif);

  /* this netif is default? */
  if (netif_default == netif) {
 201c140:	d0e7dd17 	ldw	r3,-24716(gp)
 201c144:	e0bfff17 	ldw	r2,-4(fp)
 201c148:	1880021e 	bne	r3,r2,201c154 <netif_remove+0x70>
    /* reset default netif */
    netif_set_default(NULL);
 201c14c:	0009883a 	mov	r4,zero
 201c150:	201c1d00 	call	201c1d0 <netif_set_default>
  }
#if !LWIP_SINGLE_NETIF
  /*  is it the first netif? */
  if (netif_list == netif) {
 201c154:	d0e7dc17 	ldw	r3,-24720(gp)
 201c158:	e0bfff17 	ldw	r2,-4(fp)
 201c15c:	1880041e 	bne	r3,r2,201c170 <netif_remove+0x8c>
    netif_list = netif->next;
 201c160:	e0bfff17 	ldw	r2,-4(fp)
 201c164:	10800017 	ldw	r2,0(r2)
 201c168:	d0a7dc15 	stw	r2,-24720(gp)
 201c16c:	00001306 	br	201c1bc <netif_remove+0xd8>
  } else {
    /*  look for netif further down the list */
    struct netif *tmp_netif;
    NETIF_FOREACH(tmp_netif) {
 201c170:	d0a7dc17 	ldw	r2,-24720(gp)
 201c174:	e0bffe15 	stw	r2,-8(fp)
 201c178:	00000c06 	br	201c1ac <netif_remove+0xc8>
      if (tmp_netif->next == netif) {
 201c17c:	e0bffe17 	ldw	r2,-8(fp)
 201c180:	10c00017 	ldw	r3,0(r2)
 201c184:	e0bfff17 	ldw	r2,-4(fp)
 201c188:	1880051e 	bne	r3,r2,201c1a0 <netif_remove+0xbc>
        tmp_netif->next = netif->next;
 201c18c:	e0bfff17 	ldw	r2,-4(fp)
 201c190:	10c00017 	ldw	r3,0(r2)
 201c194:	e0bffe17 	ldw	r2,-8(fp)
 201c198:	10c00015 	stw	r3,0(r2)
        break;
 201c19c:	00000706 	br	201c1bc <netif_remove+0xd8>
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif *tmp_netif;
    NETIF_FOREACH(tmp_netif) {
 201c1a0:	e0bffe17 	ldw	r2,-8(fp)
 201c1a4:	10800017 	ldw	r2,0(r2)
 201c1a8:	e0bffe15 	stw	r2,-8(fp)
 201c1ac:	e0bffe17 	ldw	r2,-8(fp)
 201c1b0:	103ff21e 	bne	r2,zero,201c17c <__alt_mem_mem_0+0xfcffc17c>
 201c1b4:	00000106 	br	201c1bc <netif_remove+0xd8>
#endif

  LWIP_ASSERT_CORE_LOCKED();

  if (netif == NULL) {
    return;
 201c1b8:	0001883a 	nop
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 201c1bc:	e037883a 	mov	sp,fp
 201c1c0:	dfc00117 	ldw	ra,4(sp)
 201c1c4:	df000017 	ldw	fp,0(sp)
 201c1c8:	dec00204 	addi	sp,sp,8
 201c1cc:	f800283a 	ret

0201c1d0 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 201c1d0:	defffe04 	addi	sp,sp,-8
 201c1d4:	df000115 	stw	fp,4(sp)
 201c1d8:	df000104 	addi	fp,sp,4
 201c1dc:	e13fff15 	stw	r4,-4(fp)
    mib2_remove_route_ip4(1, netif);
  } else {
    /* install default route */
    mib2_add_route_ip4(1, netif);
  }
  netif_default = netif;
 201c1e0:	e0bfff17 	ldw	r2,-4(fp)
 201c1e4:	d0a7dd15 	stw	r2,-24716(gp)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
                            netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 201c1e8:	0001883a 	nop
 201c1ec:	e037883a 	mov	sp,fp
 201c1f0:	df000017 	ldw	fp,0(sp)
 201c1f4:	dec00104 	addi	sp,sp,4
 201c1f8:	f800283a 	ret

0201c1fc <netif_set_up>:
 * Bring an interface up, available for processing
 * traffic.
 */
void
netif_set_up(struct netif *netif)
{
 201c1fc:	defffd04 	addi	sp,sp,-12
 201c200:	dfc00215 	stw	ra,8(sp)
 201c204:	df000115 	stw	fp,4(sp)
 201c208:	df000104 	addi	fp,sp,4
 201c20c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_up: invalid netif", netif != NULL, return);
 201c210:	e0bfff17 	ldw	r2,-4(fp)
 201c214:	10001626 	beq	r2,zero,201c270 <netif_set_up+0x74>

  if (!(netif->flags & NETIF_FLAG_UP)) {
 201c218:	e0bfff17 	ldw	r2,-4(fp)
 201c21c:	10800f43 	ldbu	r2,61(r2)
 201c220:	10803fcc 	andi	r2,r2,255
 201c224:	1080004c 	andi	r2,r2,1
 201c228:	1000121e 	bne	r2,zero,201c274 <netif_set_up+0x78>
    netif_set_flags(netif, NETIF_FLAG_UP);
 201c22c:	e0bfff17 	ldw	r2,-4(fp)
 201c230:	10800f43 	ldbu	r2,61(r2)
 201c234:	10800054 	ori	r2,r2,1
 201c238:	1007883a 	mov	r3,r2
 201c23c:	e0bfff17 	ldw	r2,-4(fp)
 201c240:	10c00f45 	stb	r3,61(r2)

    MIB2_COPY_SYSUPTIME_TO(&netif->ts);

    NETIF_STATUS_CALLBACK(netif);
 201c244:	e0bfff17 	ldw	r2,-4(fp)
 201c248:	10800717 	ldw	r2,28(r2)
 201c24c:	10000426 	beq	r2,zero,201c260 <netif_set_up+0x64>
 201c250:	e0bfff17 	ldw	r2,-4(fp)
 201c254:	10800717 	ldw	r2,28(r2)
 201c258:	e13fff17 	ldw	r4,-4(fp)
 201c25c:	103ee83a 	callr	r2
      args.status_changed.state = 1;
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
    }
#endif

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 201c260:	014000c4 	movi	r5,3
 201c264:	e13fff17 	ldw	r4,-4(fp)
 201c268:	201c2880 	call	201c288 <netif_issue_reports>
 201c26c:	00000106 	br	201c274 <netif_set_up+0x78>
void
netif_set_up(struct netif *netif)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_up: invalid netif", netif != NULL, return);
 201c270:	0001883a 	nop
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */
  }
}
 201c274:	e037883a 	mov	sp,fp
 201c278:	dfc00117 	ldw	ra,4(sp)
 201c27c:	df000017 	ldw	fp,0(sp)
 201c280:	dec00204 	addi	sp,sp,8
 201c284:	f800283a 	ret

0201c288 <netif_issue_reports>:

/** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
 */
static void
netif_issue_reports(struct netif *netif, u8_t report_type)
{
 201c288:	defffb04 	addi	sp,sp,-20
 201c28c:	df000415 	stw	fp,16(sp)
 201c290:	df000404 	addi	fp,sp,16
 201c294:	e13ffc15 	stw	r4,-16(fp)
 201c298:	2805883a 	mov	r2,r5
 201c29c:	e0bffd05 	stb	r2,-12(fp)
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);

  /* Only send reports when both link and admin states are up */
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 201c2a0:	e0bffc17 	ldw	r2,-16(fp)
 201c2a4:	10800f43 	ldbu	r2,61(r2)
 201c2a8:	10803fcc 	andi	r2,r2,255
 201c2ac:	1080010c 	andi	r2,r2,4
 201c2b0:	10000626 	beq	r2,zero,201c2cc <netif_issue_reports+0x44>
      !(netif->flags & NETIF_FLAG_UP)) {
 201c2b4:	e0bffc17 	ldw	r2,-16(fp)
 201c2b8:	10800f43 	ldbu	r2,61(r2)
 201c2bc:	10803fcc 	andi	r2,r2,255
 201c2c0:	1080004c 	andi	r2,r2,1
netif_issue_reports(struct netif *netif, u8_t report_type)
{
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);

  /* Only send reports when both link and admin states are up */
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 201c2c4:	10000126 	beq	r2,zero,201c2cc <netif_issue_reports+0x44>
 201c2c8:	00000106 	br	201c2d0 <netif_issue_reports+0x48>
      !(netif->flags & NETIF_FLAG_UP)) {
    return;
 201c2cc:	0001883a 	nop
    /* send mld memberships */
    mld6_report_groups(netif);
#endif /* LWIP_IPV6_MLD */
  }
#endif /* LWIP_IPV6 */
}
 201c2d0:	e037883a 	mov	sp,fp
 201c2d4:	df000017 	ldw	fp,0(sp)
 201c2d8:	dec00104 	addi	sp,sp,4
 201c2dc:	f800283a 	ret

0201c2e0 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 201c2e0:	defffd04 	addi	sp,sp,-12
 201c2e4:	dfc00215 	stw	ra,8(sp)
 201c2e8:	df000115 	stw	fp,4(sp)
 201c2ec:	df000104 	addi	fp,sp,4
 201c2f0:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 201c2f4:	e0bfff17 	ldw	r2,-4(fp)
 201c2f8:	10001b26 	beq	r2,zero,201c368 <netif_set_down+0x88>

  if (netif->flags & NETIF_FLAG_UP) {
 201c2fc:	e0bfff17 	ldw	r2,-4(fp)
 201c300:	10800f43 	ldbu	r2,61(r2)
 201c304:	10803fcc 	andi	r2,r2,255
 201c308:	1080004c 	andi	r2,r2,1
 201c30c:	10001726 	beq	r2,zero,201c36c <netif_set_down+0x8c>
      args.status_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
    }
#endif

    netif_clear_flags(netif, NETIF_FLAG_UP);
 201c310:	e0bfff17 	ldw	r2,-4(fp)
 201c314:	10c00f43 	ldbu	r3,61(r2)
 201c318:	00bfff84 	movi	r2,-2
 201c31c:	1884703a 	and	r2,r3,r2
 201c320:	1007883a 	mov	r3,r2
 201c324:	e0bfff17 	ldw	r2,-4(fp)
 201c328:	10c00f45 	stb	r3,61(r2)
    MIB2_COPY_SYSUPTIME_TO(&netif->ts);

#if LWIP_IPV4 && LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 201c32c:	e0bfff17 	ldw	r2,-4(fp)
 201c330:	10800f43 	ldbu	r2,61(r2)
 201c334:	10803fcc 	andi	r2,r2,255
 201c338:	1080020c 	andi	r2,r2,8
 201c33c:	10000226 	beq	r2,zero,201c348 <netif_set_down+0x68>
      etharp_cleanup_netif(netif);
 201c340:	e13fff17 	ldw	r4,-4(fp)
 201c344:	201909c0 	call	201909c <etharp_cleanup_netif>

#if LWIP_IPV6
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
 201c348:	e0bfff17 	ldw	r2,-4(fp)
 201c34c:	10800717 	ldw	r2,28(r2)
 201c350:	10000626 	beq	r2,zero,201c36c <netif_set_down+0x8c>
 201c354:	e0bfff17 	ldw	r2,-4(fp)
 201c358:	10800717 	ldw	r2,28(r2)
 201c35c:	e13fff17 	ldw	r4,-4(fp)
 201c360:	103ee83a 	callr	r2
 201c364:	00000106 	br	201c36c <netif_set_down+0x8c>
void
netif_set_down(struct netif *netif)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 201c368:	0001883a 	nop
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
  }
}
 201c36c:	e037883a 	mov	sp,fp
 201c370:	dfc00117 	ldw	ra,4(sp)
 201c374:	df000017 	ldw	fp,0(sp)
 201c378:	dec00204 	addi	sp,sp,8
 201c37c:	f800283a 	ret

0201c380 <netif_set_status_callback>:
 * @ingroup netif
 * Set callback to be called when interface is brought up/down or address is changed while up
 */
void
netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
 201c380:	defffd04 	addi	sp,sp,-12
 201c384:	df000215 	stw	fp,8(sp)
 201c388:	df000204 	addi	fp,sp,8
 201c38c:	e13ffe15 	stw	r4,-8(fp)
 201c390:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  if (netif) {
 201c394:	e0bffe17 	ldw	r2,-8(fp)
 201c398:	10000326 	beq	r2,zero,201c3a8 <netif_set_status_callback+0x28>
    netif->status_callback = status_callback;
 201c39c:	e0bffe17 	ldw	r2,-8(fp)
 201c3a0:	e0ffff17 	ldw	r3,-4(fp)
 201c3a4:	10c00715 	stw	r3,28(r2)
  }
}
 201c3a8:	0001883a 	nop
 201c3ac:	e037883a 	mov	sp,fp
 201c3b0:	df000017 	ldw	fp,0(sp)
 201c3b4:	dec00104 	addi	sp,sp,4
 201c3b8:	f800283a 	ret

0201c3bc <netif_set_link_up>:
 * @ingroup netif
 * Called by a driver when its link goes up
 */
void
netif_set_link_up(struct netif *netif)
{
 201c3bc:	defffd04 	addi	sp,sp,-12
 201c3c0:	dfc00215 	stw	ra,8(sp)
 201c3c4:	df000115 	stw	fp,4(sp)
 201c3c8:	df000104 	addi	fp,sp,4
 201c3cc:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 201c3d0:	e0bfff17 	ldw	r2,-4(fp)
 201c3d4:	10001826 	beq	r2,zero,201c438 <netif_set_link_up+0x7c>

  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 201c3d8:	e0bfff17 	ldw	r2,-4(fp)
 201c3dc:	10800f43 	ldbu	r2,61(r2)
 201c3e0:	10803fcc 	andi	r2,r2,255
 201c3e4:	1080010c 	andi	r2,r2,4
 201c3e8:	1000141e 	bne	r2,zero,201c43c <netif_set_link_up+0x80>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
 201c3ec:	e0bfff17 	ldw	r2,-4(fp)
 201c3f0:	10800f43 	ldbu	r2,61(r2)
 201c3f4:	10800114 	ori	r2,r2,4
 201c3f8:	1007883a 	mov	r3,r2
 201c3fc:	e0bfff17 	ldw	r2,-4(fp)
 201c400:	10c00f45 	stb	r3,61(r2)

#if LWIP_DHCP
    dhcp_network_changed_link_up(netif);
 201c404:	e13fff17 	ldw	r4,-4(fp)
 201c408:	20165780 	call	2016578 <dhcp_network_changed_link_up>

#if LWIP_AUTOIP
    autoip_network_changed_link_up(netif);
#endif /* LWIP_AUTOIP */

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 201c40c:	014000c4 	movi	r5,3
 201c410:	e13fff17 	ldw	r4,-4(fp)
 201c414:	201c2880 	call	201c288 <netif_issue_reports>
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_LINK_CALLBACK(netif);
 201c418:	e0bfff17 	ldw	r2,-4(fp)
 201c41c:	10800817 	ldw	r2,32(r2)
 201c420:	10000626 	beq	r2,zero,201c43c <netif_set_link_up+0x80>
 201c424:	e0bfff17 	ldw	r2,-4(fp)
 201c428:	10800817 	ldw	r2,32(r2)
 201c42c:	e13fff17 	ldw	r4,-4(fp)
 201c430:	103ee83a 	callr	r2
 201c434:	00000106 	br	201c43c <netif_set_link_up+0x80>
void
netif_set_link_up(struct netif *netif)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 201c438:	0001883a 	nop
      args.link_changed.state = 1;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 201c43c:	e037883a 	mov	sp,fp
 201c440:	dfc00117 	ldw	ra,4(sp)
 201c444:	df000017 	ldw	fp,0(sp)
 201c448:	dec00204 	addi	sp,sp,8
 201c44c:	f800283a 	ret

0201c450 <netif_set_link_down>:
 * @ingroup netif
 * Called by a driver when its link goes down
 */
void
netif_set_link_down(struct netif *netif)
{
 201c450:	defffd04 	addi	sp,sp,-12
 201c454:	dfc00215 	stw	ra,8(sp)
 201c458:	df000115 	stw	fp,4(sp)
 201c45c:	df000104 	addi	fp,sp,4
 201c460:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 201c464:	e0bfff17 	ldw	r2,-4(fp)
 201c468:	10001626 	beq	r2,zero,201c4c4 <netif_set_link_down+0x74>

  if (netif->flags & NETIF_FLAG_LINK_UP) {
 201c46c:	e0bfff17 	ldw	r2,-4(fp)
 201c470:	10800f43 	ldbu	r2,61(r2)
 201c474:	10803fcc 	andi	r2,r2,255
 201c478:	1080010c 	andi	r2,r2,4
 201c47c:	10001226 	beq	r2,zero,201c4c8 <netif_set_link_down+0x78>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
 201c480:	e0bfff17 	ldw	r2,-4(fp)
 201c484:	10c00f43 	ldbu	r3,61(r2)
 201c488:	00bffec4 	movi	r2,-5
 201c48c:	1884703a 	and	r2,r3,r2
 201c490:	1007883a 	mov	r3,r2
 201c494:	e0bfff17 	ldw	r2,-4(fp)
 201c498:	10c00f45 	stb	r3,61(r2)
#if LWIP_AUTOIP
    autoip_network_changed_link_down(netif);
#endif /* LWIP_AUTOIP */

#if LWIP_ACD
    acd_network_changed_link_down(netif);
 201c49c:	e13fff17 	ldw	r4,-4(fp)
 201c4a0:	203a5480 	call	203a548 <acd_network_changed_link_down>

#if LWIP_IPV6 && LWIP_ND6_ALLOW_RA_UPDATES
    netif->mtu6 = netif->mtu;
#endif

    NETIF_LINK_CALLBACK(netif);
 201c4a4:	e0bfff17 	ldw	r2,-4(fp)
 201c4a8:	10800817 	ldw	r2,32(r2)
 201c4ac:	10000626 	beq	r2,zero,201c4c8 <netif_set_link_down+0x78>
 201c4b0:	e0bfff17 	ldw	r2,-4(fp)
 201c4b4:	10800817 	ldw	r2,32(r2)
 201c4b8:	e13fff17 	ldw	r4,-4(fp)
 201c4bc:	103ee83a 	callr	r2
 201c4c0:	00000106 	br	201c4c8 <netif_set_link_down+0x78>
void
netif_set_link_down(struct netif *netif)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 201c4c4:	0001883a 	nop
      args.link_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 201c4c8:	e037883a 	mov	sp,fp
 201c4cc:	dfc00117 	ldw	ra,4(sp)
 201c4d0:	df000017 	ldw	fp,0(sp)
 201c4d4:	dec00204 	addi	sp,sp,8
 201c4d8:	f800283a 	ret

0201c4dc <netif_set_link_callback>:
 * @ingroup netif
 * Set callback to be called when link is brought up/down
 */
void
netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
 201c4dc:	defffd04 	addi	sp,sp,-12
 201c4e0:	df000215 	stw	fp,8(sp)
 201c4e4:	df000204 	addi	fp,sp,8
 201c4e8:	e13ffe15 	stw	r4,-8(fp)
 201c4ec:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  if (netif) {
 201c4f0:	e0bffe17 	ldw	r2,-8(fp)
 201c4f4:	10000326 	beq	r2,zero,201c504 <netif_set_link_callback+0x28>
    netif->link_callback = link_callback;
 201c4f8:	e0bffe17 	ldw	r2,-8(fp)
 201c4fc:	e0ffff17 	ldw	r3,-4(fp)
 201c500:	10c00815 	stw	r3,32(r2)
  }
}
 201c504:	0001883a 	nop
 201c508:	e037883a 	mov	sp,fp
 201c50c:	df000017 	ldw	fp,0(sp)
 201c510:	dec00104 	addi	sp,sp,4
 201c514:	f800283a 	ret

0201c518 <netif_null_output_ip4>:
#if LWIP_IPV4
/** Dummy IPv4 output function for netifs not supporting IPv4
 */
static err_t
netif_null_output_ip4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipaddr)
{
 201c518:	defffc04 	addi	sp,sp,-16
 201c51c:	df000315 	stw	fp,12(sp)
 201c520:	df000304 	addi	fp,sp,12
 201c524:	e13ffd15 	stw	r4,-12(fp)
 201c528:	e17ffe15 	stw	r5,-8(fp)
 201c52c:	e1bfff15 	stw	r6,-4(fp)
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
 201c530:	00bffd04 	movi	r2,-12
}
 201c534:	e037883a 	mov	sp,fp
 201c538:	df000017 	ldw	fp,0(sp)
 201c53c:	dec00104 	addi	sp,sp,4
 201c540:	f800283a 	ret

0201c544 <netif_name_to_index>:
*
* @param name the name of the netif
*/
u8_t
netif_name_to_index(const char *name)
{
 201c544:	defffc04 	addi	sp,sp,-16
 201c548:	dfc00315 	stw	ra,12(sp)
 201c54c:	df000215 	stw	fp,8(sp)
 201c550:	df000204 	addi	fp,sp,8
 201c554:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif = netif_find(name);
 201c558:	e13fff17 	ldw	r4,-4(fp)
 201c55c:	201c69c0 	call	201c69c <netif_find>
 201c560:	e0bffe15 	stw	r2,-8(fp)
  if (netif != NULL) {
 201c564:	e0bffe17 	ldw	r2,-8(fp)
 201c568:	10000426 	beq	r2,zero,201c57c <netif_name_to_index+0x38>
    return netif_get_index(netif);
 201c56c:	e0bffe17 	ldw	r2,-8(fp)
 201c570:	10801003 	ldbu	r2,64(r2)
 201c574:	10800044 	addi	r2,r2,1
 201c578:	00000106 	br	201c580 <netif_name_to_index+0x3c>
  }
  /* No name found, return invalid index */
  return NETIF_NO_INDEX;
 201c57c:	0005883a 	mov	r2,zero
}
 201c580:	e037883a 	mov	sp,fp
 201c584:	dfc00117 	ldw	ra,4(sp)
 201c588:	df000017 	ldw	fp,0(sp)
 201c58c:	dec00204 	addi	sp,sp,8
 201c590:	f800283a 	ret

0201c594 <netif_index_to_name>:
* @param idx the interface index of the netif
* @param name char buffer of at least NETIF_NAMESIZE bytes
*/
char *
netif_index_to_name(u8_t idx, char *name)
{
 201c594:	defffb04 	addi	sp,sp,-20
 201c598:	dfc00415 	stw	ra,16(sp)
 201c59c:	df000315 	stw	fp,12(sp)
 201c5a0:	df000304 	addi	fp,sp,12
 201c5a4:	2005883a 	mov	r2,r4
 201c5a8:	e17fff15 	stw	r5,-4(fp)
 201c5ac:	e0bffe05 	stb	r2,-8(fp)
  struct netif *netif = netif_get_by_index(idx);
 201c5b0:	e0bffe03 	ldbu	r2,-8(fp)
 201c5b4:	1009883a 	mov	r4,r2
 201c5b8:	201c62c0 	call	201c62c <netif_get_by_index>
 201c5bc:	e0bffd15 	stw	r2,-12(fp)

  if (netif != NULL) {
 201c5c0:	e0bffd17 	ldw	r2,-12(fp)
 201c5c4:	10001326 	beq	r2,zero,201c614 <netif_index_to_name+0x80>
    name[0] = netif->name[0];
 201c5c8:	e0bffd17 	ldw	r2,-12(fp)
 201c5cc:	10c00f83 	ldbu	r3,62(r2)
 201c5d0:	e0bfff17 	ldw	r2,-4(fp)
 201c5d4:	10c00005 	stb	r3,0(r2)
    name[1] = netif->name[1];
 201c5d8:	e0bfff17 	ldw	r2,-4(fp)
 201c5dc:	10800044 	addi	r2,r2,1
 201c5e0:	e0fffd17 	ldw	r3,-12(fp)
 201c5e4:	18c00fc3 	ldbu	r3,63(r3)
 201c5e8:	10c00005 	stb	r3,0(r2)
    lwip_itoa(&name[2], NETIF_NAMESIZE - 2, netif_index_to_num(idx));
 201c5ec:	e0bfff17 	ldw	r2,-4(fp)
 201c5f0:	10c00084 	addi	r3,r2,2
 201c5f4:	e0bffe03 	ldbu	r2,-8(fp)
 201c5f8:	10bfffc4 	addi	r2,r2,-1
 201c5fc:	100d883a 	mov	r6,r2
 201c600:	01400104 	movi	r5,4
 201c604:	1809883a 	mov	r4,r3
 201c608:	20398200 	call	2039820 <lwip_itoa>
    return name;
 201c60c:	e0bfff17 	ldw	r2,-4(fp)
 201c610:	00000106 	br	201c618 <netif_index_to_name+0x84>
  }
  return NULL;
 201c614:	0005883a 	mov	r2,zero
}
 201c618:	e037883a 	mov	sp,fp
 201c61c:	dfc00117 	ldw	ra,4(sp)
 201c620:	df000017 	ldw	fp,0(sp)
 201c624:	dec00204 	addi	sp,sp,8
 201c628:	f800283a 	ret

0201c62c <netif_get_by_index>:
*
* @param idx index of netif to find
*/
struct netif *
netif_get_by_index(u8_t idx)
{
 201c62c:	defffd04 	addi	sp,sp,-12
 201c630:	df000215 	stw	fp,8(sp)
 201c634:	df000204 	addi	fp,sp,8
 201c638:	2005883a 	mov	r2,r4
 201c63c:	e0bfff05 	stb	r2,-4(fp)
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
 201c640:	e0bfff03 	ldbu	r2,-4(fp)
 201c644:	10001026 	beq	r2,zero,201c688 <netif_get_by_index+0x5c>
    NETIF_FOREACH(netif) {
 201c648:	d0a7dc17 	ldw	r2,-24720(gp)
 201c64c:	e0bffe15 	stw	r2,-8(fp)
 201c650:	00000b06 	br	201c680 <netif_get_by_index+0x54>
      if (idx == netif_get_index(netif)) {
 201c654:	e0bffe17 	ldw	r2,-8(fp)
 201c658:	10801003 	ldbu	r2,64(r2)
 201c65c:	10800044 	addi	r2,r2,1
 201c660:	10c03fcc 	andi	r3,r2,255
 201c664:	e0bfff03 	ldbu	r2,-4(fp)
 201c668:	1880021e 	bne	r3,r2,201c674 <netif_get_by_index+0x48>
        return netif; /* found! */
 201c66c:	e0bffe17 	ldw	r2,-8(fp)
 201c670:	00000606 	br	201c68c <netif_get_by_index+0x60>
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
    NETIF_FOREACH(netif) {
 201c674:	e0bffe17 	ldw	r2,-8(fp)
 201c678:	10800017 	ldw	r2,0(r2)
 201c67c:	e0bffe15 	stw	r2,-8(fp)
 201c680:	e0bffe17 	ldw	r2,-8(fp)
 201c684:	103ff31e 	bne	r2,zero,201c654 <__alt_mem_mem_0+0xfcffc654>
        return netif; /* found! */
      }
    }
  }

  return NULL;
 201c688:	0005883a 	mov	r2,zero
}
 201c68c:	e037883a 	mov	sp,fp
 201c690:	df000017 	ldw	fp,0(sp)
 201c694:	dec00104 	addi	sp,sp,4
 201c698:	f800283a 	ret

0201c69c <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(const char *name)
{
 201c69c:	defffb04 	addi	sp,sp,-20
 201c6a0:	dfc00415 	stw	ra,16(sp)
 201c6a4:	df000315 	stw	fp,12(sp)
 201c6a8:	df000304 	addi	fp,sp,12
 201c6ac:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;
  u8_t num;

  LWIP_ASSERT_CORE_LOCKED();

  if (name == NULL) {
 201c6b0:	e0bfff17 	ldw	r2,-4(fp)
 201c6b4:	1000021e 	bne	r2,zero,201c6c0 <netif_find+0x24>
    return NULL;
 201c6b8:	0005883a 	mov	r2,zero
 201c6bc:	00003806 	br	201c7a0 <netif_find+0x104>
  }

  num = (u8_t)atoi(&name[2]);
 201c6c0:	e0bfff17 	ldw	r2,-4(fp)
 201c6c4:	10800084 	addi	r2,r2,2
 201c6c8:	1009883a 	mov	r4,r2
 201c6cc:	20423a00 	call	20423a0 <atoi>
 201c6d0:	e0bffe05 	stb	r2,-8(fp)
  if (!num && (name[2] != '0')) {
 201c6d4:	e0bffe03 	ldbu	r2,-8(fp)
 201c6d8:	10000a1e 	bne	r2,zero,201c704 <netif_find+0x68>
 201c6dc:	e0bfff17 	ldw	r2,-4(fp)
 201c6e0:	10800084 	addi	r2,r2,2
 201c6e4:	10800003 	ldbu	r2,0(r2)
 201c6e8:	10803fcc 	andi	r2,r2,255
 201c6ec:	1080201c 	xori	r2,r2,128
 201c6f0:	10bfe004 	addi	r2,r2,-128
 201c6f4:	10800c20 	cmpeqi	r2,r2,48
 201c6f8:	1000021e 	bne	r2,zero,201c704 <netif_find+0x68>
    /* this means atoi has failed */
    return NULL;
 201c6fc:	0005883a 	mov	r2,zero
 201c700:	00002706 	br	201c7a0 <netif_find+0x104>
  }

  NETIF_FOREACH(netif) {
 201c704:	d0a7dc17 	ldw	r2,-24720(gp)
 201c708:	e0bffd15 	stw	r2,-12(fp)
 201c70c:	00002106 	br	201c794 <netif_find+0xf8>
    if (num == netif->num &&
 201c710:	e0bffd17 	ldw	r2,-12(fp)
 201c714:	10801003 	ldbu	r2,64(r2)
 201c718:	10c03fcc 	andi	r3,r2,255
 201c71c:	e0bffe03 	ldbu	r2,-8(fp)
 201c720:	1880191e 	bne	r3,r2,201c788 <netif_find+0xec>
        name[0] == netif->name[0] &&
 201c724:	e0bfff17 	ldw	r2,-4(fp)
 201c728:	10c00003 	ldbu	r3,0(r2)
 201c72c:	e0bffd17 	ldw	r2,-12(fp)
 201c730:	10800f83 	ldbu	r2,62(r2)
    /* this means atoi has failed */
    return NULL;
  }

  NETIF_FOREACH(netif) {
    if (num == netif->num &&
 201c734:	18c03fcc 	andi	r3,r3,255
 201c738:	18c0201c 	xori	r3,r3,128
 201c73c:	18ffe004 	addi	r3,r3,-128
 201c740:	10803fcc 	andi	r2,r2,255
 201c744:	1080201c 	xori	r2,r2,128
 201c748:	10bfe004 	addi	r2,r2,-128
 201c74c:	18800e1e 	bne	r3,r2,201c788 <netif_find+0xec>
        name[0] == netif->name[0] &&
        name[1] == netif->name[1]) {
 201c750:	e0bfff17 	ldw	r2,-4(fp)
 201c754:	10800044 	addi	r2,r2,1
 201c758:	10c00003 	ldbu	r3,0(r2)
 201c75c:	e0bffd17 	ldw	r2,-12(fp)
 201c760:	10800fc3 	ldbu	r2,63(r2)
    return NULL;
  }

  NETIF_FOREACH(netif) {
    if (num == netif->num &&
        name[0] == netif->name[0] &&
 201c764:	18c03fcc 	andi	r3,r3,255
 201c768:	18c0201c 	xori	r3,r3,128
 201c76c:	18ffe004 	addi	r3,r3,-128
 201c770:	10803fcc 	andi	r2,r2,255
 201c774:	1080201c 	xori	r2,r2,128
 201c778:	10bfe004 	addi	r2,r2,-128
 201c77c:	1880021e 	bne	r3,r2,201c788 <netif_find+0xec>
        name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
 201c780:	e0bffd17 	ldw	r2,-12(fp)
 201c784:	00000606 	br	201c7a0 <netif_find+0x104>
  if (!num && (name[2] != '0')) {
    /* this means atoi has failed */
    return NULL;
  }

  NETIF_FOREACH(netif) {
 201c788:	e0bffd17 	ldw	r2,-12(fp)
 201c78c:	10800017 	ldw	r2,0(r2)
 201c790:	e0bffd15 	stw	r2,-12(fp)
 201c794:	e0bffd17 	ldw	r2,-12(fp)
 201c798:	103fdd1e 	bne	r2,zero,201c710 <__alt_mem_mem_0+0xfcffc710>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
 201c79c:	0005883a 	mov	r2,zero
}
 201c7a0:	e037883a 	mov	sp,fp
 201c7a4:	dfc00117 	ldw	ra,4(sp)
 201c7a8:	df000017 	ldw	fp,0(sp)
 201c7ac:	dec00204 	addi	sp,sp,8
 201c7b0:	f800283a 	ret

0201c7b4 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
 201c7b4:	defffc04 	addi	sp,sp,-16
 201c7b8:	dfc00315 	stw	ra,12(sp)
 201c7bc:	df000215 	stw	fp,8(sp)
 201c7c0:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb;
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 201c7c4:	2014cec0 	call	2014cec <sys_arch_protect>
 201c7c8:	e0bfff15 	stw	r2,-4(fp)
 201c7cc:	d027de05 	stb	zero,-24712(gp)
 201c7d0:	e13fff17 	ldw	r4,-4(fp)
 201c7d4:	2014d200 	call	2014d20 <sys_arch_unprotect>

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 201c7d8:	d0a7e117 	ldw	r2,-24700(gp)
 201c7dc:	e0bffe15 	stw	r2,-8(fp)
 201c7e0:	00000906 	br	201c808 <pbuf_free_ooseq+0x54>
    if (pcb->ooseq != NULL) {
 201c7e4:	e0bffe17 	ldw	r2,-8(fp)
 201c7e8:	10801f17 	ldw	r2,124(r2)
 201c7ec:	10000326 	beq	r2,zero,201c7fc <pbuf_free_ooseq+0x48>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_free_ooseq(pcb);
 201c7f0:	e13ffe17 	ldw	r4,-8(fp)
 201c7f4:	2021c680 	call	2021c68 <tcp_free_ooseq>
      return;
 201c7f8:	00000506 	br	201c810 <pbuf_free_ooseq+0x5c>
pbuf_free_ooseq(void)
{
  struct tcp_pcb *pcb;
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 201c7fc:	e0bffe17 	ldw	r2,-8(fp)
 201c800:	10800417 	ldw	r2,16(r2)
 201c804:	e0bffe15 	stw	r2,-8(fp)
 201c808:	e0bffe17 	ldw	r2,-8(fp)
 201c80c:	103ff51e 	bne	r2,zero,201c7e4 <__alt_mem_mem_0+0xfcffc7e4>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_free_ooseq(pcb);
      return;
    }
  }
}
 201c810:	e037883a 	mov	sp,fp
 201c814:	dfc00117 	ldw	ra,4(sp)
 201c818:	df000017 	ldw	fp,0(sp)
 201c81c:	dec00204 	addi	sp,sp,8
 201c820:	f800283a 	ret

0201c824 <pbuf_free_ooseq_callback>:
/**
 * Just a callback function for tcpip_callback() that calls pbuf_free_ooseq().
 */
static void
pbuf_free_ooseq_callback(void *arg)
{
 201c824:	defffd04 	addi	sp,sp,-12
 201c828:	dfc00215 	stw	ra,8(sp)
 201c82c:	df000115 	stw	fp,4(sp)
 201c830:	df000104 	addi	fp,sp,4
 201c834:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  pbuf_free_ooseq();
 201c838:	201c7b40 	call	201c7b4 <pbuf_free_ooseq>
}
 201c83c:	0001883a 	nop
 201c840:	e037883a 	mov	sp,fp
 201c844:	dfc00117 	ldw	ra,4(sp)
 201c848:	df000017 	ldw	fp,0(sp)
 201c84c:	dec00204 	addi	sp,sp,8
 201c850:	f800283a 	ret

0201c854 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
 201c854:	defffc04 	addi	sp,sp,-16
 201c858:	dfc00315 	stw	ra,12(sp)
 201c85c:	df000215 	stw	fp,8(sp)
 201c860:	df000204 	addi	fp,sp,8
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
#else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
  u8_t queued;
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
 201c864:	2014cec0 	call	2014cec <sys_arch_protect>
 201c868:	e0bffe15 	stw	r2,-8(fp)
  queued = pbuf_free_ooseq_pending;
 201c86c:	d0a7de03 	ldbu	r2,-24712(gp)
 201c870:	e0bfff05 	stb	r2,-4(fp)
  pbuf_free_ooseq_pending = 1;
 201c874:	00800044 	movi	r2,1
 201c878:	d0a7de05 	stb	r2,-24712(gp)
  SYS_ARCH_UNPROTECT(old_level);
 201c87c:	e13ffe17 	ldw	r4,-8(fp)
 201c880:	2014d200 	call	2014d20 <sys_arch_unprotect>

  if (!queued) {
 201c884:	e0bfff03 	ldbu	r2,-4(fp)
 201c888:	10000d1e 	bne	r2,zero,201c8c0 <pbuf_pool_is_empty+0x6c>
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
 201c88c:	000b883a 	mov	r5,zero
 201c890:	010080b4 	movhi	r4,514
 201c894:	21320904 	addi	r4,r4,-14300
 201c898:	2033f100 	call	2033f10 <tcpip_try_callback>
 201c89c:	10803fcc 	andi	r2,r2,255
 201c8a0:	1080201c 	xori	r2,r2,128
 201c8a4:	10bfe004 	addi	r2,r2,-128
 201c8a8:	10000526 	beq	r2,zero,201c8c0 <pbuf_pool_is_empty+0x6c>
 201c8ac:	2014cec0 	call	2014cec <sys_arch_protect>
 201c8b0:	e0bffe15 	stw	r2,-8(fp)
 201c8b4:	d027de05 	stb	zero,-24712(gp)
 201c8b8:	e13ffe17 	ldw	r4,-8(fp)
 201c8bc:	2014d200 	call	2014d20 <sys_arch_unprotect>
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 201c8c0:	0001883a 	nop
 201c8c4:	e037883a 	mov	sp,fp
 201c8c8:	dfc00117 	ldw	ra,4(sp)
 201c8cc:	df000017 	ldw	fp,0(sp)
 201c8d0:	dec00204 	addi	sp,sp,8
 201c8d4:	f800283a 	ret

0201c8d8 <pbuf_init_alloced_pbuf>:
#endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */

/* Initialize members of struct pbuf after allocation */
static void
pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
{
 201c8d8:	defffa04 	addi	sp,sp,-24
 201c8dc:	df000515 	stw	fp,20(sp)
 201c8e0:	df000504 	addi	fp,sp,20
 201c8e4:	e13ffb15 	stw	r4,-20(fp)
 201c8e8:	e17ffc15 	stw	r5,-16(fp)
 201c8ec:	3009883a 	mov	r4,r6
 201c8f0:	3807883a 	mov	r3,r7
 201c8f4:	e0800217 	ldw	r2,8(fp)
 201c8f8:	e13ffd0d 	sth	r4,-12(fp)
 201c8fc:	e0fffe0d 	sth	r3,-8(fp)
 201c900:	e0bfff05 	stb	r2,-4(fp)
  p->next = NULL;
 201c904:	e0bffb17 	ldw	r2,-20(fp)
 201c908:	10000015 	stw	zero,0(r2)
  p->payload = payload;
 201c90c:	e0bffb17 	ldw	r2,-20(fp)
 201c910:	e0fffc17 	ldw	r3,-16(fp)
 201c914:	10c00115 	stw	r3,4(r2)
  p->tot_len = tot_len;
 201c918:	e0bffb17 	ldw	r2,-20(fp)
 201c91c:	e0fffd0b 	ldhu	r3,-12(fp)
 201c920:	10c0020d 	sth	r3,8(r2)
  p->len = len;
 201c924:	e0bffb17 	ldw	r2,-20(fp)
 201c928:	e0fffe0b 	ldhu	r3,-8(fp)
 201c92c:	10c0028d 	sth	r3,10(r2)
  p->type_internal = (u8_t)type;
 201c930:	e0800117 	ldw	r2,4(fp)
 201c934:	1007883a 	mov	r3,r2
 201c938:	e0bffb17 	ldw	r2,-20(fp)
 201c93c:	10c00305 	stb	r3,12(r2)
  p->flags = flags;
 201c940:	e0bffb17 	ldw	r2,-20(fp)
 201c944:	e0ffff03 	ldbu	r3,-4(fp)
 201c948:	10c00345 	stb	r3,13(r2)
  p->ref = 1;
 201c94c:	e0bffb17 	ldw	r2,-20(fp)
 201c950:	00c00044 	movi	r3,1
 201c954:	10c00385 	stb	r3,14(r2)
  p->if_idx = NETIF_NO_INDEX;
 201c958:	e0bffb17 	ldw	r2,-20(fp)
 201c95c:	100003c5 	stb	zero,15(r2)
}
 201c960:	0001883a 	nop
 201c964:	e037883a 	mov	sp,fp
 201c968:	df000017 	ldw	fp,0(sp)
 201c96c:	dec00104 	addi	sp,sp,4
 201c970:	f800283a 	ret

0201c974 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 201c974:	defff204 	addi	sp,sp,-56
 201c978:	dfc00d15 	stw	ra,52(sp)
 201c97c:	df000c15 	stw	fp,48(sp)
 201c980:	df000c04 	addi	fp,sp,48
 201c984:	e13ffd15 	stw	r4,-12(fp)
 201c988:	2805883a 	mov	r2,r5
 201c98c:	e1bfff15 	stw	r6,-4(fp)
 201c990:	e0bffe0d 	sth	r2,-8(fp)
  struct pbuf *p;
  u16_t offset = (u16_t)layer;
 201c994:	e0bffd17 	ldw	r2,-12(fp)
 201c998:	e0bff70d 	sth	r2,-36(fp)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  switch (type) {
 201c99c:	e0bfff17 	ldw	r2,-4(fp)
 201c9a0:	10c01060 	cmpeqi	r3,r2,65
 201c9a4:	18000a1e 	bne	r3,zero,201c9d0 <pbuf_alloc+0x5c>
 201c9a8:	10c010a8 	cmpgeui	r3,r2,66
 201c9ac:	1800031e 	bne	r3,zero,201c9bc <pbuf_alloc+0x48>
 201c9b0:	10800060 	cmpeqi	r2,r2,1
 201c9b4:	1000061e 	bne	r2,zero,201c9d0 <pbuf_alloc+0x5c>
 201c9b8:	00008506 	br	201cbd0 <pbuf_alloc+0x25c>
 201c9bc:	10c060a0 	cmpeqi	r3,r2,386
 201c9c0:	18000a1e 	bne	r3,zero,201c9ec <pbuf_alloc+0x78>
 201c9c4:	1080a020 	cmpeqi	r2,r2,640
 201c9c8:	1000491e 	bne	r2,zero,201caf0 <pbuf_alloc+0x17c>
 201c9cc:	00008006 	br	201cbd0 <pbuf_alloc+0x25c>
    case PBUF_REF: /* fall through */
    case PBUF_ROM:
      p = pbuf_alloc_reference(NULL, length, type);
 201c9d0:	e0bffe0b 	ldhu	r2,-8(fp)
 201c9d4:	e1bfff17 	ldw	r6,-4(fp)
 201c9d8:	100b883a 	mov	r5,r2
 201c9dc:	0009883a 	mov	r4,zero
 201c9e0:	201cbf00 	call	201cbf0 <pbuf_alloc_reference>
 201c9e4:	e0bff615 	stw	r2,-40(fp)
      break;
 201c9e8:	00007b06 	br	201cbd8 <pbuf_alloc+0x264>
    case PBUF_POOL: {
      struct pbuf *q, *last;
      u16_t rem_len; /* remaining length */
      p = NULL;
 201c9ec:	e03ff615 	stw	zero,-40(fp)
      last = NULL;
 201c9f0:	e03ff815 	stw	zero,-32(fp)
      rem_len = length;
 201c9f4:	e0bffe0b 	ldhu	r2,-8(fp)
 201c9f8:	e0bff90d 	sth	r2,-28(fp)
      do {
        u16_t qlen;
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 201c9fc:	01000384 	movi	r4,14
 201ca00:	201b82c0 	call	201b82c <memp_malloc>
 201ca04:	e0bffa15 	stw	r2,-24(fp)
        if (q == NULL) {
 201ca08:	e0bffa17 	ldw	r2,-24(fp)
 201ca0c:	1000071e 	bne	r2,zero,201ca2c <pbuf_alloc+0xb8>
          PBUF_POOL_IS_EMPTY();
 201ca10:	201c8540 	call	201c854 <pbuf_pool_is_empty>
          /* free chain so far allocated */
          if (p) {
 201ca14:	e0bff617 	ldw	r2,-40(fp)
 201ca18:	10000226 	beq	r2,zero,201ca24 <pbuf_alloc+0xb0>
            pbuf_free(p);
 201ca1c:	e13ff617 	ldw	r4,-40(fp)
 201ca20:	201d2f40 	call	201d2f4 <pbuf_free>
          }
          /* bail out unsuccessfully */
          return NULL;
 201ca24:	0005883a 	mov	r2,zero
 201ca28:	00006c06 	br	201cbdc <pbuf_alloc+0x268>
        }
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
 201ca2c:	e0bff70b 	ldhu	r2,-36(fp)
 201ca30:	108000c4 	addi	r2,r2,3
 201ca34:	1007883a 	mov	r3,r2
 201ca38:	00bfff04 	movi	r2,-4
 201ca3c:	1884703a 	and	r2,r3,r2
 201ca40:	1007883a 	mov	r3,r2
 201ca44:	00817b04 	movi	r2,1516
 201ca48:	10c5c83a 	sub	r2,r2,r3
 201ca4c:	e17ff90b 	ldhu	r5,-28(fp)
 201ca50:	10ffffcc 	andi	r3,r2,65535
 201ca54:	293fffcc 	andi	r4,r5,65535
 201ca58:	20c0012e 	bgeu	r4,r3,201ca60 <pbuf_alloc+0xec>
 201ca5c:	2805883a 	mov	r2,r5
 201ca60:	e0bffb0d 	sth	r2,-20(fp)
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
 201ca64:	e0bff70b 	ldhu	r2,-36(fp)
 201ca68:	10800404 	addi	r2,r2,16
 201ca6c:	e0fffa17 	ldw	r3,-24(fp)
 201ca70:	1885883a 	add	r2,r3,r2
 201ca74:	10c000c4 	addi	r3,r2,3
 201ca78:	00bfff04 	movi	r2,-4
 201ca7c:	1884703a 	and	r2,r3,r2
 201ca80:	100b883a 	mov	r5,r2
 201ca84:	e0fff90b 	ldhu	r3,-28(fp)
 201ca88:	e13ffb0b 	ldhu	r4,-20(fp)
 201ca8c:	d8000115 	stw	zero,4(sp)
 201ca90:	e0bfff17 	ldw	r2,-4(fp)
 201ca94:	d8800015 	stw	r2,0(sp)
 201ca98:	200f883a 	mov	r7,r4
 201ca9c:	180d883a 	mov	r6,r3
 201caa0:	e13ffa17 	ldw	r4,-24(fp)
 201caa4:	201c8d80 	call	201c8d8 <pbuf_init_alloced_pbuf>
                               rem_len, qlen, type, 0);
        LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
                    ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
                    (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
        if (p == NULL) {
 201caa8:	e0bff617 	ldw	r2,-40(fp)
 201caac:	1000031e 	bne	r2,zero,201cabc <pbuf_alloc+0x148>
          /* allocated head of pbuf chain (into p) */
          p = q;
 201cab0:	e0bffa17 	ldw	r2,-24(fp)
 201cab4:	e0bff615 	stw	r2,-40(fp)
 201cab8:	00000306 	br	201cac8 <pbuf_alloc+0x154>
        } else {
          /* make previous pbuf point to this pbuf */
          last->next = q;
 201cabc:	e0bff817 	ldw	r2,-32(fp)
 201cac0:	e0fffa17 	ldw	r3,-24(fp)
 201cac4:	10c00015 	stw	r3,0(r2)
        }
        last = q;
 201cac8:	e0bffa17 	ldw	r2,-24(fp)
 201cacc:	e0bff815 	stw	r2,-32(fp)
        rem_len = (u16_t)(rem_len - qlen);
 201cad0:	e0fff90b 	ldhu	r3,-28(fp)
 201cad4:	e0bffb0b 	ldhu	r2,-20(fp)
 201cad8:	1885c83a 	sub	r2,r3,r2
 201cadc:	e0bff90d 	sth	r2,-28(fp)
        offset = 0;
 201cae0:	e03ff70d 	sth	zero,-36(fp)
      } while (rem_len > 0);
 201cae4:	e0bff90b 	ldhu	r2,-28(fp)
 201cae8:	103fc41e 	bne	r2,zero,201c9fc <__alt_mem_mem_0+0xfcffc9fc>
      break;
 201caec:	00003a06 	br	201cbd8 <pbuf_alloc+0x264>
    }
    case PBUF_RAM: {
      u16_t payload_len = (u16_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
 201caf0:	e0bff70b 	ldhu	r2,-36(fp)
 201caf4:	108000c4 	addi	r2,r2,3
 201caf8:	1007883a 	mov	r3,r2
 201cafc:	00bfff04 	movi	r2,-4
 201cb00:	1884703a 	and	r2,r3,r2
 201cb04:	1007883a 	mov	r3,r2
 201cb08:	e0bffe0b 	ldhu	r2,-8(fp)
 201cb0c:	108000c4 	addi	r2,r2,3
 201cb10:	1009883a 	mov	r4,r2
 201cb14:	00bfff04 	movi	r2,-4
 201cb18:	2084703a 	and	r2,r4,r2
 201cb1c:	1885883a 	add	r2,r3,r2
 201cb20:	e0bffb8d 	sth	r2,-18(fp)
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
 201cb24:	e0bffb8b 	ldhu	r2,-18(fp)
 201cb28:	10800404 	addi	r2,r2,16
 201cb2c:	e0bffc0d 	sth	r2,-16(fp)

      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 201cb30:	e0fffb8b 	ldhu	r3,-18(fp)
 201cb34:	e0bffe0b 	ldhu	r2,-8(fp)
 201cb38:	110000c4 	addi	r4,r2,3
 201cb3c:	00bfff04 	movi	r2,-4
 201cb40:	2084703a 	and	r2,r4,r2
 201cb44:	18800636 	bltu	r3,r2,201cb60 <pbuf_alloc+0x1ec>
          (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
 201cb48:	e0fffc0b 	ldhu	r3,-16(fp)
 201cb4c:	e0bffe0b 	ldhu	r2,-8(fp)
 201cb50:	110000c4 	addi	r4,r2,3
 201cb54:	00bfff04 	movi	r2,-4
 201cb58:	2084703a 	and	r2,r4,r2
    case PBUF_RAM: {
      u16_t payload_len = (u16_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);

      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 201cb5c:	1880022e 	bgeu	r3,r2,201cb68 <pbuf_alloc+0x1f4>
          (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
        return NULL;
 201cb60:	0005883a 	mov	r2,zero
 201cb64:	00001d06 	br	201cbdc <pbuf_alloc+0x268>
      }

      /* If pbuf is to be allocated in RAM, allocate memory for it. */
      p = (struct pbuf *)mem_malloc(alloc_len);
 201cb68:	e0bffc0b 	ldhu	r2,-16(fp)
 201cb6c:	1009883a 	mov	r4,r2
 201cb70:	201b1d40 	call	201b1d4 <mem_malloc>
 201cb74:	e0bff615 	stw	r2,-40(fp)
      if (p == NULL) {
 201cb78:	e0bff617 	ldw	r2,-40(fp)
 201cb7c:	1000021e 	bne	r2,zero,201cb88 <pbuf_alloc+0x214>
        return NULL;
 201cb80:	0005883a 	mov	r2,zero
 201cb84:	00001506 	br	201cbdc <pbuf_alloc+0x268>
      }
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
 201cb88:	e0bff70b 	ldhu	r2,-36(fp)
 201cb8c:	10800404 	addi	r2,r2,16
 201cb90:	e0fff617 	ldw	r3,-40(fp)
 201cb94:	1885883a 	add	r2,r3,r2
 201cb98:	10c000c4 	addi	r3,r2,3
 201cb9c:	00bfff04 	movi	r2,-4
 201cba0:	1884703a 	and	r2,r3,r2
 201cba4:	100b883a 	mov	r5,r2
 201cba8:	e0fffe0b 	ldhu	r3,-8(fp)
 201cbac:	e13ffe0b 	ldhu	r4,-8(fp)
 201cbb0:	d8000115 	stw	zero,4(sp)
 201cbb4:	e0bfff17 	ldw	r2,-4(fp)
 201cbb8:	d8800015 	stw	r2,0(sp)
 201cbbc:	200f883a 	mov	r7,r4
 201cbc0:	180d883a 	mov	r6,r3
 201cbc4:	e13ff617 	ldw	r4,-40(fp)
 201cbc8:	201c8d80 	call	201c8d8 <pbuf_init_alloced_pbuf>
                             length, length, type, 0);
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
                  ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
      break;
 201cbcc:	00000206 	br	201cbd8 <pbuf_alloc+0x264>
    }
    default:
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
      return NULL;
 201cbd0:	0005883a 	mov	r2,zero
 201cbd4:	00000106 	br	201cbdc <pbuf_alloc+0x268>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 201cbd8:	e0bff617 	ldw	r2,-40(fp)
}
 201cbdc:	e037883a 	mov	sp,fp
 201cbe0:	dfc00117 	ldw	ra,4(sp)
 201cbe4:	df000017 	ldw	fp,0(sp)
 201cbe8:	dec00204 	addi	sp,sp,8
 201cbec:	f800283a 	ret

0201cbf0 <pbuf_alloc_reference>:
 *
 * @return the allocated pbuf.
 */
struct pbuf *
pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
{
 201cbf0:	defff804 	addi	sp,sp,-32
 201cbf4:	dfc00715 	stw	ra,28(sp)
 201cbf8:	df000615 	stw	fp,24(sp)
 201cbfc:	df000604 	addi	fp,sp,24
 201cc00:	e13ffd15 	stw	r4,-12(fp)
 201cc04:	2805883a 	mov	r2,r5
 201cc08:	e1bfff15 	stw	r6,-4(fp)
 201cc0c:	e0bffe0d 	sth	r2,-8(fp)
  struct pbuf *p;
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
  /* only allocate memory for the pbuf structure */
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 201cc10:	01000344 	movi	r4,13
 201cc14:	201b82c0 	call	201b82c <memp_malloc>
 201cc18:	e0bffc15 	stw	r2,-16(fp)
  if (p == NULL) {
 201cc1c:	e0bffc17 	ldw	r2,-16(fp)
 201cc20:	1000021e 	bne	r2,zero,201cc2c <pbuf_alloc_reference+0x3c>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                 (type == PBUF_ROM) ? "ROM" : "REF"));
    return NULL;
 201cc24:	0005883a 	mov	r2,zero
 201cc28:	00000b06 	br	201cc58 <pbuf_alloc_reference+0x68>
  }
  pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
 201cc2c:	e0fffe0b 	ldhu	r3,-8(fp)
 201cc30:	e13ffe0b 	ldhu	r4,-8(fp)
 201cc34:	d8000115 	stw	zero,4(sp)
 201cc38:	e0bfff17 	ldw	r2,-4(fp)
 201cc3c:	d8800015 	stw	r2,0(sp)
 201cc40:	200f883a 	mov	r7,r4
 201cc44:	180d883a 	mov	r6,r3
 201cc48:	e17ffd17 	ldw	r5,-12(fp)
 201cc4c:	e13ffc17 	ldw	r4,-16(fp)
 201cc50:	201c8d80 	call	201c8d8 <pbuf_init_alloced_pbuf>
  return p;
 201cc54:	e0bffc17 	ldw	r2,-16(fp)
}
 201cc58:	e037883a 	mov	sp,fp
 201cc5c:	dfc00117 	ldw	ra,4(sp)
 201cc60:	df000017 	ldw	fp,0(sp)
 201cc64:	dec00204 	addi	sp,sp,8
 201cc68:	f800283a 	ret

0201cc6c <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 201cc6c:	defff504 	addi	sp,sp,-44
 201cc70:	dfc00a15 	stw	ra,40(sp)
 201cc74:	df000915 	stw	fp,36(sp)
 201cc78:	df000904 	addi	fp,sp,36
 201cc7c:	e13ffb15 	stw	r4,-20(fp)
 201cc80:	2807883a 	mov	r3,r5
 201cc84:	e1bffd15 	stw	r6,-12(fp)
 201cc88:	e1fffe15 	stw	r7,-8(fp)
 201cc8c:	e0800317 	ldw	r2,12(fp)
 201cc90:	e0fffc0d 	sth	r3,-16(fp)
 201cc94:	e0bfff0d 	sth	r2,-4(fp)
  u16_t offset = (u16_t)l;
 201cc98:	e0bffb17 	ldw	r2,-20(fp)
 201cc9c:	e0bffa0d 	sth	r2,-24(fp)
  void *payload;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 201cca0:	e0bffa0b 	ldhu	r2,-24(fp)
 201cca4:	10c000c4 	addi	r3,r2,3
 201cca8:	00bfff04 	movi	r2,-4
 201ccac:	1886703a 	and	r3,r3,r2
 201ccb0:	e0bffc0b 	ldhu	r2,-16(fp)
 201ccb4:	1885883a 	add	r2,r3,r2
 201ccb8:	e0ffff0b 	ldhu	r3,-4(fp)
 201ccbc:	1880022e 	bgeu	r3,r2,201ccc8 <pbuf_alloced_custom+0x5c>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
 201ccc0:	0005883a 	mov	r2,zero
 201ccc4:	00001806 	br	201cd28 <pbuf_alloced_custom+0xbc>
  }

  if (payload_mem != NULL) {
 201ccc8:	e0800217 	ldw	r2,8(fp)
 201cccc:	10000826 	beq	r2,zero,201ccf0 <pbuf_alloced_custom+0x84>
    payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 201ccd0:	e0bffa0b 	ldhu	r2,-24(fp)
 201ccd4:	10c000c4 	addi	r3,r2,3
 201ccd8:	00bfff04 	movi	r2,-4
 201ccdc:	1884703a 	and	r2,r3,r2
 201cce0:	e0c00217 	ldw	r3,8(fp)
 201cce4:	1885883a 	add	r2,r3,r2
 201cce8:	e0bff915 	stw	r2,-28(fp)
 201ccec:	00000106 	br	201ccf4 <pbuf_alloced_custom+0x88>
  } else {
    payload = NULL;
 201ccf0:	e03ff915 	stw	zero,-28(fp)
  }
  pbuf_init_alloced_pbuf(&p->pbuf, payload, length, length, type, PBUF_FLAG_IS_CUSTOM);
 201ccf4:	e0fffe17 	ldw	r3,-8(fp)
 201ccf8:	e13ffc0b 	ldhu	r4,-16(fp)
 201ccfc:	e17ffc0b 	ldhu	r5,-16(fp)
 201cd00:	00800084 	movi	r2,2
 201cd04:	d8800115 	stw	r2,4(sp)
 201cd08:	e0bffd17 	ldw	r2,-12(fp)
 201cd0c:	d8800015 	stw	r2,0(sp)
 201cd10:	280f883a 	mov	r7,r5
 201cd14:	200d883a 	mov	r6,r4
 201cd18:	e17ff917 	ldw	r5,-28(fp)
 201cd1c:	1809883a 	mov	r4,r3
 201cd20:	201c8d80 	call	201c8d8 <pbuf_init_alloced_pbuf>
  return &p->pbuf;
 201cd24:	e0bffe17 	ldw	r2,-8(fp)
}
 201cd28:	e037883a 	mov	sp,fp
 201cd2c:	dfc00117 	ldw	ra,4(sp)
 201cd30:	df000017 	ldw	fp,0(sp)
 201cd34:	dec00204 	addi	sp,sp,8
 201cd38:	f800283a 	ret

0201cd3c <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 201cd3c:	defffa04 	addi	sp,sp,-24
 201cd40:	dfc00515 	stw	ra,20(sp)
 201cd44:	df000415 	stw	fp,16(sp)
 201cd48:	df000404 	addi	fp,sp,16
 201cd4c:	e13ffe15 	stw	r4,-8(fp)
 201cd50:	2805883a 	mov	r2,r5
 201cd54:	e0bfff0d 	sth	r2,-4(fp)
  u16_t shrink;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 201cd58:	e0bffe17 	ldw	r2,-8(fp)
 201cd5c:	1080020b 	ldhu	r2,8(r2)
 201cd60:	10bfffcc 	andi	r2,r2,65535
 201cd64:	e0ffff0b 	ldhu	r3,-4(fp)
 201cd68:	18804b2e 	bgeu	r3,r2,201ce98 <pbuf_realloc+0x15c>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  shrink = (u16_t)(p->tot_len - new_len);
 201cd6c:	e0bffe17 	ldw	r2,-8(fp)
 201cd70:	10c0020b 	ldhu	r3,8(r2)
 201cd74:	e0bfff0b 	ldhu	r2,-4(fp)
 201cd78:	1885c83a 	sub	r2,r3,r2
 201cd7c:	e0bffd8d 	sth	r2,-10(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 201cd80:	e0bfff0b 	ldhu	r2,-4(fp)
 201cd84:	e0bffd0d 	sth	r2,-12(fp)
  q = p;
 201cd88:	e0bffe17 	ldw	r2,-8(fp)
 201cd8c:	e0bffc15 	stw	r2,-16(fp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 201cd90:	00000f06 	br	201cdd0 <pbuf_realloc+0x94>
    /* decrease remaining length by pbuf length */
    rem_len = (u16_t)(rem_len - q->len);
 201cd94:	e0bffc17 	ldw	r2,-16(fp)
 201cd98:	1080028b 	ldhu	r2,10(r2)
 201cd9c:	e0fffd0b 	ldhu	r3,-12(fp)
 201cda0:	1885c83a 	sub	r2,r3,r2
 201cda4:	e0bffd0d 	sth	r2,-12(fp)
    /* decrease total length indicator */
    q->tot_len = (u16_t)(q->tot_len - shrink);
 201cda8:	e0bffc17 	ldw	r2,-16(fp)
 201cdac:	10c0020b 	ldhu	r3,8(r2)
 201cdb0:	e0bffd8b 	ldhu	r2,-10(fp)
 201cdb4:	1885c83a 	sub	r2,r3,r2
 201cdb8:	1007883a 	mov	r3,r2
 201cdbc:	e0bffc17 	ldw	r2,-16(fp)
 201cdc0:	10c0020d 	sth	r3,8(r2)
    /* proceed to next pbuf in chain */
    q = q->next;
 201cdc4:	e0bffc17 	ldw	r2,-16(fp)
 201cdc8:	10800017 	ldw	r2,0(r2)
 201cdcc:	e0bffc15 	stw	r2,-16(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 201cdd0:	e0bffc17 	ldw	r2,-16(fp)
 201cdd4:	1080028b 	ldhu	r2,10(r2)
 201cdd8:	10ffffcc 	andi	r3,r2,65535
 201cddc:	e0bffd0b 	ldhu	r2,-12(fp)
 201cde0:	18bfec36 	bltu	r3,r2,201cd94 <__alt_mem_mem_0+0xfcffcd94>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
 201cde4:	e0bffc17 	ldw	r2,-16(fp)
 201cde8:	10800303 	ldbu	r2,12(r2)
 201cdec:	10803fcc 	andi	r2,r2,255
 201cdf0:	108003cc 	andi	r2,r2,15
 201cdf4:	1000171e 	bne	r2,zero,201ce54 <pbuf_realloc+0x118>
 201cdf8:	e0bffc17 	ldw	r2,-16(fp)
 201cdfc:	1080028b 	ldhu	r2,10(r2)
 201ce00:	10ffffcc 	andi	r3,r2,65535
 201ce04:	e0bffd0b 	ldhu	r2,-12(fp)
 201ce08:	18801226 	beq	r3,r2,201ce54 <pbuf_realloc+0x118>
#if LWIP_SUPPORT_CUSTOM_PBUF
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 201ce0c:	e0bffc17 	ldw	r2,-16(fp)
 201ce10:	10800343 	ldbu	r2,13(r2)
 201ce14:	10803fcc 	andi	r2,r2,255
 201ce18:	1080008c 	andi	r2,r2,2
 201ce1c:	10000d1e 	bne	r2,zero,201ce54 <pbuf_realloc+0x118>
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
     ) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
 201ce20:	e0bffc17 	ldw	r2,-16(fp)
 201ce24:	10800117 	ldw	r2,4(r2)
 201ce28:	1007883a 	mov	r3,r2
 201ce2c:	e0bffc17 	ldw	r2,-16(fp)
 201ce30:	1885c83a 	sub	r2,r3,r2
 201ce34:	1007883a 	mov	r3,r2
 201ce38:	e0bffd0b 	ldhu	r2,-12(fp)
 201ce3c:	1885883a 	add	r2,r3,r2
 201ce40:	10bfffcc 	andi	r2,r2,65535
 201ce44:	100b883a 	mov	r5,r2
 201ce48:	e13ffc17 	ldw	r4,-16(fp)
 201ce4c:	201aec40 	call	201aec4 <mem_trim>
 201ce50:	e0bffc15 	stw	r2,-16(fp)
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 201ce54:	e0bffc17 	ldw	r2,-16(fp)
 201ce58:	e0fffd0b 	ldhu	r3,-12(fp)
 201ce5c:	10c0028d 	sth	r3,10(r2)
  q->tot_len = q->len;
 201ce60:	e0bffc17 	ldw	r2,-16(fp)
 201ce64:	10c0028b 	ldhu	r3,10(r2)
 201ce68:	e0bffc17 	ldw	r2,-16(fp)
 201ce6c:	10c0020d 	sth	r3,8(r2)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 201ce70:	e0bffc17 	ldw	r2,-16(fp)
 201ce74:	10800017 	ldw	r2,0(r2)
 201ce78:	10000426 	beq	r2,zero,201ce8c <pbuf_realloc+0x150>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 201ce7c:	e0bffc17 	ldw	r2,-16(fp)
 201ce80:	10800017 	ldw	r2,0(r2)
 201ce84:	1009883a 	mov	r4,r2
 201ce88:	201d2f40 	call	201d2f4 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 201ce8c:	e0bffc17 	ldw	r2,-16(fp)
 201ce90:	10000015 	stw	zero,0(r2)
 201ce94:	00000106 	br	201ce9c <pbuf_realloc+0x160>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
 201ce98:	0001883a 	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
 201ce9c:	e037883a 	mov	sp,fp
 201cea0:	dfc00117 	ldw	ra,4(sp)
 201cea4:	df000017 	ldw	fp,0(sp)
 201cea8:	dec00204 	addi	sp,sp,8
 201ceac:	f800283a 	ret

0201ceb0 <pbuf_add_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
{
 201ceb0:	defffa04 	addi	sp,sp,-24
 201ceb4:	df000515 	stw	fp,20(sp)
 201ceb8:	df000504 	addi	fp,sp,20
 201cebc:	e13ffd15 	stw	r4,-12(fp)
 201cec0:	e17ffe15 	stw	r5,-8(fp)
 201cec4:	3005883a 	mov	r2,r6
 201cec8:	e0bfff05 	stb	r2,-4(fp)
  u16_t type_internal;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
 201cecc:	e0bffd17 	ldw	r2,-12(fp)
 201ced0:	10000326 	beq	r2,zero,201cee0 <pbuf_add_header_impl+0x30>
 201ced4:	e0bffe17 	ldw	r2,-8(fp)
 201ced8:	00ffffd4 	movui	r3,65535
 201cedc:	1880022e 	bgeu	r3,r2,201cee8 <pbuf_add_header_impl+0x38>
    return 1;
 201cee0:	00800044 	movi	r2,1
 201cee4:	00003f06 	br	201cfe4 <pbuf_add_header_impl+0x134>
  }
  if (header_size_increment == 0) {
 201cee8:	e0bffe17 	ldw	r2,-8(fp)
 201ceec:	1000021e 	bne	r2,zero,201cef8 <pbuf_add_header_impl+0x48>
    return 0;
 201cef0:	0005883a 	mov	r2,zero
 201cef4:	00003b06 	br	201cfe4 <pbuf_add_header_impl+0x134>
  }

  increment_magnitude = (u16_t)header_size_increment;
 201cef8:	e0bffe17 	ldw	r2,-8(fp)
 201cefc:	e0bffc0d 	sth	r2,-16(fp)
  /* Do not allow tot_len to wrap as a result. */
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
 201cf00:	e0bffd17 	ldw	r2,-12(fp)
 201cf04:	10c0020b 	ldhu	r3,8(r2)
 201cf08:	e0bffc0b 	ldhu	r2,-16(fp)
 201cf0c:	1885883a 	add	r2,r3,r2
 201cf10:	10ffffcc 	andi	r3,r2,65535
 201cf14:	e0bffc0b 	ldhu	r2,-16(fp)
 201cf18:	1880022e 	bgeu	r3,r2,201cf24 <pbuf_add_header_impl+0x74>
    return 1;
 201cf1c:	00800044 	movi	r2,1
 201cf20:	00003006 	br	201cfe4 <pbuf_add_header_impl+0x134>
  }

  type_internal = p->type_internal;
 201cf24:	e0bffd17 	ldw	r2,-12(fp)
 201cf28:	10800303 	ldbu	r2,12(r2)
 201cf2c:	10803fcc 	andi	r2,r2,255
 201cf30:	e0bffc8d 	sth	r2,-14(fp)

  /* pbuf types containing payloads? */
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
 201cf34:	e0bffc8b 	ldhu	r2,-14(fp)
 201cf38:	1080200c 	andi	r2,r2,128
 201cf3c:	10000c26 	beq	r2,zero,201cf70 <pbuf_add_header_impl+0xc0>
    /* set new payload pointer */
    payload = (u8_t *)p->payload - header_size_increment;
 201cf40:	e0bffd17 	ldw	r2,-12(fp)
 201cf44:	10c00117 	ldw	r3,4(r2)
 201cf48:	e0bffe17 	ldw	r2,-8(fp)
 201cf4c:	0085c83a 	sub	r2,zero,r2
 201cf50:	1885883a 	add	r2,r3,r2
 201cf54:	e0bffb15 	stw	r2,-20(fp)
    /* boundary check fails? */
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 201cf58:	e0bffd17 	ldw	r2,-12(fp)
 201cf5c:	10800404 	addi	r2,r2,16
 201cf60:	e0fffb17 	ldw	r3,-20(fp)
 201cf64:	18800d2e 	bgeu	r3,r2,201cf9c <pbuf_add_header_impl+0xec>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
                   ("pbuf_add_header: failed as %p < %p (not enough space for new header size)\n",
                    (void *)payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
      /* bail out unsuccessfully */
      return 1;
 201cf68:	00800044 	movi	r2,1
 201cf6c:	00001d06 	br	201cfe4 <pbuf_add_header_impl+0x134>
    }
    /* pbuf types referring to external payloads? */
  } else {
    /* hide a header in the payload? */
    if (force) {
 201cf70:	e0bfff03 	ldbu	r2,-4(fp)
 201cf74:	10000726 	beq	r2,zero,201cf94 <pbuf_add_header_impl+0xe4>
      payload = (u8_t *)p->payload - header_size_increment;
 201cf78:	e0bffd17 	ldw	r2,-12(fp)
 201cf7c:	10c00117 	ldw	r3,4(r2)
 201cf80:	e0bffe17 	ldw	r2,-8(fp)
 201cf84:	0085c83a 	sub	r2,zero,r2
 201cf88:	1885883a 	add	r2,r3,r2
 201cf8c:	e0bffb15 	stw	r2,-20(fp)
 201cf90:	00000206 	br	201cf9c <pbuf_add_header_impl+0xec>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccessfully */
      return 1;
 201cf94:	00800044 	movi	r2,1
 201cf98:	00001206 	br	201cfe4 <pbuf_add_header_impl+0x134>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
              (void *)p->payload, (void *)payload, increment_magnitude));

  /* modify pbuf fields */
  p->payload = payload;
 201cf9c:	e0bffd17 	ldw	r2,-12(fp)
 201cfa0:	e0fffb17 	ldw	r3,-20(fp)
 201cfa4:	10c00115 	stw	r3,4(r2)
  p->len = (u16_t)(p->len + increment_magnitude);
 201cfa8:	e0bffd17 	ldw	r2,-12(fp)
 201cfac:	10c0028b 	ldhu	r3,10(r2)
 201cfb0:	e0bffc0b 	ldhu	r2,-16(fp)
 201cfb4:	1885883a 	add	r2,r3,r2
 201cfb8:	1007883a 	mov	r3,r2
 201cfbc:	e0bffd17 	ldw	r2,-12(fp)
 201cfc0:	10c0028d 	sth	r3,10(r2)
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
 201cfc4:	e0bffd17 	ldw	r2,-12(fp)
 201cfc8:	10c0020b 	ldhu	r3,8(r2)
 201cfcc:	e0bffc0b 	ldhu	r2,-16(fp)
 201cfd0:	1885883a 	add	r2,r3,r2
 201cfd4:	1007883a 	mov	r3,r2
 201cfd8:	e0bffd17 	ldw	r2,-12(fp)
 201cfdc:	10c0020d 	sth	r3,8(r2)


  return 0;
 201cfe0:	0005883a 	mov	r2,zero
}
 201cfe4:	e037883a 	mov	sp,fp
 201cfe8:	df000017 	ldw	fp,0(sp)
 201cfec:	dec00104 	addi	sp,sp,4
 201cff0:	f800283a 	ret

0201cff4 <pbuf_add_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_add_header(struct pbuf *p, size_t header_size_increment)
{
 201cff4:	defffc04 	addi	sp,sp,-16
 201cff8:	dfc00315 	stw	ra,12(sp)
 201cffc:	df000215 	stw	fp,8(sp)
 201d000:	df000204 	addi	fp,sp,8
 201d004:	e13ffe15 	stw	r4,-8(fp)
 201d008:	e17fff15 	stw	r5,-4(fp)
  return pbuf_add_header_impl(p, header_size_increment, 0);
 201d00c:	000d883a 	mov	r6,zero
 201d010:	e17fff17 	ldw	r5,-4(fp)
 201d014:	e13ffe17 	ldw	r4,-8(fp)
 201d018:	201ceb00 	call	201ceb0 <pbuf_add_header_impl>
}
 201d01c:	e037883a 	mov	sp,fp
 201d020:	dfc00117 	ldw	ra,4(sp)
 201d024:	df000017 	ldw	fp,0(sp)
 201d028:	dec00204 	addi	sp,sp,8
 201d02c:	f800283a 	ret

0201d030 <pbuf_add_header_force>:
 * Same as @ref pbuf_add_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_add_header_force(struct pbuf *p, size_t header_size_increment)
{
 201d030:	defffc04 	addi	sp,sp,-16
 201d034:	dfc00315 	stw	ra,12(sp)
 201d038:	df000215 	stw	fp,8(sp)
 201d03c:	df000204 	addi	fp,sp,8
 201d040:	e13ffe15 	stw	r4,-8(fp)
 201d044:	e17fff15 	stw	r5,-4(fp)
  return pbuf_add_header_impl(p, header_size_increment, 1);
 201d048:	01800044 	movi	r6,1
 201d04c:	e17fff17 	ldw	r5,-4(fp)
 201d050:	e13ffe17 	ldw	r4,-8(fp)
 201d054:	201ceb00 	call	201ceb0 <pbuf_add_header_impl>
}
 201d058:	e037883a 	mov	sp,fp
 201d05c:	dfc00117 	ldw	ra,4(sp)
 201d060:	df000017 	ldw	fp,0(sp)
 201d064:	dec00204 	addi	sp,sp,8
 201d068:	f800283a 	ret

0201d06c <pbuf_remove_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
{
 201d06c:	defffb04 	addi	sp,sp,-20
 201d070:	df000415 	stw	fp,16(sp)
 201d074:	df000404 	addi	fp,sp,16
 201d078:	e13ffe15 	stw	r4,-8(fp)
 201d07c:	e17fff15 	stw	r5,-4(fp)
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
 201d080:	e0bffe17 	ldw	r2,-8(fp)
 201d084:	10000326 	beq	r2,zero,201d094 <pbuf_remove_header+0x28>
 201d088:	e0bfff17 	ldw	r2,-4(fp)
 201d08c:	00ffffd4 	movui	r3,65535
 201d090:	1880022e 	bgeu	r3,r2,201d09c <pbuf_remove_header+0x30>
    return 1;
 201d094:	00800044 	movi	r2,1
 201d098:	00002506 	br	201d130 <pbuf_remove_header+0xc4>
  }
  if (header_size_decrement == 0) {
 201d09c:	e0bfff17 	ldw	r2,-4(fp)
 201d0a0:	1000021e 	bne	r2,zero,201d0ac <pbuf_remove_header+0x40>
    return 0;
 201d0a4:	0005883a 	mov	r2,zero
 201d0a8:	00002106 	br	201d130 <pbuf_remove_header+0xc4>
  }

  increment_magnitude = (u16_t)header_size_decrement;
 201d0ac:	e0bfff17 	ldw	r2,-4(fp)
 201d0b0:	e0bffc0d 	sth	r2,-16(fp)
  /* Check that we aren't going to move off the end of the pbuf */
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 201d0b4:	e0bffe17 	ldw	r2,-8(fp)
 201d0b8:	1080028b 	ldhu	r2,10(r2)
 201d0bc:	10ffffcc 	andi	r3,r2,65535
 201d0c0:	e0bffc0b 	ldhu	r2,-16(fp)
 201d0c4:	1880022e 	bgeu	r3,r2,201d0d0 <pbuf_remove_header+0x64>
 201d0c8:	00800044 	movi	r2,1
 201d0cc:	00001806 	br	201d130 <pbuf_remove_header+0xc4>

  /* remember current payload pointer */
  payload = p->payload;
 201d0d0:	e0bffe17 	ldw	r2,-8(fp)
 201d0d4:	10800117 	ldw	r2,4(r2)
 201d0d8:	e0bffd15 	stw	r2,-12(fp)
  LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */

  /* increase payload pointer (guarded by length check above) */
  p->payload = (u8_t *)p->payload + header_size_decrement;
 201d0dc:	e0bffe17 	ldw	r2,-8(fp)
 201d0e0:	10c00117 	ldw	r3,4(r2)
 201d0e4:	e0bfff17 	ldw	r2,-4(fp)
 201d0e8:	1887883a 	add	r3,r3,r2
 201d0ec:	e0bffe17 	ldw	r2,-8(fp)
 201d0f0:	10c00115 	stw	r3,4(r2)
  /* modify pbuf length fields */
  p->len = (u16_t)(p->len - increment_magnitude);
 201d0f4:	e0bffe17 	ldw	r2,-8(fp)
 201d0f8:	10c0028b 	ldhu	r3,10(r2)
 201d0fc:	e0bffc0b 	ldhu	r2,-16(fp)
 201d100:	1885c83a 	sub	r2,r3,r2
 201d104:	1007883a 	mov	r3,r2
 201d108:	e0bffe17 	ldw	r2,-8(fp)
 201d10c:	10c0028d 	sth	r3,10(r2)
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
 201d110:	e0bffe17 	ldw	r2,-8(fp)
 201d114:	10c0020b 	ldhu	r3,8(r2)
 201d118:	e0bffc0b 	ldhu	r2,-16(fp)
 201d11c:	1885c83a 	sub	r2,r3,r2
 201d120:	1007883a 	mov	r3,r2
 201d124:	e0bffe17 	ldw	r2,-8(fp)
 201d128:	10c0020d 	sth	r3,8(r2)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
              (void *)payload, (void *)p->payload, increment_magnitude));

  return 0;
 201d12c:	0005883a 	mov	r2,zero
}
 201d130:	e037883a 	mov	sp,fp
 201d134:	df000017 	ldw	fp,0(sp)
 201d138:	dec00104 	addi	sp,sp,4
 201d13c:	f800283a 	ret

0201d140 <pbuf_header_impl>:

static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 201d140:	defffb04 	addi	sp,sp,-20
 201d144:	dfc00415 	stw	ra,16(sp)
 201d148:	df000315 	stw	fp,12(sp)
 201d14c:	df000304 	addi	fp,sp,12
 201d150:	e13ffd15 	stw	r4,-12(fp)
 201d154:	2807883a 	mov	r3,r5
 201d158:	3005883a 	mov	r2,r6
 201d15c:	e0fffe0d 	sth	r3,-8(fp)
 201d160:	e0bfff05 	stb	r2,-4(fp)
  if (header_size_increment < 0) {
 201d164:	e0bffe0f 	ldh	r2,-8(fp)
 201d168:	1000060e 	bge	r2,zero,201d184 <pbuf_header_impl+0x44>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
 201d16c:	e0bffe0f 	ldh	r2,-8(fp)
 201d170:	0085c83a 	sub	r2,zero,r2
 201d174:	100b883a 	mov	r5,r2
 201d178:	e13ffd17 	ldw	r4,-12(fp)
 201d17c:	201d06c0 	call	201d06c <pbuf_remove_header>
 201d180:	00000606 	br	201d19c <pbuf_header_impl+0x5c>
  } else {
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
 201d184:	e0bffe0f 	ldh	r2,-8(fp)
 201d188:	e0ffff03 	ldbu	r3,-4(fp)
 201d18c:	180d883a 	mov	r6,r3
 201d190:	100b883a 	mov	r5,r2
 201d194:	e13ffd17 	ldw	r4,-12(fp)
 201d198:	201ceb00 	call	201ceb0 <pbuf_add_header_impl>
  }
}
 201d19c:	e037883a 	mov	sp,fp
 201d1a0:	dfc00117 	ldw	ra,4(sp)
 201d1a4:	df000017 	ldw	fp,0(sp)
 201d1a8:	dec00204 	addi	sp,sp,8
 201d1ac:	f800283a 	ret

0201d1b0 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 201d1b0:	defffc04 	addi	sp,sp,-16
 201d1b4:	dfc00315 	stw	ra,12(sp)
 201d1b8:	df000215 	stw	fp,8(sp)
 201d1bc:	df000204 	addi	fp,sp,8
 201d1c0:	e13ffe15 	stw	r4,-8(fp)
 201d1c4:	2805883a 	mov	r2,r5
 201d1c8:	e0bfff0d 	sth	r2,-4(fp)
  return pbuf_header_impl(p, header_size_increment, 0);
 201d1cc:	e0bfff0f 	ldh	r2,-4(fp)
 201d1d0:	000d883a 	mov	r6,zero
 201d1d4:	100b883a 	mov	r5,r2
 201d1d8:	e13ffe17 	ldw	r4,-8(fp)
 201d1dc:	201d1400 	call	201d140 <pbuf_header_impl>
}
 201d1e0:	e037883a 	mov	sp,fp
 201d1e4:	dfc00117 	ldw	ra,4(sp)
 201d1e8:	df000017 	ldw	fp,0(sp)
 201d1ec:	dec00204 	addi	sp,sp,8
 201d1f0:	f800283a 	ret

0201d1f4 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 201d1f4:	defffc04 	addi	sp,sp,-16
 201d1f8:	dfc00315 	stw	ra,12(sp)
 201d1fc:	df000215 	stw	fp,8(sp)
 201d200:	df000204 	addi	fp,sp,8
 201d204:	e13ffe15 	stw	r4,-8(fp)
 201d208:	2805883a 	mov	r2,r5
 201d20c:	e0bfff0d 	sth	r2,-4(fp)
  return pbuf_header_impl(p, header_size_increment, 1);
 201d210:	e0bfff0f 	ldh	r2,-4(fp)
 201d214:	01800044 	movi	r6,1
 201d218:	100b883a 	mov	r5,r2
 201d21c:	e13ffe17 	ldw	r4,-8(fp)
 201d220:	201d1400 	call	201d140 <pbuf_header_impl>
}
 201d224:	e037883a 	mov	sp,fp
 201d228:	dfc00117 	ldw	ra,4(sp)
 201d22c:	df000017 	ldw	fp,0(sp)
 201d230:	dec00204 	addi	sp,sp,8
 201d234:	f800283a 	ret

0201d238 <pbuf_free_header>:
 *                   takes an u16_t not s16_t!
 * @return the new head pbuf
 */
struct pbuf *
pbuf_free_header(struct pbuf *q, u16_t size)
{
 201d238:	defff904 	addi	sp,sp,-28
 201d23c:	dfc00615 	stw	ra,24(sp)
 201d240:	df000515 	stw	fp,20(sp)
 201d244:	df000504 	addi	fp,sp,20
 201d248:	e13ffe15 	stw	r4,-8(fp)
 201d24c:	2805883a 	mov	r2,r5
 201d250:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p = q;
 201d254:	e0bffe17 	ldw	r2,-8(fp)
 201d258:	e0bffb15 	stw	r2,-20(fp)
  u16_t free_left = size;
 201d25c:	e0bfff0b 	ldhu	r2,-4(fp)
 201d260:	e0bffc0d 	sth	r2,-16(fp)
  while (free_left && p) {
 201d264:	00001906 	br	201d2cc <pbuf_free_header+0x94>
    if (free_left >= p->len) {
 201d268:	e0bffb17 	ldw	r2,-20(fp)
 201d26c:	1080028b 	ldhu	r2,10(r2)
 201d270:	10bfffcc 	andi	r2,r2,65535
 201d274:	e0fffc0b 	ldhu	r3,-16(fp)
 201d278:	18800f36 	bltu	r3,r2,201d2b8 <pbuf_free_header+0x80>
      struct pbuf *f = p;
 201d27c:	e0bffb17 	ldw	r2,-20(fp)
 201d280:	e0bffd15 	stw	r2,-12(fp)
      free_left = (u16_t)(free_left - p->len);
 201d284:	e0bffb17 	ldw	r2,-20(fp)
 201d288:	1080028b 	ldhu	r2,10(r2)
 201d28c:	e0fffc0b 	ldhu	r3,-16(fp)
 201d290:	1885c83a 	sub	r2,r3,r2
 201d294:	e0bffc0d 	sth	r2,-16(fp)
      p = p->next;
 201d298:	e0bffb17 	ldw	r2,-20(fp)
 201d29c:	10800017 	ldw	r2,0(r2)
 201d2a0:	e0bffb15 	stw	r2,-20(fp)
      f->next = 0;
 201d2a4:	e0bffd17 	ldw	r2,-12(fp)
 201d2a8:	10000015 	stw	zero,0(r2)
      pbuf_free(f);
 201d2ac:	e13ffd17 	ldw	r4,-12(fp)
 201d2b0:	201d2f40 	call	201d2f4 <pbuf_free>
 201d2b4:	00000506 	br	201d2cc <pbuf_free_header+0x94>
    } else {
      pbuf_remove_header(p, free_left);
 201d2b8:	e0bffc0b 	ldhu	r2,-16(fp)
 201d2bc:	100b883a 	mov	r5,r2
 201d2c0:	e13ffb17 	ldw	r4,-20(fp)
 201d2c4:	201d06c0 	call	201d06c <pbuf_remove_header>
      free_left = 0;
 201d2c8:	e03ffc0d 	sth	zero,-16(fp)
struct pbuf *
pbuf_free_header(struct pbuf *q, u16_t size)
{
  struct pbuf *p = q;
  u16_t free_left = size;
  while (free_left && p) {
 201d2cc:	e0bffc0b 	ldhu	r2,-16(fp)
 201d2d0:	10000226 	beq	r2,zero,201d2dc <pbuf_free_header+0xa4>
 201d2d4:	e0bffb17 	ldw	r2,-20(fp)
 201d2d8:	103fe31e 	bne	r2,zero,201d268 <__alt_mem_mem_0+0xfcffd268>
    } else {
      pbuf_remove_header(p, free_left);
      free_left = 0;
    }
  }
  return p;
 201d2dc:	e0bffb17 	ldw	r2,-20(fp)
}
 201d2e0:	e037883a 	mov	sp,fp
 201d2e4:	dfc00117 	ldw	ra,4(sp)
 201d2e8:	df000017 	ldw	fp,0(sp)
 201d2ec:	dec00204 	addi	sp,sp,8
 201d2f0:	f800283a 	ret

0201d2f4 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 201d2f4:	defff704 	addi	sp,sp,-36
 201d2f8:	dfc00815 	stw	ra,32(sp)
 201d2fc:	df000715 	stw	fp,28(sp)
 201d300:	df000704 	addi	fp,sp,28
 201d304:	e13fff15 	stw	r4,-4(fp)
  u8_t alloc_src;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 201d308:	e0bfff17 	ldw	r2,-4(fp)
 201d30c:	1000021e 	bne	r2,zero,201d318 <pbuf_free+0x24>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 201d310:	0005883a 	mov	r2,zero
 201d314:	00004006 	br	201d418 <pbuf_free+0x124>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  count = 0;
 201d318:	e03ff905 	stb	zero,-28(fp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 201d31c:	00003b06 	br	201d40c <pbuf_free+0x118>
    LWIP_PBUF_REF_T ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
 201d320:	2014cec0 	call	2014cec <sys_arch_protect>
 201d324:	e0bffa15 	stw	r2,-24(fp)
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 201d328:	e0bfff17 	ldw	r2,-4(fp)
 201d32c:	10800383 	ldbu	r2,14(r2)
 201d330:	10bfffc4 	addi	r2,r2,-1
 201d334:	1007883a 	mov	r3,r2
 201d338:	e0bfff17 	ldw	r2,-4(fp)
 201d33c:	10c00385 	stb	r3,14(r2)
 201d340:	e0bfff17 	ldw	r2,-4(fp)
 201d344:	10800383 	ldbu	r2,14(r2)
 201d348:	e0bffb05 	stb	r2,-20(fp)
    SYS_ARCH_UNPROTECT(old_level);
 201d34c:	e13ffa17 	ldw	r4,-24(fp)
 201d350:	2014d200 	call	2014d20 <sys_arch_unprotect>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 201d354:	e0bffb03 	ldbu	r2,-20(fp)
 201d358:	10002b1e 	bne	r2,zero,201d408 <pbuf_free+0x114>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 201d35c:	e0bfff17 	ldw	r2,-4(fp)
 201d360:	10800017 	ldw	r2,0(r2)
 201d364:	e0bffc15 	stw	r2,-16(fp)
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      alloc_src = pbuf_get_allocsrc(p);
 201d368:	e0bfff17 	ldw	r2,-4(fp)
 201d36c:	10800303 	ldbu	r2,12(r2)
 201d370:	108003cc 	andi	r2,r2,15
 201d374:	e0bffd05 	stb	r2,-12(fp)
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 201d378:	e0bfff17 	ldw	r2,-4(fp)
 201d37c:	10800343 	ldbu	r2,13(r2)
 201d380:	10803fcc 	andi	r2,r2,255
 201d384:	1080008c 	andi	r2,r2,2
 201d388:	10000726 	beq	r2,zero,201d3a8 <pbuf_free+0xb4>
        struct pbuf_custom *pc = (struct pbuf_custom *)p;
 201d38c:	e0bfff17 	ldw	r2,-4(fp)
 201d390:	e0bffe15 	stw	r2,-8(fp)
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
 201d394:	e0bffe17 	ldw	r2,-8(fp)
 201d398:	10800417 	ldw	r2,16(r2)
 201d39c:	e13fff17 	ldw	r4,-4(fp)
 201d3a0:	103ee83a 	callr	r2
 201d3a4:	00001206 	br	201d3f0 <pbuf_free+0xfc>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
 201d3a8:	e0bffd03 	ldbu	r2,-12(fp)
 201d3ac:	10800098 	cmpnei	r2,r2,2
 201d3b0:	1000041e 	bne	r2,zero,201d3c4 <pbuf_free+0xd0>
          memp_free(MEMP_PBUF_POOL, p);
 201d3b4:	e17fff17 	ldw	r5,-4(fp)
 201d3b8:	01000384 	movi	r4,14
 201d3bc:	201b9640 	call	201b964 <memp_free>
 201d3c0:	00000b06 	br	201d3f0 <pbuf_free+0xfc>
          /* is this a ROM or RAM referencing pbuf? */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
 201d3c4:	e0bffd03 	ldbu	r2,-12(fp)
 201d3c8:	10800058 	cmpnei	r2,r2,1
 201d3cc:	1000041e 	bne	r2,zero,201d3e0 <pbuf_free+0xec>
          memp_free(MEMP_PBUF, p);
 201d3d0:	e17fff17 	ldw	r5,-4(fp)
 201d3d4:	01000344 	movi	r4,13
 201d3d8:	201b9640 	call	201b964 <memp_free>
 201d3dc:	00000406 	br	201d3f0 <pbuf_free+0xfc>
          /* type == PBUF_RAM */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
 201d3e0:	e0bffd03 	ldbu	r2,-12(fp)
 201d3e4:	1000021e 	bne	r2,zero,201d3f0 <pbuf_free+0xfc>
          mem_free(p);
 201d3e8:	e13fff17 	ldw	r4,-4(fp)
 201d3ec:	201acfc0 	call	201acfc <mem_free>
        } else {
          /* @todo: support freeing other types */
          LWIP_ASSERT("invalid pbuf type", 0);
        }
      }
      count++;
 201d3f0:	e0bff903 	ldbu	r2,-28(fp)
 201d3f4:	10800044 	addi	r2,r2,1
 201d3f8:	e0bff905 	stb	r2,-28(fp)
      /* proceed to next pbuf */
      p = q;
 201d3fc:	e0bffc17 	ldw	r2,-16(fp)
 201d400:	e0bfff15 	stw	r2,-4(fp)
 201d404:	00000106 	br	201d40c <pbuf_free+0x118>
      /* p->ref > 0, this pbuf is still referenced to */
      /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, (u16_t)ref));
      /* stop walking through the chain */
      p = NULL;
 201d408:	e03fff15 	stw	zero,-4(fp)
  PERF_START;

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 201d40c:	e0bfff17 	ldw	r2,-4(fp)
 201d410:	103fc31e 	bne	r2,zero,201d320 <__alt_mem_mem_0+0xfcffd320>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 201d414:	e0bff903 	ldbu	r2,-28(fp)
}
 201d418:	e037883a 	mov	sp,fp
 201d41c:	dfc00117 	ldw	ra,4(sp)
 201d420:	df000017 	ldw	fp,0(sp)
 201d424:	dec00204 	addi	sp,sp,8
 201d428:	f800283a 	ret

0201d42c <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 201d42c:	defffd04 	addi	sp,sp,-12
 201d430:	df000215 	stw	fp,8(sp)
 201d434:	df000204 	addi	fp,sp,8
 201d438:	e13fff15 	stw	r4,-4(fp)
  u16_t len;

  len = 0;
 201d43c:	e03ffe0d 	sth	zero,-8(fp)
  while (p != NULL) {
 201d440:	00000606 	br	201d45c <pbuf_clen+0x30>
    ++len;
 201d444:	e0bffe0b 	ldhu	r2,-8(fp)
 201d448:	10800044 	addi	r2,r2,1
 201d44c:	e0bffe0d 	sth	r2,-8(fp)
    p = p->next;
 201d450:	e0bfff17 	ldw	r2,-4(fp)
 201d454:	10800017 	ldw	r2,0(r2)
 201d458:	e0bfff15 	stw	r2,-4(fp)
pbuf_clen(const struct pbuf *p)
{
  u16_t len;

  len = 0;
  while (p != NULL) {
 201d45c:	e0bfff17 	ldw	r2,-4(fp)
 201d460:	103ff81e 	bne	r2,zero,201d444 <__alt_mem_mem_0+0xfcffd444>
    ++len;
    p = p->next;
  }
  return len;
 201d464:	e0bffe0b 	ldhu	r2,-8(fp)
}
 201d468:	e037883a 	mov	sp,fp
 201d46c:	df000017 	ldw	fp,0(sp)
 201d470:	dec00104 	addi	sp,sp,4
 201d474:	f800283a 	ret

0201d478 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 201d478:	defffc04 	addi	sp,sp,-16
 201d47c:	dfc00315 	stw	ra,12(sp)
 201d480:	df000215 	stw	fp,8(sp)
 201d484:	df000204 	addi	fp,sp,8
 201d488:	e13fff15 	stw	r4,-4(fp)
  /* pbuf given? */
  if (p != NULL) {
 201d48c:	e0bfff17 	ldw	r2,-4(fp)
 201d490:	10000a26 	beq	r2,zero,201d4bc <pbuf_ref+0x44>
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
 201d494:	2014cec0 	call	2014cec <sys_arch_protect>
 201d498:	e0bffe15 	stw	r2,-8(fp)
 201d49c:	e0bfff17 	ldw	r2,-4(fp)
 201d4a0:	10800383 	ldbu	r2,14(r2)
 201d4a4:	10800044 	addi	r2,r2,1
 201d4a8:	1007883a 	mov	r3,r2
 201d4ac:	e0bfff17 	ldw	r2,-4(fp)
 201d4b0:	10c00385 	stb	r3,14(r2)
 201d4b4:	e13ffe17 	ldw	r4,-8(fp)
 201d4b8:	2014d200 	call	2014d20 <sys_arch_unprotect>
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
  }
}
 201d4bc:	0001883a 	nop
 201d4c0:	e037883a 	mov	sp,fp
 201d4c4:	dfc00117 	ldw	ra,4(sp)
 201d4c8:	df000017 	ldw	fp,0(sp)
 201d4cc:	dec00204 	addi	sp,sp,8
 201d4d0:	f800283a 	ret

0201d4d4 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 201d4d4:	defffc04 	addi	sp,sp,-16
 201d4d8:	df000315 	stw	fp,12(sp)
 201d4dc:	df000304 	addi	fp,sp,12
 201d4e0:	e13ffe15 	stw	r4,-8(fp)
 201d4e4:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 201d4e8:	e0bffe17 	ldw	r2,-8(fp)
 201d4ec:	10001f26 	beq	r2,zero,201d56c <pbuf_cat+0x98>
 201d4f0:	e0bfff17 	ldw	r2,-4(fp)
 201d4f4:	10001d26 	beq	r2,zero,201d56c <pbuf_cat+0x98>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 201d4f8:	e0bffe17 	ldw	r2,-8(fp)
 201d4fc:	e0bffd15 	stw	r2,-12(fp)
 201d500:	00000b06 	br	201d530 <pbuf_cat+0x5c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 201d504:	e0bffd17 	ldw	r2,-12(fp)
 201d508:	10c0020b 	ldhu	r3,8(r2)
 201d50c:	e0bfff17 	ldw	r2,-4(fp)
 201d510:	1080020b 	ldhu	r2,8(r2)
 201d514:	1885883a 	add	r2,r3,r2
 201d518:	1007883a 	mov	r3,r2
 201d51c:	e0bffd17 	ldw	r2,-12(fp)
 201d520:	10c0020d 	sth	r3,8(r2)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 201d524:	e0bffd17 	ldw	r2,-12(fp)
 201d528:	10800017 	ldw	r2,0(r2)
 201d52c:	e0bffd15 	stw	r2,-12(fp)
 201d530:	e0bffd17 	ldw	r2,-12(fp)
 201d534:	10800017 	ldw	r2,0(r2)
 201d538:	103ff21e 	bne	r2,zero,201d504 <__alt_mem_mem_0+0xfcffd504>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 201d53c:	e0bffd17 	ldw	r2,-12(fp)
 201d540:	10c0020b 	ldhu	r3,8(r2)
 201d544:	e0bfff17 	ldw	r2,-4(fp)
 201d548:	1080020b 	ldhu	r2,8(r2)
 201d54c:	1885883a 	add	r2,r3,r2
 201d550:	1007883a 	mov	r3,r2
 201d554:	e0bffd17 	ldw	r2,-12(fp)
 201d558:	10c0020d 	sth	r3,8(r2)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 201d55c:	e0bffd17 	ldw	r2,-12(fp)
 201d560:	e0ffff17 	ldw	r3,-4(fp)
 201d564:	10c00015 	stw	r3,0(r2)
 201d568:	00000106 	br	201d570 <pbuf_cat+0x9c>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 201d56c:	0001883a 	nop
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 201d570:	e037883a 	mov	sp,fp
 201d574:	df000017 	ldw	fp,0(sp)
 201d578:	dec00104 	addi	sp,sp,4
 201d57c:	f800283a 	ret

0201d580 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 201d580:	defffc04 	addi	sp,sp,-16
 201d584:	dfc00315 	stw	ra,12(sp)
 201d588:	df000215 	stw	fp,8(sp)
 201d58c:	df000204 	addi	fp,sp,8
 201d590:	e13ffe15 	stw	r4,-8(fp)
 201d594:	e17fff15 	stw	r5,-4(fp)
  pbuf_cat(h, t);
 201d598:	e17fff17 	ldw	r5,-4(fp)
 201d59c:	e13ffe17 	ldw	r4,-8(fp)
 201d5a0:	201d4d40 	call	201d4d4 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 201d5a4:	e13fff17 	ldw	r4,-4(fp)
 201d5a8:	201d4780 	call	201d478 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 201d5ac:	0001883a 	nop
 201d5b0:	e037883a 	mov	sp,fp
 201d5b4:	dfc00117 	ldw	ra,4(sp)
 201d5b8:	df000017 	ldw	fp,0(sp)
 201d5bc:	dec00204 	addi	sp,sp,8
 201d5c0:	f800283a 	ret

0201d5c4 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 201d5c4:	defffb04 	addi	sp,sp,-20
 201d5c8:	dfc00415 	stw	ra,16(sp)
 201d5cc:	df000315 	stw	fp,12(sp)
 201d5d0:	df000304 	addi	fp,sp,12
 201d5d4:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q;
  u8_t tail_gone = 1;
 201d5d8:	00800044 	movi	r2,1
 201d5dc:	e0bffd05 	stb	r2,-12(fp)
  /* tail */
  q = p->next;
 201d5e0:	e0bfff17 	ldw	r2,-4(fp)
 201d5e4:	10800017 	ldw	r2,0(r2)
 201d5e8:	e0bffe15 	stw	r2,-8(fp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
 201d5ec:	e0bffe17 	ldw	r2,-8(fp)
 201d5f0:	10001126 	beq	r2,zero,201d638 <pbuf_dechain+0x74>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = (u16_t)(p->tot_len - p->len);
 201d5f4:	e0bfff17 	ldw	r2,-4(fp)
 201d5f8:	10c0020b 	ldhu	r3,8(r2)
 201d5fc:	e0bfff17 	ldw	r2,-4(fp)
 201d600:	1080028b 	ldhu	r2,10(r2)
 201d604:	1885c83a 	sub	r2,r3,r2
 201d608:	1007883a 	mov	r3,r2
 201d60c:	e0bffe17 	ldw	r2,-8(fp)
 201d610:	10c0020d 	sth	r3,8(r2)
    /* decouple pbuf from remainder */
    p->next = NULL;
 201d614:	e0bfff17 	ldw	r2,-4(fp)
 201d618:	10000015 	stw	zero,0(r2)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 201d61c:	e0bfff17 	ldw	r2,-4(fp)
 201d620:	10c0028b 	ldhu	r3,10(r2)
 201d624:	e0bfff17 	ldw	r2,-4(fp)
 201d628:	10c0020d 	sth	r3,8(r2)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 201d62c:	e13ffe17 	ldw	r4,-8(fp)
 201d630:	201d2f40 	call	201d2f4 <pbuf_free>
 201d634:	e0bffd05 	stb	r2,-12(fp)
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
 201d638:	e0bffd03 	ldbu	r2,-12(fp)
 201d63c:	1000021e 	bne	r2,zero,201d648 <pbuf_dechain+0x84>
 201d640:	e0bffe17 	ldw	r2,-8(fp)
 201d644:	00000106 	br	201d64c <pbuf_dechain+0x88>
 201d648:	0005883a 	mov	r2,zero
}
 201d64c:	e037883a 	mov	sp,fp
 201d650:	dfc00117 	ldw	ra,4(sp)
 201d654:	df000017 	ldw	fp,0(sp)
 201d658:	dec00204 	addi	sp,sp,8
 201d65c:	f800283a 	ret

0201d660 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 201d660:	defff904 	addi	sp,sp,-28
 201d664:	dfc00615 	stw	ra,24(sp)
 201d668:	df000515 	stw	fp,20(sp)
 201d66c:	df000504 	addi	fp,sp,20
 201d670:	e13ffe15 	stw	r4,-8(fp)
 201d674:	e17fff15 	stw	r5,-4(fp)
  size_t offset_to = 0, offset_from = 0, len;
 201d678:	e03ffb15 	stw	zero,-20(fp)
 201d67c:	e03ffc15 	stw	zero,-16(fp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
              (const void *)p_to, (const void *)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 201d680:	e0bffe17 	ldw	r2,-8(fp)
 201d684:	10000926 	beq	r2,zero,201d6ac <pbuf_copy+0x4c>
 201d688:	e0bfff17 	ldw	r2,-4(fp)
 201d68c:	10000726 	beq	r2,zero,201d6ac <pbuf_copy+0x4c>
 201d690:	e0bffe17 	ldw	r2,-8(fp)
 201d694:	10c0020b 	ldhu	r3,8(r2)
 201d698:	e0bfff17 	ldw	r2,-4(fp)
 201d69c:	1080020b 	ldhu	r2,8(r2)
 201d6a0:	18ffffcc 	andi	r3,r3,65535
 201d6a4:	10bfffcc 	andi	r2,r2,65535
 201d6a8:	1880022e 	bgeu	r3,r2,201d6b4 <pbuf_copy+0x54>
 201d6ac:	00bffc04 	movi	r2,-16
 201d6b0:	00006206 	br	201d83c <pbuf_copy+0x1dc>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 201d6b4:	e0bffe17 	ldw	r2,-8(fp)
 201d6b8:	1080028b 	ldhu	r2,10(r2)
 201d6bc:	10ffffcc 	andi	r3,r2,65535
 201d6c0:	e0bffb17 	ldw	r2,-20(fp)
 201d6c4:	1887c83a 	sub	r3,r3,r2
 201d6c8:	e0bfff17 	ldw	r2,-4(fp)
 201d6cc:	1080028b 	ldhu	r2,10(r2)
 201d6d0:	113fffcc 	andi	r4,r2,65535
 201d6d4:	e0bffc17 	ldw	r2,-16(fp)
 201d6d8:	2085c83a 	sub	r2,r4,r2
 201d6dc:	18800736 	bltu	r3,r2,201d6fc <pbuf_copy+0x9c>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 201d6e0:	e0bfff17 	ldw	r2,-4(fp)
 201d6e4:	1080028b 	ldhu	r2,10(r2)
 201d6e8:	10ffffcc 	andi	r3,r2,65535
 201d6ec:	e0bffc17 	ldw	r2,-16(fp)
 201d6f0:	1885c83a 	sub	r2,r3,r2
 201d6f4:	e0bffd15 	stw	r2,-12(fp)
 201d6f8:	00000606 	br	201d714 <pbuf_copy+0xb4>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 201d6fc:	e0bffe17 	ldw	r2,-8(fp)
 201d700:	1080028b 	ldhu	r2,10(r2)
 201d704:	10ffffcc 	andi	r3,r2,65535
 201d708:	e0bffb17 	ldw	r2,-20(fp)
 201d70c:	1885c83a 	sub	r2,r3,r2
 201d710:	e0bffd15 	stw	r2,-12(fp)
    }
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
 201d714:	e0bffe17 	ldw	r2,-8(fp)
 201d718:	10c00117 	ldw	r3,4(r2)
 201d71c:	e0bffb17 	ldw	r2,-20(fp)
 201d720:	1889883a 	add	r4,r3,r2
 201d724:	e0bfff17 	ldw	r2,-4(fp)
 201d728:	10c00117 	ldw	r3,4(r2)
 201d72c:	e0bffc17 	ldw	r2,-16(fp)
 201d730:	1885883a 	add	r2,r3,r2
 201d734:	e1bffd17 	ldw	r6,-12(fp)
 201d738:	100b883a 	mov	r5,r2
 201d73c:	2005e580 	call	2005e58 <memcpy>
    offset_to += len;
 201d740:	e0fffb17 	ldw	r3,-20(fp)
 201d744:	e0bffd17 	ldw	r2,-12(fp)
 201d748:	1885883a 	add	r2,r3,r2
 201d74c:	e0bffb15 	stw	r2,-20(fp)
    offset_from += len;
 201d750:	e0fffc17 	ldw	r3,-16(fp)
 201d754:	e0bffd17 	ldw	r2,-12(fp)
 201d758:	1885883a 	add	r2,r3,r2
 201d75c:	e0bffc15 	stw	r2,-16(fp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 201d760:	e0bfff17 	ldw	r2,-4(fp)
 201d764:	1080028b 	ldhu	r2,10(r2)
 201d768:	10bfffcc 	andi	r2,r2,65535
 201d76c:	e0fffc17 	ldw	r3,-16(fp)
 201d770:	18800436 	bltu	r3,r2,201d784 <pbuf_copy+0x124>
      /* on to next p_from (if any) */
      offset_from = 0;
 201d774:	e03ffc15 	stw	zero,-16(fp)
      p_from = p_from->next;
 201d778:	e0bfff17 	ldw	r2,-4(fp)
 201d77c:	10800017 	ldw	r2,0(r2)
 201d780:	e0bfff15 	stw	r2,-4(fp)
    }
    if (offset_to == p_to->len) {
 201d784:	e0bffe17 	ldw	r2,-8(fp)
 201d788:	1080028b 	ldhu	r2,10(r2)
 201d78c:	10ffffcc 	andi	r3,r2,65535
 201d790:	e0bffb17 	ldw	r2,-20(fp)
 201d794:	18800a1e 	bne	r3,r2,201d7c0 <pbuf_copy+0x160>
      /* on to next p_to (if any) */
      offset_to = 0;
 201d798:	e03ffb15 	stw	zero,-20(fp)
      p_to = p_to->next;
 201d79c:	e0bffe17 	ldw	r2,-8(fp)
 201d7a0:	10800017 	ldw	r2,0(r2)
 201d7a4:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
 201d7a8:	e0bffe17 	ldw	r2,-8(fp)
 201d7ac:	1000041e 	bne	r2,zero,201d7c0 <pbuf_copy+0x160>
 201d7b0:	e0bfff17 	ldw	r2,-4(fp)
 201d7b4:	10000226 	beq	r2,zero,201d7c0 <pbuf_copy+0x160>
 201d7b8:	00bffc04 	movi	r2,-16
 201d7bc:	00001f06 	br	201d83c <pbuf_copy+0x1dc>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 201d7c0:	e0bfff17 	ldw	r2,-4(fp)
 201d7c4:	10000c26 	beq	r2,zero,201d7f8 <pbuf_copy+0x198>
 201d7c8:	e0bfff17 	ldw	r2,-4(fp)
 201d7cc:	10c0028b 	ldhu	r3,10(r2)
 201d7d0:	e0bfff17 	ldw	r2,-4(fp)
 201d7d4:	1080020b 	ldhu	r2,8(r2)
 201d7d8:	18ffffcc 	andi	r3,r3,65535
 201d7dc:	10bfffcc 	andi	r2,r2,65535
 201d7e0:	1880051e 	bne	r3,r2,201d7f8 <pbuf_copy+0x198>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 201d7e4:	e0bfff17 	ldw	r2,-4(fp)
 201d7e8:	10800017 	ldw	r2,0(r2)
 201d7ec:	10000226 	beq	r2,zero,201d7f8 <pbuf_copy+0x198>
 201d7f0:	00bffe84 	movi	r2,-6
 201d7f4:	00001106 	br	201d83c <pbuf_copy+0x1dc>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 201d7f8:	e0bffe17 	ldw	r2,-8(fp)
 201d7fc:	10000c26 	beq	r2,zero,201d830 <pbuf_copy+0x1d0>
 201d800:	e0bffe17 	ldw	r2,-8(fp)
 201d804:	10c0028b 	ldhu	r3,10(r2)
 201d808:	e0bffe17 	ldw	r2,-8(fp)
 201d80c:	1080020b 	ldhu	r2,8(r2)
 201d810:	18ffffcc 	andi	r3,r3,65535
 201d814:	10bfffcc 	andi	r2,r2,65535
 201d818:	1880051e 	bne	r3,r2,201d830 <pbuf_copy+0x1d0>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 201d81c:	e0bffe17 	ldw	r2,-8(fp)
 201d820:	10800017 	ldw	r2,0(r2)
 201d824:	10000226 	beq	r2,zero,201d830 <pbuf_copy+0x1d0>
 201d828:	00bffe84 	movi	r2,-6
 201d82c:	00000306 	br	201d83c <pbuf_copy+0x1dc>
                 (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 201d830:	e0bfff17 	ldw	r2,-4(fp)
 201d834:	103f9f1e 	bne	r2,zero,201d6b4 <__alt_mem_mem_0+0xfcffd6b4>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 201d838:	0005883a 	mov	r2,zero
}
 201d83c:	e037883a 	mov	sp,fp
 201d840:	dfc00117 	ldw	ra,4(sp)
 201d844:	df000017 	ldw	fp,0(sp)
 201d848:	dec00204 	addi	sp,sp,8
 201d84c:	f800283a 	ret

0201d850 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 201d850:	defff704 	addi	sp,sp,-36
 201d854:	dfc00815 	stw	ra,32(sp)
 201d858:	df000715 	stw	fp,28(sp)
 201d85c:	df000704 	addi	fp,sp,28
 201d860:	e13ffc15 	stw	r4,-16(fp)
 201d864:	e17ffd15 	stw	r5,-12(fp)
 201d868:	3007883a 	mov	r3,r6
 201d86c:	3805883a 	mov	r2,r7
 201d870:	e0fffe0d 	sth	r3,-8(fp)
 201d874:	e0bfff0d 	sth	r2,-4(fp)
  const struct pbuf *p;
  u16_t left = 0;
 201d878:	e03ffa0d 	sth	zero,-24(fp)
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 201d87c:	e03ffb0d 	sth	zero,-20(fp)

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 201d880:	e0bffc17 	ldw	r2,-16(fp)
 201d884:	1000021e 	bne	r2,zero,201d890 <pbuf_copy_partial+0x40>
 201d888:	0005883a 	mov	r2,zero
 201d88c:	00003e06 	br	201d988 <pbuf_copy_partial+0x138>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 201d890:	e0bffd17 	ldw	r2,-12(fp)
 201d894:	1000021e 	bne	r2,zero,201d8a0 <pbuf_copy_partial+0x50>
 201d898:	0005883a 	mov	r2,zero
 201d89c:	00003a06 	br	201d988 <pbuf_copy_partial+0x138>

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 201d8a0:	e0bffc17 	ldw	r2,-16(fp)
 201d8a4:	e0bff915 	stw	r2,-28(fp)
 201d8a8:	00003206 	br	201d974 <pbuf_copy_partial+0x124>
    if ((offset != 0) && (offset >= p->len)) {
 201d8ac:	e0bfff0b 	ldhu	r2,-4(fp)
 201d8b0:	10000b26 	beq	r2,zero,201d8e0 <pbuf_copy_partial+0x90>
 201d8b4:	e0bff917 	ldw	r2,-28(fp)
 201d8b8:	1080028b 	ldhu	r2,10(r2)
 201d8bc:	10bfffcc 	andi	r2,r2,65535
 201d8c0:	e0ffff0b 	ldhu	r3,-4(fp)
 201d8c4:	18800636 	bltu	r3,r2,201d8e0 <pbuf_copy_partial+0x90>
      /* don't copy from this buffer -> on to the next */
      offset = (u16_t)(offset - p->len);
 201d8c8:	e0bff917 	ldw	r2,-28(fp)
 201d8cc:	1080028b 	ldhu	r2,10(r2)
 201d8d0:	e0ffff0b 	ldhu	r3,-4(fp)
 201d8d4:	1885c83a 	sub	r2,r3,r2
 201d8d8:	e0bfff0d 	sth	r2,-4(fp)
 201d8dc:	00002206 	br	201d968 <pbuf_copy_partial+0x118>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = (u16_t)(p->len - offset);
 201d8e0:	e0bff917 	ldw	r2,-28(fp)
 201d8e4:	10c0028b 	ldhu	r3,10(r2)
 201d8e8:	e0bfff0b 	ldhu	r2,-4(fp)
 201d8ec:	1885c83a 	sub	r2,r3,r2
 201d8f0:	e0bffa8d 	sth	r2,-22(fp)
      if (buf_copy_len > len) {
 201d8f4:	e0bffa8b 	ldhu	r2,-22(fp)
 201d8f8:	e0fffe0b 	ldhu	r3,-8(fp)
 201d8fc:	1880022e 	bgeu	r3,r2,201d908 <pbuf_copy_partial+0xb8>
        buf_copy_len = len;
 201d900:	e0bffe0b 	ldhu	r2,-8(fp)
 201d904:	e0bffa8d 	sth	r2,-22(fp)
      }
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
 201d908:	e0bffa0b 	ldhu	r2,-24(fp)
 201d90c:	e0fffd17 	ldw	r3,-12(fp)
 201d910:	1889883a 	add	r4,r3,r2
 201d914:	e0bff917 	ldw	r2,-28(fp)
 201d918:	10c00117 	ldw	r3,4(r2)
 201d91c:	e0bfff0b 	ldhu	r2,-4(fp)
 201d920:	1885883a 	add	r2,r3,r2
 201d924:	e0fffa8b 	ldhu	r3,-22(fp)
 201d928:	180d883a 	mov	r6,r3
 201d92c:	100b883a 	mov	r5,r2
 201d930:	2005e580 	call	2005e58 <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
 201d934:	e0fffb0b 	ldhu	r3,-20(fp)
 201d938:	e0bffa8b 	ldhu	r2,-22(fp)
 201d93c:	1885883a 	add	r2,r3,r2
 201d940:	e0bffb0d 	sth	r2,-20(fp)
      left = (u16_t)(left + buf_copy_len);
 201d944:	e0fffa0b 	ldhu	r3,-24(fp)
 201d948:	e0bffa8b 	ldhu	r2,-22(fp)
 201d94c:	1885883a 	add	r2,r3,r2
 201d950:	e0bffa0d 	sth	r2,-24(fp)
      len = (u16_t)(len - buf_copy_len);
 201d954:	e0fffe0b 	ldhu	r3,-8(fp)
 201d958:	e0bffa8b 	ldhu	r2,-22(fp)
 201d95c:	1885c83a 	sub	r2,r3,r2
 201d960:	e0bffe0d 	sth	r2,-8(fp)
      offset = 0;
 201d964:	e03fff0d 	sth	zero,-4(fp)

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 201d968:	e0bff917 	ldw	r2,-28(fp)
 201d96c:	10800017 	ldw	r2,0(r2)
 201d970:	e0bff915 	stw	r2,-28(fp)
 201d974:	e0bffe0b 	ldhu	r2,-8(fp)
 201d978:	10000226 	beq	r2,zero,201d984 <pbuf_copy_partial+0x134>
 201d97c:	e0bff917 	ldw	r2,-28(fp)
 201d980:	103fca1e 	bne	r2,zero,201d8ac <__alt_mem_mem_0+0xfcffd8ac>
      left = (u16_t)(left + buf_copy_len);
      len = (u16_t)(len - buf_copy_len);
      offset = 0;
    }
  }
  return copied_total;
 201d984:	e0bffb0b 	ldhu	r2,-20(fp)
}
 201d988:	e037883a 	mov	sp,fp
 201d98c:	dfc00117 	ldw	ra,4(sp)
 201d990:	df000017 	ldw	fp,0(sp)
 201d994:	dec00204 	addi	sp,sp,8
 201d998:	f800283a 	ret

0201d99c <pbuf_get_contiguous>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
void *
pbuf_get_contiguous(const struct pbuf *p, void *buffer, size_t bufsize, u16_t len, u16_t offset)
{
 201d99c:	defff704 	addi	sp,sp,-36
 201d9a0:	dfc00815 	stw	ra,32(sp)
 201d9a4:	df000715 	stw	fp,28(sp)
 201d9a8:	df000704 	addi	fp,sp,28
 201d9ac:	e13ffb15 	stw	r4,-20(fp)
 201d9b0:	e17ffc15 	stw	r5,-16(fp)
 201d9b4:	e1bffd15 	stw	r6,-12(fp)
 201d9b8:	3807883a 	mov	r3,r7
 201d9bc:	e0800217 	ldw	r2,8(fp)
 201d9c0:	e0fffe0d 	sth	r3,-8(fp)
 201d9c4:	e0bfff0d 	sth	r2,-4(fp)
  const struct pbuf *q;
  u16_t out_offset;

  LWIP_ERROR("pbuf_get_contiguous: invalid buf", (p != NULL), return NULL;);
 201d9c8:	e0bffb17 	ldw	r2,-20(fp)
 201d9cc:	1000021e 	bne	r2,zero,201d9d8 <pbuf_get_contiguous+0x3c>
 201d9d0:	0005883a 	mov	r2,zero
 201d9d4:	00003006 	br	201da98 <pbuf_get_contiguous+0xfc>
  LWIP_ERROR("pbuf_get_contiguous: invalid dataptr", (buffer != NULL), return NULL;);
 201d9d8:	e0bffc17 	ldw	r2,-16(fp)
 201d9dc:	1000021e 	bne	r2,zero,201d9e8 <pbuf_get_contiguous+0x4c>
 201d9e0:	0005883a 	mov	r2,zero
 201d9e4:	00002c06 	br	201da98 <pbuf_get_contiguous+0xfc>
  LWIP_ERROR("pbuf_get_contiguous: invalid dataptr", (bufsize >= len), return NULL;);
 201d9e8:	e0bffe0b 	ldhu	r2,-8(fp)
 201d9ec:	e0fffd17 	ldw	r3,-12(fp)
 201d9f0:	1880022e 	bgeu	r3,r2,201d9fc <pbuf_get_contiguous+0x60>
 201d9f4:	0005883a 	mov	r2,zero
 201d9f8:	00002706 	br	201da98 <pbuf_get_contiguous+0xfc>

  q = pbuf_skip_const(p, offset, &out_offset);
 201d9fc:	e0bfff0b 	ldhu	r2,-4(fp)
 201da00:	e0fffa04 	addi	r3,fp,-24
 201da04:	180d883a 	mov	r6,r3
 201da08:	100b883a 	mov	r5,r2
 201da0c:	e13ffb17 	ldw	r4,-20(fp)
 201da10:	201daac0 	call	201daac <pbuf_skip_const>
 201da14:	e0bff915 	stw	r2,-28(fp)
  if (q != NULL) {
 201da18:	e0bff917 	ldw	r2,-28(fp)
 201da1c:	10001d26 	beq	r2,zero,201da94 <pbuf_get_contiguous+0xf8>
    if (q->len >= (out_offset + len)) {
 201da20:	e0bff917 	ldw	r2,-28(fp)
 201da24:	1080028b 	ldhu	r2,10(r2)
 201da28:	10ffffcc 	andi	r3,r2,65535
 201da2c:	e0bffa0b 	ldhu	r2,-24(fp)
 201da30:	113fffcc 	andi	r4,r2,65535
 201da34:	e0bffe0b 	ldhu	r2,-8(fp)
 201da38:	2085883a 	add	r2,r4,r2
 201da3c:	18800616 	blt	r3,r2,201da58 <pbuf_get_contiguous+0xbc>
      /* all data in this pbuf, return zero-copy */
      return (u8_t *)q->payload + out_offset;
 201da40:	e0bff917 	ldw	r2,-28(fp)
 201da44:	10c00117 	ldw	r3,4(r2)
 201da48:	e0bffa0b 	ldhu	r2,-24(fp)
 201da4c:	10bfffcc 	andi	r2,r2,65535
 201da50:	1885883a 	add	r2,r3,r2
 201da54:	00001006 	br	201da98 <pbuf_get_contiguous+0xfc>
    }
    /* need to copy */
    if (pbuf_copy_partial(q, buffer, len, out_offset) != len) {
 201da58:	e0bffe0b 	ldhu	r2,-8(fp)
 201da5c:	e0fffa0b 	ldhu	r3,-24(fp)
 201da60:	18ffffcc 	andi	r3,r3,65535
 201da64:	180f883a 	mov	r7,r3
 201da68:	100d883a 	mov	r6,r2
 201da6c:	e17ffc17 	ldw	r5,-16(fp)
 201da70:	e13ff917 	ldw	r4,-28(fp)
 201da74:	201d8500 	call	201d850 <pbuf_copy_partial>
 201da78:	10ffffcc 	andi	r3,r2,65535
 201da7c:	e0bffe0b 	ldhu	r2,-8(fp)
 201da80:	18800226 	beq	r3,r2,201da8c <pbuf_get_contiguous+0xf0>
      /* copying failed: pbuf is too short */
      return NULL;
 201da84:	0005883a 	mov	r2,zero
 201da88:	00000306 	br	201da98 <pbuf_get_contiguous+0xfc>
    }
    return buffer;
 201da8c:	e0bffc17 	ldw	r2,-16(fp)
 201da90:	00000106 	br	201da98 <pbuf_get_contiguous+0xfc>
  }
  /* pbuf is too short (offset does not fit in) */
  return NULL;
 201da94:	0005883a 	mov	r2,zero
}
 201da98:	e037883a 	mov	sp,fp
 201da9c:	dfc00117 	ldw	ra,4(sp)
 201daa0:	df000017 	ldw	fp,0(sp)
 201daa4:	dec00204 	addi	sp,sp,8
 201daa8:	f800283a 	ret

0201daac <pbuf_skip_const>:
#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

/* Actual implementation of pbuf_skip() but returning const pointer... */
static const struct pbuf *
pbuf_skip_const(const struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 201daac:	defffa04 	addi	sp,sp,-24
 201dab0:	df000515 	stw	fp,20(sp)
 201dab4:	df000504 	addi	fp,sp,20
 201dab8:	e13ffd15 	stw	r4,-12(fp)
 201dabc:	2805883a 	mov	r2,r5
 201dac0:	e1bfff15 	stw	r6,-4(fp)
 201dac4:	e0bffe0d 	sth	r2,-8(fp)
  u16_t offset_left = in_offset;
 201dac8:	e0bffe0b 	ldhu	r2,-8(fp)
 201dacc:	e0bffb0d 	sth	r2,-20(fp)
  const struct pbuf *q = in;
 201dad0:	e0bffd17 	ldw	r2,-12(fp)
 201dad4:	e0bffc15 	stw	r2,-16(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 201dad8:	00000806 	br	201dafc <pbuf_skip_const+0x50>
    offset_left = (u16_t)(offset_left - q->len);
 201dadc:	e0bffc17 	ldw	r2,-16(fp)
 201dae0:	1080028b 	ldhu	r2,10(r2)
 201dae4:	e0fffb0b 	ldhu	r3,-20(fp)
 201dae8:	1885c83a 	sub	r2,r3,r2
 201daec:	e0bffb0d 	sth	r2,-20(fp)
    q = q->next;
 201daf0:	e0bffc17 	ldw	r2,-16(fp)
 201daf4:	10800017 	ldw	r2,0(r2)
 201daf8:	e0bffc15 	stw	r2,-16(fp)
{
  u16_t offset_left = in_offset;
  const struct pbuf *q = in;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 201dafc:	e0bffc17 	ldw	r2,-16(fp)
 201db00:	10000526 	beq	r2,zero,201db18 <pbuf_skip_const+0x6c>
 201db04:	e0bffc17 	ldw	r2,-16(fp)
 201db08:	1080028b 	ldhu	r2,10(r2)
 201db0c:	10bfffcc 	andi	r2,r2,65535
 201db10:	e0fffb0b 	ldhu	r3,-20(fp)
 201db14:	18bff12e 	bgeu	r3,r2,201dadc <__alt_mem_mem_0+0xfcffdadc>
    offset_left = (u16_t)(offset_left - q->len);
    q = q->next;
  }
  if (out_offset != NULL) {
 201db18:	e0bfff17 	ldw	r2,-4(fp)
 201db1c:	10000326 	beq	r2,zero,201db2c <pbuf_skip_const+0x80>
    *out_offset = offset_left;
 201db20:	e0bfff17 	ldw	r2,-4(fp)
 201db24:	e0fffb0b 	ldhu	r3,-20(fp)
 201db28:	10c0000d 	sth	r3,0(r2)
  }
  return q;
 201db2c:	e0bffc17 	ldw	r2,-16(fp)
}
 201db30:	e037883a 	mov	sp,fp
 201db34:	df000017 	ldw	fp,0(sp)
 201db38:	dec00104 	addi	sp,sp,4
 201db3c:	f800283a 	ret

0201db40 <pbuf_skip>:
 * @param out_offset resulting offset in the returned pbuf
 * @return the pbuf in the queue where the offset is
 */
struct pbuf *
pbuf_skip(struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 201db40:	defffa04 	addi	sp,sp,-24
 201db44:	dfc00515 	stw	ra,20(sp)
 201db48:	df000415 	stw	fp,16(sp)
 201db4c:	df000404 	addi	fp,sp,16
 201db50:	e13ffd15 	stw	r4,-12(fp)
 201db54:	2805883a 	mov	r2,r5
 201db58:	e1bfff15 	stw	r6,-4(fp)
 201db5c:	e0bffe0d 	sth	r2,-8(fp)
  const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
 201db60:	e0bffe0b 	ldhu	r2,-8(fp)
 201db64:	e1bfff17 	ldw	r6,-4(fp)
 201db68:	100b883a 	mov	r5,r2
 201db6c:	e13ffd17 	ldw	r4,-12(fp)
 201db70:	201daac0 	call	201daac <pbuf_skip_const>
 201db74:	e0bffc15 	stw	r2,-16(fp)
  return LWIP_CONST_CAST(struct pbuf *, out);
 201db78:	e0bffc17 	ldw	r2,-16(fp)
}
 201db7c:	e037883a 	mov	sp,fp
 201db80:	dfc00117 	ldw	ra,4(sp)
 201db84:	df000017 	ldw	fp,0(sp)
 201db88:	dec00204 	addi	sp,sp,8
 201db8c:	f800283a 	ret

0201db90 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 201db90:	defff704 	addi	sp,sp,-36
 201db94:	dfc00815 	stw	ra,32(sp)
 201db98:	df000715 	stw	fp,28(sp)
 201db9c:	df000704 	addi	fp,sp,28
 201dba0:	e13ffd15 	stw	r4,-12(fp)
 201dba4:	e17ffe15 	stw	r5,-8(fp)
 201dba8:	3005883a 	mov	r2,r6
 201dbac:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  size_t buf_copy_len;
  size_t total_copy_len = len;
 201dbb0:	e0bfff0b 	ldhu	r2,-4(fp)
 201dbb4:	e0bffb15 	stw	r2,-20(fp)
  size_t copied_total = 0;
 201dbb8:	e03ffc15 	stw	zero,-16(fp)

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 201dbbc:	e0bffd17 	ldw	r2,-12(fp)
 201dbc0:	1000021e 	bne	r2,zero,201dbcc <pbuf_take+0x3c>
 201dbc4:	00bffc04 	movi	r2,-16
 201dbc8:	00003a06 	br	201dcb4 <pbuf_take+0x124>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 201dbcc:	e0bffe17 	ldw	r2,-8(fp)
 201dbd0:	1000021e 	bne	r2,zero,201dbdc <pbuf_take+0x4c>
 201dbd4:	00bffc04 	movi	r2,-16
 201dbd8:	00003606 	br	201dcb4 <pbuf_take+0x124>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 201dbdc:	e0bffd17 	ldw	r2,-12(fp)
 201dbe0:	1080020b 	ldhu	r2,8(r2)
 201dbe4:	10ffffcc 	andi	r3,r2,65535
 201dbe8:	e0bfff0b 	ldhu	r2,-4(fp)
 201dbec:	1880022e 	bgeu	r3,r2,201dbf8 <pbuf_take+0x68>
 201dbf0:	00bfffc4 	movi	r2,-1
 201dbf4:	00002f06 	br	201dcb4 <pbuf_take+0x124>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 201dbf8:	e0bffd17 	ldw	r2,-12(fp)
 201dbfc:	10000726 	beq	r2,zero,201dc1c <pbuf_take+0x8c>
 201dc00:	e0bffe17 	ldw	r2,-8(fp)
 201dc04:	10000526 	beq	r2,zero,201dc1c <pbuf_take+0x8c>
 201dc08:	e0bffd17 	ldw	r2,-12(fp)
 201dc0c:	1080020b 	ldhu	r2,8(r2)
 201dc10:	10ffffcc 	andi	r3,r2,65535
 201dc14:	e0bfff0b 	ldhu	r2,-4(fp)
 201dc18:	1880022e 	bgeu	r3,r2,201dc24 <pbuf_take+0x94>
    return ERR_ARG;
 201dc1c:	00bffc04 	movi	r2,-16
 201dc20:	00002406 	br	201dcb4 <pbuf_take+0x124>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
 201dc24:	e0bffd17 	ldw	r2,-12(fp)
 201dc28:	e0bff915 	stw	r2,-28(fp)
 201dc2c:	00001e06 	br	201dca8 <pbuf_take+0x118>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    buf_copy_len = total_copy_len;
 201dc30:	e0bffb17 	ldw	r2,-20(fp)
 201dc34:	e0bffa15 	stw	r2,-24(fp)
    if (buf_copy_len > p->len) {
 201dc38:	e0bff917 	ldw	r2,-28(fp)
 201dc3c:	1080028b 	ldhu	r2,10(r2)
 201dc40:	10ffffcc 	andi	r3,r2,65535
 201dc44:	e0bffa17 	ldw	r2,-24(fp)
 201dc48:	1880042e 	bgeu	r3,r2,201dc5c <pbuf_take+0xcc>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 201dc4c:	e0bff917 	ldw	r2,-28(fp)
 201dc50:	1080028b 	ldhu	r2,10(r2)
 201dc54:	10bfffcc 	andi	r2,r2,65535
 201dc58:	e0bffa15 	stw	r2,-24(fp)
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
 201dc5c:	e0bff917 	ldw	r2,-28(fp)
 201dc60:	11000117 	ldw	r4,4(r2)
 201dc64:	e0fffe17 	ldw	r3,-8(fp)
 201dc68:	e0bffc17 	ldw	r2,-16(fp)
 201dc6c:	1885883a 	add	r2,r3,r2
 201dc70:	e1bffa17 	ldw	r6,-24(fp)
 201dc74:	100b883a 	mov	r5,r2
 201dc78:	2005e580 	call	2005e58 <memcpy>
    total_copy_len -= buf_copy_len;
 201dc7c:	e0fffb17 	ldw	r3,-20(fp)
 201dc80:	e0bffa17 	ldw	r2,-24(fp)
 201dc84:	1885c83a 	sub	r2,r3,r2
 201dc88:	e0bffb15 	stw	r2,-20(fp)
    copied_total += buf_copy_len;
 201dc8c:	e0fffc17 	ldw	r3,-16(fp)
 201dc90:	e0bffa17 	ldw	r2,-24(fp)
 201dc94:	1885883a 	add	r2,r3,r2
 201dc98:	e0bffc15 	stw	r2,-16(fp)
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
 201dc9c:	e0bff917 	ldw	r2,-28(fp)
 201dca0:	10800017 	ldw	r2,0(r2)
 201dca4:	e0bff915 	stw	r2,-28(fp)
 201dca8:	e0bffb17 	ldw	r2,-20(fp)
 201dcac:	103fe01e 	bne	r2,zero,201dc30 <__alt_mem_mem_0+0xfcffdc30>
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
 201dcb0:	0005883a 	mov	r2,zero
}
 201dcb4:	e037883a 	mov	sp,fp
 201dcb8:	dfc00117 	ldw	ra,4(sp)
 201dcbc:	df000017 	ldw	fp,0(sp)
 201dcc0:	dec00204 	addi	sp,sp,8
 201dcc4:	f800283a 	ret

0201dcc8 <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
 201dcc8:	defff604 	addi	sp,sp,-40
 201dccc:	dfc00915 	stw	ra,36(sp)
 201dcd0:	df000815 	stw	fp,32(sp)
 201dcd4:	df000804 	addi	fp,sp,32
 201dcd8:	e13ffc15 	stw	r4,-16(fp)
 201dcdc:	e17ffd15 	stw	r5,-12(fp)
 201dce0:	3007883a 	mov	r3,r6
 201dce4:	3805883a 	mov	r2,r7
 201dce8:	e0fffe0d 	sth	r3,-8(fp)
 201dcec:	e0bfff0d 	sth	r2,-4(fp)
  u16_t target_offset;
  struct pbuf *q = pbuf_skip(buf, offset, &target_offset);
 201dcf0:	e0bfff0b 	ldhu	r2,-4(fp)
 201dcf4:	e0fffb84 	addi	r3,fp,-18
 201dcf8:	180d883a 	mov	r6,r3
 201dcfc:	100b883a 	mov	r5,r2
 201dd00:	e13ffc17 	ldw	r4,-16(fp)
 201dd04:	201db400 	call	201db40 <pbuf_skip>
 201dd08:	e0bff815 	stw	r2,-32(fp)

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
 201dd0c:	e0bff817 	ldw	r2,-32(fp)
 201dd10:	10003926 	beq	r2,zero,201ddf8 <pbuf_take_at+0x130>
 201dd14:	e0bff817 	ldw	r2,-32(fp)
 201dd18:	1080020b 	ldhu	r2,8(r2)
 201dd1c:	10ffffcc 	andi	r3,r2,65535
 201dd20:	e0bffb8b 	ldhu	r2,-18(fp)
 201dd24:	113fffcc 	andi	r4,r2,65535
 201dd28:	e0bffe0b 	ldhu	r2,-8(fp)
 201dd2c:	2085883a 	add	r2,r4,r2
 201dd30:	18803116 	blt	r3,r2,201ddf8 <pbuf_take_at+0x130>
    u16_t remaining_len = len;
 201dd34:	e0bffe0b 	ldhu	r2,-8(fp)
 201dd38:	e0bff90d 	sth	r2,-28(fp)
    const u8_t *src_ptr = (const u8_t *)dataptr;
 201dd3c:	e0bffd17 	ldw	r2,-12(fp)
 201dd40:	e0bffa15 	stw	r2,-24(fp)
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len;
    LWIP_ASSERT("check pbuf_skip result", target_offset < q->len);
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
 201dd44:	e0bff817 	ldw	r2,-32(fp)
 201dd48:	1080028b 	ldhu	r2,10(r2)
 201dd4c:	10ffffcc 	andi	r3,r2,65535
 201dd50:	e0bffb8b 	ldhu	r2,-18(fp)
 201dd54:	10bfffcc 	andi	r2,r2,65535
 201dd58:	1887c83a 	sub	r3,r3,r2
 201dd5c:	e0bffe0b 	ldhu	r2,-8(fp)
 201dd60:	1880050e 	bge	r3,r2,201dd78 <pbuf_take_at+0xb0>
 201dd64:	e0bff817 	ldw	r2,-32(fp)
 201dd68:	10c0028b 	ldhu	r3,10(r2)
 201dd6c:	e0bffb8b 	ldhu	r2,-18(fp)
 201dd70:	1885c83a 	sub	r2,r3,r2
 201dd74:	00000106 	br	201dd7c <pbuf_take_at+0xb4>
 201dd78:	e0bffe0b 	ldhu	r2,-8(fp)
 201dd7c:	e0bffb0d 	sth	r2,-20(fp)
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
 201dd80:	e0bff817 	ldw	r2,-32(fp)
 201dd84:	10c00117 	ldw	r3,4(r2)
 201dd88:	e0bffb8b 	ldhu	r2,-18(fp)
 201dd8c:	10bfffcc 	andi	r2,r2,65535
 201dd90:	1885883a 	add	r2,r3,r2
 201dd94:	e0fffb0b 	ldhu	r3,-20(fp)
 201dd98:	180d883a 	mov	r6,r3
 201dd9c:	e17ffd17 	ldw	r5,-12(fp)
 201dda0:	1009883a 	mov	r4,r2
 201dda4:	2005e580 	call	2005e58 <memcpy>
    remaining_len = (u16_t)(remaining_len - first_copy_len);
 201dda8:	e0fff90b 	ldhu	r3,-28(fp)
 201ddac:	e0bffb0b 	ldhu	r2,-20(fp)
 201ddb0:	1885c83a 	sub	r2,r3,r2
 201ddb4:	e0bff90d 	sth	r2,-28(fp)
    src_ptr += first_copy_len;
 201ddb8:	e0bffb0b 	ldhu	r2,-20(fp)
 201ddbc:	e0fffa17 	ldw	r3,-24(fp)
 201ddc0:	1885883a 	add	r2,r3,r2
 201ddc4:	e0bffa15 	stw	r2,-24(fp)
    if (remaining_len > 0) {
 201ddc8:	e0bff90b 	ldhu	r2,-28(fp)
 201ddcc:	10000826 	beq	r2,zero,201ddf0 <pbuf_take_at+0x128>
      return pbuf_take(q->next, src_ptr, remaining_len);
 201ddd0:	e0bff817 	ldw	r2,-32(fp)
 201ddd4:	10800017 	ldw	r2,0(r2)
 201ddd8:	e0fff90b 	ldhu	r3,-28(fp)
 201dddc:	180d883a 	mov	r6,r3
 201dde0:	e17ffa17 	ldw	r5,-24(fp)
 201dde4:	1009883a 	mov	r4,r2
 201dde8:	201db900 	call	201db90 <pbuf_take>
 201ddec:	00000306 	br	201ddfc <pbuf_take_at+0x134>
    }
    return ERR_OK;
 201ddf0:	0005883a 	mov	r2,zero
 201ddf4:	00000106 	br	201ddfc <pbuf_take_at+0x134>
  }
  return ERR_MEM;
 201ddf8:	00bfffc4 	movi	r2,-1
}
 201ddfc:	e037883a 	mov	sp,fp
 201de00:	dfc00117 	ldw	ra,4(sp)
 201de04:	df000017 	ldw	fp,0(sp)
 201de08:	dec00204 	addi	sp,sp,8
 201de0c:	f800283a 	ret

0201de10 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf *
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 201de10:	defffb04 	addi	sp,sp,-20
 201de14:	dfc00415 	stw	ra,16(sp)
 201de18:	df000315 	stw	fp,12(sp)
 201de1c:	df000304 	addi	fp,sp,12
 201de20:	e13ffe15 	stw	r4,-8(fp)
 201de24:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *q;
  if (p->next == NULL) {
 201de28:	e0bffe17 	ldw	r2,-8(fp)
 201de2c:	10800017 	ldw	r2,0(r2)
 201de30:	1000021e 	bne	r2,zero,201de3c <pbuf_coalesce+0x2c>
    return p;
 201de34:	e0bffe17 	ldw	r2,-8(fp)
 201de38:	00000c06 	br	201de6c <pbuf_coalesce+0x5c>
  }
  q = pbuf_clone(layer, PBUF_RAM, p);
 201de3c:	e1bffe17 	ldw	r6,-8(fp)
 201de40:	0140a004 	movi	r5,640
 201de44:	e13fff17 	ldw	r4,-4(fp)
 201de48:	201de800 	call	201de80 <pbuf_clone>
 201de4c:	e0bffd15 	stw	r2,-12(fp)
  if (q == NULL) {
 201de50:	e0bffd17 	ldw	r2,-12(fp)
 201de54:	1000021e 	bne	r2,zero,201de60 <pbuf_coalesce+0x50>
    /* @todo: what do we do now? */
    return p;
 201de58:	e0bffe17 	ldw	r2,-8(fp)
 201de5c:	00000306 	br	201de6c <pbuf_coalesce+0x5c>
  }
  pbuf_free(p);
 201de60:	e13ffe17 	ldw	r4,-8(fp)
 201de64:	201d2f40 	call	201d2f4 <pbuf_free>
  return q;
 201de68:	e0bffd17 	ldw	r2,-12(fp)
}
 201de6c:	e037883a 	mov	sp,fp
 201de70:	dfc00117 	ldw	ra,4(sp)
 201de74:	df000017 	ldw	fp,0(sp)
 201de78:	dec00204 	addi	sp,sp,8
 201de7c:	f800283a 	ret

0201de80 <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
 201de80:	defff904 	addi	sp,sp,-28
 201de84:	dfc00615 	stw	ra,24(sp)
 201de88:	df000515 	stw	fp,20(sp)
 201de8c:	df000504 	addi	fp,sp,20
 201de90:	e13ffd15 	stw	r4,-12(fp)
 201de94:	e17ffe15 	stw	r5,-8(fp)
 201de98:	e1bfff15 	stw	r6,-4(fp)
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
 201de9c:	e0bfff17 	ldw	r2,-4(fp)
 201dea0:	1080020b 	ldhu	r2,8(r2)
 201dea4:	10bfffcc 	andi	r2,r2,65535
 201dea8:	e1bffe17 	ldw	r6,-8(fp)
 201deac:	100b883a 	mov	r5,r2
 201deb0:	e13ffd17 	ldw	r4,-12(fp)
 201deb4:	201c9740 	call	201c974 <pbuf_alloc>
 201deb8:	e0bffb15 	stw	r2,-20(fp)
  if (q == NULL) {
 201debc:	e0bffb17 	ldw	r2,-20(fp)
 201dec0:	1000021e 	bne	r2,zero,201decc <pbuf_clone+0x4c>
    return NULL;
 201dec4:	0005883a 	mov	r2,zero
 201dec8:	00000506 	br	201dee0 <pbuf_clone+0x60>
  }
  err = pbuf_copy(q, p);
 201decc:	e17fff17 	ldw	r5,-4(fp)
 201ded0:	e13ffb17 	ldw	r4,-20(fp)
 201ded4:	201d6600 	call	201d660 <pbuf_copy>
 201ded8:	e0bffc05 	stb	r2,-16(fp)
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
  return q;
 201dedc:	e0bffb17 	ldw	r2,-20(fp)
}
 201dee0:	e037883a 	mov	sp,fp
 201dee4:	dfc00117 	ldw	ra,4(sp)
 201dee8:	df000017 	ldw	fp,0(sp)
 201deec:	dec00204 	addi	sp,sp,8
 201def0:	f800283a 	ret

0201def4 <pbuf_fill_chksum>:
 *         within the (first) pbuf (no pbuf queues!)
 */
err_t
pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
                 u16_t len, u16_t *chksum)
{
 201def4:	defff704 	addi	sp,sp,-36
 201def8:	dfc00815 	stw	ra,32(sp)
 201defc:	df000715 	stw	fp,28(sp)
 201df00:	df000704 	addi	fp,sp,28
 201df04:	e13ffc15 	stw	r4,-16(fp)
 201df08:	2807883a 	mov	r3,r5
 201df0c:	e1bffe15 	stw	r6,-8(fp)
 201df10:	3805883a 	mov	r2,r7
 201df14:	e0fffd0d 	sth	r3,-12(fp)
 201df18:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("dataptr != NULL", dataptr != NULL);
  LWIP_ASSERT("chksum != NULL", chksum != NULL);
  LWIP_ASSERT("len != 0", len != 0);

  if ((start_offset >= p->len) || (start_offset + len > p->len)) {
 201df1c:	e0bffc17 	ldw	r2,-16(fp)
 201df20:	1080028b 	ldhu	r2,10(r2)
 201df24:	10bfffcc 	andi	r2,r2,65535
 201df28:	e0fffd0b 	ldhu	r3,-12(fp)
 201df2c:	1880072e 	bgeu	r3,r2,201df4c <pbuf_fill_chksum+0x58>
 201df30:	e0fffd0b 	ldhu	r3,-12(fp)
 201df34:	e0bfff0b 	ldhu	r2,-4(fp)
 201df38:	1885883a 	add	r2,r3,r2
 201df3c:	e0fffc17 	ldw	r3,-16(fp)
 201df40:	18c0028b 	ldhu	r3,10(r3)
 201df44:	18ffffcc 	andi	r3,r3,65535
 201df48:	1880020e 	bge	r3,r2,201df54 <pbuf_fill_chksum+0x60>
    return ERR_ARG;
 201df4c:	00bffc04 	movi	r2,-16
 201df50:	00002606 	br	201dfec <pbuf_fill_chksum+0xf8>
  }

  dst_ptr = ((char *)p->payload) + start_offset;
 201df54:	e0bffc17 	ldw	r2,-16(fp)
 201df58:	10c00117 	ldw	r3,4(r2)
 201df5c:	e0bffd0b 	ldhu	r2,-12(fp)
 201df60:	1885883a 	add	r2,r3,r2
 201df64:	e0bffa15 	stw	r2,-24(fp)
  copy_chksum = LWIP_CHKSUM_COPY(dst_ptr, dataptr, len);
 201df68:	e0bfff0b 	ldhu	r2,-4(fp)
 201df6c:	100d883a 	mov	r6,r2
 201df70:	e17ffe17 	ldw	r5,-8(fp)
 201df74:	e13ffa17 	ldw	r4,-24(fp)
 201df78:	203a3140 	call	203a314 <lwip_chksum_copy>
 201df7c:	e0bff90d 	sth	r2,-28(fp)
  if ((start_offset & 1) != 0) {
 201df80:	e0bffd0b 	ldhu	r2,-12(fp)
 201df84:	1080004c 	andi	r2,r2,1
 201df88:	10000726 	beq	r2,zero,201dfa8 <pbuf_fill_chksum+0xb4>
    copy_chksum = SWAP_BYTES_IN_WORD(copy_chksum);
 201df8c:	e0bff90b 	ldhu	r2,-28(fp)
 201df90:	1004923a 	slli	r2,r2,8
 201df94:	1007883a 	mov	r3,r2
 201df98:	e0bff90b 	ldhu	r2,-28(fp)
 201df9c:	1004d23a 	srli	r2,r2,8
 201dfa0:	1884b03a 	or	r2,r3,r2
 201dfa4:	e0bff90d 	sth	r2,-28(fp)
  }
  acc = *chksum;
 201dfa8:	e0800217 	ldw	r2,8(fp)
 201dfac:	1080000b 	ldhu	r2,0(r2)
 201dfb0:	10bfffcc 	andi	r2,r2,65535
 201dfb4:	e0bffb15 	stw	r2,-20(fp)
  acc += copy_chksum;
 201dfb8:	e0bff90b 	ldhu	r2,-28(fp)
 201dfbc:	e0fffb17 	ldw	r3,-20(fp)
 201dfc0:	1885883a 	add	r2,r3,r2
 201dfc4:	e0bffb15 	stw	r2,-20(fp)
  *chksum = FOLD_U32T(acc);
 201dfc8:	e0bffb17 	ldw	r2,-20(fp)
 201dfcc:	1004d43a 	srli	r2,r2,16
 201dfd0:	1007883a 	mov	r3,r2
 201dfd4:	e0bffb17 	ldw	r2,-20(fp)
 201dfd8:	1885883a 	add	r2,r3,r2
 201dfdc:	1007883a 	mov	r3,r2
 201dfe0:	e0800217 	ldw	r2,8(fp)
 201dfe4:	10c0000d 	sth	r3,0(r2)
  return ERR_OK;
 201dfe8:	0005883a 	mov	r2,zero
}
 201dfec:	e037883a 	mov	sp,fp
 201dff0:	dfc00117 	ldw	ra,4(sp)
 201dff4:	df000017 	ldw	fp,0(sp)
 201dff8:	dec00204 	addi	sp,sp,8
 201dffc:	f800283a 	ret

0201e000 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(const struct pbuf *p, u16_t offset)
{
 201e000:	defffb04 	addi	sp,sp,-20
 201e004:	dfc00415 	stw	ra,16(sp)
 201e008:	df000315 	stw	fp,12(sp)
 201e00c:	df000304 	addi	fp,sp,12
 201e010:	e13ffe15 	stw	r4,-8(fp)
 201e014:	2805883a 	mov	r2,r5
 201e018:	e0bfff0d 	sth	r2,-4(fp)
  int ret = pbuf_try_get_at(p, offset);
 201e01c:	e0bfff0b 	ldhu	r2,-4(fp)
 201e020:	100b883a 	mov	r5,r2
 201e024:	e13ffe17 	ldw	r4,-8(fp)
 201e028:	201e0580 	call	201e058 <pbuf_try_get_at>
 201e02c:	e0bffd15 	stw	r2,-12(fp)
  if (ret >= 0) {
 201e030:	e0bffd17 	ldw	r2,-12(fp)
 201e034:	10000216 	blt	r2,zero,201e040 <pbuf_get_at+0x40>
    return (u8_t)ret;
 201e038:	e0bffd17 	ldw	r2,-12(fp)
 201e03c:	00000106 	br	201e044 <pbuf_get_at+0x44>
  }
  return 0;
 201e040:	0005883a 	mov	r2,zero
}
 201e044:	e037883a 	mov	sp,fp
 201e048:	dfc00117 	ldw	ra,4(sp)
 201e04c:	df000017 	ldw	fp,0(sp)
 201e050:	dec00204 	addi	sp,sp,8
 201e054:	f800283a 	ret

0201e058 <pbuf_try_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p [0..0xFF] OR negative if 'offset' >= p->tot_len
 */
int
pbuf_try_get_at(const struct pbuf *p, u16_t offset)
{
 201e058:	defffa04 	addi	sp,sp,-24
 201e05c:	dfc00515 	stw	ra,20(sp)
 201e060:	df000415 	stw	fp,16(sp)
 201e064:	df000404 	addi	fp,sp,16
 201e068:	e13ffe15 	stw	r4,-8(fp)
 201e06c:	2805883a 	mov	r2,r5
 201e070:	e0bfff0d 	sth	r2,-4(fp)
  u16_t q_idx;
  const struct pbuf *q = pbuf_skip_const(p, offset, &q_idx);
 201e074:	e0bfff0b 	ldhu	r2,-4(fp)
 201e078:	e0fffd04 	addi	r3,fp,-12
 201e07c:	180d883a 	mov	r6,r3
 201e080:	100b883a 	mov	r5,r2
 201e084:	e13ffe17 	ldw	r4,-8(fp)
 201e088:	201daac0 	call	201daac <pbuf_skip_const>
 201e08c:	e0bffc15 	stw	r2,-16(fp)

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 201e090:	e0bffc17 	ldw	r2,-16(fp)
 201e094:	10000e26 	beq	r2,zero,201e0d0 <pbuf_try_get_at+0x78>
 201e098:	e0bffc17 	ldw	r2,-16(fp)
 201e09c:	1080028b 	ldhu	r2,10(r2)
 201e0a0:	e0fffd0b 	ldhu	r3,-12(fp)
 201e0a4:	10bfffcc 	andi	r2,r2,65535
 201e0a8:	18ffffcc 	andi	r3,r3,65535
 201e0ac:	1880082e 	bgeu	r3,r2,201e0d0 <pbuf_try_get_at+0x78>
    return ((u8_t *)q->payload)[q_idx];
 201e0b0:	e0bffc17 	ldw	r2,-16(fp)
 201e0b4:	10c00117 	ldw	r3,4(r2)
 201e0b8:	e0bffd0b 	ldhu	r2,-12(fp)
 201e0bc:	10bfffcc 	andi	r2,r2,65535
 201e0c0:	1885883a 	add	r2,r3,r2
 201e0c4:	10800003 	ldbu	r2,0(r2)
 201e0c8:	10803fcc 	andi	r2,r2,255
 201e0cc:	00000106 	br	201e0d4 <pbuf_try_get_at+0x7c>
  }
  return -1;
 201e0d0:	00bfffc4 	movi	r2,-1
}
 201e0d4:	e037883a 	mov	sp,fp
 201e0d8:	dfc00117 	ldw	ra,4(sp)
 201e0dc:	df000017 	ldw	fp,0(sp)
 201e0e0:	dec00204 	addi	sp,sp,8
 201e0e4:	f800283a 	ret

0201e0e8 <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
{
 201e0e8:	defff904 	addi	sp,sp,-28
 201e0ec:	dfc00615 	stw	ra,24(sp)
 201e0f0:	df000515 	stw	fp,20(sp)
 201e0f4:	df000504 	addi	fp,sp,20
 201e0f8:	e13ffd15 	stw	r4,-12(fp)
 201e0fc:	2807883a 	mov	r3,r5
 201e100:	3005883a 	mov	r2,r6
 201e104:	e0fffe0d 	sth	r3,-8(fp)
 201e108:	e0bfff05 	stb	r2,-4(fp)
  u16_t q_idx;
  struct pbuf *q = pbuf_skip(p, offset, &q_idx);
 201e10c:	e0bffe0b 	ldhu	r2,-8(fp)
 201e110:	e0fffc04 	addi	r3,fp,-16
 201e114:	180d883a 	mov	r6,r3
 201e118:	100b883a 	mov	r5,r2
 201e11c:	e13ffd17 	ldw	r4,-12(fp)
 201e120:	201db400 	call	201db40 <pbuf_skip>
 201e124:	e0bffb15 	stw	r2,-20(fp)

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 201e128:	e0bffb17 	ldw	r2,-20(fp)
 201e12c:	10000d26 	beq	r2,zero,201e164 <pbuf_put_at+0x7c>
 201e130:	e0bffb17 	ldw	r2,-20(fp)
 201e134:	1080028b 	ldhu	r2,10(r2)
 201e138:	e0fffc0b 	ldhu	r3,-16(fp)
 201e13c:	10bfffcc 	andi	r2,r2,65535
 201e140:	18ffffcc 	andi	r3,r3,65535
 201e144:	1880072e 	bgeu	r3,r2,201e164 <pbuf_put_at+0x7c>
    ((u8_t *)q->payload)[q_idx] = data;
 201e148:	e0bffb17 	ldw	r2,-20(fp)
 201e14c:	10c00117 	ldw	r3,4(r2)
 201e150:	e0bffc0b 	ldhu	r2,-16(fp)
 201e154:	10bfffcc 	andi	r2,r2,65535
 201e158:	1885883a 	add	r2,r3,r2
 201e15c:	e0ffff03 	ldbu	r3,-4(fp)
 201e160:	10c00005 	stb	r3,0(r2)
  }
}
 201e164:	0001883a 	nop
 201e168:	e037883a 	mov	sp,fp
 201e16c:	dfc00117 	ldw	ra,4(sp)
 201e170:	df000017 	ldw	fp,0(sp)
 201e174:	dec00204 	addi	sp,sp,8
 201e178:	f800283a 	ret

0201e17c <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(const struct pbuf *p, u16_t offset, const void *s2, u16_t n)
{
 201e17c:	defff704 	addi	sp,sp,-36
 201e180:	dfc00815 	stw	ra,32(sp)
 201e184:	df000715 	stw	fp,28(sp)
 201e188:	df000704 	addi	fp,sp,28
 201e18c:	e13ffc15 	stw	r4,-16(fp)
 201e190:	2807883a 	mov	r3,r5
 201e194:	e1bffe15 	stw	r6,-8(fp)
 201e198:	3805883a 	mov	r2,r7
 201e19c:	e0fffd0d 	sth	r3,-12(fp)
 201e1a0:	e0bfff0d 	sth	r2,-4(fp)
  u16_t start = offset;
 201e1a4:	e0bffd0b 	ldhu	r2,-12(fp)
 201e1a8:	e0bff90d 	sth	r2,-28(fp)
  const struct pbuf *q = p;
 201e1ac:	e0bffc17 	ldw	r2,-16(fp)
 201e1b0:	e0bffa15 	stw	r2,-24(fp)
  u16_t i;

  /* pbuf long enough to perform check? */
  if (p->tot_len < (offset + n)) {
 201e1b4:	e0bffc17 	ldw	r2,-16(fp)
 201e1b8:	1080020b 	ldhu	r2,8(r2)
 201e1bc:	10ffffcc 	andi	r3,r2,65535
 201e1c0:	e13ffd0b 	ldhu	r4,-12(fp)
 201e1c4:	e0bfff0b 	ldhu	r2,-4(fp)
 201e1c8:	2085883a 	add	r2,r4,r2
 201e1cc:	18800a0e 	bge	r3,r2,201e1f8 <pbuf_memcmp+0x7c>
    return 0xffff;
 201e1d0:	00bfffc4 	movi	r2,-1
 201e1d4:	00003106 	br	201e29c <pbuf_memcmp+0x120>
  }

  /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
  while ((q != NULL) && (q->len <= start)) {
    start = (u16_t)(start - q->len);
 201e1d8:	e0bffa17 	ldw	r2,-24(fp)
 201e1dc:	1080028b 	ldhu	r2,10(r2)
 201e1e0:	e0fff90b 	ldhu	r3,-28(fp)
 201e1e4:	1885c83a 	sub	r2,r3,r2
 201e1e8:	e0bff90d 	sth	r2,-28(fp)
    q = q->next;
 201e1ec:	e0bffa17 	ldw	r2,-24(fp)
 201e1f0:	10800017 	ldw	r2,0(r2)
 201e1f4:	e0bffa15 	stw	r2,-24(fp)
  if (p->tot_len < (offset + n)) {
    return 0xffff;
  }

  /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
  while ((q != NULL) && (q->len <= start)) {
 201e1f8:	e0bffa17 	ldw	r2,-24(fp)
 201e1fc:	10000526 	beq	r2,zero,201e214 <pbuf_memcmp+0x98>
 201e200:	e0bffa17 	ldw	r2,-24(fp)
 201e204:	1080028b 	ldhu	r2,10(r2)
 201e208:	10bfffcc 	andi	r2,r2,65535
 201e20c:	e0fff90b 	ldhu	r3,-28(fp)
 201e210:	18bff12e 	bgeu	r3,r2,201e1d8 <__alt_mem_mem_0+0xfcffe1d8>
    start = (u16_t)(start - q->len);
    q = q->next;
  }

  /* return requested data if pbuf is OK */
  for (i = 0; i < n; i++) {
 201e214:	e03ffb0d 	sth	zero,-20(fp)
 201e218:	00001c06 	br	201e28c <pbuf_memcmp+0x110>
    /* We know pbuf_get_at() succeeds because of p->tot_len check above. */
    u8_t a = pbuf_get_at(q, (u16_t)(start + i));
 201e21c:	e0fff90b 	ldhu	r3,-28(fp)
 201e220:	e0bffb0b 	ldhu	r2,-20(fp)
 201e224:	1885883a 	add	r2,r3,r2
 201e228:	10bfffcc 	andi	r2,r2,65535
 201e22c:	100b883a 	mov	r5,r2
 201e230:	e13ffa17 	ldw	r4,-24(fp)
 201e234:	201e0000 	call	201e000 <pbuf_get_at>
 201e238:	e0bffb85 	stb	r2,-18(fp)
    u8_t b = ((const u8_t *)s2)[i];
 201e23c:	e0bffb0b 	ldhu	r2,-20(fp)
 201e240:	e0fffe17 	ldw	r3,-8(fp)
 201e244:	1885883a 	add	r2,r3,r2
 201e248:	10800003 	ldbu	r2,0(r2)
 201e24c:	e0bffbc5 	stb	r2,-17(fp)
    if (a != b) {
 201e250:	e0fffb83 	ldbu	r3,-18(fp)
 201e254:	e0bffbc3 	ldbu	r2,-17(fp)
 201e258:	18800926 	beq	r3,r2,201e280 <pbuf_memcmp+0x104>
      return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
 201e25c:	e0bffb0b 	ldhu	r2,-20(fp)
 201e260:	10800044 	addi	r2,r2,1
 201e264:	00ffff94 	movui	r3,65534
 201e268:	18800316 	blt	r3,r2,201e278 <pbuf_memcmp+0xfc>
 201e26c:	e0bffb0b 	ldhu	r2,-20(fp)
 201e270:	10800044 	addi	r2,r2,1
 201e274:	00000906 	br	201e29c <pbuf_memcmp+0x120>
 201e278:	00bfffc4 	movi	r2,-1
 201e27c:	00000706 	br	201e29c <pbuf_memcmp+0x120>
    start = (u16_t)(start - q->len);
    q = q->next;
  }

  /* return requested data if pbuf is OK */
  for (i = 0; i < n; i++) {
 201e280:	e0bffb0b 	ldhu	r2,-20(fp)
 201e284:	10800044 	addi	r2,r2,1
 201e288:	e0bffb0d 	sth	r2,-20(fp)
 201e28c:	e0fffb0b 	ldhu	r3,-20(fp)
 201e290:	e0bfff0b 	ldhu	r2,-4(fp)
 201e294:	18bfe136 	bltu	r3,r2,201e21c <__alt_mem_mem_0+0xfcffe21c>
    u8_t b = ((const u8_t *)s2)[i];
    if (a != b) {
      return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
    }
  }
  return 0;
 201e298:	0005883a 	mov	r2,zero
}
 201e29c:	e037883a 	mov	sp,fp
 201e2a0:	dfc00117 	ldw	ra,4(sp)
 201e2a4:	df000017 	ldw	fp,0(sp)
 201e2a8:	dec00204 	addi	sp,sp,8
 201e2ac:	f800283a 	ret

0201e2b0 <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(const struct pbuf *p, const void *mem, u16_t mem_len, u16_t start_offset)
{
 201e2b0:	defff804 	addi	sp,sp,-32
 201e2b4:	dfc00715 	stw	ra,28(sp)
 201e2b8:	df000615 	stw	fp,24(sp)
 201e2bc:	df000604 	addi	fp,sp,24
 201e2c0:	e13ffc15 	stw	r4,-16(fp)
 201e2c4:	e17ffd15 	stw	r5,-12(fp)
 201e2c8:	3007883a 	mov	r3,r6
 201e2cc:	3805883a 	mov	r2,r7
 201e2d0:	e0fffe0d 	sth	r3,-8(fp)
 201e2d4:	e0bfff0d 	sth	r2,-4(fp)
  u16_t i;
  u16_t max_cmp_start = (u16_t)(p->tot_len - mem_len);
 201e2d8:	e0bffc17 	ldw	r2,-16(fp)
 201e2dc:	10c0020b 	ldhu	r3,8(r2)
 201e2e0:	e0bffe0b 	ldhu	r2,-8(fp)
 201e2e4:	1885c83a 	sub	r2,r3,r2
 201e2e8:	e0bffa8d 	sth	r2,-22(fp)
  if (p->tot_len >= mem_len + start_offset) {
 201e2ec:	e0bffc17 	ldw	r2,-16(fp)
 201e2f0:	1080020b 	ldhu	r2,8(r2)
 201e2f4:	10ffffcc 	andi	r3,r2,65535
 201e2f8:	e13ffe0b 	ldhu	r4,-8(fp)
 201e2fc:	e0bfff0b 	ldhu	r2,-4(fp)
 201e300:	2085883a 	add	r2,r4,r2
 201e304:	18801516 	blt	r3,r2,201e35c <pbuf_memfind+0xac>
    for (i = start_offset; i <= max_cmp_start; i++) {
 201e308:	e0bfff0b 	ldhu	r2,-4(fp)
 201e30c:	e0bffa0d 	sth	r2,-24(fp)
 201e310:	00000f06 	br	201e350 <pbuf_memfind+0xa0>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 201e314:	e0bffa0b 	ldhu	r2,-24(fp)
 201e318:	e0fffe0b 	ldhu	r3,-8(fp)
 201e31c:	180f883a 	mov	r7,r3
 201e320:	e1bffd17 	ldw	r6,-12(fp)
 201e324:	100b883a 	mov	r5,r2
 201e328:	e13ffc17 	ldw	r4,-16(fp)
 201e32c:	201e17c0 	call	201e17c <pbuf_memcmp>
 201e330:	e0bffb0d 	sth	r2,-20(fp)
      if (plus == 0) {
 201e334:	e0bffb0b 	ldhu	r2,-20(fp)
 201e338:	1000021e 	bne	r2,zero,201e344 <pbuf_memfind+0x94>
        return i;
 201e33c:	e0bffa0b 	ldhu	r2,-24(fp)
 201e340:	00000706 	br	201e360 <pbuf_memfind+0xb0>
pbuf_memfind(const struct pbuf *p, const void *mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max_cmp_start = (u16_t)(p->tot_len - mem_len);
  if (p->tot_len >= mem_len + start_offset) {
    for (i = start_offset; i <= max_cmp_start; i++) {
 201e344:	e0bffa0b 	ldhu	r2,-24(fp)
 201e348:	10800044 	addi	r2,r2,1
 201e34c:	e0bffa0d 	sth	r2,-24(fp)
 201e350:	e0bffa0b 	ldhu	r2,-24(fp)
 201e354:	e0fffa8b 	ldhu	r3,-22(fp)
 201e358:	18bfee2e 	bgeu	r3,r2,201e314 <__alt_mem_mem_0+0xfcffe314>
      if (plus == 0) {
        return i;
      }
    }
  }
  return 0xFFFF;
 201e35c:	00bfffc4 	movi	r2,-1
}
 201e360:	e037883a 	mov	sp,fp
 201e364:	dfc00117 	ldw	ra,4(sp)
 201e368:	df000017 	ldw	fp,0(sp)
 201e36c:	dec00204 	addi	sp,sp,8
 201e370:	f800283a 	ret

0201e374 <pbuf_strstr>:
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(const struct pbuf *p, const char *substr)
{
 201e374:	defffb04 	addi	sp,sp,-20
 201e378:	dfc00415 	stw	ra,16(sp)
 201e37c:	df000315 	stw	fp,12(sp)
 201e380:	df000304 	addi	fp,sp,12
 201e384:	e13ffe15 	stw	r4,-8(fp)
 201e388:	e17fff15 	stw	r5,-4(fp)
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
 201e38c:	e0bfff17 	ldw	r2,-4(fp)
 201e390:	10000b26 	beq	r2,zero,201e3c0 <pbuf_strstr+0x4c>
 201e394:	e0bfff17 	ldw	r2,-4(fp)
 201e398:	10800003 	ldbu	r2,0(r2)
 201e39c:	10803fcc 	andi	r2,r2,255
 201e3a0:	1080201c 	xori	r2,r2,128
 201e3a4:	10bfe004 	addi	r2,r2,-128
 201e3a8:	10000526 	beq	r2,zero,201e3c0 <pbuf_strstr+0x4c>
 201e3ac:	e0bffe17 	ldw	r2,-8(fp)
 201e3b0:	1080020b 	ldhu	r2,8(r2)
 201e3b4:	10ffffcc 	andi	r3,r2,65535
 201e3b8:	00bfffd4 	movui	r2,65535
 201e3bc:	1880021e 	bne	r3,r2,201e3c8 <pbuf_strstr+0x54>
    return 0xFFFF;
 201e3c0:	00bfffc4 	movi	r2,-1
 201e3c4:	00000f06 	br	201e404 <pbuf_strstr+0x90>
  }
  substr_len = strlen(substr);
 201e3c8:	e13fff17 	ldw	r4,-4(fp)
 201e3cc:	20073a40 	call	20073a4 <strlen>
 201e3d0:	e0bffd15 	stw	r2,-12(fp)
  if (substr_len >= 0xFFFF) {
 201e3d4:	e0bffd17 	ldw	r2,-12(fp)
 201e3d8:	10bffff0 	cmpltui	r2,r2,65535
 201e3dc:	1000021e 	bne	r2,zero,201e3e8 <pbuf_strstr+0x74>
    return 0xFFFF;
 201e3e0:	00bfffc4 	movi	r2,-1
 201e3e4:	00000706 	br	201e404 <pbuf_strstr+0x90>
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
 201e3e8:	e0bffd17 	ldw	r2,-12(fp)
 201e3ec:	10bfffcc 	andi	r2,r2,65535
 201e3f0:	000f883a 	mov	r7,zero
 201e3f4:	100d883a 	mov	r6,r2
 201e3f8:	e17fff17 	ldw	r5,-4(fp)
 201e3fc:	e13ffe17 	ldw	r4,-8(fp)
 201e400:	201e2b00 	call	201e2b0 <pbuf_memfind>
}
 201e404:	e037883a 	mov	sp,fp
 201e408:	dfc00117 	ldw	ra,4(sp)
 201e40c:	df000017 	ldw	fp,0(sp)
 201e410:	dec00204 	addi	sp,sp,8
 201e414:	f800283a 	ret

0201e418 <raw_input_local_match>:
/** The list of RAW PCBs */
static struct raw_pcb *raw_pcbs;

static u8_t
raw_input_local_match(struct raw_pcb *pcb, u8_t broadcast)
{
 201e418:	defffd04 	addi	sp,sp,-12
 201e41c:	df000215 	stw	fp,8(sp)
 201e420:	df000204 	addi	fp,sp,8
 201e424:	e13ffe15 	stw	r4,-8(fp)
 201e428:	2805883a 	mov	r2,r5
 201e42c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 201e430:	e0bffe17 	ldw	r2,-8(fp)
 201e434:	10800203 	ldbu	r2,8(r2)
 201e438:	10803fcc 	andi	r2,r2,255
 201e43c:	10000c26 	beq	r2,zero,201e470 <raw_input_local_match+0x58>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 201e440:	e0bffe17 	ldw	r2,-8(fp)
 201e444:	10c00203 	ldbu	r3,8(r2)
 201e448:	008085f4 	movhi	r2,535
 201e44c:	10be4204 	addi	r2,r2,-1784
 201e450:	10800117 	ldw	r2,4(r2)
 201e454:	10801003 	ldbu	r2,64(r2)
 201e458:	10800044 	addi	r2,r2,1
raw_input_local_match(struct raw_pcb *pcb, u8_t broadcast)
{
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 201e45c:	18c03fcc 	andi	r3,r3,255
 201e460:	10803fcc 	andi	r2,r2,255
 201e464:	18800226 	beq	r3,r2,201e470 <raw_input_local_match+0x58>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
    return 0;
 201e468:	0005883a 	mov	r2,zero
 201e46c:	00001706 	br	201e4cc <raw_input_local_match+0xb4>
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: receive all broadcasts
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 201e470:	e0bfff03 	ldbu	r2,-4(fp)
 201e474:	10000726 	beq	r2,zero,201e494 <raw_input_local_match+0x7c>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip))) {
 201e478:	e0bffe17 	ldw	r2,-8(fp)
 201e47c:	10000326 	beq	r2,zero,201e48c <raw_input_local_match+0x74>
 201e480:	e0bffe17 	ldw	r2,-8(fp)
 201e484:	10800017 	ldw	r2,0(r2)
 201e488:	10000f1e 	bne	r2,zero,201e4c8 <raw_input_local_match+0xb0>
          return 1;
 201e48c:	00800044 	movi	r2,1
 201e490:	00000e06 	br	201e4cc <raw_input_local_match+0xb4>
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: catch all or exact match */
      if (ip_addr_isany(&pcb->local_ip) ||
 201e494:	e0bffe17 	ldw	r2,-8(fp)
 201e498:	10000926 	beq	r2,zero,201e4c0 <raw_input_local_match+0xa8>
 201e49c:	e0bffe17 	ldw	r2,-8(fp)
 201e4a0:	10800017 	ldw	r2,0(r2)
 201e4a4:	10000626 	beq	r2,zero,201e4c0 <raw_input_local_match+0xa8>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 201e4a8:	e0bffe17 	ldw	r2,-8(fp)
 201e4ac:	10c00017 	ldw	r3,0(r2)
 201e4b0:	008085f4 	movhi	r2,535
 201e4b4:	10be4204 	addi	r2,r2,-1784
 201e4b8:	10800517 	ldw	r2,20(r2)
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: catch all or exact match */
      if (ip_addr_isany(&pcb->local_ip) ||
 201e4bc:	1880021e 	bne	r3,r2,201e4c8 <raw_input_local_match+0xb0>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
        return 1;
 201e4c0:	00800044 	movi	r2,1
 201e4c4:	00000106 	br	201e4cc <raw_input_local_match+0xb4>
      }
  }

  return 0;
 201e4c8:	0005883a 	mov	r2,zero
}
 201e4cc:	e037883a 	mov	sp,fp
 201e4d0:	df000017 	ldw	fp,0(sp)
 201e4d4:	dec00104 	addi	sp,sp,4
 201e4d8:	f800283a 	ret

0201e4dc <raw_input>:
 *           caller).
 *
 */
raw_input_state_t
raw_input(struct pbuf *p, struct netif *inp)
{
 201e4dc:	defff704 	addi	sp,sp,-36
 201e4e0:	dfc00815 	stw	ra,32(sp)
 201e4e4:	df000715 	stw	fp,28(sp)
 201e4e8:	df000704 	addi	fp,sp,28
 201e4ec:	e13ffe15 	stw	r4,-8(fp)
 201e4f0:	e17fff15 	stw	r5,-4(fp)
  struct raw_pcb *pcb, *prev;
  s16_t proto;
  raw_input_state_t ret = RAW_INPUT_NONE;
 201e4f4:	e03ffb15 	stw	zero,-20(fp)
  u8_t broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 201e4f8:	008085f4 	movhi	r2,535
 201e4fc:	10be4204 	addi	r2,r2,-1784
 201e500:	10c00517 	ldw	r3,20(r2)
 201e504:	008085f4 	movhi	r2,535
 201e508:	10be4204 	addi	r2,r2,-1784
 201e50c:	10800017 	ldw	r2,0(r2)
 201e510:	100b883a 	mov	r5,r2
 201e514:	1809883a 	mov	r4,r3
 201e518:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
 201e51c:	e0bffc05 	stb	r2,-16(fp)
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    proto = IPH_PROTO((struct ip_hdr *)p->payload);
 201e520:	e0bffe17 	ldw	r2,-8(fp)
 201e524:	10800117 	ldw	r2,4(r2)
 201e528:	10800243 	ldbu	r2,9(r2)
 201e52c:	10803fcc 	andi	r2,r2,255
 201e530:	e0bffc8d 	sth	r2,-14(fp)
  }
#endif /* LWIP_IPV4 */

  prev = NULL;
 201e534:	e03ffa15 	stw	zero,-24(fp)
  pcb = raw_pcbs;
 201e538:	d0a7df17 	ldw	r2,-24708(gp)
 201e53c:	e0bff915 	stw	r2,-28(fp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while (pcb != NULL) {
 201e540:	00003b06 	br	201e630 <raw_input+0x154>
    if ((pcb->protocol == proto) && raw_input_local_match(pcb, broadcast) &&
 201e544:	e0bff917 	ldw	r2,-28(fp)
 201e548:	10800503 	ldbu	r2,20(r2)
 201e54c:	10c03fcc 	andi	r3,r2,255
 201e550:	e0bffc8f 	ldh	r2,-14(fp)
 201e554:	1880311e 	bne	r3,r2,201e61c <raw_input+0x140>
 201e558:	e0bffc03 	ldbu	r2,-16(fp)
 201e55c:	100b883a 	mov	r5,r2
 201e560:	e13ff917 	ldw	r4,-28(fp)
 201e564:	201e4180 	call	201e418 <raw_input_local_match>
 201e568:	10803fcc 	andi	r2,r2,255
 201e56c:	10002b26 	beq	r2,zero,201e61c <raw_input+0x140>
        (((pcb->flags & RAW_FLAGS_CONNECTED) == 0) ||
 201e570:	e0bff917 	ldw	r2,-28(fp)
 201e574:	10800543 	ldbu	r2,21(r2)
 201e578:	10803fcc 	andi	r2,r2,255
 201e57c:	1080004c 	andi	r2,r2,1
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while (pcb != NULL) {
    if ((pcb->protocol == proto) && raw_input_local_match(pcb, broadcast) &&
 201e580:	10000626 	beq	r2,zero,201e59c <raw_input+0xc0>
        (((pcb->flags & RAW_FLAGS_CONNECTED) == 0) ||
         ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 201e584:	e0bff917 	ldw	r2,-28(fp)
 201e588:	10c00117 	ldw	r3,4(r2)
 201e58c:	008085f4 	movhi	r2,535
 201e590:	10be4204 	addi	r2,r2,-1784
 201e594:	10800417 	ldw	r2,16(r2)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while (pcb != NULL) {
    if ((pcb->protocol == proto) && raw_input_local_match(pcb, broadcast) &&
        (((pcb->flags & RAW_FLAGS_CONNECTED) == 0) ||
 201e598:	1880201e 	bne	r3,r2,201e61c <raw_input+0x140>
         ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
      /* receive callback function available? */
      if (pcb->recv != NULL) {
 201e59c:	e0bff917 	ldw	r2,-28(fp)
 201e5a0:	10800617 	ldw	r2,24(r2)
 201e5a4:	10001d26 	beq	r2,zero,201e61c <raw_input+0x140>
        u8_t eaten;
#ifndef LWIP_NOASSERT
        void *old_payload = p->payload;
#endif
        ret = RAW_INPUT_DELIVERED;
 201e5a8:	00800084 	movi	r2,2
 201e5ac:	e0bffb15 	stw	r2,-20(fp)
        /* the receive callback function did not eat the packet? */
        eaten = pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr());
 201e5b0:	e0bff917 	ldw	r2,-28(fp)
 201e5b4:	10800617 	ldw	r2,24(r2)
 201e5b8:	e0fff917 	ldw	r3,-28(fp)
 201e5bc:	18c00717 	ldw	r3,28(r3)
 201e5c0:	01c085f4 	movhi	r7,535
 201e5c4:	39fe4604 	addi	r7,r7,-1768
 201e5c8:	e1bffe17 	ldw	r6,-8(fp)
 201e5cc:	e17ff917 	ldw	r5,-28(fp)
 201e5d0:	1809883a 	mov	r4,r3
 201e5d4:	103ee83a 	callr	r2
 201e5d8:	e0bffd05 	stb	r2,-12(fp)
        if (eaten != 0) {
 201e5dc:	e0bffd03 	ldbu	r2,-12(fp)
 201e5e0:	10000e26 	beq	r2,zero,201e61c <raw_input+0x140>
          /* receive function ate the packet */
          p = NULL;
 201e5e4:	e03ffe15 	stw	zero,-8(fp)
          if (prev != NULL) {
 201e5e8:	e0bffa17 	ldw	r2,-24(fp)
 201e5ec:	10000926 	beq	r2,zero,201e614 <raw_input+0x138>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
            prev->next = pcb->next;
 201e5f0:	e0bff917 	ldw	r2,-28(fp)
 201e5f4:	10c00417 	ldw	r3,16(r2)
 201e5f8:	e0bffa17 	ldw	r2,-24(fp)
 201e5fc:	10c00415 	stw	r3,16(r2)
            pcb->next = raw_pcbs;
 201e600:	d0e7df17 	ldw	r3,-24708(gp)
 201e604:	e0bff917 	ldw	r2,-28(fp)
 201e608:	10c00415 	stw	r3,16(r2)
            raw_pcbs = pcb;
 201e60c:	e0bff917 	ldw	r2,-28(fp)
 201e610:	d0a7df15 	stw	r2,-24708(gp)
          }
          return RAW_INPUT_EATEN;
 201e614:	00800044 	movi	r2,1
 201e618:	00000806 	br	201e63c <raw_input+0x160>
        }
      }
      /* no receive callback function was set for this raw PCB */
    }
    /* drop the packet */
    prev = pcb;
 201e61c:	e0bff917 	ldw	r2,-28(fp)
 201e620:	e0bffa15 	stw	r2,-24(fp)
    pcb = pcb->next;
 201e624:	e0bff917 	ldw	r2,-28(fp)
 201e628:	10800417 	ldw	r2,16(r2)
 201e62c:	e0bff915 	stw	r2,-28(fp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while (pcb != NULL) {
 201e630:	e0bff917 	ldw	r2,-28(fp)
 201e634:	103fc31e 	bne	r2,zero,201e544 <__alt_mem_mem_0+0xfcffe544>
    }
    /* drop the packet */
    prev = pcb;
    pcb = pcb->next;
  }
  return ret;
 201e638:	e0bffb17 	ldw	r2,-20(fp)
}
 201e63c:	e037883a 	mov	sp,fp
 201e640:	dfc00117 	ldw	ra,4(sp)
 201e644:	df000017 	ldw	fp,0(sp)
 201e648:	dec00204 	addi	sp,sp,8
 201e64c:	f800283a 	ret

0201e650 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, const ip_addr_t *ipaddr)
{
 201e650:	defffd04 	addi	sp,sp,-12
 201e654:	df000215 	stw	fp,8(sp)
 201e658:	df000204 	addi	fp,sp,8
 201e65c:	e13ffe15 	stw	r4,-8(fp)
 201e660:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  if ((pcb == NULL) || (ipaddr == NULL)) {
 201e664:	e0bffe17 	ldw	r2,-8(fp)
 201e668:	10000226 	beq	r2,zero,201e674 <raw_bind+0x24>
 201e66c:	e0bfff17 	ldw	r2,-4(fp)
 201e670:	1000021e 	bne	r2,zero,201e67c <raw_bind+0x2c>
    return ERR_VAL;
 201e674:	00bffe84 	movi	r2,-6
 201e678:	00000906 	br	201e6a0 <raw_bind+0x50>
  }
  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 201e67c:	e0bfff17 	ldw	r2,-4(fp)
 201e680:	10000326 	beq	r2,zero,201e690 <raw_bind+0x40>
 201e684:	e0bfff17 	ldw	r2,-4(fp)
 201e688:	10800017 	ldw	r2,0(r2)
 201e68c:	00000106 	br	201e694 <raw_bind+0x44>
 201e690:	0005883a 	mov	r2,zero
 201e694:	e0fffe17 	ldw	r3,-8(fp)
 201e698:	18800015 	stw	r2,0(r3)
  if (IP_IS_V6(&pcb->local_ip) &&
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->local_ip), IP6_UNKNOWN)) {
    ip6_addr_select_zone(ip_2_ip6(&pcb->local_ip), ip_2_ip6(&pcb->local_ip));
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
  return ERR_OK;
 201e69c:	0005883a 	mov	r2,zero
}
 201e6a0:	e037883a 	mov	sp,fp
 201e6a4:	df000017 	ldw	fp,0(sp)
 201e6a8:	dec00104 	addi	sp,sp,4
 201e6ac:	f800283a 	ret

0201e6b0 <raw_bind_netif>:
 *
 * @see raw_disconnect()
 */
void
raw_bind_netif(struct raw_pcb *pcb, const struct netif *netif)
{
 201e6b0:	defffd04 	addi	sp,sp,-12
 201e6b4:	df000215 	stw	fp,8(sp)
 201e6b8:	df000204 	addi	fp,sp,8
 201e6bc:	e13ffe15 	stw	r4,-8(fp)
 201e6c0:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  if (netif != NULL) {
 201e6c4:	e0bfff17 	ldw	r2,-4(fp)
 201e6c8:	10000726 	beq	r2,zero,201e6e8 <raw_bind_netif+0x38>
    pcb->netif_idx = netif_get_index(netif);
 201e6cc:	e0bfff17 	ldw	r2,-4(fp)
 201e6d0:	10801003 	ldbu	r2,64(r2)
 201e6d4:	10800044 	addi	r2,r2,1
 201e6d8:	1007883a 	mov	r3,r2
 201e6dc:	e0bffe17 	ldw	r2,-8(fp)
 201e6e0:	10c00205 	stb	r3,8(r2)
  } else {
    pcb->netif_idx = NETIF_NO_INDEX;
  }
}
 201e6e4:	00000206 	br	201e6f0 <raw_bind_netif+0x40>
{
  LWIP_ASSERT_CORE_LOCKED();
  if (netif != NULL) {
    pcb->netif_idx = netif_get_index(netif);
  } else {
    pcb->netif_idx = NETIF_NO_INDEX;
 201e6e8:	e0bffe17 	ldw	r2,-8(fp)
 201e6ec:	10000205 	stb	zero,8(r2)
  }
}
 201e6f0:	0001883a 	nop
 201e6f4:	e037883a 	mov	sp,fp
 201e6f8:	df000017 	ldw	fp,0(sp)
 201e6fc:	dec00104 	addi	sp,sp,4
 201e700:	f800283a 	ret

0201e704 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, const ip_addr_t *ipaddr)
{
 201e704:	defffd04 	addi	sp,sp,-12
 201e708:	df000215 	stw	fp,8(sp)
 201e70c:	df000204 	addi	fp,sp,8
 201e710:	e13ffe15 	stw	r4,-8(fp)
 201e714:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  if ((pcb == NULL) || (ipaddr == NULL)) {
 201e718:	e0bffe17 	ldw	r2,-8(fp)
 201e71c:	10000226 	beq	r2,zero,201e728 <raw_connect+0x24>
 201e720:	e0bfff17 	ldw	r2,-4(fp)
 201e724:	1000021e 	bne	r2,zero,201e730 <raw_connect+0x2c>
    return ERR_VAL;
 201e728:	00bffe84 	movi	r2,-6
 201e72c:	00000f06 	br	201e76c <raw_connect+0x68>
  }
  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 201e730:	e0bfff17 	ldw	r2,-4(fp)
 201e734:	10000326 	beq	r2,zero,201e744 <raw_connect+0x40>
 201e738:	e0bfff17 	ldw	r2,-4(fp)
 201e73c:	10800017 	ldw	r2,0(r2)
 201e740:	00000106 	br	201e748 <raw_connect+0x44>
 201e744:	0005883a 	mov	r2,zero
 201e748:	e0fffe17 	ldw	r3,-8(fp)
 201e74c:	18800115 	stw	r2,4(r3)
  if (IP_IS_V6(&pcb->remote_ip) &&
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNKNOWN)) {
    ip6_addr_select_zone(ip_2_ip6(&pcb->remote_ip), ip_2_ip6(&pcb->local_ip));
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
  raw_set_flags(pcb, RAW_FLAGS_CONNECTED);
 201e750:	e0bffe17 	ldw	r2,-8(fp)
 201e754:	10800543 	ldbu	r2,21(r2)
 201e758:	10800054 	ori	r2,r2,1
 201e75c:	1007883a 	mov	r3,r2
 201e760:	e0bffe17 	ldw	r2,-8(fp)
 201e764:	10c00545 	stb	r3,21(r2)
  return ERR_OK;
 201e768:	0005883a 	mov	r2,zero
}
 201e76c:	e037883a 	mov	sp,fp
 201e770:	df000017 	ldw	fp,0(sp)
 201e774:	dec00104 	addi	sp,sp,4
 201e778:	f800283a 	ret

0201e77c <raw_disconnect>:
 *
 * @param pcb the raw pcb to disconnect.
 */
void
raw_disconnect(struct raw_pcb *pcb)
{
 201e77c:	defffe04 	addi	sp,sp,-8
 201e780:	df000115 	stw	fp,4(sp)
 201e784:	df000104 	addi	fp,sp,4
 201e788:	e13fff15 	stw	r4,-4(fp)
#if LWIP_IPV4 && LWIP_IPV6
  if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
    ip_addr_copy(pcb->remote_ip, *IP_ANY_TYPE);
  } else {
#endif
    ip_addr_set_any(IP_IS_V6_VAL(pcb->remote_ip), &pcb->remote_ip);
 201e78c:	e0bfff17 	ldw	r2,-4(fp)
 201e790:	10000115 	stw	zero,4(r2)
#if LWIP_IPV4 && LWIP_IPV6
  }
#endif
  pcb->netif_idx = NETIF_NO_INDEX;
 201e794:	e0bfff17 	ldw	r2,-4(fp)
 201e798:	10000205 	stb	zero,8(r2)
  /* mark PCB as unconnected */
  raw_clear_flags(pcb, RAW_FLAGS_CONNECTED);
 201e79c:	e0bfff17 	ldw	r2,-4(fp)
 201e7a0:	10c00543 	ldbu	r3,21(r2)
 201e7a4:	00bfff84 	movi	r2,-2
 201e7a8:	1884703a 	and	r2,r3,r2
 201e7ac:	1007883a 	mov	r3,r2
 201e7b0:	e0bfff17 	ldw	r2,-4(fp)
 201e7b4:	10c00545 	stb	r3,21(r2)
}
 201e7b8:	0001883a 	nop
 201e7bc:	e037883a 	mov	sp,fp
 201e7c0:	df000017 	ldw	fp,0(sp)
 201e7c4:	dec00104 	addi	sp,sp,4
 201e7c8:	f800283a 	ret

0201e7cc <raw_recv>:
 * - not free the packet, and return zero. The packet will be matched
 *   against further PCBs and/or forwarded to another protocol layers.
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
 201e7cc:	defffc04 	addi	sp,sp,-16
 201e7d0:	df000315 	stw	fp,12(sp)
 201e7d4:	df000304 	addi	fp,sp,12
 201e7d8:	e13ffd15 	stw	r4,-12(fp)
 201e7dc:	e17ffe15 	stw	r5,-8(fp)
 201e7e0:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  /* remember recv() callback and user data */
  pcb->recv = recv;
 201e7e4:	e0bffd17 	ldw	r2,-12(fp)
 201e7e8:	e0fffe17 	ldw	r3,-8(fp)
 201e7ec:	10c00615 	stw	r3,24(r2)
  pcb->recv_arg = recv_arg;
 201e7f0:	e0bffd17 	ldw	r2,-12(fp)
 201e7f4:	e0ffff17 	ldw	r3,-4(fp)
 201e7f8:	10c00715 	stw	r3,28(r2)
}
 201e7fc:	0001883a 	nop
 201e800:	e037883a 	mov	sp,fp
 201e804:	df000017 	ldw	fp,0(sp)
 201e808:	dec00104 	addi	sp,sp,4
 201e80c:	f800283a 	ret

0201e810 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *ipaddr)
{
 201e810:	defff804 	addi	sp,sp,-32
 201e814:	dfc00715 	stw	ra,28(sp)
 201e818:	df000615 	stw	fp,24(sp)
 201e81c:	df000604 	addi	fp,sp,24
 201e820:	e13ffd15 	stw	r4,-12(fp)
 201e824:	e17ffe15 	stw	r5,-8(fp)
 201e828:	e1bfff15 	stw	r6,-4(fp)
  struct netif *netif;
  const ip_addr_t *src_ip;

  if ((pcb == NULL) || (ipaddr == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
 201e82c:	e0bffd17 	ldw	r2,-12(fp)
 201e830:	10000226 	beq	r2,zero,201e83c <raw_sendto+0x2c>
 201e834:	e0bfff17 	ldw	r2,-4(fp)
 201e838:	1000021e 	bne	r2,zero,201e844 <raw_sendto+0x34>
    return ERR_VAL;
 201e83c:	00bffe84 	movi	r2,-6
 201e840:	00002d06 	br	201e8f8 <raw_sendto+0xe8>
  }

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 201e844:	e0bffd17 	ldw	r2,-12(fp)
 201e848:	10800203 	ldbu	r2,8(r2)
 201e84c:	10803fcc 	andi	r2,r2,255
 201e850:	10000726 	beq	r2,zero,201e870 <raw_sendto+0x60>
    netif = netif_get_by_index(pcb->netif_idx);
 201e854:	e0bffd17 	ldw	r2,-12(fp)
 201e858:	10800203 	ldbu	r2,8(r2)
 201e85c:	10803fcc 	andi	r2,r2,255
 201e860:	1009883a 	mov	r4,r2
 201e864:	201c62c0 	call	201c62c <netif_get_by_index>
 201e868:	e0bffb15 	stw	r2,-20(fp)
 201e86c:	00000306 	br	201e87c <raw_sendto+0x6c>
    }

    if (netif == NULL)
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    {
      netif = ip_route(&pcb->local_ip, ipaddr);
 201e870:	e13fff17 	ldw	r4,-4(fp)
 201e874:	203b5c40 	call	203b5c4 <ip4_route>
 201e878:	e0bffb15 	stw	r2,-20(fp)
    }
  }

  if (netif == NULL) {
 201e87c:	e0bffb17 	ldw	r2,-20(fp)
 201e880:	1000021e 	bne	r2,zero,201e88c <raw_sendto+0x7c>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to "));
    ip_addr_debug_print(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ipaddr);
    return ERR_RTE;
 201e884:	00bfff04 	movi	r2,-4
 201e888:	00001b06 	br	201e8f8 <raw_sendto+0xe8>
  }

  if (ip_addr_isany(&pcb->local_ip) || ip_addr_ismulticast(&pcb->local_ip)) {
 201e88c:	e0bffd17 	ldw	r2,-12(fp)
 201e890:	10000826 	beq	r2,zero,201e8b4 <raw_sendto+0xa4>
 201e894:	e0bffd17 	ldw	r2,-12(fp)
 201e898:	10800017 	ldw	r2,0(r2)
 201e89c:	10000526 	beq	r2,zero,201e8b4 <raw_sendto+0xa4>
 201e8a0:	e0bffd17 	ldw	r2,-12(fp)
 201e8a4:	10800017 	ldw	r2,0(r2)
 201e8a8:	10803c0c 	andi	r2,r2,240
 201e8ac:	10803818 	cmpnei	r2,r2,224
 201e8b0:	1000081e 	bne	r2,zero,201e8d4 <raw_sendto+0xc4>
    /* use outgoing network interface IP address as source address */
    src_ip = ip_netif_get_local_ip(netif, ipaddr);
 201e8b4:	e0bffb17 	ldw	r2,-20(fp)
 201e8b8:	10000326 	beq	r2,zero,201e8c8 <raw_sendto+0xb8>
 201e8bc:	e0bffb17 	ldw	r2,-20(fp)
 201e8c0:	10800104 	addi	r2,r2,4
 201e8c4:	00000106 	br	201e8cc <raw_sendto+0xbc>
 201e8c8:	0005883a 	mov	r2,zero
 201e8cc:	e0bffc15 	stw	r2,-16(fp)
 201e8d0:	00000206 	br	201e8dc <raw_sendto+0xcc>
      return ERR_RTE;
    }
#endif /* LWIP_IPV6 */
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &pcb->local_ip;
 201e8d4:	e0bffd17 	ldw	r2,-12(fp)
 201e8d8:	e0bffc15 	stw	r2,-16(fp)
  }

  return raw_sendto_if_src(pcb, p, ipaddr, netif, src_ip);
 201e8dc:	e0bffc17 	ldw	r2,-16(fp)
 201e8e0:	d8800015 	stw	r2,0(sp)
 201e8e4:	e1fffb17 	ldw	r7,-20(fp)
 201e8e8:	e1bfff17 	ldw	r6,-4(fp)
 201e8ec:	e17ffe17 	ldw	r5,-8(fp)
 201e8f0:	e13ffd17 	ldw	r4,-12(fp)
 201e8f4:	201e90c0 	call	201e90c <raw_sendto_if_src>
}
 201e8f8:	e037883a 	mov	sp,fp
 201e8fc:	dfc00117 	ldw	ra,4(sp)
 201e900:	df000017 	ldw	fp,0(sp)
 201e904:	dec00204 	addi	sp,sp,8
 201e908:	f800283a 	ret

0201e90c <raw_sendto_if_src>:
 * @param src_ip source IP address
 */
err_t
raw_sendto_if_src(struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                  struct netif *netif, const ip_addr_t *src_ip)
{
 201e90c:	defff504 	addi	sp,sp,-44
 201e910:	dfc00a15 	stw	ra,40(sp)
 201e914:	df000915 	stw	fp,36(sp)
 201e918:	df000904 	addi	fp,sp,36
 201e91c:	e13ffc15 	stw	r4,-16(fp)
 201e920:	e17ffd15 	stw	r5,-12(fp)
 201e924:	e1bffe15 	stw	r6,-8(fp)
 201e928:	e1ffff15 	stw	r7,-4(fp)
  u16_t header_size;
  u8_t ttl;

  LWIP_ASSERT_CORE_LOCKED();

  if ((pcb == NULL) || (dst_ip == NULL) || (netif == NULL) || (src_ip == NULL) ||
 201e92c:	e0bffc17 	ldw	r2,-16(fp)
 201e930:	10000626 	beq	r2,zero,201e94c <raw_sendto_if_src+0x40>
 201e934:	e0bffe17 	ldw	r2,-8(fp)
 201e938:	10000426 	beq	r2,zero,201e94c <raw_sendto_if_src+0x40>
 201e93c:	e0bfff17 	ldw	r2,-4(fp)
 201e940:	10000226 	beq	r2,zero,201e94c <raw_sendto_if_src+0x40>
      !IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 201e944:	e0800217 	ldw	r2,8(fp)
 201e948:	1000021e 	bne	r2,zero,201e954 <raw_sendto_if_src+0x48>
    return ERR_VAL;
 201e94c:	00bffe84 	movi	r2,-6
 201e950:	00006d06 	br	201eb08 <raw_sendto_if_src+0x1fc>
  }

  header_size = (
 201e954:	00800504 	movi	r2,20
 201e958:	e0bffb0d 	sth	r2,-20(fp)
                  IP6_HLEN);
#endif

  /* Handle the HDRINCL option as an exception: none of the code below applies
   * to this case, and sending the packet needs to be done differently too. */
  if (pcb->flags & RAW_FLAGS_HDRINCL) {
 201e95c:	e0bffc17 	ldw	r2,-16(fp)
 201e960:	10800543 	ldbu	r2,21(r2)
 201e964:	10803fcc 	andi	r2,r2,255
 201e968:	1080008c 	andi	r2,r2,2
 201e96c:	10001926 	beq	r2,zero,201e9d4 <raw_sendto_if_src+0xc8>
    /* A full header *must* be present in the first pbuf of the chain, as the
     * output routines may access its fields directly. */
    if (p->len < header_size) {
 201e970:	e0bffd17 	ldw	r2,-12(fp)
 201e974:	1080028b 	ldhu	r2,10(r2)
 201e978:	10ffffcc 	andi	r3,r2,65535
 201e97c:	e0bffb0b 	ldhu	r2,-20(fp)
 201e980:	1880022e 	bgeu	r3,r2,201e98c <raw_sendto_if_src+0x80>
      return ERR_VAL;
 201e984:	00bffe84 	movi	r2,-6
 201e988:	00005f06 	br	201eb08 <raw_sendto_if_src+0x1fc>
    }
    /* @todo multicast loop support, if at all desired for this scenario.. */
    NETIF_SET_HINTS(netif, &pcb->netif_hints);
 201e98c:	e0bffc17 	ldw	r2,-16(fp)
 201e990:	10c00304 	addi	r3,r2,12
 201e994:	e0bfff17 	ldw	r2,-4(fp)
 201e998:	10c01215 	stw	r3,72(r2)
    err = ip_output_if_hdrincl(p, src_ip, dst_ip, netif);
 201e99c:	e0bfff17 	ldw	r2,-4(fp)
 201e9a0:	d8800215 	stw	r2,8(sp)
 201e9a4:	d8000115 	stw	zero,4(sp)
 201e9a8:	d8000015 	stw	zero,0(sp)
 201e9ac:	000f883a 	mov	r7,zero
 201e9b0:	000d883a 	mov	r6,zero
 201e9b4:	e1400217 	ldw	r5,8(fp)
 201e9b8:	e13ffd17 	ldw	r4,-12(fp)
 201e9bc:	203be1c0 	call	203be1c <ip4_output_if>
 201e9c0:	e0bffb85 	stb	r2,-18(fp)
    NETIF_RESET_HINTS(netif);
 201e9c4:	e0bfff17 	ldw	r2,-4(fp)
 201e9c8:	10001215 	stw	zero,72(r2)
    return err;
 201e9cc:	e0bffb83 	ldbu	r2,-18(fp)
 201e9d0:	00004d06 	br	201eb08 <raw_sendto_if_src+0x1fc>
  }

  /* packet too large to add an IP header without causing an overflow? */
  if ((u16_t)(p->tot_len + header_size) < p->tot_len) {
 201e9d4:	e0bffd17 	ldw	r2,-12(fp)
 201e9d8:	10c0020b 	ldhu	r3,8(r2)
 201e9dc:	e0bffb0b 	ldhu	r2,-20(fp)
 201e9e0:	1885883a 	add	r2,r3,r2
 201e9e4:	1007883a 	mov	r3,r2
 201e9e8:	e0bffd17 	ldw	r2,-12(fp)
 201e9ec:	1080020b 	ldhu	r2,8(r2)
 201e9f0:	18ffffcc 	andi	r3,r3,65535
 201e9f4:	10bfffcc 	andi	r2,r2,65535
 201e9f8:	1880022e 	bgeu	r3,r2,201ea04 <raw_sendto_if_src+0xf8>
    return ERR_MEM;
 201e9fc:	00bfffc4 	movi	r2,-1
 201ea00:	00004106 	br	201eb08 <raw_sendto_if_src+0x1fc>
  }
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_add_header(p, header_size)) {
 201ea04:	e0bffb0b 	ldhu	r2,-20(fp)
 201ea08:	100b883a 	mov	r5,r2
 201ea0c:	e13ffd17 	ldw	r4,-12(fp)
 201ea10:	201cff40 	call	201cff4 <pbuf_add_header>
 201ea14:	10803fcc 	andi	r2,r2,255
 201ea18:	10001126 	beq	r2,zero,201ea60 <raw_sendto_if_src+0x154>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
 201ea1c:	0180a004 	movi	r6,640
 201ea20:	000b883a 	mov	r5,zero
 201ea24:	01000904 	movi	r4,36
 201ea28:	201c9740 	call	201c974 <pbuf_alloc>
 201ea2c:	e0bffa15 	stw	r2,-24(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 201ea30:	e0bffa17 	ldw	r2,-24(fp)
 201ea34:	1000021e 	bne	r2,zero,201ea40 <raw_sendto_if_src+0x134>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
 201ea38:	00bfffc4 	movi	r2,-1
 201ea3c:	00003206 	br	201eb08 <raw_sendto_if_src+0x1fc>
    }
    if (p->tot_len != 0) {
 201ea40:	e0bffd17 	ldw	r2,-12(fp)
 201ea44:	1080020b 	ldhu	r2,8(r2)
 201ea48:	10bfffcc 	andi	r2,r2,65535
 201ea4c:	10000e26 	beq	r2,zero,201ea88 <raw_sendto_if_src+0x17c>
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
 201ea50:	e17ffd17 	ldw	r5,-12(fp)
 201ea54:	e13ffa17 	ldw	r4,-24(fp)
 201ea58:	201d5800 	call	201d580 <pbuf_chain>
 201ea5c:	00000a06 	br	201ea88 <raw_sendto_if_src+0x17c>
    }
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* first pbuf q equals given pbuf */
    q = p;
 201ea60:	e0bffd17 	ldw	r2,-12(fp)
 201ea64:	e0bffa15 	stw	r2,-24(fp)
    if (pbuf_remove_header(q, header_size)) {
 201ea68:	e0bffb0b 	ldhu	r2,-20(fp)
 201ea6c:	100b883a 	mov	r5,r2
 201ea70:	e13ffa17 	ldw	r4,-24(fp)
 201ea74:	201d06c0 	call	201d06c <pbuf_remove_header>
 201ea78:	10803fcc 	andi	r2,r2,255
 201ea7c:	10000226 	beq	r2,zero,201ea88 <raw_sendto_if_src+0x17c>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
 201ea80:	00bfffc4 	movi	r2,-1
 201ea84:	00002006 	br	201eb08 <raw_sendto_if_src+0x1fc>

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? raw_get_multicast_ttl(pcb) : pcb->ttl);
#else /* LWIP_MULTICAST_TX_OPTIONS */
  ttl = pcb->ttl;
 201ea88:	e0bffc17 	ldw	r2,-16(fp)
 201ea8c:	108002c3 	ldbu	r2,11(r2)
 201ea90:	e0bffbc5 	stb	r2,-17(fp)
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  NETIF_SET_HINTS(netif, &pcb->netif_hints);
 201ea94:	e0bffc17 	ldw	r2,-16(fp)
 201ea98:	10c00304 	addi	r3,r2,12
 201ea9c:	e0bfff17 	ldw	r2,-4(fp)
 201eaa0:	10c01215 	stw	r3,72(r2)
  err = ip_output_if(q, src_ip, dst_ip, ttl, pcb->tos, pcb->protocol, netif);
 201eaa4:	e17ffbc3 	ldbu	r5,-17(fp)
 201eaa8:	e0bffc17 	ldw	r2,-16(fp)
 201eaac:	10800283 	ldbu	r2,10(r2)
 201eab0:	10803fcc 	andi	r2,r2,255
 201eab4:	e0fffc17 	ldw	r3,-16(fp)
 201eab8:	18c00503 	ldbu	r3,20(r3)
 201eabc:	18c03fcc 	andi	r3,r3,255
 201eac0:	e13fff17 	ldw	r4,-4(fp)
 201eac4:	d9000215 	stw	r4,8(sp)
 201eac8:	d8c00115 	stw	r3,4(sp)
 201eacc:	d8800015 	stw	r2,0(sp)
 201ead0:	280f883a 	mov	r7,r5
 201ead4:	e1bffe17 	ldw	r6,-8(fp)
 201ead8:	e1400217 	ldw	r5,8(fp)
 201eadc:	e13ffa17 	ldw	r4,-24(fp)
 201eae0:	203be1c0 	call	203be1c <ip4_output_if>
 201eae4:	e0bffb85 	stb	r2,-18(fp)
  NETIF_RESET_HINTS(netif);
 201eae8:	e0bfff17 	ldw	r2,-4(fp)
 201eaec:	10001215 	stw	zero,72(r2)

  /* did we chain a header earlier? */
  if (q != p) {
 201eaf0:	e0fffa17 	ldw	r3,-24(fp)
 201eaf4:	e0bffd17 	ldw	r2,-12(fp)
 201eaf8:	18800226 	beq	r3,r2,201eb04 <raw_sendto_if_src+0x1f8>
    /* free the header */
    pbuf_free(q);
 201eafc:	e13ffa17 	ldw	r4,-24(fp)
 201eb00:	201d2f40 	call	201d2f4 <pbuf_free>
  }
  return err;
 201eb04:	e0bffb83 	ldbu	r2,-18(fp)
}
 201eb08:	e037883a 	mov	sp,fp
 201eb0c:	dfc00117 	ldw	ra,4(sp)
 201eb10:	df000017 	ldw	fp,0(sp)
 201eb14:	dec00204 	addi	sp,sp,8
 201eb18:	f800283a 	ret

0201eb1c <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
 201eb1c:	defffc04 	addi	sp,sp,-16
 201eb20:	dfc00315 	stw	ra,12(sp)
 201eb24:	df000215 	stw	fp,8(sp)
 201eb28:	df000204 	addi	fp,sp,8
 201eb2c:	e13ffe15 	stw	r4,-8(fp)
 201eb30:	e17fff15 	stw	r5,-4(fp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
 201eb34:	e0bffe17 	ldw	r2,-8(fp)
 201eb38:	10800104 	addi	r2,r2,4
 201eb3c:	100d883a 	mov	r6,r2
 201eb40:	e17fff17 	ldw	r5,-4(fp)
 201eb44:	e13ffe17 	ldw	r4,-8(fp)
 201eb48:	201e8100 	call	201e810 <raw_sendto>
}
 201eb4c:	e037883a 	mov	sp,fp
 201eb50:	dfc00117 	ldw	ra,4(sp)
 201eb54:	df000017 	ldw	fp,0(sp)
 201eb58:	dec00204 	addi	sp,sp,8
 201eb5c:	f800283a 	ret

0201eb60 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 201eb60:	defffc04 	addi	sp,sp,-16
 201eb64:	dfc00315 	stw	ra,12(sp)
 201eb68:	df000215 	stw	fp,8(sp)
 201eb6c:	df000204 	addi	fp,sp,8
 201eb70:	e13fff15 	stw	r4,-4(fp)
  struct raw_pcb *pcb2;
  LWIP_ASSERT_CORE_LOCKED();
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 201eb74:	d0e7df17 	ldw	r3,-24708(gp)
 201eb78:	e0bfff17 	ldw	r2,-4(fp)
 201eb7c:	1880041e 	bne	r3,r2,201eb90 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
 201eb80:	d0a7df17 	ldw	r2,-24708(gp)
 201eb84:	10800417 	ldw	r2,16(r2)
 201eb88:	d0a7df15 	stw	r2,-24708(gp)
 201eb8c:	00001406 	br	201ebe0 <raw_remove+0x80>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 201eb90:	d0a7df17 	ldw	r2,-24708(gp)
 201eb94:	e0bffe15 	stw	r2,-8(fp)
 201eb98:	00000f06 	br	201ebd8 <raw_remove+0x78>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 201eb9c:	e0bffe17 	ldw	r2,-8(fp)
 201eba0:	10800417 	ldw	r2,16(r2)
 201eba4:	10000926 	beq	r2,zero,201ebcc <raw_remove+0x6c>
 201eba8:	e0bffe17 	ldw	r2,-8(fp)
 201ebac:	10c00417 	ldw	r3,16(r2)
 201ebb0:	e0bfff17 	ldw	r2,-4(fp)
 201ebb4:	1880051e 	bne	r3,r2,201ebcc <raw_remove+0x6c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 201ebb8:	e0bfff17 	ldw	r2,-4(fp)
 201ebbc:	10c00417 	ldw	r3,16(r2)
 201ebc0:	e0bffe17 	ldw	r2,-8(fp)
 201ebc4:	10c00415 	stw	r3,16(r2)
        break;
 201ebc8:	00000506 	br	201ebe0 <raw_remove+0x80>
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 201ebcc:	e0bffe17 	ldw	r2,-8(fp)
 201ebd0:	10800417 	ldw	r2,16(r2)
 201ebd4:	e0bffe15 	stw	r2,-8(fp)
 201ebd8:	e0bffe17 	ldw	r2,-8(fp)
 201ebdc:	103fef1e 	bne	r2,zero,201eb9c <__alt_mem_mem_0+0xfcffeb9c>
        pcb2->next = pcb->next;
        break;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 201ebe0:	e17fff17 	ldw	r5,-4(fp)
 201ebe4:	0009883a 	mov	r4,zero
 201ebe8:	201b9640 	call	201b964 <memp_free>
}
 201ebec:	0001883a 	nop
 201ebf0:	e037883a 	mov	sp,fp
 201ebf4:	dfc00117 	ldw	ra,4(sp)
 201ebf8:	df000017 	ldw	fp,0(sp)
 201ebfc:	dec00204 	addi	sp,sp,8
 201ec00:	f800283a 	ret

0201ec04 <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
 201ec04:	defffc04 	addi	sp,sp,-16
 201ec08:	dfc00315 	stw	ra,12(sp)
 201ec0c:	df000215 	stw	fp,8(sp)
 201ec10:	df000204 	addi	fp,sp,8
 201ec14:	2005883a 	mov	r2,r4
 201ec18:	e0bfff05 	stb	r2,-4(fp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));
  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
 201ec1c:	0009883a 	mov	r4,zero
 201ec20:	201b82c0 	call	201b82c <memp_malloc>
 201ec24:	e0bffe15 	stw	r2,-8(fp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
 201ec28:	e0bffe17 	ldw	r2,-8(fp)
 201ec2c:	10000f26 	beq	r2,zero,201ec6c <raw_new+0x68>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
 201ec30:	01800804 	movi	r6,32
 201ec34:	000b883a 	mov	r5,zero
 201ec38:	e13ffe17 	ldw	r4,-8(fp)
 201ec3c:	2005fa00 	call	2005fa0 <memset>
    pcb->protocol = proto;
 201ec40:	e0bffe17 	ldw	r2,-8(fp)
 201ec44:	e0ffff03 	ldbu	r3,-4(fp)
 201ec48:	10c00505 	stb	r3,20(r2)
    pcb->ttl = RAW_TTL;
 201ec4c:	e0bffe17 	ldw	r2,-8(fp)
 201ec50:	00c01004 	movi	r3,64
 201ec54:	10c002c5 	stb	r3,11(r2)
#if LWIP_MULTICAST_TX_OPTIONS
    raw_set_multicast_ttl(pcb, RAW_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    pcb->next = raw_pcbs;
 201ec58:	d0e7df17 	ldw	r3,-24708(gp)
 201ec5c:	e0bffe17 	ldw	r2,-8(fp)
 201ec60:	10c00415 	stw	r3,16(r2)
    raw_pcbs = pcb;
 201ec64:	e0bffe17 	ldw	r2,-8(fp)
 201ec68:	d0a7df15 	stw	r2,-24708(gp)
  }
  return pcb;
 201ec6c:	e0bffe17 	ldw	r2,-8(fp)
}
 201ec70:	e037883a 	mov	sp,fp
 201ec74:	dfc00117 	ldw	ra,4(sp)
 201ec78:	df000017 	ldw	fp,0(sp)
 201ec7c:	dec00204 	addi	sp,sp,8
 201ec80:	f800283a 	ret

0201ec84 <raw_new_ip_type>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new_ip_type(u8_t type, u8_t proto)
{
 201ec84:	defffb04 	addi	sp,sp,-20
 201ec88:	dfc00415 	stw	ra,16(sp)
 201ec8c:	df000315 	stw	fp,12(sp)
 201ec90:	df000304 	addi	fp,sp,12
 201ec94:	2007883a 	mov	r3,r4
 201ec98:	2805883a 	mov	r2,r5
 201ec9c:	e0fffe05 	stb	r3,-8(fp)
 201eca0:	e0bfff05 	stb	r2,-4(fp)
  struct raw_pcb *pcb;
  LWIP_ASSERT_CORE_LOCKED();
  pcb = raw_new(proto);
 201eca4:	e0bfff03 	ldbu	r2,-4(fp)
 201eca8:	1009883a 	mov	r4,r2
 201ecac:	201ec040 	call	201ec04 <raw_new>
 201ecb0:	e0bffd15 	stw	r2,-12(fp)
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else /* LWIP_IPV4 && LWIP_IPV6 */
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
 201ecb4:	e0bffd17 	ldw	r2,-12(fp)
}
 201ecb8:	e037883a 	mov	sp,fp
 201ecbc:	dfc00117 	ldw	ra,4(sp)
 201ecc0:	df000017 	ldw	fp,0(sp)
 201ecc4:	dec00204 	addi	sp,sp,8
 201ecc8:	f800283a 	ret

0201eccc <raw_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void raw_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 201eccc:	defffc04 	addi	sp,sp,-16
 201ecd0:	df000315 	stw	fp,12(sp)
 201ecd4:	df000304 	addi	fp,sp,12
 201ecd8:	e13ffe15 	stw	r4,-8(fp)
 201ecdc:	e17fff15 	stw	r5,-4(fp)
  struct raw_pcb *rpcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 201ece0:	e0bffe17 	ldw	r2,-8(fp)
 201ece4:	10001926 	beq	r2,zero,201ed4c <raw_netif_ip_addr_changed+0x80>
 201ece8:	e0bffe17 	ldw	r2,-8(fp)
 201ecec:	10800017 	ldw	r2,0(r2)
 201ecf0:	10001626 	beq	r2,zero,201ed4c <raw_netif_ip_addr_changed+0x80>
 201ecf4:	e0bfff17 	ldw	r2,-4(fp)
 201ecf8:	10001426 	beq	r2,zero,201ed4c <raw_netif_ip_addr_changed+0x80>
 201ecfc:	e0bfff17 	ldw	r2,-4(fp)
 201ed00:	10800017 	ldw	r2,0(r2)
 201ed04:	10001126 	beq	r2,zero,201ed4c <raw_netif_ip_addr_changed+0x80>
    for (rpcb = raw_pcbs; rpcb != NULL; rpcb = rpcb->next) {
 201ed08:	d0a7df17 	ldw	r2,-24708(gp)
 201ed0c:	e0bffd15 	stw	r2,-12(fp)
 201ed10:	00000c06 	br	201ed44 <raw_netif_ip_addr_changed+0x78>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&rpcb->local_ip, old_addr)) {
 201ed14:	e0bffd17 	ldw	r2,-12(fp)
 201ed18:	10c00017 	ldw	r3,0(r2)
 201ed1c:	e0bffe17 	ldw	r2,-8(fp)
 201ed20:	10800017 	ldw	r2,0(r2)
 201ed24:	1880041e 	bne	r3,r2,201ed38 <raw_netif_ip_addr_changed+0x6c>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(rpcb->local_ip, *new_addr);
 201ed28:	e0bfff17 	ldw	r2,-4(fp)
 201ed2c:	10c00017 	ldw	r3,0(r2)
 201ed30:	e0bffd17 	ldw	r2,-12(fp)
 201ed34:	10c00015 	stw	r3,0(r2)
void raw_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
  struct raw_pcb *rpcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
    for (rpcb = raw_pcbs; rpcb != NULL; rpcb = rpcb->next) {
 201ed38:	e0bffd17 	ldw	r2,-12(fp)
 201ed3c:	10800417 	ldw	r2,16(r2)
 201ed40:	e0bffd15 	stw	r2,-12(fp)
 201ed44:	e0bffd17 	ldw	r2,-12(fp)
 201ed48:	103ff21e 	bne	r2,zero,201ed14 <__alt_mem_mem_0+0xfcffed14>
         * is set to bound to the new one instead */
        ip_addr_copy(rpcb->local_ip, *new_addr);
      }
    }
  }
}
 201ed4c:	0001883a 	nop
 201ed50:	e037883a 	mov	sp,fp
 201ed54:	df000017 	ldw	fp,0(sp)
 201ed58:	dec00104 	addi	sp,sp,4
 201ed5c:	f800283a 	ret

0201ed60 <stats_init>:

struct stats_ lwip_stats;

void
stats_init(void)
{
 201ed60:	deffff04 	addi	sp,sp,-4
 201ed64:	df000015 	stw	fp,0(sp)
 201ed68:	d839883a 	mov	fp,sp
#ifdef LWIP_DEBUG
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
 201ed6c:	0001883a 	nop
 201ed70:	e037883a 	mov	sp,fp
 201ed74:	df000017 	ldw	fp,0(sp)
 201ed78:	dec00104 	addi	sp,sp,4
 201ed7c:	f800283a 	ret

0201ed80 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 201ed80:	deffff04 	addi	sp,sp,-4
 201ed84:	df000015 	stw	fp,0(sp)
 201ed88:	d839883a 	mov	fp,sp
#ifdef LWIP_RAND
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RAND */
}
 201ed8c:	0001883a 	nop
 201ed90:	e037883a 	mov	sp,fp
 201ed94:	df000017 	ldw	fp,0(sp)
 201ed98:	dec00104 	addi	sp,sp,4
 201ed9c:	f800283a 	ret

0201eda0 <tcp_free>:

/** Free a tcp pcb */
void
tcp_free(struct tcp_pcb *pcb)
{
 201eda0:	defffd04 	addi	sp,sp,-12
 201eda4:	dfc00215 	stw	ra,8(sp)
 201eda8:	df000115 	stw	fp,4(sp)
 201edac:	df000104 	addi	fp,sp,4
 201edb0:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB, pcb);
 201edb4:	e17fff17 	ldw	r5,-4(fp)
 201edb8:	01000084 	movi	r4,2
 201edbc:	201b9640 	call	201b964 <memp_free>
}
 201edc0:	0001883a 	nop
 201edc4:	e037883a 	mov	sp,fp
 201edc8:	dfc00117 	ldw	ra,4(sp)
 201edcc:	df000017 	ldw	fp,0(sp)
 201edd0:	dec00204 	addi	sp,sp,8
 201edd4:	f800283a 	ret

0201edd8 <tcp_free_listen>:

/** Free a tcp listen pcb */
static void
tcp_free_listen(struct tcp_pcb *pcb)
{
 201edd8:	defffd04 	addi	sp,sp,-12
 201eddc:	dfc00215 	stw	ra,8(sp)
 201ede0:	df000115 	stw	fp,4(sp)
 201ede4:	df000104 	addi	fp,sp,4
 201ede8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 201edec:	e17fff17 	ldw	r5,-4(fp)
 201edf0:	010000c4 	movi	r4,3
 201edf4:	201b9640 	call	201b964 <memp_free>
}
 201edf8:	0001883a 	nop
 201edfc:	e037883a 	mov	sp,fp
 201ee00:	dfc00117 	ldw	ra,4(sp)
 201ee04:	df000017 	ldw	fp,0(sp)
 201ee08:	dec00204 	addi	sp,sp,8
 201ee0c:	f800283a 	ret

0201ee10 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 201ee10:	defffe04 	addi	sp,sp,-8
 201ee14:	dfc00115 	stw	ra,4(sp)
 201ee18:	df000015 	stw	fp,0(sp)
 201ee1c:	d839883a 	mov	fp,sp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 201ee20:	2020b800 	call	2020b80 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 201ee24:	d0a7e003 	ldbu	r2,-24704(gp)
 201ee28:	10800044 	addi	r2,r2,1
 201ee2c:	d0a7e005 	stb	r2,-24704(gp)
 201ee30:	d0a7e003 	ldbu	r2,-24704(gp)
 201ee34:	10803fcc 	andi	r2,r2,255
 201ee38:	1080004c 	andi	r2,r2,1
 201ee3c:	10000126 	beq	r2,zero,201ee44 <tcp_tmr+0x34>
    /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 201ee40:	202030c0 	call	202030c <tcp_slowtmr>
  }
}
 201ee44:	0001883a 	nop
 201ee48:	e037883a 	mov	sp,fp
 201ee4c:	dfc00117 	ldw	ra,4(sp)
 201ee50:	df000017 	ldw	fp,0(sp)
 201ee54:	dec00204 	addi	sp,sp,8
 201ee58:	f800283a 	ret

0201ee5c <tcp_remove_listener>:
/** Called when a listen pcb is closed. Iterates one pcb list and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
 201ee5c:	defffc04 	addi	sp,sp,-16
 201ee60:	df000315 	stw	fp,12(sp)
 201ee64:	df000304 	addi	fp,sp,12
 201ee68:	e13ffe15 	stw	r4,-8(fp)
 201ee6c:	e17fff15 	stw	r5,-4(fp)
  struct tcp_pcb *pcb;

  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);

  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 201ee70:	e0bffe17 	ldw	r2,-8(fp)
 201ee74:	e0bffd15 	stw	r2,-12(fp)
 201ee78:	00000906 	br	201eea0 <tcp_remove_listener+0x44>
    if (pcb->listener == lpcb) {
 201ee7c:	e0bffd17 	ldw	r2,-12(fp)
 201ee80:	10c02117 	ldw	r3,132(r2)
 201ee84:	e0bfff17 	ldw	r2,-4(fp)
 201ee88:	1880021e 	bne	r3,r2,201ee94 <tcp_remove_listener+0x38>
      pcb->listener = NULL;
 201ee8c:	e0bffd17 	ldw	r2,-12(fp)
 201ee90:	10002115 	stw	zero,132(r2)
{
  struct tcp_pcb *pcb;

  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);

  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 201ee94:	e0bffd17 	ldw	r2,-12(fp)
 201ee98:	10800417 	ldw	r2,16(r2)
 201ee9c:	e0bffd15 	stw	r2,-12(fp)
 201eea0:	e0bffd17 	ldw	r2,-12(fp)
 201eea4:	103ff51e 	bne	r2,zero,201ee7c <__alt_mem_mem_0+0xfcffee7c>
    if (pcb->listener == lpcb) {
      pcb->listener = NULL;
    }
  }
}
 201eea8:	0001883a 	nop
 201eeac:	e037883a 	mov	sp,fp
 201eeb0:	df000017 	ldw	fp,0(sp)
 201eeb4:	dec00104 	addi	sp,sp,4
 201eeb8:	f800283a 	ret

0201eebc <tcp_listen_closed>:
/** Called when a listen pcb is closed. Iterates all pcb lists and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_listen_closed(struct tcp_pcb *pcb)
{
 201eebc:	defffc04 	addi	sp,sp,-16
 201eec0:	dfc00315 	stw	ra,12(sp)
 201eec4:	df000215 	stw	fp,8(sp)
 201eec8:	df000204 	addi	fp,sp,8
 201eecc:	e13fff15 	stw	r4,-4(fp)
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 201eed0:	00800044 	movi	r2,1
 201eed4:	e0bffe15 	stw	r2,-8(fp)
 201eed8:	00000e06 	br	201ef14 <tcp_listen_closed+0x58>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
 201eedc:	00808134 	movhi	r2,516
 201eee0:	109bf304 	addi	r2,r2,28620
 201eee4:	e0fffe17 	ldw	r3,-8(fp)
 201eee8:	18c7883a 	add	r3,r3,r3
 201eeec:	18c7883a 	add	r3,r3,r3
 201eef0:	10c5883a 	add	r2,r2,r3
 201eef4:	10800017 	ldw	r2,0(r2)
 201eef8:	10800017 	ldw	r2,0(r2)
 201eefc:	e17fff17 	ldw	r5,-4(fp)
 201ef00:	1009883a 	mov	r4,r2
 201ef04:	201ee5c0 	call	201ee5c <tcp_remove_listener>
{
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 201ef08:	e0bffe17 	ldw	r2,-8(fp)
 201ef0c:	10800044 	addi	r2,r2,1
 201ef10:	e0bffe15 	stw	r2,-8(fp)
 201ef14:	e0bffe17 	ldw	r2,-8(fp)
 201ef18:	10800130 	cmpltui	r2,r2,4
 201ef1c:	103fef1e 	bne	r2,zero,201eedc <__alt_mem_mem_0+0xfcffeedc>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
  }
#endif
  LWIP_UNUSED_ARG(pcb);
}
 201ef20:	0001883a 	nop
 201ef24:	e037883a 	mov	sp,fp
 201ef28:	dfc00117 	ldw	ra,4(sp)
 201ef2c:	df000017 	ldw	fp,0(sp)
 201ef30:	dec00204 	addi	sp,sp,8
 201ef34:	f800283a 	ret

0201ef38 <tcp_backlog_delayed>:
 *
 * @param pcb the connection pcb which is not fully accepted yet
 */
void
tcp_backlog_delayed(struct tcp_pcb *pcb)
{
 201ef38:	defffe04 	addi	sp,sp,-8
 201ef3c:	df000115 	stw	fp,4(sp)
 201ef40:	df000104 	addi	fp,sp,4
 201ef44:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
  LWIP_ASSERT_CORE_LOCKED();
  if ((pcb->flags & TF_BACKLOGPEND) == 0) {
 201ef48:	e0bfff17 	ldw	r2,-4(fp)
 201ef4c:	1080088b 	ldhu	r2,34(r2)
 201ef50:	10bfffcc 	andi	r2,r2,65535
 201ef54:	1080800c 	andi	r2,r2,512
 201ef58:	10000e1e 	bne	r2,zero,201ef94 <tcp_backlog_delayed+0x5c>
    if (pcb->listener != NULL) {
 201ef5c:	e0bfff17 	ldw	r2,-4(fp)
 201ef60:	10802117 	ldw	r2,132(r2)
 201ef64:	10000b26 	beq	r2,zero,201ef94 <tcp_backlog_delayed+0x5c>
      pcb->listener->accepts_pending++;
 201ef68:	e0bfff17 	ldw	r2,-4(fp)
 201ef6c:	10802117 	ldw	r2,132(r2)
 201ef70:	10c00943 	ldbu	r3,37(r2)
 201ef74:	18c00044 	addi	r3,r3,1
 201ef78:	10c00945 	stb	r3,37(r2)
      LWIP_ASSERT("accepts_pending != 0", pcb->listener->accepts_pending != 0);
      tcp_set_flags(pcb, TF_BACKLOGPEND);
 201ef7c:	e0bfff17 	ldw	r2,-4(fp)
 201ef80:	1080088b 	ldhu	r2,34(r2)
 201ef84:	10808014 	ori	r2,r2,512
 201ef88:	1007883a 	mov	r3,r2
 201ef8c:	e0bfff17 	ldw	r2,-4(fp)
 201ef90:	10c0088d 	sth	r3,34(r2)
    }
  }
}
 201ef94:	0001883a 	nop
 201ef98:	e037883a 	mov	sp,fp
 201ef9c:	df000017 	ldw	fp,0(sp)
 201efa0:	dec00104 	addi	sp,sp,4
 201efa4:	f800283a 	ret

0201efa8 <tcp_backlog_accepted>:
 *
 * @param pcb the connection pcb which is now fully accepted (or closed/aborted)
 */
void
tcp_backlog_accepted(struct tcp_pcb *pcb)
{
 201efa8:	defffe04 	addi	sp,sp,-8
 201efac:	df000115 	stw	fp,4(sp)
 201efb0:	df000104 	addi	fp,sp,4
 201efb4:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
  LWIP_ASSERT_CORE_LOCKED();
  if ((pcb->flags & TF_BACKLOGPEND) != 0) {
 201efb8:	e0bfff17 	ldw	r2,-4(fp)
 201efbc:	1080088b 	ldhu	r2,34(r2)
 201efc0:	10bfffcc 	andi	r2,r2,65535
 201efc4:	1080800c 	andi	r2,r2,512
 201efc8:	10000f26 	beq	r2,zero,201f008 <tcp_backlog_accepted+0x60>
    if (pcb->listener != NULL) {
 201efcc:	e0bfff17 	ldw	r2,-4(fp)
 201efd0:	10802117 	ldw	r2,132(r2)
 201efd4:	10000c26 	beq	r2,zero,201f008 <tcp_backlog_accepted+0x60>
      LWIP_ASSERT("accepts_pending != 0", pcb->listener->accepts_pending != 0);
      pcb->listener->accepts_pending--;
 201efd8:	e0bfff17 	ldw	r2,-4(fp)
 201efdc:	10802117 	ldw	r2,132(r2)
 201efe0:	10c00943 	ldbu	r3,37(r2)
 201efe4:	18ffffc4 	addi	r3,r3,-1
 201efe8:	10c00945 	stb	r3,37(r2)
      tcp_clear_flags(pcb, TF_BACKLOGPEND);
 201efec:	e0bfff17 	ldw	r2,-4(fp)
 201eff0:	10c0088b 	ldhu	r3,34(r2)
 201eff4:	00bf7fc4 	movi	r2,-513
 201eff8:	1884703a 	and	r2,r3,r2
 201effc:	1007883a 	mov	r3,r2
 201f000:	e0bfff17 	ldw	r2,-4(fp)
 201f004:	10c0088d 	sth	r3,34(r2)
    }
  }
}
 201f008:	0001883a 	nop
 201f00c:	e037883a 	mov	sp,fp
 201f010:	df000017 	ldw	fp,0(sp)
 201f014:	dec00104 	addi	sp,sp,4
 201f018:	f800283a 	ret

0201f01c <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 201f01c:	defff704 	addi	sp,sp,-36
 201f020:	dfc00815 	stw	ra,32(sp)
 201f024:	df000715 	stw	fp,28(sp)
 201f028:	df000704 	addi	fp,sp,28
 201f02c:	e13ffe15 	stw	r4,-8(fp)
 201f030:	2805883a 	mov	r2,r5
 201f034:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 201f038:	e0bfff03 	ldbu	r2,-4(fp)
 201f03c:	10004926 	beq	r2,zero,201f164 <tcp_close_shutdown+0x148>
 201f040:	e0bffe17 	ldw	r2,-8(fp)
 201f044:	10800617 	ldw	r2,24(r2)
 201f048:	10800120 	cmpeqi	r2,r2,4
 201f04c:	1000041e 	bne	r2,zero,201f060 <tcp_close_shutdown+0x44>
 201f050:	e0bffe17 	ldw	r2,-8(fp)
 201f054:	10800617 	ldw	r2,24(r2)
 201f058:	108001d8 	cmpnei	r2,r2,7
 201f05c:	1000411e 	bne	r2,zero,201f164 <tcp_close_shutdown+0x148>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 201f060:	e0bffe17 	ldw	r2,-8(fp)
 201f064:	10802017 	ldw	r2,128(r2)
 201f068:	1000051e 	bne	r2,zero,201f080 <tcp_close_shutdown+0x64>
 201f06c:	e0bffe17 	ldw	r2,-8(fp)
 201f070:	10800c0b 	ldhu	r2,48(r2)
 201f074:	10bfffcc 	andi	r2,r2,65535
 201f078:	10880020 	cmpeqi	r2,r2,8192
 201f07c:	1000391e 	bne	r2,zero,201f164 <tcp_close_shutdown+0x148>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201f080:	e0bffe17 	ldw	r2,-8(fp)
 201f084:	11401617 	ldw	r5,88(r2)
 201f088:	e0bffe17 	ldw	r2,-8(fp)
 201f08c:	11800b17 	ldw	r6,44(r2)
 201f090:	e1fffe17 	ldw	r7,-8(fp)
 201f094:	e0bffe17 	ldw	r2,-8(fp)
 201f098:	10800104 	addi	r2,r2,4
              pcb->local_port, pcb->remote_port);
 201f09c:	e0fffe17 	ldw	r3,-8(fp)
 201f0a0:	18c0078b 	ldhu	r3,30(r3)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201f0a4:	18ffffcc 	andi	r3,r3,65535
              pcb->local_port, pcb->remote_port);
 201f0a8:	e13ffe17 	ldw	r4,-8(fp)
 201f0ac:	2100080b 	ldhu	r4,32(r4)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201f0b0:	213fffcc 	andi	r4,r4,65535
 201f0b4:	d9000215 	stw	r4,8(sp)
 201f0b8:	d8c00115 	stw	r3,4(sp)
 201f0bc:	d8800015 	stw	r2,0(sp)
 201f0c0:	e13ffe17 	ldw	r4,-8(fp)
 201f0c4:	2028cf40 	call	2028cf4 <tcp_rst>
              pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 201f0c8:	e13ffe17 	ldw	r4,-8(fp)
 201f0cc:	202176c0 	call	202176c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 201f0d0:	d0e7e117 	ldw	r3,-24700(gp)
 201f0d4:	e0bffe17 	ldw	r2,-8(fp)
 201f0d8:	1880041e 	bne	r3,r2,201f0ec <tcp_close_shutdown+0xd0>
 201f0dc:	d0a7e117 	ldw	r2,-24700(gp)
 201f0e0:	10800417 	ldw	r2,16(r2)
 201f0e4:	d0a7e115 	stw	r2,-24700(gp)
 201f0e8:	00001106 	br	201f130 <tcp_close_shutdown+0x114>
 201f0ec:	d0a7e117 	ldw	r2,-24700(gp)
 201f0f0:	e0bffc15 	stw	r2,-16(fp)
 201f0f4:	00000c06 	br	201f128 <tcp_close_shutdown+0x10c>
 201f0f8:	e0bffc17 	ldw	r2,-16(fp)
 201f0fc:	10c00417 	ldw	r3,16(r2)
 201f100:	e0bffe17 	ldw	r2,-8(fp)
 201f104:	1880051e 	bne	r3,r2,201f11c <tcp_close_shutdown+0x100>
 201f108:	e0bffe17 	ldw	r2,-8(fp)
 201f10c:	10c00417 	ldw	r3,16(r2)
 201f110:	e0bffc17 	ldw	r2,-16(fp)
 201f114:	10c00415 	stw	r3,16(r2)
 201f118:	00000506 	br	201f130 <tcp_close_shutdown+0x114>
 201f11c:	e0bffc17 	ldw	r2,-16(fp)
 201f120:	10800417 	ldw	r2,16(r2)
 201f124:	e0bffc15 	stw	r2,-16(fp)
 201f128:	e0bffc17 	ldw	r2,-16(fp)
 201f12c:	103ff21e 	bne	r2,zero,201f0f8 <__alt_mem_mem_0+0xfcfff0f8>
 201f130:	e0bffe17 	ldw	r2,-8(fp)
 201f134:	10000415 	stw	zero,16(r2)
 201f138:	00800044 	movi	r2,1
 201f13c:	d0a7e085 	stb	r2,-24702(gp)
      /* Deallocate the pcb since we already sent a RST for it */
      if (tcp_input_pcb == pcb) {
 201f140:	d0e7ef17 	ldw	r3,-24644(gp)
 201f144:	e0bffe17 	ldw	r2,-8(fp)
 201f148:	1880021e 	bne	r3,r2,201f154 <tcp_close_shutdown+0x138>
        /* prevent using a deallocated pcb: free it from tcp_input later */
        tcp_trigger_input_pcb_close();
 201f14c:	2025b780 	call	2025b78 <tcp_trigger_input_pcb_close>
 201f150:	00000206 	br	201f15c <tcp_close_shutdown+0x140>
      } else {
        tcp_free(pcb);
 201f154:	e13ffe17 	ldw	r4,-8(fp)
 201f158:	201eda00 	call	201eda0 <tcp_free>
      }
      return ERR_OK;
 201f15c:	0005883a 	mov	r2,zero
 201f160:	00003d06 	br	201f258 <tcp_close_shutdown+0x23c>
    }
  }

  /* - states which free the pcb are handled here,
     - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
  switch (pcb->state) {
 201f164:	e0bffe17 	ldw	r2,-8(fp)
 201f168:	10800617 	ldw	r2,24(r2)
 201f16c:	10c00060 	cmpeqi	r3,r2,1
 201f170:	1800251e 	bne	r3,zero,201f208 <tcp_close_shutdown+0x1ec>
 201f174:	0080032e 	bgeu	zero,r2,201f184 <tcp_close_shutdown+0x168>
 201f178:	108000a0 	cmpeqi	r2,r2,2
 201f17c:	10002a1e 	bne	r2,zero,201f228 <tcp_close_shutdown+0x20c>
 201f180:	00003106 	br	201f248 <tcp_close_shutdown+0x22c>
       * and the user needs some way to free it should the need arise.
       * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
       * or for a pcb that has been used and then entered the CLOSED state
       * is erroneous, but this should never happen as the pcb has in those cases
       * been freed, and so any remaining handles are bogus. */
      if (pcb->local_port != 0) {
 201f184:	e0bffe17 	ldw	r2,-8(fp)
 201f188:	1080078b 	ldhu	r2,30(r2)
 201f18c:	10bfffcc 	andi	r2,r2,65535
 201f190:	10001a26 	beq	r2,zero,201f1fc <tcp_close_shutdown+0x1e0>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 201f194:	d0e7e417 	ldw	r3,-24688(gp)
 201f198:	e0bffe17 	ldw	r2,-8(fp)
 201f19c:	1880041e 	bne	r3,r2,201f1b0 <tcp_close_shutdown+0x194>
 201f1a0:	d0a7e417 	ldw	r2,-24688(gp)
 201f1a4:	10800417 	ldw	r2,16(r2)
 201f1a8:	d0a7e415 	stw	r2,-24688(gp)
 201f1ac:	00001106 	br	201f1f4 <tcp_close_shutdown+0x1d8>
 201f1b0:	d0a7e417 	ldw	r2,-24688(gp)
 201f1b4:	e0bffd15 	stw	r2,-12(fp)
 201f1b8:	00000c06 	br	201f1ec <tcp_close_shutdown+0x1d0>
 201f1bc:	e0bffd17 	ldw	r2,-12(fp)
 201f1c0:	10c00417 	ldw	r3,16(r2)
 201f1c4:	e0bffe17 	ldw	r2,-8(fp)
 201f1c8:	1880051e 	bne	r3,r2,201f1e0 <tcp_close_shutdown+0x1c4>
 201f1cc:	e0bffe17 	ldw	r2,-8(fp)
 201f1d0:	10c00417 	ldw	r3,16(r2)
 201f1d4:	e0bffd17 	ldw	r2,-12(fp)
 201f1d8:	10c00415 	stw	r3,16(r2)
 201f1dc:	00000506 	br	201f1f4 <tcp_close_shutdown+0x1d8>
 201f1e0:	e0bffd17 	ldw	r2,-12(fp)
 201f1e4:	10800417 	ldw	r2,16(r2)
 201f1e8:	e0bffd15 	stw	r2,-12(fp)
 201f1ec:	e0bffd17 	ldw	r2,-12(fp)
 201f1f0:	103ff21e 	bne	r2,zero,201f1bc <__alt_mem_mem_0+0xfcfff1bc>
 201f1f4:	e0bffe17 	ldw	r2,-8(fp)
 201f1f8:	10000415 	stw	zero,16(r2)
      }
      tcp_free(pcb);
 201f1fc:	e13ffe17 	ldw	r4,-8(fp)
 201f200:	201eda00 	call	201eda0 <tcp_free>
      break;
 201f204:	00001306 	br	201f254 <tcp_close_shutdown+0x238>
    case LISTEN:
      tcp_listen_closed(pcb);
 201f208:	e13ffe17 	ldw	r4,-8(fp)
 201f20c:	201eebc0 	call	201eebc <tcp_listen_closed>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 201f210:	e17ffe17 	ldw	r5,-8(fp)
 201f214:	d127e304 	addi	r4,gp,-24692
 201f218:	202185c0 	call	202185c <tcp_pcb_remove>
      tcp_free_listen(pcb);
 201f21c:	e13ffe17 	ldw	r4,-8(fp)
 201f220:	201edd80 	call	201edd8 <tcp_free_listen>
      break;
 201f224:	00000b06 	br	201f254 <tcp_close_shutdown+0x238>
    case SYN_SENT:
      TCP_PCB_REMOVE_ACTIVE(pcb);
 201f228:	e17ffe17 	ldw	r5,-8(fp)
 201f22c:	d127e104 	addi	r4,gp,-24700
 201f230:	202185c0 	call	202185c <tcp_pcb_remove>
 201f234:	00800044 	movi	r2,1
 201f238:	d0a7e085 	stb	r2,-24702(gp)
      tcp_free(pcb);
 201f23c:	e13ffe17 	ldw	r4,-8(fp)
 201f240:	201eda00 	call	201eda0 <tcp_free>
      MIB2_STATS_INC(mib2.tcpattemptfails);
      break;
 201f244:	00000306 	br	201f254 <tcp_close_shutdown+0x238>
    default:
      return tcp_close_shutdown_fin(pcb);
 201f248:	e13ffe17 	ldw	r4,-8(fp)
 201f24c:	201f26c0 	call	201f26c <tcp_close_shutdown_fin>
 201f250:	00000106 	br	201f258 <tcp_close_shutdown+0x23c>
  }
  return ERR_OK;
 201f254:	0005883a 	mov	r2,zero
}
 201f258:	e037883a 	mov	sp,fp
 201f25c:	dfc00117 	ldw	ra,4(sp)
 201f260:	df000017 	ldw	fp,0(sp)
 201f264:	dec00204 	addi	sp,sp,8
 201f268:	f800283a 	ret

0201f26c <tcp_close_shutdown_fin>:

static err_t
tcp_close_shutdown_fin(struct tcp_pcb *pcb)
{
 201f26c:	defffc04 	addi	sp,sp,-16
 201f270:	dfc00315 	stw	ra,12(sp)
 201f274:	df000215 	stw	fp,8(sp)
 201f278:	df000204 	addi	fp,sp,8
 201f27c:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);

  switch (pcb->state) {
 201f280:	e0bfff17 	ldw	r2,-4(fp)
 201f284:	10800617 	ldw	r2,24(r2)
 201f288:	10c00120 	cmpeqi	r3,r2,4
 201f28c:	18000f1e 	bne	r3,zero,201f2cc <tcp_close_shutdown_fin+0x60>
 201f290:	10c001e0 	cmpeqi	r3,r2,7
 201f294:	1800161e 	bne	r3,zero,201f2f0 <tcp_close_shutdown_fin+0x84>
 201f298:	108000e0 	cmpeqi	r2,r2,3
 201f29c:	10001d26 	beq	r2,zero,201f314 <tcp_close_shutdown_fin+0xa8>
    case SYN_RCVD:
      err = tcp_send_fin(pcb);
 201f2a0:	e13fff17 	ldw	r4,-4(fp)
 201f2a4:	20272680 	call	2027268 <tcp_send_fin>
 201f2a8:	e0bffe05 	stb	r2,-8(fp)
      if (err == ERR_OK) {
 201f2ac:	e0bffe07 	ldb	r2,-8(fp)
 201f2b0:	10001a1e 	bne	r2,zero,201f31c <tcp_close_shutdown_fin+0xb0>
        tcp_backlog_accepted(pcb);
 201f2b4:	e13fff17 	ldw	r4,-4(fp)
 201f2b8:	201efa80 	call	201efa8 <tcp_backlog_accepted>
        MIB2_STATS_INC(mib2.tcpattemptfails);
        pcb->state = FIN_WAIT_1;
 201f2bc:	e0bfff17 	ldw	r2,-4(fp)
 201f2c0:	00c00144 	movi	r3,5
 201f2c4:	10c00615 	stw	r3,24(r2)
      }
      break;
 201f2c8:	00001406 	br	201f31c <tcp_close_shutdown_fin+0xb0>
    case ESTABLISHED:
      err = tcp_send_fin(pcb);
 201f2cc:	e13fff17 	ldw	r4,-4(fp)
 201f2d0:	20272680 	call	2027268 <tcp_send_fin>
 201f2d4:	e0bffe05 	stb	r2,-8(fp)
      if (err == ERR_OK) {
 201f2d8:	e0bffe07 	ldb	r2,-8(fp)
 201f2dc:	1000111e 	bne	r2,zero,201f324 <tcp_close_shutdown_fin+0xb8>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = FIN_WAIT_1;
 201f2e0:	e0bfff17 	ldw	r2,-4(fp)
 201f2e4:	00c00144 	movi	r3,5
 201f2e8:	10c00615 	stw	r3,24(r2)
      }
      break;
 201f2ec:	00000d06 	br	201f324 <tcp_close_shutdown_fin+0xb8>
    case CLOSE_WAIT:
      err = tcp_send_fin(pcb);
 201f2f0:	e13fff17 	ldw	r4,-4(fp)
 201f2f4:	20272680 	call	2027268 <tcp_send_fin>
 201f2f8:	e0bffe05 	stb	r2,-8(fp)
      if (err == ERR_OK) {
 201f2fc:	e0bffe07 	ldb	r2,-8(fp)
 201f300:	10000a1e 	bne	r2,zero,201f32c <tcp_close_shutdown_fin+0xc0>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = LAST_ACK;
 201f304:	e0bfff17 	ldw	r2,-4(fp)
 201f308:	00c00244 	movi	r3,9
 201f30c:	10c00615 	stw	r3,24(r2)
      }
      break;
 201f310:	00000606 	br	201f32c <tcp_close_shutdown_fin+0xc0>
    default:
      /* Has already been closed, do nothing. */
      return ERR_OK;
 201f314:	0005883a 	mov	r2,zero
 201f318:	00001606 	br	201f374 <tcp_close_shutdown_fin+0x108>
      if (err == ERR_OK) {
        tcp_backlog_accepted(pcb);
        MIB2_STATS_INC(mib2.tcpattemptfails);
        pcb->state = FIN_WAIT_1;
      }
      break;
 201f31c:	0001883a 	nop
 201f320:	00000306 	br	201f330 <tcp_close_shutdown_fin+0xc4>
      err = tcp_send_fin(pcb);
      if (err == ERR_OK) {
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = FIN_WAIT_1;
      }
      break;
 201f324:	0001883a 	nop
 201f328:	00000106 	br	201f330 <tcp_close_shutdown_fin+0xc4>
      err = tcp_send_fin(pcb);
      if (err == ERR_OK) {
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = LAST_ACK;
      }
      break;
 201f32c:	0001883a 	nop
    default:
      /* Has already been closed, do nothing. */
      return ERR_OK;
  }

  if (err == ERR_OK) {
 201f330:	e0bffe07 	ldb	r2,-8(fp)
 201f334:	1000031e 	bne	r2,zero,201f344 <tcp_close_shutdown_fin+0xd8>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    tcp_output(pcb);
 201f338:	e13fff17 	ldw	r4,-4(fp)
 201f33c:	20275b40 	call	20275b4 <tcp_output>
 201f340:	00000b06 	br	201f370 <tcp_close_shutdown_fin+0x104>
  } else if (err == ERR_MEM) {
 201f344:	e0bffe07 	ldb	r2,-8(fp)
 201f348:	10bfffd8 	cmpnei	r2,r2,-1
 201f34c:	1000081e 	bne	r2,zero,201f370 <tcp_close_shutdown_fin+0x104>
    /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
    tcp_set_flags(pcb, TF_CLOSEPEND);
 201f350:	e0bfff17 	ldw	r2,-4(fp)
 201f354:	1080088b 	ldhu	r2,34(r2)
 201f358:	10800214 	ori	r2,r2,8
 201f35c:	1007883a 	mov	r3,r2
 201f360:	e0bfff17 	ldw	r2,-4(fp)
 201f364:	10c0088d 	sth	r3,34(r2)
    /* We have to return ERR_OK from here to indicate to the callers that this
       pcb should not be used any more as it will be freed soon via tcp_tmr.
       This is OK here since sending FIN does not guarantee a time frime for
       actually freeing the pcb, either (it is left in closure states for
       remote ACK or timeout) */
    return ERR_OK;
 201f368:	0005883a 	mov	r2,zero
 201f36c:	00000106 	br	201f374 <tcp_close_shutdown_fin+0x108>
  }
  return err;
 201f370:	e0bffe03 	ldbu	r2,-8(fp)
}
 201f374:	e037883a 	mov	sp,fp
 201f378:	dfc00117 	ldw	ra,4(sp)
 201f37c:	df000017 	ldw	fp,0(sp)
 201f380:	dec00204 	addi	sp,sp,8
 201f384:	f800283a 	ret

0201f388 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 201f388:	defffd04 	addi	sp,sp,-12
 201f38c:	dfc00215 	stw	ra,8(sp)
 201f390:	df000115 	stw	fp,4(sp)
 201f394:	df000104 	addi	fp,sp,4
 201f398:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
 201f39c:	e0bfff17 	ldw	r2,-4(fp)
 201f3a0:	1000021e 	bne	r2,zero,201f3ac <tcp_close+0x24>
 201f3a4:	00bffc04 	movi	r2,-16
 201f3a8:	00000d06 	br	201f3e0 <tcp_close+0x58>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));

  tcp_debug_print_state(pcb->state);

  if (pcb->state != LISTEN) {
 201f3ac:	e0bfff17 	ldw	r2,-4(fp)
 201f3b0:	10800617 	ldw	r2,24(r2)
 201f3b4:	10800060 	cmpeqi	r2,r2,1
 201f3b8:	1000061e 	bne	r2,zero,201f3d4 <tcp_close+0x4c>
    /* Set a flag not to receive any more data... */
    tcp_set_flags(pcb, TF_RXCLOSED);
 201f3bc:	e0bfff17 	ldw	r2,-4(fp)
 201f3c0:	1080088b 	ldhu	r2,34(r2)
 201f3c4:	10800414 	ori	r2,r2,16
 201f3c8:	1007883a 	mov	r3,r2
 201f3cc:	e0bfff17 	ldw	r2,-4(fp)
 201f3d0:	10c0088d 	sth	r3,34(r2)
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 201f3d4:	01400044 	movi	r5,1
 201f3d8:	e13fff17 	ldw	r4,-4(fp)
 201f3dc:	201f01c0 	call	201f01c <tcp_close_shutdown>
}
 201f3e0:	e037883a 	mov	sp,fp
 201f3e4:	dfc00117 	ldw	ra,4(sp)
 201f3e8:	df000017 	ldw	fp,0(sp)
 201f3ec:	dec00204 	addi	sp,sp,8
 201f3f0:	f800283a 	ret

0201f3f4 <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
 201f3f4:	defffb04 	addi	sp,sp,-20
 201f3f8:	dfc00415 	stw	ra,16(sp)
 201f3fc:	df000315 	stw	fp,12(sp)
 201f400:	df000304 	addi	fp,sp,12
 201f404:	e13ffd15 	stw	r4,-12(fp)
 201f408:	e17ffe15 	stw	r5,-8(fp)
 201f40c:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_shutdown: invalid pcb", pcb != NULL, return ERR_ARG);
 201f410:	e0bffd17 	ldw	r2,-12(fp)
 201f414:	1000021e 	bne	r2,zero,201f420 <tcp_shutdown+0x2c>
 201f418:	00bffc04 	movi	r2,-16
 201f41c:	00003006 	br	201f4e0 <tcp_shutdown+0xec>

  if (pcb->state == LISTEN) {
 201f420:	e0bffd17 	ldw	r2,-12(fp)
 201f424:	10800617 	ldw	r2,24(r2)
 201f428:	10800058 	cmpnei	r2,r2,1
 201f42c:	1000021e 	bne	r2,zero,201f438 <tcp_shutdown+0x44>
    return ERR_CONN;
 201f430:	00bffd44 	movi	r2,-11
 201f434:	00002a06 	br	201f4e0 <tcp_shutdown+0xec>
  }
  if (shut_rx) {
 201f438:	e0bffe17 	ldw	r2,-8(fp)
 201f43c:	10001526 	beq	r2,zero,201f494 <tcp_shutdown+0xa0>
    /* shut down the receive side: set a flag not to receive any more data... */
    tcp_set_flags(pcb, TF_RXCLOSED);
 201f440:	e0bffd17 	ldw	r2,-12(fp)
 201f444:	1080088b 	ldhu	r2,34(r2)
 201f448:	10800414 	ori	r2,r2,16
 201f44c:	1007883a 	mov	r3,r2
 201f450:	e0bffd17 	ldw	r2,-12(fp)
 201f454:	10c0088d 	sth	r3,34(r2)
    if (shut_tx) {
 201f458:	e0bfff17 	ldw	r2,-4(fp)
 201f45c:	10000426 	beq	r2,zero,201f470 <tcp_shutdown+0x7c>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
 201f460:	01400044 	movi	r5,1
 201f464:	e13ffd17 	ldw	r4,-12(fp)
 201f468:	201f01c0 	call	201f01c <tcp_close_shutdown>
 201f46c:	00001c06 	br	201f4e0 <tcp_shutdown+0xec>
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
 201f470:	e0bffd17 	ldw	r2,-12(fp)
 201f474:	10802017 	ldw	r2,128(r2)
 201f478:	10000626 	beq	r2,zero,201f494 <tcp_shutdown+0xa0>
      pbuf_free(pcb->refused_data);
 201f47c:	e0bffd17 	ldw	r2,-12(fp)
 201f480:	10802017 	ldw	r2,128(r2)
 201f484:	1009883a 	mov	r4,r2
 201f488:	201d2f40 	call	201d2f4 <pbuf_free>
      pcb->refused_data = NULL;
 201f48c:	e0bffd17 	ldw	r2,-12(fp)
 201f490:	10002015 	stw	zero,128(r2)
    }
  }
  if (shut_tx) {
 201f494:	e0bfff17 	ldw	r2,-4(fp)
 201f498:	10001026 	beq	r2,zero,201f4dc <tcp_shutdown+0xe8>
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
 201f49c:	e0bffd17 	ldw	r2,-12(fp)
 201f4a0:	10800617 	ldw	r2,24(r2)
 201f4a4:	10c000f0 	cmpltui	r3,r2,3
 201f4a8:	18000a1e 	bne	r3,zero,201f4d4 <tcp_shutdown+0xe0>
 201f4ac:	10c00170 	cmpltui	r3,r2,5
 201f4b0:	1800021e 	bne	r3,zero,201f4bc <tcp_shutdown+0xc8>
 201f4b4:	108001e0 	cmpeqi	r2,r2,7
 201f4b8:	10000626 	beq	r2,zero,201f4d4 <tcp_shutdown+0xe0>
      case SYN_RCVD:
      case ESTABLISHED:
      case CLOSE_WAIT:
        return tcp_close_shutdown(pcb, (u8_t)shut_rx);
 201f4bc:	e0bffe17 	ldw	r2,-8(fp)
 201f4c0:	10803fcc 	andi	r2,r2,255
 201f4c4:	100b883a 	mov	r5,r2
 201f4c8:	e13ffd17 	ldw	r4,-12(fp)
 201f4cc:	201f01c0 	call	201f01c <tcp_close_shutdown>
 201f4d0:	00000306 	br	201f4e0 <tcp_shutdown+0xec>
      default:
        /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
          into CLOSED state, where the PCB is deallocated. */
        return ERR_CONN;
 201f4d4:	00bffd44 	movi	r2,-11
 201f4d8:	00000106 	br	201f4e0 <tcp_shutdown+0xec>
    }
  }
  return ERR_OK;
 201f4dc:	0005883a 	mov	r2,zero
}
 201f4e0:	e037883a 	mov	sp,fp
 201f4e4:	dfc00117 	ldw	ra,4(sp)
 201f4e8:	df000017 	ldw	fp,0(sp)
 201f4ec:	dec00204 	addi	sp,sp,8
 201f4f0:	f800283a 	ret

0201f4f4 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 201f4f4:	defff104 	addi	sp,sp,-60
 201f4f8:	dfc00e15 	stw	ra,56(sp)
 201f4fc:	df000d15 	stw	fp,52(sp)
 201f500:	df000d04 	addi	fp,sp,52
 201f504:	e13ffe15 	stw	r4,-8(fp)
 201f508:	e17fff15 	stw	r5,-4(fp)
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 201f50c:	e0bffe17 	ldw	r2,-8(fp)
 201f510:	10007826 	beq	r2,zero,201f6f4 <tcp_abandon+0x200>
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
              pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 201f514:	e0bffe17 	ldw	r2,-8(fp)
 201f518:	10800617 	ldw	r2,24(r2)
 201f51c:	10800298 	cmpnei	r2,r2,10
 201f520:	1000061e 	bne	r2,zero,201f53c <tcp_abandon+0x48>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 201f524:	e17ffe17 	ldw	r5,-8(fp)
 201f528:	d127e504 	addi	r4,gp,-24684
 201f52c:	202185c0 	call	202185c <tcp_pcb_remove>
    tcp_free(pcb);
 201f530:	e13ffe17 	ldw	r4,-8(fp)
 201f534:	201eda00 	call	201eda0 <tcp_free>
 201f538:	00006f06 	br	201f6f8 <tcp_abandon+0x204>
  } else {
    int send_rst = 0;
 201f53c:	e03ff615 	stw	zero,-40(fp)
    u16_t local_port = 0;
 201f540:	e03ff70d 	sth	zero,-36(fp)
    enum tcp_state last_state;
    seqno = pcb->snd_nxt;
 201f544:	e0bffe17 	ldw	r2,-8(fp)
 201f548:	10801617 	ldw	r2,88(r2)
 201f54c:	e0bff915 	stw	r2,-28(fp)
    ackno = pcb->rcv_nxt;
 201f550:	e0bffe17 	ldw	r2,-8(fp)
 201f554:	10800b17 	ldw	r2,44(r2)
 201f558:	e0bffa15 	stw	r2,-24(fp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 201f55c:	e0bffe17 	ldw	r2,-8(fp)
 201f560:	10802617 	ldw	r2,152(r2)
 201f564:	e0bffb15 	stw	r2,-20(fp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 201f568:	e0bffe17 	ldw	r2,-8(fp)
 201f56c:	10800517 	ldw	r2,20(r2)
 201f570:	e0bffc15 	stw	r2,-16(fp)
    if (pcb->state == CLOSED) {
 201f574:	e0bffe17 	ldw	r2,-8(fp)
 201f578:	10800617 	ldw	r2,24(r2)
 201f57c:	10001f1e 	bne	r2,zero,201f5fc <tcp_abandon+0x108>
      if (pcb->local_port != 0) {
 201f580:	e0bffe17 	ldw	r2,-8(fp)
 201f584:	1080078b 	ldhu	r2,30(r2)
 201f588:	10bfffcc 	andi	r2,r2,65535
 201f58c:	10002526 	beq	r2,zero,201f624 <tcp_abandon+0x130>
        /* bound, not yet opened */
        TCP_RMV(&tcp_bound_pcbs, pcb);
 201f590:	d0e7e417 	ldw	r3,-24688(gp)
 201f594:	e0bffe17 	ldw	r2,-8(fp)
 201f598:	1880041e 	bne	r3,r2,201f5ac <tcp_abandon+0xb8>
 201f59c:	d0a7e417 	ldw	r2,-24688(gp)
 201f5a0:	10800417 	ldw	r2,16(r2)
 201f5a4:	d0a7e415 	stw	r2,-24688(gp)
 201f5a8:	00001106 	br	201f5f0 <tcp_abandon+0xfc>
 201f5ac:	d0a7e417 	ldw	r2,-24688(gp)
 201f5b0:	e0bff815 	stw	r2,-32(fp)
 201f5b4:	00000c06 	br	201f5e8 <tcp_abandon+0xf4>
 201f5b8:	e0bff817 	ldw	r2,-32(fp)
 201f5bc:	10c00417 	ldw	r3,16(r2)
 201f5c0:	e0bffe17 	ldw	r2,-8(fp)
 201f5c4:	1880051e 	bne	r3,r2,201f5dc <tcp_abandon+0xe8>
 201f5c8:	e0bffe17 	ldw	r2,-8(fp)
 201f5cc:	10c00417 	ldw	r3,16(r2)
 201f5d0:	e0bff817 	ldw	r2,-32(fp)
 201f5d4:	10c00415 	stw	r3,16(r2)
 201f5d8:	00000506 	br	201f5f0 <tcp_abandon+0xfc>
 201f5dc:	e0bff817 	ldw	r2,-32(fp)
 201f5e0:	10800417 	ldw	r2,16(r2)
 201f5e4:	e0bff815 	stw	r2,-32(fp)
 201f5e8:	e0bff817 	ldw	r2,-32(fp)
 201f5ec:	103ff21e 	bne	r2,zero,201f5b8 <__alt_mem_mem_0+0xfcfff5b8>
 201f5f0:	e0bffe17 	ldw	r2,-8(fp)
 201f5f4:	10000415 	stw	zero,16(r2)
 201f5f8:	00000a06 	br	201f624 <tcp_abandon+0x130>
      }
    } else {
      send_rst = reset;
 201f5fc:	e0bfff17 	ldw	r2,-4(fp)
 201f600:	e0bff615 	stw	r2,-40(fp)
      local_port = pcb->local_port;
 201f604:	e0bffe17 	ldw	r2,-8(fp)
 201f608:	1080078b 	ldhu	r2,30(r2)
 201f60c:	e0bff70d 	sth	r2,-36(fp)
      TCP_PCB_REMOVE_ACTIVE(pcb);
 201f610:	e17ffe17 	ldw	r5,-8(fp)
 201f614:	d127e104 	addi	r4,gp,-24700
 201f618:	202185c0 	call	202185c <tcp_pcb_remove>
 201f61c:	00800044 	movi	r2,1
 201f620:	d0a7e085 	stb	r2,-24702(gp)
    }
    if (pcb->unacked != NULL) {
 201f624:	e0bffe17 	ldw	r2,-8(fp)
 201f628:	10801e17 	ldw	r2,120(r2)
 201f62c:	10000426 	beq	r2,zero,201f640 <tcp_abandon+0x14c>
      tcp_segs_free(pcb->unacked);
 201f630:	e0bffe17 	ldw	r2,-8(fp)
 201f634:	10801e17 	ldw	r2,120(r2)
 201f638:	1009883a 	mov	r4,r2
 201f63c:	2020e8c0 	call	2020e8c <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 201f640:	e0bffe17 	ldw	r2,-8(fp)
 201f644:	10801d17 	ldw	r2,116(r2)
 201f648:	10000426 	beq	r2,zero,201f65c <tcp_abandon+0x168>
      tcp_segs_free(pcb->unsent);
 201f64c:	e0bffe17 	ldw	r2,-8(fp)
 201f650:	10801d17 	ldw	r2,116(r2)
 201f654:	1009883a 	mov	r4,r2
 201f658:	2020e8c0 	call	2020e8c <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 201f65c:	e0bffe17 	ldw	r2,-8(fp)
 201f660:	10801f17 	ldw	r2,124(r2)
 201f664:	10000426 	beq	r2,zero,201f678 <tcp_abandon+0x184>
      tcp_segs_free(pcb->ooseq);
 201f668:	e0bffe17 	ldw	r2,-8(fp)
 201f66c:	10801f17 	ldw	r2,124(r2)
 201f670:	1009883a 	mov	r4,r2
 201f674:	2020e8c0 	call	2020e8c <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    tcp_backlog_accepted(pcb);
 201f678:	e13ffe17 	ldw	r4,-8(fp)
 201f67c:	201efa80 	call	201efa8 <tcp_backlog_accepted>
    if (send_rst) {
 201f680:	e0bff617 	ldw	r2,-40(fp)
 201f684:	10000f26 	beq	r2,zero,201f6c4 <tcp_abandon+0x1d0>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 201f688:	e17ffe17 	ldw	r5,-8(fp)
 201f68c:	e0bffe17 	ldw	r2,-8(fp)
 201f690:	10800104 	addi	r2,r2,4
 201f694:	e0fff70b 	ldhu	r3,-36(fp)
 201f698:	e13ffe17 	ldw	r4,-8(fp)
 201f69c:	2100080b 	ldhu	r4,32(r4)
 201f6a0:	213fffcc 	andi	r4,r4,65535
 201f6a4:	d9000215 	stw	r4,8(sp)
 201f6a8:	d8c00115 	stw	r3,4(sp)
 201f6ac:	d8800015 	stw	r2,0(sp)
 201f6b0:	280f883a 	mov	r7,r5
 201f6b4:	e1bffa17 	ldw	r6,-24(fp)
 201f6b8:	e17ff917 	ldw	r5,-28(fp)
 201f6bc:	e13ffe17 	ldw	r4,-8(fp)
 201f6c0:	2028cf40 	call	2028cf4 <tcp_rst>
    }
    last_state = pcb->state;
 201f6c4:	e0bffe17 	ldw	r2,-8(fp)
 201f6c8:	10800617 	ldw	r2,24(r2)
 201f6cc:	e0bffd15 	stw	r2,-12(fp)
    tcp_free(pcb);
 201f6d0:	e13ffe17 	ldw	r4,-8(fp)
 201f6d4:	201eda00 	call	201eda0 <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 201f6d8:	e0bffb17 	ldw	r2,-20(fp)
 201f6dc:	10000626 	beq	r2,zero,201f6f8 <tcp_abandon+0x204>
 201f6e0:	e0bffb17 	ldw	r2,-20(fp)
 201f6e4:	017ffcc4 	movi	r5,-13
 201f6e8:	e13ffc17 	ldw	r4,-16(fp)
 201f6ec:	103ee83a 	callr	r2
 201f6f0:	00000106 	br	201f6f8 <tcp_abandon+0x204>
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 201f6f4:	0001883a 	nop
    }
    last_state = pcb->state;
    tcp_free(pcb);
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
  }
}
 201f6f8:	e037883a 	mov	sp,fp
 201f6fc:	dfc00117 	ldw	ra,4(sp)
 201f700:	df000017 	ldw	fp,0(sp)
 201f704:	dec00204 	addi	sp,sp,8
 201f708:	f800283a 	ret

0201f70c <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
 201f70c:	defffd04 	addi	sp,sp,-12
 201f710:	dfc00215 	stw	ra,8(sp)
 201f714:	df000115 	stw	fp,4(sp)
 201f718:	df000104 	addi	fp,sp,4
 201f71c:	e13fff15 	stw	r4,-4(fp)
  tcp_abandon(pcb, 1);
 201f720:	01400044 	movi	r5,1
 201f724:	e13fff17 	ldw	r4,-4(fp)
 201f728:	201f4f40 	call	201f4f4 <tcp_abandon>
}
 201f72c:	0001883a 	nop
 201f730:	e037883a 	mov	sp,fp
 201f734:	dfc00117 	ldw	ra,4(sp)
 201f738:	df000017 	ldw	fp,0(sp)
 201f73c:	dec00204 	addi	sp,sp,8
 201f740:	f800283a 	ret

0201f744 <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 201f744:	defff804 	addi	sp,sp,-32
 201f748:	dfc00715 	stw	ra,28(sp)
 201f74c:	df000615 	stw	fp,24(sp)
 201f750:	df000604 	addi	fp,sp,24
 201f754:	e13ffd15 	stw	r4,-12(fp)
 201f758:	e17ffe15 	stw	r5,-8(fp)
 201f75c:	3005883a 	mov	r2,r6
 201f760:	e0bfff0d 	sth	r2,-4(fp)
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
 201f764:	00800104 	movi	r2,4
 201f768:	e0bffb15 	stw	r2,-20(fp)

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 201f76c:	e0bffe17 	ldw	r2,-8(fp)
 201f770:	1000021e 	bne	r2,zero,201f77c <tcp_bind+0x38>
    ipaddr = IP4_ADDR_ANY;
 201f774:	d0a00e04 	addi	r2,gp,-32712
 201f778:	e0bffe15 	stw	r2,-8(fp)
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("tcp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("tcp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 201f77c:	e0bffd17 	ldw	r2,-12(fp)
 201f780:	1000021e 	bne	r2,zero,201f78c <tcp_bind+0x48>
 201f784:	00bffc04 	movi	r2,-16
 201f788:	00006206 	br	201f914 <tcp_bind+0x1d0>

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 201f78c:	e0bffd17 	ldw	r2,-12(fp)
 201f790:	10800617 	ldw	r2,24(r2)
 201f794:	10000226 	beq	r2,zero,201f7a0 <tcp_bind+0x5c>
 201f798:	00bffe84 	movi	r2,-6
 201f79c:	00005d06 	br	201f914 <tcp_bind+0x1d0>
  /* Unless the REUSEADDR flag is set,
     we have to check the pcbs in TIME-WAIT state, also.
     We do not dump TIME_WAIT pcb's; they can still be matched by incoming
     packets using both local and remote IP addresses and ports to distinguish.
   */
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 201f7a0:	e0bffd17 	ldw	r2,-12(fp)
 201f7a4:	10800243 	ldbu	r2,9(r2)
 201f7a8:	10803fcc 	andi	r2,r2,255
 201f7ac:	1080010c 	andi	r2,r2,4
 201f7b0:	10000226 	beq	r2,zero,201f7bc <tcp_bind+0x78>
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
 201f7b4:	008000c4 	movi	r2,3
 201f7b8:	e0bffb15 	stw	r2,-20(fp)
    ip6_addr_select_zone(ip_2_ip6(&zoned_ipaddr), ip_2_ip6(&zoned_ipaddr));
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  if (port == 0) {
 201f7bc:	e0bfff0b 	ldhu	r2,-4(fp)
 201f7c0:	1000061e 	bne	r2,zero,201f7dc <tcp_bind+0x98>
    port = tcp_new_port();
 201f7c4:	201fe400 	call	201fe40 <tcp_new_port>
 201f7c8:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
 201f7cc:	e0bfff0b 	ldhu	r2,-4(fp)
 201f7d0:	1000391e 	bne	r2,zero,201f8b8 <tcp_bind+0x174>
      return ERR_BUF;
 201f7d4:	00bfff84 	movi	r2,-2
 201f7d8:	00004e06 	br	201f914 <tcp_bind+0x1d0>
    }
  } else {
    /* Check if the address already is in use (on all lists) */
    for (i = 0; i < max_pcb_list; i++) {
 201f7dc:	e03ffa15 	stw	zero,-24(fp)
 201f7e0:	00003206 	br	201f8ac <tcp_bind+0x168>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 201f7e4:	00808134 	movhi	r2,516
 201f7e8:	109bf304 	addi	r2,r2,28620
 201f7ec:	e0fffa17 	ldw	r3,-24(fp)
 201f7f0:	18c7883a 	add	r3,r3,r3
 201f7f4:	18c7883a 	add	r3,r3,r3
 201f7f8:	10c5883a 	add	r2,r2,r3
 201f7fc:	10800017 	ldw	r2,0(r2)
 201f800:	10800017 	ldw	r2,0(r2)
 201f804:	e0bffc15 	stw	r2,-16(fp)
 201f808:	00002306 	br	201f898 <tcp_bind+0x154>
        if (cpcb->local_port == port) {
 201f80c:	e0bffc17 	ldw	r2,-16(fp)
 201f810:	1080078b 	ldhu	r2,30(r2)
 201f814:	10ffffcc 	andi	r3,r2,65535
 201f818:	e0bfff0b 	ldhu	r2,-4(fp)
 201f81c:	18801b1e 	bne	r3,r2,201f88c <tcp_bind+0x148>
#if SO_REUSE
          /* Omit checking for the same port if both pcbs have REUSEADDR set.
             For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
             tcp_connect. */
          if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 201f820:	e0bffd17 	ldw	r2,-12(fp)
 201f824:	10800243 	ldbu	r2,9(r2)
 201f828:	10803fcc 	andi	r2,r2,255
 201f82c:	1080010c 	andi	r2,r2,4
 201f830:	10000526 	beq	r2,zero,201f848 <tcp_bind+0x104>
              !ip_get_option(cpcb, SOF_REUSEADDR))
 201f834:	e0bffc17 	ldw	r2,-16(fp)
 201f838:	10800243 	ldbu	r2,9(r2)
 201f83c:	10803fcc 	andi	r2,r2,255
 201f840:	1080010c 	andi	r2,r2,4
        if (cpcb->local_port == port) {
#if SO_REUSE
          /* Omit checking for the same port if both pcbs have REUSEADDR set.
             For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
             tcp_connect. */
          if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 201f844:	1000111e 	bne	r2,zero,201f88c <tcp_bind+0x148>
              !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
          {
            /* @todo: check accept_any_ip_version */
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
                (ip_addr_isany(&cpcb->local_ip) ||
 201f848:	e0bffc17 	ldw	r2,-16(fp)
          if (!ip_get_option(pcb, SOF_REUSEADDR) ||
              !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
          {
            /* @todo: check accept_any_ip_version */
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 201f84c:	10000d26 	beq	r2,zero,201f884 <tcp_bind+0x140>
                (ip_addr_isany(&cpcb->local_ip) ||
 201f850:	e0bffc17 	ldw	r2,-16(fp)
 201f854:	10800017 	ldw	r2,0(r2)
 201f858:	10000a26 	beq	r2,zero,201f884 <tcp_bind+0x140>
 201f85c:	e0bffe17 	ldw	r2,-8(fp)
 201f860:	10000826 	beq	r2,zero,201f884 <tcp_bind+0x140>
                 ip_addr_isany(ipaddr) ||
 201f864:	e0bffe17 	ldw	r2,-8(fp)
 201f868:	10800017 	ldw	r2,0(r2)
 201f86c:	10000526 	beq	r2,zero,201f884 <tcp_bind+0x140>
                 ip_addr_cmp(&cpcb->local_ip, ipaddr))) {
 201f870:	e0bffc17 	ldw	r2,-16(fp)
 201f874:	10c00017 	ldw	r3,0(r2)
 201f878:	e0bffe17 	ldw	r2,-8(fp)
 201f87c:	10800017 	ldw	r2,0(r2)
          if (!ip_get_option(pcb, SOF_REUSEADDR) ||
              !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
          {
            /* @todo: check accept_any_ip_version */
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 201f880:	1880021e 	bne	r3,r2,201f88c <tcp_bind+0x148>
                (ip_addr_isany(&cpcb->local_ip) ||
                 ip_addr_isany(ipaddr) ||
                 ip_addr_cmp(&cpcb->local_ip, ipaddr))) {
              return ERR_USE;
 201f884:	00bffe04 	movi	r2,-8
 201f888:	00002206 	br	201f914 <tcp_bind+0x1d0>
      return ERR_BUF;
    }
  } else {
    /* Check if the address already is in use (on all lists) */
    for (i = 0; i < max_pcb_list; i++) {
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 201f88c:	e0bffc17 	ldw	r2,-16(fp)
 201f890:	10800417 	ldw	r2,16(r2)
 201f894:	e0bffc15 	stw	r2,-16(fp)
 201f898:	e0bffc17 	ldw	r2,-16(fp)
 201f89c:	103fdb1e 	bne	r2,zero,201f80c <__alt_mem_mem_0+0xfcfff80c>
    if (port == 0) {
      return ERR_BUF;
    }
  } else {
    /* Check if the address already is in use (on all lists) */
    for (i = 0; i < max_pcb_list; i++) {
 201f8a0:	e0bffa17 	ldw	r2,-24(fp)
 201f8a4:	10800044 	addi	r2,r2,1
 201f8a8:	e0bffa15 	stw	r2,-24(fp)
 201f8ac:	e0fffa17 	ldw	r3,-24(fp)
 201f8b0:	e0bffb17 	ldw	r2,-20(fp)
 201f8b4:	18bfcb16 	blt	r3,r2,201f7e4 <__alt_mem_mem_0+0xfcfff7e4>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)
 201f8b8:	e0bffe17 	ldw	r2,-8(fp)
 201f8bc:	10000b26 	beq	r2,zero,201f8ec <tcp_bind+0x1a8>
 201f8c0:	e0bffe17 	ldw	r2,-8(fp)
 201f8c4:	10800017 	ldw	r2,0(r2)
 201f8c8:	10000826 	beq	r2,zero,201f8ec <tcp_bind+0x1a8>
#if LWIP_IPV4 && LWIP_IPV6
      || (IP_GET_TYPE(ipaddr) != IP_GET_TYPE(&pcb->local_ip))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
     ) {
    ip_addr_set(&pcb->local_ip, ipaddr);
 201f8cc:	e0bffe17 	ldw	r2,-8(fp)
 201f8d0:	10000326 	beq	r2,zero,201f8e0 <tcp_bind+0x19c>
 201f8d4:	e0bffe17 	ldw	r2,-8(fp)
 201f8d8:	10800017 	ldw	r2,0(r2)
 201f8dc:	00000106 	br	201f8e4 <tcp_bind+0x1a0>
 201f8e0:	0005883a 	mov	r2,zero
 201f8e4:	e0fffd17 	ldw	r3,-12(fp)
 201f8e8:	18800015 	stw	r2,0(r3)
  }
  pcb->local_port = port;
 201f8ec:	e0bffd17 	ldw	r2,-12(fp)
 201f8f0:	e0ffff0b 	ldhu	r3,-4(fp)
 201f8f4:	10c0078d 	sth	r3,30(r2)
  TCP_REG(&tcp_bound_pcbs, pcb);
 201f8f8:	d0e7e417 	ldw	r3,-24688(gp)
 201f8fc:	e0bffd17 	ldw	r2,-12(fp)
 201f900:	10c00415 	stw	r3,16(r2)
 201f904:	e0bffd17 	ldw	r2,-12(fp)
 201f908:	d0a7e415 	stw	r2,-24688(gp)
 201f90c:	20292b80 	call	20292b8 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 201f910:	0005883a 	mov	r2,zero
}
 201f914:	e037883a 	mov	sp,fp
 201f918:	dfc00117 	ldw	ra,4(sp)
 201f91c:	df000017 	ldw	fp,0(sp)
 201f920:	dec00204 	addi	sp,sp,8
 201f924:	f800283a 	ret

0201f928 <tcp_bind_netif>:
 * @param pcb the tcp_pcb to bind.
 * @param netif the netif to bind to. Can be NULL.
 */
void
tcp_bind_netif(struct tcp_pcb *pcb, const struct netif *netif)
{
 201f928:	defffd04 	addi	sp,sp,-12
 201f92c:	df000215 	stw	fp,8(sp)
 201f930:	df000204 	addi	fp,sp,8
 201f934:	e13ffe15 	stw	r4,-8(fp)
 201f938:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  if (netif != NULL) {
 201f93c:	e0bfff17 	ldw	r2,-4(fp)
 201f940:	10000726 	beq	r2,zero,201f960 <tcp_bind_netif+0x38>
    pcb->netif_idx = netif_get_index(netif);
 201f944:	e0bfff17 	ldw	r2,-4(fp)
 201f948:	10801003 	ldbu	r2,64(r2)
 201f94c:	10800044 	addi	r2,r2,1
 201f950:	1007883a 	mov	r3,r2
 201f954:	e0bffe17 	ldw	r2,-8(fp)
 201f958:	10c00205 	stb	r3,8(r2)
  } else {
    pcb->netif_idx = NETIF_NO_INDEX;
  }
}
 201f95c:	00000206 	br	201f968 <tcp_bind_netif+0x40>
{
  LWIP_ASSERT_CORE_LOCKED();
  if (netif != NULL) {
    pcb->netif_idx = netif_get_index(netif);
  } else {
    pcb->netif_idx = NETIF_NO_INDEX;
 201f960:	e0bffe17 	ldw	r2,-8(fp)
 201f964:	10000205 	stb	zero,8(r2)
  }
}
 201f968:	0001883a 	nop
 201f96c:	e037883a 	mov	sp,fp
 201f970:	df000017 	ldw	fp,0(sp)
 201f974:	dec00104 	addi	sp,sp,4
 201f978:	f800283a 	ret

0201f97c <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
 201f97c:	defffb04 	addi	sp,sp,-20
 201f980:	dfc00415 	stw	ra,16(sp)
 201f984:	df000315 	stw	fp,12(sp)
 201f988:	df000304 	addi	fp,sp,12
 201f98c:	e13ffd15 	stw	r4,-12(fp)
 201f990:	e17ffe15 	stw	r5,-8(fp)
 201f994:	3005883a 	mov	r2,r6
 201f998:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(err);

  LWIP_ASSERT("tcp_accept_null: invalid pcb", pcb != NULL);

  tcp_abort(pcb);
 201f99c:	e13ffe17 	ldw	r4,-8(fp)
 201f9a0:	201f70c0 	call	201f70c <tcp_abort>

  return ERR_ABRT;
 201f9a4:	00bffcc4 	movi	r2,-13
}
 201f9a8:	e037883a 	mov	sp,fp
 201f9ac:	dfc00117 	ldw	ra,4(sp)
 201f9b0:	df000017 	ldw	fp,0(sp)
 201f9b4:	dec00204 	addi	sp,sp,8
 201f9b8:	f800283a 	ret

0201f9bc <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen_with_backlog(tpcb, backlog);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 201f9bc:	defffc04 	addi	sp,sp,-16
 201f9c0:	dfc00315 	stw	ra,12(sp)
 201f9c4:	df000215 	stw	fp,8(sp)
 201f9c8:	df000204 	addi	fp,sp,8
 201f9cc:	e13ffe15 	stw	r4,-8(fp)
 201f9d0:	2805883a 	mov	r2,r5
 201f9d4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  return tcp_listen_with_backlog_and_err(pcb, backlog, NULL);
 201f9d8:	e0bfff03 	ldbu	r2,-4(fp)
 201f9dc:	000d883a 	mov	r6,zero
 201f9e0:	100b883a 	mov	r5,r2
 201f9e4:	e13ffe17 	ldw	r4,-8(fp)
 201f9e8:	201fa000 	call	201fa00 <tcp_listen_with_backlog_and_err>
}
 201f9ec:	e037883a 	mov	sp,fp
 201f9f0:	dfc00117 	ldw	ra,4(sp)
 201f9f4:	df000017 	ldw	fp,0(sp)
 201f9f8:	dec00204 	addi	sp,sp,8
 201f9fc:	f800283a 	ret

0201fa00 <tcp_listen_with_backlog_and_err>:
 *       called like this:
 *             tpcb = tcp_listen_with_backlog_and_err(tpcb, backlog, &err);
 */
struct tcp_pcb *
tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err)
{
 201fa00:	defff804 	addi	sp,sp,-32
 201fa04:	dfc00715 	stw	ra,28(sp)
 201fa08:	df000615 	stw	fp,24(sp)
 201fa0c:	df000604 	addi	fp,sp,24
 201fa10:	e13ffd15 	stw	r4,-12(fp)
 201fa14:	2805883a 	mov	r2,r5
 201fa18:	e1bfff15 	stw	r6,-4(fp)
 201fa1c:	e0bffe05 	stb	r2,-8(fp)
  struct tcp_pcb_listen *lpcb = NULL;
 201fa20:	e03ffa15 	stw	zero,-24(fp)

  LWIP_UNUSED_ARG(backlog);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_listen_with_backlog_and_err: invalid pcb", pcb != NULL, res = ERR_ARG; goto done);
 201fa24:	e0bffd17 	ldw	r2,-12(fp)
 201fa28:	1000031e 	bne	r2,zero,201fa38 <tcp_listen_with_backlog_and_err+0x38>
 201fa2c:	00bffc04 	movi	r2,-16
 201fa30:	e0bffb05 	stb	r2,-20(fp)
 201fa34:	00008906 	br	201fc5c <tcp_listen_with_backlog_and_err+0x25c>
  LWIP_ERROR("tcp_listen_with_backlog_and_err: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
 201fa38:	e0bffd17 	ldw	r2,-12(fp)
 201fa3c:	10800617 	ldw	r2,24(r2)
 201fa40:	10000326 	beq	r2,zero,201fa50 <tcp_listen_with_backlog_and_err+0x50>
 201fa44:	00bffc44 	movi	r2,-15
 201fa48:	e0bffb05 	stb	r2,-20(fp)
 201fa4c:	00008306 	br	201fc5c <tcp_listen_with_backlog_and_err+0x25c>

  /* already listening? */
  if (pcb->state == LISTEN) {
 201fa50:	e0bffd17 	ldw	r2,-12(fp)
 201fa54:	10800617 	ldw	r2,24(r2)
 201fa58:	10800058 	cmpnei	r2,r2,1
 201fa5c:	1000051e 	bne	r2,zero,201fa74 <tcp_listen_with_backlog_and_err+0x74>
    lpcb = (struct tcp_pcb_listen *)pcb;
 201fa60:	e0bffd17 	ldw	r2,-12(fp)
 201fa64:	e0bffa15 	stw	r2,-24(fp)
    res = ERR_ALREADY;
 201fa68:	00bffdc4 	movi	r2,-9
 201fa6c:	e0bffb05 	stb	r2,-20(fp)
    goto done;
 201fa70:	00007a06 	br	201fc5c <tcp_listen_with_backlog_and_err+0x25c>
  }
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 201fa74:	e0bffd17 	ldw	r2,-12(fp)
 201fa78:	10800243 	ldbu	r2,9(r2)
 201fa7c:	10803fcc 	andi	r2,r2,255
 201fa80:	1080010c 	andi	r2,r2,4
 201fa84:	10001826 	beq	r2,zero,201fae8 <tcp_listen_with_backlog_and_err+0xe8>
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 201fa88:	d0a7e317 	ldw	r2,-24692(gp)
 201fa8c:	e0bffa15 	stw	r2,-24(fp)
 201fa90:	00001306 	br	201fae0 <tcp_listen_with_backlog_and_err+0xe0>
      if ((lpcb->local_port == pcb->local_port) &&
 201fa94:	e0bffa17 	ldw	r2,-24(fp)
 201fa98:	10c0078b 	ldhu	r3,30(r2)
 201fa9c:	e0bffd17 	ldw	r2,-12(fp)
 201faa0:	1080078b 	ldhu	r2,30(r2)
 201faa4:	18ffffcc 	andi	r3,r3,65535
 201faa8:	10bfffcc 	andi	r2,r2,65535
 201faac:	1880091e 	bne	r3,r2,201fad4 <tcp_listen_with_backlog_and_err+0xd4>
          ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
 201fab0:	e0bffa17 	ldw	r2,-24(fp)
 201fab4:	10c00017 	ldw	r3,0(r2)
 201fab8:	e0bffd17 	ldw	r2,-12(fp)
 201fabc:	10800017 	ldw	r2,0(r2)
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((lpcb->local_port == pcb->local_port) &&
 201fac0:	1880041e 	bne	r3,r2,201fad4 <tcp_listen_with_backlog_and_err+0xd4>
          ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
        /* this address/port is already used */
        lpcb = NULL;
 201fac4:	e03ffa15 	stw	zero,-24(fp)
        res = ERR_USE;
 201fac8:	00bffe04 	movi	r2,-8
 201facc:	e0bffb05 	stb	r2,-20(fp)
        goto done;
 201fad0:	00006206 	br	201fc5c <tcp_listen_with_backlog_and_err+0x25c>
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 201fad4:	e0bffa17 	ldw	r2,-24(fp)
 201fad8:	10800417 	ldw	r2,16(r2)
 201fadc:	e0bffa15 	stw	r2,-24(fp)
 201fae0:	e0bffa17 	ldw	r2,-24(fp)
 201fae4:	103feb1e 	bne	r2,zero,201fa94 <__alt_mem_mem_0+0xfcfffa94>
        goto done;
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 201fae8:	010000c4 	movi	r4,3
 201faec:	201b82c0 	call	201b82c <memp_malloc>
 201faf0:	e0bffa15 	stw	r2,-24(fp)
  if (lpcb == NULL) {
 201faf4:	e0bffa17 	ldw	r2,-24(fp)
 201faf8:	1000031e 	bne	r2,zero,201fb08 <tcp_listen_with_backlog_and_err+0x108>
    res = ERR_MEM;
 201fafc:	00bfffc4 	movi	r2,-1
 201fb00:	e0bffb05 	stb	r2,-20(fp)
    goto done;
 201fb04:	00005506 	br	201fc5c <tcp_listen_with_backlog_and_err+0x25c>
  }
  lpcb->callback_arg = pcb->callback_arg;
 201fb08:	e0bffd17 	ldw	r2,-12(fp)
 201fb0c:	10c00517 	ldw	r3,20(r2)
 201fb10:	e0bffa17 	ldw	r2,-24(fp)
 201fb14:	10c00515 	stw	r3,20(r2)
  lpcb->local_port = pcb->local_port;
 201fb18:	e0bffd17 	ldw	r2,-12(fp)
 201fb1c:	10c0078b 	ldhu	r3,30(r2)
 201fb20:	e0bffa17 	ldw	r2,-24(fp)
 201fb24:	10c0078d 	sth	r3,30(r2)
  lpcb->state = LISTEN;
 201fb28:	e0bffa17 	ldw	r2,-24(fp)
 201fb2c:	00c00044 	movi	r3,1
 201fb30:	10c00615 	stw	r3,24(r2)
  lpcb->prio = pcb->prio;
 201fb34:	e0bffd17 	ldw	r2,-12(fp)
 201fb38:	10c00703 	ldbu	r3,28(r2)
 201fb3c:	e0bffa17 	ldw	r2,-24(fp)
 201fb40:	10c00705 	stb	r3,28(r2)
  lpcb->so_options = pcb->so_options;
 201fb44:	e0bffd17 	ldw	r2,-12(fp)
 201fb48:	10c00243 	ldbu	r3,9(r2)
 201fb4c:	e0bffa17 	ldw	r2,-24(fp)
 201fb50:	10c00245 	stb	r3,9(r2)
  lpcb->netif_idx = NETIF_NO_INDEX;
 201fb54:	e0bffa17 	ldw	r2,-24(fp)
 201fb58:	10000205 	stb	zero,8(r2)
  lpcb->ttl = pcb->ttl;
 201fb5c:	e0bffd17 	ldw	r2,-12(fp)
 201fb60:	10c002c3 	ldbu	r3,11(r2)
 201fb64:	e0bffa17 	ldw	r2,-24(fp)
 201fb68:	10c002c5 	stb	r3,11(r2)
  lpcb->tos = pcb->tos;
 201fb6c:	e0bffd17 	ldw	r2,-12(fp)
 201fb70:	10c00283 	ldbu	r3,10(r2)
 201fb74:	e0bffa17 	ldw	r2,-24(fp)
 201fb78:	10c00285 	stb	r3,10(r2)
  lpcb->netif_hints.tci = pcb->netif_hints.tci;
#endif /* LWIP_VLAN_PCP */
#if LWIP_IPV4 && LWIP_IPV6
  IP_SET_TYPE_VAL(lpcb->remote_ip, pcb->local_ip.type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 201fb7c:	e0bffd17 	ldw	r2,-12(fp)
 201fb80:	10c00017 	ldw	r3,0(r2)
 201fb84:	e0bffa17 	ldw	r2,-24(fp)
 201fb88:	10c00015 	stw	r3,0(r2)
  if (pcb->local_port != 0) {
 201fb8c:	e0bffd17 	ldw	r2,-12(fp)
 201fb90:	1080078b 	ldhu	r2,30(r2)
 201fb94:	10bfffcc 	andi	r2,r2,65535
 201fb98:	10001a26 	beq	r2,zero,201fc04 <tcp_listen_with_backlog_and_err+0x204>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 201fb9c:	d0e7e417 	ldw	r3,-24688(gp)
 201fba0:	e0bffd17 	ldw	r2,-12(fp)
 201fba4:	1880041e 	bne	r3,r2,201fbb8 <tcp_listen_with_backlog_and_err+0x1b8>
 201fba8:	d0a7e417 	ldw	r2,-24688(gp)
 201fbac:	10800417 	ldw	r2,16(r2)
 201fbb0:	d0a7e415 	stw	r2,-24688(gp)
 201fbb4:	00001106 	br	201fbfc <tcp_listen_with_backlog_and_err+0x1fc>
 201fbb8:	d0a7e417 	ldw	r2,-24688(gp)
 201fbbc:	e0bffc15 	stw	r2,-16(fp)
 201fbc0:	00000c06 	br	201fbf4 <tcp_listen_with_backlog_and_err+0x1f4>
 201fbc4:	e0bffc17 	ldw	r2,-16(fp)
 201fbc8:	10c00417 	ldw	r3,16(r2)
 201fbcc:	e0bffd17 	ldw	r2,-12(fp)
 201fbd0:	1880051e 	bne	r3,r2,201fbe8 <tcp_listen_with_backlog_and_err+0x1e8>
 201fbd4:	e0bffd17 	ldw	r2,-12(fp)
 201fbd8:	10c00417 	ldw	r3,16(r2)
 201fbdc:	e0bffc17 	ldw	r2,-16(fp)
 201fbe0:	10c00415 	stw	r3,16(r2)
 201fbe4:	00000506 	br	201fbfc <tcp_listen_with_backlog_and_err+0x1fc>
 201fbe8:	e0bffc17 	ldw	r2,-16(fp)
 201fbec:	10800417 	ldw	r2,16(r2)
 201fbf0:	e0bffc15 	stw	r2,-16(fp)
 201fbf4:	e0bffc17 	ldw	r2,-16(fp)
 201fbf8:	103ff21e 	bne	r2,zero,201fbc4 <__alt_mem_mem_0+0xfcfffbc4>
 201fbfc:	e0bffd17 	ldw	r2,-12(fp)
 201fc00:	10000415 	stw	zero,16(r2)
  }
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  /* copy over ext_args to listening pcb  */
  memcpy(&lpcb->ext_args, &pcb->ext_args, sizeof(pcb->ext_args));
#endif
  tcp_free(pcb);
 201fc04:	e13ffd17 	ldw	r4,-12(fp)
 201fc08:	201eda00 	call	201eda0 <tcp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 201fc0c:	e0fffa17 	ldw	r3,-24(fp)
 201fc10:	008080b4 	movhi	r2,514
 201fc14:	10be5f04 	addi	r2,r2,-1668
 201fc18:	18800815 	stw	r2,32(r3)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
 201fc1c:	e0bffa17 	ldw	r2,-24(fp)
 201fc20:	10000945 	stb	zero,37(r2)
  tcp_backlog_set(lpcb, backlog);
 201fc24:	e0bffe03 	ldbu	r2,-8(fp)
 201fc28:	10000226 	beq	r2,zero,201fc34 <tcp_listen_with_backlog_and_err+0x234>
 201fc2c:	e0bffe03 	ldbu	r2,-8(fp)
 201fc30:	00000106 	br	201fc38 <tcp_listen_with_backlog_and_err+0x238>
 201fc34:	00800044 	movi	r2,1
 201fc38:	e0fffa17 	ldw	r3,-24(fp)
 201fc3c:	18800905 	stb	r2,36(r3)
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 201fc40:	d0e7e317 	ldw	r3,-24692(gp)
 201fc44:	e0bffa17 	ldw	r2,-24(fp)
 201fc48:	10c00415 	stw	r3,16(r2)
 201fc4c:	e0bffa17 	ldw	r2,-24(fp)
 201fc50:	d0a7e315 	stw	r2,-24692(gp)
 201fc54:	20292b80 	call	20292b8 <tcp_timer_needed>
  res = ERR_OK;
 201fc58:	e03ffb05 	stb	zero,-20(fp)
done:
  if (err != NULL) {
 201fc5c:	e0bfff17 	ldw	r2,-4(fp)
 201fc60:	10000326 	beq	r2,zero,201fc70 <tcp_listen_with_backlog_and_err+0x270>
    *err = res;
 201fc64:	e0bfff17 	ldw	r2,-4(fp)
 201fc68:	e0fffb03 	ldbu	r3,-20(fp)
 201fc6c:	10c00005 	stb	r3,0(r2)
  }
  return (struct tcp_pcb *)lpcb;
 201fc70:	e0bffa17 	ldw	r2,-24(fp)
}
 201fc74:	e037883a 	mov	sp,fp
 201fc78:	dfc00117 	ldw	ra,4(sp)
 201fc7c:	df000017 	ldw	fp,0(sp)
 201fc80:	dec00204 	addi	sp,sp,8
 201fc84:	f800283a 	ret

0201fc88 <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t
tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 201fc88:	defffc04 	addi	sp,sp,-16
 201fc8c:	df000315 	stw	fp,12(sp)
 201fc90:	df000304 	addi	fp,sp,12
 201fc94:	e13fff15 	stw	r4,-4(fp)
  u32_t new_right_edge;

  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 201fc98:	e0bfff17 	ldw	r2,-4(fp)
 201fc9c:	10c00b17 	ldw	r3,44(r2)
 201fca0:	e0bfff17 	ldw	r2,-4(fp)
 201fca4:	10800c0b 	ldhu	r2,48(r2)
 201fca8:	10bfffcc 	andi	r2,r2,65535
 201fcac:	1885883a 	add	r2,r3,r2
 201fcb0:	e0bffd15 	stw	r2,-12(fp)

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 201fcb4:	e0bfff17 	ldw	r2,-4(fp)
 201fcb8:	10c00d17 	ldw	r3,52(r2)
 201fcbc:	e0bfff17 	ldw	r2,-4(fp)
 201fcc0:	10800e8b 	ldhu	r2,58(r2)
 201fcc4:	10bfffcc 	andi	r2,r2,65535
 201fcc8:	10840068 	cmpgeui	r2,r2,4097
 201fccc:	1000041e 	bne	r2,zero,201fce0 <tcp_update_rcv_ann_wnd+0x58>
 201fcd0:	e0bfff17 	ldw	r2,-4(fp)
 201fcd4:	10800e8b 	ldhu	r2,58(r2)
 201fcd8:	10bfffcc 	andi	r2,r2,65535
 201fcdc:	00000106 	br	201fce4 <tcp_update_rcv_ann_wnd+0x5c>
 201fce0:	00840004 	movi	r2,4096
 201fce4:	1885883a 	add	r2,r3,r2
 201fce8:	e0fffd17 	ldw	r3,-12(fp)
 201fcec:	1885c83a 	sub	r2,r3,r2
 201fcf0:	10000916 	blt	r2,zero,201fd18 <tcp_update_rcv_ann_wnd+0x90>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 201fcf4:	e0bfff17 	ldw	r2,-4(fp)
 201fcf8:	10c00c0b 	ldhu	r3,48(r2)
 201fcfc:	e0bfff17 	ldw	r2,-4(fp)
 201fd00:	10c00c8d 	sth	r3,50(r2)
    return new_right_edge - pcb->rcv_ann_right_edge;
 201fd04:	e0bfff17 	ldw	r2,-4(fp)
 201fd08:	10800d17 	ldw	r2,52(r2)
 201fd0c:	e0fffd17 	ldw	r3,-12(fp)
 201fd10:	1885c83a 	sub	r2,r3,r2
 201fd14:	00001406 	br	201fd68 <tcp_update_rcv_ann_wnd+0xe0>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 201fd18:	e0bfff17 	ldw	r2,-4(fp)
 201fd1c:	10c00b17 	ldw	r3,44(r2)
 201fd20:	e0bfff17 	ldw	r2,-4(fp)
 201fd24:	10800d17 	ldw	r2,52(r2)
 201fd28:	1885c83a 	sub	r2,r3,r2
 201fd2c:	0080030e 	bge	zero,r2,201fd3c <tcp_update_rcv_ann_wnd+0xb4>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 201fd30:	e0bfff17 	ldw	r2,-4(fp)
 201fd34:	10000c8d 	sth	zero,50(r2)
 201fd38:	00000a06 	br	201fd64 <tcp_update_rcv_ann_wnd+0xdc>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 201fd3c:	e0bfff17 	ldw	r2,-4(fp)
 201fd40:	10c00d17 	ldw	r3,52(r2)
 201fd44:	e0bfff17 	ldw	r2,-4(fp)
 201fd48:	10800b17 	ldw	r2,44(r2)
 201fd4c:	1885c83a 	sub	r2,r3,r2
 201fd50:	e0bffe15 	stw	r2,-8(fp)
#if !LWIP_WND_SCALE
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
#endif
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 201fd54:	e0bffe17 	ldw	r2,-8(fp)
 201fd58:	1007883a 	mov	r3,r2
 201fd5c:	e0bfff17 	ldw	r2,-4(fp)
 201fd60:	10c00c8d 	sth	r3,50(r2)
    }
    return 0;
 201fd64:	0005883a 	mov	r2,zero
  }
}
 201fd68:	e037883a 	mov	sp,fp
 201fd6c:	df000017 	ldw	fp,0(sp)
 201fd70:	dec00104 	addi	sp,sp,4
 201fd74:	f800283a 	ret

0201fd78 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 201fd78:	defffa04 	addi	sp,sp,-24
 201fd7c:	dfc00515 	stw	ra,20(sp)
 201fd80:	df000415 	stw	fp,16(sp)
 201fd84:	df000404 	addi	fp,sp,16
 201fd88:	e13ffe15 	stw	r4,-8(fp)
 201fd8c:	2805883a 	mov	r2,r5
 201fd90:	e0bfff0d 	sth	r2,-4(fp)
  u32_t wnd_inflation;
  tcpwnd_size_t rcv_wnd;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 201fd94:	e0bffe17 	ldw	r2,-8(fp)
 201fd98:	10002326 	beq	r2,zero,201fe28 <tcp_recved+0xb0>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
              pcb->state != LISTEN);

  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
 201fd9c:	e0bffe17 	ldw	r2,-8(fp)
 201fda0:	10c00c0b 	ldhu	r3,48(r2)
 201fda4:	e0bfff0b 	ldhu	r2,-4(fp)
 201fda8:	1885883a 	add	r2,r3,r2
 201fdac:	e0bffc0d 	sth	r2,-16(fp)
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
 201fdb0:	e0bffc0b 	ldhu	r2,-16(fp)
 201fdb4:	10880068 	cmpgeui	r2,r2,8193
 201fdb8:	1000051e 	bne	r2,zero,201fdd0 <tcp_recved+0x58>
 201fdbc:	e0bffe17 	ldw	r2,-8(fp)
 201fdc0:	10800c0b 	ldhu	r2,48(r2)
 201fdc4:	10bfffcc 	andi	r2,r2,65535
 201fdc8:	e0fffc0b 	ldhu	r3,-16(fp)
 201fdcc:	1880042e 	bgeu	r3,r2,201fde0 <tcp_recved+0x68>
    /* window got too big or tcpwnd_size_t overflow */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: window got too big or tcpwnd_size_t overflow\n"));
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 201fdd0:	e0bffe17 	ldw	r2,-8(fp)
 201fdd4:	00c80004 	movi	r3,8192
 201fdd8:	10c00c0d 	sth	r3,48(r2)
 201fddc:	00000306 	br	201fdec <tcp_recved+0x74>
  } else  {
    pcb->rcv_wnd = rcv_wnd;
 201fde0:	e0bffe17 	ldw	r2,-8(fp)
 201fde4:	e0fffc0b 	ldhu	r3,-16(fp)
 201fde8:	10c00c0d 	sth	r3,48(r2)
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 201fdec:	e13ffe17 	ldw	r4,-8(fp)
 201fdf0:	201fc880 	call	201fc88 <tcp_update_rcv_ann_wnd>
 201fdf4:	e0bffd15 	stw	r2,-12(fp)

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 201fdf8:	e0bffd17 	ldw	r2,-12(fp)
 201fdfc:	10820030 	cmpltui	r2,r2,2048
 201fe00:	10000a1e 	bne	r2,zero,201fe2c <tcp_recved+0xb4>
    tcp_ack_now(pcb);
 201fe04:	e0bffe17 	ldw	r2,-8(fp)
 201fe08:	1080088b 	ldhu	r2,34(r2)
 201fe0c:	10800094 	ori	r2,r2,2
 201fe10:	1007883a 	mov	r3,r2
 201fe14:	e0bffe17 	ldw	r2,-8(fp)
 201fe18:	10c0088d 	sth	r3,34(r2)
    tcp_output(pcb);
 201fe1c:	e13ffe17 	ldw	r4,-8(fp)
 201fe20:	20275b40 	call	20275b4 <tcp_output>
 201fe24:	00000106 	br	201fe2c <tcp_recved+0xb4>
  u32_t wnd_inflation;
  tcpwnd_size_t rcv_wnd;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 201fe28:	0001883a 	nop
    tcp_output(pcb);
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
                          len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
}
 201fe2c:	e037883a 	mov	sp,fp
 201fe30:	dfc00117 	ldw	ra,4(sp)
 201fe34:	df000017 	ldw	fp,0(sp)
 201fe38:	dec00204 	addi	sp,sp,8
 201fe3c:	f800283a 	ret

0201fe40 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 201fe40:	defffd04 	addi	sp,sp,-12
 201fe44:	df000215 	stw	fp,8(sp)
 201fe48:	df000204 	addi	fp,sp,8
  u8_t i;
  u16_t n = 0;
 201fe4c:	e03ffe8d 	sth	zero,-6(fp)
  struct tcp_pcb *pcb;

again:
  tcp_port++;
 201fe50:	d0a0100b 	ldhu	r2,-32704(gp)
 201fe54:	10800044 	addi	r2,r2,1
 201fe58:	d0a0100d 	sth	r2,-32704(gp)
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
 201fe5c:	d0a0100b 	ldhu	r2,-32704(gp)
 201fe60:	10ffffcc 	andi	r3,r2,65535
 201fe64:	00bfffd4 	movui	r2,65535
 201fe68:	1880021e 	bne	r3,r2,201fe74 <tcp_new_port+0x34>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 201fe6c:	00b00004 	movi	r2,-16384
 201fe70:	d0a0100d 	sth	r2,-32704(gp)
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 201fe74:	e03ffe05 	stb	zero,-8(fp)
 201fe78:	00002006 	br	201fefc <tcp_new_port+0xbc>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 201fe7c:	e0fffe03 	ldbu	r3,-8(fp)
 201fe80:	00808134 	movhi	r2,516
 201fe84:	109bf304 	addi	r2,r2,28620
 201fe88:	18c7883a 	add	r3,r3,r3
 201fe8c:	18c7883a 	add	r3,r3,r3
 201fe90:	10c5883a 	add	r2,r2,r3
 201fe94:	10800017 	ldw	r2,0(r2)
 201fe98:	10800017 	ldw	r2,0(r2)
 201fe9c:	e0bfff15 	stw	r2,-4(fp)
 201fea0:	00001106 	br	201fee8 <tcp_new_port+0xa8>
      if (pcb->local_port == tcp_port) {
 201fea4:	e0bfff17 	ldw	r2,-4(fp)
 201fea8:	10c0078b 	ldhu	r3,30(r2)
 201feac:	d0a0100b 	ldhu	r2,-32704(gp)
 201feb0:	18ffffcc 	andi	r3,r3,65535
 201feb4:	10bfffcc 	andi	r2,r2,65535
 201feb8:	1880081e 	bne	r3,r2,201fedc <tcp_new_port+0x9c>
        n++;
 201febc:	e0bffe8b 	ldhu	r2,-6(fp)
 201fec0:	10800044 	addi	r2,r2,1
 201fec4:	e0bffe8d 	sth	r2,-6(fp)
        if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 201fec8:	e0bffe8b 	ldhu	r2,-6(fp)
 201fecc:	10900030 	cmpltui	r2,r2,16384
 201fed0:	103fdf1e 	bne	r2,zero,201fe50 <__alt_mem_mem_0+0xfcfffe50>
          return 0;
 201fed4:	0005883a 	mov	r2,zero
 201fed8:	00000c06 	br	201ff0c <tcp_new_port+0xcc>
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 201fedc:	e0bfff17 	ldw	r2,-4(fp)
 201fee0:	10800417 	ldw	r2,16(r2)
 201fee4:	e0bfff15 	stw	r2,-4(fp)
 201fee8:	e0bfff17 	ldw	r2,-4(fp)
 201feec:	103fed1e 	bne	r2,zero,201fea4 <__alt_mem_mem_0+0xfcfffea4>
  tcp_port++;
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 201fef0:	e0bffe03 	ldbu	r2,-8(fp)
 201fef4:	10800044 	addi	r2,r2,1
 201fef8:	e0bffe05 	stb	r2,-8(fp)
 201fefc:	e0bffe03 	ldbu	r2,-8(fp)
 201ff00:	10800130 	cmpltui	r2,r2,4
 201ff04:	103fdd1e 	bne	r2,zero,201fe7c <__alt_mem_mem_0+0xfcfffe7c>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 201ff08:	d0a0100b 	ldhu	r2,-32704(gp)
}
 201ff0c:	e037883a 	mov	sp,fp
 201ff10:	df000017 	ldw	fp,0(sp)
 201ff14:	dec00104 	addi	sp,sp,4
 201ff18:	f800283a 	ret

0201ff1c <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
            tcp_connected_fn connected)
{
 201ff1c:	defff204 	addi	sp,sp,-56
 201ff20:	dfc00d15 	stw	ra,52(sp)
 201ff24:	df000c15 	stw	fp,48(sp)
 201ff28:	df000c04 	addi	fp,sp,48
 201ff2c:	e13ffc15 	stw	r4,-16(fp)
 201ff30:	e17ffd15 	stw	r5,-12(fp)
 201ff34:	3005883a 	mov	r2,r6
 201ff38:	e1ffff15 	stw	r7,-4(fp)
 201ff3c:	e0bffe0d 	sth	r2,-8(fp)
  struct netif *netif = NULL;
 201ff40:	e03ff415 	stw	zero,-48(fp)
  u32_t iss;
  u16_t old_local_port;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 201ff44:	e0bffc17 	ldw	r2,-16(fp)
 201ff48:	1000021e 	bne	r2,zero,201ff54 <tcp_connect+0x38>
 201ff4c:	00bffc04 	movi	r2,-16
 201ff50:	0000e906 	br	20202f8 <tcp_connect+0x3dc>
  LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 201ff54:	e0bffd17 	ldw	r2,-12(fp)
 201ff58:	1000021e 	bne	r2,zero,201ff64 <tcp_connect+0x48>
 201ff5c:	00bffc04 	movi	r2,-16
 201ff60:	0000e506 	br	20202f8 <tcp_connect+0x3dc>

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 201ff64:	e0bffc17 	ldw	r2,-16(fp)
 201ff68:	10800617 	ldw	r2,24(r2)
 201ff6c:	10000226 	beq	r2,zero,201ff78 <tcp_connect+0x5c>
 201ff70:	00bffd84 	movi	r2,-10
 201ff74:	0000e006 	br	20202f8 <tcp_connect+0x3dc>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  ip_addr_set(&pcb->remote_ip, ipaddr);
 201ff78:	e0bffd17 	ldw	r2,-12(fp)
 201ff7c:	10000326 	beq	r2,zero,201ff8c <tcp_connect+0x70>
 201ff80:	e0bffd17 	ldw	r2,-12(fp)
 201ff84:	10800017 	ldw	r2,0(r2)
 201ff88:	00000106 	br	201ff90 <tcp_connect+0x74>
 201ff8c:	0005883a 	mov	r2,zero
 201ff90:	e0fffc17 	ldw	r3,-16(fp)
 201ff94:	18800115 	stw	r2,4(r3)
  pcb->remote_port = port;
 201ff98:	e0bffc17 	ldw	r2,-16(fp)
 201ff9c:	e0fffe0b 	ldhu	r3,-8(fp)
 201ffa0:	10c0080d 	sth	r3,32(r2)

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 201ffa4:	e0bffc17 	ldw	r2,-16(fp)
 201ffa8:	10800203 	ldbu	r2,8(r2)
 201ffac:	10803fcc 	andi	r2,r2,255
 201ffb0:	10000726 	beq	r2,zero,201ffd0 <tcp_connect+0xb4>
    netif = netif_get_by_index(pcb->netif_idx);
 201ffb4:	e0bffc17 	ldw	r2,-16(fp)
 201ffb8:	10800203 	ldbu	r2,8(r2)
 201ffbc:	10803fcc 	andi	r2,r2,255
 201ffc0:	1009883a 	mov	r4,r2
 201ffc4:	201c62c0 	call	201c62c <netif_get_by_index>
 201ffc8:	e0bff415 	stw	r2,-48(fp)
 201ffcc:	00000506 	br	201ffe4 <tcp_connect+0xc8>
  } else {
    /* check if we have a route to the remote host */
    netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 201ffd0:	e0bffc17 	ldw	r2,-16(fp)
 201ffd4:	10800104 	addi	r2,r2,4
 201ffd8:	1009883a 	mov	r4,r2
 201ffdc:	203b5c40 	call	203b5c4 <ip4_route>
 201ffe0:	e0bff415 	stw	r2,-48(fp)
  }
  if (netif == NULL) {
 201ffe4:	e0bff417 	ldw	r2,-48(fp)
 201ffe8:	1000021e 	bne	r2,zero,201fff4 <tcp_connect+0xd8>
    /* Don't even try to send a SYN packet if we have no route since that will fail. */
    return ERR_RTE;
 201ffec:	00bfff04 	movi	r2,-4
 201fff0:	0000c106 	br	20202f8 <tcp_connect+0x3dc>
  }

  /* check if local IP has been assigned to pcb, if not, get one */
  if (ip_addr_isany(&pcb->local_ip)) {
 201fff4:	e0bffc17 	ldw	r2,-16(fp)
 201fff8:	10000326 	beq	r2,zero,2020008 <tcp_connect+0xec>
 201fffc:	e0bffc17 	ldw	r2,-16(fp)
 2020000:	10800017 	ldw	r2,0(r2)
 2020004:	10000f1e 	bne	r2,zero,2020044 <tcp_connect+0x128>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, ipaddr);
 2020008:	e0bff417 	ldw	r2,-48(fp)
 202000c:	10000326 	beq	r2,zero,202001c <tcp_connect+0x100>
 2020010:	e0bff417 	ldw	r2,-48(fp)
 2020014:	10800104 	addi	r2,r2,4
 2020018:	00000106 	br	2020020 <tcp_connect+0x104>
 202001c:	0005883a 	mov	r2,zero
 2020020:	e0bff815 	stw	r2,-32(fp)
    if (local_ip == NULL) {
 2020024:	e0bff817 	ldw	r2,-32(fp)
 2020028:	1000021e 	bne	r2,zero,2020034 <tcp_connect+0x118>
      return ERR_RTE;
 202002c:	00bfff04 	movi	r2,-4
 2020030:	0000b106 	br	20202f8 <tcp_connect+0x3dc>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 2020034:	e0bff817 	ldw	r2,-32(fp)
 2020038:	10c00017 	ldw	r3,0(r2)
 202003c:	e0bffc17 	ldw	r2,-16(fp)
 2020040:	10c00015 	stw	r3,0(r2)
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST)) {
    ip6_addr_assign_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST, netif);
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  old_local_port = pcb->local_port;
 2020044:	e0bffc17 	ldw	r2,-16(fp)
 2020048:	1080078b 	ldhu	r2,30(r2)
 202004c:	e0bff90d 	sth	r2,-28(fp)
  if (pcb->local_port == 0) {
 2020050:	e0bffc17 	ldw	r2,-16(fp)
 2020054:	1080078b 	ldhu	r2,30(r2)
 2020058:	10bfffcc 	andi	r2,r2,65535
 202005c:	10000a1e 	bne	r2,zero,2020088 <tcp_connect+0x16c>
    pcb->local_port = tcp_new_port();
 2020060:	201fe400 	call	201fe40 <tcp_new_port>
 2020064:	1007883a 	mov	r3,r2
 2020068:	e0bffc17 	ldw	r2,-16(fp)
 202006c:	10c0078d 	sth	r3,30(r2)
    if (pcb->local_port == 0) {
 2020070:	e0bffc17 	ldw	r2,-16(fp)
 2020074:	1080078b 	ldhu	r2,30(r2)
 2020078:	10bfffcc 	andi	r2,r2,65535
 202007c:	1000371e 	bne	r2,zero,202015c <tcp_connect+0x240>
      return ERR_BUF;
 2020080:	00bfff84 	movi	r2,-2
 2020084:	00009c06 	br	20202f8 <tcp_connect+0x3dc>
    }
  } else {
#if SO_REUSE
    if (ip_get_option(pcb, SOF_REUSEADDR)) {
 2020088:	e0bffc17 	ldw	r2,-16(fp)
 202008c:	10800243 	ldbu	r2,9(r2)
 2020090:	10803fcc 	andi	r2,r2,255
 2020094:	1080010c 	andi	r2,r2,4
 2020098:	10003026 	beq	r2,zero,202015c <tcp_connect+0x240>
      /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 202009c:	00800084 	movi	r2,2
 20200a0:	e0bff615 	stw	r2,-40(fp)
 20200a4:	00002a06 	br	2020150 <tcp_connect+0x234>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 20200a8:	00808134 	movhi	r2,516
 20200ac:	109bf304 	addi	r2,r2,28620
 20200b0:	e0fff617 	ldw	r3,-40(fp)
 20200b4:	18c7883a 	add	r3,r3,r3
 20200b8:	18c7883a 	add	r3,r3,r3
 20200bc:	10c5883a 	add	r2,r2,r3
 20200c0:	10800017 	ldw	r2,0(r2)
 20200c4:	10800017 	ldw	r2,0(r2)
 20200c8:	e0bff515 	stw	r2,-44(fp)
 20200cc:	00001b06 	br	202013c <tcp_connect+0x220>
          if ((cpcb->local_port == pcb->local_port) &&
 20200d0:	e0bff517 	ldw	r2,-44(fp)
 20200d4:	10c0078b 	ldhu	r3,30(r2)
 20200d8:	e0bffc17 	ldw	r2,-16(fp)
 20200dc:	1080078b 	ldhu	r2,30(r2)
 20200e0:	18ffffcc 	andi	r3,r3,65535
 20200e4:	10bfffcc 	andi	r2,r2,65535
 20200e8:	1880111e 	bne	r3,r2,2020130 <tcp_connect+0x214>
              (cpcb->remote_port == port) &&
 20200ec:	e0bff517 	ldw	r2,-44(fp)
 20200f0:	1080080b 	ldhu	r2,32(r2)
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
          if ((cpcb->local_port == pcb->local_port) &&
 20200f4:	10ffffcc 	andi	r3,r2,65535
 20200f8:	e0bffe0b 	ldhu	r2,-8(fp)
 20200fc:	18800c1e 	bne	r3,r2,2020130 <tcp_connect+0x214>
              (cpcb->remote_port == port) &&
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 2020100:	e0bff517 	ldw	r2,-44(fp)
 2020104:	10c00017 	ldw	r3,0(r2)
 2020108:	e0bffc17 	ldw	r2,-16(fp)
 202010c:	10800017 	ldw	r2,0(r2)
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
          if ((cpcb->local_port == pcb->local_port) &&
              (cpcb->remote_port == port) &&
 2020110:	1880071e 	bne	r3,r2,2020130 <tcp_connect+0x214>
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
              ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
 2020114:	e0bff517 	ldw	r2,-44(fp)
 2020118:	10c00117 	ldw	r3,4(r2)
 202011c:	e0bffd17 	ldw	r2,-12(fp)
 2020120:	10800017 	ldw	r2,0(r2)
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
          if ((cpcb->local_port == pcb->local_port) &&
              (cpcb->remote_port == port) &&
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 2020124:	1880021e 	bne	r3,r2,2020130 <tcp_connect+0x214>
              ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
            /* linux returns EISCONN here, but ERR_USE should be OK for us */
            return ERR_USE;
 2020128:	00bffe04 	movi	r2,-8
 202012c:	00007206 	br	20202f8 <tcp_connect+0x3dc>
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 2020130:	e0bff517 	ldw	r2,-44(fp)
 2020134:	10800417 	ldw	r2,16(r2)
 2020138:	e0bff515 	stw	r2,-44(fp)
 202013c:	e0bff517 	ldw	r2,-44(fp)
 2020140:	103fe31e 	bne	r2,zero,20200d0 <__alt_mem_mem_0+0xfd0000d0>
      /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 2020144:	e0bff617 	ldw	r2,-40(fp)
 2020148:	10800044 	addi	r2,r2,1
 202014c:	e0bff615 	stw	r2,-40(fp)
 2020150:	e0bff617 	ldw	r2,-40(fp)
 2020154:	10800110 	cmplti	r2,r2,4
 2020158:	103fd31e 	bne	r2,zero,20200a8 <__alt_mem_mem_0+0xfd0000a8>
      }
    }
#endif /* SO_REUSE */
  }

  iss = tcp_next_iss(pcb);
 202015c:	e13ffc17 	ldw	r4,-16(fp)
 2020160:	20219700 	call	2021970 <tcp_next_iss>
 2020164:	e0bffa15 	stw	r2,-24(fp)
  pcb->rcv_nxt = 0;
 2020168:	e0bffc17 	ldw	r2,-16(fp)
 202016c:	10000b15 	stw	zero,44(r2)
  pcb->snd_nxt = iss;
 2020170:	e0bffc17 	ldw	r2,-16(fp)
 2020174:	e0fffa17 	ldw	r3,-24(fp)
 2020178:	10c01615 	stw	r3,88(r2)
  pcb->lastack = iss - 1;
 202017c:	e0bffa17 	ldw	r2,-24(fp)
 2020180:	10ffffc4 	addi	r3,r2,-1
 2020184:	e0bffc17 	ldw	r2,-16(fp)
 2020188:	10c01315 	stw	r3,76(r2)
  pcb->snd_wl2 = iss - 1;
 202018c:	e0bffa17 	ldw	r2,-24(fp)
 2020190:	10ffffc4 	addi	r3,r2,-1
 2020194:	e0bffc17 	ldw	r2,-16(fp)
 2020198:	10c01815 	stw	r3,96(r2)
  pcb->snd_lbb = iss - 1;
 202019c:	e0bffa17 	ldw	r2,-24(fp)
 20201a0:	10ffffc4 	addi	r3,r2,-1
 20201a4:	e0bffc17 	ldw	r2,-16(fp)
 20201a8:	10c01915 	stw	r3,100(r2)
  /* Start with a window that does not need scaling. When window scaling is
     enabled and used, the window is enlarged when both sides agree on scaling. */
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 20201ac:	e0bffc17 	ldw	r2,-16(fp)
 20201b0:	00c80004 	movi	r3,8192
 20201b4:	10c00c8d 	sth	r3,50(r2)
 20201b8:	e0bffc17 	ldw	r2,-16(fp)
 20201bc:	10c00c8b 	ldhu	r3,50(r2)
 20201c0:	e0bffc17 	ldw	r2,-16(fp)
 20201c4:	10c00c0d 	sth	r3,48(r2)
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 20201c8:	e0bffc17 	ldw	r2,-16(fp)
 20201cc:	10c00b17 	ldw	r3,44(r2)
 20201d0:	e0bffc17 	ldw	r2,-16(fp)
 20201d4:	10c00d15 	stw	r3,52(r2)
  pcb->snd_wnd = TCP_WND;
 20201d8:	e0bffc17 	ldw	r2,-16(fp)
 20201dc:	00c80004 	movi	r3,8192
 20201e0:	10c01a0d 	sth	r3,104(r2)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = INITIAL_MSS;
 20201e4:	e0bffc17 	ldw	r2,-16(fp)
 20201e8:	00c08604 	movi	r3,536
 20201ec:	10c00e8d 	sth	r3,58(r2)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
 20201f0:	e0bffc17 	ldw	r2,-16(fp)
 20201f4:	10800e8b 	ldhu	r2,58(r2)
 20201f8:	10ffffcc 	andi	r3,r2,65535
 20201fc:	e0bffc17 	ldw	r2,-16(fp)
 2020200:	10800104 	addi	r2,r2,4
 2020204:	100d883a 	mov	r6,r2
 2020208:	e17ff417 	ldw	r5,-48(fp)
 202020c:	1809883a 	mov	r4,r3
 2020210:	20219a40 	call	20219a4 <tcp_eff_send_mss_netif>
 2020214:	1007883a 	mov	r3,r2
 2020218:	e0bffc17 	ldw	r2,-16(fp)
 202021c:	10c00e8d 	sth	r3,58(r2)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 2020220:	e0bffc17 	ldw	r2,-16(fp)
 2020224:	00c00044 	movi	r3,1
 2020228:	10c0140d 	sth	r3,80(r2)
#if LWIP_CALLBACK_API
  pcb->connected = connected;
 202022c:	e0bffc17 	ldw	r2,-16(fp)
 2020230:	e0ffff17 	ldw	r3,-4(fp)
 2020234:	10c02415 	stw	r3,144(r2)
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 2020238:	01400084 	movi	r5,2
 202023c:	e13ffc17 	ldw	r4,-16(fp)
 2020240:	20273a80 	call	20273a8 <tcp_enqueue_flags>
 2020244:	e0bffb05 	stb	r2,-20(fp)
  if (ret == ERR_OK) {
 2020248:	e0bffb07 	ldb	r2,-20(fp)
 202024c:	1000291e 	bne	r2,zero,20202f4 <tcp_connect+0x3d8>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
 2020250:	e0bffc17 	ldw	r2,-16(fp)
 2020254:	00c00084 	movi	r3,2
 2020258:	10c00615 	stw	r3,24(r2)
    if (old_local_port != 0) {
 202025c:	e0bff90b 	ldhu	r2,-28(fp)
 2020260:	10001a26 	beq	r2,zero,20202cc <tcp_connect+0x3b0>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 2020264:	d0e7e417 	ldw	r3,-24688(gp)
 2020268:	e0bffc17 	ldw	r2,-16(fp)
 202026c:	1880041e 	bne	r3,r2,2020280 <tcp_connect+0x364>
 2020270:	d0a7e417 	ldw	r2,-24688(gp)
 2020274:	10800417 	ldw	r2,16(r2)
 2020278:	d0a7e415 	stw	r2,-24688(gp)
 202027c:	00001106 	br	20202c4 <tcp_connect+0x3a8>
 2020280:	d0a7e417 	ldw	r2,-24688(gp)
 2020284:	e0bff715 	stw	r2,-36(fp)
 2020288:	00000c06 	br	20202bc <tcp_connect+0x3a0>
 202028c:	e0bff717 	ldw	r2,-36(fp)
 2020290:	10c00417 	ldw	r3,16(r2)
 2020294:	e0bffc17 	ldw	r2,-16(fp)
 2020298:	1880051e 	bne	r3,r2,20202b0 <tcp_connect+0x394>
 202029c:	e0bffc17 	ldw	r2,-16(fp)
 20202a0:	10c00417 	ldw	r3,16(r2)
 20202a4:	e0bff717 	ldw	r2,-36(fp)
 20202a8:	10c00415 	stw	r3,16(r2)
 20202ac:	00000506 	br	20202c4 <tcp_connect+0x3a8>
 20202b0:	e0bff717 	ldw	r2,-36(fp)
 20202b4:	10800417 	ldw	r2,16(r2)
 20202b8:	e0bff715 	stw	r2,-36(fp)
 20202bc:	e0bff717 	ldw	r2,-36(fp)
 20202c0:	103ff21e 	bne	r2,zero,202028c <__alt_mem_mem_0+0xfd00028c>
 20202c4:	e0bffc17 	ldw	r2,-16(fp)
 20202c8:	10000415 	stw	zero,16(r2)
    }
    TCP_REG_ACTIVE(pcb);
 20202cc:	d0e7e117 	ldw	r3,-24700(gp)
 20202d0:	e0bffc17 	ldw	r2,-16(fp)
 20202d4:	10c00415 	stw	r3,16(r2)
 20202d8:	e0bffc17 	ldw	r2,-16(fp)
 20202dc:	d0a7e115 	stw	r2,-24700(gp)
 20202e0:	20292b80 	call	20292b8 <tcp_timer_needed>
 20202e4:	00800044 	movi	r2,1
 20202e8:	d0a7e085 	stb	r2,-24702(gp)
    MIB2_STATS_INC(mib2.tcpactiveopens);

    tcp_output(pcb);
 20202ec:	e13ffc17 	ldw	r4,-16(fp)
 20202f0:	20275b40 	call	20275b4 <tcp_output>
  }
  return ret;
 20202f4:	e0bffb03 	ldbu	r2,-20(fp)
}
 20202f8:	e037883a 	mov	sp,fp
 20202fc:	dfc00117 	ldw	ra,4(sp)
 2020300:	df000017 	ldw	fp,0(sp)
 2020304:	dec00204 	addi	sp,sp,8
 2020308:	f800283a 	ret

0202030c <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 202030c:	deffee04 	addi	sp,sp,-72
 2020310:	dfc01115 	stw	ra,68(sp)
 2020314:	df001015 	stw	fp,64(sp)
 2020318:	dc000f15 	stw	r16,60(sp)
 202031c:	df001004 	addi	fp,sp,64
  tcpwnd_size_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 2020320:	e03ff585 	stb	zero,-42(fp)

  ++tcp_ticks;
 2020324:	d0a7e217 	ldw	r2,-24696(gp)
 2020328:	10800044 	addi	r2,r2,1
 202032c:	d0a7e215 	stw	r2,-24696(gp)
  ++tcp_timer_ctr;
 2020330:	d0a7e043 	ldbu	r2,-24703(gp)
 2020334:	10800044 	addi	r2,r2,1
 2020338:	d0a7e045 	stb	r2,-24703(gp)

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
 202033c:	e03ff415 	stw	zero,-48(fp)
  pcb = tcp_active_pcbs;
 2020340:	d0a7e117 	ldw	r2,-24700(gp)
 2020344:	e0bff315 	stw	r2,-52(fp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 2020348:	0001d906 	br	2020ab0 <tcp_slowtmr+0x7a4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
 202034c:	e0bff317 	ldw	r2,-52(fp)
 2020350:	10c00983 	ldbu	r3,38(r2)
 2020354:	d0a7e043 	ldbu	r2,-24703(gp)
 2020358:	18c03fcc 	andi	r3,r3,255
 202035c:	10803fcc 	andi	r2,r2,255
 2020360:	1880061e 	bne	r3,r2,202037c <tcp_slowtmr+0x70>
      /* skip this pcb, we have already processed it */
      prev = pcb;
 2020364:	e0bff317 	ldw	r2,-52(fp)
 2020368:	e0bff415 	stw	r2,-48(fp)
      pcb = pcb->next;
 202036c:	e0bff317 	ldw	r2,-52(fp)
 2020370:	10800417 	ldw	r2,16(r2)
 2020374:	e0bff315 	stw	r2,-52(fp)
      continue;
 2020378:	0001cd06 	br	2020ab0 <tcp_slowtmr+0x7a4>
    }
    pcb->last_timer = tcp_timer_ctr;
 202037c:	d0e7e043 	ldbu	r3,-24703(gp)
 2020380:	e0bff317 	ldw	r2,-52(fp)
 2020384:	10c00985 	stb	r3,38(r2)

    pcb_remove = 0;
 2020388:	e03ff505 	stb	zero,-44(fp)
    pcb_reset = 0;
 202038c:	e03ff545 	stb	zero,-43(fp)

    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 2020390:	e0bff317 	ldw	r2,-52(fp)
 2020394:	10800617 	ldw	r2,24(r2)
 2020398:	10800098 	cmpnei	r2,r2,2
 202039c:	1000091e 	bne	r2,zero,20203c4 <tcp_slowtmr+0xb8>
 20203a0:	e0bff317 	ldw	r2,-52(fp)
 20203a4:	10801283 	ldbu	r2,74(r2)
 20203a8:	10803fcc 	andi	r2,r2,255
 20203ac:	108001b0 	cmpltui	r2,r2,6
 20203b0:	1000041e 	bne	r2,zero,20203c4 <tcp_slowtmr+0xb8>
      ++pcb_remove;
 20203b4:	e0bff503 	ldbu	r2,-44(fp)
 20203b8:	10800044 	addi	r2,r2,1
 20203bc:	e0bff505 	stb	r2,-44(fp)
 20203c0:	0000d806 	br	2020724 <tcp_slowtmr+0x418>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    } else if (pcb->nrtx >= TCP_MAXRTX) {
 20203c4:	e0bff317 	ldw	r2,-52(fp)
 20203c8:	10801283 	ldbu	r2,74(r2)
 20203cc:	10803fcc 	andi	r2,r2,255
 20203d0:	10800330 	cmpltui	r2,r2,12
 20203d4:	1000041e 	bne	r2,zero,20203e8 <tcp_slowtmr+0xdc>
      ++pcb_remove;
 20203d8:	e0bff503 	ldbu	r2,-44(fp)
 20203dc:	10800044 	addi	r2,r2,1
 20203e0:	e0bff505 	stb	r2,-44(fp)
 20203e4:	0000cf06 	br	2020724 <tcp_slowtmr+0x418>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 20203e8:	e0bff317 	ldw	r2,-52(fp)
 20203ec:	10802a43 	ldbu	r2,169(r2)
 20203f0:	10803fcc 	andi	r2,r2,255
 20203f4:	10005026 	beq	r2,zero,2020538 <tcp_slowtmr+0x22c>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
        if (pcb->persist_probe >= TCP_MAXRTX) {
 20203f8:	e0bff317 	ldw	r2,-52(fp)
 20203fc:	10802a83 	ldbu	r2,170(r2)
 2020400:	10803fcc 	andi	r2,r2,255
 2020404:	10800330 	cmpltui	r2,r2,12
 2020408:	1000041e 	bne	r2,zero,202041c <tcp_slowtmr+0x110>
          ++pcb_remove; /* max probes reached */
 202040c:	e0bff503 	ldbu	r2,-44(fp)
 2020410:	10800044 	addi	r2,r2,1
 2020414:	e0bff505 	stb	r2,-44(fp)
 2020418:	0000c206 	br	2020724 <tcp_slowtmr+0x418>
        } else {
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
 202041c:	e0bff317 	ldw	r2,-52(fp)
 2020420:	10802a43 	ldbu	r2,169(r2)
 2020424:	10803fcc 	andi	r2,r2,255
 2020428:	10ffffc4 	addi	r3,r2,-1
 202042c:	d0a01084 	addi	r2,gp,-32702
 2020430:	1885883a 	add	r2,r3,r2
 2020434:	10800003 	ldbu	r2,0(r2)
 2020438:	e0bff705 	stb	r2,-36(fp)
          if (pcb->persist_cnt < backoff_cnt) {
 202043c:	e0bff317 	ldw	r2,-52(fp)
 2020440:	10802a03 	ldbu	r2,168(r2)
 2020444:	10c03fcc 	andi	r3,r2,255
 2020448:	e0bff703 	ldbu	r2,-36(fp)
 202044c:	1880062e 	bgeu	r3,r2,2020468 <tcp_slowtmr+0x15c>
            pcb->persist_cnt++;
 2020450:	e0bff317 	ldw	r2,-52(fp)
 2020454:	10802a03 	ldbu	r2,168(r2)
 2020458:	10800044 	addi	r2,r2,1
 202045c:	1007883a 	mov	r3,r2
 2020460:	e0bff317 	ldw	r2,-52(fp)
 2020464:	10c02a05 	stb	r3,168(r2)
          }
          if (pcb->persist_cnt >= backoff_cnt) {
 2020468:	e0bff317 	ldw	r2,-52(fp)
 202046c:	10802a03 	ldbu	r2,168(r2)
 2020470:	10c03fcc 	andi	r3,r2,255
 2020474:	e0bff703 	ldbu	r2,-36(fp)
 2020478:	1880aa36 	bltu	r3,r2,2020724 <tcp_slowtmr+0x418>
            int next_slot = 1; /* increment timer to next slot */
 202047c:	00800044 	movi	r2,1
 2020480:	e0bff615 	stw	r2,-40(fp)
            /* If snd_wnd is zero, send 1 byte probes */
            if (pcb->snd_wnd == 0) {
 2020484:	e0bff317 	ldw	r2,-52(fp)
 2020488:	10801a0b 	ldhu	r2,104(r2)
 202048c:	10bfffcc 	andi	r2,r2,65535
 2020490:	1000081e 	bne	r2,zero,20204b4 <tcp_slowtmr+0x1a8>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
 2020494:	e13ff317 	ldw	r4,-52(fp)
 2020498:	2028fb00 	call	2028fb0 <tcp_zero_window_probe>
 202049c:	10803fcc 	andi	r2,r2,255
 20204a0:	1080201c 	xori	r2,r2,128
 20204a4:	10bfe004 	addi	r2,r2,-128
 20204a8:	10001326 	beq	r2,zero,20204f8 <tcp_slowtmr+0x1ec>
                next_slot = 0; /* try probe again with current slot */
 20204ac:	e03ff615 	stw	zero,-40(fp)
 20204b0:	00001106 	br	20204f8 <tcp_slowtmr+0x1ec>
              }
              /* snd_wnd not fully closed, split unsent head and fill window */
            } else {
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
 20204b4:	e0bff317 	ldw	r2,-52(fp)
 20204b8:	10801a0b 	ldhu	r2,104(r2)
 20204bc:	10bfffcc 	andi	r2,r2,65535
 20204c0:	100b883a 	mov	r5,r2
 20204c4:	e13ff317 	ldw	r4,-52(fp)
 20204c8:	2026cd00 	call	2026cd0 <tcp_split_unsent_seg>
 20204cc:	10803fcc 	andi	r2,r2,255
 20204d0:	1080201c 	xori	r2,r2,128
 20204d4:	10bfe004 	addi	r2,r2,-128
 20204d8:	1000071e 	bne	r2,zero,20204f8 <tcp_slowtmr+0x1ec>
                if (tcp_output(pcb) == ERR_OK) {
 20204dc:	e13ff317 	ldw	r4,-52(fp)
 20204e0:	20275b40 	call	20275b4 <tcp_output>
 20204e4:	10803fcc 	andi	r2,r2,255
 20204e8:	1080201c 	xori	r2,r2,128
 20204ec:	10bfe004 	addi	r2,r2,-128
 20204f0:	1000011e 	bne	r2,zero,20204f8 <tcp_slowtmr+0x1ec>
                  /* sending will cancel persist timer, else retry with current slot */
                  next_slot = 0;
 20204f4:	e03ff615 	stw	zero,-40(fp)
                }
              }
            }
            if (next_slot) {
 20204f8:	e0bff617 	ldw	r2,-40(fp)
 20204fc:	10008926 	beq	r2,zero,2020724 <tcp_slowtmr+0x418>
              pcb->persist_cnt = 0;
 2020500:	e0bff317 	ldw	r2,-52(fp)
 2020504:	10002a05 	stb	zero,168(r2)
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 2020508:	e0bff317 	ldw	r2,-52(fp)
 202050c:	10802a43 	ldbu	r2,169(r2)
 2020510:	10803fcc 	andi	r2,r2,255
 2020514:	108001e8 	cmpgeui	r2,r2,7
 2020518:	1000821e 	bne	r2,zero,2020724 <tcp_slowtmr+0x418>
                pcb->persist_backoff++;
 202051c:	e0bff317 	ldw	r2,-52(fp)
 2020520:	10802a43 	ldbu	r2,169(r2)
 2020524:	10800044 	addi	r2,r2,1
 2020528:	1007883a 	mov	r3,r2
 202052c:	e0bff317 	ldw	r2,-52(fp)
 2020530:	10c02a45 	stb	r3,169(r2)
 2020534:	00007b06 	br	2020724 <tcp_slowtmr+0x418>
            }
          }
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
 2020538:	e0bff317 	ldw	r2,-52(fp)
 202053c:	10800e0b 	ldhu	r2,56(r2)
 2020540:	10bfffcc 	andi	r2,r2,65535
 2020544:	10a0001c 	xori	r2,r2,32768
 2020548:	10a00004 	addi	r2,r2,-32768
 202054c:	10000d16 	blt	r2,zero,2020584 <tcp_slowtmr+0x278>
 2020550:	e0bff317 	ldw	r2,-52(fp)
 2020554:	10800e0b 	ldhu	r2,56(r2)
 2020558:	10bfffcc 	andi	r2,r2,65535
 202055c:	10a0001c 	xori	r2,r2,32768
 2020560:	10a00004 	addi	r2,r2,-32768
 2020564:	109fffe0 	cmpeqi	r2,r2,32767
 2020568:	1000061e 	bne	r2,zero,2020584 <tcp_slowtmr+0x278>
          ++pcb->rtime;
 202056c:	e0bff317 	ldw	r2,-52(fp)
 2020570:	10800e0b 	ldhu	r2,56(r2)
 2020574:	10800044 	addi	r2,r2,1
 2020578:	1007883a 	mov	r3,r2
 202057c:	e0bff317 	ldw	r2,-52(fp)
 2020580:	10c00e0d 	sth	r3,56(r2)
        }

        if (pcb->rtime >= pcb->rto) {
 2020584:	e0bff317 	ldw	r2,-52(fp)
 2020588:	10c00e0b 	ldhu	r3,56(r2)
 202058c:	e0bff317 	ldw	r2,-52(fp)
 2020590:	1080120b 	ldhu	r2,72(r2)
 2020594:	18ffffcc 	andi	r3,r3,65535
 2020598:	18e0001c 	xori	r3,r3,32768
 202059c:	18e00004 	addi	r3,r3,-32768
 20205a0:	10bfffcc 	andi	r2,r2,65535
 20205a4:	10a0001c 	xori	r2,r2,32768
 20205a8:	10a00004 	addi	r2,r2,-32768
 20205ac:	18805d16 	blt	r3,r2,2020724 <tcp_slowtmr+0x418>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));
          /* If prepare phase fails but we have unsent data but no unacked data,
             still execute the backoff calculations below, as this means we somehow
             failed to send segment. */
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
 20205b0:	e13ff317 	ldw	r4,-52(fp)
 20205b4:	202822c0 	call	202822c <tcp_rexmit_rto_prepare>
 20205b8:	10803fcc 	andi	r2,r2,255
 20205bc:	1080201c 	xori	r2,r2,128
 20205c0:	10bfe004 	addi	r2,r2,-128
 20205c4:	10000626 	beq	r2,zero,20205e0 <tcp_slowtmr+0x2d4>
 20205c8:	e0bff317 	ldw	r2,-52(fp)
 20205cc:	10801e17 	ldw	r2,120(r2)
 20205d0:	1000541e 	bne	r2,zero,2020724 <tcp_slowtmr+0x418>
 20205d4:	e0bff317 	ldw	r2,-52(fp)
 20205d8:	10801d17 	ldw	r2,116(r2)
 20205dc:	10005126 	beq	r2,zero,2020724 <tcp_slowtmr+0x418>
            /* Double retransmission time-out unless we are trying to
             * connect to somebody (i.e., we are in SYN_SENT). */
            if (pcb->state != SYN_SENT) {
 20205e0:	e0bff317 	ldw	r2,-52(fp)
 20205e4:	10800617 	ldw	r2,24(r2)
 20205e8:	108000a0 	cmpeqi	r2,r2,2
 20205ec:	1000261e 	bne	r2,zero,2020688 <tcp_slowtmr+0x37c>
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
 20205f0:	e0bff317 	ldw	r2,-52(fp)
 20205f4:	10801283 	ldbu	r2,74(r2)
 20205f8:	10c03fcc 	andi	r3,r2,255
 20205fc:	18c00370 	cmpltui	r3,r3,13
 2020600:	1800011e 	bne	r3,zero,2020608 <tcp_slowtmr+0x2fc>
 2020604:	00800304 	movi	r2,12
 2020608:	e0bff745 	stb	r2,-35(fp)
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 202060c:	e0bff317 	ldw	r2,-52(fp)
 2020610:	1080110b 	ldhu	r2,68(r2)
 2020614:	10bfffcc 	andi	r2,r2,65535
 2020618:	10a0001c 	xori	r2,r2,32768
 202061c:	10a00004 	addi	r2,r2,-32768
 2020620:	1005d0fa 	srai	r2,r2,3
 2020624:	10ffffcc 	andi	r3,r2,65535
 2020628:	18e0001c 	xori	r3,r3,32768
 202062c:	18e00004 	addi	r3,r3,-32768
 2020630:	e0bff317 	ldw	r2,-52(fp)
 2020634:	1080118b 	ldhu	r2,70(r2)
 2020638:	10bfffcc 	andi	r2,r2,65535
 202063c:	10a0001c 	xori	r2,r2,32768
 2020640:	10a00004 	addi	r2,r2,-32768
 2020644:	1887883a 	add	r3,r3,r2
 2020648:	e13ff743 	ldbu	r4,-35(fp)
 202064c:	00808134 	movhi	r2,516
 2020650:	109bef04 	addi	r2,r2,28604
 2020654:	1105883a 	add	r2,r2,r4
 2020658:	10800003 	ldbu	r2,0(r2)
 202065c:	10803fcc 	andi	r2,r2,255
 2020660:	1884983a 	sll	r2,r3,r2
 2020664:	e0bff815 	stw	r2,-32(fp)
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
 2020668:	e0bff817 	ldw	r2,-32(fp)
 202066c:	109fffc8 	cmpgei	r2,r2,32767
 2020670:	1000021e 	bne	r2,zero,202067c <tcp_slowtmr+0x370>
 2020674:	e0bff817 	ldw	r2,-32(fp)
 2020678:	00000106 	br	2020680 <tcp_slowtmr+0x374>
 202067c:	009fffc4 	movi	r2,32767
 2020680:	e0fff317 	ldw	r3,-52(fp)
 2020684:	1880120d 	sth	r2,72(r3)
            }

            /* Reset the retransmission timer. */
            pcb->rtime = 0;
 2020688:	e0bff317 	ldw	r2,-52(fp)
 202068c:	10000e0d 	sth	zero,56(r2)

            /* Reduce congestion window and ssthresh. */
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 2020690:	e0bff317 	ldw	r2,-52(fp)
 2020694:	10c01a0b 	ldhu	r3,104(r2)
 2020698:	e0bff317 	ldw	r2,-52(fp)
 202069c:	1140140b 	ldhu	r5,80(r2)
 20206a0:	1805883a 	mov	r2,r3
 20206a4:	10ffffcc 	andi	r3,r2,65535
 20206a8:	293fffcc 	andi	r4,r5,65535
 20206ac:	20c0012e 	bgeu	r4,r3,20206b4 <tcp_slowtmr+0x3a8>
 20206b0:	2805883a 	mov	r2,r5
 20206b4:	e0bff90d 	sth	r2,-28(fp)
            pcb->ssthresh = eff_wnd >> 1;
 20206b8:	e0bff90b 	ldhu	r2,-28(fp)
 20206bc:	1004d07a 	srli	r2,r2,1
 20206c0:	1007883a 	mov	r3,r2
 20206c4:	e0bff317 	ldw	r2,-52(fp)
 20206c8:	10c0148d 	sth	r3,82(r2)
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 20206cc:	e0bff317 	ldw	r2,-52(fp)
 20206d0:	10c0148b 	ldhu	r3,82(r2)
 20206d4:	e0bff317 	ldw	r2,-52(fp)
 20206d8:	10800e8b 	ldhu	r2,58(r2)
 20206dc:	1085883a 	add	r2,r2,r2
 20206e0:	18ffffcc 	andi	r3,r3,65535
 20206e4:	10bfffcc 	andi	r2,r2,65535
 20206e8:	1880062e 	bgeu	r3,r2,2020704 <tcp_slowtmr+0x3f8>
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
 20206ec:	e0bff317 	ldw	r2,-52(fp)
 20206f0:	10800e8b 	ldhu	r2,58(r2)
 20206f4:	1085883a 	add	r2,r2,r2
 20206f8:	1007883a 	mov	r3,r2
 20206fc:	e0bff317 	ldw	r2,-52(fp)
 2020700:	10c0148d 	sth	r3,82(r2)
            }
            pcb->cwnd = pcb->mss;
 2020704:	e0bff317 	ldw	r2,-52(fp)
 2020708:	10c00e8b 	ldhu	r3,58(r2)
 202070c:	e0bff317 	ldw	r2,-52(fp)
 2020710:	10c0140d 	sth	r3,80(r2)
            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
                                         " ssthresh %"TCPWNDSIZE_F"\n",
                                         pcb->cwnd, pcb->ssthresh));
            pcb->bytes_acked = 0;
 2020714:	e0bff317 	ldw	r2,-52(fp)
 2020718:	10001c8d 	sth	zero,114(r2)

            /* The following needs to be called AFTER cwnd is set to one
               mss - STJ */
            tcp_rexmit_rto_commit(pcb);
 202071c:	e13ff317 	ldw	r4,-52(fp)
 2020720:	20283a80 	call	20283a8 <tcp_rexmit_rto_commit>
          }
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 2020724:	e0bff317 	ldw	r2,-52(fp)
 2020728:	10800617 	ldw	r2,24(r2)
 202072c:	10800198 	cmpnei	r2,r2,6
 2020730:	10000e1e 	bne	r2,zero,202076c <tcp_slowtmr+0x460>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 2020734:	e0bff317 	ldw	r2,-52(fp)
 2020738:	1080088b 	ldhu	r2,34(r2)
 202073c:	10bfffcc 	andi	r2,r2,65535
 2020740:	1080040c 	andi	r2,r2,16
 2020744:	10000926 	beq	r2,zero,202076c <tcp_slowtmr+0x460>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 2020748:	d0e7e217 	ldw	r3,-24696(gp)
 202074c:	e0bff317 	ldw	r2,-52(fp)
 2020750:	10800a17 	ldw	r2,40(r2)
 2020754:	1885c83a 	sub	r2,r3,r2
 2020758:	10800a70 	cmpltui	r2,r2,41
 202075c:	1000031e 	bne	r2,zero,202076c <tcp_slowtmr+0x460>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 2020760:	e0bff503 	ldbu	r2,-44(fp)
 2020764:	10800044 	addi	r2,r2,1
 2020768:	e0bff505 	stb	r2,-44(fp)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 202076c:	e0bff317 	ldw	r2,-52(fp)
 2020770:	10800243 	ldbu	r2,9(r2)
 2020774:	10803fcc 	andi	r2,r2,255
 2020778:	1080020c 	andi	r2,r2,8
 202077c:	10003b26 	beq	r2,zero,202086c <tcp_slowtmr+0x560>
        ((pcb->state == ESTABLISHED) ||
 2020780:	e0bff317 	ldw	r2,-52(fp)
 2020784:	10800617 	ldw	r2,24(r2)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 2020788:	10800120 	cmpeqi	r2,r2,4
 202078c:	1000041e 	bne	r2,zero,20207a0 <tcp_slowtmr+0x494>
        ((pcb->state == ESTABLISHED) ||
         (pcb->state == CLOSE_WAIT))) {
 2020790:	e0bff317 	ldw	r2,-52(fp)
 2020794:	10800617 	ldw	r2,24(r2)
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
        ((pcb->state == ESTABLISHED) ||
 2020798:	108001d8 	cmpnei	r2,r2,7
 202079c:	1000331e 	bne	r2,zero,202086c <tcp_slowtmr+0x560>
         (pcb->state == CLOSE_WAIT))) {
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 20207a0:	d0e7e217 	ldw	r3,-24696(gp)
 20207a4:	e0bff317 	ldw	r2,-52(fp)
 20207a8:	10800a17 	ldw	r2,40(r2)
 20207ac:	18a1c83a 	sub	r16,r3,r2
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
 20207b0:	e0bff317 	ldw	r2,-52(fp)
 20207b4:	10c02717 	ldw	r3,156(r2)
 20207b8:	e0bff317 	ldw	r2,-52(fp)
 20207bc:	11002917 	ldw	r4,164(r2)
 20207c0:	e0bff317 	ldw	r2,-52(fp)
 20207c4:	10802817 	ldw	r2,160(r2)
 20207c8:	2085383a 	mul	r2,r4,r2
 20207cc:	1885883a 	add	r2,r3,r2
 20207d0:	01407d04 	movi	r5,500
 20207d4:	1009883a 	mov	r4,r2
 20207d8:	200aadc0 	call	200aadc <__udivsi3>

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
        ((pcb->state == ESTABLISHED) ||
         (pcb->state == CLOSE_WAIT))) {
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 20207dc:	1400072e 	bgeu	r2,r16,20207fc <tcp_slowtmr+0x4f0>
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
        ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
 20207e0:	e0bff503 	ldbu	r2,-44(fp)
 20207e4:	10800044 	addi	r2,r2,1
 20207e8:	e0bff505 	stb	r2,-44(fp)
        ++pcb_reset;
 20207ec:	e0bff543 	ldbu	r2,-43(fp)
 20207f0:	10800044 	addi	r2,r2,1
 20207f4:	e0bff545 	stb	r2,-43(fp)
 20207f8:	00001c06 	br	202086c <tcp_slowtmr+0x560>
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 20207fc:	d0e7e217 	ldw	r3,-24696(gp)
 2020800:	e0bff317 	ldw	r2,-52(fp)
 2020804:	10800a17 	ldw	r2,40(r2)
 2020808:	18a1c83a 	sub	r16,r3,r2
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 202080c:	e0bff317 	ldw	r2,-52(fp)
 2020810:	10c02717 	ldw	r3,156(r2)
 2020814:	e0bff317 	ldw	r2,-52(fp)
 2020818:	10802ac3 	ldbu	r2,171(r2)
 202081c:	11003fcc 	andi	r4,r2,255
 2020820:	e0bff317 	ldw	r2,-52(fp)
 2020824:	10802817 	ldw	r2,160(r2)
 2020828:	2085383a 	mul	r2,r4,r2
 202082c:	1885883a 	add	r2,r3,r2
                 / TCP_SLOW_INTERVAL) {
 2020830:	01407d04 	movi	r5,500
 2020834:	1009883a 	mov	r4,r2
 2020838:	200aadc0 	call	200aadc <__udivsi3>
        ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
        ++pcb_reset;
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 202083c:	14000b2e 	bgeu	r2,r16,202086c <tcp_slowtmr+0x560>
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
                 / TCP_SLOW_INTERVAL) {
        err = tcp_keepalive(pcb);
 2020840:	e13ff317 	ldw	r4,-52(fp)
 2020844:	2028efc0 	call	2028efc <tcp_keepalive>
 2020848:	e0bff585 	stb	r2,-42(fp)
        if (err == ERR_OK) {
 202084c:	e0bff587 	ldb	r2,-42(fp)
 2020850:	1000061e 	bne	r2,zero,202086c <tcp_slowtmr+0x560>
          pcb->keep_cnt_sent++;
 2020854:	e0bff317 	ldw	r2,-52(fp)
 2020858:	10802ac3 	ldbu	r2,171(r2)
 202085c:	10800044 	addi	r2,r2,1
 2020860:	1007883a 	mov	r3,r2
 2020864:	e0bff317 	ldw	r2,-52(fp)
 2020868:	10c02ac5 	stb	r3,171(r2)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 202086c:	e0bff317 	ldw	r2,-52(fp)
 2020870:	10801f17 	ldw	r2,124(r2)
 2020874:	10000d26 	beq	r2,zero,20208ac <tcp_slowtmr+0x5a0>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
 2020878:	d0e7e217 	ldw	r3,-24696(gp)
 202087c:	e0bff317 	ldw	r2,-52(fp)
 2020880:	10800a17 	ldw	r2,40(r2)
 2020884:	1887c83a 	sub	r3,r3,r2
 2020888:	e0bff317 	ldw	r2,-52(fp)
 202088c:	1080120b 	ldhu	r2,72(r2)
 2020890:	10bfffcc 	andi	r2,r2,65535
 2020894:	10a0001c 	xori	r2,r2,32768
 2020898:	10a00004 	addi	r2,r2,-32768
 202089c:	108001a4 	muli	r2,r2,6

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 20208a0:	18800236 	bltu	r3,r2,20208ac <tcp_slowtmr+0x5a0>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
      tcp_free_ooseq(pcb);
 20208a4:	e13ff317 	ldw	r4,-52(fp)
 20208a8:	2021c680 	call	2021c68 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 20208ac:	e0bff317 	ldw	r2,-52(fp)
 20208b0:	10800617 	ldw	r2,24(r2)
 20208b4:	108000d8 	cmpnei	r2,r2,3
 20208b8:	1000091e 	bne	r2,zero,20208e0 <tcp_slowtmr+0x5d4>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 20208bc:	d0e7e217 	ldw	r3,-24696(gp)
 20208c0:	e0bff317 	ldw	r2,-52(fp)
 20208c4:	10800a17 	ldw	r2,40(r2)
 20208c8:	1885c83a 	sub	r2,r3,r2
 20208cc:	10800a70 	cmpltui	r2,r2,41
 20208d0:	1000031e 	bne	r2,zero,20208e0 <tcp_slowtmr+0x5d4>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 20208d4:	e0bff503 	ldbu	r2,-44(fp)
 20208d8:	10800044 	addi	r2,r2,1
 20208dc:	e0bff505 	stb	r2,-44(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 20208e0:	e0bff317 	ldw	r2,-52(fp)
 20208e4:	10800617 	ldw	r2,24(r2)
 20208e8:	10800258 	cmpnei	r2,r2,9
 20208ec:	1000091e 	bne	r2,zero,2020914 <tcp_slowtmr+0x608>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 20208f0:	d0e7e217 	ldw	r3,-24696(gp)
 20208f4:	e0bff317 	ldw	r2,-52(fp)
 20208f8:	10800a17 	ldw	r2,40(r2)
 20208fc:	1885c83a 	sub	r2,r3,r2
 2020900:	10803c70 	cmpltui	r2,r2,241
 2020904:	1000031e 	bne	r2,zero,2020914 <tcp_slowtmr+0x608>
        ++pcb_remove;
 2020908:	e0bff503 	ldbu	r2,-44(fp)
 202090c:	10800044 	addi	r2,r2,1
 2020910:	e0bff505 	stb	r2,-44(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 2020914:	e0bff503 	ldbu	r2,-44(fp)
 2020918:	10003b26 	beq	r2,zero,2020a08 <tcp_slowtmr+0x6fc>
      struct tcp_pcb *pcb2;
#if LWIP_CALLBACK_API
      tcp_err_fn err_fn = pcb->errf;
 202091c:	e0bff317 	ldw	r2,-52(fp)
 2020920:	10802617 	ldw	r2,152(r2)
 2020924:	e0bffa15 	stw	r2,-24(fp)
#endif /* LWIP_CALLBACK_API */
      void *err_arg;
      enum tcp_state last_state;
      tcp_pcb_purge(pcb);
 2020928:	e13ff317 	ldw	r4,-52(fp)
 202092c:	202176c0 	call	202176c <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 2020930:	e0bff417 	ldw	r2,-48(fp)
 2020934:	10000526 	beq	r2,zero,202094c <tcp_slowtmr+0x640>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 2020938:	e0bff317 	ldw	r2,-52(fp)
 202093c:	10c00417 	ldw	r3,16(r2)
 2020940:	e0bff417 	ldw	r2,-48(fp)
 2020944:	10c00415 	stw	r3,16(r2)
 2020948:	00000306 	br	2020958 <tcp_slowtmr+0x64c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
 202094c:	e0bff317 	ldw	r2,-52(fp)
 2020950:	10800417 	ldw	r2,16(r2)
 2020954:	d0a7e115 	stw	r2,-24700(gp)
      }

      if (pcb_reset) {
 2020958:	e0bff543 	ldbu	r2,-43(fp)
 202095c:	10001226 	beq	r2,zero,20209a8 <tcp_slowtmr+0x69c>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 2020960:	e0bff317 	ldw	r2,-52(fp)
 2020964:	11401617 	ldw	r5,88(r2)
 2020968:	e0bff317 	ldw	r2,-52(fp)
 202096c:	11800b17 	ldw	r6,44(r2)
 2020970:	e1fff317 	ldw	r7,-52(fp)
 2020974:	e0bff317 	ldw	r2,-52(fp)
 2020978:	10800104 	addi	r2,r2,4
                pcb->local_port, pcb->remote_port);
 202097c:	e0fff317 	ldw	r3,-52(fp)
 2020980:	18c0078b 	ldhu	r3,30(r3)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 2020984:	18ffffcc 	andi	r3,r3,65535
                pcb->local_port, pcb->remote_port);
 2020988:	e13ff317 	ldw	r4,-52(fp)
 202098c:	2100080b 	ldhu	r4,32(r4)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 2020990:	213fffcc 	andi	r4,r4,65535
 2020994:	d9000215 	stw	r4,8(sp)
 2020998:	d8c00115 	stw	r3,4(sp)
 202099c:	d8800015 	stw	r2,0(sp)
 20209a0:	e13ff317 	ldw	r4,-52(fp)
 20209a4:	2028cf40 	call	2028cf4 <tcp_rst>
                pcb->local_port, pcb->remote_port);
      }

      err_arg = pcb->callback_arg;
 20209a8:	e0bff317 	ldw	r2,-52(fp)
 20209ac:	10800517 	ldw	r2,20(r2)
 20209b0:	e0bffb15 	stw	r2,-20(fp)
      last_state = pcb->state;
 20209b4:	e0bff317 	ldw	r2,-52(fp)
 20209b8:	10800617 	ldw	r2,24(r2)
 20209bc:	e0bffc15 	stw	r2,-16(fp)
      pcb2 = pcb;
 20209c0:	e0bff317 	ldw	r2,-52(fp)
 20209c4:	e0bffd15 	stw	r2,-12(fp)
      pcb = pcb->next;
 20209c8:	e0bff317 	ldw	r2,-52(fp)
 20209cc:	10800417 	ldw	r2,16(r2)
 20209d0:	e0bff315 	stw	r2,-52(fp)
      tcp_free(pcb2);
 20209d4:	e13ffd17 	ldw	r4,-12(fp)
 20209d8:	201eda00 	call	201eda0 <tcp_free>

      tcp_active_pcbs_changed = 0;
 20209dc:	d027e085 	stb	zero,-24702(gp)
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 20209e0:	e0bffa17 	ldw	r2,-24(fp)
 20209e4:	10000426 	beq	r2,zero,20209f8 <tcp_slowtmr+0x6ec>
 20209e8:	e0bffa17 	ldw	r2,-24(fp)
 20209ec:	017ffcc4 	movi	r5,-13
 20209f0:	e13ffb17 	ldw	r4,-20(fp)
 20209f4:	103ee83a 	callr	r2
      if (tcp_active_pcbs_changed) {
 20209f8:	d0a7e083 	ldbu	r2,-24702(gp)
 20209fc:	10803fcc 	andi	r2,r2,255
 2020a00:	10002b26 	beq	r2,zero,2020ab0 <tcp_slowtmr+0x7a4>
        goto tcp_slowtmr_start;
 2020a04:	003e4d06 	br	202033c <__alt_mem_mem_0+0xfd00033c>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
 2020a08:	e0bff317 	ldw	r2,-52(fp)
 2020a0c:	e0bff415 	stw	r2,-48(fp)
      pcb = pcb->next;
 2020a10:	e0bff317 	ldw	r2,-52(fp)
 2020a14:	10800417 	ldw	r2,16(r2)
 2020a18:	e0bff315 	stw	r2,-52(fp)

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 2020a1c:	e0bff417 	ldw	r2,-48(fp)
 2020a20:	10800903 	ldbu	r2,36(r2)
 2020a24:	10800044 	addi	r2,r2,1
 2020a28:	1007883a 	mov	r3,r2
 2020a2c:	e0bff417 	ldw	r2,-48(fp)
 2020a30:	10c00905 	stb	r3,36(r2)
      if (prev->polltmr >= prev->pollinterval) {
 2020a34:	e0bff417 	ldw	r2,-48(fp)
 2020a38:	10c00903 	ldbu	r3,36(r2)
 2020a3c:	e0bff417 	ldw	r2,-48(fp)
 2020a40:	10800943 	ldbu	r2,37(r2)
 2020a44:	18c03fcc 	andi	r3,r3,255
 2020a48:	10803fcc 	andi	r2,r2,255
 2020a4c:	18801836 	bltu	r3,r2,2020ab0 <tcp_slowtmr+0x7a4>
        prev->polltmr = 0;
 2020a50:	e0bff417 	ldw	r2,-48(fp)
 2020a54:	10000905 	stb	zero,36(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 2020a58:	d027e085 	stb	zero,-24702(gp)
        TCP_EVENT_POLL(prev, err);
 2020a5c:	e0bff417 	ldw	r2,-48(fp)
 2020a60:	10802517 	ldw	r2,148(r2)
 2020a64:	10000926 	beq	r2,zero,2020a8c <tcp_slowtmr+0x780>
 2020a68:	e0bff417 	ldw	r2,-48(fp)
 2020a6c:	10802517 	ldw	r2,148(r2)
 2020a70:	e0fff417 	ldw	r3,-48(fp)
 2020a74:	18c00517 	ldw	r3,20(r3)
 2020a78:	e17ff417 	ldw	r5,-48(fp)
 2020a7c:	1809883a 	mov	r4,r3
 2020a80:	103ee83a 	callr	r2
 2020a84:	e0bff585 	stb	r2,-42(fp)
 2020a88:	00000106 	br	2020a90 <tcp_slowtmr+0x784>
 2020a8c:	e03ff585 	stb	zero,-42(fp)
        if (tcp_active_pcbs_changed) {
 2020a90:	d0a7e083 	ldbu	r2,-24702(gp)
 2020a94:	10803fcc 	andi	r2,r2,255
 2020a98:	10000126 	beq	r2,zero,2020aa0 <tcp_slowtmr+0x794>
          goto tcp_slowtmr_start;
 2020a9c:	003e2706 	br	202033c <__alt_mem_mem_0+0xfd00033c>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 2020aa0:	e0bff587 	ldb	r2,-42(fp)
 2020aa4:	1000021e 	bne	r2,zero,2020ab0 <tcp_slowtmr+0x7a4>
          tcp_output(prev);
 2020aa8:	e13ff417 	ldw	r4,-48(fp)
 2020aac:	20275b40 	call	20275b4 <tcp_output>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 2020ab0:	e0bff317 	ldw	r2,-52(fp)
 2020ab4:	103e251e 	bne	r2,zero,202034c <__alt_mem_mem_0+0xfd00034c>
    }
  }


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
 2020ab8:	e03ff415 	stw	zero,-48(fp)
  pcb = tcp_tw_pcbs;
 2020abc:	d0a7e517 	ldw	r2,-24684(gp)
 2020ac0:	e0bff315 	stw	r2,-52(fp)
  while (pcb != NULL) {
 2020ac4:	00002506 	br	2020b5c <tcp_slowtmr+0x850>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
 2020ac8:	e03ff505 	stb	zero,-44(fp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 2020acc:	d0e7e217 	ldw	r3,-24696(gp)
 2020ad0:	e0bff317 	ldw	r2,-52(fp)
 2020ad4:	10800a17 	ldw	r2,40(r2)
 2020ad8:	1885c83a 	sub	r2,r3,r2
 2020adc:	10803c70 	cmpltui	r2,r2,241
 2020ae0:	1000031e 	bne	r2,zero,2020af0 <tcp_slowtmr+0x7e4>
      ++pcb_remove;
 2020ae4:	e0bff503 	ldbu	r2,-44(fp)
 2020ae8:	10800044 	addi	r2,r2,1
 2020aec:	e0bff505 	stb	r2,-44(fp)
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 2020af0:	e0bff503 	ldbu	r2,-44(fp)
 2020af4:	10001426 	beq	r2,zero,2020b48 <tcp_slowtmr+0x83c>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 2020af8:	e13ff317 	ldw	r4,-52(fp)
 2020afc:	202176c0 	call	202176c <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 2020b00:	e0bff417 	ldw	r2,-48(fp)
 2020b04:	10000526 	beq	r2,zero,2020b1c <tcp_slowtmr+0x810>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
 2020b08:	e0bff317 	ldw	r2,-52(fp)
 2020b0c:	10c00417 	ldw	r3,16(r2)
 2020b10:	e0bff417 	ldw	r2,-48(fp)
 2020b14:	10c00415 	stw	r3,16(r2)
 2020b18:	00000306 	br	2020b28 <tcp_slowtmr+0x81c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
 2020b1c:	e0bff317 	ldw	r2,-52(fp)
 2020b20:	10800417 	ldw	r2,16(r2)
 2020b24:	d0a7e515 	stw	r2,-24684(gp)
      }
      pcb2 = pcb;
 2020b28:	e0bff317 	ldw	r2,-52(fp)
 2020b2c:	e0bffe15 	stw	r2,-8(fp)
      pcb = pcb->next;
 2020b30:	e0bff317 	ldw	r2,-52(fp)
 2020b34:	10800417 	ldw	r2,16(r2)
 2020b38:	e0bff315 	stw	r2,-52(fp)
      tcp_free(pcb2);
 2020b3c:	e13ffe17 	ldw	r4,-8(fp)
 2020b40:	201eda00 	call	201eda0 <tcp_free>
 2020b44:	00000506 	br	2020b5c <tcp_slowtmr+0x850>
    } else {
      prev = pcb;
 2020b48:	e0bff317 	ldw	r2,-52(fp)
 2020b4c:	e0bff415 	stw	r2,-48(fp)
      pcb = pcb->next;
 2020b50:	e0bff317 	ldw	r2,-52(fp)
 2020b54:	10800417 	ldw	r2,16(r2)
 2020b58:	e0bff315 	stw	r2,-52(fp)


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 2020b5c:	e0bff317 	ldw	r2,-52(fp)
 2020b60:	103fd91e 	bne	r2,zero,2020ac8 <__alt_mem_mem_0+0xfd000ac8>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
 2020b64:	0001883a 	nop
 2020b68:	e6ffff04 	addi	sp,fp,-4
 2020b6c:	dfc00217 	ldw	ra,8(sp)
 2020b70:	df000117 	ldw	fp,4(sp)
 2020b74:	dc000017 	ldw	r16,0(sp)
 2020b78:	dec00304 	addi	sp,sp,12
 2020b7c:	f800283a 	ret

02020b80 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 2020b80:	defffc04 	addi	sp,sp,-16
 2020b84:	dfc00315 	stw	ra,12(sp)
 2020b88:	df000215 	stw	fp,8(sp)
 2020b8c:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 2020b90:	d0a7e043 	ldbu	r2,-24703(gp)
 2020b94:	10800044 	addi	r2,r2,1
 2020b98:	d0a7e045 	stb	r2,-24703(gp)

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 2020b9c:	d0a7e117 	ldw	r2,-24700(gp)
 2020ba0:	e0bffe15 	stw	r2,-8(fp)

  while (pcb != NULL) {
 2020ba4:	00003e06 	br	2020ca0 <tcp_fasttmr+0x120>
    if (pcb->last_timer != tcp_timer_ctr) {
 2020ba8:	e0bffe17 	ldw	r2,-8(fp)
 2020bac:	10c00983 	ldbu	r3,38(r2)
 2020bb0:	d0a7e043 	ldbu	r2,-24703(gp)
 2020bb4:	18c03fcc 	andi	r3,r3,255
 2020bb8:	10803fcc 	andi	r2,r2,255
 2020bbc:	18803526 	beq	r3,r2,2020c94 <tcp_fasttmr+0x114>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 2020bc0:	d0e7e043 	ldbu	r3,-24703(gp)
 2020bc4:	e0bffe17 	ldw	r2,-8(fp)
 2020bc8:	10c00985 	stb	r3,38(r2)
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 2020bcc:	e0bffe17 	ldw	r2,-8(fp)
 2020bd0:	1080088b 	ldhu	r2,34(r2)
 2020bd4:	10bfffcc 	andi	r2,r2,65535
 2020bd8:	1080004c 	andi	r2,r2,1
 2020bdc:	10000f26 	beq	r2,zero,2020c1c <tcp_fasttmr+0x9c>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 2020be0:	e0bffe17 	ldw	r2,-8(fp)
 2020be4:	1080088b 	ldhu	r2,34(r2)
 2020be8:	10800094 	ori	r2,r2,2
 2020bec:	1007883a 	mov	r3,r2
 2020bf0:	e0bffe17 	ldw	r2,-8(fp)
 2020bf4:	10c0088d 	sth	r3,34(r2)
        tcp_output(pcb);
 2020bf8:	e13ffe17 	ldw	r4,-8(fp)
 2020bfc:	20275b40 	call	20275b4 <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 2020c00:	e0bffe17 	ldw	r2,-8(fp)
 2020c04:	10c0088b 	ldhu	r3,34(r2)
 2020c08:	00bfff04 	movi	r2,-4
 2020c0c:	1884703a 	and	r2,r3,r2
 2020c10:	1007883a 	mov	r3,r2
 2020c14:	e0bffe17 	ldw	r2,-8(fp)
 2020c18:	10c0088d 	sth	r3,34(r2)
      }
      /* send pending FIN */
      if (pcb->flags & TF_CLOSEPEND) {
 2020c1c:	e0bffe17 	ldw	r2,-8(fp)
 2020c20:	1080088b 	ldhu	r2,34(r2)
 2020c24:	10bfffcc 	andi	r2,r2,65535
 2020c28:	1080020c 	andi	r2,r2,8
 2020c2c:	10000926 	beq	r2,zero,2020c54 <tcp_fasttmr+0xd4>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
        tcp_clear_flags(pcb, TF_CLOSEPEND);
 2020c30:	e0bffe17 	ldw	r2,-8(fp)
 2020c34:	10c0088b 	ldhu	r3,34(r2)
 2020c38:	00bffdc4 	movi	r2,-9
 2020c3c:	1884703a 	and	r2,r3,r2
 2020c40:	1007883a 	mov	r3,r2
 2020c44:	e0bffe17 	ldw	r2,-8(fp)
 2020c48:	10c0088d 	sth	r3,34(r2)
        tcp_close_shutdown_fin(pcb);
 2020c4c:	e13ffe17 	ldw	r4,-8(fp)
 2020c50:	201f26c0 	call	201f26c <tcp_close_shutdown_fin>
      }

      next = pcb->next;
 2020c54:	e0bffe17 	ldw	r2,-8(fp)
 2020c58:	10800417 	ldw	r2,16(r2)
 2020c5c:	e0bfff15 	stw	r2,-4(fp)

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 2020c60:	e0bffe17 	ldw	r2,-8(fp)
 2020c64:	10802017 	ldw	r2,128(r2)
 2020c68:	10000726 	beq	r2,zero,2020c88 <tcp_fasttmr+0x108>
        tcp_active_pcbs_changed = 0;
 2020c6c:	d027e085 	stb	zero,-24702(gp)
        tcp_process_refused_data(pcb);
 2020c70:	e13ffe17 	ldw	r4,-8(fp)
 2020c74:	2020d240 	call	2020d24 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 2020c78:	d0a7e083 	ldbu	r2,-24702(gp)
 2020c7c:	10803fcc 	andi	r2,r2,255
 2020c80:	10000126 	beq	r2,zero,2020c88 <tcp_fasttmr+0x108>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
 2020c84:	003fc506 	br	2020b9c <__alt_mem_mem_0+0xfd000b9c>
        }
      }
      pcb = next;
 2020c88:	e0bfff17 	ldw	r2,-4(fp)
 2020c8c:	e0bffe15 	stw	r2,-8(fp)
 2020c90:	00000306 	br	2020ca0 <tcp_fasttmr+0x120>
    } else {
      pcb = pcb->next;
 2020c94:	e0bffe17 	ldw	r2,-8(fp)
 2020c98:	10800417 	ldw	r2,16(r2)
 2020c9c:	e0bffe15 	stw	r2,-8(fp)
  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;

  while (pcb != NULL) {
 2020ca0:	e0bffe17 	ldw	r2,-8(fp)
 2020ca4:	103fc01e 	bne	r2,zero,2020ba8 <__alt_mem_mem_0+0xfd000ba8>
      pcb = next;
    } else {
      pcb = pcb->next;
    }
  }
}
 2020ca8:	0001883a 	nop
 2020cac:	e037883a 	mov	sp,fp
 2020cb0:	dfc00117 	ldw	ra,4(sp)
 2020cb4:	df000017 	ldw	fp,0(sp)
 2020cb8:	dec00204 	addi	sp,sp,8
 2020cbc:	f800283a 	ret

02020cc0 <tcp_txnow>:

/** Call tcp_output for all active pcbs that have TF_NAGLEMEMERR set */
void
tcp_txnow(void)
{
 2020cc0:	defffd04 	addi	sp,sp,-12
 2020cc4:	dfc00215 	stw	ra,8(sp)
 2020cc8:	df000115 	stw	fp,4(sp)
 2020ccc:	df000104 	addi	fp,sp,4
  struct tcp_pcb *pcb;

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 2020cd0:	d0a7e117 	ldw	r2,-24700(gp)
 2020cd4:	e0bfff15 	stw	r2,-4(fp)
 2020cd8:	00000a06 	br	2020d04 <tcp_txnow+0x44>
    if (pcb->flags & TF_NAGLEMEMERR) {
 2020cdc:	e0bfff17 	ldw	r2,-4(fp)
 2020ce0:	1080088b 	ldhu	r2,34(r2)
 2020ce4:	10bfffcc 	andi	r2,r2,65535
 2020ce8:	1080200c 	andi	r2,r2,128
 2020cec:	10000226 	beq	r2,zero,2020cf8 <tcp_txnow+0x38>
      tcp_output(pcb);
 2020cf0:	e13fff17 	ldw	r4,-4(fp)
 2020cf4:	20275b40 	call	20275b4 <tcp_output>
void
tcp_txnow(void)
{
  struct tcp_pcb *pcb;

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 2020cf8:	e0bfff17 	ldw	r2,-4(fp)
 2020cfc:	10800417 	ldw	r2,16(r2)
 2020d00:	e0bfff15 	stw	r2,-4(fp)
 2020d04:	e0bfff17 	ldw	r2,-4(fp)
 2020d08:	103ff41e 	bne	r2,zero,2020cdc <__alt_mem_mem_0+0xfd000cdc>
    if (pcb->flags & TF_NAGLEMEMERR) {
      tcp_output(pcb);
    }
  }
}
 2020d0c:	0001883a 	nop
 2020d10:	e037883a 	mov	sp,fp
 2020d14:	dfc00117 	ldw	ra,4(sp)
 2020d18:	df000017 	ldw	fp,0(sp)
 2020d1c:	dec00204 	addi	sp,sp,8
 2020d20:	f800283a 	ret

02020d24 <tcp_process_refused_data>:

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 2020d24:	defffb04 	addi	sp,sp,-20
 2020d28:	dfc00415 	stw	ra,16(sp)
 2020d2c:	df000315 	stw	fp,12(sp)
 2020d30:	df000304 	addi	fp,sp,12
 2020d34:	e13fff15 	stw	r4,-4(fp)
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  struct pbuf *rest;
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
 2020d38:	e0bfff17 	ldw	r2,-4(fp)
 2020d3c:	1000021e 	bne	r2,zero,2020d48 <tcp_process_refused_data+0x24>
 2020d40:	00bffc04 	movi	r2,-16
 2020d44:	00004c06 	br	2020e78 <tcp_process_refused_data+0x154>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  while (pcb->refused_data != NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
  {
    err_t err;
    u8_t refused_flags = pcb->refused_data->flags;
 2020d48:	e0bfff17 	ldw	r2,-4(fp)
 2020d4c:	10802017 	ldw	r2,128(r2)
 2020d50:	10800343 	ldbu	r2,13(r2)
 2020d54:	e0bffd45 	stb	r2,-11(fp)
    /* set pcb->refused_data to NULL in case the callback frees it and then
       closes the pcb */
    struct pbuf *refused_data = pcb->refused_data;
 2020d58:	e0bfff17 	ldw	r2,-4(fp)
 2020d5c:	10802017 	ldw	r2,128(r2)
 2020d60:	e0bffe15 	stw	r2,-8(fp)
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
    pbuf_split_64k(refused_data, &rest);
    pcb->refused_data = rest;
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    pcb->refused_data = NULL;
 2020d64:	e0bfff17 	ldw	r2,-4(fp)
 2020d68:	10002015 	stw	zero,128(r2)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    /* Notify again application with data previously received. */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 2020d6c:	e0bfff17 	ldw	r2,-4(fp)
 2020d70:	10802317 	ldw	r2,140(r2)
 2020d74:	10000b26 	beq	r2,zero,2020da4 <tcp_process_refused_data+0x80>
 2020d78:	e0bfff17 	ldw	r2,-4(fp)
 2020d7c:	10802317 	ldw	r2,140(r2)
 2020d80:	e0ffff17 	ldw	r3,-4(fp)
 2020d84:	18c00517 	ldw	r3,20(r3)
 2020d88:	000f883a 	mov	r7,zero
 2020d8c:	e1bffe17 	ldw	r6,-8(fp)
 2020d90:	e17fff17 	ldw	r5,-4(fp)
 2020d94:	1809883a 	mov	r4,r3
 2020d98:	103ee83a 	callr	r2
 2020d9c:	e0bffd05 	stb	r2,-12(fp)
 2020da0:	00000606 	br	2020dbc <tcp_process_refused_data+0x98>
 2020da4:	000f883a 	mov	r7,zero
 2020da8:	e1bffe17 	ldw	r6,-8(fp)
 2020dac:	e17fff17 	ldw	r5,-4(fp)
 2020db0:	0009883a 	mov	r4,zero
 2020db4:	2020fe80 	call	2020fe8 <tcp_recv_null>
 2020db8:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
 2020dbc:	e0bffd07 	ldb	r2,-12(fp)
 2020dc0:	1000221e 	bne	r2,zero,2020e4c <tcp_process_refused_data+0x128>
      /* did refused_data include a FIN? */
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
 2020dc4:	e0bffd43 	ldbu	r2,-11(fp)
 2020dc8:	1080080c 	andi	r2,r2,32
 2020dcc:	10002926 	beq	r2,zero,2020e74 <tcp_process_refused_data+0x150>
          && (rest == NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
         ) {
        /* correct rcv_wnd as the application won't call tcp_recved()
           for the FIN's seqno */
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 2020dd0:	e0bfff17 	ldw	r2,-4(fp)
 2020dd4:	10800c0b 	ldhu	r2,48(r2)
 2020dd8:	10bfffcc 	andi	r2,r2,65535
 2020ddc:	10880020 	cmpeqi	r2,r2,8192
 2020de0:	1000061e 	bne	r2,zero,2020dfc <tcp_process_refused_data+0xd8>
          pcb->rcv_wnd++;
 2020de4:	e0bfff17 	ldw	r2,-4(fp)
 2020de8:	10800c0b 	ldhu	r2,48(r2)
 2020dec:	10800044 	addi	r2,r2,1
 2020df0:	1007883a 	mov	r3,r2
 2020df4:	e0bfff17 	ldw	r2,-4(fp)
 2020df8:	10c00c0d 	sth	r3,48(r2)
        }
        TCP_EVENT_CLOSED(pcb, err);
 2020dfc:	e0bfff17 	ldw	r2,-4(fp)
 2020e00:	10802317 	ldw	r2,140(r2)
 2020e04:	10000b26 	beq	r2,zero,2020e34 <tcp_process_refused_data+0x110>
 2020e08:	e0bfff17 	ldw	r2,-4(fp)
 2020e0c:	10802317 	ldw	r2,140(r2)
 2020e10:	e0ffff17 	ldw	r3,-4(fp)
 2020e14:	18c00517 	ldw	r3,20(r3)
 2020e18:	000f883a 	mov	r7,zero
 2020e1c:	000d883a 	mov	r6,zero
 2020e20:	e17fff17 	ldw	r5,-4(fp)
 2020e24:	1809883a 	mov	r4,r3
 2020e28:	103ee83a 	callr	r2
 2020e2c:	e0bffd05 	stb	r2,-12(fp)
 2020e30:	00000106 	br	2020e38 <tcp_process_refused_data+0x114>
 2020e34:	e03ffd05 	stb	zero,-12(fp)
        if (err == ERR_ABRT) {
 2020e38:	e0bffd07 	ldb	r2,-12(fp)
 2020e3c:	10bffcd8 	cmpnei	r2,r2,-13
 2020e40:	10000c1e 	bne	r2,zero,2020e74 <tcp_process_refused_data+0x150>
          return ERR_ABRT;
 2020e44:	00bffcc4 	movi	r2,-13
 2020e48:	00000b06 	br	2020e78 <tcp_process_refused_data+0x154>
        }
      }
    } else if (err == ERR_ABRT) {
 2020e4c:	e0bffd07 	ldb	r2,-12(fp)
 2020e50:	10bffcd8 	cmpnei	r2,r2,-13
 2020e54:	1000021e 	bne	r2,zero,2020e60 <tcp_process_refused_data+0x13c>
      /* if err == ERR_ABRT, 'pcb' is already deallocated */
      /* Drop incoming packets because pcb is "full" (only if the incoming
         segment contains data). */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
      return ERR_ABRT;
 2020e58:	00bffcc4 	movi	r2,-13
 2020e5c:	00000606 	br	2020e78 <tcp_process_refused_data+0x154>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
      if (rest != NULL) {
        pbuf_cat(refused_data, rest);
      }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
      pcb->refused_data = refused_data;
 2020e60:	e0bfff17 	ldw	r2,-4(fp)
 2020e64:	e0fffe17 	ldw	r3,-8(fp)
 2020e68:	10c02015 	stw	r3,128(r2)
      return ERR_INPROGRESS;
 2020e6c:	00bffec4 	movi	r2,-5
 2020e70:	00000106 	br	2020e78 <tcp_process_refused_data+0x154>
    }
  }
  return ERR_OK;
 2020e74:	0005883a 	mov	r2,zero
}
 2020e78:	e037883a 	mov	sp,fp
 2020e7c:	dfc00117 	ldw	ra,4(sp)
 2020e80:	df000017 	ldw	fp,0(sp)
 2020e84:	dec00204 	addi	sp,sp,8
 2020e88:	f800283a 	ret

02020e8c <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 2020e8c:	defffc04 	addi	sp,sp,-16
 2020e90:	dfc00315 	stw	ra,12(sp)
 2020e94:	df000215 	stw	fp,8(sp)
 2020e98:	df000204 	addi	fp,sp,8
 2020e9c:	e13fff15 	stw	r4,-4(fp)
  while (seg != NULL) {
 2020ea0:	00000706 	br	2020ec0 <tcp_segs_free+0x34>
    struct tcp_seg *next = seg->next;
 2020ea4:	e0bfff17 	ldw	r2,-4(fp)
 2020ea8:	10800017 	ldw	r2,0(r2)
 2020eac:	e0bffe15 	stw	r2,-8(fp)
    tcp_seg_free(seg);
 2020eb0:	e13fff17 	ldw	r4,-4(fp)
 2020eb4:	2020ee00 	call	2020ee0 <tcp_seg_free>
    seg = next;
 2020eb8:	e0bffe17 	ldw	r2,-8(fp)
 2020ebc:	e0bfff15 	stw	r2,-4(fp)
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 2020ec0:	e0bfff17 	ldw	r2,-4(fp)
 2020ec4:	103ff71e 	bne	r2,zero,2020ea4 <__alt_mem_mem_0+0xfd000ea4>
    struct tcp_seg *next = seg->next;
    tcp_seg_free(seg);
    seg = next;
  }
}
 2020ec8:	0001883a 	nop
 2020ecc:	e037883a 	mov	sp,fp
 2020ed0:	dfc00117 	ldw	ra,4(sp)
 2020ed4:	df000017 	ldw	fp,0(sp)
 2020ed8:	dec00204 	addi	sp,sp,8
 2020edc:	f800283a 	ret

02020ee0 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 2020ee0:	defffd04 	addi	sp,sp,-12
 2020ee4:	dfc00215 	stw	ra,8(sp)
 2020ee8:	df000115 	stw	fp,4(sp)
 2020eec:	df000104 	addi	fp,sp,4
 2020ef0:	e13fff15 	stw	r4,-4(fp)
  if (seg != NULL) {
 2020ef4:	e0bfff17 	ldw	r2,-4(fp)
 2020ef8:	10000a26 	beq	r2,zero,2020f24 <tcp_seg_free+0x44>
    if (seg->p != NULL) {
 2020efc:	e0bfff17 	ldw	r2,-4(fp)
 2020f00:	10800117 	ldw	r2,4(r2)
 2020f04:	10000426 	beq	r2,zero,2020f18 <tcp_seg_free+0x38>
      pbuf_free(seg->p);
 2020f08:	e0bfff17 	ldw	r2,-4(fp)
 2020f0c:	10800117 	ldw	r2,4(r2)
 2020f10:	1009883a 	mov	r4,r2
 2020f14:	201d2f40 	call	201d2f4 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 2020f18:	e17fff17 	ldw	r5,-4(fp)
 2020f1c:	01000104 	movi	r4,4
 2020f20:	201b9640 	call	201b964 <memp_free>
  }
}
 2020f24:	0001883a 	nop
 2020f28:	e037883a 	mov	sp,fp
 2020f2c:	dfc00117 	ldw	ra,4(sp)
 2020f30:	df000017 	ldw	fp,0(sp)
 2020f34:	dec00204 	addi	sp,sp,8
 2020f38:	f800283a 	ret

02020f3c <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
 2020f3c:	defffd04 	addi	sp,sp,-12
 2020f40:	df000215 	stw	fp,8(sp)
 2020f44:	df000204 	addi	fp,sp,8
 2020f48:	e13ffe15 	stw	r4,-8(fp)
 2020f4c:	2805883a 	mov	r2,r5
 2020f50:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_setprio: invalid pcb", pcb != NULL, return);
 2020f54:	e0bffe17 	ldw	r2,-8(fp)
 2020f58:	10000426 	beq	r2,zero,2020f6c <tcp_setprio+0x30>

  pcb->prio = prio;
 2020f5c:	e0bffe17 	ldw	r2,-8(fp)
 2020f60:	e0ffff03 	ldbu	r3,-4(fp)
 2020f64:	10c00705 	stb	r3,28(r2)
 2020f68:	00000106 	br	2020f70 <tcp_setprio+0x34>
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_setprio: invalid pcb", pcb != NULL, return);
 2020f6c:	0001883a 	nop

  pcb->prio = prio;
}
 2020f70:	e037883a 	mov	sp,fp
 2020f74:	df000017 	ldw	fp,0(sp)
 2020f78:	dec00104 	addi	sp,sp,4
 2020f7c:	f800283a 	ret

02020f80 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 2020f80:	defffc04 	addi	sp,sp,-16
 2020f84:	dfc00315 	stw	ra,12(sp)
 2020f88:	df000215 	stw	fp,8(sp)
 2020f8c:	df000204 	addi	fp,sp,8
 2020f90:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *cseg;

  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 2020f94:	01000104 	movi	r4,4
 2020f98:	201b82c0 	call	201b82c <memp_malloc>
 2020f9c:	e0bffe15 	stw	r2,-8(fp)
  if (cseg == NULL) {
 2020fa0:	e0bffe17 	ldw	r2,-8(fp)
 2020fa4:	1000021e 	bne	r2,zero,2020fb0 <tcp_seg_copy+0x30>
    return NULL;
 2020fa8:	0005883a 	mov	r2,zero
 2020fac:	00000906 	br	2020fd4 <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 2020fb0:	01800504 	movi	r6,20
 2020fb4:	e17fff17 	ldw	r5,-4(fp)
 2020fb8:	e13ffe17 	ldw	r4,-8(fp)
 2020fbc:	2005e580 	call	2005e58 <memcpy>
  pbuf_ref(cseg->p);
 2020fc0:	e0bffe17 	ldw	r2,-8(fp)
 2020fc4:	10800117 	ldw	r2,4(r2)
 2020fc8:	1009883a 	mov	r4,r2
 2020fcc:	201d4780 	call	201d478 <pbuf_ref>
  return cseg;
 2020fd0:	e0bffe17 	ldw	r2,-8(fp)
}
 2020fd4:	e037883a 	mov	sp,fp
 2020fd8:	dfc00117 	ldw	ra,4(sp)
 2020fdc:	df000017 	ldw	fp,0(sp)
 2020fe0:	dec00204 	addi	sp,sp,8
 2020fe4:	f800283a 	ret

02020fe8 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 2020fe8:	defffa04 	addi	sp,sp,-24
 2020fec:	dfc00515 	stw	ra,20(sp)
 2020ff0:	df000415 	stw	fp,16(sp)
 2020ff4:	df000404 	addi	fp,sp,16
 2020ff8:	e13ffc15 	stw	r4,-16(fp)
 2020ffc:	e17ffd15 	stw	r5,-12(fp)
 2021000:	e1bffe15 	stw	r6,-8(fp)
 2021004:	3805883a 	mov	r2,r7
 2021008:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);

  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
 202100c:	e0bffd17 	ldw	r2,-12(fp)
 2021010:	1000021e 	bne	r2,zero,202101c <tcp_recv_null+0x34>
 2021014:	00bffc04 	movi	r2,-16
 2021018:	00001106 	br	2021060 <tcp_recv_null+0x78>

  if (p != NULL) {
 202101c:	e0bffe17 	ldw	r2,-8(fp)
 2021020:	10000926 	beq	r2,zero,2021048 <tcp_recv_null+0x60>
    tcp_recved(pcb, p->tot_len);
 2021024:	e0bffe17 	ldw	r2,-8(fp)
 2021028:	1080020b 	ldhu	r2,8(r2)
 202102c:	10bfffcc 	andi	r2,r2,65535
 2021030:	100b883a 	mov	r5,r2
 2021034:	e13ffd17 	ldw	r4,-12(fp)
 2021038:	201fd780 	call	201fd78 <tcp_recved>
    pbuf_free(p);
 202103c:	e13ffe17 	ldw	r4,-8(fp)
 2021040:	201d2f40 	call	201d2f4 <pbuf_free>
 2021044:	00000506 	br	202105c <tcp_recv_null+0x74>
  } else if (err == ERR_OK) {
 2021048:	e0bfff07 	ldb	r2,-4(fp)
 202104c:	1000031e 	bne	r2,zero,202105c <tcp_recv_null+0x74>
    return tcp_close(pcb);
 2021050:	e13ffd17 	ldw	r4,-12(fp)
 2021054:	201f3880 	call	201f388 <tcp_close>
 2021058:	00000106 	br	2021060 <tcp_recv_null+0x78>
  }
  return ERR_OK;
 202105c:	0005883a 	mov	r2,zero
}
 2021060:	e037883a 	mov	sp,fp
 2021064:	dfc00117 	ldw	ra,4(sp)
 2021068:	df000017 	ldw	fp,0(sp)
 202106c:	dec00204 	addi	sp,sp,8
 2021070:	f800283a 	ret

02021074 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 2021074:	defff904 	addi	sp,sp,-28
 2021078:	dfc00615 	stw	ra,24(sp)
 202107c:	df000515 	stw	fp,20(sp)
 2021080:	df000504 	addi	fp,sp,20
 2021084:	2005883a 	mov	r2,r4
 2021088:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;

  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 202108c:	e0bfff03 	ldbu	r2,-4(fp)
 2021090:	10803fcc 	andi	r2,r2,255
 2021094:	1080201c 	xori	r2,r2,128
 2021098:	10bfe004 	addi	r2,r2,-128
 202109c:	10000216 	blt	r2,zero,20210a8 <tcp_kill_prio+0x34>
 20210a0:	e0bfff03 	ldbu	r2,-4(fp)
 20210a4:	00000106 	br	20210ac <tcp_kill_prio+0x38>
 20210a8:	00801fc4 	movi	r2,127
 20210ac:	e0bffe05 	stb	r2,-8(fp)

  /* We want to kill connections with a lower prio, so bail out if
   * supplied prio is 0 - there can never be a lower prio
   */
  if (mprio == 0) {
 20210b0:	e0bffe03 	ldbu	r2,-8(fp)
 20210b4:	10002c26 	beq	r2,zero,2021168 <tcp_kill_prio+0xf4>
  /* We only want kill connections with a lower prio, so decrement prio by one
   * and start searching for oldest connection with same or lower priority than mprio.
   * We want to find the connections with the lowest possible prio, and among
   * these the one with the longest inactivity time.
   */
  mprio--;
 20210b8:	e0bffe03 	ldbu	r2,-8(fp)
 20210bc:	10bfffc4 	addi	r2,r2,-1
 20210c0:	e0bffe05 	stb	r2,-8(fp)

  inactivity = 0;
 20210c4:	e03ffd15 	stw	zero,-12(fp)
  inactive = NULL;
 20210c8:	e03ffc15 	stw	zero,-16(fp)
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 20210cc:	d0a7e117 	ldw	r2,-24700(gp)
 20210d0:	e0bffb15 	stw	r2,-20(fp)
 20210d4:	00001d06 	br	202114c <tcp_kill_prio+0xd8>
        /* lower prio is always a kill candidate */
    if ((pcb->prio < mprio) ||
 20210d8:	e0bffb17 	ldw	r2,-20(fp)
 20210dc:	10800703 	ldbu	r2,28(r2)
 20210e0:	10c03fcc 	andi	r3,r2,255
 20210e4:	e0bffe03 	ldbu	r2,-8(fp)
 20210e8:	18800b36 	bltu	r3,r2,2021118 <tcp_kill_prio+0xa4>
        /* longer inactivity is also a kill candidate */
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 20210ec:	e0bffb17 	ldw	r2,-20(fp)
 20210f0:	10800703 	ldbu	r2,28(r2)

  inactivity = 0;
  inactive = NULL;
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
        /* lower prio is always a kill candidate */
    if ((pcb->prio < mprio) ||
 20210f4:	10c03fcc 	andi	r3,r2,255
 20210f8:	e0bffe03 	ldbu	r2,-8(fp)
 20210fc:	1880101e 	bne	r3,r2,2021140 <tcp_kill_prio+0xcc>
        /* longer inactivity is also a kill candidate */
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 2021100:	d0e7e217 	ldw	r3,-24696(gp)
 2021104:	e0bffb17 	ldw	r2,-20(fp)
 2021108:	10800a17 	ldw	r2,40(r2)
 202110c:	1887c83a 	sub	r3,r3,r2
 2021110:	e0bffd17 	ldw	r2,-12(fp)
 2021114:	18800a36 	bltu	r3,r2,2021140 <tcp_kill_prio+0xcc>
      inactivity = tcp_ticks - pcb->tmr;
 2021118:	d0e7e217 	ldw	r3,-24696(gp)
 202111c:	e0bffb17 	ldw	r2,-20(fp)
 2021120:	10800a17 	ldw	r2,40(r2)
 2021124:	1885c83a 	sub	r2,r3,r2
 2021128:	e0bffd15 	stw	r2,-12(fp)
      inactive   = pcb;
 202112c:	e0bffb17 	ldw	r2,-20(fp)
 2021130:	e0bffc15 	stw	r2,-16(fp)
      mprio      = pcb->prio;
 2021134:	e0bffb17 	ldw	r2,-20(fp)
 2021138:	10800703 	ldbu	r2,28(r2)
 202113c:	e0bffe05 	stb	r2,-8(fp)
   */
  mprio--;

  inactivity = 0;
  inactive = NULL;
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 2021140:	e0bffb17 	ldw	r2,-20(fp)
 2021144:	10800417 	ldw	r2,16(r2)
 2021148:	e0bffb15 	stw	r2,-20(fp)
 202114c:	e0bffb17 	ldw	r2,-20(fp)
 2021150:	103fe11e 	bne	r2,zero,20210d8 <__alt_mem_mem_0+0xfd0010d8>
      inactivity = tcp_ticks - pcb->tmr;
      inactive   = pcb;
      mprio      = pcb->prio;
    }
  }
  if (inactive != NULL) {
 2021154:	e0bffc17 	ldw	r2,-16(fp)
 2021158:	10000426 	beq	r2,zero,202116c <tcp_kill_prio+0xf8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 202115c:	e13ffc17 	ldw	r4,-16(fp)
 2021160:	201f70c0 	call	201f70c <tcp_abort>
 2021164:	00000106 	br	202116c <tcp_kill_prio+0xf8>

  /* We want to kill connections with a lower prio, so bail out if
   * supplied prio is 0 - there can never be a lower prio
   */
  if (mprio == 0) {
    return;
 2021168:	0001883a 	nop
  if (inactive != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
  }
}
 202116c:	e037883a 	mov	sp,fp
 2021170:	dfc00117 	ldw	ra,4(sp)
 2021174:	df000017 	ldw	fp,0(sp)
 2021178:	dec00204 	addi	sp,sp,8
 202117c:	f800283a 	ret

02021180 <tcp_kill_state>:
 * Kills the oldest connection that is in specific state.
 * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
 */
static void
tcp_kill_state(enum tcp_state state)
{
 2021180:	defffa04 	addi	sp,sp,-24
 2021184:	dfc00515 	stw	ra,20(sp)
 2021188:	df000415 	stw	fp,16(sp)
 202118c:	df000404 	addi	fp,sp,16
 2021190:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));

  inactivity = 0;
 2021194:	e03ffe15 	stw	zero,-8(fp)
  inactive = NULL;
 2021198:	e03ffd15 	stw	zero,-12(fp)
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 202119c:	d0a7e117 	ldw	r2,-24700(gp)
 20211a0:	e0bffc15 	stw	r2,-16(fp)
 20211a4:	00001406 	br	20211f8 <tcp_kill_state+0x78>
    if (pcb->state == state) {
 20211a8:	e0bffc17 	ldw	r2,-16(fp)
 20211ac:	10c00617 	ldw	r3,24(r2)
 20211b0:	e0bfff17 	ldw	r2,-4(fp)
 20211b4:	18800d1e 	bne	r3,r2,20211ec <tcp_kill_state+0x6c>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 20211b8:	d0e7e217 	ldw	r3,-24696(gp)
 20211bc:	e0bffc17 	ldw	r2,-16(fp)
 20211c0:	10800a17 	ldw	r2,40(r2)
 20211c4:	1887c83a 	sub	r3,r3,r2
 20211c8:	e0bffe17 	ldw	r2,-8(fp)
 20211cc:	18800736 	bltu	r3,r2,20211ec <tcp_kill_state+0x6c>
        inactivity = tcp_ticks - pcb->tmr;
 20211d0:	d0e7e217 	ldw	r3,-24696(gp)
 20211d4:	e0bffc17 	ldw	r2,-16(fp)
 20211d8:	10800a17 	ldw	r2,40(r2)
 20211dc:	1885c83a 	sub	r2,r3,r2
 20211e0:	e0bffe15 	stw	r2,-8(fp)
        inactive = pcb;
 20211e4:	e0bffc17 	ldw	r2,-16(fp)
 20211e8:	e0bffd15 	stw	r2,-12(fp)

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 20211ec:	e0bffc17 	ldw	r2,-16(fp)
 20211f0:	10800417 	ldw	r2,16(r2)
 20211f4:	e0bffc15 	stw	r2,-16(fp)
 20211f8:	e0bffc17 	ldw	r2,-16(fp)
 20211fc:	103fea1e 	bne	r2,zero,20211a8 <__alt_mem_mem_0+0xfd0011a8>
        inactivity = tcp_ticks - pcb->tmr;
        inactive = pcb;
      }
    }
  }
  if (inactive != NULL) {
 2021200:	e0bffd17 	ldw	r2,-12(fp)
 2021204:	10000326 	beq	r2,zero,2021214 <tcp_kill_state+0x94>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
                            tcp_state_str[state], (void *)inactive, inactivity));
    /* Don't send a RST, since no data is lost. */
    tcp_abandon(inactive, 0);
 2021208:	000b883a 	mov	r5,zero
 202120c:	e13ffd17 	ldw	r4,-12(fp)
 2021210:	201f4f40 	call	201f4f4 <tcp_abandon>
  }
}
 2021214:	0001883a 	nop
 2021218:	e037883a 	mov	sp,fp
 202121c:	dfc00117 	ldw	ra,4(sp)
 2021220:	df000017 	ldw	fp,0(sp)
 2021224:	dec00204 	addi	sp,sp,8
 2021228:	f800283a 	ret

0202122c <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 202122c:	defffb04 	addi	sp,sp,-20
 2021230:	dfc00415 	stw	ra,16(sp)
 2021234:	df000315 	stw	fp,12(sp)
 2021238:	df000304 	addi	fp,sp,12
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 202123c:	e03fff15 	stw	zero,-4(fp)
  inactive = NULL;
 2021240:	e03ffe15 	stw	zero,-8(fp)
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 2021244:	d0a7e517 	ldw	r2,-24684(gp)
 2021248:	e0bffd15 	stw	r2,-12(fp)
 202124c:	00001006 	br	2021290 <tcp_kill_timewait+0x64>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 2021250:	d0e7e217 	ldw	r3,-24696(gp)
 2021254:	e0bffd17 	ldw	r2,-12(fp)
 2021258:	10800a17 	ldw	r2,40(r2)
 202125c:	1887c83a 	sub	r3,r3,r2
 2021260:	e0bfff17 	ldw	r2,-4(fp)
 2021264:	18800736 	bltu	r3,r2,2021284 <tcp_kill_timewait+0x58>
      inactivity = tcp_ticks - pcb->tmr;
 2021268:	d0e7e217 	ldw	r3,-24696(gp)
 202126c:	e0bffd17 	ldw	r2,-12(fp)
 2021270:	10800a17 	ldw	r2,40(r2)
 2021274:	1885c83a 	sub	r2,r3,r2
 2021278:	e0bfff15 	stw	r2,-4(fp)
      inactive = pcb;
 202127c:	e0bffd17 	ldw	r2,-12(fp)
 2021280:	e0bffe15 	stw	r2,-8(fp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 2021284:	e0bffd17 	ldw	r2,-12(fp)
 2021288:	10800417 	ldw	r2,16(r2)
 202128c:	e0bffd15 	stw	r2,-12(fp)
 2021290:	e0bffd17 	ldw	r2,-12(fp)
 2021294:	103fee1e 	bne	r2,zero,2021250 <__alt_mem_mem_0+0xfd001250>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
 2021298:	e0bffe17 	ldw	r2,-8(fp)
 202129c:	10000226 	beq	r2,zero,20212a8 <tcp_kill_timewait+0x7c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 20212a0:	e13ffe17 	ldw	r4,-8(fp)
 20212a4:	201f70c0 	call	201f70c <tcp_abort>
  }
}
 20212a8:	0001883a 	nop
 20212ac:	e037883a 	mov	sp,fp
 20212b0:	dfc00117 	ldw	ra,4(sp)
 20212b4:	df000017 	ldw	fp,0(sp)
 20212b8:	dec00204 	addi	sp,sp,8
 20212bc:	f800283a 	ret

020212c0 <tcp_handle_closepend>:
 * now send the FIN (which failed before), the pcb might be in a state that is
 * OK for us to now free it.
 */
static void
tcp_handle_closepend(void)
{
 20212c0:	defffc04 	addi	sp,sp,-16
 20212c4:	dfc00315 	stw	ra,12(sp)
 20212c8:	df000215 	stw	fp,8(sp)
 20212cc:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb = tcp_active_pcbs;
 20212d0:	d0a7e117 	ldw	r2,-24700(gp)
 20212d4:	e0bffe15 	stw	r2,-8(fp)

  while (pcb != NULL) {
 20212d8:	00001306 	br	2021328 <tcp_handle_closepend+0x68>
    struct tcp_pcb *next = pcb->next;
 20212dc:	e0bffe17 	ldw	r2,-8(fp)
 20212e0:	10800417 	ldw	r2,16(r2)
 20212e4:	e0bfff15 	stw	r2,-4(fp)
    /* send pending FIN */
    if (pcb->flags & TF_CLOSEPEND) {
 20212e8:	e0bffe17 	ldw	r2,-8(fp)
 20212ec:	1080088b 	ldhu	r2,34(r2)
 20212f0:	10bfffcc 	andi	r2,r2,65535
 20212f4:	1080020c 	andi	r2,r2,8
 20212f8:	10000926 	beq	r2,zero,2021320 <tcp_handle_closepend+0x60>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
      tcp_clear_flags(pcb, TF_CLOSEPEND);
 20212fc:	e0bffe17 	ldw	r2,-8(fp)
 2021300:	10c0088b 	ldhu	r3,34(r2)
 2021304:	00bffdc4 	movi	r2,-9
 2021308:	1884703a 	and	r2,r3,r2
 202130c:	1007883a 	mov	r3,r2
 2021310:	e0bffe17 	ldw	r2,-8(fp)
 2021314:	10c0088d 	sth	r3,34(r2)
      tcp_close_shutdown_fin(pcb);
 2021318:	e13ffe17 	ldw	r4,-8(fp)
 202131c:	201f26c0 	call	201f26c <tcp_close_shutdown_fin>
    }
    pcb = next;
 2021320:	e0bfff17 	ldw	r2,-4(fp)
 2021324:	e0bffe15 	stw	r2,-8(fp)
static void
tcp_handle_closepend(void)
{
  struct tcp_pcb *pcb = tcp_active_pcbs;

  while (pcb != NULL) {
 2021328:	e0bffe17 	ldw	r2,-8(fp)
 202132c:	103feb1e 	bne	r2,zero,20212dc <__alt_mem_mem_0+0xfd0012dc>
      tcp_clear_flags(pcb, TF_CLOSEPEND);
      tcp_close_shutdown_fin(pcb);
    }
    pcb = next;
  }
}
 2021330:	0001883a 	nop
 2021334:	e037883a 	mov	sp,fp
 2021338:	dfc00117 	ldw	ra,4(sp)
 202133c:	df000017 	ldw	fp,0(sp)
 2021340:	dec00204 	addi	sp,sp,8
 2021344:	f800283a 	ret

02021348 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 2021348:	defffc04 	addi	sp,sp,-16
 202134c:	dfc00315 	stw	ra,12(sp)
 2021350:	df000215 	stw	fp,8(sp)
 2021354:	df000204 	addi	fp,sp,8
 2021358:	2005883a 	mov	r2,r4
 202135c:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 2021360:	01000084 	movi	r4,2
 2021364:	201b82c0 	call	201b82c <memp_malloc>
 2021368:	e0bffe15 	stw	r2,-8(fp)
  if (pcb == NULL) {
 202136c:	e0bffe17 	ldw	r2,-8(fp)
 2021370:	10003b1e 	bne	r2,zero,2021460 <tcp_alloc+0x118>
    /* Try to send FIN for all pcbs stuck in TF_CLOSEPEND first */
    tcp_handle_closepend();
 2021374:	20212c00 	call	20212c0 <tcp_handle_closepend>

    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 2021378:	202122c0 	call	202122c <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 202137c:	01000084 	movi	r4,2
 2021380:	201b82c0 	call	201b82c <memp_malloc>
 2021384:	e0bffe15 	stw	r2,-8(fp)
    if (pcb == NULL) {
 2021388:	e0bffe17 	ldw	r2,-8(fp)
 202138c:	10002c1e 	bne	r2,zero,2021440 <tcp_alloc+0xf8>
      /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
      tcp_kill_state(LAST_ACK);
 2021390:	01000244 	movi	r4,9
 2021394:	20211800 	call	2021180 <tcp_kill_state>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 2021398:	01000084 	movi	r4,2
 202139c:	201b82c0 	call	201b82c <memp_malloc>
 20213a0:	e0bffe15 	stw	r2,-8(fp)
      if (pcb == NULL) {
 20213a4:	e0bffe17 	ldw	r2,-8(fp)
 20213a8:	10001d1e 	bne	r2,zero,2021420 <tcp_alloc+0xd8>
        /* Try killing oldest connection in CLOSING. */
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
        tcp_kill_state(CLOSING);
 20213ac:	01000204 	movi	r4,8
 20213b0:	20211800 	call	2021180 <tcp_kill_state>
        /* Try to allocate a tcp_pcb again. */
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 20213b4:	01000084 	movi	r4,2
 20213b8:	201b82c0 	call	201b82c <memp_malloc>
 20213bc:	e0bffe15 	stw	r2,-8(fp)
        if (pcb == NULL) {
 20213c0:	e0bffe17 	ldw	r2,-8(fp)
 20213c4:	10000e1e 	bne	r2,zero,2021400 <tcp_alloc+0xb8>
          /* Try killing oldest active connection with lower priority than the new one. */
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing oldest connection with prio lower than %d\n", prio));
          tcp_kill_prio(prio);
 20213c8:	e0bfff03 	ldbu	r2,-4(fp)
 20213cc:	1009883a 	mov	r4,r2
 20213d0:	20210740 	call	2021074 <tcp_kill_prio>
          /* Try to allocate a tcp_pcb again. */
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 20213d4:	01000084 	movi	r4,2
 20213d8:	201b82c0 	call	201b82c <memp_malloc>
 20213dc:	e0bffe15 	stw	r2,-8(fp)
          if (pcb != NULL) {
 20213e0:	e0bffe17 	ldw	r2,-8(fp)
 20213e4:	10000626 	beq	r2,zero,2021400 <tcp_alloc+0xb8>
            /* adjust err stats: memp_malloc failed multiple times before */
            MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 20213e8:	008085f4 	movhi	r2,535
 20213ec:	10bd8204 	addi	r2,r2,-2552
 20213f0:	10805a17 	ldw	r2,360(r2)
 20213f4:	10c00017 	ldw	r3,0(r2)
 20213f8:	18ffffc4 	addi	r3,r3,-1
 20213fc:	10c00015 	stw	r3,0(r2)
          }
        }
        if (pcb != NULL) {
 2021400:	e0bffe17 	ldw	r2,-8(fp)
 2021404:	10000626 	beq	r2,zero,2021420 <tcp_alloc+0xd8>
          /* adjust err stats: memp_malloc failed multiple times before */
          MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 2021408:	008085f4 	movhi	r2,535
 202140c:	10bd8204 	addi	r2,r2,-2552
 2021410:	10805a17 	ldw	r2,360(r2)
 2021414:	10c00017 	ldw	r3,0(r2)
 2021418:	18ffffc4 	addi	r3,r3,-1
 202141c:	10c00015 	stw	r3,0(r2)
        }
      }
      if (pcb != NULL) {
 2021420:	e0bffe17 	ldw	r2,-8(fp)
 2021424:	10000626 	beq	r2,zero,2021440 <tcp_alloc+0xf8>
        /* adjust err stats: memp_malloc failed multiple times before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 2021428:	008085f4 	movhi	r2,535
 202142c:	10bd8204 	addi	r2,r2,-2552
 2021430:	10805a17 	ldw	r2,360(r2)
 2021434:	10c00017 	ldw	r3,0(r2)
 2021438:	18ffffc4 	addi	r3,r3,-1
 202143c:	10c00015 	stw	r3,0(r2)
      }
    }
    if (pcb != NULL) {
 2021440:	e0bffe17 	ldw	r2,-8(fp)
 2021444:	10000626 	beq	r2,zero,2021460 <tcp_alloc+0x118>
      /* adjust err stats: memp_malloc failed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 2021448:	008085f4 	movhi	r2,535
 202144c:	10bd8204 	addi	r2,r2,-2552
 2021450:	10805a17 	ldw	r2,360(r2)
 2021454:	10c00017 	ldw	r3,0(r2)
 2021458:	18ffffc4 	addi	r3,r3,-1
 202145c:	10c00015 	stw	r3,0(r2)
    }
  }
  if (pcb != NULL) {
 2021460:	e0bffe17 	ldw	r2,-8(fp)
 2021464:	10003b26 	beq	r2,zero,2021554 <tcp_alloc+0x20c>
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
 2021468:	01802b04 	movi	r6,172
 202146c:	000b883a 	mov	r5,zero
 2021470:	e13ffe17 	ldw	r4,-8(fp)
 2021474:	2005fa00 	call	2005fa0 <memset>
    pcb->prio = prio;
 2021478:	e0bffe17 	ldw	r2,-8(fp)
 202147c:	e0ffff03 	ldbu	r3,-4(fp)
 2021480:	10c00705 	stb	r3,28(r2)
    pcb->snd_buf = TCP_SND_BUF;
 2021484:	e0bffe17 	ldw	r2,-8(fp)
 2021488:	00c2da04 	movi	r3,2920
 202148c:	10c01b0d 	sth	r3,108(r2)
    /* Start with a window that does not need scaling. When window scaling is
       enabled and used, the window is enlarged when both sides agree on scaling. */
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 2021490:	e0bffe17 	ldw	r2,-8(fp)
 2021494:	00c80004 	movi	r3,8192
 2021498:	10c00c8d 	sth	r3,50(r2)
 202149c:	e0bffe17 	ldw	r2,-8(fp)
 20214a0:	10c00c8b 	ldhu	r3,50(r2)
 20214a4:	e0bffe17 	ldw	r2,-8(fp)
 20214a8:	10c00c0d 	sth	r3,48(r2)
    pcb->ttl = TCP_TTL;
 20214ac:	e0bffe17 	ldw	r2,-8(fp)
 20214b0:	00c01004 	movi	r3,64
 20214b4:	10c002c5 	stb	r3,11(r2)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = INITIAL_MSS;
 20214b8:	e0bffe17 	ldw	r2,-8(fp)
 20214bc:	00c08604 	movi	r3,536
 20214c0:	10c00e8d 	sth	r3,58(r2)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 20214c4:	e0bffe17 	ldw	r2,-8(fp)
 20214c8:	00c00184 	movi	r3,6
 20214cc:	10c0120d 	sth	r3,72(r2)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 20214d0:	e0bffe17 	ldw	r2,-8(fp)
 20214d4:	00c00184 	movi	r3,6
 20214d8:	10c0118d 	sth	r3,70(r2)
    pcb->rtime = -1;
 20214dc:	e0bffe17 	ldw	r2,-8(fp)
 20214e0:	00ffffc4 	movi	r3,-1
 20214e4:	10c00e0d 	sth	r3,56(r2)
    pcb->cwnd = 1;
 20214e8:	e0bffe17 	ldw	r2,-8(fp)
 20214ec:	00c00044 	movi	r3,1
 20214f0:	10c0140d 	sth	r3,80(r2)
    pcb->tmr = tcp_ticks;
 20214f4:	d0e7e217 	ldw	r3,-24696(gp)
 20214f8:	e0bffe17 	ldw	r2,-8(fp)
 20214fc:	10c00a15 	stw	r3,40(r2)
    pcb->last_timer = tcp_timer_ctr;
 2021500:	d0e7e043 	ldbu	r3,-24703(gp)
 2021504:	e0bffe17 	ldw	r2,-8(fp)
 2021508:	10c00985 	stb	r3,38(r2)
    of using the largest advertised receive window.  We've seen complications with
    receiving TCPs that use window scaling and/or window auto-tuning where the
    initial advertised window is very small and then grows rapidly once the
    connection is established. To avoid these complications, we set ssthresh to the
    largest effective cwnd (amount of in-flight data) that the sender can have. */
    pcb->ssthresh = TCP_SND_BUF;
 202150c:	e0bffe17 	ldw	r2,-8(fp)
 2021510:	00c2da04 	movi	r3,2920
 2021514:	10c0148d 	sth	r3,82(r2)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 2021518:	e0fffe17 	ldw	r3,-8(fp)
 202151c:	008080b4 	movhi	r2,514
 2021520:	1083fa04 	addi	r2,r2,4072
 2021524:	18802315 	stw	r2,140(r3)
#endif /* LWIP_CALLBACK_API */

    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 2021528:	e0fffe17 	ldw	r3,-8(fp)
 202152c:	00801bb4 	movhi	r2,110
 2021530:	10b74004 	addi	r2,r2,-8960
 2021534:	18802715 	stw	r2,156(r3)

#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 2021538:	e0fffe17 	ldw	r3,-8(fp)
 202153c:	00800074 	movhi	r2,1
 2021540:	10893e04 	addi	r2,r2,9464
 2021544:	18802815 	stw	r2,160(r3)
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 2021548:	e0bffe17 	ldw	r2,-8(fp)
 202154c:	00c00244 	movi	r3,9
 2021550:	10c02915 	stw	r3,164(r2)
#endif /* LWIP_TCP_KEEPALIVE */
  }
  return pcb;
 2021554:	e0bffe17 	ldw	r2,-8(fp)
}
 2021558:	e037883a 	mov	sp,fp
 202155c:	dfc00117 	ldw	ra,4(sp)
 2021560:	df000017 	ldw	fp,0(sp)
 2021564:	dec00204 	addi	sp,sp,8
 2021568:	f800283a 	ret

0202156c <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 202156c:	defffe04 	addi	sp,sp,-8
 2021570:	dfc00115 	stw	ra,4(sp)
 2021574:	df000015 	stw	fp,0(sp)
 2021578:	d839883a 	mov	fp,sp
  return tcp_alloc(TCP_PRIO_NORMAL);
 202157c:	01001004 	movi	r4,64
 2021580:	20213480 	call	2021348 <tcp_alloc>
}
 2021584:	e037883a 	mov	sp,fp
 2021588:	dfc00117 	ldw	ra,4(sp)
 202158c:	df000017 	ldw	fp,0(sp)
 2021590:	dec00204 	addi	sp,sp,8
 2021594:	f800283a 	ret

02021598 <tcp_new_ip_type>:
 * supply @ref IPADDR_TYPE_ANY as argument and bind to @ref IP_ANY_TYPE.
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new_ip_type(u8_t type)
{
 2021598:	defffc04 	addi	sp,sp,-16
 202159c:	dfc00315 	stw	ra,12(sp)
 20215a0:	df000215 	stw	fp,8(sp)
 20215a4:	df000204 	addi	fp,sp,8
 20215a8:	2005883a 	mov	r2,r4
 20215ac:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb;
  pcb = tcp_alloc(TCP_PRIO_NORMAL);
 20215b0:	01001004 	movi	r4,64
 20215b4:	20213480 	call	2021348 <tcp_alloc>
 20215b8:	e0bffe15 	stw	r2,-8(fp)
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
 20215bc:	e0bffe17 	ldw	r2,-8(fp)
}
 20215c0:	e037883a 	mov	sp,fp
 20215c4:	dfc00117 	ldw	ra,4(sp)
 20215c8:	df000017 	ldw	fp,0(sp)
 20215cc:	dec00204 	addi	sp,sp,8
 20215d0:	f800283a 	ret

020215d4 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
 20215d4:	defffd04 	addi	sp,sp,-12
 20215d8:	df000215 	stw	fp,8(sp)
 20215dc:	df000204 	addi	fp,sp,8
 20215e0:	e13ffe15 	stw	r4,-8(fp)
 20215e4:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 20215e8:	e0bffe17 	ldw	r2,-8(fp)
 20215ec:	10000326 	beq	r2,zero,20215fc <tcp_arg+0x28>
    pcb->callback_arg = arg;
 20215f0:	e0bffe17 	ldw	r2,-8(fp)
 20215f4:	e0ffff17 	ldw	r3,-4(fp)
 20215f8:	10c00515 	stw	r3,20(r2)
  }
}
 20215fc:	0001883a 	nop
 2021600:	e037883a 	mov	sp,fp
 2021604:	df000017 	ldw	fp,0(sp)
 2021608:	dec00104 	addi	sp,sp,4
 202160c:	f800283a 	ret

02021610 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 2021610:	defffd04 	addi	sp,sp,-12
 2021614:	df000215 	stw	fp,8(sp)
 2021618:	df000204 	addi	fp,sp,8
 202161c:	e13ffe15 	stw	r4,-8(fp)
 2021620:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 2021624:	e0bffe17 	ldw	r2,-8(fp)
 2021628:	10000326 	beq	r2,zero,2021638 <tcp_recv+0x28>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
    pcb->recv = recv;
 202162c:	e0bffe17 	ldw	r2,-8(fp)
 2021630:	e0ffff17 	ldw	r3,-4(fp)
 2021634:	10c02315 	stw	r3,140(r2)
  }
}
 2021638:	0001883a 	nop
 202163c:	e037883a 	mov	sp,fp
 2021640:	df000017 	ldw	fp,0(sp)
 2021644:	dec00104 	addi	sp,sp,4
 2021648:	f800283a 	ret

0202164c <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 202164c:	defffd04 	addi	sp,sp,-12
 2021650:	df000215 	stw	fp,8(sp)
 2021654:	df000204 	addi	fp,sp,8
 2021658:	e13ffe15 	stw	r4,-8(fp)
 202165c:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 2021660:	e0bffe17 	ldw	r2,-8(fp)
 2021664:	10000326 	beq	r2,zero,2021674 <tcp_sent+0x28>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
    pcb->sent = sent;
 2021668:	e0bffe17 	ldw	r2,-8(fp)
 202166c:	e0ffff17 	ldw	r3,-4(fp)
 2021670:	10c02215 	stw	r3,136(r2)
  }
}
 2021674:	0001883a 	nop
 2021678:	e037883a 	mov	sp,fp
 202167c:	df000017 	ldw	fp,0(sp)
 2021680:	dec00104 	addi	sp,sp,4
 2021684:	f800283a 	ret

02021688 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 2021688:	defffd04 	addi	sp,sp,-12
 202168c:	df000215 	stw	fp,8(sp)
 2021690:	df000204 	addi	fp,sp,8
 2021694:	e13ffe15 	stw	r4,-8(fp)
 2021698:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 202169c:	e0bffe17 	ldw	r2,-8(fp)
 20216a0:	10000326 	beq	r2,zero,20216b0 <tcp_err+0x28>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
    pcb->errf = err;
 20216a4:	e0bffe17 	ldw	r2,-8(fp)
 20216a8:	e0ffff17 	ldw	r3,-4(fp)
 20216ac:	10c02615 	stw	r3,152(r2)
  }
}
 20216b0:	0001883a 	nop
 20216b4:	e037883a 	mov	sp,fp
 20216b8:	df000017 	ldw	fp,0(sp)
 20216bc:	dec00104 	addi	sp,sp,4
 20216c0:	f800283a 	ret

020216c4 <tcp_accept>:
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
 20216c4:	defffc04 	addi	sp,sp,-16
 20216c8:	df000315 	stw	fp,12(sp)
 20216cc:	df000304 	addi	fp,sp,12
 20216d0:	e13ffe15 	stw	r4,-8(fp)
 20216d4:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();
  if ((pcb != NULL) && (pcb->state == LISTEN)) {
 20216d8:	e0bffe17 	ldw	r2,-8(fp)
 20216dc:	10000926 	beq	r2,zero,2021704 <tcp_accept+0x40>
 20216e0:	e0bffe17 	ldw	r2,-8(fp)
 20216e4:	10800617 	ldw	r2,24(r2)
 20216e8:	10800058 	cmpnei	r2,r2,1
 20216ec:	1000051e 	bne	r2,zero,2021704 <tcp_accept+0x40>
    struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen *)pcb;
 20216f0:	e0bffe17 	ldw	r2,-8(fp)
 20216f4:	e0bffd15 	stw	r2,-12(fp)
    lpcb->accept = accept;
 20216f8:	e0bffd17 	ldw	r2,-12(fp)
 20216fc:	e0ffff17 	ldw	r3,-4(fp)
 2021700:	10c00815 	stw	r3,32(r2)
  }
}
 2021704:	0001883a 	nop
 2021708:	e037883a 	mov	sp,fp
 202170c:	df000017 	ldw	fp,0(sp)
 2021710:	dec00104 	addi	sp,sp,4
 2021714:	f800283a 	ret

02021718 <tcp_poll>:
 * the application may use the polling functionality to call tcp_write()
 * again when the connection has been idle for a while.
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 2021718:	defffc04 	addi	sp,sp,-16
 202171c:	df000315 	stw	fp,12(sp)
 2021720:	df000304 	addi	fp,sp,12
 2021724:	e13ffd15 	stw	r4,-12(fp)
 2021728:	e17ffe15 	stw	r5,-8(fp)
 202172c:	3005883a 	mov	r2,r6
 2021730:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
 2021734:	e0bffd17 	ldw	r2,-12(fp)
 2021738:	10000726 	beq	r2,zero,2021758 <tcp_poll+0x40>
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);

#if LWIP_CALLBACK_API
  pcb->poll = poll;
 202173c:	e0bffd17 	ldw	r2,-12(fp)
 2021740:	e0fffe17 	ldw	r3,-8(fp)
 2021744:	10c02515 	stw	r3,148(r2)
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 2021748:	e0bffd17 	ldw	r2,-12(fp)
 202174c:	e0ffff03 	ldbu	r3,-4(fp)
 2021750:	10c00945 	stb	r3,37(r2)
 2021754:	00000106 	br	202175c <tcp_poll+0x44>
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
 2021758:	0001883a 	nop
  pcb->poll = poll;
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
}
 202175c:	e037883a 	mov	sp,fp
 2021760:	df000017 	ldw	fp,0(sp)
 2021764:	dec00104 	addi	sp,sp,4
 2021768:	f800283a 	ret

0202176c <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 202176c:	defffd04 	addi	sp,sp,-12
 2021770:	dfc00215 	stw	ra,8(sp)
 2021774:	df000115 	stw	fp,4(sp)
 2021778:	df000104 	addi	fp,sp,4
 202177c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 2021780:	e0bfff17 	ldw	r2,-4(fp)
 2021784:	10002f26 	beq	r2,zero,2021844 <tcp_pcb_purge+0xd8>

  if (pcb->state != CLOSED &&
 2021788:	e0bfff17 	ldw	r2,-4(fp)
 202178c:	10800617 	ldw	r2,24(r2)
 2021790:	10002d26 	beq	r2,zero,2021848 <tcp_pcb_purge+0xdc>
      pcb->state != TIME_WAIT &&
 2021794:	e0bfff17 	ldw	r2,-4(fp)
 2021798:	10800617 	ldw	r2,24(r2)
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);

  if (pcb->state != CLOSED &&
 202179c:	108002a0 	cmpeqi	r2,r2,10
 20217a0:	1000291e 	bne	r2,zero,2021848 <tcp_pcb_purge+0xdc>
      pcb->state != TIME_WAIT &&
      pcb->state != LISTEN) {
 20217a4:	e0bfff17 	ldw	r2,-4(fp)
 20217a8:	10800617 	ldw	r2,24(r2)
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);

  if (pcb->state != CLOSED &&
      pcb->state != TIME_WAIT &&
 20217ac:	10800060 	cmpeqi	r2,r2,1
 20217b0:	1000251e 	bne	r2,zero,2021848 <tcp_pcb_purge+0xdc>
      pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);
 20217b4:	e13fff17 	ldw	r4,-4(fp)
 20217b8:	201efa80 	call	201efa8 <tcp_backlog_accepted>

    if (pcb->refused_data != NULL) {
 20217bc:	e0bfff17 	ldw	r2,-4(fp)
 20217c0:	10802017 	ldw	r2,128(r2)
 20217c4:	10000626 	beq	r2,zero,20217e0 <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 20217c8:	e0bfff17 	ldw	r2,-4(fp)
 20217cc:	10802017 	ldw	r2,128(r2)
 20217d0:	1009883a 	mov	r4,r2
 20217d4:	201d2f40 	call	201d2f4 <pbuf_free>
      pcb->refused_data = NULL;
 20217d8:	e0bfff17 	ldw	r2,-4(fp)
 20217dc:	10002015 	stw	zero,128(r2)
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 20217e0:	e0bfff17 	ldw	r2,-4(fp)
 20217e4:	10801f17 	ldw	r2,124(r2)
 20217e8:	10000226 	beq	r2,zero,20217f4 <tcp_pcb_purge+0x88>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
      tcp_free_ooseq(pcb);
 20217ec:	e13fff17 	ldw	r4,-4(fp)
 20217f0:	2021c680 	call	2021c68 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 20217f4:	e0bfff17 	ldw	r2,-4(fp)
 20217f8:	00ffffc4 	movi	r3,-1
 20217fc:	10c00e0d 	sth	r3,56(r2)

    tcp_segs_free(pcb->unsent);
 2021800:	e0bfff17 	ldw	r2,-4(fp)
 2021804:	10801d17 	ldw	r2,116(r2)
 2021808:	1009883a 	mov	r4,r2
 202180c:	2020e8c0 	call	2020e8c <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 2021810:	e0bfff17 	ldw	r2,-4(fp)
 2021814:	10801e17 	ldw	r2,120(r2)
 2021818:	1009883a 	mov	r4,r2
 202181c:	2020e8c0 	call	2020e8c <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 2021820:	e0bfff17 	ldw	r2,-4(fp)
 2021824:	10001d15 	stw	zero,116(r2)
 2021828:	e0bfff17 	ldw	r2,-4(fp)
 202182c:	10c01d17 	ldw	r3,116(r2)
 2021830:	e0bfff17 	ldw	r2,-4(fp)
 2021834:	10c01e15 	stw	r3,120(r2)
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 2021838:	e0bfff17 	ldw	r2,-4(fp)
 202183c:	10001c0d 	sth	zero,112(r2)
 2021840:	00000106 	br	2021848 <tcp_pcb_purge+0xdc>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 2021844:	0001883a 	nop
    pcb->unacked = pcb->unsent = NULL;
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */
  }
}
 2021848:	e037883a 	mov	sp,fp
 202184c:	dfc00117 	ldw	ra,4(sp)
 2021850:	df000017 	ldw	fp,0(sp)
 2021854:	dec00204 	addi	sp,sp,8
 2021858:	f800283a 	ret

0202185c <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 202185c:	defffb04 	addi	sp,sp,-20
 2021860:	dfc00415 	stw	ra,16(sp)
 2021864:	df000315 	stw	fp,12(sp)
 2021868:	df000304 	addi	fp,sp,12
 202186c:	e13ffe15 	stw	r4,-8(fp)
 2021870:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);

  TCP_RMV(pcblist, pcb);
 2021874:	e0bffe17 	ldw	r2,-8(fp)
 2021878:	10c00017 	ldw	r3,0(r2)
 202187c:	e0bfff17 	ldw	r2,-4(fp)
 2021880:	1880061e 	bne	r3,r2,202189c <tcp_pcb_remove+0x40>
 2021884:	e0bffe17 	ldw	r2,-8(fp)
 2021888:	10800017 	ldw	r2,0(r2)
 202188c:	10c00417 	ldw	r3,16(r2)
 2021890:	e0bffe17 	ldw	r2,-8(fp)
 2021894:	10c00015 	stw	r3,0(r2)
 2021898:	00001206 	br	20218e4 <tcp_pcb_remove+0x88>
 202189c:	e0bffe17 	ldw	r2,-8(fp)
 20218a0:	10800017 	ldw	r2,0(r2)
 20218a4:	e0bffd15 	stw	r2,-12(fp)
 20218a8:	00000c06 	br	20218dc <tcp_pcb_remove+0x80>
 20218ac:	e0bffd17 	ldw	r2,-12(fp)
 20218b0:	10c00417 	ldw	r3,16(r2)
 20218b4:	e0bfff17 	ldw	r2,-4(fp)
 20218b8:	1880051e 	bne	r3,r2,20218d0 <tcp_pcb_remove+0x74>
 20218bc:	e0bfff17 	ldw	r2,-4(fp)
 20218c0:	10c00417 	ldw	r3,16(r2)
 20218c4:	e0bffd17 	ldw	r2,-12(fp)
 20218c8:	10c00415 	stw	r3,16(r2)
 20218cc:	00000506 	br	20218e4 <tcp_pcb_remove+0x88>
 20218d0:	e0bffd17 	ldw	r2,-12(fp)
 20218d4:	10800417 	ldw	r2,16(r2)
 20218d8:	e0bffd15 	stw	r2,-12(fp)
 20218dc:	e0bffd17 	ldw	r2,-12(fp)
 20218e0:	103ff21e 	bne	r2,zero,20218ac <__alt_mem_mem_0+0xfd0018ac>
 20218e4:	e0bfff17 	ldw	r2,-4(fp)
 20218e8:	10000415 	stw	zero,16(r2)

  tcp_pcb_purge(pcb);
 20218ec:	e13fff17 	ldw	r4,-4(fp)
 20218f0:	202176c0 	call	202176c <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
 20218f4:	e0bfff17 	ldw	r2,-4(fp)
 20218f8:	10800617 	ldw	r2,24(r2)
 20218fc:	108002a0 	cmpeqi	r2,r2,10
 2021900:	1000111e 	bne	r2,zero,2021948 <tcp_pcb_remove+0xec>
      (pcb->state != LISTEN) &&
 2021904:	e0bfff17 	ldw	r2,-4(fp)
 2021908:	10800617 	ldw	r2,24(r2)
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
 202190c:	10800060 	cmpeqi	r2,r2,1
 2021910:	10000d1e 	bne	r2,zero,2021948 <tcp_pcb_remove+0xec>
      (pcb->state != LISTEN) &&
      (pcb->flags & TF_ACK_DELAY)) {
 2021914:	e0bfff17 	ldw	r2,-4(fp)
 2021918:	1080088b 	ldhu	r2,34(r2)
 202191c:	10bfffcc 	andi	r2,r2,65535
 2021920:	1080004c 	andi	r2,r2,1

  tcp_pcb_purge(pcb);

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
      (pcb->state != LISTEN) &&
 2021924:	10000826 	beq	r2,zero,2021948 <tcp_pcb_remove+0xec>
      (pcb->flags & TF_ACK_DELAY)) {
    tcp_ack_now(pcb);
 2021928:	e0bfff17 	ldw	r2,-4(fp)
 202192c:	1080088b 	ldhu	r2,34(r2)
 2021930:	10800094 	ori	r2,r2,2
 2021934:	1007883a 	mov	r3,r2
 2021938:	e0bfff17 	ldw	r2,-4(fp)
 202193c:	10c0088d 	sth	r3,34(r2)
    tcp_output(pcb);
 2021940:	e13fff17 	ldw	r4,-4(fp)
 2021944:	20275b40 	call	20275b4 <tcp_output>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 2021948:	e0bfff17 	ldw	r2,-4(fp)
 202194c:	10000615 	stw	zero,24(r2)
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 2021950:	e0bfff17 	ldw	r2,-4(fp)
 2021954:	1000078d 	sth	zero,30(r2)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 2021958:	0001883a 	nop
 202195c:	e037883a 	mov	sp,fp
 2021960:	dfc00117 	ldw	ra,4(sp)
 2021964:	df000017 	ldw	fp,0(sp)
 2021968:	dec00204 	addi	sp,sp,8
 202196c:	f800283a 	ret

02021970 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
 2021970:	defffe04 	addi	sp,sp,-8
 2021974:	df000115 	stw	fp,4(sp)
 2021978:	df000104 	addi	fp,sp,4
 202197c:	e13fff15 	stw	r4,-4(fp)
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
 2021980:	d0e01317 	ldw	r3,-32692(gp)
 2021984:	d0a7e217 	ldw	r2,-24696(gp)
 2021988:	1885883a 	add	r2,r3,r2
 202198c:	d0a01315 	stw	r2,-32692(gp)
  return iss;
 2021990:	d0a01317 	ldw	r2,-32692(gp)
#endif /* LWIP_HOOK_TCP_ISN */
}
 2021994:	e037883a 	mov	sp,fp
 2021998:	df000017 	ldw	fp,0(sp)
 202199c:	dec00104 	addi	sp,sp,4
 20219a0:	f800283a 	ret

020219a4 <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
 20219a4:	defffa04 	addi	sp,sp,-24
 20219a8:	df000515 	stw	fp,20(sp)
 20219ac:	df000504 	addi	fp,sp,20
 20219b0:	2005883a 	mov	r2,r4
 20219b4:	e17ffe15 	stw	r5,-8(fp)
 20219b8:	e1bfff15 	stw	r6,-4(fp)
 20219bc:	e0bffd0d 	sth	r2,-12(fp)
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
 20219c0:	e0bffe17 	ldw	r2,-8(fp)
 20219c4:	1000021e 	bne	r2,zero,20219d0 <tcp_eff_send_mss_netif+0x2c>
      return sendmss;
 20219c8:	e0bffd0b 	ldhu	r2,-12(fp)
 20219cc:	00001806 	br	2021a30 <tcp_eff_send_mss_netif+0x8c>
    }
    mtu = outif->mtu;
 20219d0:	e0bffe17 	ldw	r2,-8(fp)
 20219d4:	10800d0b 	ldhu	r2,52(r2)
 20219d8:	e0bffb0d 	sth	r2,-20(fp)
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
 20219dc:	e0bffb0b 	ldhu	r2,-20(fp)
 20219e0:	10001226 	beq	r2,zero,2021a2c <tcp_eff_send_mss_netif+0x88>
    else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
 20219e4:	00800a04 	movi	r2,40
 20219e8:	e0bffb8d 	sth	r2,-18(fp)
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
 20219ec:	e0bffb0b 	ldhu	r2,-20(fp)
 20219f0:	e0fffb8b 	ldhu	r3,-18(fp)
 20219f4:	1880042e 	bgeu	r3,r2,2021a08 <tcp_eff_send_mss_netif+0x64>
 20219f8:	e0fffb0b 	ldhu	r3,-20(fp)
 20219fc:	e0bffb8b 	ldhu	r2,-18(fp)
 2021a00:	1885c83a 	sub	r2,r3,r2
 2021a04:	00000106 	br	2021a0c <tcp_eff_send_mss_netif+0x68>
 2021a08:	0005883a 	mov	r2,zero
 2021a0c:	e0bffc0d 	sth	r2,-16(fp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 2021a10:	e17ffd0b 	ldhu	r5,-12(fp)
 2021a14:	e0bffc0b 	ldhu	r2,-16(fp)
 2021a18:	10ffffcc 	andi	r3,r2,65535
 2021a1c:	293fffcc 	andi	r4,r5,65535
 2021a20:	20c0012e 	bgeu	r4,r3,2021a28 <tcp_eff_send_mss_netif+0x84>
 2021a24:	2805883a 	mov	r2,r5
 2021a28:	e0bffd0d 	sth	r2,-12(fp)
  }
  return sendmss;
 2021a2c:	e0bffd0b 	ldhu	r2,-12(fp)
}
 2021a30:	e037883a 	mov	sp,fp
 2021a34:	df000017 	ldw	fp,0(sp)
 2021a38:	dec00104 	addi	sp,sp,4
 2021a3c:	f800283a 	ret

02021a40 <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb_list)
{
 2021a40:	defffa04 	addi	sp,sp,-24
 2021a44:	dfc00515 	stw	ra,20(sp)
 2021a48:	df000415 	stw	fp,16(sp)
 2021a4c:	df000404 	addi	fp,sp,16
 2021a50:	e13ffe15 	stw	r4,-8(fp)
 2021a54:	e17fff15 	stw	r5,-4(fp)
  struct tcp_pcb *pcb;
  pcb = pcb_list;
 2021a58:	e0bfff17 	ldw	r2,-4(fp)
 2021a5c:	e0bffc15 	stw	r2,-16(fp)

  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);

  while (pcb != NULL) {
 2021a60:	00001006 	br	2021aa4 <tcp_netif_ip_addr_changed_pcblist+0x64>
    /* PCB bound to current local interface address? */
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 2021a64:	e0bffc17 	ldw	r2,-16(fp)
 2021a68:	10c00017 	ldw	r3,0(r2)
 2021a6c:	e0bffe17 	ldw	r2,-8(fp)
 2021a70:	10800017 	ldw	r2,0(r2)
 2021a74:	1880081e 	bne	r3,r2,2021a98 <tcp_netif_ip_addr_changed_pcblist+0x58>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
       ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
 2021a78:	e0bffc17 	ldw	r2,-16(fp)
 2021a7c:	10800417 	ldw	r2,16(r2)
 2021a80:	e0bffd15 	stw	r2,-12(fp)
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
 2021a84:	e13ffc17 	ldw	r4,-16(fp)
 2021a88:	201f70c0 	call	201f70c <tcp_abort>
      pcb = next;
 2021a8c:	e0bffd17 	ldw	r2,-12(fp)
 2021a90:	e0bffc15 	stw	r2,-16(fp)
 2021a94:	00000306 	br	2021aa4 <tcp_netif_ip_addr_changed_pcblist+0x64>
    } else {
      pcb = pcb->next;
 2021a98:	e0bffc17 	ldw	r2,-16(fp)
 2021a9c:	10800417 	ldw	r2,16(r2)
 2021aa0:	e0bffc15 	stw	r2,-16(fp)
  struct tcp_pcb *pcb;
  pcb = pcb_list;

  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);

  while (pcb != NULL) {
 2021aa4:	e0bffc17 	ldw	r2,-16(fp)
 2021aa8:	103fee1e 	bne	r2,zero,2021a64 <__alt_mem_mem_0+0xfd001a64>
      pcb = next;
    } else {
      pcb = pcb->next;
    }
  }
}
 2021aac:	0001883a 	nop
 2021ab0:	e037883a 	mov	sp,fp
 2021ab4:	dfc00117 	ldw	ra,4(sp)
 2021ab8:	df000017 	ldw	fp,0(sp)
 2021abc:	dec00204 	addi	sp,sp,8
 2021ac0:	f800283a 	ret

02021ac4 <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 2021ac4:	defffb04 	addi	sp,sp,-20
 2021ac8:	dfc00415 	stw	ra,16(sp)
 2021acc:	df000315 	stw	fp,12(sp)
 2021ad0:	df000304 	addi	fp,sp,12
 2021ad4:	e13ffe15 	stw	r4,-8(fp)
 2021ad8:	e17fff15 	stw	r5,-4(fp)
  struct tcp_pcb_listen *lpcb;

  if (!ip_addr_isany(old_addr)) {
 2021adc:	e0bffe17 	ldw	r2,-8(fp)
 2021ae0:	10002126 	beq	r2,zero,2021b68 <tcp_netif_ip_addr_changed+0xa4>
 2021ae4:	e0bffe17 	ldw	r2,-8(fp)
 2021ae8:	10800017 	ldw	r2,0(r2)
 2021aec:	10001e26 	beq	r2,zero,2021b68 <tcp_netif_ip_addr_changed+0xa4>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 2021af0:	d0a7e117 	ldw	r2,-24700(gp)
 2021af4:	100b883a 	mov	r5,r2
 2021af8:	e13ffe17 	ldw	r4,-8(fp)
 2021afc:	2021a400 	call	2021a40 <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 2021b00:	d0a7e417 	ldw	r2,-24688(gp)
 2021b04:	100b883a 	mov	r5,r2
 2021b08:	e13ffe17 	ldw	r4,-8(fp)
 2021b0c:	2021a400 	call	2021a40 <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
 2021b10:	e0bfff17 	ldw	r2,-4(fp)
 2021b14:	10001426 	beq	r2,zero,2021b68 <tcp_netif_ip_addr_changed+0xa4>
 2021b18:	e0bfff17 	ldw	r2,-4(fp)
 2021b1c:	10800017 	ldw	r2,0(r2)
 2021b20:	10001126 	beq	r2,zero,2021b68 <tcp_netif_ip_addr_changed+0xa4>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 2021b24:	d0a7e317 	ldw	r2,-24692(gp)
 2021b28:	e0bffd15 	stw	r2,-12(fp)
 2021b2c:	00000c06 	br	2021b60 <tcp_netif_ip_addr_changed+0x9c>
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 2021b30:	e0bffd17 	ldw	r2,-12(fp)
 2021b34:	10c00017 	ldw	r3,0(r2)
 2021b38:	e0bffe17 	ldw	r2,-8(fp)
 2021b3c:	10800017 	ldw	r2,0(r2)
 2021b40:	1880041e 	bne	r3,r2,2021b54 <tcp_netif_ip_addr_changed+0x90>
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
 2021b44:	e0bfff17 	ldw	r2,-4(fp)
 2021b48:	10c00017 	ldw	r3,0(r2)
 2021b4c:	e0bffd17 	ldw	r2,-12(fp)
 2021b50:	10c00015 	stw	r3,0(r2)
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);

    if (!ip_addr_isany(new_addr)) {
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 2021b54:	e0bffd17 	ldw	r2,-12(fp)
 2021b58:	10800417 	ldw	r2,16(r2)
 2021b5c:	e0bffd15 	stw	r2,-12(fp)
 2021b60:	e0bffd17 	ldw	r2,-12(fp)
 2021b64:	103ff21e 	bne	r2,zero,2021b30 <__alt_mem_mem_0+0xfd001b30>
          ip_addr_copy(lpcb->local_ip, *new_addr);
        }
      }
    }
  }
}
 2021b68:	0001883a 	nop
 2021b6c:	e037883a 	mov	sp,fp
 2021b70:	dfc00117 	ldw	ra,4(sp)
 2021b74:	df000017 	ldw	fp,0(sp)
 2021b78:	dec00204 	addi	sp,sp,8
 2021b7c:	f800283a 	ret

02021b80 <tcp_debug_state_str>:

const char *
tcp_debug_state_str(enum tcp_state s)
{
 2021b80:	defffe04 	addi	sp,sp,-8
 2021b84:	df000115 	stw	fp,4(sp)
 2021b88:	df000104 	addi	fp,sp,4
 2021b8c:	e13fff15 	stw	r4,-4(fp)
  return tcp_state_str[s];
 2021b90:	00808134 	movhi	r2,516
 2021b94:	109be404 	addi	r2,r2,28560
 2021b98:	e0ffff17 	ldw	r3,-4(fp)
 2021b9c:	18c7883a 	add	r3,r3,r3
 2021ba0:	18c7883a 	add	r3,r3,r3
 2021ba4:	10c5883a 	add	r2,r2,r3
 2021ba8:	10800017 	ldw	r2,0(r2)
}
 2021bac:	e037883a 	mov	sp,fp
 2021bb0:	df000017 	ldw	fp,0(sp)
 2021bb4:	dec00104 	addi	sp,sp,4
 2021bb8:	f800283a 	ret

02021bbc <tcp_tcp_get_tcp_addrinfo>:

err_t
tcp_tcp_get_tcp_addrinfo(struct tcp_pcb *pcb, int local, ip_addr_t *addr, u16_t *port)
{
 2021bbc:	defffb04 	addi	sp,sp,-20
 2021bc0:	df000415 	stw	fp,16(sp)
 2021bc4:	df000404 	addi	fp,sp,16
 2021bc8:	e13ffc15 	stw	r4,-16(fp)
 2021bcc:	e17ffd15 	stw	r5,-12(fp)
 2021bd0:	e1bffe15 	stw	r6,-8(fp)
 2021bd4:	e1ffff15 	stw	r7,-4(fp)
  if (pcb) {
 2021bd8:	e0bffc17 	ldw	r2,-16(fp)
 2021bdc:	10001d26 	beq	r2,zero,2021c54 <tcp_tcp_get_tcp_addrinfo+0x98>
    if (local) {
 2021be0:	e0bffd17 	ldw	r2,-12(fp)
 2021be4:	10000d26 	beq	r2,zero,2021c1c <tcp_tcp_get_tcp_addrinfo+0x60>
      if (addr) {
 2021be8:	e0bffe17 	ldw	r2,-8(fp)
 2021bec:	10000426 	beq	r2,zero,2021c00 <tcp_tcp_get_tcp_addrinfo+0x44>
        *addr = pcb->local_ip;
 2021bf0:	e0bffe17 	ldw	r2,-8(fp)
 2021bf4:	e0fffc17 	ldw	r3,-16(fp)
 2021bf8:	18c00017 	ldw	r3,0(r3)
 2021bfc:	10c00015 	stw	r3,0(r2)
      }
      if (port) {
 2021c00:	e0bfff17 	ldw	r2,-4(fp)
 2021c04:	10001126 	beq	r2,zero,2021c4c <tcp_tcp_get_tcp_addrinfo+0x90>
        *port = pcb->local_port;
 2021c08:	e0bffc17 	ldw	r2,-16(fp)
 2021c0c:	10c0078b 	ldhu	r3,30(r2)
 2021c10:	e0bfff17 	ldw	r2,-4(fp)
 2021c14:	10c0000d 	sth	r3,0(r2)
 2021c18:	00000c06 	br	2021c4c <tcp_tcp_get_tcp_addrinfo+0x90>
      }
    } else {
      if (addr) {
 2021c1c:	e0bffe17 	ldw	r2,-8(fp)
 2021c20:	10000426 	beq	r2,zero,2021c34 <tcp_tcp_get_tcp_addrinfo+0x78>
        *addr = pcb->remote_ip;
 2021c24:	e0bffe17 	ldw	r2,-8(fp)
 2021c28:	e0fffc17 	ldw	r3,-16(fp)
 2021c2c:	18c00117 	ldw	r3,4(r3)
 2021c30:	10c00015 	stw	r3,0(r2)
      }
      if (port) {
 2021c34:	e0bfff17 	ldw	r2,-4(fp)
 2021c38:	10000426 	beq	r2,zero,2021c4c <tcp_tcp_get_tcp_addrinfo+0x90>
        *port = pcb->remote_port;
 2021c3c:	e0bffc17 	ldw	r2,-16(fp)
 2021c40:	10c0080b 	ldhu	r3,32(r2)
 2021c44:	e0bfff17 	ldw	r2,-4(fp)
 2021c48:	10c0000d 	sth	r3,0(r2)
      }
    }
    return ERR_OK;
 2021c4c:	0005883a 	mov	r2,zero
 2021c50:	00000106 	br	2021c58 <tcp_tcp_get_tcp_addrinfo+0x9c>
  }
  return ERR_VAL;
 2021c54:	00bffe84 	movi	r2,-6
}
 2021c58:	e037883a 	mov	sp,fp
 2021c5c:	df000017 	ldw	fp,0(sp)
 2021c60:	dec00104 	addi	sp,sp,4
 2021c64:	f800283a 	ret

02021c68 <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
 2021c68:	defffd04 	addi	sp,sp,-12
 2021c6c:	dfc00215 	stw	ra,8(sp)
 2021c70:	df000115 	stw	fp,4(sp)
 2021c74:	df000104 	addi	fp,sp,4
 2021c78:	e13fff15 	stw	r4,-4(fp)
  if (pcb->ooseq) {
 2021c7c:	e0bfff17 	ldw	r2,-4(fp)
 2021c80:	10801f17 	ldw	r2,124(r2)
 2021c84:	10000626 	beq	r2,zero,2021ca0 <tcp_free_ooseq+0x38>
    tcp_segs_free(pcb->ooseq);
 2021c88:	e0bfff17 	ldw	r2,-4(fp)
 2021c8c:	10801f17 	ldw	r2,124(r2)
 2021c90:	1009883a 	mov	r4,r2
 2021c94:	2020e8c0 	call	2020e8c <tcp_segs_free>
    pcb->ooseq = NULL;
 2021c98:	e0bfff17 	ldw	r2,-4(fp)
 2021c9c:	10001f15 	stw	zero,124(r2)
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
 2021ca0:	0001883a 	nop
 2021ca4:	e037883a 	mov	sp,fp
 2021ca8:	dfc00117 	ldw	ra,4(sp)
 2021cac:	df000017 	ldw	fp,0(sp)
 2021cb0:	dec00204 	addi	sp,sp,8
 2021cb4:	f800283a 	ret

02021cb8 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 2021cb8:	defff004 	addi	sp,sp,-64
 2021cbc:	dfc00f15 	stw	ra,60(sp)
 2021cc0:	df000e15 	stw	fp,56(sp)
 2021cc4:	dc000d15 	stw	r16,52(sp)
 2021cc8:	df000e04 	addi	fp,sp,56
 2021ccc:	e13ffd15 	stw	r4,-12(fp)
 2021cd0:	e17ffe15 	stw	r5,-8(fp)
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
 2021cd4:	e03ff815 	stw	zero,-32(fp)
  struct tcp_pcb_listen *lpcb_any = NULL;
 2021cd8:	e03ff915 	stw	zero,-28(fp)
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);

  PERF_START;

  TCP_STATS_INC(tcp.recv);
 2021cdc:	008085f4 	movhi	r2,535
 2021ce0:	10bd8204 	addi	r2,r2,-2552
 2021ce4:	10804917 	ldw	r2,292(r2)
 2021ce8:	10c00044 	addi	r3,r2,1
 2021cec:	008085f4 	movhi	r2,535
 2021cf0:	10bd8204 	addi	r2,r2,-2552
 2021cf4:	10c04915 	stw	r3,292(r2)
  MIB2_STATS_INC(mib2.tcpinsegs);

  tcphdr = (struct tcp_hdr *)p->payload;
 2021cf8:	e0bffd17 	ldw	r2,-12(fp)
 2021cfc:	10800117 	ldw	r2,4(r2)
 2021d00:	d0a7e615 	stw	r2,-24680(gp)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* Check that TCP header fits in payload */
  if (p->len < TCP_HLEN) {
 2021d04:	e0bffd17 	ldw	r2,-12(fp)
 2021d08:	1080028b 	ldhu	r2,10(r2)
 2021d0c:	10bfffcc 	andi	r2,r2,65535
 2021d10:	10800528 	cmpgeui	r2,r2,20
 2021d14:	1000081e 	bne	r2,zero,2021d38 <tcp_input+0x80>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
 2021d18:	008085f4 	movhi	r2,535
 2021d1c:	10bd8204 	addi	r2,r2,-2552
 2021d20:	10804d17 	ldw	r2,308(r2)
 2021d24:	10c00044 	addi	r3,r2,1
 2021d28:	008085f4 	movhi	r2,535
 2021d2c:	10bd8204 	addi	r2,r2,-2552
 2021d30:	10c04d15 	stw	r3,308(r2)
    goto dropped;
 2021d34:	00037406 	br	2022b08 <tcp_input+0xe50>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 2021d38:	008085f4 	movhi	r2,535
 2021d3c:	10be4204 	addi	r2,r2,-1784
 2021d40:	10c00517 	ldw	r3,20(r2)
 2021d44:	008085f4 	movhi	r2,535
 2021d48:	10be4204 	addi	r2,r2,-1784
 2021d4c:	10800017 	ldw	r2,0(r2)
 2021d50:	100b883a 	mov	r5,r2
 2021d54:	1809883a 	mov	r4,r3
 2021d58:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
 2021d5c:	10803fcc 	andi	r2,r2,255
 2021d60:	1000061e 	bne	r2,zero,2021d7c <tcp_input+0xc4>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 2021d64:	008085f4 	movhi	r2,535
 2021d68:	10be4204 	addi	r2,r2,-1784
 2021d6c:	10800517 	ldw	r2,20(r2)
 2021d70:	10803c0c 	andi	r2,r2,240
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 2021d74:	10803818 	cmpnei	r2,r2,224
 2021d78:	1000081e 	bne	r2,zero,2021d9c <tcp_input+0xe4>
      ip_addr_ismulticast(ip_current_dest_addr())) {
    TCP_STATS_INC(tcp.proterr);
 2021d7c:	008085f4 	movhi	r2,535
 2021d80:	10bd8204 	addi	r2,r2,-2552
 2021d84:	10805017 	ldw	r2,320(r2)
 2021d88:	10c00044 	addi	r3,r2,1
 2021d8c:	008085f4 	movhi	r2,535
 2021d90:	10bd8204 	addi	r2,r2,-2552
 2021d94:	10c05015 	stw	r3,320(r2)
    goto dropped;
 2021d98:	00035b06 	br	2022b08 <tcp_input+0xe50>
  }

#if CHECKSUM_CHECK_TCP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
    /* Verify TCP checksum. */
    u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 2021d9c:	e0bffd17 	ldw	r2,-12(fp)
 2021da0:	1080020b 	ldhu	r2,8(r2)
 2021da4:	10ffffcc 	andi	r3,r2,65535
 2021da8:	008085f4 	movhi	r2,535
 2021dac:	10be4704 	addi	r2,r2,-1764
 2021db0:	d8800015 	stw	r2,0(sp)
 2021db4:	01c085f4 	movhi	r7,535
 2021db8:	39fe4604 	addi	r7,r7,-1768
 2021dbc:	180d883a 	mov	r6,r3
 2021dc0:	01400184 	movi	r5,6
 2021dc4:	e13ffd17 	ldw	r4,-12(fp)
 2021dc8:	2039e440 	call	2039e44 <ip_chksum_pseudo>
 2021dcc:	e0bffa8d 	sth	r2,-22(fp)
                                    ip_current_src_addr(), ip_current_dest_addr());
    if (chksum != 0) {
 2021dd0:	e0bffa8b 	ldhu	r2,-22(fp)
 2021dd4:	10000826 	beq	r2,zero,2021df8 <tcp_input+0x140>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
                                    chksum));
      tcp_debug_print(tcphdr);
      TCP_STATS_INC(tcp.chkerr);
 2021dd8:	008085f4 	movhi	r2,535
 2021ddc:	10bd8204 	addi	r2,r2,-2552
 2021de0:	10804c17 	ldw	r2,304(r2)
 2021de4:	10c00044 	addi	r3,r2,1
 2021de8:	008085f4 	movhi	r2,535
 2021dec:	10bd8204 	addi	r2,r2,-2552
 2021df0:	10c04c15 	stw	r3,304(r2)
      goto dropped;
 2021df4:	00034406 	br	2022b08 <tcp_input+0xe50>
    }
  }
#endif /* CHECKSUM_CHECK_TCP */

  /* sanity-check header length */
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
 2021df8:	d0a7e617 	ldw	r2,-24680(gp)
 2021dfc:	10c00303 	ldbu	r3,12(r2)
 2021e00:	10800343 	ldbu	r2,13(r2)
 2021e04:	1004923a 	slli	r2,r2,8
 2021e08:	10c4b03a 	or	r2,r2,r3
 2021e0c:	10bfffcc 	andi	r2,r2,65535
 2021e10:	1009883a 	mov	r4,r2
 2021e14:	20394740 	call	2039474 <lwip_htons>
 2021e18:	10bfffcc 	andi	r2,r2,65535
 2021e1c:	1004d33a 	srli	r2,r2,12
 2021e20:	1085883a 	add	r2,r2,r2
 2021e24:	1085883a 	add	r2,r2,r2
 2021e28:	e0bffb05 	stb	r2,-20(fp)
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 2021e2c:	e0bffb03 	ldbu	r2,-20(fp)
 2021e30:	10800530 	cmpltui	r2,r2,20
 2021e34:	1000061e 	bne	r2,zero,2021e50 <tcp_input+0x198>
 2021e38:	e13ffb03 	ldbu	r4,-20(fp)
 2021e3c:	e0bffd17 	ldw	r2,-12(fp)
 2021e40:	10c0020b 	ldhu	r3,8(r2)
 2021e44:	20bfffcc 	andi	r2,r4,65535
 2021e48:	18ffffcc 	andi	r3,r3,65535
 2021e4c:	1880082e 	bgeu	r3,r2,2021e70 <tcp_input+0x1b8>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_bytes));
    TCP_STATS_INC(tcp.lenerr);
 2021e50:	008085f4 	movhi	r2,535
 2021e54:	10bd8204 	addi	r2,r2,-2552
 2021e58:	10804d17 	ldw	r2,308(r2)
 2021e5c:	10c00044 	addi	r3,r2,1
 2021e60:	008085f4 	movhi	r2,535
 2021e64:	10bd8204 	addi	r2,r2,-2552
 2021e68:	10c04d15 	stw	r3,308(r2)
    goto dropped;
 2021e6c:	00032606 	br	2022b08 <tcp_input+0xe50>
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
 2021e70:	e0bffb03 	ldbu	r2,-20(fp)
 2021e74:	10bffb04 	addi	r2,r2,-20
 2021e78:	d0a7e70d 	sth	r2,-24676(gp)
  tcphdr_opt2 = NULL;
 2021e7c:	d027e815 	stw	zero,-24672(gp)
  if (p->len >= hdrlen_bytes) {
 2021e80:	e0bffd17 	ldw	r2,-12(fp)
 2021e84:	10c0028b 	ldhu	r3,10(r2)
 2021e88:	e0bffb03 	ldbu	r2,-20(fp)
 2021e8c:	18ffffcc 	andi	r3,r3,65535
 2021e90:	10bfffcc 	andi	r2,r2,65535
 2021e94:	18800736 	bltu	r3,r2,2021eb4 <tcp_input+0x1fc>
    /* all options are in the first pbuf */
    tcphdr_opt1len = tcphdr_optlen;
 2021e98:	d0a7e70b 	ldhu	r2,-24676(gp)
 2021e9c:	d0a7e78d 	sth	r2,-24674(gp)
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 2021ea0:	e0bffb03 	ldbu	r2,-20(fp)
 2021ea4:	100b883a 	mov	r5,r2
 2021ea8:	e13ffd17 	ldw	r4,-12(fp)
 2021eac:	201d06c0 	call	201d06c <pbuf_remove_header>
 2021eb0:	00002e06 	br	2021f6c <tcp_input+0x2b4>
    /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
    /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);

    /* advance over the TCP header (cannot fail) */
    pbuf_remove_header(p, TCP_HLEN);
 2021eb4:	01400504 	movi	r5,20
 2021eb8:	e13ffd17 	ldw	r4,-12(fp)
 2021ebc:	201d06c0 	call	201d06c <pbuf_remove_header>

    /* determine how long the first and second parts of the options are */
    tcphdr_opt1len = p->len;
 2021ec0:	e0bffd17 	ldw	r2,-12(fp)
 2021ec4:	1080028b 	ldhu	r2,10(r2)
 2021ec8:	d0a7e78d 	sth	r2,-24674(gp)
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 2021ecc:	d0e7e70b 	ldhu	r3,-24676(gp)
 2021ed0:	d0a7e78b 	ldhu	r2,-24674(gp)
 2021ed4:	1885c83a 	sub	r2,r3,r2
 2021ed8:	e0bffb8d 	sth	r2,-18(fp)

    /* options continue in the next pbuf: set p to zero length and hide the
        options in the next pbuf (adjusting p->tot_len) */
    pbuf_remove_header(p, tcphdr_opt1len);
 2021edc:	d0a7e78b 	ldhu	r2,-24674(gp)
 2021ee0:	10bfffcc 	andi	r2,r2,65535
 2021ee4:	100b883a 	mov	r5,r2
 2021ee8:	e13ffd17 	ldw	r4,-12(fp)
 2021eec:	201d06c0 	call	201d06c <pbuf_remove_header>

    /* check that the options fit in the second pbuf */
    if (opt2len > p->next->len) {
 2021ef0:	e0bffd17 	ldw	r2,-12(fp)
 2021ef4:	10800017 	ldw	r2,0(r2)
 2021ef8:	1080028b 	ldhu	r2,10(r2)
 2021efc:	10ffffcc 	andi	r3,r2,65535
 2021f00:	e0bffb8b 	ldhu	r2,-18(fp)
 2021f04:	1880082e 	bgeu	r3,r2,2021f28 <tcp_input+0x270>
      /* drop short packets */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: options overflow second pbuf (%"U16_F" bytes)\n", p->next->len));
      TCP_STATS_INC(tcp.lenerr);
 2021f08:	008085f4 	movhi	r2,535
 2021f0c:	10bd8204 	addi	r2,r2,-2552
 2021f10:	10804d17 	ldw	r2,308(r2)
 2021f14:	10c00044 	addi	r3,r2,1
 2021f18:	008085f4 	movhi	r2,535
 2021f1c:	10bd8204 	addi	r2,r2,-2552
 2021f20:	10c04d15 	stw	r3,308(r2)
      goto dropped;
 2021f24:	0002f806 	br	2022b08 <tcp_input+0xe50>
    }

    /* remember the pointer to the second part of the options */
    tcphdr_opt2 = (u8_t *)p->next->payload;
 2021f28:	e0bffd17 	ldw	r2,-12(fp)
 2021f2c:	10800017 	ldw	r2,0(r2)
 2021f30:	10800117 	ldw	r2,4(r2)
 2021f34:	d0a7e815 	stw	r2,-24672(gp)

    /* advance p->next to point after the options, and manually
        adjust p->tot_len to keep it consistent with the changed p->next */
    pbuf_remove_header(p->next, opt2len);
 2021f38:	e0bffd17 	ldw	r2,-12(fp)
 2021f3c:	10800017 	ldw	r2,0(r2)
 2021f40:	e0fffb8b 	ldhu	r3,-18(fp)
 2021f44:	180b883a 	mov	r5,r3
 2021f48:	1009883a 	mov	r4,r2
 2021f4c:	201d06c0 	call	201d06c <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
 2021f50:	e0bffd17 	ldw	r2,-12(fp)
 2021f54:	10c0020b 	ldhu	r3,8(r2)
 2021f58:	e0bffb8b 	ldhu	r2,-18(fp)
 2021f5c:	1885c83a 	sub	r2,r3,r2
 2021f60:	1007883a 	mov	r3,r2
 2021f64:	e0bffd17 	ldw	r2,-12(fp)
 2021f68:	10c0020d 	sth	r3,8(r2)
    LWIP_ASSERT("p->len == 0", p->len == 0);
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = lwip_ntohs(tcphdr->src);
 2021f6c:	d427e617 	ldw	r16,-24680(gp)
 2021f70:	d0a7e617 	ldw	r2,-24680(gp)
 2021f74:	10c00003 	ldbu	r3,0(r2)
 2021f78:	10800043 	ldbu	r2,1(r2)
 2021f7c:	1004923a 	slli	r2,r2,8
 2021f80:	10c4b03a 	or	r2,r2,r3
 2021f84:	10bfffcc 	andi	r2,r2,65535
 2021f88:	1009883a 	mov	r4,r2
 2021f8c:	20394740 	call	2039474 <lwip_htons>
 2021f90:	100b883a 	mov	r5,r2
 2021f94:	28bfffcc 	andi	r2,r5,65535
 2021f98:	11003fcc 	andi	r4,r2,255
 2021f9c:	80800003 	ldbu	r2,0(r16)
 2021fa0:	1004703a 	and	r2,r2,zero
 2021fa4:	1007883a 	mov	r3,r2
 2021fa8:	2005883a 	mov	r2,r4
 2021fac:	1884b03a 	or	r2,r3,r2
 2021fb0:	80800005 	stb	r2,0(r16)
 2021fb4:	28bfffcc 	andi	r2,r5,65535
 2021fb8:	1004d23a 	srli	r2,r2,8
 2021fbc:	113fffcc 	andi	r4,r2,65535
 2021fc0:	80800043 	ldbu	r2,1(r16)
 2021fc4:	1004703a 	and	r2,r2,zero
 2021fc8:	1007883a 	mov	r3,r2
 2021fcc:	2005883a 	mov	r2,r4
 2021fd0:	1884b03a 	or	r2,r3,r2
 2021fd4:	80800045 	stb	r2,1(r16)
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 2021fd8:	d427e617 	ldw	r16,-24680(gp)
 2021fdc:	d0a7e617 	ldw	r2,-24680(gp)
 2021fe0:	10c00083 	ldbu	r3,2(r2)
 2021fe4:	108000c3 	ldbu	r2,3(r2)
 2021fe8:	1004923a 	slli	r2,r2,8
 2021fec:	10c4b03a 	or	r2,r2,r3
 2021ff0:	10bfffcc 	andi	r2,r2,65535
 2021ff4:	1009883a 	mov	r4,r2
 2021ff8:	20394740 	call	2039474 <lwip_htons>
 2021ffc:	100b883a 	mov	r5,r2
 2022000:	28bfffcc 	andi	r2,r5,65535
 2022004:	11003fcc 	andi	r4,r2,255
 2022008:	80800083 	ldbu	r2,2(r16)
 202200c:	1004703a 	and	r2,r2,zero
 2022010:	1007883a 	mov	r3,r2
 2022014:	2005883a 	mov	r2,r4
 2022018:	1884b03a 	or	r2,r3,r2
 202201c:	80800085 	stb	r2,2(r16)
 2022020:	28bfffcc 	andi	r2,r5,65535
 2022024:	1004d23a 	srli	r2,r2,8
 2022028:	113fffcc 	andi	r4,r2,65535
 202202c:	808000c3 	ldbu	r2,3(r16)
 2022030:	1004703a 	and	r2,r2,zero
 2022034:	1007883a 	mov	r3,r2
 2022038:	2005883a 	mov	r2,r4
 202203c:	1884b03a 	or	r2,r3,r2
 2022040:	808000c5 	stb	r2,3(r16)
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 2022044:	d427e617 	ldw	r16,-24680(gp)
 2022048:	d0a7e617 	ldw	r2,-24680(gp)
 202204c:	10c00103 	ldbu	r3,4(r2)
 2022050:	11000143 	ldbu	r4,5(r2)
 2022054:	2008923a 	slli	r4,r4,8
 2022058:	20c6b03a 	or	r3,r4,r3
 202205c:	11000183 	ldbu	r4,6(r2)
 2022060:	2008943a 	slli	r4,r4,16
 2022064:	20c6b03a 	or	r3,r4,r3
 2022068:	108001c3 	ldbu	r2,7(r2)
 202206c:	1004963a 	slli	r2,r2,24
 2022070:	10c4b03a 	or	r2,r2,r3
 2022074:	1009883a 	mov	r4,r2
 2022078:	20394b00 	call	20394b0 <lwip_htonl>
 202207c:	11403fcc 	andi	r5,r2,255
 2022080:	80c00103 	ldbu	r3,4(r16)
 2022084:	1806703a 	and	r3,r3,zero
 2022088:	1809883a 	mov	r4,r3
 202208c:	2807883a 	mov	r3,r5
 2022090:	20c6b03a 	or	r3,r4,r3
 2022094:	80c00105 	stb	r3,4(r16)
 2022098:	1006d23a 	srli	r3,r2,8
 202209c:	19403fcc 	andi	r5,r3,255
 20220a0:	80c00143 	ldbu	r3,5(r16)
 20220a4:	1806703a 	and	r3,r3,zero
 20220a8:	1809883a 	mov	r4,r3
 20220ac:	2807883a 	mov	r3,r5
 20220b0:	20c6b03a 	or	r3,r4,r3
 20220b4:	80c00145 	stb	r3,5(r16)
 20220b8:	1006d43a 	srli	r3,r2,16
 20220bc:	19403fcc 	andi	r5,r3,255
 20220c0:	80c00183 	ldbu	r3,6(r16)
 20220c4:	1806703a 	and	r3,r3,zero
 20220c8:	1809883a 	mov	r4,r3
 20220cc:	2807883a 	mov	r3,r5
 20220d0:	20c6b03a 	or	r3,r4,r3
 20220d4:	80c00185 	stb	r3,6(r16)
 20220d8:	1008d63a 	srli	r4,r2,24
 20220dc:	808001c3 	ldbu	r2,7(r16)
 20220e0:	1004703a 	and	r2,r2,zero
 20220e4:	1007883a 	mov	r3,r2
 20220e8:	2005883a 	mov	r2,r4
 20220ec:	1884b03a 	or	r2,r3,r2
 20220f0:	808001c5 	stb	r2,7(r16)
 20220f4:	80800103 	ldbu	r2,4(r16)
 20220f8:	80c00143 	ldbu	r3,5(r16)
 20220fc:	1806923a 	slli	r3,r3,8
 2022100:	1884b03a 	or	r2,r3,r2
 2022104:	80c00183 	ldbu	r3,6(r16)
 2022108:	1806943a 	slli	r3,r3,16
 202210c:	1884b03a 	or	r2,r3,r2
 2022110:	80c001c3 	ldbu	r3,7(r16)
 2022114:	1806963a 	slli	r3,r3,24
 2022118:	1884b03a 	or	r2,r3,r2
 202211c:	d0a7ea15 	stw	r2,-24664(gp)
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 2022120:	d427e617 	ldw	r16,-24680(gp)
 2022124:	d0a7e617 	ldw	r2,-24680(gp)
 2022128:	10c00203 	ldbu	r3,8(r2)
 202212c:	11000243 	ldbu	r4,9(r2)
 2022130:	2008923a 	slli	r4,r4,8
 2022134:	20c6b03a 	or	r3,r4,r3
 2022138:	11000283 	ldbu	r4,10(r2)
 202213c:	2008943a 	slli	r4,r4,16
 2022140:	20c6b03a 	or	r3,r4,r3
 2022144:	108002c3 	ldbu	r2,11(r2)
 2022148:	1004963a 	slli	r2,r2,24
 202214c:	10c4b03a 	or	r2,r2,r3
 2022150:	1009883a 	mov	r4,r2
 2022154:	20394b00 	call	20394b0 <lwip_htonl>
 2022158:	11403fcc 	andi	r5,r2,255
 202215c:	80c00203 	ldbu	r3,8(r16)
 2022160:	1806703a 	and	r3,r3,zero
 2022164:	1809883a 	mov	r4,r3
 2022168:	2807883a 	mov	r3,r5
 202216c:	20c6b03a 	or	r3,r4,r3
 2022170:	80c00205 	stb	r3,8(r16)
 2022174:	1006d23a 	srli	r3,r2,8
 2022178:	19403fcc 	andi	r5,r3,255
 202217c:	80c00243 	ldbu	r3,9(r16)
 2022180:	1806703a 	and	r3,r3,zero
 2022184:	1809883a 	mov	r4,r3
 2022188:	2807883a 	mov	r3,r5
 202218c:	20c6b03a 	or	r3,r4,r3
 2022190:	80c00245 	stb	r3,9(r16)
 2022194:	1006d43a 	srli	r3,r2,16
 2022198:	19403fcc 	andi	r5,r3,255
 202219c:	80c00283 	ldbu	r3,10(r16)
 20221a0:	1806703a 	and	r3,r3,zero
 20221a4:	1809883a 	mov	r4,r3
 20221a8:	2807883a 	mov	r3,r5
 20221ac:	20c6b03a 	or	r3,r4,r3
 20221b0:	80c00285 	stb	r3,10(r16)
 20221b4:	1008d63a 	srli	r4,r2,24
 20221b8:	808002c3 	ldbu	r2,11(r16)
 20221bc:	1004703a 	and	r2,r2,zero
 20221c0:	1007883a 	mov	r3,r2
 20221c4:	2005883a 	mov	r2,r4
 20221c8:	1884b03a 	or	r2,r3,r2
 20221cc:	808002c5 	stb	r2,11(r16)
 20221d0:	80800203 	ldbu	r2,8(r16)
 20221d4:	80c00243 	ldbu	r3,9(r16)
 20221d8:	1806923a 	slli	r3,r3,8
 20221dc:	1884b03a 	or	r2,r3,r2
 20221e0:	80c00283 	ldbu	r3,10(r16)
 20221e4:	1806943a 	slli	r3,r3,16
 20221e8:	1884b03a 	or	r2,r3,r2
 20221ec:	80c002c3 	ldbu	r3,11(r16)
 20221f0:	1806963a 	slli	r3,r3,24
 20221f4:	1884b03a 	or	r2,r3,r2
 20221f8:	d0a7eb15 	stw	r2,-24660(gp)
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 20221fc:	d427e617 	ldw	r16,-24680(gp)
 2022200:	d0a7e617 	ldw	r2,-24680(gp)
 2022204:	10c00383 	ldbu	r3,14(r2)
 2022208:	108003c3 	ldbu	r2,15(r2)
 202220c:	1004923a 	slli	r2,r2,8
 2022210:	10c4b03a 	or	r2,r2,r3
 2022214:	10bfffcc 	andi	r2,r2,65535
 2022218:	1009883a 	mov	r4,r2
 202221c:	20394740 	call	2039474 <lwip_htons>
 2022220:	100b883a 	mov	r5,r2
 2022224:	28bfffcc 	andi	r2,r5,65535
 2022228:	11003fcc 	andi	r4,r2,255
 202222c:	80800383 	ldbu	r2,14(r16)
 2022230:	1004703a 	and	r2,r2,zero
 2022234:	1007883a 	mov	r3,r2
 2022238:	2005883a 	mov	r2,r4
 202223c:	1884b03a 	or	r2,r3,r2
 2022240:	80800385 	stb	r2,14(r16)
 2022244:	28bfffcc 	andi	r2,r5,65535
 2022248:	1004d23a 	srli	r2,r2,8
 202224c:	113fffcc 	andi	r4,r2,65535
 2022250:	808003c3 	ldbu	r2,15(r16)
 2022254:	1004703a 	and	r2,r2,zero
 2022258:	1007883a 	mov	r3,r2
 202225c:	2005883a 	mov	r2,r4
 2022260:	1884b03a 	or	r2,r3,r2
 2022264:	808003c5 	stb	r2,15(r16)

  flags = TCPH_FLAGS(tcphdr);
 2022268:	d0a7e617 	ldw	r2,-24680(gp)
 202226c:	10c00303 	ldbu	r3,12(r2)
 2022270:	10800343 	ldbu	r2,13(r2)
 2022274:	1004923a 	slli	r2,r2,8
 2022278:	10c4b03a 	or	r2,r2,r3
 202227c:	10bfffcc 	andi	r2,r2,65535
 2022280:	1009883a 	mov	r4,r2
 2022284:	20394740 	call	2039474 <lwip_htons>
 2022288:	10800fcc 	andi	r2,r2,63
 202228c:	d0a7ed05 	stb	r2,-24652(gp)
  tcplen = p->tot_len;
 2022290:	e0bffd17 	ldw	r2,-12(fp)
 2022294:	1080020b 	ldhu	r2,8(r2)
 2022298:	d0a7ec8d 	sth	r2,-24654(gp)
  if (flags & (TCP_FIN | TCP_SYN)) {
 202229c:	d0a7ed03 	ldbu	r2,-24652(gp)
 20222a0:	10803fcc 	andi	r2,r2,255
 20222a4:	108000cc 	andi	r2,r2,3
 20222a8:	10001126 	beq	r2,zero,20222f0 <tcp_input+0x638>
    tcplen++;
 20222ac:	d0a7ec8b 	ldhu	r2,-24654(gp)
 20222b0:	10800044 	addi	r2,r2,1
 20222b4:	d0a7ec8d 	sth	r2,-24654(gp)
    if (tcplen < p->tot_len) {
 20222b8:	e0bffd17 	ldw	r2,-12(fp)
 20222bc:	1080020b 	ldhu	r2,8(r2)
 20222c0:	d0e7ec8b 	ldhu	r3,-24654(gp)
 20222c4:	10bfffcc 	andi	r2,r2,65535
 20222c8:	18ffffcc 	andi	r3,r3,65535
 20222cc:	1880082e 	bgeu	r3,r2,20222f0 <tcp_input+0x638>
      /* u16_t overflow, cannot handle this */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: length u16_t overflow, cannot handle this\n"));
      TCP_STATS_INC(tcp.lenerr);
 20222d0:	008085f4 	movhi	r2,535
 20222d4:	10bd8204 	addi	r2,r2,-2552
 20222d8:	10804d17 	ldw	r2,308(r2)
 20222dc:	10c00044 	addi	r3,r2,1
 20222e0:	008085f4 	movhi	r2,535
 20222e4:	10bd8204 	addi	r2,r2,-2552
 20222e8:	10c04d15 	stw	r3,308(r2)
      goto dropped;
 20222ec:	00020606 	br	2022b08 <tcp_input+0xe50>
    }
  }

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 20222f0:	e03ff615 	stw	zero,-40(fp)

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 20222f4:	d0a7e117 	ldw	r2,-24700(gp)
 20222f8:	e0bff515 	stw	r2,-44(fp)
 20222fc:	00004a06 	br	2022428 <tcp_input+0x770>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);

    /* check if PCB is bound to specific netif */
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 2022300:	e0bff517 	ldw	r2,-44(fp)
 2022304:	10800203 	ldbu	r2,8(r2)
 2022308:	10803fcc 	andi	r2,r2,255
 202230c:	10000d26 	beq	r2,zero,2022344 <tcp_input+0x68c>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 2022310:	e0bff517 	ldw	r2,-44(fp)
 2022314:	10c00203 	ldbu	r3,8(r2)
 2022318:	008085f4 	movhi	r2,535
 202231c:	10be4204 	addi	r2,r2,-1784
 2022320:	10800117 	ldw	r2,4(r2)
 2022324:	10801003 	ldbu	r2,64(r2)
 2022328:	10800044 	addi	r2,r2,1
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);

    /* check if PCB is bound to specific netif */
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 202232c:	18c03fcc 	andi	r3,r3,255
 2022330:	10803fcc 	andi	r2,r2,255
 2022334:	18800326 	beq	r3,r2,2022344 <tcp_input+0x68c>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
      prev = pcb;
 2022338:	e0bff517 	ldw	r2,-44(fp)
 202233c:	e0bff615 	stw	r2,-40(fp)
      continue;
 2022340:	00003606 	br	202241c <tcp_input+0x764>
    }

    if (pcb->remote_port == tcphdr->src &&
 2022344:	e0bff517 	ldw	r2,-44(fp)
 2022348:	1100080b 	ldhu	r4,32(r2)
 202234c:	d0a7e617 	ldw	r2,-24680(gp)
 2022350:	10c00003 	ldbu	r3,0(r2)
 2022354:	10800043 	ldbu	r2,1(r2)
 2022358:	1004923a 	slli	r2,r2,8
 202235c:	10c4b03a 	or	r2,r2,r3
 2022360:	20ffffcc 	andi	r3,r4,65535
 2022364:	10bfffcc 	andi	r2,r2,65535
 2022368:	18802a1e 	bne	r3,r2,2022414 <tcp_input+0x75c>
        pcb->local_port == tcphdr->dest &&
 202236c:	e0bff517 	ldw	r2,-44(fp)
 2022370:	1100078b 	ldhu	r4,30(r2)
 2022374:	d0a7e617 	ldw	r2,-24680(gp)
 2022378:	10c00083 	ldbu	r3,2(r2)
 202237c:	108000c3 	ldbu	r2,3(r2)
 2022380:	1004923a 	slli	r2,r2,8
 2022384:	10c4b03a 	or	r2,r2,r3
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
      prev = pcb;
      continue;
    }

    if (pcb->remote_port == tcphdr->src &&
 2022388:	20ffffcc 	andi	r3,r4,65535
 202238c:	10bfffcc 	andi	r2,r2,65535
 2022390:	1880201e 	bne	r3,r2,2022414 <tcp_input+0x75c>
        pcb->local_port == tcphdr->dest &&
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 2022394:	e0bff517 	ldw	r2,-44(fp)
 2022398:	10c00117 	ldw	r3,4(r2)
 202239c:	008085f4 	movhi	r2,535
 20223a0:	10be4204 	addi	r2,r2,-1784
 20223a4:	10800417 	ldw	r2,16(r2)
      prev = pcb;
      continue;
    }

    if (pcb->remote_port == tcphdr->src &&
        pcb->local_port == tcphdr->dest &&
 20223a8:	18801a1e 	bne	r3,r2,2022414 <tcp_input+0x75c>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 20223ac:	e0bff517 	ldw	r2,-44(fp)
 20223b0:	10c00017 	ldw	r3,0(r2)
 20223b4:	008085f4 	movhi	r2,535
 20223b8:	10be4204 	addi	r2,r2,-1784
 20223bc:	10800517 	ldw	r2,20(r2)
      continue;
    }

    if (pcb->remote_port == tcphdr->src &&
        pcb->local_port == tcphdr->dest &&
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 20223c0:	1880141e 	bne	r3,r2,2022414 <tcp_input+0x75c>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
 20223c4:	e0bff617 	ldw	r2,-40(fp)
 20223c8:	10000a26 	beq	r2,zero,20223f4 <tcp_input+0x73c>
        prev->next = pcb->next;
 20223cc:	e0bff517 	ldw	r2,-44(fp)
 20223d0:	10c00417 	ldw	r3,16(r2)
 20223d4:	e0bff617 	ldw	r2,-40(fp)
 20223d8:	10c00415 	stw	r3,16(r2)
        pcb->next = tcp_active_pcbs;
 20223dc:	d0e7e117 	ldw	r3,-24700(gp)
 20223e0:	e0bff517 	ldw	r2,-44(fp)
 20223e4:	10c00415 	stw	r3,16(r2)
        tcp_active_pcbs = pcb;
 20223e8:	e0bff517 	ldw	r2,-44(fp)
 20223ec:	d0a7e115 	stw	r2,-24700(gp)
      } else {
        TCP_STATS_INC(tcp.cachehit);
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 20223f0:	00000f06 	br	2022430 <tcp_input+0x778>
      if (prev != NULL) {
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      } else {
        TCP_STATS_INC(tcp.cachehit);
 20223f4:	008085f4 	movhi	r2,535
 20223f8:	10bd8204 	addi	r2,r2,-2552
 20223fc:	10805317 	ldw	r2,332(r2)
 2022400:	10c00044 	addi	r3,r2,1
 2022404:	008085f4 	movhi	r2,535
 2022408:	10bd8204 	addi	r2,r2,-2552
 202240c:	10c05315 	stw	r3,332(r2)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 2022410:	00000706 	br	2022430 <tcp_input+0x778>
    }
    prev = pcb;
 2022414:	e0bff517 	ldw	r2,-44(fp)
 2022418:	e0bff615 	stw	r2,-40(fp)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 202241c:	e0bff517 	ldw	r2,-44(fp)
 2022420:	10800417 	ldw	r2,16(r2)
 2022424:	e0bff515 	stw	r2,-44(fp)
 2022428:	e0bff517 	ldw	r2,-44(fp)
 202242c:	103fb41e 	bne	r2,zero,2022300 <__alt_mem_mem_0+0xfd002300>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
 2022430:	e0bff517 	ldw	r2,-44(fp)
 2022434:	1000931e 	bne	r2,zero,2022684 <tcp_input+0x9cc>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 2022438:	d0a7e517 	ldw	r2,-24684(gp)
 202243c:	e0bff515 	stw	r2,-44(fp)
 2022440:	00003706 	br	2022520 <tcp_input+0x868>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 2022444:	e0bff517 	ldw	r2,-44(fp)
 2022448:	10800203 	ldbu	r2,8(r2)
 202244c:	10803fcc 	andi	r2,r2,255
 2022450:	10000a26 	beq	r2,zero,202247c <tcp_input+0x7c4>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 2022454:	e0bff517 	ldw	r2,-44(fp)
 2022458:	10c00203 	ldbu	r3,8(r2)
 202245c:	008085f4 	movhi	r2,535
 2022460:	10be4204 	addi	r2,r2,-1784
 2022464:	10800117 	ldw	r2,4(r2)
 2022468:	10801003 	ldbu	r2,64(r2)
 202246c:	10800044 	addi	r2,r2,1
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 2022470:	18c03fcc 	andi	r3,r3,255
 2022474:	10803fcc 	andi	r2,r2,255
 2022478:	1880251e 	bne	r3,r2,2022510 <tcp_input+0x858>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
 202247c:	e0bff517 	ldw	r2,-44(fp)
 2022480:	1100080b 	ldhu	r4,32(r2)
 2022484:	d0a7e617 	ldw	r2,-24680(gp)
 2022488:	10c00003 	ldbu	r3,0(r2)
 202248c:	10800043 	ldbu	r2,1(r2)
 2022490:	1004923a 	slli	r2,r2,8
 2022494:	10c4b03a 	or	r2,r2,r3
 2022498:	20ffffcc 	andi	r3,r4,65535
 202249c:	10bfffcc 	andi	r2,r2,65535
 20224a0:	18801c1e 	bne	r3,r2,2022514 <tcp_input+0x85c>
          pcb->local_port == tcphdr->dest &&
 20224a4:	e0bff517 	ldw	r2,-44(fp)
 20224a8:	1100078b 	ldhu	r4,30(r2)
 20224ac:	d0a7e617 	ldw	r2,-24680(gp)
 20224b0:	10c00083 	ldbu	r3,2(r2)
 20224b4:	108000c3 	ldbu	r2,3(r2)
 20224b8:	1004923a 	slli	r2,r2,8
 20224bc:	10c4b03a 	or	r2,r2,r3
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
 20224c0:	20ffffcc 	andi	r3,r4,65535
 20224c4:	10bfffcc 	andi	r2,r2,65535
 20224c8:	1880121e 	bne	r3,r2,2022514 <tcp_input+0x85c>
          pcb->local_port == tcphdr->dest &&
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 20224cc:	e0bff517 	ldw	r2,-44(fp)
 20224d0:	10c00117 	ldw	r3,4(r2)
 20224d4:	008085f4 	movhi	r2,535
 20224d8:	10be4204 	addi	r2,r2,-1784
 20224dc:	10800417 	ldw	r2,16(r2)
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
          pcb->local_port == tcphdr->dest &&
 20224e0:	18800c1e 	bne	r3,r2,2022514 <tcp_input+0x85c>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 20224e4:	e0bff517 	ldw	r2,-44(fp)
 20224e8:	10c00017 	ldw	r3,0(r2)
 20224ec:	008085f4 	movhi	r2,535
 20224f0:	10be4204 	addi	r2,r2,-1784
 20224f4:	10800517 	ldw	r2,20(r2)
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
          pcb->local_port == tcphdr->dest &&
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 20224f8:	1880061e 	bne	r3,r2,2022514 <tcp_input+0x85c>
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
        if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
                                       tcphdr_opt2, p) == ERR_OK)
#endif
        {
          tcp_timewait_input(pcb);
 20224fc:	e13ff517 	ldw	r4,-44(fp)
 2022500:	2022f700 	call	2022f70 <tcp_timewait_input>
        }
        pbuf_free(p);
 2022504:	e13ffd17 	ldw	r4,-12(fp)
 2022508:	201d2f40 	call	201d2f4 <pbuf_free>
        return;
 202250c:	00018906 	br	2022b34 <tcp_input+0xe7c>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
        continue;
 2022510:	0001883a 	nop
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 2022514:	e0bff517 	ldw	r2,-44(fp)
 2022518:	10800417 	ldw	r2,16(r2)
 202251c:	e0bff515 	stw	r2,-44(fp)
 2022520:	e0bff517 	ldw	r2,-44(fp)
 2022524:	103fc71e 	bne	r2,zero,2022444 <__alt_mem_mem_0+0xfd002444>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
 2022528:	e03ff615 	stw	zero,-40(fp)
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 202252c:	d0a7e317 	ldw	r2,-24692(gp)
 2022530:	e0bff715 	stw	r2,-36(fp)
 2022534:	00002f06 	br	20225f4 <tcp_input+0x93c>
      /* check if PCB is bound to specific netif */
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 2022538:	e0bff717 	ldw	r2,-36(fp)
 202253c:	10800203 	ldbu	r2,8(r2)
 2022540:	10803fcc 	andi	r2,r2,255
 2022544:	10000d26 	beq	r2,zero,202257c <tcp_input+0x8c4>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 2022548:	e0bff717 	ldw	r2,-36(fp)
 202254c:	10c00203 	ldbu	r3,8(r2)
 2022550:	008085f4 	movhi	r2,535
 2022554:	10be4204 	addi	r2,r2,-1784
 2022558:	10800117 	ldw	r2,4(r2)
 202255c:	10801003 	ldbu	r2,64(r2)
 2022560:	10800044 	addi	r2,r2,1
    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* check if PCB is bound to specific netif */
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 2022564:	18c03fcc 	andi	r3,r3,255
 2022568:	10803fcc 	andi	r2,r2,255
 202256c:	18800326 	beq	r3,r2,202257c <tcp_input+0x8c4>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
        prev = (struct tcp_pcb *)lpcb;
 2022570:	e0bff717 	ldw	r2,-36(fp)
 2022574:	e0bff615 	stw	r2,-40(fp)
        continue;
 2022578:	00001b06 	br	20225e8 <tcp_input+0x930>
      }

      if (lpcb->local_port == tcphdr->dest) {
 202257c:	e0bff717 	ldw	r2,-36(fp)
 2022580:	1100078b 	ldhu	r4,30(r2)
 2022584:	d0a7e617 	ldw	r2,-24680(gp)
 2022588:	10c00083 	ldbu	r3,2(r2)
 202258c:	108000c3 	ldbu	r2,3(r2)
 2022590:	1004923a 	slli	r2,r2,8
 2022594:	10c4b03a 	or	r2,r2,r3
 2022598:	20ffffcc 	andi	r3,r4,65535
 202259c:	10bfffcc 	andi	r2,r2,65535
 20225a0:	18800f1e 	bne	r3,r2,20225e0 <tcp_input+0x928>
          lpcb_prev = prev;
#else /* SO_REUSE */
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 20225a4:	e0bff717 	ldw	r2,-36(fp)
 20225a8:	10c00017 	ldw	r3,0(r2)
 20225ac:	008085f4 	movhi	r2,535
 20225b0:	10be4204 	addi	r2,r2,-1784
 20225b4:	10800517 	ldw	r2,20(r2)
 20225b8:	18801126 	beq	r3,r2,2022600 <tcp_input+0x948>
            /* found an exact match */
            break;
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 20225bc:	e0bff717 	ldw	r2,-36(fp)
 20225c0:	10000326 	beq	r2,zero,20225d0 <tcp_input+0x918>
 20225c4:	e0bff717 	ldw	r2,-36(fp)
 20225c8:	10800017 	ldw	r2,0(r2)
 20225cc:	1000041e 	bne	r2,zero,20225e0 <tcp_input+0x928>
            /* found an ANY-match */
#if SO_REUSE
            lpcb_any = lpcb;
 20225d0:	e0bff717 	ldw	r2,-36(fp)
 20225d4:	e0bff915 	stw	r2,-28(fp)
            lpcb_prev = prev;
 20225d8:	e0bff617 	ldw	r2,-40(fp)
 20225dc:	e0bff815 	stw	r2,-32(fp)
            break;
#endif /* SO_REUSE */
          }
        }
      }
      prev = (struct tcp_pcb *)lpcb;
 20225e0:	e0bff717 	ldw	r2,-36(fp)
 20225e4:	e0bff615 	stw	r2,-40(fp)
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 20225e8:	e0bff717 	ldw	r2,-36(fp)
 20225ec:	10800417 	ldw	r2,16(r2)
 20225f0:	e0bff715 	stw	r2,-36(fp)
 20225f4:	e0bff717 	ldw	r2,-36(fp)
 20225f8:	103fcf1e 	bne	r2,zero,2022538 <__alt_mem_mem_0+0xfd002538>
 20225fc:	00000106 	br	2022604 <tcp_input+0x94c>
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
            /* found an exact match */
            break;
 2022600:	0001883a 	nop
      }
      prev = (struct tcp_pcb *)lpcb;
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
 2022604:	e0bff717 	ldw	r2,-36(fp)
 2022608:	1000041e 	bne	r2,zero,202261c <tcp_input+0x964>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
 202260c:	e0bff917 	ldw	r2,-28(fp)
 2022610:	e0bff715 	stw	r2,-36(fp)
      prev = lpcb_prev;
 2022614:	e0bff817 	ldw	r2,-32(fp)
 2022618:	e0bff615 	stw	r2,-40(fp)
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
 202261c:	e0bff717 	ldw	r2,-36(fp)
 2022620:	10001826 	beq	r2,zero,2022684 <tcp_input+0x9cc>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 2022624:	e0bff617 	ldw	r2,-40(fp)
 2022628:	10000a26 	beq	r2,zero,2022654 <tcp_input+0x99c>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 202262c:	e0bff717 	ldw	r2,-36(fp)
 2022630:	10c00417 	ldw	r3,16(r2)
 2022634:	e0bff617 	ldw	r2,-40(fp)
 2022638:	10c00415 	stw	r3,16(r2)
        /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 202263c:	d0e7e317 	ldw	r3,-24692(gp)
 2022640:	e0bff717 	ldw	r2,-36(fp)
 2022644:	10c00415 	stw	r3,16(r2)
        /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 2022648:	e0bff717 	ldw	r2,-36(fp)
 202264c:	d0a7e315 	stw	r2,-24692(gp)
 2022650:	00000706 	br	2022670 <tcp_input+0x9b8>
      } else {
        TCP_STATS_INC(tcp.cachehit);
 2022654:	008085f4 	movhi	r2,535
 2022658:	10bd8204 	addi	r2,r2,-2552
 202265c:	10805317 	ldw	r2,332(r2)
 2022660:	10c00044 	addi	r3,r2,1
 2022664:	008085f4 	movhi	r2,535
 2022668:	10bd8204 	addi	r2,r2,-2552
 202266c:	10c05315 	stw	r3,332(r2)
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
      if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
                                     tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
#endif
      {
        tcp_listen_input(lpcb);
 2022670:	e13ff717 	ldw	r4,-36(fp)
 2022674:	2022be00 	call	2022be0 <tcp_listen_input>
      }
      pbuf_free(p);
 2022678:	e13ffd17 	ldw	r4,-12(fp)
 202267c:	201d2f40 	call	201d2f4 <pbuf_free>
      return;
 2022680:	00012c06 	br	2022b34 <tcp_input+0xe7c>
      tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
    pbuf_free(p);
    return;
  }
#endif
  if (pcb != NULL) {
 2022684:	e0bff517 	ldw	r2,-44(fp)
 2022688:	1000e926 	beq	r2,zero,2022a30 <tcp_input+0xd78>
#if TCP_INPUT_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 202268c:	00808174 	movhi	r2,517
 2022690:	10b45f04 	addi	r2,r2,-11908
 2022694:	10000015 	stw	zero,0(r2)
    inseg.len = p->tot_len;
 2022698:	e0bffd17 	ldw	r2,-12(fp)
 202269c:	10c0020b 	ldhu	r3,8(r2)
 20226a0:	00808174 	movhi	r2,517
 20226a4:	10b45f04 	addi	r2,r2,-11908
 20226a8:	10c0020d 	sth	r3,8(r2)
    inseg.p = p;
 20226ac:	00808174 	movhi	r2,517
 20226b0:	10b45f04 	addi	r2,r2,-11908
 20226b4:	e0fffd17 	ldw	r3,-12(fp)
 20226b8:	10c00115 	stw	r3,4(r2)
    inseg.tcphdr = tcphdr;
 20226bc:	d0e7e617 	ldw	r3,-24680(gp)
 20226c0:	00808174 	movhi	r2,517
 20226c4:	10b45f04 	addi	r2,r2,-11908
 20226c8:	10c00415 	stw	r3,16(r2)

    recv_data = NULL;
 20226cc:	d027ee15 	stw	zero,-24648(gp)
    recv_flags = 0;
 20226d0:	d027ed45 	stb	zero,-24651(gp)
    recv_acked = 0;
 20226d4:	d027ec0d 	sth	zero,-24656(gp)

    if (flags & TCP_PSH) {
 20226d8:	d0a7ed03 	ldbu	r2,-24652(gp)
 20226dc:	10803fcc 	andi	r2,r2,255
 20226e0:	1080020c 	andi	r2,r2,8
 20226e4:	10000626 	beq	r2,zero,2022700 <tcp_input+0xa48>
      p->flags |= PBUF_FLAG_PUSH;
 20226e8:	e0bffd17 	ldw	r2,-12(fp)
 20226ec:	10800343 	ldbu	r2,13(r2)
 20226f0:	10800054 	ori	r2,r2,1
 20226f4:	1007883a 	mov	r3,r2
 20226f8:	e0bffd17 	ldw	r2,-12(fp)
 20226fc:	10c00345 	stb	r3,13(r2)
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 2022700:	e0bff517 	ldw	r2,-44(fp)
 2022704:	10802017 	ldw	r2,128(r2)
 2022708:	10001b26 	beq	r2,zero,2022778 <tcp_input+0xac0>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 202270c:	e13ff517 	ldw	r4,-44(fp)
 2022710:	2020d240 	call	2020d24 <tcp_process_refused_data>
 2022714:	10803fcc 	andi	r2,r2,255
 2022718:	1080201c 	xori	r2,r2,128
 202271c:	10bfe004 	addi	r2,r2,-128
 2022720:	10bffce0 	cmpeqi	r2,r2,-13
 2022724:	1000061e 	bne	r2,zero,2022740 <tcp_input+0xa88>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 2022728:	e0bff517 	ldw	r2,-44(fp)
 202272c:	10802017 	ldw	r2,128(r2)
      p->flags |= PBUF_FLAG_PUSH;
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 2022730:	10001126 	beq	r2,zero,2022778 <tcp_input+0xac0>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 2022734:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2022738:	10bfffcc 	andi	r2,r2,65535
 202273c:	10000e26 	beq	r2,zero,2022778 <tcp_input+0xac0>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        if (pcb->rcv_ann_wnd == 0) {
 2022740:	e0bff517 	ldw	r2,-44(fp)
 2022744:	10800c8b 	ldhu	r2,50(r2)
 2022748:	10bfffcc 	andi	r2,r2,65535
 202274c:	1000021e 	bne	r2,zero,2022758 <tcp_input+0xaa0>
          /* this is a zero-window probe, we respond to it with current RCV.NXT
          and drop the data segment */
          tcp_send_empty_ack(pcb);
 2022750:	e13ff517 	ldw	r4,-44(fp)
 2022754:	2028dd00 	call	2028dd0 <tcp_send_empty_ack>
        }
        TCP_STATS_INC(tcp.drop);
 2022758:	008085f4 	movhi	r2,535
 202275c:	10bd8204 	addi	r2,r2,-2552
 2022760:	10804b17 	ldw	r2,300(r2)
 2022764:	10c00044 	addi	r3,r2,1
 2022768:	008085f4 	movhi	r2,535
 202276c:	10bd8204 	addi	r2,r2,-2552
 2022770:	10c04b15 	stw	r3,300(r2)
        MIB2_STATS_INC(mib2.tcpinerrs);
        goto aborted;
 2022774:	00009f06 	br	20229f4 <tcp_input+0xd3c>
      }
    }
    tcp_input_pcb = pcb;
 2022778:	e0bff517 	ldw	r2,-44(fp)
 202277c:	d0a7ef15 	stw	r2,-24644(gp)
    err = tcp_process(pcb);
 2022780:	e13ff517 	ldw	r4,-44(fp)
 2022784:	20230b80 	call	20230b8 <tcp_process>
 2022788:	e0bffa05 	stb	r2,-24(fp)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 202278c:	e0bffa07 	ldb	r2,-24(fp)
 2022790:	10bffce0 	cmpeqi	r2,r2,-13
 2022794:	1000971e 	bne	r2,zero,20229f4 <tcp_input+0xd3c>
      if (recv_flags & TF_RESET) {
 2022798:	d0a7ed43 	ldbu	r2,-24651(gp)
 202279c:	10803fcc 	andi	r2,r2,255
 20227a0:	1080020c 	andi	r2,r2,8
 20227a4:	10001026 	beq	r2,zero,20227e8 <tcp_input+0xb30>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 20227a8:	e0bff517 	ldw	r2,-44(fp)
 20227ac:	10802617 	ldw	r2,152(r2)
 20227b0:	10000726 	beq	r2,zero,20227d0 <tcp_input+0xb18>
 20227b4:	e0bff517 	ldw	r2,-44(fp)
 20227b8:	10802617 	ldw	r2,152(r2)
 20227bc:	e0fff517 	ldw	r3,-44(fp)
 20227c0:	18c00517 	ldw	r3,20(r3)
 20227c4:	017ffc84 	movi	r5,-14
 20227c8:	1809883a 	mov	r4,r3
 20227cc:	103ee83a 	callr	r2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 20227d0:	e17ff517 	ldw	r5,-44(fp)
 20227d4:	d127e104 	addi	r4,gp,-24700
 20227d8:	202185c0 	call	202185c <tcp_pcb_remove>
        tcp_free(pcb);
 20227dc:	e13ff517 	ldw	r4,-44(fp)
 20227e0:	201eda00 	call	201eda0 <tcp_free>
 20227e4:	00008306 	br	20229f4 <tcp_input+0xd3c>
      } else {
        err = ERR_OK;
 20227e8:	e03ffa05 	stb	zero,-24(fp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (recv_acked > 0) {
 20227ec:	d0a7ec0b 	ldhu	r2,-24656(gp)
 20227f0:	10bfffcc 	andi	r2,r2,65535
 20227f4:	10001526 	beq	r2,zero,202284c <tcp_input+0xb94>
          while (acked > 0) {
            acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
            acked -= acked16;
#else
          {
            acked16 = recv_acked;
 20227f8:	d0a7ec0b 	ldhu	r2,-24656(gp)
 20227fc:	e0bffc0d 	sth	r2,-16(fp)
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 2022800:	e0bff517 	ldw	r2,-44(fp)
 2022804:	10802217 	ldw	r2,136(r2)
 2022808:	10000b26 	beq	r2,zero,2022838 <tcp_input+0xb80>
 202280c:	e0bff517 	ldw	r2,-44(fp)
 2022810:	10802217 	ldw	r2,136(r2)
 2022814:	e0fff517 	ldw	r3,-44(fp)
 2022818:	18c00517 	ldw	r3,20(r3)
 202281c:	e13ffc0b 	ldhu	r4,-16(fp)
 2022820:	200d883a 	mov	r6,r4
 2022824:	e17ff517 	ldw	r5,-44(fp)
 2022828:	1809883a 	mov	r4,r3
 202282c:	103ee83a 	callr	r2
 2022830:	e0bffa05 	stb	r2,-24(fp)
 2022834:	00000106 	br	202283c <tcp_input+0xb84>
 2022838:	e03ffa05 	stb	zero,-24(fp)
            if (err == ERR_ABRT) {
 202283c:	e0bffa07 	ldb	r2,-24(fp)
 2022840:	10bffcd8 	cmpnei	r2,r2,-13
 2022844:	10006226 	beq	r2,zero,20229d0 <tcp_input+0xd18>
              goto aborted;
            }
          }
          recv_acked = 0;
 2022848:	d027ec0d 	sth	zero,-24656(gp)
        }
        if (tcp_input_delayed_close(pcb)) {
 202284c:	e13ff517 	ldw	r4,-44(fp)
 2022850:	2022b4c0 	call	2022b4c <tcp_input_delayed_close>
 2022854:	1000601e 	bne	r2,zero,20229d8 <tcp_input+0xd20>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
        while (recv_data != NULL) {
          struct pbuf *rest = NULL;
          pbuf_split_64k(recv_data, &rest);
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
        if (recv_data != NULL) {
 2022858:	d0a7ee17 	ldw	r2,-24648(gp)
 202285c:	10002926 	beq	r2,zero,2022904 <tcp_input+0xc4c>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
 2022860:	e0bff517 	ldw	r2,-44(fp)
 2022864:	1080088b 	ldhu	r2,34(r2)
 2022868:	10bfffcc 	andi	r2,r2,65535
 202286c:	1080040c 	andi	r2,r2,16
 2022870:	10000626 	beq	r2,zero,202288c <tcp_input+0xbd4>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 2022874:	d0a7ee17 	ldw	r2,-24648(gp)
 2022878:	1009883a 	mov	r4,r2
 202287c:	201d2f40 	call	201d2f4 <pbuf_free>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            tcp_abort(pcb);
 2022880:	e13ff517 	ldw	r4,-44(fp)
 2022884:	201f70c0 	call	201f70c <tcp_abort>
            goto aborted;
 2022888:	00005a06 	br	20229f4 <tcp_input+0xd3c>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 202288c:	e0bff517 	ldw	r2,-44(fp)
 2022890:	10802317 	ldw	r2,140(r2)
 2022894:	10000c26 	beq	r2,zero,20228c8 <tcp_input+0xc10>
 2022898:	e0bff517 	ldw	r2,-44(fp)
 202289c:	10802317 	ldw	r2,140(r2)
 20228a0:	e0fff517 	ldw	r3,-44(fp)
 20228a4:	18c00517 	ldw	r3,20(r3)
 20228a8:	d127ee17 	ldw	r4,-24648(gp)
 20228ac:	000f883a 	mov	r7,zero
 20228b0:	200d883a 	mov	r6,r4
 20228b4:	e17ff517 	ldw	r5,-44(fp)
 20228b8:	1809883a 	mov	r4,r3
 20228bc:	103ee83a 	callr	r2
 20228c0:	e0bffa05 	stb	r2,-24(fp)
 20228c4:	00000706 	br	20228e4 <tcp_input+0xc2c>
 20228c8:	d0a7ee17 	ldw	r2,-24648(gp)
 20228cc:	000f883a 	mov	r7,zero
 20228d0:	100d883a 	mov	r6,r2
 20228d4:	e17ff517 	ldw	r5,-44(fp)
 20228d8:	0009883a 	mov	r4,zero
 20228dc:	2020fe80 	call	2020fe8 <tcp_recv_null>
 20228e0:	e0bffa05 	stb	r2,-24(fp)
          if (err == ERR_ABRT) {
 20228e4:	e0bffa07 	ldb	r2,-24(fp)
 20228e8:	10bffcd8 	cmpnei	r2,r2,-13
 20228ec:	10003c26 	beq	r2,zero,20229e0 <tcp_input+0xd28>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 20228f0:	e0bffa07 	ldb	r2,-24(fp)
 20228f4:	10000326 	beq	r2,zero,2022904 <tcp_input+0xc4c>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_cat(recv_data, rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            pcb->refused_data = recv_data;
 20228f8:	d0e7ee17 	ldw	r3,-24648(gp)
 20228fc:	e0bff517 	ldw	r2,-44(fp)
 2022900:	10c02015 	stw	r3,128(r2)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 2022904:	d0a7ed43 	ldbu	r2,-24651(gp)
 2022908:	10803fcc 	andi	r2,r2,255
 202290c:	1080080c 	andi	r2,r2,32
 2022910:	10002826 	beq	r2,zero,20229b4 <tcp_input+0xcfc>
          if (pcb->refused_data != NULL) {
 2022914:	e0bff517 	ldw	r2,-44(fp)
 2022918:	10802017 	ldw	r2,128(r2)
 202291c:	10000826 	beq	r2,zero,2022940 <tcp_input+0xc88>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 2022920:	e0bff517 	ldw	r2,-44(fp)
 2022924:	10802017 	ldw	r2,128(r2)
 2022928:	e0fff517 	ldw	r3,-44(fp)
 202292c:	18c02017 	ldw	r3,128(r3)
 2022930:	18c00343 	ldbu	r3,13(r3)
 2022934:	18c00814 	ori	r3,r3,32
 2022938:	10c00345 	stb	r3,13(r2)
 202293c:	00001d06 	br	20229b4 <tcp_input+0xcfc>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 2022940:	e0bff517 	ldw	r2,-44(fp)
 2022944:	10800c0b 	ldhu	r2,48(r2)
 2022948:	10bfffcc 	andi	r2,r2,65535
 202294c:	10880020 	cmpeqi	r2,r2,8192
 2022950:	1000061e 	bne	r2,zero,202296c <tcp_input+0xcb4>
              pcb->rcv_wnd++;
 2022954:	e0bff517 	ldw	r2,-44(fp)
 2022958:	10800c0b 	ldhu	r2,48(r2)
 202295c:	10800044 	addi	r2,r2,1
 2022960:	1007883a 	mov	r3,r2
 2022964:	e0bff517 	ldw	r2,-44(fp)
 2022968:	10c00c0d 	sth	r3,48(r2)
            }
            TCP_EVENT_CLOSED(pcb, err);
 202296c:	e0bff517 	ldw	r2,-44(fp)
 2022970:	10802317 	ldw	r2,140(r2)
 2022974:	10000b26 	beq	r2,zero,20229a4 <tcp_input+0xcec>
 2022978:	e0bff517 	ldw	r2,-44(fp)
 202297c:	10802317 	ldw	r2,140(r2)
 2022980:	e0fff517 	ldw	r3,-44(fp)
 2022984:	18c00517 	ldw	r3,20(r3)
 2022988:	000f883a 	mov	r7,zero
 202298c:	000d883a 	mov	r6,zero
 2022990:	e17ff517 	ldw	r5,-44(fp)
 2022994:	1809883a 	mov	r4,r3
 2022998:	103ee83a 	callr	r2
 202299c:	e0bffa05 	stb	r2,-24(fp)
 20229a0:	00000106 	br	20229a8 <tcp_input+0xcf0>
 20229a4:	e03ffa05 	stb	zero,-24(fp)
            if (err == ERR_ABRT) {
 20229a8:	e0bffa07 	ldb	r2,-24(fp)
 20229ac:	10bffcd8 	cmpnei	r2,r2,-13
 20229b0:	10000d26 	beq	r2,zero,20229e8 <tcp_input+0xd30>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 20229b4:	d027ef15 	stw	zero,-24644(gp)
        if (tcp_input_delayed_close(pcb)) {
 20229b8:	e13ff517 	ldw	r4,-44(fp)
 20229bc:	2022b4c0 	call	2022b4c <tcp_input_delayed_close>
 20229c0:	10000b1e 	bne	r2,zero,20229f0 <tcp_input+0xd38>
          goto aborted;
        }
        /* Try to send something out. */
        tcp_output(pcb);
 20229c4:	e13ff517 	ldw	r4,-44(fp)
 20229c8:	20275b40 	call	20275b4 <tcp_output>
 20229cc:	00000906 	br	20229f4 <tcp_input+0xd3c>
          {
            acked16 = recv_acked;
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
            if (err == ERR_ABRT) {
              goto aborted;
 20229d0:	0001883a 	nop
 20229d4:	00000706 	br	20229f4 <tcp_input+0xd3c>
            }
          }
          recv_acked = 0;
        }
        if (tcp_input_delayed_close(pcb)) {
          goto aborted;
 20229d8:	0001883a 	nop
 20229dc:	00000506 	br	20229f4 <tcp_input+0xd3c>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
 20229e0:	0001883a 	nop
 20229e4:	00000306 	br	20229f4 <tcp_input+0xd3c>
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
            if (err == ERR_ABRT) {
              goto aborted;
 20229e8:	0001883a 	nop
 20229ec:	00000106 	br	20229f4 <tcp_input+0xd3c>
          }
        }

        tcp_input_pcb = NULL;
        if (tcp_input_delayed_close(pcb)) {
          goto aborted;
 20229f0:	0001883a 	nop
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
 20229f4:	d027ef15 	stw	zero,-24644(gp)
    recv_data = NULL;
 20229f8:	d027ee15 	stw	zero,-24648(gp)

    /* give up our reference to inseg.p */
    if (inseg.p != NULL) {
 20229fc:	00808174 	movhi	r2,517
 2022a00:	10b45f04 	addi	r2,r2,-11908
 2022a04:	10800117 	ldw	r2,4(r2)
 2022a08:	10004926 	beq	r2,zero,2022b30 <tcp_input+0xe78>
      pbuf_free(inseg.p);
 2022a0c:	00808174 	movhi	r2,517
 2022a10:	10b45f04 	addi	r2,r2,-11908
 2022a14:	10800117 	ldw	r2,4(r2)
 2022a18:	1009883a 	mov	r4,r2
 2022a1c:	201d2f40 	call	201d2f4 <pbuf_free>
      inseg.p = NULL;
 2022a20:	00808174 	movhi	r2,517
 2022a24:	10b45f04 	addi	r2,r2,-11908
 2022a28:	10000115 	stw	zero,4(r2)
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 2022a2c:	00004006 	br	2022b30 <tcp_input+0xe78>
    }
  } else {
    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 2022a30:	d0a7e617 	ldw	r2,-24680(gp)
 2022a34:	10c00303 	ldbu	r3,12(r2)
 2022a38:	10800343 	ldbu	r2,13(r2)
 2022a3c:	1004923a 	slli	r2,r2,8
 2022a40:	10c4b03a 	or	r2,r2,r3
 2022a44:	10bfffcc 	andi	r2,r2,65535
 2022a48:	1009883a 	mov	r4,r2
 2022a4c:	20394740 	call	2039474 <lwip_htons>
 2022a50:	10803fcc 	andi	r2,r2,255
 2022a54:	1080010c 	andi	r2,r2,4
 2022a58:	1000281e 	bne	r2,zero,2022afc <tcp_input+0xe44>
      TCP_STATS_INC(tcp.proterr);
 2022a5c:	008085f4 	movhi	r2,535
 2022a60:	10bd8204 	addi	r2,r2,-2552
 2022a64:	10805017 	ldw	r2,320(r2)
 2022a68:	10c00044 	addi	r3,r2,1
 2022a6c:	008085f4 	movhi	r2,535
 2022a70:	10bd8204 	addi	r2,r2,-2552
 2022a74:	10c05015 	stw	r3,320(r2)
      TCP_STATS_INC(tcp.drop);
 2022a78:	008085f4 	movhi	r2,535
 2022a7c:	10bd8204 	addi	r2,r2,-2552
 2022a80:	10804b17 	ldw	r2,300(r2)
 2022a84:	10c00044 	addi	r3,r2,1
 2022a88:	008085f4 	movhi	r2,535
 2022a8c:	10bd8204 	addi	r2,r2,-2552
 2022a90:	10c04b15 	stw	r3,300(r2)
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 2022a94:	d167eb17 	ldw	r5,-24660(gp)
 2022a98:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2022a9c:	10ffffcc 	andi	r3,r2,65535
 2022aa0:	d0a7ea17 	ldw	r2,-24664(gp)
 2022aa4:	188d883a 	add	r6,r3,r2
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2022aa8:	d0a7e617 	ldw	r2,-24680(gp)
 2022aac:	10c00083 	ldbu	r3,2(r2)
 2022ab0:	108000c3 	ldbu	r2,3(r2)
 2022ab4:	1004923a 	slli	r2,r2,8
 2022ab8:	10c4b03a 	or	r2,r2,r3
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 2022abc:	10ffffcc 	andi	r3,r2,65535
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2022ac0:	d0a7e617 	ldw	r2,-24680(gp)
 2022ac4:	11000003 	ldbu	r4,0(r2)
 2022ac8:	10800043 	ldbu	r2,1(r2)
 2022acc:	1004923a 	slli	r2,r2,8
 2022ad0:	1104b03a 	or	r2,r2,r4
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 2022ad4:	10bfffcc 	andi	r2,r2,65535
 2022ad8:	d8800215 	stw	r2,8(sp)
 2022adc:	d8c00115 	stw	r3,4(sp)
 2022ae0:	008085f4 	movhi	r2,535
 2022ae4:	10be4604 	addi	r2,r2,-1768
 2022ae8:	d8800015 	stw	r2,0(sp)
 2022aec:	01c085f4 	movhi	r7,535
 2022af0:	39fe4704 	addi	r7,r7,-1764
 2022af4:	0009883a 	mov	r4,zero
 2022af8:	2028cf40 	call	2028cf4 <tcp_rst>
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
 2022afc:	e13ffd17 	ldw	r4,-12(fp)
 2022b00:	201d2f40 	call	201d2f4 <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 2022b04:	00000a06 	br	2022b30 <tcp_input+0xe78>
dropped:
  TCP_STATS_INC(tcp.drop);
 2022b08:	008085f4 	movhi	r2,535
 2022b0c:	10bd8204 	addi	r2,r2,-2552
 2022b10:	10804b17 	ldw	r2,300(r2)
 2022b14:	10c00044 	addi	r3,r2,1
 2022b18:	008085f4 	movhi	r2,535
 2022b1c:	10bd8204 	addi	r2,r2,-2552
 2022b20:	10c04b15 	stw	r3,300(r2)
  MIB2_STATS_INC(mib2.tcpinerrs);
  pbuf_free(p);
 2022b24:	e13ffd17 	ldw	r4,-12(fp)
 2022b28:	201d2f40 	call	201d2f4 <pbuf_free>
 2022b2c:	00000106 	br	2022b34 <tcp_input+0xe7c>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 2022b30:	0001883a 	nop
dropped:
  TCP_STATS_INC(tcp.drop);
  MIB2_STATS_INC(mib2.tcpinerrs);
  pbuf_free(p);
}
 2022b34:	e6ffff04 	addi	sp,fp,-4
 2022b38:	dfc00217 	ldw	ra,8(sp)
 2022b3c:	df000117 	ldw	fp,4(sp)
 2022b40:	dc000017 	ldw	r16,0(sp)
 2022b44:	dec00304 	addi	sp,sp,12
 2022b48:	f800283a 	ret

02022b4c <tcp_input_delayed_close>:
 * any more.
 * @returns 1 if the pcb has been closed and deallocated, 0 otherwise
 */
static int
tcp_input_delayed_close(struct tcp_pcb *pcb)
{
 2022b4c:	defffd04 	addi	sp,sp,-12
 2022b50:	dfc00215 	stw	ra,8(sp)
 2022b54:	df000115 	stw	fp,4(sp)
 2022b58:	df000104 	addi	fp,sp,4
 2022b5c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);

  if (recv_flags & TF_CLOSED) {
 2022b60:	d0a7ed43 	ldbu	r2,-24651(gp)
 2022b64:	10803fcc 	andi	r2,r2,255
 2022b68:	1080040c 	andi	r2,r2,16
 2022b6c:	10001626 	beq	r2,zero,2022bc8 <tcp_input_delayed_close+0x7c>
    /* The connection has been closed and we will deallocate the
        PCB. */
    if (!(pcb->flags & TF_RXCLOSED)) {
 2022b70:	e0bfff17 	ldw	r2,-4(fp)
 2022b74:	1080088b 	ldhu	r2,34(r2)
 2022b78:	10bfffcc 	andi	r2,r2,65535
 2022b7c:	1080040c 	andi	r2,r2,16
 2022b80:	10000a1e 	bne	r2,zero,2022bac <tcp_input_delayed_close+0x60>
      /* Connection closed although the application has only shut down the
          tx side: call the PCB's err callback and indicate the closure to
          ensure the application doesn't continue using the PCB. */
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 2022b84:	e0bfff17 	ldw	r2,-4(fp)
 2022b88:	10802617 	ldw	r2,152(r2)
 2022b8c:	10000726 	beq	r2,zero,2022bac <tcp_input_delayed_close+0x60>
 2022b90:	e0bfff17 	ldw	r2,-4(fp)
 2022b94:	10802617 	ldw	r2,152(r2)
 2022b98:	e0ffff17 	ldw	r3,-4(fp)
 2022b9c:	18c00517 	ldw	r3,20(r3)
 2022ba0:	017ffc44 	movi	r5,-15
 2022ba4:	1809883a 	mov	r4,r3
 2022ba8:	103ee83a 	callr	r2
    }
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 2022bac:	e17fff17 	ldw	r5,-4(fp)
 2022bb0:	d127e104 	addi	r4,gp,-24700
 2022bb4:	202185c0 	call	202185c <tcp_pcb_remove>
    tcp_free(pcb);
 2022bb8:	e13fff17 	ldw	r4,-4(fp)
 2022bbc:	201eda00 	call	201eda0 <tcp_free>
    return 1;
 2022bc0:	00800044 	movi	r2,1
 2022bc4:	00000106 	br	2022bcc <tcp_input_delayed_close+0x80>
  }
  return 0;
 2022bc8:	0005883a 	mov	r2,zero
}
 2022bcc:	e037883a 	mov	sp,fp
 2022bd0:	dfc00117 	ldw	ra,4(sp)
 2022bd4:	df000017 	ldw	fp,0(sp)
 2022bd8:	dec00204 	addi	sp,sp,8
 2022bdc:	f800283a 	ret

02022be0 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 2022be0:	defff504 	addi	sp,sp,-44
 2022be4:	dfc00a15 	stw	ra,40(sp)
 2022be8:	df000915 	stw	fp,36(sp)
 2022bec:	dc000815 	stw	r16,32(sp)
 2022bf0:	df000904 	addi	fp,sp,36
 2022bf4:	e13ffe15 	stw	r4,-8(fp)
  struct tcp_pcb *npcb;
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
 2022bf8:	d0a7ed03 	ldbu	r2,-24652(gp)
 2022bfc:	10803fcc 	andi	r2,r2,255
 2022c00:	1080010c 	andi	r2,r2,4
 2022c04:	1000cf1e 	bne	r2,zero,2022f44 <tcp_listen_input+0x364>

  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 2022c08:	d0a7ed03 	ldbu	r2,-24652(gp)
 2022c0c:	10803fcc 	andi	r2,r2,255
 2022c10:	1080040c 	andi	r2,r2,16
 2022c14:	10001b26 	beq	r2,zero,2022c84 <tcp_listen_input+0xa4>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 2022c18:	d167eb17 	ldw	r5,-24660(gp)
 2022c1c:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2022c20:	10ffffcc 	andi	r3,r2,65535
 2022c24:	d0a7ea17 	ldw	r2,-24664(gp)
 2022c28:	188d883a 	add	r6,r3,r2
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2022c2c:	d0a7e617 	ldw	r2,-24680(gp)
 2022c30:	10c00083 	ldbu	r3,2(r2)
 2022c34:	108000c3 	ldbu	r2,3(r2)
 2022c38:	1004923a 	slli	r2,r2,8
 2022c3c:	10c4b03a 	or	r2,r2,r3
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 2022c40:	10ffffcc 	andi	r3,r2,65535
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2022c44:	d0a7e617 	ldw	r2,-24680(gp)
 2022c48:	11000003 	ldbu	r4,0(r2)
 2022c4c:	10800043 	ldbu	r2,1(r2)
 2022c50:	1004923a 	slli	r2,r2,8
 2022c54:	1104b03a 	or	r2,r2,r4
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 2022c58:	10bfffcc 	andi	r2,r2,65535
 2022c5c:	d8800215 	stw	r2,8(sp)
 2022c60:	d8c00115 	stw	r3,4(sp)
 2022c64:	008085f4 	movhi	r2,535
 2022c68:	10be4604 	addi	r2,r2,-1768
 2022c6c:	d8800015 	stw	r2,0(sp)
 2022c70:	01c085f4 	movhi	r7,535
 2022c74:	39fe4704 	addi	r7,r7,-1764
 2022c78:	e13ffe17 	ldw	r4,-8(fp)
 2022c7c:	2028cf40 	call	2028cf4 <tcp_rst>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
 2022c80:	0000b206 	br	2022f4c <tcp_listen_input+0x36c>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
 2022c84:	d0a7ed03 	ldbu	r2,-24652(gp)
 2022c88:	10803fcc 	andi	r2,r2,255
 2022c8c:	1080008c 	andi	r2,r2,2
 2022c90:	1000ae26 	beq	r2,zero,2022f4c <tcp_listen_input+0x36c>
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
 2022c94:	e0bffe17 	ldw	r2,-8(fp)
 2022c98:	10c00943 	ldbu	r3,37(r2)
 2022c9c:	e0bffe17 	ldw	r2,-8(fp)
 2022ca0:	10800903 	ldbu	r2,36(r2)
 2022ca4:	18c03fcc 	andi	r3,r3,255
 2022ca8:	10803fcc 	andi	r2,r2,255
 2022cac:	1880a92e 	bgeu	r3,r2,2022f54 <tcp_listen_input+0x374>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 2022cb0:	e0bffe17 	ldw	r2,-8(fp)
 2022cb4:	10800703 	ldbu	r2,28(r2)
 2022cb8:	10803fcc 	andi	r2,r2,255
 2022cbc:	1009883a 	mov	r4,r2
 2022cc0:	20213480 	call	2021348 <tcp_alloc>
 2022cc4:	e0bffa15 	stw	r2,-24(fp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 2022cc8:	e0bffa17 	ldw	r2,-24(fp)
 2022ccc:	1000171e 	bne	r2,zero,2022d2c <tcp_listen_input+0x14c>
      err_t err;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
 2022cd0:	008085f4 	movhi	r2,535
 2022cd4:	10bd8204 	addi	r2,r2,-2552
 2022cd8:	10804e17 	ldw	r2,312(r2)
 2022cdc:	10c00044 	addi	r3,r2,1
 2022ce0:	008085f4 	movhi	r2,535
 2022ce4:	10bd8204 	addi	r2,r2,-2552
 2022ce8:	10c04e15 	stw	r3,312(r2)
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 2022cec:	e0bffe17 	ldw	r2,-8(fp)
 2022cf0:	10800817 	ldw	r2,32(r2)
 2022cf4:	10000a26 	beq	r2,zero,2022d20 <tcp_listen_input+0x140>
 2022cf8:	e0bffe17 	ldw	r2,-8(fp)
 2022cfc:	10800817 	ldw	r2,32(r2)
 2022d00:	e0fffe17 	ldw	r3,-8(fp)
 2022d04:	18c00517 	ldw	r3,20(r3)
 2022d08:	01bfffc4 	movi	r6,-1
 2022d0c:	000b883a 	mov	r5,zero
 2022d10:	1809883a 	mov	r4,r3
 2022d14:	103ee83a 	callr	r2
 2022d18:	e0bffb05 	stb	r2,-20(fp)
      LWIP_UNUSED_ARG(err); /* err not useful here */
      return;
 2022d1c:	00008e06 	br	2022f58 <tcp_listen_input+0x378>
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
      err_t err;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 2022d20:	00bffc04 	movi	r2,-16
 2022d24:	e0bffb05 	stb	r2,-20(fp)
      LWIP_UNUSED_ARG(err); /* err not useful here */
      return;
 2022d28:	00008b06 	br	2022f58 <tcp_listen_input+0x378>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
 2022d2c:	e0bffe17 	ldw	r2,-8(fp)
 2022d30:	10800943 	ldbu	r2,37(r2)
 2022d34:	10800044 	addi	r2,r2,1
 2022d38:	1007883a 	mov	r3,r2
 2022d3c:	e0bffe17 	ldw	r2,-8(fp)
 2022d40:	10c00945 	stb	r3,37(r2)
    tcp_set_flags(npcb, TF_BACKLOGPEND);
 2022d44:	e0bffa17 	ldw	r2,-24(fp)
 2022d48:	1080088b 	ldhu	r2,34(r2)
 2022d4c:	10808014 	ori	r2,r2,512
 2022d50:	1007883a 	mov	r3,r2
 2022d54:	e0bffa17 	ldw	r2,-24(fp)
 2022d58:	10c0088d 	sth	r3,34(r2)
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 2022d5c:	008085f4 	movhi	r2,535
 2022d60:	10be4204 	addi	r2,r2,-1784
 2022d64:	10c00517 	ldw	r3,20(r2)
 2022d68:	e0bffa17 	ldw	r2,-24(fp)
 2022d6c:	10c00015 	stw	r3,0(r2)
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 2022d70:	008085f4 	movhi	r2,535
 2022d74:	10be4204 	addi	r2,r2,-1784
 2022d78:	10c00417 	ldw	r3,16(r2)
 2022d7c:	e0bffa17 	ldw	r2,-24(fp)
 2022d80:	10c00115 	stw	r3,4(r2)
    npcb->local_port = pcb->local_port;
 2022d84:	e0bffe17 	ldw	r2,-8(fp)
 2022d88:	10c0078b 	ldhu	r3,30(r2)
 2022d8c:	e0bffa17 	ldw	r2,-24(fp)
 2022d90:	10c0078d 	sth	r3,30(r2)
    npcb->remote_port = tcphdr->src;
 2022d94:	d0a7e617 	ldw	r2,-24680(gp)
 2022d98:	10c00003 	ldbu	r3,0(r2)
 2022d9c:	10800043 	ldbu	r2,1(r2)
 2022da0:	1004923a 	slli	r2,r2,8
 2022da4:	10c4b03a 	or	r2,r2,r3
 2022da8:	1007883a 	mov	r3,r2
 2022dac:	e0bffa17 	ldw	r2,-24(fp)
 2022db0:	10c0080d 	sth	r3,32(r2)
    npcb->state = SYN_RCVD;
 2022db4:	e0bffa17 	ldw	r2,-24(fp)
 2022db8:	00c000c4 	movi	r3,3
 2022dbc:	10c00615 	stw	r3,24(r2)
    npcb->rcv_nxt = seqno + 1;
 2022dc0:	d0a7ea17 	ldw	r2,-24664(gp)
 2022dc4:	10c00044 	addi	r3,r2,1
 2022dc8:	e0bffa17 	ldw	r2,-24(fp)
 2022dcc:	10c00b15 	stw	r3,44(r2)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 2022dd0:	e0bffa17 	ldw	r2,-24(fp)
 2022dd4:	10c00b17 	ldw	r3,44(r2)
 2022dd8:	e0bffa17 	ldw	r2,-24(fp)
 2022ddc:	10c00d15 	stw	r3,52(r2)
    iss = tcp_next_iss(npcb);
 2022de0:	e13ffa17 	ldw	r4,-24(fp)
 2022de4:	20219700 	call	2021970 <tcp_next_iss>
 2022de8:	e0bffc15 	stw	r2,-16(fp)
    npcb->snd_wl2 = iss;
 2022dec:	e0bffa17 	ldw	r2,-24(fp)
 2022df0:	e0fffc17 	ldw	r3,-16(fp)
 2022df4:	10c01815 	stw	r3,96(r2)
    npcb->snd_nxt = iss;
 2022df8:	e0bffa17 	ldw	r2,-24(fp)
 2022dfc:	e0fffc17 	ldw	r3,-16(fp)
 2022e00:	10c01615 	stw	r3,88(r2)
    npcb->lastack = iss;
 2022e04:	e0bffa17 	ldw	r2,-24(fp)
 2022e08:	e0fffc17 	ldw	r3,-16(fp)
 2022e0c:	10c01315 	stw	r3,76(r2)
    npcb->snd_lbb = iss;
 2022e10:	e0bffa17 	ldw	r2,-24(fp)
 2022e14:	e0fffc17 	ldw	r3,-16(fp)
 2022e18:	10c01915 	stw	r3,100(r2)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 2022e1c:	d0a7ea17 	ldw	r2,-24664(gp)
 2022e20:	10ffffc4 	addi	r3,r2,-1
 2022e24:	e0bffa17 	ldw	r2,-24(fp)
 2022e28:	10c01715 	stw	r3,92(r2)
    npcb->callback_arg = pcb->callback_arg;
 2022e2c:	e0bffe17 	ldw	r2,-8(fp)
 2022e30:	10c00517 	ldw	r3,20(r2)
 2022e34:	e0bffa17 	ldw	r2,-24(fp)
 2022e38:	10c00515 	stw	r3,20(r2)
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
    npcb->listener = pcb;
 2022e3c:	e0bffa17 	ldw	r2,-24(fp)
 2022e40:	e0fffe17 	ldw	r3,-8(fp)
 2022e44:	10c02115 	stw	r3,132(r2)
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
#if LWIP_VLAN_PCP
    npcb->netif_hints.tci = pcb->netif_hints.tci;
#endif /* LWIP_VLAN_PCP */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 2022e48:	e0bffe17 	ldw	r2,-8(fp)
 2022e4c:	10800243 	ldbu	r2,9(r2)
 2022e50:	1080030c 	andi	r2,r2,12
 2022e54:	1007883a 	mov	r3,r2
 2022e58:	e0bffa17 	ldw	r2,-24(fp)
 2022e5c:	10c00245 	stb	r3,9(r2)
    npcb->netif_idx = pcb->netif_idx;
 2022e60:	e0bffe17 	ldw	r2,-8(fp)
 2022e64:	10c00203 	ldbu	r3,8(r2)
 2022e68:	e0bffa17 	ldw	r2,-24(fp)
 2022e6c:	10c00205 	stb	r3,8(r2)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 2022e70:	d0e7e117 	ldw	r3,-24700(gp)
 2022e74:	e0bffa17 	ldw	r2,-24(fp)
 2022e78:	10c00415 	stw	r3,16(r2)
 2022e7c:	e0bffa17 	ldw	r2,-24(fp)
 2022e80:	d0a7e115 	stw	r2,-24700(gp)
 2022e84:	20292b80 	call	20292b8 <tcp_timer_needed>
 2022e88:	00800044 	movi	r2,1
 2022e8c:	d0a7e085 	stb	r2,-24702(gp)

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 2022e90:	e13ffa17 	ldw	r4,-24(fp)
 2022e94:	2025a4c0 	call	2025a4c <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 2022e98:	d0a7e617 	ldw	r2,-24680(gp)
 2022e9c:	10c00383 	ldbu	r3,14(r2)
 2022ea0:	108003c3 	ldbu	r2,15(r2)
 2022ea4:	1004923a 	slli	r2,r2,8
 2022ea8:	10c4b03a 	or	r2,r2,r3
 2022eac:	1007883a 	mov	r3,r2
 2022eb0:	e0bffa17 	ldw	r2,-24(fp)
 2022eb4:	10c01a0d 	sth	r3,104(r2)
    npcb->snd_wnd_max = npcb->snd_wnd;
 2022eb8:	e0bffa17 	ldw	r2,-24(fp)
 2022ebc:	10c01a0b 	ldhu	r3,104(r2)
 2022ec0:	e0bffa17 	ldw	r2,-24(fp)
 2022ec4:	10c01a8d 	sth	r3,106(r2)

#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 2022ec8:	e0bffa17 	ldw	r2,-24(fp)
 2022ecc:	10800e8b 	ldhu	r2,58(r2)
 2022ed0:	143fffcc 	andi	r16,r2,65535
 2022ed4:	e0bffa17 	ldw	r2,-24(fp)
 2022ed8:	10800104 	addi	r2,r2,4
 2022edc:	1009883a 	mov	r4,r2
 2022ee0:	203b5c40 	call	203b5c4 <ip4_route>
 2022ee4:	1007883a 	mov	r3,r2
 2022ee8:	e0bffa17 	ldw	r2,-24(fp)
 2022eec:	10800104 	addi	r2,r2,4
 2022ef0:	100d883a 	mov	r6,r2
 2022ef4:	180b883a 	mov	r5,r3
 2022ef8:	8009883a 	mov	r4,r16
 2022efc:	20219a40 	call	20219a4 <tcp_eff_send_mss_netif>
 2022f00:	1007883a 	mov	r3,r2
 2022f04:	e0bffa17 	ldw	r2,-24(fp)
 2022f08:	10c00e8d 	sth	r3,58(r2)
      return;
    }
#endif

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 2022f0c:	01400484 	movi	r5,18
 2022f10:	e13ffa17 	ldw	r4,-24(fp)
 2022f14:	20273a80 	call	20273a8 <tcp_enqueue_flags>
 2022f18:	e0bffd05 	stb	r2,-12(fp)
    if (rc != ERR_OK) {
 2022f1c:	e0bffd07 	ldb	r2,-12(fp)
 2022f20:	10000426 	beq	r2,zero,2022f34 <tcp_listen_input+0x354>
      tcp_abandon(npcb, 0);
 2022f24:	000b883a 	mov	r5,zero
 2022f28:	e13ffa17 	ldw	r4,-24(fp)
 2022f2c:	201f4f40 	call	201f4f4 <tcp_abandon>
      return;
 2022f30:	00000906 	br	2022f58 <tcp_listen_input+0x378>
    }
    tcp_output(npcb);
 2022f34:	e13ffa17 	ldw	r4,-24(fp)
 2022f38:	20275b40 	call	20275b4 <tcp_output>
  }
  return;
 2022f3c:	0001883a 	nop
 2022f40:	00000206 	br	2022f4c <tcp_listen_input+0x36c>
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
    /* An incoming RST should be ignored. Return. */
    return;
 2022f44:	0001883a 	nop
 2022f48:	00000306 	br	2022f58 <tcp_listen_input+0x378>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
 2022f4c:	0001883a 	nop
 2022f50:	00000106 	br	2022f58 <tcp_listen_input+0x378>
  } else if (flags & TCP_SYN) {
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return;
 2022f54:	0001883a 	nop
      return;
    }
    tcp_output(npcb);
  }
  return;
}
 2022f58:	e6ffff04 	addi	sp,fp,-4
 2022f5c:	dfc00217 	ldw	ra,8(sp)
 2022f60:	df000117 	ldw	fp,4(sp)
 2022f64:	dc000017 	ldw	r16,0(sp)
 2022f68:	dec00304 	addi	sp,sp,12
 2022f6c:	f800283a 	ret

02022f70 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_timewait_input(struct tcp_pcb *pcb)
{
 2022f70:	defffa04 	addi	sp,sp,-24
 2022f74:	dfc00515 	stw	ra,20(sp)
 2022f78:	df000415 	stw	fp,16(sp)
 2022f7c:	df000404 	addi	fp,sp,16
 2022f80:	e13fff15 	stw	r4,-4(fp)
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
 2022f84:	d0a7ed03 	ldbu	r2,-24652(gp)
 2022f88:	10803fcc 	andi	r2,r2,255
 2022f8c:	1080010c 	andi	r2,r2,4
 2022f90:	1000411e 	bne	r2,zero,2023098 <tcp_timewait_input+0x128>
  }

  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);

  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 2022f94:	d0a7ed03 	ldbu	r2,-24652(gp)
 2022f98:	10803fcc 	andi	r2,r2,255
 2022f9c:	1080008c 	andi	r2,r2,2
 2022fa0:	10002926 	beq	r2,zero,2023048 <tcp_timewait_input+0xd8>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 2022fa4:	d0e7ea17 	ldw	r3,-24664(gp)
 2022fa8:	e0bfff17 	ldw	r2,-4(fp)
 2022fac:	10800b17 	ldw	r2,44(r2)
 2022fb0:	1885c83a 	sub	r2,r3,r2
 2022fb4:	10002b16 	blt	r2,zero,2023064 <tcp_timewait_input+0xf4>
 2022fb8:	d0e7ea17 	ldw	r3,-24664(gp)
 2022fbc:	e0bfff17 	ldw	r2,-4(fp)
 2022fc0:	11000b17 	ldw	r4,44(r2)
 2022fc4:	e0bfff17 	ldw	r2,-4(fp)
 2022fc8:	10800c0b 	ldhu	r2,48(r2)
 2022fcc:	10bfffcc 	andi	r2,r2,65535
 2022fd0:	2085883a 	add	r2,r4,r2
 2022fd4:	1885c83a 	sub	r2,r3,r2
 2022fd8:	00802216 	blt	zero,r2,2023064 <tcp_timewait_input+0xf4>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 2022fdc:	d167eb17 	ldw	r5,-24660(gp)
 2022fe0:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2022fe4:	10ffffcc 	andi	r3,r2,65535
 2022fe8:	d0a7ea17 	ldw	r2,-24664(gp)
 2022fec:	188d883a 	add	r6,r3,r2
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2022ff0:	d0a7e617 	ldw	r2,-24680(gp)
 2022ff4:	10c00083 	ldbu	r3,2(r2)
 2022ff8:	108000c3 	ldbu	r2,3(r2)
 2022ffc:	1004923a 	slli	r2,r2,8
 2023000:	10c4b03a 	or	r2,r2,r3
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 2023004:	10ffffcc 	andi	r3,r2,65535
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2023008:	d0a7e617 	ldw	r2,-24680(gp)
 202300c:	11000003 	ldbu	r4,0(r2)
 2023010:	10800043 	ldbu	r2,1(r2)
 2023014:	1004923a 	slli	r2,r2,8
 2023018:	1104b03a 	or	r2,r2,r4
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 202301c:	10bfffcc 	andi	r2,r2,65535
 2023020:	d8800215 	stw	r2,8(sp)
 2023024:	d8c00115 	stw	r3,4(sp)
 2023028:	008085f4 	movhi	r2,535
 202302c:	10be4604 	addi	r2,r2,-1768
 2023030:	d8800015 	stw	r2,0(sp)
 2023034:	01c085f4 	movhi	r7,535
 2023038:	39fe4704 	addi	r7,r7,-1764
 202303c:	e13fff17 	ldw	r4,-4(fp)
 2023040:	2028cf40 	call	2028cf4 <tcp_rst>
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
      return;
 2023044:	00001706 	br	20230a4 <tcp_timewait_input+0x134>
    }
  } else if (flags & TCP_FIN) {
 2023048:	d0a7ed03 	ldbu	r2,-24652(gp)
 202304c:	10803fcc 	andi	r2,r2,255
 2023050:	1080004c 	andi	r2,r2,1
 2023054:	10000326 	beq	r2,zero,2023064 <tcp_timewait_input+0xf4>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 2023058:	d0e7e217 	ldw	r3,-24696(gp)
 202305c:	e0bfff17 	ldw	r2,-4(fp)
 2023060:	10c00a15 	stw	r3,40(r2)
  }

  if ((tcplen > 0)) {
 2023064:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2023068:	10bfffcc 	andi	r2,r2,65535
 202306c:	10000c26 	beq	r2,zero,20230a0 <tcp_timewait_input+0x130>
    /* Acknowledge data, FIN or out-of-window SYN */
    tcp_ack_now(pcb);
 2023070:	e0bfff17 	ldw	r2,-4(fp)
 2023074:	1080088b 	ldhu	r2,34(r2)
 2023078:	10800094 	ori	r2,r2,2
 202307c:	1007883a 	mov	r3,r2
 2023080:	e0bfff17 	ldw	r2,-4(fp)
 2023084:	10c0088d 	sth	r3,34(r2)
    tcp_output(pcb);
 2023088:	e13fff17 	ldw	r4,-4(fp)
 202308c:	20275b40 	call	20275b4 <tcp_output>
  }
  return;
 2023090:	0001883a 	nop
 2023094:	00000206 	br	20230a0 <tcp_timewait_input+0x130>
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
    return;
 2023098:	0001883a 	nop
 202309c:	00000106 	br	20230a4 <tcp_timewait_input+0x134>
  if ((tcplen > 0)) {
    /* Acknowledge data, FIN or out-of-window SYN */
    tcp_ack_now(pcb);
    tcp_output(pcb);
  }
  return;
 20230a0:	0001883a 	nop
}
 20230a4:	e037883a 	mov	sp,fp
 20230a8:	dfc00117 	ldw	ra,4(sp)
 20230ac:	df000017 	ldw	fp,0(sp)
 20230b0:	dec00204 	addi	sp,sp,8
 20230b4:	f800283a 	ret

020230b8 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 20230b8:	defff404 	addi	sp,sp,-48
 20230bc:	dfc00b15 	stw	ra,44(sp)
 20230c0:	df000a15 	stw	fp,40(sp)
 20230c4:	dc000915 	stw	r16,36(sp)
 20230c8:	df000a04 	addi	fp,sp,40
 20230cc:	e13ffe15 	stw	r4,-8(fp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 20230d0:	e03ffa05 	stb	zero,-24(fp)
  err_t err;

  err = ERR_OK;
 20230d4:	e03ffa45 	stb	zero,-23(fp)

  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 20230d8:	d0a7ed03 	ldbu	r2,-24652(gp)
 20230dc:	10803fcc 	andi	r2,r2,255
 20230e0:	1080010c 	andi	r2,r2,4
 20230e4:	10003626 	beq	r2,zero,20231c0 <tcp_process+0x108>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 20230e8:	e0bffe17 	ldw	r2,-8(fp)
 20230ec:	10800617 	ldw	r2,24(r2)
 20230f0:	10800098 	cmpnei	r2,r2,2
 20230f4:	1000071e 	bne	r2,zero,2023114 <tcp_process+0x5c>
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
 20230f8:	e0bffe17 	ldw	r2,-8(fp)
 20230fc:	10c01617 	ldw	r3,88(r2)
 2023100:	d0a7eb17 	ldw	r2,-24660(gp)
 2023104:	18801e1e 	bne	r3,r2,2023180 <tcp_process+0xc8>
        acceptable = 1;
 2023108:	00800044 	movi	r2,1
 202310c:	e0bffa05 	stb	r2,-24(fp)
 2023110:	00001b06 	br	2023180 <tcp_process+0xc8>
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
 2023114:	e0bffe17 	ldw	r2,-8(fp)
 2023118:	10c00b17 	ldw	r3,44(r2)
 202311c:	d0a7ea17 	ldw	r2,-24664(gp)
 2023120:	1880031e 	bne	r3,r2,2023130 <tcp_process+0x78>
        acceptable = 1;
 2023124:	00800044 	movi	r2,1
 2023128:	e0bffa05 	stb	r2,-24(fp)
 202312c:	00001406 	br	2023180 <tcp_process+0xc8>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 2023130:	d0e7ea17 	ldw	r3,-24664(gp)
 2023134:	e0bffe17 	ldw	r2,-8(fp)
 2023138:	10800b17 	ldw	r2,44(r2)
 202313c:	1885c83a 	sub	r2,r3,r2
 2023140:	10000f16 	blt	r2,zero,2023180 <tcp_process+0xc8>
 2023144:	d0e7ea17 	ldw	r3,-24664(gp)
 2023148:	e0bffe17 	ldw	r2,-8(fp)
 202314c:	11000b17 	ldw	r4,44(r2)
 2023150:	e0bffe17 	ldw	r2,-8(fp)
 2023154:	10800c0b 	ldhu	r2,48(r2)
 2023158:	10bfffcc 	andi	r2,r2,65535
 202315c:	2085883a 	add	r2,r4,r2
 2023160:	1885c83a 	sub	r2,r3,r2
 2023164:	00800616 	blt	zero,r2,2023180 <tcp_process+0xc8>
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we send a challenge ACK
           and wait for a re-send with matching sequence number.
           This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
           (RST spoofing attack), which is present in RFC 793 RST handling. */
        tcp_ack_now(pcb);
 2023168:	e0bffe17 	ldw	r2,-8(fp)
 202316c:	1080088b 	ldhu	r2,34(r2)
 2023170:	10800094 	ori	r2,r2,2
 2023174:	1007883a 	mov	r3,r2
 2023178:	e0bffe17 	ldw	r2,-8(fp)
 202317c:	10c0088d 	sth	r3,34(r2)
      }
    }

    if (acceptable) {
 2023180:	e0bffa03 	ldbu	r2,-24(fp)
 2023184:	10000c26 	beq	r2,zero,20231b8 <tcp_process+0x100>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 2023188:	d0a7ed43 	ldbu	r2,-24651(gp)
 202318c:	10800214 	ori	r2,r2,8
 2023190:	d0a7ed45 	stb	r2,-24651(gp)
      tcp_clear_flags(pcb, TF_ACK_DELAY);
 2023194:	e0bffe17 	ldw	r2,-8(fp)
 2023198:	10c0088b 	ldhu	r3,34(r2)
 202319c:	00bfff84 	movi	r2,-2
 20231a0:	1884703a 	and	r2,r3,r2
 20231a4:	1007883a 	mov	r3,r2
 20231a8:	e0bffe17 	ldw	r2,-8(fp)
 20231ac:	10c0088d 	sth	r3,34(r2)
      return ERR_RST;
 20231b0:	00bffc84 	movi	r2,-14
 20231b4:	00028c06 	br	2023be8 <tcp_process+0xb30>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                                    seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                              seqno, pcb->rcv_nxt));
      return ERR_OK;
 20231b8:	0005883a 	mov	r2,zero
 20231bc:	00028a06 	br	2023be8 <tcp_process+0xb30>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 20231c0:	d0a7ed03 	ldbu	r2,-24652(gp)
 20231c4:	10803fcc 	andi	r2,r2,255
 20231c8:	1080008c 	andi	r2,r2,2
 20231cc:	10001026 	beq	r2,zero,2023210 <tcp_process+0x158>
 20231d0:	e0bffe17 	ldw	r2,-8(fp)
 20231d4:	10800617 	ldw	r2,24(r2)
 20231d8:	108000a0 	cmpeqi	r2,r2,2
 20231dc:	10000c1e 	bne	r2,zero,2023210 <tcp_process+0x158>
 20231e0:	e0bffe17 	ldw	r2,-8(fp)
 20231e4:	10800617 	ldw	r2,24(r2)
 20231e8:	108000e0 	cmpeqi	r2,r2,3
 20231ec:	1000081e 	bne	r2,zero,2023210 <tcp_process+0x158>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 20231f0:	e0bffe17 	ldw	r2,-8(fp)
 20231f4:	1080088b 	ldhu	r2,34(r2)
 20231f8:	10800094 	ori	r2,r2,2
 20231fc:	1007883a 	mov	r3,r2
 2023200:	e0bffe17 	ldw	r2,-8(fp)
 2023204:	10c0088d 	sth	r3,34(r2)
    return ERR_OK;
 2023208:	0005883a 	mov	r2,zero
 202320c:	00027606 	br	2023be8 <tcp_process+0xb30>
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
 2023210:	e0bffe17 	ldw	r2,-8(fp)
 2023214:	1080088b 	ldhu	r2,34(r2)
 2023218:	10bfffcc 	andi	r2,r2,65535
 202321c:	1080040c 	andi	r2,r2,16
 2023220:	1000031e 	bne	r2,zero,2023230 <tcp_process+0x178>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 2023224:	d0e7e217 	ldw	r3,-24696(gp)
 2023228:	e0bffe17 	ldw	r2,-8(fp)
 202322c:	10c00a15 	stw	r3,40(r2)
  }
  pcb->keep_cnt_sent = 0;
 2023230:	e0bffe17 	ldw	r2,-8(fp)
 2023234:	10002ac5 	stb	zero,171(r2)
  pcb->persist_probe = 0;
 2023238:	e0bffe17 	ldw	r2,-8(fp)
 202323c:	10002a85 	stb	zero,170(r2)

  tcp_parseopt(pcb);
 2023240:	e13ffe17 	ldw	r4,-8(fp)
 2023244:	2025a4c0 	call	2025a4c <tcp_parseopt>

  if (flags & TCP_SYN) {
 2023248:	d0a7ed03 	ldbu	r2,-24652(gp)
 202324c:	10803fcc 	andi	r2,r2,255
 2023250:	1080008c 	andi	r2,r2,2
 2023254:	10000a26 	beq	r2,zero,2023280 <tcp_process+0x1c8>
    /* accept SYN only in 2 states: */
    if ((pcb->state != SYN_SENT) && (pcb->state != SYN_RCVD)) {
 2023258:	e0bffe17 	ldw	r2,-8(fp)
 202325c:	10800617 	ldw	r2,24(r2)
 2023260:	108000a0 	cmpeqi	r2,r2,2
 2023264:	1000061e 	bne	r2,zero,2023280 <tcp_process+0x1c8>
 2023268:	e0bffe17 	ldw	r2,-8(fp)
 202326c:	10800617 	ldw	r2,24(r2)
 2023270:	108000e0 	cmpeqi	r2,r2,3
 2023274:	1000021e 	bne	r2,zero,2023280 <tcp_process+0x1c8>
      return ERR_OK;
 2023278:	0005883a 	mov	r2,zero
 202327c:	00025a06 	br	2023be8 <tcp_process+0xb30>
    }
  }

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 2023280:	e0bffe17 	ldw	r2,-8(fp)
 2023284:	10800617 	ldw	r2,24(r2)
 2023288:	10c002a8 	cmpgeui	r3,r2,10
 202328c:	1802461e 	bne	r3,zero,2023ba8 <tcp_process+0xaf0>
 2023290:	100690ba 	slli	r3,r2,2
 2023294:	008080b4 	movhi	r2,514
 2023298:	108caa04 	addi	r2,r2,12968
 202329c:	1885883a 	add	r2,r3,r2
 20232a0:	10800017 	ldw	r2,0(r2)
 20232a4:	1000683a 	jmp	r2
 20232a8:	02023ba8 	cmpgeui	r8,zero,2286
 20232ac:	02023ba8 	cmpgeui	r8,zero,2286
 20232b0:	020232d0 	cmplti	r8,zero,2251
 20232b4:	020235d8 	cmpnei	r8,zero,2263
 20232b8:	02023820 	cmpeqi	r8,zero,2272
 20232bc:	02023860 	cmpeqi	r8,zero,2273
 20232c0:	020239c0 	call	20239c <__alt_mem_sdram_controller_0-0x1dfdc64>
 20232c4:	02023820 	cmpeqi	r8,zero,2272
 20232c8:	02023a90 	cmplti	r8,zero,2282
 20232cc:	02023b64 	muli	r8,zero,2285
    case SYN_SENT:
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %s %"U32_F"\n",
                                    ackno, pcb->snd_nxt, pcb->unacked ? "" : " empty:",
                                    pcb->unacked ? lwip_ntohl(pcb->unacked->tcphdr->seqno) : 0));
      /* received SYN ACK with expected sequence number? */
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
 20232d0:	d0a7ed03 	ldbu	r2,-24652(gp)
 20232d4:	10803fcc 	andi	r2,r2,255
 20232d8:	1080040c 	andi	r2,r2,16
 20232dc:	10009626 	beq	r2,zero,2023538 <tcp_process+0x480>
 20232e0:	d0a7ed03 	ldbu	r2,-24652(gp)
 20232e4:	10803fcc 	andi	r2,r2,255
 20232e8:	1080008c 	andi	r2,r2,2
 20232ec:	10009226 	beq	r2,zero,2023538 <tcp_process+0x480>
          && (ackno == pcb->lastack + 1)) {
 20232f0:	e0bffe17 	ldw	r2,-8(fp)
 20232f4:	10801317 	ldw	r2,76(r2)
 20232f8:	10c00044 	addi	r3,r2,1
 20232fc:	d0a7eb17 	ldw	r2,-24660(gp)
 2023300:	18808d1e 	bne	r3,r2,2023538 <tcp_process+0x480>
        pcb->rcv_nxt = seqno + 1;
 2023304:	d0a7ea17 	ldw	r2,-24664(gp)
 2023308:	10c00044 	addi	r3,r2,1
 202330c:	e0bffe17 	ldw	r2,-8(fp)
 2023310:	10c00b15 	stw	r3,44(r2)
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 2023314:	e0bffe17 	ldw	r2,-8(fp)
 2023318:	10c00b17 	ldw	r3,44(r2)
 202331c:	e0bffe17 	ldw	r2,-8(fp)
 2023320:	10c00d15 	stw	r3,52(r2)
        pcb->lastack = ackno;
 2023324:	d0e7eb17 	ldw	r3,-24660(gp)
 2023328:	e0bffe17 	ldw	r2,-8(fp)
 202332c:	10c01315 	stw	r3,76(r2)
        pcb->snd_wnd = tcphdr->wnd;
 2023330:	d0a7e617 	ldw	r2,-24680(gp)
 2023334:	10c00383 	ldbu	r3,14(r2)
 2023338:	108003c3 	ldbu	r2,15(r2)
 202333c:	1004923a 	slli	r2,r2,8
 2023340:	10c4b03a 	or	r2,r2,r3
 2023344:	1007883a 	mov	r3,r2
 2023348:	e0bffe17 	ldw	r2,-8(fp)
 202334c:	10c01a0d 	sth	r3,104(r2)
        pcb->snd_wnd_max = pcb->snd_wnd;
 2023350:	e0bffe17 	ldw	r2,-8(fp)
 2023354:	10c01a0b 	ldhu	r3,104(r2)
 2023358:	e0bffe17 	ldw	r2,-8(fp)
 202335c:	10c01a8d 	sth	r3,106(r2)
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 2023360:	d0a7ea17 	ldw	r2,-24664(gp)
 2023364:	10ffffc4 	addi	r3,r2,-1
 2023368:	e0bffe17 	ldw	r2,-8(fp)
 202336c:	10c01715 	stw	r3,92(r2)
        pcb->state = ESTABLISHED;
 2023370:	e0bffe17 	ldw	r2,-8(fp)
 2023374:	00c00104 	movi	r3,4
 2023378:	10c00615 	stw	r3,24(r2)

#if TCP_CALCULATE_EFF_SEND_MSS
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 202337c:	e0bffe17 	ldw	r2,-8(fp)
 2023380:	10800e8b 	ldhu	r2,58(r2)
 2023384:	143fffcc 	andi	r16,r2,65535
 2023388:	e0bffe17 	ldw	r2,-8(fp)
 202338c:	10800104 	addi	r2,r2,4
 2023390:	1009883a 	mov	r4,r2
 2023394:	203b5c40 	call	203b5c4 <ip4_route>
 2023398:	1007883a 	mov	r3,r2
 202339c:	e0bffe17 	ldw	r2,-8(fp)
 20233a0:	10800104 	addi	r2,r2,4
 20233a4:	100d883a 	mov	r6,r2
 20233a8:	180b883a 	mov	r5,r3
 20233ac:	8009883a 	mov	r4,r16
 20233b0:	20219a40 	call	20219a4 <tcp_eff_send_mss_netif>
 20233b4:	1007883a 	mov	r3,r2
 20233b8:	e0bffe17 	ldw	r2,-8(fp)
 20233bc:	10c00e8d 	sth	r3,58(r2)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 20233c0:	e0bffe17 	ldw	r2,-8(fp)
 20233c4:	10800e8b 	ldhu	r2,58(r2)
 20233c8:	10bfffcc 	andi	r2,r2,65535
 20233cc:	1085883a 	add	r2,r2,r2
 20233d0:	1085883a 	add	r2,r2,r2
 20233d4:	1009883a 	mov	r4,r2
 20233d8:	e0bffe17 	ldw	r2,-8(fp)
 20233dc:	10800e8b 	ldhu	r2,58(r2)
 20233e0:	10bfffcc 	andi	r2,r2,65535
 20233e4:	1085883a 	add	r2,r2,r2
 20233e8:	10c44728 	cmpgeui	r3,r2,4380
 20233ec:	1800011e 	bne	r3,zero,20233f4 <tcp_process+0x33c>
 20233f0:	00844704 	movi	r2,4380
 20233f4:	2080052e 	bgeu	r4,r2,202340c <tcp_process+0x354>
 20233f8:	e0bffe17 	ldw	r2,-8(fp)
 20233fc:	10800e8b 	ldhu	r2,58(r2)
 2023400:	1085883a 	add	r2,r2,r2
 2023404:	1085883a 	add	r2,r2,r2
 2023408:	00000b06 	br	2023438 <tcp_process+0x380>
 202340c:	e0bffe17 	ldw	r2,-8(fp)
 2023410:	10800e8b 	ldhu	r2,58(r2)
 2023414:	10bfffcc 	andi	r2,r2,65535
 2023418:	1085883a 	add	r2,r2,r2
 202341c:	10844770 	cmpltui	r2,r2,4381
 2023420:	1000041e 	bne	r2,zero,2023434 <tcp_process+0x37c>
 2023424:	e0bffe17 	ldw	r2,-8(fp)
 2023428:	10800e8b 	ldhu	r2,58(r2)
 202342c:	1085883a 	add	r2,r2,r2
 2023430:	00000106 	br	2023438 <tcp_process+0x380>
 2023434:	00844704 	movi	r2,4380
 2023438:	e0fffe17 	ldw	r3,-8(fp)
 202343c:	1880140d 	sth	r2,80(r3)
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
        --pcb->snd_queuelen;
 2023440:	e0bffe17 	ldw	r2,-8(fp)
 2023444:	10801b8b 	ldhu	r2,110(r2)
 2023448:	10bfffc4 	addi	r2,r2,-1
 202344c:	1007883a 	mov	r3,r2
 2023450:	e0bffe17 	ldw	r2,-8(fp)
 2023454:	10c01b8d 	sth	r3,110(r2)
        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
        rseg = pcb->unacked;
 2023458:	e0bffe17 	ldw	r2,-8(fp)
 202345c:	10801e17 	ldw	r2,120(r2)
 2023460:	e0bff915 	stw	r2,-28(fp)
        if (rseg == NULL) {
 2023464:	e0bff917 	ldw	r2,-28(fp)
 2023468:	1000081e 	bne	r2,zero,202348c <tcp_process+0x3d4>
          /* might happen if tcp_output fails in tcp_rexmit_rto()
             in which case the segment is on the unsent list */
          rseg = pcb->unsent;
 202346c:	e0bffe17 	ldw	r2,-8(fp)
 2023470:	10801d17 	ldw	r2,116(r2)
 2023474:	e0bff915 	stw	r2,-28(fp)
          LWIP_ASSERT("no segment to free", rseg != NULL);
          pcb->unsent = rseg->next;
 2023478:	e0bff917 	ldw	r2,-28(fp)
 202347c:	10c00017 	ldw	r3,0(r2)
 2023480:	e0bffe17 	ldw	r2,-8(fp)
 2023484:	10c01d15 	stw	r3,116(r2)
 2023488:	00000406 	br	202349c <tcp_process+0x3e4>
        } else {
          pcb->unacked = rseg->next;
 202348c:	e0bff917 	ldw	r2,-28(fp)
 2023490:	10c00017 	ldw	r3,0(r2)
 2023494:	e0bffe17 	ldw	r2,-8(fp)
 2023498:	10c01e15 	stw	r3,120(r2)
        }
        tcp_seg_free(rseg);
 202349c:	e13ff917 	ldw	r4,-28(fp)
 20234a0:	2020ee00 	call	2020ee0 <tcp_seg_free>

        /* If there's nothing left to acknowledge, stop the retransmit
           timer, otherwise reset it to start again */
        if (pcb->unacked == NULL) {
 20234a4:	e0bffe17 	ldw	r2,-8(fp)
 20234a8:	10801e17 	ldw	r2,120(r2)
 20234ac:	1000041e 	bne	r2,zero,20234c0 <tcp_process+0x408>
          pcb->rtime = -1;
 20234b0:	e0bffe17 	ldw	r2,-8(fp)
 20234b4:	00ffffc4 	movi	r3,-1
 20234b8:	10c00e0d 	sth	r3,56(r2)
 20234bc:	00000406 	br	20234d0 <tcp_process+0x418>
        } else {
          pcb->rtime = 0;
 20234c0:	e0bffe17 	ldw	r2,-8(fp)
 20234c4:	10000e0d 	sth	zero,56(r2)
          pcb->nrtx = 0;
 20234c8:	e0bffe17 	ldw	r2,-8(fp)
 20234cc:	10001285 	stb	zero,74(r2)
        }

        /* Call the user specified function to call when successfully
         * connected. */
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 20234d0:	e0bffe17 	ldw	r2,-8(fp)
 20234d4:	10802417 	ldw	r2,144(r2)
 20234d8:	10000a26 	beq	r2,zero,2023504 <tcp_process+0x44c>
 20234dc:	e0bffe17 	ldw	r2,-8(fp)
 20234e0:	10802417 	ldw	r2,144(r2)
 20234e4:	e0fffe17 	ldw	r3,-8(fp)
 20234e8:	18c00517 	ldw	r3,20(r3)
 20234ec:	000d883a 	mov	r6,zero
 20234f0:	e17ffe17 	ldw	r5,-8(fp)
 20234f4:	1809883a 	mov	r4,r3
 20234f8:	103ee83a 	callr	r2
 20234fc:	e0bffa45 	stb	r2,-23(fp)
 2023500:	00000106 	br	2023508 <tcp_process+0x450>
 2023504:	e03ffa45 	stb	zero,-23(fp)
        if (err == ERR_ABRT) {
 2023508:	e0bffa47 	ldb	r2,-23(fp)
 202350c:	10bffcd8 	cmpnei	r2,r2,-13
 2023510:	1000021e 	bne	r2,zero,202351c <tcp_process+0x464>
          return ERR_ABRT;
 2023514:	00bffcc4 	movi	r2,-13
 2023518:	0001b306 	br	2023be8 <tcp_process+0xb30>
        }
        tcp_ack_now(pcb);
 202351c:	e0bffe17 	ldw	r2,-8(fp)
 2023520:	1080088b 	ldhu	r2,34(r2)
 2023524:	10800094 	ori	r2,r2,2
 2023528:	1007883a 	mov	r3,r2
 202352c:	e0bffe17 	ldw	r2,-8(fp)
 2023530:	10c0088d 	sth	r3,34(r2)
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
 2023534:	00019e06 	br	2023bb0 <tcp_process+0xaf8>
          return ERR_ABRT;
        }
        tcp_ack_now(pcb);
      }
      /* received ACK? possibly a half-open connection */
      else if (flags & TCP_ACK) {
 2023538:	d0a7ed03 	ldbu	r2,-24652(gp)
 202353c:	10803fcc 	andi	r2,r2,255
 2023540:	1080040c 	andi	r2,r2,16
 2023544:	10019a26 	beq	r2,zero,2023bb0 <tcp_process+0xaf8>
        /* send a RST to bring the other side in a non-synchronized state. */
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 2023548:	d167eb17 	ldw	r5,-24660(gp)
 202354c:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2023550:	10ffffcc 	andi	r3,r2,65535
 2023554:	d0a7ea17 	ldw	r2,-24664(gp)
 2023558:	188d883a 	add	r6,r3,r2
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 202355c:	d0a7e617 	ldw	r2,-24680(gp)
 2023560:	10c00083 	ldbu	r3,2(r2)
 2023564:	108000c3 	ldbu	r2,3(r2)
 2023568:	1004923a 	slli	r2,r2,8
 202356c:	10c4b03a 	or	r2,r2,r3
        tcp_ack_now(pcb);
      }
      /* received ACK? possibly a half-open connection */
      else if (flags & TCP_ACK) {
        /* send a RST to bring the other side in a non-synchronized state. */
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 2023570:	10ffffcc 	andi	r3,r2,65535
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2023574:	d0a7e617 	ldw	r2,-24680(gp)
 2023578:	11000003 	ldbu	r4,0(r2)
 202357c:	10800043 	ldbu	r2,1(r2)
 2023580:	1004923a 	slli	r2,r2,8
 2023584:	1104b03a 	or	r2,r2,r4
        tcp_ack_now(pcb);
      }
      /* received ACK? possibly a half-open connection */
      else if (flags & TCP_ACK) {
        /* send a RST to bring the other side in a non-synchronized state. */
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 2023588:	10bfffcc 	andi	r2,r2,65535
 202358c:	d8800215 	stw	r2,8(sp)
 2023590:	d8c00115 	stw	r3,4(sp)
 2023594:	008085f4 	movhi	r2,535
 2023598:	10be4604 	addi	r2,r2,-1768
 202359c:	d8800015 	stw	r2,0(sp)
 20235a0:	01c085f4 	movhi	r7,535
 20235a4:	39fe4704 	addi	r7,r7,-1764
 20235a8:	e13ffe17 	ldw	r4,-8(fp)
 20235ac:	2028cf40 	call	2028cf4 <tcp_rst>
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
        /* Resend SYN immediately (don't wait for rto timeout) to establish
          connection faster, but do not send more SYNs than we otherwise would
          have, or we might get caught in a loop on loopback interfaces. */
        if (pcb->nrtx < TCP_SYNMAXRTX) {
 20235b0:	e0bffe17 	ldw	r2,-8(fp)
 20235b4:	10801283 	ldbu	r2,74(r2)
 20235b8:	10803fcc 	andi	r2,r2,255
 20235bc:	108001a8 	cmpgeui	r2,r2,6
 20235c0:	10017b1e 	bne	r2,zero,2023bb0 <tcp_process+0xaf8>
          pcb->rtime = 0;
 20235c4:	e0bffe17 	ldw	r2,-8(fp)
 20235c8:	10000e0d 	sth	zero,56(r2)
          tcp_rexmit_rto(pcb);
 20235cc:	e13ffe17 	ldw	r4,-8(fp)
 20235d0:	20284080 	call	2028408 <tcp_rexmit_rto>
        }
      }
      break;
 20235d4:	00017606 	br	2023bb0 <tcp_process+0xaf8>
    case SYN_RCVD:
      if (flags & TCP_SYN) {
 20235d8:	d0a7ed03 	ldbu	r2,-24652(gp)
 20235dc:	10803fcc 	andi	r2,r2,255
 20235e0:	1080008c 	andi	r2,r2,2
 20235e4:	10000826 	beq	r2,zero,2023608 <tcp_process+0x550>
        if (seqno == pcb->rcv_nxt - 1) {
 20235e8:	e0bffe17 	ldw	r2,-8(fp)
 20235ec:	10800b17 	ldw	r2,44(r2)
 20235f0:	10ffffc4 	addi	r3,r2,-1
 20235f4:	d0a7ea17 	ldw	r2,-24664(gp)
 20235f8:	18816f1e 	bne	r3,r2,2023bb8 <tcp_process+0xb00>
          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
          tcp_rexmit(pcb);
 20235fc:	e13ffe17 	ldw	r4,-8(fp)
 2023600:	20284540 	call	2028454 <tcp_rexmit>
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
        }
      }
      break;
 2023604:	00016c06 	br	2023bb8 <tcp_process+0xb00>
      if (flags & TCP_SYN) {
        if (seqno == pcb->rcv_nxt - 1) {
          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
          tcp_rexmit(pcb);
        }
      } else if (flags & TCP_ACK) {
 2023608:	d0a7ed03 	ldbu	r2,-24652(gp)
 202360c:	10803fcc 	andi	r2,r2,255
 2023610:	1080040c 	andi	r2,r2,16
 2023614:	10016826 	beq	r2,zero,2023bb8 <tcp_process+0xb00>
        /* expected ACK number? */
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 2023618:	d0e7eb17 	ldw	r3,-24660(gp)
 202361c:	e0bffe17 	ldw	r2,-8(fp)
 2023620:	10801317 	ldw	r2,76(r2)
 2023624:	1885c83a 	sub	r2,r3,r2
 2023628:	10bfffc4 	addi	r2,r2,-1
 202362c:	10006016 	blt	r2,zero,20237b0 <tcp_process+0x6f8>
 2023630:	d0e7eb17 	ldw	r3,-24660(gp)
 2023634:	e0bffe17 	ldw	r2,-8(fp)
 2023638:	10801617 	ldw	r2,88(r2)
 202363c:	1885c83a 	sub	r2,r3,r2
 2023640:	00805b16 	blt	zero,r2,20237b0 <tcp_process+0x6f8>
          pcb->state = ESTABLISHED;
 2023644:	e0bffe17 	ldw	r2,-8(fp)
 2023648:	00c00104 	movi	r3,4
 202364c:	10c00615 	stw	r3,24(r2)
          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
          if (pcb->listener == NULL) {
 2023650:	e0bffe17 	ldw	r2,-8(fp)
 2023654:	10802117 	ldw	r2,132(r2)
 2023658:	1000031e 	bne	r2,zero,2023668 <tcp_process+0x5b0>
            /* listen pcb might be closed by now */
            err = ERR_VAL;
 202365c:	00bffe84 	movi	r2,-6
 2023660:	e0bffa45 	stb	r2,-23(fp)
 2023664:	00001306 	br	20236b4 <tcp_process+0x5fc>
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
          {
#if LWIP_CALLBACK_API
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
#endif
            tcp_backlog_accepted(pcb);
 2023668:	e13ffe17 	ldw	r4,-8(fp)
 202366c:	201efa80 	call	201efa8 <tcp_backlog_accepted>
            /* Call the accept function. */
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 2023670:	e0bffe17 	ldw	r2,-8(fp)
 2023674:	10802117 	ldw	r2,132(r2)
 2023678:	10800817 	ldw	r2,32(r2)
 202367c:	10000b26 	beq	r2,zero,20236ac <tcp_process+0x5f4>
 2023680:	e0bffe17 	ldw	r2,-8(fp)
 2023684:	10802117 	ldw	r2,132(r2)
 2023688:	10800817 	ldw	r2,32(r2)
 202368c:	e0fffe17 	ldw	r3,-8(fp)
 2023690:	18c00517 	ldw	r3,20(r3)
 2023694:	000d883a 	mov	r6,zero
 2023698:	e17ffe17 	ldw	r5,-8(fp)
 202369c:	1809883a 	mov	r4,r3
 20236a0:	103ee83a 	callr	r2
 20236a4:	e0bffa45 	stb	r2,-23(fp)
 20236a8:	00000206 	br	20236b4 <tcp_process+0x5fc>
 20236ac:	00bffc04 	movi	r2,-16
 20236b0:	e0bffa45 	stb	r2,-23(fp)
          }
          if (err != ERR_OK) {
 20236b4:	e0bffa47 	ldb	r2,-23(fp)
 20236b8:	10000726 	beq	r2,zero,20236d8 <tcp_process+0x620>
            /* If the accept function returns with an error, we abort
             * the connection. */
            /* Already aborted? */
            if (err != ERR_ABRT) {
 20236bc:	e0bffa47 	ldb	r2,-23(fp)
 20236c0:	10bffce0 	cmpeqi	r2,r2,-13
 20236c4:	1000021e 	bne	r2,zero,20236d0 <tcp_process+0x618>
              tcp_abort(pcb);
 20236c8:	e13ffe17 	ldw	r4,-8(fp)
 20236cc:	201f70c0 	call	201f70c <tcp_abort>
            }
            return ERR_ABRT;
 20236d0:	00bffcc4 	movi	r2,-13
 20236d4:	00014406 	br	2023be8 <tcp_process+0xb30>
          }
          /* If there was any data contained within this ACK,
           * we'd better pass it on to the application as well. */
          tcp_receive(pcb);
 20236d8:	e13ffe17 	ldw	r4,-8(fp)
 20236dc:	2023fc00 	call	2023fc0 <tcp_receive>

          /* Prevent ACK for SYN to generate a sent event */
          if (recv_acked != 0) {
 20236e0:	d0a7ec0b 	ldhu	r2,-24656(gp)
 20236e4:	10bfffcc 	andi	r2,r2,65535
 20236e8:	10000326 	beq	r2,zero,20236f8 <tcp_process+0x640>
            recv_acked--;
 20236ec:	d0a7ec0b 	ldhu	r2,-24656(gp)
 20236f0:	10bfffc4 	addi	r2,r2,-1
 20236f4:	d0a7ec0d 	sth	r2,-24656(gp)
          }

          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 20236f8:	e0bffe17 	ldw	r2,-8(fp)
 20236fc:	10800e8b 	ldhu	r2,58(r2)
 2023700:	10bfffcc 	andi	r2,r2,65535
 2023704:	1085883a 	add	r2,r2,r2
 2023708:	1085883a 	add	r2,r2,r2
 202370c:	1009883a 	mov	r4,r2
 2023710:	e0bffe17 	ldw	r2,-8(fp)
 2023714:	10800e8b 	ldhu	r2,58(r2)
 2023718:	10bfffcc 	andi	r2,r2,65535
 202371c:	1085883a 	add	r2,r2,r2
 2023720:	10c44728 	cmpgeui	r3,r2,4380
 2023724:	1800011e 	bne	r3,zero,202372c <tcp_process+0x674>
 2023728:	00844704 	movi	r2,4380
 202372c:	2080052e 	bgeu	r4,r2,2023744 <tcp_process+0x68c>
 2023730:	e0bffe17 	ldw	r2,-8(fp)
 2023734:	10800e8b 	ldhu	r2,58(r2)
 2023738:	1085883a 	add	r2,r2,r2
 202373c:	1085883a 	add	r2,r2,r2
 2023740:	00000b06 	br	2023770 <tcp_process+0x6b8>
 2023744:	e0bffe17 	ldw	r2,-8(fp)
 2023748:	10800e8b 	ldhu	r2,58(r2)
 202374c:	10bfffcc 	andi	r2,r2,65535
 2023750:	1085883a 	add	r2,r2,r2
 2023754:	10844770 	cmpltui	r2,r2,4381
 2023758:	1000041e 	bne	r2,zero,202376c <tcp_process+0x6b4>
 202375c:	e0bffe17 	ldw	r2,-8(fp)
 2023760:	10800e8b 	ldhu	r2,58(r2)
 2023764:	1085883a 	add	r2,r2,r2
 2023768:	00000106 	br	2023770 <tcp_process+0x6b8>
 202376c:	00844704 	movi	r2,4380
 2023770:	e0fffe17 	ldw	r3,-8(fp)
 2023774:	1880140d 	sth	r2,80(r3)
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
 2023778:	d0a7ed43 	ldbu	r2,-24651(gp)
 202377c:	10803fcc 	andi	r2,r2,255
 2023780:	1080080c 	andi	r2,r2,32
 2023784:	10002526 	beq	r2,zero,202381c <tcp_process+0x764>
            tcp_ack_now(pcb);
 2023788:	e0bffe17 	ldw	r2,-8(fp)
 202378c:	1080088b 	ldhu	r2,34(r2)
 2023790:	10800094 	ori	r2,r2,2
 2023794:	1007883a 	mov	r3,r2
 2023798:	e0bffe17 	ldw	r2,-8(fp)
 202379c:	10c0088d 	sth	r3,34(r2)
            pcb->state = CLOSE_WAIT;
 20237a0:	e0bffe17 	ldw	r2,-8(fp)
 20237a4:	00c001c4 	movi	r3,7
 20237a8:	10c00615 	stw	r3,24(r2)
          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
 20237ac:	00001b06 	br	202381c <tcp_process+0x764>
            tcp_ack_now(pcb);
            pcb->state = CLOSE_WAIT;
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 20237b0:	d167eb17 	ldw	r5,-24660(gp)
 20237b4:	d0a7ec8b 	ldhu	r2,-24654(gp)
 20237b8:	10ffffcc 	andi	r3,r2,65535
 20237bc:	d0a7ea17 	ldw	r2,-24664(gp)
 20237c0:	188d883a 	add	r6,r3,r2
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 20237c4:	d0a7e617 	ldw	r2,-24680(gp)
 20237c8:	10c00083 	ldbu	r3,2(r2)
 20237cc:	108000c3 	ldbu	r2,3(r2)
 20237d0:	1004923a 	slli	r2,r2,8
 20237d4:	10c4b03a 	or	r2,r2,r3
            tcp_ack_now(pcb);
            pcb->state = CLOSE_WAIT;
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 20237d8:	10ffffcc 	andi	r3,r2,65535
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 20237dc:	d0a7e617 	ldw	r2,-24680(gp)
 20237e0:	11000003 	ldbu	r4,0(r2)
 20237e4:	10800043 	ldbu	r2,1(r2)
 20237e8:	1004923a 	slli	r2,r2,8
 20237ec:	1104b03a 	or	r2,r2,r4
            tcp_ack_now(pcb);
            pcb->state = CLOSE_WAIT;
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 20237f0:	10bfffcc 	andi	r2,r2,65535
 20237f4:	d8800215 	stw	r2,8(sp)
 20237f8:	d8c00115 	stw	r3,4(sp)
 20237fc:	008085f4 	movhi	r2,535
 2023800:	10be4604 	addi	r2,r2,-1768
 2023804:	d8800015 	stw	r2,0(sp)
 2023808:	01c085f4 	movhi	r7,535
 202380c:	39fe4704 	addi	r7,r7,-1764
 2023810:	e13ffe17 	ldw	r4,-8(fp)
 2023814:	2028cf40 	call	2028cf4 <tcp_rst>
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
        }
      }
      break;
 2023818:	0000e706 	br	2023bb8 <tcp_process+0xb00>
 202381c:	0000e606 	br	2023bb8 <tcp_process+0xb00>
    case CLOSE_WAIT:
    /* FALLTHROUGH */
    case ESTABLISHED:
      tcp_receive(pcb);
 2023820:	e13ffe17 	ldw	r4,-8(fp)
 2023824:	2023fc00 	call	2023fc0 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) { /* passive close */
 2023828:	d0a7ed43 	ldbu	r2,-24651(gp)
 202382c:	10803fcc 	andi	r2,r2,255
 2023830:	1080080c 	andi	r2,r2,32
 2023834:	1000e226 	beq	r2,zero,2023bc0 <tcp_process+0xb08>
        tcp_ack_now(pcb);
 2023838:	e0bffe17 	ldw	r2,-8(fp)
 202383c:	1080088b 	ldhu	r2,34(r2)
 2023840:	10800094 	ori	r2,r2,2
 2023844:	1007883a 	mov	r3,r2
 2023848:	e0bffe17 	ldw	r2,-8(fp)
 202384c:	10c0088d 	sth	r3,34(r2)
        pcb->state = CLOSE_WAIT;
 2023850:	e0bffe17 	ldw	r2,-8(fp)
 2023854:	00c001c4 	movi	r3,7
 2023858:	10c00615 	stw	r3,24(r2)
      }
      break;
 202385c:	0000d806 	br	2023bc0 <tcp_process+0xb08>
    case FIN_WAIT_1:
      tcp_receive(pcb);
 2023860:	e13ffe17 	ldw	r4,-8(fp)
 2023864:	2023fc00 	call	2023fc0 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 2023868:	d0a7ed43 	ldbu	r2,-24651(gp)
 202386c:	10803fcc 	andi	r2,r2,255
 2023870:	1080080c 	andi	r2,r2,32
 2023874:	10004326 	beq	r2,zero,2023984 <tcp_process+0x8cc>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 2023878:	d0a7ed03 	ldbu	r2,-24652(gp)
 202387c:	10803fcc 	andi	r2,r2,255
 2023880:	1080040c 	andi	r2,r2,16
 2023884:	10003526 	beq	r2,zero,202395c <tcp_process+0x8a4>
 2023888:	e0bffe17 	ldw	r2,-8(fp)
 202388c:	10c01617 	ldw	r3,88(r2)
 2023890:	d0a7eb17 	ldw	r2,-24660(gp)
 2023894:	1880311e 	bne	r3,r2,202395c <tcp_process+0x8a4>
            pcb->unsent == NULL) {
 2023898:	e0bffe17 	ldw	r2,-8(fp)
 202389c:	10801d17 	ldw	r2,116(r2)
      }
      break;
    case FIN_WAIT_1:
      tcp_receive(pcb);
      if (recv_flags & TF_GOT_FIN) {
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 20238a0:	10002e1e 	bne	r2,zero,202395c <tcp_process+0x8a4>
            pcb->unsent == NULL) {
          LWIP_DEBUGF(TCP_DEBUG,
                      ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
          tcp_ack_now(pcb);
 20238a4:	e0bffe17 	ldw	r2,-8(fp)
 20238a8:	1080088b 	ldhu	r2,34(r2)
 20238ac:	10800094 	ori	r2,r2,2
 20238b0:	1007883a 	mov	r3,r2
 20238b4:	e0bffe17 	ldw	r2,-8(fp)
 20238b8:	10c0088d 	sth	r3,34(r2)
          tcp_pcb_purge(pcb);
 20238bc:	e13ffe17 	ldw	r4,-8(fp)
 20238c0:	202176c0 	call	202176c <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
 20238c4:	d0e7e117 	ldw	r3,-24700(gp)
 20238c8:	e0bffe17 	ldw	r2,-8(fp)
 20238cc:	1880041e 	bne	r3,r2,20238e0 <tcp_process+0x828>
 20238d0:	d0a7e117 	ldw	r2,-24700(gp)
 20238d4:	10800417 	ldw	r2,16(r2)
 20238d8:	d0a7e115 	stw	r2,-24700(gp)
 20238dc:	00001106 	br	2023924 <tcp_process+0x86c>
 20238e0:	d0a7e117 	ldw	r2,-24700(gp)
 20238e4:	e0bffb15 	stw	r2,-20(fp)
 20238e8:	00000c06 	br	202391c <tcp_process+0x864>
 20238ec:	e0bffb17 	ldw	r2,-20(fp)
 20238f0:	10c00417 	ldw	r3,16(r2)
 20238f4:	e0bffe17 	ldw	r2,-8(fp)
 20238f8:	1880051e 	bne	r3,r2,2023910 <tcp_process+0x858>
 20238fc:	e0bffe17 	ldw	r2,-8(fp)
 2023900:	10c00417 	ldw	r3,16(r2)
 2023904:	e0bffb17 	ldw	r2,-20(fp)
 2023908:	10c00415 	stw	r3,16(r2)
 202390c:	00000506 	br	2023924 <tcp_process+0x86c>
 2023910:	e0bffb17 	ldw	r2,-20(fp)
 2023914:	10800417 	ldw	r2,16(r2)
 2023918:	e0bffb15 	stw	r2,-20(fp)
 202391c:	e0bffb17 	ldw	r2,-20(fp)
 2023920:	103ff21e 	bne	r2,zero,20238ec <__alt_mem_mem_0+0xfd0038ec>
 2023924:	e0bffe17 	ldw	r2,-8(fp)
 2023928:	10000415 	stw	zero,16(r2)
 202392c:	00800044 	movi	r2,1
 2023930:	d0a7e085 	stb	r2,-24702(gp)
          pcb->state = TIME_WAIT;
 2023934:	e0bffe17 	ldw	r2,-8(fp)
 2023938:	00c00284 	movi	r3,10
 202393c:	10c00615 	stw	r3,24(r2)
          TCP_REG(&tcp_tw_pcbs, pcb);
 2023940:	d0e7e517 	ldw	r3,-24684(gp)
 2023944:	e0bffe17 	ldw	r2,-8(fp)
 2023948:	10c00415 	stw	r3,16(r2)
 202394c:	e0bffe17 	ldw	r2,-8(fp)
 2023950:	d0a7e515 	stw	r2,-24684(gp)
 2023954:	20292b80 	call	20292b8 <tcp_timer_needed>
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
 2023958:	00009b06 	br	2023bc8 <tcp_process+0xb10>
          tcp_pcb_purge(pcb);
          TCP_RMV_ACTIVE(pcb);
          pcb->state = TIME_WAIT;
          TCP_REG(&tcp_tw_pcbs, pcb);
        } else {
          tcp_ack_now(pcb);
 202395c:	e0bffe17 	ldw	r2,-8(fp)
 2023960:	1080088b 	ldhu	r2,34(r2)
 2023964:	10800094 	ori	r2,r2,2
 2023968:	1007883a 	mov	r3,r2
 202396c:	e0bffe17 	ldw	r2,-8(fp)
 2023970:	10c0088d 	sth	r3,34(r2)
          pcb->state = CLOSING;
 2023974:	e0bffe17 	ldw	r2,-8(fp)
 2023978:	00c00204 	movi	r3,8
 202397c:	10c00615 	stw	r3,24(r2)
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
 2023980:	00009106 	br	2023bc8 <tcp_process+0xb10>
          TCP_REG(&tcp_tw_pcbs, pcb);
        } else {
          tcp_ack_now(pcb);
          pcb->state = CLOSING;
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 2023984:	d0a7ed03 	ldbu	r2,-24652(gp)
 2023988:	10803fcc 	andi	r2,r2,255
 202398c:	1080040c 	andi	r2,r2,16
 2023990:	10008d26 	beq	r2,zero,2023bc8 <tcp_process+0xb10>
 2023994:	e0bffe17 	ldw	r2,-8(fp)
 2023998:	10c01617 	ldw	r3,88(r2)
 202399c:	d0a7eb17 	ldw	r2,-24660(gp)
 20239a0:	1880891e 	bne	r3,r2,2023bc8 <tcp_process+0xb10>
                 pcb->unsent == NULL) {
 20239a4:	e0bffe17 	ldw	r2,-8(fp)
 20239a8:	10801d17 	ldw	r2,116(r2)
          TCP_REG(&tcp_tw_pcbs, pcb);
        } else {
          tcp_ack_now(pcb);
          pcb->state = CLOSING;
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 20239ac:	1000861e 	bne	r2,zero,2023bc8 <tcp_process+0xb10>
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
 20239b0:	e0bffe17 	ldw	r2,-8(fp)
 20239b4:	00c00184 	movi	r3,6
 20239b8:	10c00615 	stw	r3,24(r2)
      }
      break;
 20239bc:	00008206 	br	2023bc8 <tcp_process+0xb10>
    case FIN_WAIT_2:
      tcp_receive(pcb);
 20239c0:	e13ffe17 	ldw	r4,-8(fp)
 20239c4:	2023fc00 	call	2023fc0 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 20239c8:	d0a7ed43 	ldbu	r2,-24651(gp)
 20239cc:	10803fcc 	andi	r2,r2,255
 20239d0:	1080080c 	andi	r2,r2,32
 20239d4:	10007e26 	beq	r2,zero,2023bd0 <tcp_process+0xb18>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 20239d8:	e0bffe17 	ldw	r2,-8(fp)
 20239dc:	1080088b 	ldhu	r2,34(r2)
 20239e0:	10800094 	ori	r2,r2,2
 20239e4:	1007883a 	mov	r3,r2
 20239e8:	e0bffe17 	ldw	r2,-8(fp)
 20239ec:	10c0088d 	sth	r3,34(r2)
        tcp_pcb_purge(pcb);
 20239f0:	e13ffe17 	ldw	r4,-8(fp)
 20239f4:	202176c0 	call	202176c <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 20239f8:	d0e7e117 	ldw	r3,-24700(gp)
 20239fc:	e0bffe17 	ldw	r2,-8(fp)
 2023a00:	1880041e 	bne	r3,r2,2023a14 <tcp_process+0x95c>
 2023a04:	d0a7e117 	ldw	r2,-24700(gp)
 2023a08:	10800417 	ldw	r2,16(r2)
 2023a0c:	d0a7e115 	stw	r2,-24700(gp)
 2023a10:	00001106 	br	2023a58 <tcp_process+0x9a0>
 2023a14:	d0a7e117 	ldw	r2,-24700(gp)
 2023a18:	e0bffc15 	stw	r2,-16(fp)
 2023a1c:	00000c06 	br	2023a50 <tcp_process+0x998>
 2023a20:	e0bffc17 	ldw	r2,-16(fp)
 2023a24:	10c00417 	ldw	r3,16(r2)
 2023a28:	e0bffe17 	ldw	r2,-8(fp)
 2023a2c:	1880051e 	bne	r3,r2,2023a44 <tcp_process+0x98c>
 2023a30:	e0bffe17 	ldw	r2,-8(fp)
 2023a34:	10c00417 	ldw	r3,16(r2)
 2023a38:	e0bffc17 	ldw	r2,-16(fp)
 2023a3c:	10c00415 	stw	r3,16(r2)
 2023a40:	00000506 	br	2023a58 <tcp_process+0x9a0>
 2023a44:	e0bffc17 	ldw	r2,-16(fp)
 2023a48:	10800417 	ldw	r2,16(r2)
 2023a4c:	e0bffc15 	stw	r2,-16(fp)
 2023a50:	e0bffc17 	ldw	r2,-16(fp)
 2023a54:	103ff21e 	bne	r2,zero,2023a20 <__alt_mem_mem_0+0xfd003a20>
 2023a58:	e0bffe17 	ldw	r2,-8(fp)
 2023a5c:	10000415 	stw	zero,16(r2)
 2023a60:	00800044 	movi	r2,1
 2023a64:	d0a7e085 	stb	r2,-24702(gp)
        pcb->state = TIME_WAIT;
 2023a68:	e0bffe17 	ldw	r2,-8(fp)
 2023a6c:	00c00284 	movi	r3,10
 2023a70:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
 2023a74:	d0e7e517 	ldw	r3,-24684(gp)
 2023a78:	e0bffe17 	ldw	r2,-8(fp)
 2023a7c:	10c00415 	stw	r3,16(r2)
 2023a80:	e0bffe17 	ldw	r2,-8(fp)
 2023a84:	d0a7e515 	stw	r2,-24684(gp)
 2023a88:	20292b80 	call	20292b8 <tcp_timer_needed>
      }
      break;
 2023a8c:	00005006 	br	2023bd0 <tcp_process+0xb18>
    case CLOSING:
      tcp_receive(pcb);
 2023a90:	e13ffe17 	ldw	r4,-8(fp)
 2023a94:	2023fc00 	call	2023fc0 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 2023a98:	d0a7ed03 	ldbu	r2,-24652(gp)
 2023a9c:	10803fcc 	andi	r2,r2,255
 2023aa0:	1080040c 	andi	r2,r2,16
 2023aa4:	10004c26 	beq	r2,zero,2023bd8 <tcp_process+0xb20>
 2023aa8:	e0bffe17 	ldw	r2,-8(fp)
 2023aac:	10c01617 	ldw	r3,88(r2)
 2023ab0:	d0a7eb17 	ldw	r2,-24660(gp)
 2023ab4:	1880481e 	bne	r3,r2,2023bd8 <tcp_process+0xb20>
 2023ab8:	e0bffe17 	ldw	r2,-8(fp)
 2023abc:	10801d17 	ldw	r2,116(r2)
 2023ac0:	1000451e 	bne	r2,zero,2023bd8 <tcp_process+0xb20>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_pcb_purge(pcb);
 2023ac4:	e13ffe17 	ldw	r4,-8(fp)
 2023ac8:	202176c0 	call	202176c <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 2023acc:	d0e7e117 	ldw	r3,-24700(gp)
 2023ad0:	e0bffe17 	ldw	r2,-8(fp)
 2023ad4:	1880041e 	bne	r3,r2,2023ae8 <tcp_process+0xa30>
 2023ad8:	d0a7e117 	ldw	r2,-24700(gp)
 2023adc:	10800417 	ldw	r2,16(r2)
 2023ae0:	d0a7e115 	stw	r2,-24700(gp)
 2023ae4:	00001106 	br	2023b2c <tcp_process+0xa74>
 2023ae8:	d0a7e117 	ldw	r2,-24700(gp)
 2023aec:	e0bffd15 	stw	r2,-12(fp)
 2023af0:	00000c06 	br	2023b24 <tcp_process+0xa6c>
 2023af4:	e0bffd17 	ldw	r2,-12(fp)
 2023af8:	10c00417 	ldw	r3,16(r2)
 2023afc:	e0bffe17 	ldw	r2,-8(fp)
 2023b00:	1880051e 	bne	r3,r2,2023b18 <tcp_process+0xa60>
 2023b04:	e0bffe17 	ldw	r2,-8(fp)
 2023b08:	10c00417 	ldw	r3,16(r2)
 2023b0c:	e0bffd17 	ldw	r2,-12(fp)
 2023b10:	10c00415 	stw	r3,16(r2)
 2023b14:	00000506 	br	2023b2c <tcp_process+0xa74>
 2023b18:	e0bffd17 	ldw	r2,-12(fp)
 2023b1c:	10800417 	ldw	r2,16(r2)
 2023b20:	e0bffd15 	stw	r2,-12(fp)
 2023b24:	e0bffd17 	ldw	r2,-12(fp)
 2023b28:	103ff21e 	bne	r2,zero,2023af4 <__alt_mem_mem_0+0xfd003af4>
 2023b2c:	e0bffe17 	ldw	r2,-8(fp)
 2023b30:	10000415 	stw	zero,16(r2)
 2023b34:	00800044 	movi	r2,1
 2023b38:	d0a7e085 	stb	r2,-24702(gp)
        pcb->state = TIME_WAIT;
 2023b3c:	e0bffe17 	ldw	r2,-8(fp)
 2023b40:	00c00284 	movi	r3,10
 2023b44:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
 2023b48:	d0e7e517 	ldw	r3,-24684(gp)
 2023b4c:	e0bffe17 	ldw	r2,-8(fp)
 2023b50:	10c00415 	stw	r3,16(r2)
 2023b54:	e0bffe17 	ldw	r2,-8(fp)
 2023b58:	d0a7e515 	stw	r2,-24684(gp)
 2023b5c:	20292b80 	call	20292b8 <tcp_timer_needed>
      }
      break;
 2023b60:	00001d06 	br	2023bd8 <tcp_process+0xb20>
    case LAST_ACK:
      tcp_receive(pcb);
 2023b64:	e13ffe17 	ldw	r4,-8(fp)
 2023b68:	2023fc00 	call	2023fc0 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 2023b6c:	d0a7ed03 	ldbu	r2,-24652(gp)
 2023b70:	10803fcc 	andi	r2,r2,255
 2023b74:	1080040c 	andi	r2,r2,16
 2023b78:	10001926 	beq	r2,zero,2023be0 <tcp_process+0xb28>
 2023b7c:	e0bffe17 	ldw	r2,-8(fp)
 2023b80:	10c01617 	ldw	r3,88(r2)
 2023b84:	d0a7eb17 	ldw	r2,-24660(gp)
 2023b88:	1880151e 	bne	r3,r2,2023be0 <tcp_process+0xb28>
 2023b8c:	e0bffe17 	ldw	r2,-8(fp)
 2023b90:	10801d17 	ldw	r2,116(r2)
 2023b94:	1000121e 	bne	r2,zero,2023be0 <tcp_process+0xb28>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
 2023b98:	d0a7ed43 	ldbu	r2,-24651(gp)
 2023b9c:	10800414 	ori	r2,r2,16
 2023ba0:	d0a7ed45 	stb	r2,-24651(gp)
      }
      break;
 2023ba4:	00000e06 	br	2023be0 <tcp_process+0xb28>
    default:
      break;
 2023ba8:	0001883a 	nop
 2023bac:	00000d06 	br	2023be4 <tcp_process+0xb2c>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
 2023bb0:	0001883a 	nop
 2023bb4:	00000b06 	br	2023be4 <tcp_process+0xb2c>
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
        }
      }
      break;
 2023bb8:	0001883a 	nop
 2023bbc:	00000906 	br	2023be4 <tcp_process+0xb2c>
      tcp_receive(pcb);
      if (recv_flags & TF_GOT_FIN) { /* passive close */
        tcp_ack_now(pcb);
        pcb->state = CLOSE_WAIT;
      }
      break;
 2023bc0:	0001883a 	nop
 2023bc4:	00000706 	br	2023be4 <tcp_process+0xb2c>
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
 2023bc8:	0001883a 	nop
 2023bcc:	00000506 	br	2023be4 <tcp_process+0xb2c>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      }
      break;
 2023bd0:	0001883a 	nop
 2023bd4:	00000306 	br	2023be4 <tcp_process+0xb2c>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      }
      break;
 2023bd8:	0001883a 	nop
 2023bdc:	00000106 	br	2023be4 <tcp_process+0xb2c>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
      }
      break;
 2023be0:	0001883a 	nop
    default:
      break;
  }
  return ERR_OK;
 2023be4:	0005883a 	mov	r2,zero
}
 2023be8:	e6ffff04 	addi	sp,fp,-4
 2023bec:	dfc00217 	ldw	ra,8(sp)
 2023bf0:	df000117 	ldw	fp,4(sp)
 2023bf4:	dc000017 	ldw	r16,0(sp)
 2023bf8:	dec00304 	addi	sp,sp,12
 2023bfc:	f800283a 	ret

02023c00 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 2023c00:	defff904 	addi	sp,sp,-28
 2023c04:	dfc00615 	stw	ra,24(sp)
 2023c08:	df000515 	stw	fp,20(sp)
 2023c0c:	dc400415 	stw	r17,16(sp)
 2023c10:	dc000315 	stw	r16,12(sp)
 2023c14:	df000504 	addi	fp,sp,20
 2023c18:	e13ffc15 	stw	r4,-16(fp)
 2023c1c:	e17ffd15 	stw	r5,-12(fp)
  struct tcp_seg *old_seg;

  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 2023c20:	e0bffc17 	ldw	r2,-16(fp)
 2023c24:	10800417 	ldw	r2,16(r2)
 2023c28:	10c00303 	ldbu	r3,12(r2)
 2023c2c:	10800343 	ldbu	r2,13(r2)
 2023c30:	1004923a 	slli	r2,r2,8
 2023c34:	10c4b03a 	or	r2,r2,r3
 2023c38:	10bfffcc 	andi	r2,r2,65535
 2023c3c:	1009883a 	mov	r4,r2
 2023c40:	20394740 	call	2039474 <lwip_htons>
 2023c44:	10803fcc 	andi	r2,r2,255
 2023c48:	1080004c 	andi	r2,r2,1
 2023c4c:	10003526 	beq	r2,zero,2023d24 <tcp_oos_insert_segment+0x124>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 2023c50:	e13ffd17 	ldw	r4,-12(fp)
 2023c54:	2020e8c0 	call	2020e8c <tcp_segs_free>
    next = NULL;
 2023c58:	e03ffd15 	stw	zero,-12(fp)
 2023c5c:	00007a06 	br	2023e48 <tcp_oos_insert_segment+0x248>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                       (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 2023c60:	e0bffd17 	ldw	r2,-12(fp)
 2023c64:	10800417 	ldw	r2,16(r2)
 2023c68:	10c00303 	ldbu	r3,12(r2)
 2023c6c:	10800343 	ldbu	r2,13(r2)
 2023c70:	1004923a 	slli	r2,r2,8
 2023c74:	10c4b03a 	or	r2,r2,r3
 2023c78:	10bfffcc 	andi	r2,r2,65535
 2023c7c:	1009883a 	mov	r4,r2
 2023c80:	20394740 	call	2039474 <lwip_htons>
 2023c84:	10803fcc 	andi	r2,r2,255
 2023c88:	1080004c 	andi	r2,r2,1
 2023c8c:	10001e26 	beq	r2,zero,2023d08 <tcp_oos_insert_segment+0x108>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 2023c90:	e0bffc17 	ldw	r2,-16(fp)
 2023c94:	14000417 	ldw	r16,16(r2)
 2023c98:	e0bffc17 	ldw	r2,-16(fp)
 2023c9c:	10800417 	ldw	r2,16(r2)
 2023ca0:	10c00303 	ldbu	r3,12(r2)
 2023ca4:	10800343 	ldbu	r2,13(r2)
 2023ca8:	1004923a 	slli	r2,r2,8
 2023cac:	10c4b03a 	or	r2,r2,r3
 2023cb0:	1023883a 	mov	r17,r2
 2023cb4:	01000044 	movi	r4,1
 2023cb8:	20394740 	call	2039474 <lwip_htons>
 2023cbc:	8884b03a 	or	r2,r17,r2
 2023cc0:	100b883a 	mov	r5,r2
 2023cc4:	28bfffcc 	andi	r2,r5,65535
 2023cc8:	11003fcc 	andi	r4,r2,255
 2023ccc:	80800303 	ldbu	r2,12(r16)
 2023cd0:	1004703a 	and	r2,r2,zero
 2023cd4:	1007883a 	mov	r3,r2
 2023cd8:	2005883a 	mov	r2,r4
 2023cdc:	1884b03a 	or	r2,r3,r2
 2023ce0:	80800305 	stb	r2,12(r16)
 2023ce4:	28bfffcc 	andi	r2,r5,65535
 2023ce8:	1004d23a 	srli	r2,r2,8
 2023cec:	113fffcc 	andi	r4,r2,65535
 2023cf0:	80800343 	ldbu	r2,13(r16)
 2023cf4:	1004703a 	and	r2,r2,zero
 2023cf8:	1007883a 	mov	r3,r2
 2023cfc:	2005883a 	mov	r2,r4
 2023d00:	1884b03a 	or	r2,r3,r2
 2023d04:	80800345 	stb	r2,13(r16)
      }
      old_seg = next;
 2023d08:	e0bffd17 	ldw	r2,-12(fp)
 2023d0c:	e0bffb15 	stw	r2,-20(fp)
      next = next->next;
 2023d10:	e0bffd17 	ldw	r2,-12(fp)
 2023d14:	10800017 	ldw	r2,0(r2)
 2023d18:	e0bffd15 	stw	r2,-12(fp)
      tcp_seg_free(old_seg);
 2023d1c:	e13ffb17 	ldw	r4,-20(fp)
 2023d20:	2020ee00 	call	2020ee0 <tcp_seg_free>
    tcp_segs_free(next);
    next = NULL;
  } else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 2023d24:	e0bffd17 	ldw	r2,-12(fp)
 2023d28:	10001826 	beq	r2,zero,2023d8c <tcp_oos_insert_segment+0x18c>
           TCP_SEQ_GEQ((seqno + cseg->len),
 2023d2c:	e0bffc17 	ldw	r2,-16(fp)
 2023d30:	1080020b 	ldhu	r2,8(r2)
 2023d34:	10ffffcc 	andi	r3,r2,65535
 2023d38:	d0a7ea17 	ldw	r2,-24664(gp)
 2023d3c:	1887883a 	add	r3,r3,r2
 2023d40:	e0bffd17 	ldw	r2,-12(fp)
 2023d44:	10800417 	ldw	r2,16(r2)
 2023d48:	11000103 	ldbu	r4,4(r2)
 2023d4c:	11400143 	ldbu	r5,5(r2)
 2023d50:	280a923a 	slli	r5,r5,8
 2023d54:	2908b03a 	or	r4,r5,r4
 2023d58:	11400183 	ldbu	r5,6(r2)
 2023d5c:	280a943a 	slli	r5,r5,16
 2023d60:	2908b03a 	or	r4,r5,r4
 2023d64:	108001c3 	ldbu	r2,7(r2)
 2023d68:	1004963a 	slli	r2,r2,24
 2023d6c:	1104b03a 	or	r2,r2,r4
 2023d70:	1009883a 	mov	r4,r2
 2023d74:	e0bffd17 	ldw	r2,-12(fp)
 2023d78:	1080020b 	ldhu	r2,8(r2)
 2023d7c:	10bfffcc 	andi	r2,r2,65535
 2023d80:	2085883a 	add	r2,r4,r2
 2023d84:	1885c83a 	sub	r2,r3,r2
    tcp_segs_free(next);
    next = NULL;
  } else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 2023d88:	103fb50e 	bge	r2,zero,2023c60 <__alt_mem_mem_0+0xfd003c60>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
 2023d8c:	e0bffd17 	ldw	r2,-12(fp)
 2023d90:	10002d26 	beq	r2,zero,2023e48 <tcp_oos_insert_segment+0x248>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 2023d94:	e0bffc17 	ldw	r2,-16(fp)
 2023d98:	1080020b 	ldhu	r2,8(r2)
 2023d9c:	10ffffcc 	andi	r3,r2,65535
 2023da0:	d0a7ea17 	ldw	r2,-24664(gp)
 2023da4:	1887883a 	add	r3,r3,r2
 2023da8:	e0bffd17 	ldw	r2,-12(fp)
 2023dac:	10800417 	ldw	r2,16(r2)
 2023db0:	11000103 	ldbu	r4,4(r2)
 2023db4:	11400143 	ldbu	r5,5(r2)
 2023db8:	280a923a 	slli	r5,r5,8
 2023dbc:	2908b03a 	or	r4,r5,r4
 2023dc0:	11400183 	ldbu	r5,6(r2)
 2023dc4:	280a943a 	slli	r5,r5,16
 2023dc8:	2908b03a 	or	r4,r5,r4
 2023dcc:	108001c3 	ldbu	r2,7(r2)
 2023dd0:	1004963a 	slli	r2,r2,24
 2023dd4:	1104b03a 	or	r2,r2,r4
 2023dd8:	1885c83a 	sub	r2,r3,r2
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
 2023ddc:	00801a0e 	bge	zero,r2,2023e48 <tcp_oos_insert_segment+0x248>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 2023de0:	e0bffd17 	ldw	r2,-12(fp)
 2023de4:	10800417 	ldw	r2,16(r2)
 2023de8:	10c00103 	ldbu	r3,4(r2)
 2023dec:	11000143 	ldbu	r4,5(r2)
 2023df0:	2008923a 	slli	r4,r4,8
 2023df4:	20c6b03a 	or	r3,r4,r3
 2023df8:	11000183 	ldbu	r4,6(r2)
 2023dfc:	2008943a 	slli	r4,r4,16
 2023e00:	20c6b03a 	or	r3,r4,r3
 2023e04:	108001c3 	ldbu	r2,7(r2)
 2023e08:	1004963a 	slli	r2,r2,24
 2023e0c:	10c4b03a 	or	r2,r2,r3
 2023e10:	1007883a 	mov	r3,r2
 2023e14:	d0a7ea17 	ldw	r2,-24664(gp)
 2023e18:	1885c83a 	sub	r2,r3,r2
 2023e1c:	1007883a 	mov	r3,r2
 2023e20:	e0bffc17 	ldw	r2,-16(fp)
 2023e24:	10c0020d 	sth	r3,8(r2)
      pbuf_realloc(cseg->p, cseg->len);
 2023e28:	e0bffc17 	ldw	r2,-16(fp)
 2023e2c:	10c00117 	ldw	r3,4(r2)
 2023e30:	e0bffc17 	ldw	r2,-16(fp)
 2023e34:	1080020b 	ldhu	r2,8(r2)
 2023e38:	10bfffcc 	andi	r2,r2,65535
 2023e3c:	100b883a 	mov	r5,r2
 2023e40:	1809883a 	mov	r4,r3
 2023e44:	201cd3c0 	call	201cd3c <pbuf_realloc>
    }
  }
  cseg->next = next;
 2023e48:	e0bffc17 	ldw	r2,-16(fp)
 2023e4c:	e0fffd17 	ldw	r3,-12(fp)
 2023e50:	10c00015 	stw	r3,0(r2)
}
 2023e54:	0001883a 	nop
 2023e58:	e6fffe04 	addi	sp,fp,-8
 2023e5c:	dfc00317 	ldw	ra,12(sp)
 2023e60:	df000217 	ldw	fp,8(sp)
 2023e64:	dc400117 	ldw	r17,4(sp)
 2023e68:	dc000017 	ldw	r16,0(sp)
 2023e6c:	dec00404 	addi	sp,sp,16
 2023e70:	f800283a 	ret

02023e74 <tcp_free_acked_segments>:

/** Remove segments from a list if the incoming ACK acknowledges them */
static struct tcp_seg *
tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
                        struct tcp_seg *dbg_other_seg_list)
{
 2023e74:	defff604 	addi	sp,sp,-40
 2023e78:	dfc00915 	stw	ra,36(sp)
 2023e7c:	df000815 	stw	fp,32(sp)
 2023e80:	dc400715 	stw	r17,28(sp)
 2023e84:	dc000615 	stw	r16,24(sp)
 2023e88:	df000804 	addi	fp,sp,32
 2023e8c:	e13ffa15 	stw	r4,-24(fp)
 2023e90:	e17ffb15 	stw	r5,-20(fp)
 2023e94:	e1bffc15 	stw	r6,-16(fp)
 2023e98:	e1fffd15 	stw	r7,-12(fp)
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
 2023e9c:	00001806 	br	2023f00 <tcp_free_acked_segments+0x8c>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
                                  lwip_ntohl(seg_list->tcphdr->seqno),
                                  lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
                                  dbg_list_name));

    next = seg_list;
 2023ea0:	e0bffb17 	ldw	r2,-20(fp)
 2023ea4:	e0bff815 	stw	r2,-32(fp)
    seg_list = seg_list->next;
 2023ea8:	e0bffb17 	ldw	r2,-20(fp)
 2023eac:	10800017 	ldw	r2,0(r2)
 2023eb0:	e0bffb15 	stw	r2,-20(fp)

    clen = pbuf_clen(next->p);
 2023eb4:	e0bff817 	ldw	r2,-32(fp)
 2023eb8:	10800117 	ldw	r2,4(r2)
 2023ebc:	1009883a 	mov	r4,r2
 2023ec0:	201d42c0 	call	201d42c <pbuf_clen>
 2023ec4:	e0bff90d 	sth	r2,-28(fp)
    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
                                 (tcpwnd_size_t)pcb->snd_queuelen));
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));

    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
 2023ec8:	e0bffa17 	ldw	r2,-24(fp)
 2023ecc:	10c01b8b 	ldhu	r3,110(r2)
 2023ed0:	e0bff90b 	ldhu	r2,-28(fp)
 2023ed4:	1885c83a 	sub	r2,r3,r2
 2023ed8:	1007883a 	mov	r3,r2
 2023edc:	e0bffa17 	ldw	r2,-24(fp)
 2023ee0:	10c01b8d 	sth	r3,110(r2)
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 2023ee4:	e0bff817 	ldw	r2,-32(fp)
 2023ee8:	10c0020b 	ldhu	r3,8(r2)
 2023eec:	d0a7ec0b 	ldhu	r2,-24656(gp)
 2023ef0:	1885883a 	add	r2,r3,r2
 2023ef4:	d0a7ec0d 	sth	r2,-24656(gp)
    tcp_seg_free(next);
 2023ef8:	e13ff817 	ldw	r4,-32(fp)
 2023efc:	2020ee00 	call	2020ee0 <tcp_seg_free>
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
 2023f00:	e0bffb17 	ldw	r2,-20(fp)
 2023f04:	10002626 	beq	r2,zero,2023fa0 <tcp_free_acked_segments+0x12c>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 2023f08:	e0bffb17 	ldw	r2,-20(fp)
 2023f0c:	10800417 	ldw	r2,16(r2)
 2023f10:	10c00103 	ldbu	r3,4(r2)
 2023f14:	11000143 	ldbu	r4,5(r2)
 2023f18:	2008923a 	slli	r4,r4,8
 2023f1c:	20c6b03a 	or	r3,r4,r3
 2023f20:	11000183 	ldbu	r4,6(r2)
 2023f24:	2008943a 	slli	r4,r4,16
 2023f28:	20c6b03a 	or	r3,r4,r3
 2023f2c:	108001c3 	ldbu	r2,7(r2)
 2023f30:	1004963a 	slli	r2,r2,24
 2023f34:	10c4b03a 	or	r2,r2,r3
 2023f38:	1009883a 	mov	r4,r2
 2023f3c:	20394b00 	call	20394b0 <lwip_htonl>
 2023f40:	1023883a 	mov	r17,r2
 2023f44:	e0bffb17 	ldw	r2,-20(fp)
 2023f48:	1080020b 	ldhu	r2,8(r2)
 2023f4c:	143fffcc 	andi	r16,r2,65535
 2023f50:	e0bffb17 	ldw	r2,-20(fp)
 2023f54:	10800417 	ldw	r2,16(r2)
 2023f58:	10c00303 	ldbu	r3,12(r2)
 2023f5c:	10800343 	ldbu	r2,13(r2)
 2023f60:	1004923a 	slli	r2,r2,8
 2023f64:	10c4b03a 	or	r2,r2,r3
 2023f68:	10bfffcc 	andi	r2,r2,65535
 2023f6c:	1009883a 	mov	r4,r2
 2023f70:	20394740 	call	2039474 <lwip_htons>
 2023f74:	10803fcc 	andi	r2,r2,255
 2023f78:	108000cc 	andi	r2,r2,3
 2023f7c:	10000226 	beq	r2,zero,2023f88 <tcp_free_acked_segments+0x114>
 2023f80:	00800044 	movi	r2,1
 2023f84:	00000106 	br	2023f8c <tcp_free_acked_segments+0x118>
 2023f88:	0005883a 	mov	r2,zero
 2023f8c:	8085883a 	add	r2,r16,r2
 2023f90:	8887883a 	add	r3,r17,r2
 2023f94:	d0a7eb17 	ldw	r2,-24660(gp)
 2023f98:	1885c83a 	sub	r2,r3,r2
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
 2023f9c:	00bfc00e 	bge	zero,r2,2023ea0 <__alt_mem_mem_0+0xfd003ea0>
    if (pcb->snd_queuelen != 0) {
      LWIP_ASSERT("tcp_receive: valid queue length",
                  seg_list != NULL || dbg_other_seg_list != NULL);
    }
  }
  return seg_list;
 2023fa0:	e0bffb17 	ldw	r2,-20(fp)
}
 2023fa4:	e6fffe04 	addi	sp,fp,-8
 2023fa8:	dfc00317 	ldw	ra,12(sp)
 2023fac:	df000217 	ldw	fp,8(sp)
 2023fb0:	dc400117 	ldw	r17,4(sp)
 2023fb4:	dc000017 	ldw	r16,0(sp)
 2023fb8:	dec00404 	addi	sp,sp,16
 2023fbc:	f800283a 	ret

02023fc0 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 2023fc0:	deffea04 	addi	sp,sp,-88
 2023fc4:	dfc01515 	stw	ra,84(sp)
 2023fc8:	df001415 	stw	fp,80(sp)
 2023fcc:	dc401315 	stw	r17,76(sp)
 2023fd0:	dc001215 	stw	r16,72(sp)
 2023fd4:	df001404 	addi	fp,sp,80
 2023fd8:	e13ffd15 	stw	r4,-12(fp)
  u32_t right_wnd_edge;

  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
 2023fdc:	d0a7ed03 	ldbu	r2,-24652(gp)
 2023fe0:	10803fcc 	andi	r2,r2,255
 2023fe4:	1080040c 	andi	r2,r2,16
 2023fe8:	1001ea26 	beq	r2,zero,2024794 <tcp_receive+0x7d4>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 2023fec:	e0bffd17 	ldw	r2,-12(fp)
 2023ff0:	10801a0b 	ldhu	r2,104(r2)
 2023ff4:	10ffffcc 	andi	r3,r2,65535
 2023ff8:	e0bffd17 	ldw	r2,-12(fp)
 2023ffc:	10801817 	ldw	r2,96(r2)
 2024000:	1885883a 	add	r2,r3,r2
 2024004:	e0bff215 	stw	r2,-56(fp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 2024008:	e0bffd17 	ldw	r2,-12(fp)
 202400c:	10c01717 	ldw	r3,92(r2)
 2024010:	d0a7ea17 	ldw	r2,-24664(gp)
 2024014:	1885c83a 	sub	r2,r3,r2
 2024018:	10001816 	blt	r2,zero,202407c <tcp_receive+0xbc>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 202401c:	e0bffd17 	ldw	r2,-12(fp)
 2024020:	10c01717 	ldw	r3,92(r2)
 2024024:	d0a7ea17 	ldw	r2,-24664(gp)

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 2024028:	1880051e 	bne	r3,r2,2024040 <tcp_receive+0x80>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 202402c:	e0bffd17 	ldw	r2,-12(fp)
 2024030:	10c01817 	ldw	r3,96(r2)
 2024034:	d0a7eb17 	ldw	r2,-24660(gp)
 2024038:	1885c83a 	sub	r2,r3,r2
 202403c:	10000f16 	blt	r2,zero,202407c <tcp_receive+0xbc>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 2024040:	e0bffd17 	ldw	r2,-12(fp)
 2024044:	10c01817 	ldw	r3,96(r2)
 2024048:	d0a7eb17 	ldw	r2,-24660(gp)
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 202404c:	1880241e 	bne	r3,r2,20240e0 <tcp_receive+0x120>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 2024050:	d0a7e617 	ldw	r2,-24680(gp)
 2024054:	10c00383 	ldbu	r3,14(r2)
 2024058:	108003c3 	ldbu	r2,15(r2)
 202405c:	1004923a 	slli	r2,r2,8
 2024060:	10c4b03a 	or	r2,r2,r3
 2024064:	1009883a 	mov	r4,r2
 2024068:	e0bffd17 	ldw	r2,-12(fp)
 202406c:	10c01a0b 	ldhu	r3,104(r2)
 2024070:	20bfffcc 	andi	r2,r4,65535
 2024074:	18ffffcc 	andi	r3,r3,65535
 2024078:	1880192e 	bgeu	r3,r2,20240e0 <tcp_receive+0x120>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 202407c:	d0a7e617 	ldw	r2,-24680(gp)
 2024080:	10c00383 	ldbu	r3,14(r2)
 2024084:	108003c3 	ldbu	r2,15(r2)
 2024088:	1004923a 	slli	r2,r2,8
 202408c:	10c4b03a 	or	r2,r2,r3
 2024090:	1007883a 	mov	r3,r2
 2024094:	e0bffd17 	ldw	r2,-12(fp)
 2024098:	10c01a0d 	sth	r3,104(r2)
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 202409c:	e0bffd17 	ldw	r2,-12(fp)
 20240a0:	10c01a8b 	ldhu	r3,106(r2)
 20240a4:	e0bffd17 	ldw	r2,-12(fp)
 20240a8:	10801a0b 	ldhu	r2,104(r2)
 20240ac:	18ffffcc 	andi	r3,r3,65535
 20240b0:	10bfffcc 	andi	r2,r2,65535
 20240b4:	1880042e 	bgeu	r3,r2,20240c8 <tcp_receive+0x108>
        pcb->snd_wnd_max = pcb->snd_wnd;
 20240b8:	e0bffd17 	ldw	r2,-12(fp)
 20240bc:	10c01a0b 	ldhu	r3,104(r2)
 20240c0:	e0bffd17 	ldw	r2,-12(fp)
 20240c4:	10c01a8d 	sth	r3,106(r2)
      }
      pcb->snd_wl1 = seqno;
 20240c8:	d0e7ea17 	ldw	r3,-24664(gp)
 20240cc:	e0bffd17 	ldw	r2,-12(fp)
 20240d0:	10c01715 	stw	r3,92(r2)
      pcb->snd_wl2 = ackno;
 20240d4:	d0e7eb17 	ldw	r3,-24660(gp)
 20240d8:	e0bffd17 	ldw	r2,-12(fp)
 20240dc:	10c01815 	stw	r3,96(r2)
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 20240e0:	d0e7eb17 	ldw	r3,-24660(gp)
 20240e4:	e0bffd17 	ldw	r2,-12(fp)
 20240e8:	10801317 	ldw	r2,76(r2)
 20240ec:	1885c83a 	sub	r2,r3,r2
 20240f0:	00804816 	blt	zero,r2,2024214 <tcp_receive+0x254>
      /* Clause 2 */
      if (tcplen == 0) {
 20240f4:	d0a7ec8b 	ldhu	r2,-24654(gp)
 20240f8:	10bfffcc 	andi	r2,r2,65535
 20240fc:	1001611e 	bne	r2,zero,2024684 <tcp_receive+0x6c4>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 2024100:	e0bffd17 	ldw	r2,-12(fp)
 2024104:	10c01817 	ldw	r3,96(r2)
 2024108:	e0bffd17 	ldw	r2,-12(fp)
 202410c:	10801a0b 	ldhu	r2,104(r2)
 2024110:	10bfffcc 	andi	r2,r2,65535
 2024114:	1887883a 	add	r3,r3,r2
 2024118:	e0bff217 	ldw	r2,-56(fp)
 202411c:	1881591e 	bne	r3,r2,2024684 <tcp_receive+0x6c4>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 2024120:	e0bffd17 	ldw	r2,-12(fp)
 2024124:	10800e0b 	ldhu	r2,56(r2)
 2024128:	10bfffcc 	andi	r2,r2,65535
 202412c:	10a0001c 	xori	r2,r2,32768
 2024130:	10a00004 	addi	r2,r2,-32768
 2024134:	10015316 	blt	r2,zero,2024684 <tcp_receive+0x6c4>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 2024138:	e0bffd17 	ldw	r2,-12(fp)
 202413c:	10c01317 	ldw	r3,76(r2)
 2024140:	d0a7eb17 	ldw	r2,-24660(gp)
 2024144:	18814f1e 	bne	r3,r2,2024684 <tcp_receive+0x6c4>
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 2024148:	e0bffd17 	ldw	r2,-12(fp)
 202414c:	108012c3 	ldbu	r2,75(r2)
 2024150:	10800044 	addi	r2,r2,1
 2024154:	1009883a 	mov	r4,r2
 2024158:	e0bffd17 	ldw	r2,-12(fp)
 202415c:	10c012c3 	ldbu	r3,75(r2)
 2024160:	20803fcc 	andi	r2,r4,255
 2024164:	18c03fcc 	andi	r3,r3,255
 2024168:	1880062e 	bgeu	r3,r2,2024184 <tcp_receive+0x1c4>
                ++pcb->dupacks;
 202416c:	e0bffd17 	ldw	r2,-12(fp)
 2024170:	108012c3 	ldbu	r2,75(r2)
 2024174:	10800044 	addi	r2,r2,1
 2024178:	1007883a 	mov	r3,r2
 202417c:	e0bffd17 	ldw	r2,-12(fp)
 2024180:	10c012c5 	stb	r3,75(r2)
              }
              if (pcb->dupacks > 3) {
 2024184:	e0bffd17 	ldw	r2,-12(fp)
 2024188:	108012c3 	ldbu	r2,75(r2)
 202418c:	10803fcc 	andi	r2,r2,255
 2024190:	10800130 	cmpltui	r2,r2,4
 2024194:	1000171e 	bne	r2,zero,20241f4 <tcp_receive+0x234>
                /* Inflate the congestion window */
                TCP_WND_INC(pcb->cwnd, pcb->mss);
 2024198:	e0bffd17 	ldw	r2,-12(fp)
 202419c:	10c0140b 	ldhu	r3,80(r2)
 20241a0:	e0bffd17 	ldw	r2,-12(fp)
 20241a4:	10800e8b 	ldhu	r2,58(r2)
 20241a8:	1885883a 	add	r2,r3,r2
 20241ac:	1007883a 	mov	r3,r2
 20241b0:	e0bffd17 	ldw	r2,-12(fp)
 20241b4:	1080140b 	ldhu	r2,80(r2)
 20241b8:	18ffffcc 	andi	r3,r3,65535
 20241bc:	10bfffcc 	andi	r2,r2,65535
 20241c0:	18800936 	bltu	r3,r2,20241e8 <tcp_receive+0x228>
 20241c4:	e0bffd17 	ldw	r2,-12(fp)
 20241c8:	10c0140b 	ldhu	r3,80(r2)
 20241cc:	e0bffd17 	ldw	r2,-12(fp)
 20241d0:	10800e8b 	ldhu	r2,58(r2)
 20241d4:	1885883a 	add	r2,r3,r2
 20241d8:	1007883a 	mov	r3,r2
 20241dc:	e0bffd17 	ldw	r2,-12(fp)
 20241e0:	10c0140d 	sth	r3,80(r2)
 20241e4:	00000306 	br	20241f4 <tcp_receive+0x234>
 20241e8:	e0bffd17 	ldw	r2,-12(fp)
 20241ec:	00ffffc4 	movi	r3,-1
 20241f0:	10c0140d 	sth	r3,80(r2)
              }
              if (pcb->dupacks >= 3) {
 20241f4:	e0bffd17 	ldw	r2,-12(fp)
 20241f8:	108012c3 	ldbu	r2,75(r2)
 20241fc:	10803fcc 	andi	r2,r2,255
 2024200:	108000f0 	cmpltui	r2,r2,3
 2024204:	10011f1e 	bne	r2,zero,2024684 <tcp_receive+0x6c4>
                /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
                tcp_rexmit_fast(pcb);
 2024208:	e13ffd17 	ldw	r4,-12(fp)
 202420c:	20285d80 	call	20285d8 <tcp_rexmit_fast>
 2024210:	00011c06 	br	2024684 <tcp_receive+0x6c4>
              }
            }
          }
        }
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 2024214:	d0e7eb17 	ldw	r3,-24660(gp)
 2024218:	e0bffd17 	ldw	r2,-12(fp)
 202421c:	10801317 	ldw	r2,76(r2)
 2024220:	1885c83a 	sub	r2,r3,r2
 2024224:	10bfffc4 	addi	r2,r2,-1
 2024228:	10011216 	blt	r2,zero,2024674 <tcp_receive+0x6b4>
 202422c:	d0e7eb17 	ldw	r3,-24660(gp)
 2024230:	e0bffd17 	ldw	r2,-12(fp)
 2024234:	10801617 	ldw	r2,88(r2)
 2024238:	1885c83a 	sub	r2,r3,r2
 202423c:	00810d16 	blt	zero,r2,2024674 <tcp_receive+0x6b4>
      tcpwnd_size_t acked;

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 2024240:	e0bffd17 	ldw	r2,-12(fp)
 2024244:	1080088b 	ldhu	r2,34(r2)
 2024248:	10bfffcc 	andi	r2,r2,65535
 202424c:	1080010c 	andi	r2,r2,4
 2024250:	10000d26 	beq	r2,zero,2024288 <tcp_receive+0x2c8>
        tcp_clear_flags(pcb, TF_INFR);
 2024254:	e0bffd17 	ldw	r2,-12(fp)
 2024258:	10c0088b 	ldhu	r3,34(r2)
 202425c:	00bffec4 	movi	r2,-5
 2024260:	1884703a 	and	r2,r3,r2
 2024264:	1007883a 	mov	r3,r2
 2024268:	e0bffd17 	ldw	r2,-12(fp)
 202426c:	10c0088d 	sth	r3,34(r2)
        pcb->cwnd = pcb->ssthresh;
 2024270:	e0bffd17 	ldw	r2,-12(fp)
 2024274:	10c0148b 	ldhu	r3,82(r2)
 2024278:	e0bffd17 	ldw	r2,-12(fp)
 202427c:	10c0140d 	sth	r3,80(r2)
        pcb->bytes_acked = 0;
 2024280:	e0bffd17 	ldw	r2,-12(fp)
 2024284:	10001c8d 	sth	zero,114(r2)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 2024288:	e0bffd17 	ldw	r2,-12(fp)
 202428c:	10001285 	stb	zero,74(r2)

      /* Reset the retransmission time-out. */
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 2024290:	e0bffd17 	ldw	r2,-12(fp)
 2024294:	1080110b 	ldhu	r2,68(r2)
 2024298:	10bfffcc 	andi	r2,r2,65535
 202429c:	10a0001c 	xori	r2,r2,32768
 20242a0:	10a00004 	addi	r2,r2,-32768
 20242a4:	1005d0fa 	srai	r2,r2,3
 20242a8:	1007883a 	mov	r3,r2
 20242ac:	e0bffd17 	ldw	r2,-12(fp)
 20242b0:	1080118b 	ldhu	r2,70(r2)
 20242b4:	1885883a 	add	r2,r3,r2
 20242b8:	1007883a 	mov	r3,r2
 20242bc:	e0bffd17 	ldw	r2,-12(fp)
 20242c0:	10c0120d 	sth	r3,72(r2)

      /* Record how much data this ACK acks */
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 20242c4:	d0a7eb17 	ldw	r2,-24660(gp)
 20242c8:	1007883a 	mov	r3,r2
 20242cc:	e0bffd17 	ldw	r2,-12(fp)
 20242d0:	10801317 	ldw	r2,76(r2)
 20242d4:	1885c83a 	sub	r2,r3,r2
 20242d8:	e0bff30d 	sth	r2,-52(fp)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 20242dc:	e0bffd17 	ldw	r2,-12(fp)
 20242e0:	100012c5 	stb	zero,75(r2)
      pcb->lastack = ackno;
 20242e4:	d0e7eb17 	ldw	r3,-24660(gp)
 20242e8:	e0bffd17 	ldw	r2,-12(fp)
 20242ec:	10c01315 	stw	r3,76(r2)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 20242f0:	e0bffd17 	ldw	r2,-12(fp)
 20242f4:	10800617 	ldw	r2,24(r2)
 20242f8:	10800130 	cmpltui	r2,r2,4
 20242fc:	10006b1e 	bne	r2,zero,20244ac <tcp_receive+0x4ec>
        if (pcb->cwnd < pcb->ssthresh) {
 2024300:	e0bffd17 	ldw	r2,-12(fp)
 2024304:	10c0140b 	ldhu	r3,80(r2)
 2024308:	e0bffd17 	ldw	r2,-12(fp)
 202430c:	1080148b 	ldhu	r2,82(r2)
 2024310:	18ffffcc 	andi	r3,r3,65535
 2024314:	10bfffcc 	andi	r2,r2,65535
 2024318:	1880292e 	bgeu	r3,r2,20243c0 <tcp_receive+0x400>
          tcpwnd_size_t increase;
          /* limit to 1 SMSS segment during period following RTO */
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
 202431c:	e0bffd17 	ldw	r2,-12(fp)
 2024320:	1080088b 	ldhu	r2,34(r2)
 2024324:	10bfffcc 	andi	r2,r2,65535
 2024328:	1082000c 	andi	r2,r2,2048
 202432c:	10000226 	beq	r2,zero,2024338 <tcp_receive+0x378>
 2024330:	00800044 	movi	r2,1
 2024334:	00000106 	br	202433c <tcp_receive+0x37c>
 2024338:	00800084 	movi	r2,2
 202433c:	e0bff385 	stb	r2,-50(fp)
          /* RFC 3465, section 2.2 Slow Start */
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
 2024340:	e0fff383 	ldbu	r3,-50(fp)
 2024344:	e0bffd17 	ldw	r2,-12(fp)
 2024348:	10800e8b 	ldhu	r2,58(r2)
 202434c:	1885383a 	mul	r2,r3,r2
 2024350:	e17ff30b 	ldhu	r5,-52(fp)
 2024354:	10ffffcc 	andi	r3,r2,65535
 2024358:	293fffcc 	andi	r4,r5,65535
 202435c:	20c0012e 	bgeu	r4,r3,2024364 <tcp_receive+0x3a4>
 2024360:	2805883a 	mov	r2,r5
 2024364:	e0bff40d 	sth	r2,-48(fp)
          TCP_WND_INC(pcb->cwnd, increase);
 2024368:	e0bffd17 	ldw	r2,-12(fp)
 202436c:	10c0140b 	ldhu	r3,80(r2)
 2024370:	e0bff40b 	ldhu	r2,-48(fp)
 2024374:	1885883a 	add	r2,r3,r2
 2024378:	1007883a 	mov	r3,r2
 202437c:	e0bffd17 	ldw	r2,-12(fp)
 2024380:	1080140b 	ldhu	r2,80(r2)
 2024384:	18ffffcc 	andi	r3,r3,65535
 2024388:	10bfffcc 	andi	r2,r2,65535
 202438c:	18800836 	bltu	r3,r2,20243b0 <tcp_receive+0x3f0>
 2024390:	e0bffd17 	ldw	r2,-12(fp)
 2024394:	10c0140b 	ldhu	r3,80(r2)
 2024398:	e0bff40b 	ldhu	r2,-48(fp)
 202439c:	1885883a 	add	r2,r3,r2
 20243a0:	1007883a 	mov	r3,r2
 20243a4:	e0bffd17 	ldw	r2,-12(fp)
 20243a8:	10c0140d 	sth	r3,80(r2)
 20243ac:	00003f06 	br	20244ac <tcp_receive+0x4ec>
 20243b0:	e0bffd17 	ldw	r2,-12(fp)
 20243b4:	00ffffc4 	movi	r3,-1
 20243b8:	10c0140d 	sth	r3,80(r2)
 20243bc:	00003b06 	br	20244ac <tcp_receive+0x4ec>
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
        } else {
          /* RFC 3465, section 2.1 Congestion Avoidance */
          TCP_WND_INC(pcb->bytes_acked, acked);
 20243c0:	e0bffd17 	ldw	r2,-12(fp)
 20243c4:	10c01c8b 	ldhu	r3,114(r2)
 20243c8:	e0bff30b 	ldhu	r2,-52(fp)
 20243cc:	1885883a 	add	r2,r3,r2
 20243d0:	1007883a 	mov	r3,r2
 20243d4:	e0bffd17 	ldw	r2,-12(fp)
 20243d8:	10801c8b 	ldhu	r2,114(r2)
 20243dc:	18ffffcc 	andi	r3,r3,65535
 20243e0:	10bfffcc 	andi	r2,r2,65535
 20243e4:	18800836 	bltu	r3,r2,2024408 <tcp_receive+0x448>
 20243e8:	e0bffd17 	ldw	r2,-12(fp)
 20243ec:	10c01c8b 	ldhu	r3,114(r2)
 20243f0:	e0bff30b 	ldhu	r2,-52(fp)
 20243f4:	1885883a 	add	r2,r3,r2
 20243f8:	1007883a 	mov	r3,r2
 20243fc:	e0bffd17 	ldw	r2,-12(fp)
 2024400:	10c01c8d 	sth	r3,114(r2)
 2024404:	00000306 	br	2024414 <tcp_receive+0x454>
 2024408:	e0bffd17 	ldw	r2,-12(fp)
 202440c:	00ffffc4 	movi	r3,-1
 2024410:	10c01c8d 	sth	r3,114(r2)
          if (pcb->bytes_acked >= pcb->cwnd) {
 2024414:	e0bffd17 	ldw	r2,-12(fp)
 2024418:	10c01c8b 	ldhu	r3,114(r2)
 202441c:	e0bffd17 	ldw	r2,-12(fp)
 2024420:	1080140b 	ldhu	r2,80(r2)
 2024424:	18ffffcc 	andi	r3,r3,65535
 2024428:	10bfffcc 	andi	r2,r2,65535
 202442c:	18801f36 	bltu	r3,r2,20244ac <tcp_receive+0x4ec>
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 2024430:	e0bffd17 	ldw	r2,-12(fp)
 2024434:	10c01c8b 	ldhu	r3,114(r2)
 2024438:	e0bffd17 	ldw	r2,-12(fp)
 202443c:	1080140b 	ldhu	r2,80(r2)
 2024440:	1885c83a 	sub	r2,r3,r2
 2024444:	1007883a 	mov	r3,r2
 2024448:	e0bffd17 	ldw	r2,-12(fp)
 202444c:	10c01c8d 	sth	r3,114(r2)
            TCP_WND_INC(pcb->cwnd, pcb->mss);
 2024450:	e0bffd17 	ldw	r2,-12(fp)
 2024454:	10c0140b 	ldhu	r3,80(r2)
 2024458:	e0bffd17 	ldw	r2,-12(fp)
 202445c:	10800e8b 	ldhu	r2,58(r2)
 2024460:	1885883a 	add	r2,r3,r2
 2024464:	1007883a 	mov	r3,r2
 2024468:	e0bffd17 	ldw	r2,-12(fp)
 202446c:	1080140b 	ldhu	r2,80(r2)
 2024470:	18ffffcc 	andi	r3,r3,65535
 2024474:	10bfffcc 	andi	r2,r2,65535
 2024478:	18800936 	bltu	r3,r2,20244a0 <tcp_receive+0x4e0>
 202447c:	e0bffd17 	ldw	r2,-12(fp)
 2024480:	10c0140b 	ldhu	r3,80(r2)
 2024484:	e0bffd17 	ldw	r2,-12(fp)
 2024488:	10800e8b 	ldhu	r2,58(r2)
 202448c:	1885883a 	add	r2,r3,r2
 2024490:	1007883a 	mov	r3,r2
 2024494:	e0bffd17 	ldw	r2,-12(fp)
 2024498:	10c0140d 	sth	r3,80(r2)
 202449c:	00000306 	br	20244ac <tcp_receive+0x4ec>
 20244a0:	e0bffd17 	ldw	r2,-12(fp)
 20244a4:	00ffffc4 	movi	r3,-1
 20244a8:	10c0140d 	sth	r3,80(r2)
                                    pcb->unacked != NULL ?
                                    lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked) : 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowledges them. */
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
 20244ac:	e0bffd17 	ldw	r2,-12(fp)
 20244b0:	10c01e17 	ldw	r3,120(r2)
 20244b4:	e0bffd17 	ldw	r2,-12(fp)
 20244b8:	10801d17 	ldw	r2,116(r2)
 20244bc:	100f883a 	mov	r7,r2
 20244c0:	01808134 	movhi	r6,516
 20244c4:	319bf704 	addi	r6,r6,28636
 20244c8:	180b883a 	mov	r5,r3
 20244cc:	e13ffd17 	ldw	r4,-12(fp)
 20244d0:	2023e740 	call	2023e74 <tcp_free_acked_segments>
 20244d4:	1007883a 	mov	r3,r2
 20244d8:	e0bffd17 	ldw	r2,-12(fp)
 20244dc:	10c01e15 	stw	r3,120(r2)
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
 20244e0:	e0bffd17 	ldw	r2,-12(fp)
 20244e4:	10c01d17 	ldw	r3,116(r2)
 20244e8:	e0bffd17 	ldw	r2,-12(fp)
 20244ec:	10801e17 	ldw	r2,120(r2)
 20244f0:	100f883a 	mov	r7,r2
 20244f4:	01808134 	movhi	r6,516
 20244f8:	319bf904 	addi	r6,r6,28644
 20244fc:	180b883a 	mov	r5,r3
 2024500:	e13ffd17 	ldw	r4,-12(fp)
 2024504:	2023e740 	call	2023e74 <tcp_free_acked_segments>
 2024508:	1007883a 	mov	r3,r2
 202450c:	e0bffd17 	ldw	r2,-12(fp)
 2024510:	10c01d15 	stw	r3,116(r2)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
 2024514:	e0bffd17 	ldw	r2,-12(fp)
 2024518:	10801e17 	ldw	r2,120(r2)
 202451c:	1000041e 	bne	r2,zero,2024530 <tcp_receive+0x570>
        pcb->rtime = -1;
 2024520:	e0bffd17 	ldw	r2,-12(fp)
 2024524:	00ffffc4 	movi	r3,-1
 2024528:	10c00e0d 	sth	r3,56(r2)
 202452c:	00000206 	br	2024538 <tcp_receive+0x578>
      } else {
        pcb->rtime = 0;
 2024530:	e0bffd17 	ldw	r2,-12(fp)
 2024534:	10000e0d 	sth	zero,56(r2)
      }

      pcb->polltmr = 0;
 2024538:	e0bffd17 	ldw	r2,-12(fp)
 202453c:	10000905 	stb	zero,36(r2)

#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 2024540:	e0bffd17 	ldw	r2,-12(fp)
 2024544:	10801d17 	ldw	r2,116(r2)
 2024548:	1000021e 	bne	r2,zero,2024554 <tcp_receive+0x594>
        pcb->unsent_oversize = 0;
 202454c:	e0bffd17 	ldw	r2,-12(fp)
 2024550:	10001c0d 	sth	zero,112(r2)
        /* Inform neighbor reachability of forward progress. */
        nd6_reachability_hint(ip6_current_src_addr());
      }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/

      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
 2024554:	e0bffd17 	ldw	r2,-12(fp)
 2024558:	10c01b0b 	ldhu	r3,108(r2)
 202455c:	d0a7ec0b 	ldhu	r2,-24656(gp)
 2024560:	1885883a 	add	r2,r3,r2
 2024564:	1007883a 	mov	r3,r2
 2024568:	e0bffd17 	ldw	r2,-12(fp)
 202456c:	10c01b0d 	sth	r3,108(r2)
      /* check if this ACK ends our retransmission of in-flight data */
      if (pcb->flags & TF_RTO) {
 2024570:	e0bffd17 	ldw	r2,-12(fp)
 2024574:	1080088b 	ldhu	r2,34(r2)
 2024578:	10bfffcc 	andi	r2,r2,65535
 202457c:	1082000c 	andi	r2,r2,2048
 2024580:	10003f26 	beq	r2,zero,2024680 <tcp_receive+0x6c0>
        /* RTO is done if
            1) both queues are empty or
            2) unacked is empty and unsent head contains data not part of RTO or
            3) unacked head contains data not part of RTO */
        if (pcb->unacked == NULL) {
 2024584:	e0bffd17 	ldw	r2,-12(fp)
 2024588:	10801e17 	ldw	r2,120(r2)
 202458c:	10001e1e 	bne	r2,zero,2024608 <tcp_receive+0x648>
          if ((pcb->unsent == NULL) ||
 2024590:	e0bffd17 	ldw	r2,-12(fp)
 2024594:	10801d17 	ldw	r2,116(r2)
 2024598:	10001326 	beq	r2,zero,20245e8 <tcp_receive+0x628>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 202459c:	e0bffd17 	ldw	r2,-12(fp)
 20245a0:	14001517 	ldw	r16,84(r2)
 20245a4:	e0bffd17 	ldw	r2,-12(fp)
 20245a8:	10801d17 	ldw	r2,116(r2)
 20245ac:	10800417 	ldw	r2,16(r2)
 20245b0:	10c00103 	ldbu	r3,4(r2)
 20245b4:	11000143 	ldbu	r4,5(r2)
 20245b8:	2008923a 	slli	r4,r4,8
 20245bc:	20c6b03a 	or	r3,r4,r3
 20245c0:	11000183 	ldbu	r4,6(r2)
 20245c4:	2008943a 	slli	r4,r4,16
 20245c8:	20c6b03a 	or	r3,r4,r3
 20245cc:	108001c3 	ldbu	r2,7(r2)
 20245d0:	1004963a 	slli	r2,r2,24
 20245d4:	10c4b03a 	or	r2,r2,r3
 20245d8:	1009883a 	mov	r4,r2
 20245dc:	20394b00 	call	20394b0 <lwip_htonl>
 20245e0:	8085c83a 	sub	r2,r16,r2
        /* RTO is done if
            1) both queues are empty or
            2) unacked is empty and unsent head contains data not part of RTO or
            3) unacked head contains data not part of RTO */
        if (pcb->unacked == NULL) {
          if ((pcb->unsent == NULL) ||
 20245e4:	00802616 	blt	zero,r2,2024680 <tcp_receive+0x6c0>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
            tcp_clear_flags(pcb, TF_RTO);
 20245e8:	e0bffd17 	ldw	r2,-12(fp)
 20245ec:	10c0088b 	ldhu	r3,34(r2)
 20245f0:	00bdffc4 	movi	r2,-2049
 20245f4:	1884703a 	and	r2,r3,r2
 20245f8:	1007883a 	mov	r3,r2
 20245fc:	e0bffd17 	ldw	r2,-12(fp)
 2024600:	10c0088d 	sth	r3,34(r2)
              }
            }
          }
        }
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 2024604:	00001e06 	br	2024680 <tcp_receive+0x6c0>
        if (pcb->unacked == NULL) {
          if ((pcb->unsent == NULL) ||
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
            tcp_clear_flags(pcb, TF_RTO);
          }
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
 2024608:	e0bffd17 	ldw	r2,-12(fp)
 202460c:	14001517 	ldw	r16,84(r2)
 2024610:	e0bffd17 	ldw	r2,-12(fp)
 2024614:	10801e17 	ldw	r2,120(r2)
 2024618:	10800417 	ldw	r2,16(r2)
 202461c:	10c00103 	ldbu	r3,4(r2)
 2024620:	11000143 	ldbu	r4,5(r2)
 2024624:	2008923a 	slli	r4,r4,8
 2024628:	20c6b03a 	or	r3,r4,r3
 202462c:	11000183 	ldbu	r4,6(r2)
 2024630:	2008943a 	slli	r4,r4,16
 2024634:	20c6b03a 	or	r3,r4,r3
 2024638:	108001c3 	ldbu	r2,7(r2)
 202463c:	1004963a 	slli	r2,r2,24
 2024640:	10c4b03a 	or	r2,r2,r3
 2024644:	1009883a 	mov	r4,r2
 2024648:	20394b00 	call	20394b0 <lwip_htonl>
 202464c:	8085c83a 	sub	r2,r16,r2
 2024650:	00800b16 	blt	zero,r2,2024680 <tcp_receive+0x6c0>
          tcp_clear_flags(pcb, TF_RTO);
 2024654:	e0bffd17 	ldw	r2,-12(fp)
 2024658:	10c0088b 	ldhu	r3,34(r2)
 202465c:	00bdffc4 	movi	r2,-2049
 2024660:	1884703a 	and	r2,r3,r2
 2024664:	1007883a 	mov	r3,r2
 2024668:	e0bffd17 	ldw	r2,-12(fp)
 202466c:	10c0088d 	sth	r3,34(r2)
              }
            }
          }
        }
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 2024670:	00000306 	br	2024680 <tcp_receive+0x6c0>
        }
      }
      /* End of ACK for new data processing. */
    } else {
      /* Out of sequence ACK, didn't really ack anything */
      tcp_send_empty_ack(pcb);
 2024674:	e13ffd17 	ldw	r4,-12(fp)
 2024678:	2028dd00 	call	2028dd0 <tcp_send_empty_ack>
 202467c:	00000106 	br	2024684 <tcp_receive+0x6c4>
              }
            }
          }
        }
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 2024680:	0001883a 	nop
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 2024684:	e0bffd17 	ldw	r2,-12(fp)
 2024688:	10800f17 	ldw	r2,60(r2)
 202468c:	10004126 	beq	r2,zero,2024794 <tcp_receive+0x7d4>
 2024690:	e0bffd17 	ldw	r2,-12(fp)
 2024694:	10c01017 	ldw	r3,64(r2)
 2024698:	d0a7eb17 	ldw	r2,-24660(gp)
 202469c:	1885c83a 	sub	r2,r3,r2
 20246a0:	10003c0e 	bge	r2,zero,2024794 <tcp_receive+0x7d4>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 20246a4:	d0a7e217 	ldw	r2,-24696(gp)
 20246a8:	1007883a 	mov	r3,r2
 20246ac:	e0bffd17 	ldw	r2,-12(fp)
 20246b0:	10800f17 	ldw	r2,60(r2)
 20246b4:	1885c83a 	sub	r2,r3,r2
 20246b8:	e0bfec0d 	sth	r2,-80(fp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, (u16_t)(m * TCP_SLOW_INTERVAL)));

      /* This is taken directly from VJs original code in his paper */
      m = (s16_t)(m - (pcb->sa >> 3));
 20246bc:	e0bfec0b 	ldhu	r2,-80(fp)
 20246c0:	e0fffd17 	ldw	r3,-12(fp)
 20246c4:	18c0110b 	ldhu	r3,68(r3)
 20246c8:	18ffffcc 	andi	r3,r3,65535
 20246cc:	18e0001c 	xori	r3,r3,32768
 20246d0:	18e00004 	addi	r3,r3,-32768
 20246d4:	1807d0fa 	srai	r3,r3,3
 20246d8:	10c5c83a 	sub	r2,r2,r3
 20246dc:	e0bfec0d 	sth	r2,-80(fp)
      pcb->sa = (s16_t)(pcb->sa + m);
 20246e0:	e0bffd17 	ldw	r2,-12(fp)
 20246e4:	1080110b 	ldhu	r2,68(r2)
 20246e8:	1007883a 	mov	r3,r2
 20246ec:	e0bfec0b 	ldhu	r2,-80(fp)
 20246f0:	1885883a 	add	r2,r3,r2
 20246f4:	1007883a 	mov	r3,r2
 20246f8:	e0bffd17 	ldw	r2,-12(fp)
 20246fc:	10c0110d 	sth	r3,68(r2)
      if (m < 0) {
 2024700:	e0bfec0f 	ldh	r2,-80(fp)
 2024704:	1000030e 	bge	r2,zero,2024714 <tcp_receive+0x754>
        m = (s16_t) - m;
 2024708:	e0bfec0b 	ldhu	r2,-80(fp)
 202470c:	0085c83a 	sub	r2,zero,r2
 2024710:	e0bfec0d 	sth	r2,-80(fp)
      }
      m = (s16_t)(m - (pcb->sv >> 2));
 2024714:	e0bfec0b 	ldhu	r2,-80(fp)
 2024718:	e0fffd17 	ldw	r3,-12(fp)
 202471c:	18c0118b 	ldhu	r3,70(r3)
 2024720:	18ffffcc 	andi	r3,r3,65535
 2024724:	18e0001c 	xori	r3,r3,32768
 2024728:	18e00004 	addi	r3,r3,-32768
 202472c:	1807d0ba 	srai	r3,r3,2
 2024730:	10c5c83a 	sub	r2,r2,r3
 2024734:	e0bfec0d 	sth	r2,-80(fp)
      pcb->sv = (s16_t)(pcb->sv + m);
 2024738:	e0bffd17 	ldw	r2,-12(fp)
 202473c:	1080118b 	ldhu	r2,70(r2)
 2024740:	1007883a 	mov	r3,r2
 2024744:	e0bfec0b 	ldhu	r2,-80(fp)
 2024748:	1885883a 	add	r2,r3,r2
 202474c:	1007883a 	mov	r3,r2
 2024750:	e0bffd17 	ldw	r2,-12(fp)
 2024754:	10c0118d 	sth	r3,70(r2)
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 2024758:	e0bffd17 	ldw	r2,-12(fp)
 202475c:	1080110b 	ldhu	r2,68(r2)
 2024760:	10bfffcc 	andi	r2,r2,65535
 2024764:	10a0001c 	xori	r2,r2,32768
 2024768:	10a00004 	addi	r2,r2,-32768
 202476c:	1005d0fa 	srai	r2,r2,3
 2024770:	1007883a 	mov	r3,r2
 2024774:	e0bffd17 	ldw	r2,-12(fp)
 2024778:	1080118b 	ldhu	r2,70(r2)
 202477c:	1885883a 	add	r2,r3,r2
 2024780:	1007883a 	mov	r3,r2
 2024784:	e0bffd17 	ldw	r2,-12(fp)
 2024788:	10c0120d 	sth	r3,72(r2)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));

      pcb->rttest = 0;
 202478c:	e0bffd17 	ldw	r2,-12(fp)
 2024790:	10000f15 	stw	zero,60(r2)

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 2024794:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2024798:	10bfffcc 	andi	r2,r2,65535
 202479c:	10046b26 	beq	r2,zero,202594c <tcp_receive+0x198c>
 20247a0:	e0bffd17 	ldw	r2,-12(fp)
 20247a4:	10800617 	ldw	r2,24(r2)
 20247a8:	108001e8 	cmpgeui	r2,r2,7
 20247ac:	1004671e 	bne	r2,zero,202594c <tcp_receive+0x198c>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 20247b0:	e0bffd17 	ldw	r2,-12(fp)
 20247b4:	10c00b17 	ldw	r3,44(r2)
 20247b8:	d0a7ea17 	ldw	r2,-24664(gp)
 20247bc:	1885c83a 	sub	r2,r3,r2
 20247c0:	10bfffc4 	addi	r2,r2,-1
 20247c4:	10006116 	blt	r2,zero,202494c <tcp_receive+0x98c>
 20247c8:	e0bffd17 	ldw	r2,-12(fp)
 20247cc:	10c00b17 	ldw	r3,44(r2)
 20247d0:	d0a7ec8b 	ldhu	r2,-24654(gp)
 20247d4:	113fffcc 	andi	r4,r2,65535
 20247d8:	d0a7ea17 	ldw	r2,-24664(gp)
 20247dc:	2085883a 	add	r2,r4,r2
 20247e0:	1885c83a 	sub	r2,r3,r2
 20247e4:	10800044 	addi	r2,r2,1
 20247e8:	00805816 	blt	zero,r2,202494c <tcp_receive+0x98c>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
 20247ec:	00808174 	movhi	r2,517
 20247f0:	10b45f04 	addi	r2,r2,-11908
 20247f4:	10800117 	ldw	r2,4(r2)
 20247f8:	e0bfed15 	stw	r2,-76(fp)
      u32_t off32 = pcb->rcv_nxt - seqno;
 20247fc:	e0bffd17 	ldw	r2,-12(fp)
 2024800:	10c00b17 	ldw	r3,44(r2)
 2024804:	d0a7ea17 	ldw	r2,-24664(gp)
 2024808:	1885c83a 	sub	r2,r3,r2
 202480c:	e0bff515 	stw	r2,-44(fp)
      u16_t new_tot_len, off;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
      off = (u16_t)off32;
 2024810:	e0bff517 	ldw	r2,-44(fp)
 2024814:	e0bfee0d 	sth	r2,-72(fp)
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
      inseg.len -= off;
 2024818:	00808174 	movhi	r2,517
 202481c:	10b45f04 	addi	r2,r2,-11908
 2024820:	10c0020b 	ldhu	r3,8(r2)
 2024824:	e0bfee0b 	ldhu	r2,-72(fp)
 2024828:	1885c83a 	sub	r2,r3,r2
 202482c:	1007883a 	mov	r3,r2
 2024830:	00808174 	movhi	r2,517
 2024834:	10b45f04 	addi	r2,r2,-11908
 2024838:	10c0020d 	sth	r3,8(r2)
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
 202483c:	00808174 	movhi	r2,517
 2024840:	10b45f04 	addi	r2,r2,-11908
 2024844:	10800117 	ldw	r2,4(r2)
 2024848:	10c0020b 	ldhu	r3,8(r2)
 202484c:	e0bfee0b 	ldhu	r2,-72(fp)
 2024850:	1885c83a 	sub	r2,r3,r2
 2024854:	e0bff60d 	sth	r2,-40(fp)
      while (p->len < off) {
 2024858:	00000d06 	br	2024890 <tcp_receive+0x8d0>
        off -= p->len;
 202485c:	e0bfed17 	ldw	r2,-76(fp)
 2024860:	1080028b 	ldhu	r2,10(r2)
 2024864:	e0ffee0b 	ldhu	r3,-72(fp)
 2024868:	1885c83a 	sub	r2,r3,r2
 202486c:	e0bfee0d 	sth	r2,-72(fp)
        /* all pbufs up to and including this one have len==0, so tot_len is equal */
        p->tot_len = new_tot_len;
 2024870:	e0bfed17 	ldw	r2,-76(fp)
 2024874:	e0fff60b 	ldhu	r3,-40(fp)
 2024878:	10c0020d 	sth	r3,8(r2)
        p->len = 0;
 202487c:	e0bfed17 	ldw	r2,-76(fp)
 2024880:	1000028d 	sth	zero,10(r2)
        p = p->next;
 2024884:	e0bfed17 	ldw	r2,-76(fp)
 2024888:	10800017 	ldw	r2,0(r2)
 202488c:	e0bfed15 	stw	r2,-76(fp)
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
      off = (u16_t)off32;
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
      inseg.len -= off;
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
      while (p->len < off) {
 2024890:	e0bfed17 	ldw	r2,-76(fp)
 2024894:	1080028b 	ldhu	r2,10(r2)
 2024898:	10ffffcc 	andi	r3,r2,65535
 202489c:	e0bfee0b 	ldhu	r2,-72(fp)
 20248a0:	18bfee36 	bltu	r3,r2,202485c <__alt_mem_mem_0+0xfd00485c>
        p->tot_len = new_tot_len;
        p->len = 0;
        p = p->next;
      }
      /* cannot fail... */
      pbuf_remove_header(p, off);
 20248a4:	e0bfee0b 	ldhu	r2,-72(fp)
 20248a8:	100b883a 	mov	r5,r2
 20248ac:	e13fed17 	ldw	r4,-76(fp)
 20248b0:	201d06c0 	call	201d06c <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 20248b4:	00808174 	movhi	r2,517
 20248b8:	10b45f04 	addi	r2,r2,-11908
 20248bc:	10800417 	ldw	r2,16(r2)
 20248c0:	e0fffd17 	ldw	r3,-12(fp)
 20248c4:	18c00b17 	ldw	r3,44(r3)
 20248c8:	d0e7ea15 	stw	r3,-24664(gp)
 20248cc:	d0e7ea17 	ldw	r3,-24664(gp)
 20248d0:	19803fcc 	andi	r6,r3,255
 20248d4:	11000103 	ldbu	r4,4(r2)
 20248d8:	2008703a 	and	r4,r4,zero
 20248dc:	200b883a 	mov	r5,r4
 20248e0:	3009883a 	mov	r4,r6
 20248e4:	2908b03a 	or	r4,r5,r4
 20248e8:	11000105 	stb	r4,4(r2)
 20248ec:	1808d23a 	srli	r4,r3,8
 20248f0:	21803fcc 	andi	r6,r4,255
 20248f4:	11000143 	ldbu	r4,5(r2)
 20248f8:	2008703a 	and	r4,r4,zero
 20248fc:	200b883a 	mov	r5,r4
 2024900:	3009883a 	mov	r4,r6
 2024904:	2908b03a 	or	r4,r5,r4
 2024908:	11000145 	stb	r4,5(r2)
 202490c:	1808d43a 	srli	r4,r3,16
 2024910:	21803fcc 	andi	r6,r4,255
 2024914:	11000183 	ldbu	r4,6(r2)
 2024918:	2008703a 	and	r4,r4,zero
 202491c:	200b883a 	mov	r5,r4
 2024920:	3009883a 	mov	r4,r6
 2024924:	2908b03a 	or	r4,r5,r4
 2024928:	11000185 	stb	r4,6(r2)
 202492c:	180ad63a 	srli	r5,r3,24
 2024930:	10c001c3 	ldbu	r3,7(r2)
 2024934:	1806703a 	and	r3,r3,zero
 2024938:	1809883a 	mov	r4,r3
 202493c:	2807883a 	mov	r3,r5
 2024940:	20c6b03a 	or	r3,r4,r3
 2024944:	10c001c5 	stb	r3,7(r2)
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 2024948:	00000b06 	br	2024978 <tcp_receive+0x9b8>
      }
      /* cannot fail... */
      pbuf_remove_header(p, off);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    } else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 202494c:	d0e7ea17 	ldw	r3,-24664(gp)
 2024950:	e0bffd17 	ldw	r2,-12(fp)
 2024954:	10800b17 	ldw	r2,44(r2)
 2024958:	1885c83a 	sub	r2,r3,r2
 202495c:	1000060e 	bge	r2,zero,2024978 <tcp_receive+0x9b8>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 2024960:	e0bffd17 	ldw	r2,-12(fp)
 2024964:	1080088b 	ldhu	r2,34(r2)
 2024968:	10800094 	ori	r2,r2,2
 202496c:	1007883a 	mov	r3,r2
 2024970:	e0bffd17 	ldw	r2,-12(fp)
 2024974:	10c0088d 	sth	r3,34(r2)
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 2024978:	d0e7ea17 	ldw	r3,-24664(gp)
 202497c:	e0bffd17 	ldw	r2,-12(fp)
 2024980:	10800b17 	ldw	r2,44(r2)
 2024984:	1885c83a 	sub	r2,r3,r2
 2024988:	1003ec16 	blt	r2,zero,202593c <tcp_receive+0x197c>
 202498c:	d0e7ea17 	ldw	r3,-24664(gp)
 2024990:	e0bffd17 	ldw	r2,-12(fp)
 2024994:	11000b17 	ldw	r4,44(r2)
 2024998:	e0bffd17 	ldw	r2,-12(fp)
 202499c:	10800c0b 	ldhu	r2,48(r2)
 20249a0:	10bfffcc 	andi	r2,r2,65535
 20249a4:	2085883a 	add	r2,r4,r2
 20249a8:	1885c83a 	sub	r2,r3,r2
 20249ac:	10800044 	addi	r2,r2,1
 20249b0:	0083e216 	blt	zero,r2,202593c <tcp_receive+0x197c>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 20249b4:	e0bffd17 	ldw	r2,-12(fp)
 20249b8:	10c00b17 	ldw	r3,44(r2)
 20249bc:	d0a7ea17 	ldw	r2,-24664(gp)
 20249c0:	18824d1e 	bne	r3,r2,20252f8 <tcp_receive+0x1338>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 20249c4:	00808174 	movhi	r2,517
 20249c8:	10b45f04 	addi	r2,r2,-11908
 20249cc:	1400020b 	ldhu	r16,8(r2)
 20249d0:	00808174 	movhi	r2,517
 20249d4:	10b45f04 	addi	r2,r2,-11908
 20249d8:	10800417 	ldw	r2,16(r2)
 20249dc:	10c00303 	ldbu	r3,12(r2)
 20249e0:	10800343 	ldbu	r2,13(r2)
 20249e4:	1004923a 	slli	r2,r2,8
 20249e8:	10c4b03a 	or	r2,r2,r3
 20249ec:	10bfffcc 	andi	r2,r2,65535
 20249f0:	1009883a 	mov	r4,r2
 20249f4:	20394740 	call	2039474 <lwip_htons>
 20249f8:	10803fcc 	andi	r2,r2,255
 20249fc:	108000cc 	andi	r2,r2,3
 2024a00:	10000226 	beq	r2,zero,2024a0c <tcp_receive+0xa4c>
 2024a04:	00800044 	movi	r2,1
 2024a08:	00000106 	br	2024a10 <tcp_receive+0xa50>
 2024a0c:	0005883a 	mov	r2,zero
 2024a10:	8085883a 	add	r2,r16,r2
 2024a14:	d0a7ec8d 	sth	r2,-24654(gp)

        if (tcplen > pcb->rcv_wnd) {
 2024a18:	e0bffd17 	ldw	r2,-12(fp)
 2024a1c:	10c00c0b 	ldhu	r3,48(r2)
 2024a20:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2024a24:	18ffffcc 	andi	r3,r3,65535
 2024a28:	10bfffcc 	andi	r2,r2,65535
 2024a2c:	1880752e 	bgeu	r3,r2,2024c04 <tcp_receive+0xc44>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 2024a30:	00808174 	movhi	r2,517
 2024a34:	10b45f04 	addi	r2,r2,-11908
 2024a38:	10800417 	ldw	r2,16(r2)
 2024a3c:	10c00303 	ldbu	r3,12(r2)
 2024a40:	10800343 	ldbu	r2,13(r2)
 2024a44:	1004923a 	slli	r2,r2,8
 2024a48:	10c4b03a 	or	r2,r2,r3
 2024a4c:	10bfffcc 	andi	r2,r2,65535
 2024a50:	1009883a 	mov	r4,r2
 2024a54:	20394740 	call	2039474 <lwip_htons>
 2024a58:	10803fcc 	andi	r2,r2,255
 2024a5c:	1080004c 	andi	r2,r2,1
 2024a60:	10002f26 	beq	r2,zero,2024b20 <tcp_receive+0xb60>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 2024a64:	00808174 	movhi	r2,517
 2024a68:	10b45f04 	addi	r2,r2,-11908
 2024a6c:	14000417 	ldw	r16,16(r2)
 2024a70:	00808174 	movhi	r2,517
 2024a74:	10b45f04 	addi	r2,r2,-11908
 2024a78:	10800417 	ldw	r2,16(r2)
 2024a7c:	10c00303 	ldbu	r3,12(r2)
 2024a80:	10800343 	ldbu	r2,13(r2)
 2024a84:	1004923a 	slli	r2,r2,8
 2024a88:	10c4b03a 	or	r2,r2,r3
 2024a8c:	1007883a 	mov	r3,r2
 2024a90:	00b03fc4 	movi	r2,-16129
 2024a94:	1884703a 	and	r2,r3,r2
 2024a98:	1023883a 	mov	r17,r2
 2024a9c:	00808174 	movhi	r2,517
 2024aa0:	10b45f04 	addi	r2,r2,-11908
 2024aa4:	10800417 	ldw	r2,16(r2)
 2024aa8:	10c00303 	ldbu	r3,12(r2)
 2024aac:	10800343 	ldbu	r2,13(r2)
 2024ab0:	1004923a 	slli	r2,r2,8
 2024ab4:	10c4b03a 	or	r2,r2,r3
 2024ab8:	10bfffcc 	andi	r2,r2,65535
 2024abc:	1009883a 	mov	r4,r2
 2024ac0:	20394740 	call	2039474 <lwip_htons>
 2024ac4:	10bfffcc 	andi	r2,r2,65535
 2024ac8:	10800f8c 	andi	r2,r2,62
 2024acc:	1009883a 	mov	r4,r2
 2024ad0:	20394740 	call	2039474 <lwip_htons>
 2024ad4:	8884b03a 	or	r2,r17,r2
 2024ad8:	100b883a 	mov	r5,r2
 2024adc:	28bfffcc 	andi	r2,r5,65535
 2024ae0:	11003fcc 	andi	r4,r2,255
 2024ae4:	80800303 	ldbu	r2,12(r16)
 2024ae8:	1004703a 	and	r2,r2,zero
 2024aec:	1007883a 	mov	r3,r2
 2024af0:	2005883a 	mov	r2,r4
 2024af4:	1884b03a 	or	r2,r3,r2
 2024af8:	80800305 	stb	r2,12(r16)
 2024afc:	28bfffcc 	andi	r2,r5,65535
 2024b00:	1004d23a 	srli	r2,r2,8
 2024b04:	113fffcc 	andi	r4,r2,65535
 2024b08:	80800343 	ldbu	r2,13(r16)
 2024b0c:	1004703a 	and	r2,r2,zero
 2024b10:	1007883a 	mov	r3,r2
 2024b14:	2005883a 	mov	r2,r4
 2024b18:	1884b03a 	or	r2,r3,r2
 2024b1c:	80800345 	stb	r2,13(r16)
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
 2024b20:	e0bffd17 	ldw	r2,-12(fp)
 2024b24:	10c00c0b 	ldhu	r3,48(r2)
 2024b28:	00808174 	movhi	r2,517
 2024b2c:	10b45f04 	addi	r2,r2,-11908
 2024b30:	10c0020d 	sth	r3,8(r2)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 2024b34:	00808174 	movhi	r2,517
 2024b38:	10b45f04 	addi	r2,r2,-11908
 2024b3c:	10800417 	ldw	r2,16(r2)
 2024b40:	10c00303 	ldbu	r3,12(r2)
 2024b44:	10800343 	ldbu	r2,13(r2)
 2024b48:	1004923a 	slli	r2,r2,8
 2024b4c:	10c4b03a 	or	r2,r2,r3
 2024b50:	10bfffcc 	andi	r2,r2,65535
 2024b54:	1009883a 	mov	r4,r2
 2024b58:	20394740 	call	2039474 <lwip_htons>
 2024b5c:	10803fcc 	andi	r2,r2,255
 2024b60:	1080008c 	andi	r2,r2,2
 2024b64:	10000826 	beq	r2,zero,2024b88 <tcp_receive+0xbc8>
            inseg.len -= 1;
 2024b68:	00808174 	movhi	r2,517
 2024b6c:	10b45f04 	addi	r2,r2,-11908
 2024b70:	1080020b 	ldhu	r2,8(r2)
 2024b74:	10bfffc4 	addi	r2,r2,-1
 2024b78:	1007883a 	mov	r3,r2
 2024b7c:	00808174 	movhi	r2,517
 2024b80:	10b45f04 	addi	r2,r2,-11908
 2024b84:	10c0020d 	sth	r3,8(r2)
          }
          pbuf_realloc(inseg.p, inseg.len);
 2024b88:	00808174 	movhi	r2,517
 2024b8c:	10b45f04 	addi	r2,r2,-11908
 2024b90:	10c00117 	ldw	r3,4(r2)
 2024b94:	00808174 	movhi	r2,517
 2024b98:	10b45f04 	addi	r2,r2,-11908
 2024b9c:	1080020b 	ldhu	r2,8(r2)
 2024ba0:	10bfffcc 	andi	r2,r2,65535
 2024ba4:	100b883a 	mov	r5,r2
 2024ba8:	1809883a 	mov	r4,r3
 2024bac:	201cd3c0 	call	201cd3c <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 2024bb0:	00808174 	movhi	r2,517
 2024bb4:	10b45f04 	addi	r2,r2,-11908
 2024bb8:	1400020b 	ldhu	r16,8(r2)
 2024bbc:	00808174 	movhi	r2,517
 2024bc0:	10b45f04 	addi	r2,r2,-11908
 2024bc4:	10800417 	ldw	r2,16(r2)
 2024bc8:	10c00303 	ldbu	r3,12(r2)
 2024bcc:	10800343 	ldbu	r2,13(r2)
 2024bd0:	1004923a 	slli	r2,r2,8
 2024bd4:	10c4b03a 	or	r2,r2,r3
 2024bd8:	10bfffcc 	andi	r2,r2,65535
 2024bdc:	1009883a 	mov	r4,r2
 2024be0:	20394740 	call	2039474 <lwip_htons>
 2024be4:	10803fcc 	andi	r2,r2,255
 2024be8:	108000cc 	andi	r2,r2,3
 2024bec:	10000226 	beq	r2,zero,2024bf8 <tcp_receive+0xc38>
 2024bf0:	00800044 	movi	r2,1
 2024bf4:	00000106 	br	2024bfc <tcp_receive+0xc3c>
 2024bf8:	0005883a 	mov	r2,zero
 2024bfc:	8085883a 	add	r2,r16,r2
 2024c00:	d0a7ec8d 	sth	r2,-24654(gp)
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 2024c04:	e0bffd17 	ldw	r2,-12(fp)
 2024c08:	10801f17 	ldw	r2,124(r2)
 2024c0c:	1000ec26 	beq	r2,zero,2024fc0 <tcp_receive+0x1000>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 2024c10:	00808174 	movhi	r2,517
 2024c14:	10b45f04 	addi	r2,r2,-11908
 2024c18:	10800417 	ldw	r2,16(r2)
 2024c1c:	10c00303 	ldbu	r3,12(r2)
 2024c20:	10800343 	ldbu	r2,13(r2)
 2024c24:	1004923a 	slli	r2,r2,8
 2024c28:	10c4b03a 	or	r2,r2,r3
 2024c2c:	10bfffcc 	andi	r2,r2,65535
 2024c30:	1009883a 	mov	r4,r2
 2024c34:	20394740 	call	2039474 <lwip_htons>
 2024c38:	10803fcc 	andi	r2,r2,255
 2024c3c:	1080004c 	andi	r2,r2,1
 2024c40:	10000f26 	beq	r2,zero,2024c80 <tcp_receive+0xcc0>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 2024c44:	00000a06 	br	2024c70 <tcp_receive+0xcb0>
              struct tcp_seg *old_ooseq = pcb->ooseq;
 2024c48:	e0bffd17 	ldw	r2,-12(fp)
 2024c4c:	10801f17 	ldw	r2,124(r2)
 2024c50:	e0bff715 	stw	r2,-36(fp)
              pcb->ooseq = pcb->ooseq->next;
 2024c54:	e0bffd17 	ldw	r2,-12(fp)
 2024c58:	10801f17 	ldw	r2,124(r2)
 2024c5c:	10c00017 	ldw	r3,0(r2)
 2024c60:	e0bffd17 	ldw	r2,-12(fp)
 2024c64:	10c01f15 	stw	r3,124(r2)
              tcp_seg_free(old_ooseq);
 2024c68:	e13ff717 	ldw	r4,-36(fp)
 2024c6c:	2020ee00 	call	2020ee0 <tcp_seg_free>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 2024c70:	e0bffd17 	ldw	r2,-12(fp)
 2024c74:	10801f17 	ldw	r2,124(r2)
 2024c78:	103ff31e 	bne	r2,zero,2024c48 <__alt_mem_mem_0+0xfd004c48>
 2024c7c:	0000d006 	br	2024fc0 <tcp_receive+0x1000>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
 2024c80:	e0bffd17 	ldw	r2,-12(fp)
 2024c84:	10801f17 	ldw	r2,124(r2)
 2024c88:	e0bfef15 	stw	r2,-68(fp)
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 2024c8c:	00005506 	br	2024de4 <tcp_receive+0xe24>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              struct tcp_seg *tmp;
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 2024c90:	e0bfef17 	ldw	r2,-68(fp)
 2024c94:	10800417 	ldw	r2,16(r2)
 2024c98:	10c00303 	ldbu	r3,12(r2)
 2024c9c:	10800343 	ldbu	r2,13(r2)
 2024ca0:	1004923a 	slli	r2,r2,8
 2024ca4:	10c4b03a 	or	r2,r2,r3
 2024ca8:	10bfffcc 	andi	r2,r2,65535
 2024cac:	1009883a 	mov	r4,r2
 2024cb0:	20394740 	call	2039474 <lwip_htons>
 2024cb4:	10803fcc 	andi	r2,r2,255
 2024cb8:	1080004c 	andi	r2,r2,1
 2024cbc:	10004226 	beq	r2,zero,2024dc8 <tcp_receive+0xe08>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 2024cc0:	00808174 	movhi	r2,517
 2024cc4:	10b45f04 	addi	r2,r2,-11908
 2024cc8:	10800417 	ldw	r2,16(r2)
 2024ccc:	10c00303 	ldbu	r3,12(r2)
 2024cd0:	10800343 	ldbu	r2,13(r2)
 2024cd4:	1004923a 	slli	r2,r2,8
 2024cd8:	10c4b03a 	or	r2,r2,r3
 2024cdc:	10bfffcc 	andi	r2,r2,65535
 2024ce0:	1009883a 	mov	r4,r2
 2024ce4:	20394740 	call	2039474 <lwip_htons>
 2024ce8:	10803fcc 	andi	r2,r2,255
 2024cec:	1080008c 	andi	r2,r2,2
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              struct tcp_seg *tmp;
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 2024cf0:	1000351e 	bne	r2,zero,2024dc8 <tcp_receive+0xe08>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 2024cf4:	00808174 	movhi	r2,517
 2024cf8:	10b45f04 	addi	r2,r2,-11908
 2024cfc:	14000417 	ldw	r16,16(r2)
 2024d00:	00808174 	movhi	r2,517
 2024d04:	10b45f04 	addi	r2,r2,-11908
 2024d08:	10800417 	ldw	r2,16(r2)
 2024d0c:	10c00303 	ldbu	r3,12(r2)
 2024d10:	10800343 	ldbu	r2,13(r2)
 2024d14:	1004923a 	slli	r2,r2,8
 2024d18:	10c4b03a 	or	r2,r2,r3
 2024d1c:	1023883a 	mov	r17,r2
 2024d20:	01000044 	movi	r4,1
 2024d24:	20394740 	call	2039474 <lwip_htons>
 2024d28:	8884b03a 	or	r2,r17,r2
 2024d2c:	100b883a 	mov	r5,r2
 2024d30:	28bfffcc 	andi	r2,r5,65535
 2024d34:	11003fcc 	andi	r4,r2,255
 2024d38:	80800303 	ldbu	r2,12(r16)
 2024d3c:	1004703a 	and	r2,r2,zero
 2024d40:	1007883a 	mov	r3,r2
 2024d44:	2005883a 	mov	r2,r4
 2024d48:	1884b03a 	or	r2,r3,r2
 2024d4c:	80800305 	stb	r2,12(r16)
 2024d50:	28bfffcc 	andi	r2,r5,65535
 2024d54:	1004d23a 	srli	r2,r2,8
 2024d58:	113fffcc 	andi	r4,r2,65535
 2024d5c:	80800343 	ldbu	r2,13(r16)
 2024d60:	1004703a 	and	r2,r2,zero
 2024d64:	1007883a 	mov	r3,r2
 2024d68:	2005883a 	mov	r2,r4
 2024d6c:	1884b03a 	or	r2,r3,r2
 2024d70:	80800345 	stb	r2,13(r16)
                tcplen = TCP_TCPLEN(&inseg);
 2024d74:	00808174 	movhi	r2,517
 2024d78:	10b45f04 	addi	r2,r2,-11908
 2024d7c:	1400020b 	ldhu	r16,8(r2)
 2024d80:	00808174 	movhi	r2,517
 2024d84:	10b45f04 	addi	r2,r2,-11908
 2024d88:	10800417 	ldw	r2,16(r2)
 2024d8c:	10c00303 	ldbu	r3,12(r2)
 2024d90:	10800343 	ldbu	r2,13(r2)
 2024d94:	1004923a 	slli	r2,r2,8
 2024d98:	10c4b03a 	or	r2,r2,r3
 2024d9c:	10bfffcc 	andi	r2,r2,65535
 2024da0:	1009883a 	mov	r4,r2
 2024da4:	20394740 	call	2039474 <lwip_htons>
 2024da8:	10803fcc 	andi	r2,r2,255
 2024dac:	108000cc 	andi	r2,r2,3
 2024db0:	10000226 	beq	r2,zero,2024dbc <tcp_receive+0xdfc>
 2024db4:	00800044 	movi	r2,1
 2024db8:	00000106 	br	2024dc0 <tcp_receive+0xe00>
 2024dbc:	0005883a 	mov	r2,zero
 2024dc0:	8085883a 	add	r2,r16,r2
 2024dc4:	d0a7ec8d 	sth	r2,-24654(gp)
              }
              tmp = next;
 2024dc8:	e0bfef17 	ldw	r2,-68(fp)
 2024dcc:	e0bff815 	stw	r2,-32(fp)
              next = next->next;
 2024dd0:	e0bfef17 	ldw	r2,-68(fp)
 2024dd4:	10800017 	ldw	r2,0(r2)
 2024dd8:	e0bfef15 	stw	r2,-68(fp)
              tcp_seg_free(tmp);
 2024ddc:	e13ff817 	ldw	r4,-32(fp)
 2024de0:	2020ee00 	call	2020ee0 <tcp_seg_free>
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 2024de4:	e0bfef17 	ldw	r2,-68(fp)
 2024de8:	10001726 	beq	r2,zero,2024e48 <tcp_receive+0xe88>
                   TCP_SEQ_GEQ(seqno + tcplen,
 2024dec:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2024df0:	10ffffcc 	andi	r3,r2,65535
 2024df4:	d0a7ea17 	ldw	r2,-24664(gp)
 2024df8:	1887883a 	add	r3,r3,r2
 2024dfc:	e0bfef17 	ldw	r2,-68(fp)
 2024e00:	10800417 	ldw	r2,16(r2)
 2024e04:	11000103 	ldbu	r4,4(r2)
 2024e08:	11400143 	ldbu	r5,5(r2)
 2024e0c:	280a923a 	slli	r5,r5,8
 2024e10:	2908b03a 	or	r4,r5,r4
 2024e14:	11400183 	ldbu	r5,6(r2)
 2024e18:	280a943a 	slli	r5,r5,16
 2024e1c:	2908b03a 	or	r4,r5,r4
 2024e20:	108001c3 	ldbu	r2,7(r2)
 2024e24:	1004963a 	slli	r2,r2,24
 2024e28:	1104b03a 	or	r2,r2,r4
 2024e2c:	1009883a 	mov	r4,r2
 2024e30:	e0bfef17 	ldw	r2,-68(fp)
 2024e34:	1080020b 	ldhu	r2,8(r2)
 2024e38:	10bfffcc 	andi	r2,r2,65535
 2024e3c:	2085883a 	add	r2,r4,r2
 2024e40:	1885c83a 	sub	r2,r3,r2
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 2024e44:	103f920e 	bge	r2,zero,2024c90 <__alt_mem_mem_0+0xfd004c90>
              next = next->next;
              tcp_seg_free(tmp);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 2024e48:	e0bfef17 	ldw	r2,-68(fp)
 2024e4c:	10005926 	beq	r2,zero,2024fb4 <tcp_receive+0xff4>
                TCP_SEQ_GT(seqno + tcplen,
 2024e50:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2024e54:	10ffffcc 	andi	r3,r2,65535
 2024e58:	d0a7ea17 	ldw	r2,-24664(gp)
 2024e5c:	1887883a 	add	r3,r3,r2
 2024e60:	e0bfef17 	ldw	r2,-68(fp)
 2024e64:	10800417 	ldw	r2,16(r2)
 2024e68:	11000103 	ldbu	r4,4(r2)
 2024e6c:	11400143 	ldbu	r5,5(r2)
 2024e70:	280a923a 	slli	r5,r5,8
 2024e74:	2908b03a 	or	r4,r5,r4
 2024e78:	11400183 	ldbu	r5,6(r2)
 2024e7c:	280a943a 	slli	r5,r5,16
 2024e80:	2908b03a 	or	r4,r5,r4
 2024e84:	108001c3 	ldbu	r2,7(r2)
 2024e88:	1004963a 	slli	r2,r2,24
 2024e8c:	1104b03a 	or	r2,r2,r4
 2024e90:	1885c83a 	sub	r2,r3,r2
              next = next->next;
              tcp_seg_free(tmp);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 2024e94:	0080470e 	bge	zero,r2,2024fb4 <tcp_receive+0xff4>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 2024e98:	e0bfef17 	ldw	r2,-68(fp)
 2024e9c:	10800417 	ldw	r2,16(r2)
 2024ea0:	10c00103 	ldbu	r3,4(r2)
 2024ea4:	11000143 	ldbu	r4,5(r2)
 2024ea8:	2008923a 	slli	r4,r4,8
 2024eac:	20c6b03a 	or	r3,r4,r3
 2024eb0:	11000183 	ldbu	r4,6(r2)
 2024eb4:	2008943a 	slli	r4,r4,16
 2024eb8:	20c6b03a 	or	r3,r4,r3
 2024ebc:	108001c3 	ldbu	r2,7(r2)
 2024ec0:	1004963a 	slli	r2,r2,24
 2024ec4:	10c4b03a 	or	r2,r2,r3
 2024ec8:	1007883a 	mov	r3,r2
 2024ecc:	d0a7ea17 	ldw	r2,-24664(gp)
 2024ed0:	1885c83a 	sub	r2,r3,r2
 2024ed4:	1007883a 	mov	r3,r2
 2024ed8:	00808174 	movhi	r2,517
 2024edc:	10b45f04 	addi	r2,r2,-11908
 2024ee0:	10c0020d 	sth	r3,8(r2)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 2024ee4:	00808174 	movhi	r2,517
 2024ee8:	10b45f04 	addi	r2,r2,-11908
 2024eec:	10800417 	ldw	r2,16(r2)
 2024ef0:	10c00303 	ldbu	r3,12(r2)
 2024ef4:	10800343 	ldbu	r2,13(r2)
 2024ef8:	1004923a 	slli	r2,r2,8
 2024efc:	10c4b03a 	or	r2,r2,r3
 2024f00:	10bfffcc 	andi	r2,r2,65535
 2024f04:	1009883a 	mov	r4,r2
 2024f08:	20394740 	call	2039474 <lwip_htons>
 2024f0c:	10803fcc 	andi	r2,r2,255
 2024f10:	1080008c 	andi	r2,r2,2
 2024f14:	10000826 	beq	r2,zero,2024f38 <tcp_receive+0xf78>
                inseg.len -= 1;
 2024f18:	00808174 	movhi	r2,517
 2024f1c:	10b45f04 	addi	r2,r2,-11908
 2024f20:	1080020b 	ldhu	r2,8(r2)
 2024f24:	10bfffc4 	addi	r2,r2,-1
 2024f28:	1007883a 	mov	r3,r2
 2024f2c:	00808174 	movhi	r2,517
 2024f30:	10b45f04 	addi	r2,r2,-11908
 2024f34:	10c0020d 	sth	r3,8(r2)
              }
              pbuf_realloc(inseg.p, inseg.len);
 2024f38:	00808174 	movhi	r2,517
 2024f3c:	10b45f04 	addi	r2,r2,-11908
 2024f40:	10c00117 	ldw	r3,4(r2)
 2024f44:	00808174 	movhi	r2,517
 2024f48:	10b45f04 	addi	r2,r2,-11908
 2024f4c:	1080020b 	ldhu	r2,8(r2)
 2024f50:	10bfffcc 	andi	r2,r2,65535
 2024f54:	100b883a 	mov	r5,r2
 2024f58:	1809883a 	mov	r4,r3
 2024f5c:	201cd3c0 	call	201cd3c <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 2024f60:	00808174 	movhi	r2,517
 2024f64:	10b45f04 	addi	r2,r2,-11908
 2024f68:	1400020b 	ldhu	r16,8(r2)
 2024f6c:	00808174 	movhi	r2,517
 2024f70:	10b45f04 	addi	r2,r2,-11908
 2024f74:	10800417 	ldw	r2,16(r2)
 2024f78:	10c00303 	ldbu	r3,12(r2)
 2024f7c:	10800343 	ldbu	r2,13(r2)
 2024f80:	1004923a 	slli	r2,r2,8
 2024f84:	10c4b03a 	or	r2,r2,r3
 2024f88:	10bfffcc 	andi	r2,r2,65535
 2024f8c:	1009883a 	mov	r4,r2
 2024f90:	20394740 	call	2039474 <lwip_htons>
 2024f94:	10803fcc 	andi	r2,r2,255
 2024f98:	108000cc 	andi	r2,r2,3
 2024f9c:	10000226 	beq	r2,zero,2024fa8 <tcp_receive+0xfe8>
 2024fa0:	00800044 	movi	r2,1
 2024fa4:	00000106 	br	2024fac <tcp_receive+0xfec>
 2024fa8:	0005883a 	mov	r2,zero
 2024fac:	8085883a 	add	r2,r16,r2
 2024fb0:	d0a7ec8d 	sth	r2,-24654(gp)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 2024fb4:	e0bffd17 	ldw	r2,-12(fp)
 2024fb8:	e0ffef17 	ldw	r3,-68(fp)
 2024fbc:	10c01f15 	stw	r3,124(r2)
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 2024fc0:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2024fc4:	10ffffcc 	andi	r3,r2,65535
 2024fc8:	d0a7ea17 	ldw	r2,-24664(gp)
 2024fcc:	1887883a 	add	r3,r3,r2
 2024fd0:	e0bffd17 	ldw	r2,-12(fp)
 2024fd4:	10c00b15 	stw	r3,44(r2)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 2024fd8:	e0bffd17 	ldw	r2,-12(fp)
 2024fdc:	10c00c0b 	ldhu	r3,48(r2)
 2024fe0:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2024fe4:	1885c83a 	sub	r2,r3,r2
 2024fe8:	1007883a 	mov	r3,r2
 2024fec:	e0bffd17 	ldw	r2,-12(fp)
 2024ff0:	10c00c0d 	sth	r3,48(r2)

        tcp_update_rcv_ann_wnd(pcb);
 2024ff4:	e13ffd17 	ldw	r4,-12(fp)
 2024ff8:	201fc880 	call	201fc88 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 2024ffc:	00808174 	movhi	r2,517
 2025000:	10b45f04 	addi	r2,r2,-11908
 2025004:	10800117 	ldw	r2,4(r2)
 2025008:	1080020b 	ldhu	r2,8(r2)
 202500c:	10bfffcc 	andi	r2,r2,65535
 2025010:	10000726 	beq	r2,zero,2025030 <tcp_receive+0x1070>
          recv_data = inseg.p;
 2025014:	00808174 	movhi	r2,517
 2025018:	10b45f04 	addi	r2,r2,-11908
 202501c:	10800117 	ldw	r2,4(r2)
 2025020:	d0a7ee15 	stw	r2,-24648(gp)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 2025024:	00808174 	movhi	r2,517
 2025028:	10b45f04 	addi	r2,r2,-11908
 202502c:	10000115 	stw	zero,4(r2)
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 2025030:	00808174 	movhi	r2,517
 2025034:	10b45f04 	addi	r2,r2,-11908
 2025038:	10800417 	ldw	r2,16(r2)
 202503c:	10c00303 	ldbu	r3,12(r2)
 2025040:	10800343 	ldbu	r2,13(r2)
 2025044:	1004923a 	slli	r2,r2,8
 2025048:	10c4b03a 	or	r2,r2,r3
 202504c:	10bfffcc 	andi	r2,r2,65535
 2025050:	1009883a 	mov	r4,r2
 2025054:	20394740 	call	2039474 <lwip_htons>
 2025058:	10803fcc 	andi	r2,r2,255
 202505c:	1080004c 	andi	r2,r2,1
 2025060:	10007726 	beq	r2,zero,2025240 <tcp_receive+0x1280>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 2025064:	d0a7ed43 	ldbu	r2,-24651(gp)
 2025068:	10800814 	ori	r2,r2,32
 202506c:	d0a7ed45 	stb	r2,-24651(gp)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 2025070:	00007306 	br	2025240 <tcp_receive+0x1280>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          struct tcp_seg *cseg = pcb->ooseq;
 2025074:	e0bffd17 	ldw	r2,-12(fp)
 2025078:	10801f17 	ldw	r2,124(r2)
 202507c:	e0bff915 	stw	r2,-28(fp)
          seqno = pcb->ooseq->tcphdr->seqno;
 2025080:	e0bffd17 	ldw	r2,-12(fp)
 2025084:	10801f17 	ldw	r2,124(r2)
 2025088:	10800417 	ldw	r2,16(r2)
 202508c:	10c00103 	ldbu	r3,4(r2)
 2025090:	11000143 	ldbu	r4,5(r2)
 2025094:	2008923a 	slli	r4,r4,8
 2025098:	20c6b03a 	or	r3,r4,r3
 202509c:	11000183 	ldbu	r4,6(r2)
 20250a0:	2008943a 	slli	r4,r4,16
 20250a4:	20c6b03a 	or	r3,r4,r3
 20250a8:	108001c3 	ldbu	r2,7(r2)
 20250ac:	1004963a 	slli	r2,r2,24
 20250b0:	10c4b03a 	or	r2,r2,r3
 20250b4:	d0a7ea15 	stw	r2,-24664(gp)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 20250b8:	e0bff917 	ldw	r2,-28(fp)
 20250bc:	1080020b 	ldhu	r2,8(r2)
 20250c0:	143fffcc 	andi	r16,r2,65535
 20250c4:	e0bff917 	ldw	r2,-28(fp)
 20250c8:	10800417 	ldw	r2,16(r2)
 20250cc:	10c00303 	ldbu	r3,12(r2)
 20250d0:	10800343 	ldbu	r2,13(r2)
 20250d4:	1004923a 	slli	r2,r2,8
 20250d8:	10c4b03a 	or	r2,r2,r3
 20250dc:	10bfffcc 	andi	r2,r2,65535
 20250e0:	1009883a 	mov	r4,r2
 20250e4:	20394740 	call	2039474 <lwip_htons>
 20250e8:	10803fcc 	andi	r2,r2,255
 20250ec:	108000cc 	andi	r2,r2,3
 20250f0:	10000226 	beq	r2,zero,20250fc <tcp_receive+0x113c>
 20250f4:	00800044 	movi	r2,1
 20250f8:	00000106 	br	2025100 <tcp_receive+0x1140>
 20250fc:	0005883a 	mov	r2,zero
 2025100:	8085883a 	add	r2,r16,r2
 2025104:	e0fffd17 	ldw	r3,-12(fp)
 2025108:	18c00b17 	ldw	r3,44(r3)
 202510c:	1887883a 	add	r3,r3,r2
 2025110:	e0bffd17 	ldw	r2,-12(fp)
 2025114:	10c00b15 	stw	r3,44(r2)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 2025118:	e0bff917 	ldw	r2,-28(fp)
 202511c:	1080020b 	ldhu	r2,8(r2)
 2025120:	143fffcc 	andi	r16,r2,65535
 2025124:	e0bff917 	ldw	r2,-28(fp)
 2025128:	10800417 	ldw	r2,16(r2)
 202512c:	10c00303 	ldbu	r3,12(r2)
 2025130:	10800343 	ldbu	r2,13(r2)
 2025134:	1004923a 	slli	r2,r2,8
 2025138:	10c4b03a 	or	r2,r2,r3
 202513c:	10bfffcc 	andi	r2,r2,65535
 2025140:	1009883a 	mov	r4,r2
 2025144:	20394740 	call	2039474 <lwip_htons>
 2025148:	10803fcc 	andi	r2,r2,255
 202514c:	108000cc 	andi	r2,r2,3
 2025150:	10000226 	beq	r2,zero,202515c <tcp_receive+0x119c>
 2025154:	00800044 	movi	r2,1
 2025158:	00000106 	br	2025160 <tcp_receive+0x11a0>
 202515c:	0005883a 	mov	r2,zero
 2025160:	8087883a 	add	r3,r16,r2
 2025164:	e0bffd17 	ldw	r2,-12(fp)
 2025168:	10800c0b 	ldhu	r2,48(r2)
 202516c:	10c5c83a 	sub	r2,r2,r3
 2025170:	1007883a 	mov	r3,r2
 2025174:	e0bffd17 	ldw	r2,-12(fp)
 2025178:	10c00c0d 	sth	r3,48(r2)

          tcp_update_rcv_ann_wnd(pcb);
 202517c:	e13ffd17 	ldw	r4,-12(fp)
 2025180:	201fc880 	call	201fc88 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 2025184:	e0bff917 	ldw	r2,-28(fp)
 2025188:	10800117 	ldw	r2,4(r2)
 202518c:	1080020b 	ldhu	r2,8(r2)
 2025190:	10bfffcc 	andi	r2,r2,65535
 2025194:	10000e26 	beq	r2,zero,20251d0 <tcp_receive+0x1210>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            /* With window scaling, this can overflow recv_data->tot_len, but
               that's not a problem since we explicitly fix that before passing
               recv_data to the application. */
            if (recv_data) {
 2025198:	d0a7ee17 	ldw	r2,-24648(gp)
 202519c:	10000726 	beq	r2,zero,20251bc <tcp_receive+0x11fc>
              pbuf_cat(recv_data, cseg->p);
 20251a0:	d0e7ee17 	ldw	r3,-24648(gp)
 20251a4:	e0bff917 	ldw	r2,-28(fp)
 20251a8:	10800117 	ldw	r2,4(r2)
 20251ac:	100b883a 	mov	r5,r2
 20251b0:	1809883a 	mov	r4,r3
 20251b4:	201d4d40 	call	201d4d4 <pbuf_cat>
 20251b8:	00000306 	br	20251c8 <tcp_receive+0x1208>
            } else {
              recv_data = cseg->p;
 20251bc:	e0bff917 	ldw	r2,-28(fp)
 20251c0:	10800117 	ldw	r2,4(r2)
 20251c4:	d0a7ee15 	stw	r2,-24648(gp)
            }
            cseg->p = NULL;
 20251c8:	e0bff917 	ldw	r2,-28(fp)
 20251cc:	10000115 	stw	zero,4(r2)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 20251d0:	e0bff917 	ldw	r2,-28(fp)
 20251d4:	10800417 	ldw	r2,16(r2)
 20251d8:	10c00303 	ldbu	r3,12(r2)
 20251dc:	10800343 	ldbu	r2,13(r2)
 20251e0:	1004923a 	slli	r2,r2,8
 20251e4:	10c4b03a 	or	r2,r2,r3
 20251e8:	10bfffcc 	andi	r2,r2,65535
 20251ec:	1009883a 	mov	r4,r2
 20251f0:	20394740 	call	2039474 <lwip_htons>
 20251f4:	10803fcc 	andi	r2,r2,255
 20251f8:	1080004c 	andi	r2,r2,1
 20251fc:	10000a26 	beq	r2,zero,2025228 <tcp_receive+0x1268>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 2025200:	d0a7ed43 	ldbu	r2,-24651(gp)
 2025204:	10800814 	ori	r2,r2,32
 2025208:	d0a7ed45 	stb	r2,-24651(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 202520c:	e0bffd17 	ldw	r2,-12(fp)
 2025210:	10800617 	ldw	r2,24(r2)
 2025214:	10800118 	cmpnei	r2,r2,4
 2025218:	1000031e 	bne	r2,zero,2025228 <tcp_receive+0x1268>
              pcb->state = CLOSE_WAIT;
 202521c:	e0bffd17 	ldw	r2,-12(fp)
 2025220:	00c001c4 	movi	r3,7
 2025224:	10c00615 	stw	r3,24(r2)
            }
          }

          pcb->ooseq = cseg->next;
 2025228:	e0bff917 	ldw	r2,-28(fp)
 202522c:	10c00017 	ldw	r3,0(r2)
 2025230:	e0bffd17 	ldw	r2,-12(fp)
 2025234:	10c01f15 	stw	r3,124(r2)
          tcp_seg_free(cseg);
 2025238:	e13ff917 	ldw	r4,-28(fp)
 202523c:	2020ee00 	call	2020ee0 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 2025240:	e0bffd17 	ldw	r2,-12(fp)
 2025244:	10801f17 	ldw	r2,124(r2)
 2025248:	10001126 	beq	r2,zero,2025290 <tcp_receive+0x12d0>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 202524c:	e0bffd17 	ldw	r2,-12(fp)
 2025250:	10801f17 	ldw	r2,124(r2)
 2025254:	10800417 	ldw	r2,16(r2)
 2025258:	10c00103 	ldbu	r3,4(r2)
 202525c:	11000143 	ldbu	r4,5(r2)
 2025260:	2008923a 	slli	r4,r4,8
 2025264:	20c6b03a 	or	r3,r4,r3
 2025268:	11000183 	ldbu	r4,6(r2)
 202526c:	2008943a 	slli	r4,r4,16
 2025270:	20c6b03a 	or	r3,r4,r3
 2025274:	108001c3 	ldbu	r2,7(r2)
 2025278:	1004963a 	slli	r2,r2,24
 202527c:	10c4b03a 	or	r2,r2,r3
 2025280:	1007883a 	mov	r3,r2
 2025284:	e0bffd17 	ldw	r2,-12(fp)
 2025288:	10800b17 	ldw	r2,44(r2)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 202528c:	18bf7926 	beq	r3,r2,2025074 <__alt_mem_mem_0+0xfd005074>
#endif /* LWIP_TCP_SACK_OUT */
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 2025290:	e0bffd17 	ldw	r2,-12(fp)
 2025294:	1080088b 	ldhu	r2,34(r2)
 2025298:	10bfffcc 	andi	r2,r2,65535
 202529c:	1080004c 	andi	r2,r2,1
 20252a0:	10000e26 	beq	r2,zero,20252dc <tcp_receive+0x131c>
 20252a4:	e0bffd17 	ldw	r2,-12(fp)
 20252a8:	10c0088b 	ldhu	r3,34(r2)
 20252ac:	00bfff84 	movi	r2,-2
 20252b0:	1884703a 	and	r2,r3,r2
 20252b4:	1007883a 	mov	r3,r2
 20252b8:	e0bffd17 	ldw	r2,-12(fp)
 20252bc:	10c0088d 	sth	r3,34(r2)
 20252c0:	e0bffd17 	ldw	r2,-12(fp)
 20252c4:	1080088b 	ldhu	r2,34(r2)
 20252c8:	10800094 	ori	r2,r2,2
 20252cc:	1007883a 	mov	r3,r2
 20252d0:	e0bffd17 	ldw	r2,-12(fp)
 20252d4:	10c0088d 	sth	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 20252d8:	00019b06 	br	2025948 <tcp_receive+0x1988>
#endif /* LWIP_TCP_SACK_OUT */
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 20252dc:	e0bffd17 	ldw	r2,-12(fp)
 20252e0:	1080088b 	ldhu	r2,34(r2)
 20252e4:	10800054 	ori	r2,r2,1
 20252e8:	1007883a 	mov	r3,r2
 20252ec:	e0bffd17 	ldw	r2,-12(fp)
 20252f0:	10c0088d 	sth	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 20252f4:	00019406 	br	2025948 <tcp_receive+0x1988>
      } else {
        /* We get here if the incoming segment is out-of-sequence. */

#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 20252f8:	e0bffd17 	ldw	r2,-12(fp)
 20252fc:	10801f17 	ldw	r2,124(r2)
 2025300:	1000071e 	bne	r2,zero,2025320 <tcp_receive+0x1360>
          pcb->ooseq = tcp_seg_copy(&inseg);
 2025304:	01008174 	movhi	r4,517
 2025308:	21345f04 	addi	r4,r4,-11908
 202530c:	2020f800 	call	2020f80 <tcp_seg_copy>
 2025310:	1007883a 	mov	r3,r2
 2025314:	e0bffd17 	ldw	r2,-12(fp)
 2025318:	10c01f15 	stw	r3,124(r2)
 202531c:	00018406 	br	2025930 <tcp_receive+0x1970>
#if LWIP_TCP_SACK_OUT
          /* This is the left edge of the lowest possible SACK range.
             It may start before the newly received segment (possibly adjusted below). */
          u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
#endif /* LWIP_TCP_SACK_OUT */
          struct tcp_seg *next, *prev = NULL;
 2025320:	e03ff115 	stw	zero,-60(fp)
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 2025324:	e0bffd17 	ldw	r2,-12(fp)
 2025328:	10801f17 	ldw	r2,124(r2)
 202532c:	e0bff015 	stw	r2,-64(fp)
 2025330:	00017106 	br	20258f8 <tcp_receive+0x1938>
            if (seqno == next->tcphdr->seqno) {
 2025334:	e0bff017 	ldw	r2,-64(fp)
 2025338:	10800417 	ldw	r2,16(r2)
 202533c:	10c00103 	ldbu	r3,4(r2)
 2025340:	11000143 	ldbu	r4,5(r2)
 2025344:	2008923a 	slli	r4,r4,8
 2025348:	20c6b03a 	or	r3,r4,r3
 202534c:	11000183 	ldbu	r4,6(r2)
 2025350:	2008943a 	slli	r4,r4,16
 2025354:	20c6b03a 	or	r3,r4,r3
 2025358:	108001c3 	ldbu	r2,7(r2)
 202535c:	1004963a 	slli	r2,r2,24
 2025360:	10c4b03a 	or	r2,r2,r3
 2025364:	1007883a 	mov	r3,r2
 2025368:	d0a7ea17 	ldw	r2,-24664(gp)
 202536c:	18801b1e 	bne	r3,r2,20253dc <tcp_receive+0x141c>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 2025370:	00808174 	movhi	r2,517
 2025374:	10b45f04 	addi	r2,r2,-11908
 2025378:	1100020b 	ldhu	r4,8(r2)
 202537c:	e0bff017 	ldw	r2,-64(fp)
 2025380:	10c0020b 	ldhu	r3,8(r2)
 2025384:	20bfffcc 	andi	r2,r4,65535
 2025388:	18ffffcc 	andi	r3,r3,65535
 202538c:	18815d2e 	bgeu	r3,r2,2025904 <tcp_receive+0x1944>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 2025390:	01008174 	movhi	r4,517
 2025394:	21345f04 	addi	r4,r4,-11908
 2025398:	2020f800 	call	2020f80 <tcp_seg_copy>
 202539c:	e0bffc15 	stw	r2,-16(fp)
                if (cseg != NULL) {
 20253a0:	e0bffc17 	ldw	r2,-16(fp)
 20253a4:	10015926 	beq	r2,zero,202590c <tcp_receive+0x194c>
                  if (prev != NULL) {
 20253a8:	e0bff117 	ldw	r2,-60(fp)
 20253ac:	10000426 	beq	r2,zero,20253c0 <tcp_receive+0x1400>
                    prev->next = cseg;
 20253b0:	e0bff117 	ldw	r2,-60(fp)
 20253b4:	e0fffc17 	ldw	r3,-16(fp)
 20253b8:	10c00015 	stw	r3,0(r2)
 20253bc:	00000306 	br	20253cc <tcp_receive+0x140c>
                  } else {
                    pcb->ooseq = cseg;
 20253c0:	e0bffd17 	ldw	r2,-12(fp)
 20253c4:	e0fffc17 	ldw	r3,-16(fp)
 20253c8:	10c01f15 	stw	r3,124(r2)
                  }
                  tcp_oos_insert_segment(cseg, next);
 20253cc:	e17ff017 	ldw	r5,-64(fp)
 20253d0:	e13ffc17 	ldw	r4,-16(fp)
 20253d4:	2023c000 	call	2023c00 <tcp_oos_insert_segment>
                }
                break;
 20253d8:	00014c06 	br	202590c <tcp_receive+0x194c>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 20253dc:	e0bff117 	ldw	r2,-60(fp)
 20253e0:	10001c1e 	bne	r2,zero,2025454 <tcp_receive+0x1494>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 20253e4:	d0e7ea17 	ldw	r3,-24664(gp)
 20253e8:	e0bff017 	ldw	r2,-64(fp)
 20253ec:	10800417 	ldw	r2,16(r2)
 20253f0:	11000103 	ldbu	r4,4(r2)
 20253f4:	11400143 	ldbu	r5,5(r2)
 20253f8:	280a923a 	slli	r5,r5,8
 20253fc:	2908b03a 	or	r4,r5,r4
 2025400:	11400183 	ldbu	r5,6(r2)
 2025404:	280a943a 	slli	r5,r5,16
 2025408:	2908b03a 	or	r4,r5,r4
 202540c:	108001c3 	ldbu	r2,7(r2)
 2025410:	1004963a 	slli	r2,r2,24
 2025414:	1104b03a 	or	r2,r2,r4
 2025418:	1885c83a 	sub	r2,r3,r2
 202541c:	1000680e 	bge	r2,zero,20255c0 <tcp_receive+0x1600>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 2025420:	01008174 	movhi	r4,517
 2025424:	21345f04 	addi	r4,r4,-11908
 2025428:	2020f800 	call	2020f80 <tcp_seg_copy>
 202542c:	e0bffa15 	stw	r2,-24(fp)
                  if (cseg != NULL) {
 2025430:	e0bffa17 	ldw	r2,-24(fp)
 2025434:	10013726 	beq	r2,zero,2025914 <tcp_receive+0x1954>
                    pcb->ooseq = cseg;
 2025438:	e0bffd17 	ldw	r2,-12(fp)
 202543c:	e0fffa17 	ldw	r3,-24(fp)
 2025440:	10c01f15 	stw	r3,124(r2)
                    tcp_oos_insert_segment(cseg, next);
 2025444:	e17ff017 	ldw	r5,-64(fp)
 2025448:	e13ffa17 	ldw	r4,-24(fp)
 202544c:	2023c000 	call	2023c00 <tcp_oos_insert_segment>
                  }
                  break;
 2025450:	00013006 	br	2025914 <tcp_receive+0x1954>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
 2025454:	d0e7ea17 	ldw	r3,-24664(gp)
 2025458:	e0bff117 	ldw	r2,-60(fp)
 202545c:	10800417 	ldw	r2,16(r2)
 2025460:	11000103 	ldbu	r4,4(r2)
 2025464:	11400143 	ldbu	r5,5(r2)
 2025468:	280a923a 	slli	r5,r5,8
 202546c:	2908b03a 	or	r4,r5,r4
 2025470:	11400183 	ldbu	r5,6(r2)
 2025474:	280a943a 	slli	r5,r5,16
 2025478:	2908b03a 	or	r4,r5,r4
 202547c:	108001c3 	ldbu	r2,7(r2)
 2025480:	1004963a 	slli	r2,r2,24
 2025484:	1104b03a 	or	r2,r2,r4
 2025488:	1885c83a 	sub	r2,r3,r2
 202548c:	10bfffc4 	addi	r2,r2,-1
 2025490:	10004b16 	blt	r2,zero,20255c0 <tcp_receive+0x1600>
 2025494:	d0e7ea17 	ldw	r3,-24664(gp)
 2025498:	e0bff017 	ldw	r2,-64(fp)
 202549c:	10800417 	ldw	r2,16(r2)
 20254a0:	11000103 	ldbu	r4,4(r2)
 20254a4:	11400143 	ldbu	r5,5(r2)
 20254a8:	280a923a 	slli	r5,r5,8
 20254ac:	2908b03a 	or	r4,r5,r4
 20254b0:	11400183 	ldbu	r5,6(r2)
 20254b4:	280a943a 	slli	r5,r5,16
 20254b8:	2908b03a 	or	r4,r5,r4
 20254bc:	108001c3 	ldbu	r2,7(r2)
 20254c0:	1004963a 	slli	r2,r2,24
 20254c4:	1104b03a 	or	r2,r2,r4
 20254c8:	1885c83a 	sub	r2,r3,r2
 20254cc:	10800044 	addi	r2,r2,1
 20254d0:	00803b16 	blt	zero,r2,20255c0 <tcp_receive+0x1600>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 20254d4:	01008174 	movhi	r4,517
 20254d8:	21345f04 	addi	r4,r4,-11908
 20254dc:	2020f800 	call	2020f80 <tcp_seg_copy>
 20254e0:	e0bffb15 	stw	r2,-20(fp)
                  if (cseg != NULL) {
 20254e4:	e0bffb17 	ldw	r2,-20(fp)
 20254e8:	10010c26 	beq	r2,zero,202591c <tcp_receive+0x195c>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 20254ec:	e0bff117 	ldw	r2,-60(fp)
 20254f0:	10800417 	ldw	r2,16(r2)
 20254f4:	10c00103 	ldbu	r3,4(r2)
 20254f8:	11000143 	ldbu	r4,5(r2)
 20254fc:	2008923a 	slli	r4,r4,8
 2025500:	20c6b03a 	or	r3,r4,r3
 2025504:	11000183 	ldbu	r4,6(r2)
 2025508:	2008943a 	slli	r4,r4,16
 202550c:	20c6b03a 	or	r3,r4,r3
 2025510:	108001c3 	ldbu	r2,7(r2)
 2025514:	1004963a 	slli	r2,r2,24
 2025518:	10c4b03a 	or	r2,r2,r3
 202551c:	1007883a 	mov	r3,r2
 2025520:	e0bff117 	ldw	r2,-60(fp)
 2025524:	1080020b 	ldhu	r2,8(r2)
 2025528:	10bfffcc 	andi	r2,r2,65535
 202552c:	1887883a 	add	r3,r3,r2
 2025530:	d0a7ea17 	ldw	r2,-24664(gp)
 2025534:	1885c83a 	sub	r2,r3,r2
 2025538:	00801a0e 	bge	zero,r2,20255a4 <tcp_receive+0x15e4>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 202553c:	d0a7ea17 	ldw	r2,-24664(gp)
 2025540:	100b883a 	mov	r5,r2
 2025544:	e0bff117 	ldw	r2,-60(fp)
 2025548:	10800417 	ldw	r2,16(r2)
 202554c:	10c00103 	ldbu	r3,4(r2)
 2025550:	11000143 	ldbu	r4,5(r2)
 2025554:	2008923a 	slli	r4,r4,8
 2025558:	20c6b03a 	or	r3,r4,r3
 202555c:	11000183 	ldbu	r4,6(r2)
 2025560:	2008943a 	slli	r4,r4,16
 2025564:	20c6b03a 	or	r3,r4,r3
 2025568:	108001c3 	ldbu	r2,7(r2)
 202556c:	1004963a 	slli	r2,r2,24
 2025570:	10c4b03a 	or	r2,r2,r3
 2025574:	2885c83a 	sub	r2,r5,r2
 2025578:	1007883a 	mov	r3,r2
 202557c:	e0bff117 	ldw	r2,-60(fp)
 2025580:	10c0020d 	sth	r3,8(r2)
                      pbuf_realloc(prev->p, prev->len);
 2025584:	e0bff117 	ldw	r2,-60(fp)
 2025588:	10c00117 	ldw	r3,4(r2)
 202558c:	e0bff117 	ldw	r2,-60(fp)
 2025590:	1080020b 	ldhu	r2,8(r2)
 2025594:	10bfffcc 	andi	r2,r2,65535
 2025598:	100b883a 	mov	r5,r2
 202559c:	1809883a 	mov	r4,r3
 20255a0:	201cd3c0 	call	201cd3c <pbuf_realloc>
                    }
                    prev->next = cseg;
 20255a4:	e0bff117 	ldw	r2,-60(fp)
 20255a8:	e0fffb17 	ldw	r3,-20(fp)
 20255ac:	10c00015 	stw	r3,0(r2)
                    tcp_oos_insert_segment(cseg, next);
 20255b0:	e17ff017 	ldw	r5,-64(fp)
 20255b4:	e13ffb17 	ldw	r4,-20(fp)
 20255b8:	2023c000 	call	2023c00 <tcp_oos_insert_segment>
                  }
                  break;
 20255bc:	0000d706 	br	202591c <tcp_receive+0x195c>
#endif /* LWIP_TCP_SACK_OUT */

              /* We don't use 'prev' below, so let's set it to current 'next'.
                 This way even if we break the loop below, 'prev' will be pointing
                 at the segment right in front of the newly added one. */
              prev = next;
 20255c0:	e0bff017 	ldw	r2,-64(fp)
 20255c4:	e0bff115 	stw	r2,-60(fp)

              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 20255c8:	e0bff017 	ldw	r2,-64(fp)
 20255cc:	10800017 	ldw	r2,0(r2)
 20255d0:	1000c61e 	bne	r2,zero,20258ec <tcp_receive+0x192c>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 20255d4:	d0e7ea17 	ldw	r3,-24664(gp)
 20255d8:	e0bff017 	ldw	r2,-64(fp)
 20255dc:	10800417 	ldw	r2,16(r2)
 20255e0:	11000103 	ldbu	r4,4(r2)
 20255e4:	11400143 	ldbu	r5,5(r2)
 20255e8:	280a923a 	slli	r5,r5,8
 20255ec:	2908b03a 	or	r4,r5,r4
 20255f0:	11400183 	ldbu	r5,6(r2)
 20255f4:	280a943a 	slli	r5,r5,16
 20255f8:	2908b03a 	or	r4,r5,r4
 20255fc:	108001c3 	ldbu	r2,7(r2)
 2025600:	1004963a 	slli	r2,r2,24
 2025604:	1104b03a 	or	r2,r2,r4
 2025608:	1885c83a 	sub	r2,r3,r2
              prev = next;

              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 202560c:	0080b70e 	bge	zero,r2,20258ec <tcp_receive+0x192c>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 2025610:	e0bff017 	ldw	r2,-64(fp)
 2025614:	10800417 	ldw	r2,16(r2)
 2025618:	10c00303 	ldbu	r3,12(r2)
 202561c:	10800343 	ldbu	r2,13(r2)
 2025620:	1004923a 	slli	r2,r2,8
 2025624:	10c4b03a 	or	r2,r2,r3
 2025628:	10bfffcc 	andi	r2,r2,65535
 202562c:	1009883a 	mov	r4,r2
 2025630:	20394740 	call	2039474 <lwip_htons>
 2025634:	10803fcc 	andi	r2,r2,255
 2025638:	1080004c 	andi	r2,r2,1
 202563c:	1000b91e 	bne	r2,zero,2025924 <tcp_receive+0x1964>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 2025640:	01008174 	movhi	r4,517
 2025644:	21345f04 	addi	r4,r4,-11908
 2025648:	2020f800 	call	2020f80 <tcp_seg_copy>
 202564c:	1007883a 	mov	r3,r2
 2025650:	e0bff017 	ldw	r2,-64(fp)
 2025654:	10c00015 	stw	r3,0(r2)
                if (next->next != NULL) {
 2025658:	e0bff017 	ldw	r2,-64(fp)
 202565c:	10800017 	ldw	r2,0(r2)
 2025660:	1000b226 	beq	r2,zero,202592c <tcp_receive+0x196c>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 2025664:	e0bff017 	ldw	r2,-64(fp)
 2025668:	10800417 	ldw	r2,16(r2)
 202566c:	10c00103 	ldbu	r3,4(r2)
 2025670:	11000143 	ldbu	r4,5(r2)
 2025674:	2008923a 	slli	r4,r4,8
 2025678:	20c6b03a 	or	r3,r4,r3
 202567c:	11000183 	ldbu	r4,6(r2)
 2025680:	2008943a 	slli	r4,r4,16
 2025684:	20c6b03a 	or	r3,r4,r3
 2025688:	108001c3 	ldbu	r2,7(r2)
 202568c:	1004963a 	slli	r2,r2,24
 2025690:	10c4b03a 	or	r2,r2,r3
 2025694:	1007883a 	mov	r3,r2
 2025698:	e0bff017 	ldw	r2,-64(fp)
 202569c:	1080020b 	ldhu	r2,8(r2)
 20256a0:	10bfffcc 	andi	r2,r2,65535
 20256a4:	1887883a 	add	r3,r3,r2
 20256a8:	d0a7ea17 	ldw	r2,-24664(gp)
 20256ac:	1885c83a 	sub	r2,r3,r2
 20256b0:	00801a0e 	bge	zero,r2,202571c <tcp_receive+0x175c>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 20256b4:	d0a7ea17 	ldw	r2,-24664(gp)
 20256b8:	100b883a 	mov	r5,r2
 20256bc:	e0bff017 	ldw	r2,-64(fp)
 20256c0:	10800417 	ldw	r2,16(r2)
 20256c4:	10c00103 	ldbu	r3,4(r2)
 20256c8:	11000143 	ldbu	r4,5(r2)
 20256cc:	2008923a 	slli	r4,r4,8
 20256d0:	20c6b03a 	or	r3,r4,r3
 20256d4:	11000183 	ldbu	r4,6(r2)
 20256d8:	2008943a 	slli	r4,r4,16
 20256dc:	20c6b03a 	or	r3,r4,r3
 20256e0:	108001c3 	ldbu	r2,7(r2)
 20256e4:	1004963a 	slli	r2,r2,24
 20256e8:	10c4b03a 	or	r2,r2,r3
 20256ec:	2885c83a 	sub	r2,r5,r2
 20256f0:	1007883a 	mov	r3,r2
 20256f4:	e0bff017 	ldw	r2,-64(fp)
 20256f8:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->p, next->len);
 20256fc:	e0bff017 	ldw	r2,-64(fp)
 2025700:	10c00117 	ldw	r3,4(r2)
 2025704:	e0bff017 	ldw	r2,-64(fp)
 2025708:	1080020b 	ldhu	r2,8(r2)
 202570c:	10bfffcc 	andi	r2,r2,65535
 2025710:	100b883a 	mov	r5,r2
 2025714:	1809883a 	mov	r4,r3
 2025718:	201cd3c0 	call	201cd3c <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 202571c:	d0a7ec8b 	ldhu	r2,-24654(gp)
 2025720:	10ffffcc 	andi	r3,r2,65535
 2025724:	d0a7ea17 	ldw	r2,-24664(gp)
 2025728:	1887883a 	add	r3,r3,r2
 202572c:	e0bffd17 	ldw	r2,-12(fp)
 2025730:	11000b17 	ldw	r4,44(r2)
 2025734:	e0bffd17 	ldw	r2,-12(fp)
 2025738:	10800c0b 	ldhu	r2,48(r2)
 202573c:	10bfffcc 	andi	r2,r2,65535
 2025740:	2085883a 	add	r2,r4,r2
 2025744:	1885c83a 	sub	r2,r3,r2
 2025748:	0080780e 	bge	zero,r2,202592c <tcp_receive+0x196c>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 202574c:	e0bff017 	ldw	r2,-64(fp)
 2025750:	10800017 	ldw	r2,0(r2)
 2025754:	10800417 	ldw	r2,16(r2)
 2025758:	10c00303 	ldbu	r3,12(r2)
 202575c:	10800343 	ldbu	r2,13(r2)
 2025760:	1004923a 	slli	r2,r2,8
 2025764:	10c4b03a 	or	r2,r2,r3
 2025768:	10bfffcc 	andi	r2,r2,65535
 202576c:	1009883a 	mov	r4,r2
 2025770:	20394740 	call	2039474 <lwip_htons>
 2025774:	10803fcc 	andi	r2,r2,255
 2025778:	1080004c 	andi	r2,r2,1
 202577c:	10002f26 	beq	r2,zero,202583c <tcp_receive+0x187c>
                      /* Must remove the FIN from the header as we're trimming
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 2025780:	e0bff017 	ldw	r2,-64(fp)
 2025784:	10800017 	ldw	r2,0(r2)
 2025788:	14000417 	ldw	r16,16(r2)
 202578c:	e0bff017 	ldw	r2,-64(fp)
 2025790:	10800017 	ldw	r2,0(r2)
 2025794:	10800417 	ldw	r2,16(r2)
 2025798:	10c00303 	ldbu	r3,12(r2)
 202579c:	10800343 	ldbu	r2,13(r2)
 20257a0:	1004923a 	slli	r2,r2,8
 20257a4:	10c4b03a 	or	r2,r2,r3
 20257a8:	1007883a 	mov	r3,r2
 20257ac:	00b03fc4 	movi	r2,-16129
 20257b0:	1884703a 	and	r2,r3,r2
 20257b4:	1023883a 	mov	r17,r2
 20257b8:	e0bff017 	ldw	r2,-64(fp)
 20257bc:	10800017 	ldw	r2,0(r2)
 20257c0:	10800417 	ldw	r2,16(r2)
 20257c4:	10c00303 	ldbu	r3,12(r2)
 20257c8:	10800343 	ldbu	r2,13(r2)
 20257cc:	1004923a 	slli	r2,r2,8
 20257d0:	10c4b03a 	or	r2,r2,r3
 20257d4:	10bfffcc 	andi	r2,r2,65535
 20257d8:	1009883a 	mov	r4,r2
 20257dc:	20394740 	call	2039474 <lwip_htons>
 20257e0:	10bfffcc 	andi	r2,r2,65535
 20257e4:	10800f8c 	andi	r2,r2,62
 20257e8:	1009883a 	mov	r4,r2
 20257ec:	20394740 	call	2039474 <lwip_htons>
 20257f0:	8884b03a 	or	r2,r17,r2
 20257f4:	100b883a 	mov	r5,r2
 20257f8:	28bfffcc 	andi	r2,r5,65535
 20257fc:	11003fcc 	andi	r4,r2,255
 2025800:	80800303 	ldbu	r2,12(r16)
 2025804:	1004703a 	and	r2,r2,zero
 2025808:	1007883a 	mov	r3,r2
 202580c:	2005883a 	mov	r2,r4
 2025810:	1884b03a 	or	r2,r3,r2
 2025814:	80800305 	stb	r2,12(r16)
 2025818:	28bfffcc 	andi	r2,r5,65535
 202581c:	1004d23a 	srli	r2,r2,8
 2025820:	113fffcc 	andi	r4,r2,65535
 2025824:	80800343 	ldbu	r2,13(r16)
 2025828:	1004703a 	and	r2,r2,zero
 202582c:	1007883a 	mov	r3,r2
 2025830:	2005883a 	mov	r2,r4
 2025834:	1884b03a 	or	r2,r3,r2
 2025838:	80800345 	stb	r2,13(r16)
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 202583c:	e0bff017 	ldw	r2,-64(fp)
 2025840:	10800017 	ldw	r2,0(r2)
 2025844:	e0fffd17 	ldw	r3,-12(fp)
 2025848:	18c00b17 	ldw	r3,44(r3)
 202584c:	1809883a 	mov	r4,r3
 2025850:	e0fffd17 	ldw	r3,-12(fp)
 2025854:	18c00c0b 	ldhu	r3,48(r3)
 2025858:	20c7883a 	add	r3,r4,r3
 202585c:	1809883a 	mov	r4,r3
 2025860:	d0e7ea17 	ldw	r3,-24664(gp)
 2025864:	20c7c83a 	sub	r3,r4,r3
 2025868:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->next->p, next->next->len);
 202586c:	e0bff017 	ldw	r2,-64(fp)
 2025870:	10800017 	ldw	r2,0(r2)
 2025874:	10c00117 	ldw	r3,4(r2)
 2025878:	e0bff017 	ldw	r2,-64(fp)
 202587c:	10800017 	ldw	r2,0(r2)
 2025880:	1080020b 	ldhu	r2,8(r2)
 2025884:	10bfffcc 	andi	r2,r2,65535
 2025888:	100b883a 	mov	r5,r2
 202588c:	1809883a 	mov	r4,r3
 2025890:	201cd3c0 	call	201cd3c <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 2025894:	e0bff017 	ldw	r2,-64(fp)
 2025898:	10800017 	ldw	r2,0(r2)
 202589c:	1400020b 	ldhu	r16,8(r2)
 20258a0:	e0bff017 	ldw	r2,-64(fp)
 20258a4:	10800017 	ldw	r2,0(r2)
 20258a8:	10800417 	ldw	r2,16(r2)
 20258ac:	10c00303 	ldbu	r3,12(r2)
 20258b0:	10800343 	ldbu	r2,13(r2)
 20258b4:	1004923a 	slli	r2,r2,8
 20258b8:	10c4b03a 	or	r2,r2,r3
 20258bc:	10bfffcc 	andi	r2,r2,65535
 20258c0:	1009883a 	mov	r4,r2
 20258c4:	20394740 	call	2039474 <lwip_htons>
 20258c8:	10803fcc 	andi	r2,r2,255
 20258cc:	108000cc 	andi	r2,r2,3
 20258d0:	10000226 	beq	r2,zero,20258dc <tcp_receive+0x191c>
 20258d4:	00800044 	movi	r2,1
 20258d8:	00000106 	br	20258e0 <tcp_receive+0x1920>
 20258dc:	0005883a 	mov	r2,zero
 20258e0:	8085883a 	add	r2,r16,r2
 20258e4:	d0a7ec8d 	sth	r2,-24654(gp)
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 20258e8:	00001006 	br	202592c <tcp_receive+0x196c>
          /* This is the left edge of the lowest possible SACK range.
             It may start before the newly received segment (possibly adjusted below). */
          u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
#endif /* LWIP_TCP_SACK_OUT */
          struct tcp_seg *next, *prev = NULL;
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 20258ec:	e0bff017 	ldw	r2,-64(fp)
 20258f0:	10800017 	ldw	r2,0(r2)
 20258f4:	e0bff015 	stw	r2,-64(fp)
 20258f8:	e0bff017 	ldw	r2,-64(fp)
 20258fc:	103e8d1e 	bne	r2,zero,2025334 <__alt_mem_mem_0+0xfd005334>
 2025900:	00000b06 	br	2025930 <tcp_receive+0x1970>
                break;
              } else {
                /* Either the lengths are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
 2025904:	0001883a 	nop
 2025908:	00000906 	br	2025930 <tcp_receive+0x1970>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
 202590c:	0001883a 	nop
 2025910:	00000706 	br	2025930 <tcp_receive+0x1970>
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
 2025914:	0001883a 	nop
 2025918:	00000506 	br	2025930 <tcp_receive+0x1970>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
 202591c:	0001883a 	nop
 2025920:	00000306 	br	2025930 <tcp_receive+0x1970>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
 2025924:	0001883a 	nop
 2025928:	00000106 	br	2025930 <tcp_receive+0x1970>
                    tcplen = TCP_TCPLEN(next->next);
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 202592c:	0001883a 	nop
#endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
#endif /* TCP_QUEUE_OOSEQ */

        /* We send the ACK packet after we've (potentially) dealt with SACKs,
           so they can be included in the acknowledgment. */
        tcp_send_empty_ack(pcb);
 2025930:	e13ffd17 	ldw	r4,-12(fp)
 2025934:	2028dd00 	call	2028dd0 <tcp_send_empty_ack>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 2025938:	00000306 	br	2025948 <tcp_receive+0x1988>
           so they can be included in the acknowledgment. */
        tcp_send_empty_ack(pcb);
      }
    } else {
      /* The incoming segment is not within the window. */
      tcp_send_empty_ack(pcb);
 202593c:	e13ffd17 	ldw	r4,-12(fp)
 2025940:	2028dd00 	call	2028dd0 <tcp_send_empty_ack>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 2025944:	00001706 	br	20259a4 <tcp_receive+0x19e4>
 2025948:	00001606 	br	20259a4 <tcp_receive+0x19e4>
      tcp_send_empty_ack(pcb);
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 202594c:	d0e7ea17 	ldw	r3,-24664(gp)
 2025950:	e0bffd17 	ldw	r2,-12(fp)
 2025954:	10800b17 	ldw	r2,44(r2)
 2025958:	1885c83a 	sub	r2,r3,r2
 202595c:	10000a16 	blt	r2,zero,2025988 <tcp_receive+0x19c8>
 2025960:	d0e7ea17 	ldw	r3,-24664(gp)
 2025964:	e0bffd17 	ldw	r2,-12(fp)
 2025968:	11000b17 	ldw	r4,44(r2)
 202596c:	e0bffd17 	ldw	r2,-12(fp)
 2025970:	10800c0b 	ldhu	r2,48(r2)
 2025974:	10bfffcc 	andi	r2,r2,65535
 2025978:	2085883a 	add	r2,r4,r2
 202597c:	1885c83a 	sub	r2,r3,r2
 2025980:	10800044 	addi	r2,r2,1
 2025984:	0080070e 	bge	zero,r2,20259a4 <tcp_receive+0x19e4>
      tcp_ack_now(pcb);
 2025988:	e0bffd17 	ldw	r2,-12(fp)
 202598c:	1080088b 	ldhu	r2,34(r2)
 2025990:	10800094 	ori	r2,r2,2
 2025994:	1007883a 	mov	r3,r2
 2025998:	e0bffd17 	ldw	r2,-12(fp)
 202599c:	10c0088d 	sth	r3,34(r2)
    }
  }
}
 20259a0:	00000006 	br	20259a4 <tcp_receive+0x19e4>
 20259a4:	0001883a 	nop
 20259a8:	e6fffe04 	addi	sp,fp,-8
 20259ac:	dfc00317 	ldw	ra,12(sp)
 20259b0:	df000217 	ldw	fp,8(sp)
 20259b4:	dc400117 	ldw	r17,4(sp)
 20259b8:	dc000017 	ldw	r16,0(sp)
 20259bc:	dec00404 	addi	sp,sp,16
 20259c0:	f800283a 	ret

020259c4 <tcp_get_next_optbyte>:

static u8_t
tcp_get_next_optbyte(void)
{
 20259c4:	defffd04 	addi	sp,sp,-12
 20259c8:	df000215 	stw	fp,8(sp)
 20259cc:	df000204 	addi	fp,sp,8
  u16_t optidx = tcp_optidx++;
 20259d0:	d0a7e90b 	ldhu	r2,-24668(gp)
 20259d4:	10c00044 	addi	r3,r2,1
 20259d8:	d0e7e90d 	sth	r3,-24668(gp)
 20259dc:	e0bffe0d 	sth	r2,-8(fp)
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 20259e0:	d0a7e817 	ldw	r2,-24672(gp)
 20259e4:	10000426 	beq	r2,zero,20259f8 <tcp_get_next_optbyte+0x34>
 20259e8:	d0a7e78b 	ldhu	r2,-24674(gp)
 20259ec:	e0fffe0b 	ldhu	r3,-8(fp)
 20259f0:	10bfffcc 	andi	r2,r2,65535
 20259f4:	1880082e 	bgeu	r3,r2,2025a18 <tcp_get_next_optbyte+0x54>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 20259f8:	d0a7e617 	ldw	r2,-24680(gp)
 20259fc:	10800504 	addi	r2,r2,20
 2025a00:	e0bfff15 	stw	r2,-4(fp)
    return opts[optidx];
 2025a04:	e0bffe0b 	ldhu	r2,-8(fp)
 2025a08:	e0ffff17 	ldw	r3,-4(fp)
 2025a0c:	1885883a 	add	r2,r3,r2
 2025a10:	10800003 	ldbu	r2,0(r2)
 2025a14:	00000906 	br	2025a3c <tcp_get_next_optbyte+0x78>
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
 2025a18:	e0bffe0b 	ldhu	r2,-8(fp)
 2025a1c:	1007883a 	mov	r3,r2
 2025a20:	d0a7e78b 	ldhu	r2,-24674(gp)
 2025a24:	1885c83a 	sub	r2,r3,r2
 2025a28:	e0bffe85 	stb	r2,-6(fp)
    return tcphdr_opt2[idx];
 2025a2c:	d0e7e817 	ldw	r3,-24672(gp)
 2025a30:	e0bffe83 	ldbu	r2,-6(fp)
 2025a34:	1885883a 	add	r2,r3,r2
 2025a38:	10800003 	ldbu	r2,0(r2)
  }
}
 2025a3c:	e037883a 	mov	sp,fp
 2025a40:	df000017 	ldw	fp,0(sp)
 2025a44:	dec00104 	addi	sp,sp,4
 2025a48:	f800283a 	ret

02025a4c <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 2025a4c:	defffb04 	addi	sp,sp,-20
 2025a50:	dfc00415 	stw	ra,16(sp)
 2025a54:	df000315 	stw	fp,12(sp)
 2025a58:	df000304 	addi	fp,sp,12
 2025a5c:	e13fff15 	stw	r4,-4(fp)
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 2025a60:	d0a7e70b 	ldhu	r2,-24676(gp)
 2025a64:	10bfffcc 	andi	r2,r2,65535
 2025a68:	10003e26 	beq	r2,zero,2025b64 <tcp_parseopt+0x118>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 2025a6c:	d027e90d 	sth	zero,-24668(gp)
 2025a70:	00003106 	br	2025b38 <tcp_parseopt+0xec>
      u8_t opt = tcp_get_next_optbyte();
 2025a74:	20259c40 	call	20259c4 <tcp_get_next_optbyte>
 2025a78:	e0bffd05 	stb	r2,-12(fp)
      switch (opt) {
 2025a7c:	e0bffd03 	ldbu	r2,-12(fp)
 2025a80:	10c00060 	cmpeqi	r3,r2,1
 2025a84:	18002c1e 	bne	r3,zero,2025b38 <tcp_parseopt+0xec>
 2025a88:	10c000a0 	cmpeqi	r3,r2,2
 2025a8c:	1800021e 	bne	r3,zero,2025a98 <tcp_parseopt+0x4c>
 2025a90:	10002f26 	beq	r2,zero,2025b50 <tcp_parseopt+0x104>
 2025a94:	00001e06 	br	2025b10 <tcp_parseopt+0xc4>
          /* NOP option. */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
          break;
        case LWIP_TCP_OPT_MSS:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 2025a98:	20259c40 	call	20259c4 <tcp_get_next_optbyte>
 2025a9c:	10803fcc 	andi	r2,r2,255
 2025aa0:	10800118 	cmpnei	r2,r2,4
 2025aa4:	10002c1e 	bne	r2,zero,2025b58 <tcp_parseopt+0x10c>
 2025aa8:	d0a7e90b 	ldhu	r2,-24668(gp)
 2025aac:	10bfffcc 	andi	r2,r2,65535
 2025ab0:	10800084 	addi	r2,r2,2
 2025ab4:	d0e7e70b 	ldhu	r3,-24676(gp)
 2025ab8:	18ffffcc 	andi	r3,r3,65535
 2025abc:	18802616 	blt	r3,r2,2025b58 <tcp_parseopt+0x10c>
            /* Bad length */
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            return;
          }
          /* An MSS option with the right option length. */
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
 2025ac0:	20259c40 	call	20259c4 <tcp_get_next_optbyte>
 2025ac4:	10803fcc 	andi	r2,r2,255
 2025ac8:	1004923a 	slli	r2,r2,8
 2025acc:	e0bffd8d 	sth	r2,-10(fp)
          mss |= tcp_get_next_optbyte();
 2025ad0:	20259c40 	call	20259c4 <tcp_get_next_optbyte>
 2025ad4:	10c03fcc 	andi	r3,r2,255
 2025ad8:	e0bffd8b 	ldhu	r2,-10(fp)
 2025adc:	1884b03a 	or	r2,r3,r2
 2025ae0:	e0bffd8d 	sth	r2,-10(fp)
          /* Limit the mss to the configured TCP_MSS and prevent division by zero */
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 2025ae4:	e0bffd8b 	ldhu	r2,-10(fp)
 2025ae8:	10816d68 	cmpgeui	r2,r2,1461
 2025aec:	1000041e 	bne	r2,zero,2025b00 <tcp_parseopt+0xb4>
 2025af0:	e0bffd8b 	ldhu	r2,-10(fp)
 2025af4:	10000226 	beq	r2,zero,2025b00 <tcp_parseopt+0xb4>
 2025af8:	e0bffd8b 	ldhu	r2,-10(fp)
 2025afc:	00000106 	br	2025b04 <tcp_parseopt+0xb8>
 2025b00:	00816d04 	movi	r2,1460
 2025b04:	e0ffff17 	ldw	r3,-4(fp)
 2025b08:	18800e8d 	sth	r2,58(r3)
          break;
 2025b0c:	00000a06 	br	2025b38 <tcp_parseopt+0xec>
          }
          break;
#endif /* LWIP_TCP_SACK_OUT */
        default:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
          data = tcp_get_next_optbyte();
 2025b10:	20259c40 	call	20259c4 <tcp_get_next_optbyte>
 2025b14:	e0bffe05 	stb	r2,-8(fp)
          if (data < 2) {
 2025b18:	e0bffe03 	ldbu	r2,-8(fp)
 2025b1c:	108000a8 	cmpgeui	r2,r2,2
 2025b20:	10000f26 	beq	r2,zero,2025b60 <tcp_parseopt+0x114>
               and we don't process them further. */
            return;
          }
          /* All other options have a length field, so that we easily
             can skip past them. */
          tcp_optidx += data - 2;
 2025b24:	e0fffe03 	ldbu	r3,-8(fp)
 2025b28:	d0a7e90b 	ldhu	r2,-24668(gp)
 2025b2c:	1885883a 	add	r2,r3,r2
 2025b30:	10bfff84 	addi	r2,r2,-2
 2025b34:	d0a7e90d 	sth	r2,-24668(gp)

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 2025b38:	d0e7e90b 	ldhu	r3,-24668(gp)
 2025b3c:	d0a7e70b 	ldhu	r2,-24676(gp)
 2025b40:	18ffffcc 	andi	r3,r3,65535
 2025b44:	10bfffcc 	andi	r2,r2,65535
 2025b48:	18bfca36 	bltu	r3,r2,2025a74 <__alt_mem_mem_0+0xfd005a74>
 2025b4c:	00000506 	br	2025b64 <tcp_parseopt+0x118>
      u8_t opt = tcp_get_next_optbyte();
      switch (opt) {
        case LWIP_TCP_OPT_EOL:
          /* End of options. */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
          return;
 2025b50:	0001883a 	nop
 2025b54:	00000306 	br	2025b64 <tcp_parseopt+0x118>
        case LWIP_TCP_OPT_MSS:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
            /* Bad length */
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            return;
 2025b58:	0001883a 	nop
 2025b5c:	00000106 	br	2025b64 <tcp_parseopt+0x118>
          data = tcp_get_next_optbyte();
          if (data < 2) {
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            /* If the length field is zero, the options are malformed
               and we don't process them further. */
            return;
 2025b60:	0001883a 	nop
             can skip past them. */
          tcp_optidx += data - 2;
      }
    }
  }
}
 2025b64:	e037883a 	mov	sp,fp
 2025b68:	dfc00117 	ldw	ra,4(sp)
 2025b6c:	df000017 	ldw	fp,0(sp)
 2025b70:	dec00204 	addi	sp,sp,8
 2025b74:	f800283a 	ret

02025b78 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
 2025b78:	deffff04 	addi	sp,sp,-4
 2025b7c:	df000015 	stw	fp,0(sp)
 2025b80:	d839883a 	mov	fp,sp
  recv_flags |= TF_CLOSED;
 2025b84:	d0a7ed43 	ldbu	r2,-24651(gp)
 2025b88:	10800414 	ori	r2,r2,16
 2025b8c:	d0a7ed45 	stb	r2,-24651(gp)
}
 2025b90:	0001883a 	nop
 2025b94:	e037883a 	mov	sp,fp
 2025b98:	df000017 	ldw	fp,0(sp)
 2025b9c:	dec00104 	addi	sp,sp,4
 2025ba0:	f800283a 	ret

02025ba4 <tcp_route>:
static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);

/* tcp_route: common code that returns a fixed bound netif or calls ip_route */
static struct netif *
tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
{
 2025ba4:	defffb04 	addi	sp,sp,-20
 2025ba8:	dfc00415 	stw	ra,16(sp)
 2025bac:	df000315 	stw	fp,12(sp)
 2025bb0:	df000304 	addi	fp,sp,12
 2025bb4:	e13ffd15 	stw	r4,-12(fp)
 2025bb8:	e17ffe15 	stw	r5,-8(fp)
 2025bbc:	e1bfff15 	stw	r6,-4(fp)
  LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */

  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
 2025bc0:	e0bffd17 	ldw	r2,-12(fp)
 2025bc4:	10000a26 	beq	r2,zero,2025bf0 <tcp_route+0x4c>
 2025bc8:	e0bffd17 	ldw	r2,-12(fp)
 2025bcc:	10800203 	ldbu	r2,8(r2)
 2025bd0:	10803fcc 	andi	r2,r2,255
 2025bd4:	10000626 	beq	r2,zero,2025bf0 <tcp_route+0x4c>
    return netif_get_by_index(pcb->netif_idx);
 2025bd8:	e0bffd17 	ldw	r2,-12(fp)
 2025bdc:	10800203 	ldbu	r2,8(r2)
 2025be0:	10803fcc 	andi	r2,r2,255
 2025be4:	1009883a 	mov	r4,r2
 2025be8:	201c62c0 	call	201c62c <netif_get_by_index>
 2025bec:	00000206 	br	2025bf8 <tcp_route+0x54>
  } else {
    return ip_route(src, dst);
 2025bf0:	e13fff17 	ldw	r4,-4(fp)
 2025bf4:	203b5c40 	call	203b5c4 <ip4_route>
  }
}
 2025bf8:	e037883a 	mov	sp,fp
 2025bfc:	dfc00117 	ldw	ra,4(sp)
 2025c00:	df000017 	ldw	fp,0(sp)
 2025c04:	dec00204 	addi	sp,sp,8
 2025c08:	f800283a 	ret

02025c0c <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optflags)
{
 2025c0c:	defff604 	addi	sp,sp,-40
 2025c10:	dfc00915 	stw	ra,36(sp)
 2025c14:	df000815 	stw	fp,32(sp)
 2025c18:	dc000715 	stw	r16,28(sp)
 2025c1c:	df000804 	addi	fp,sp,32
 2025c20:	e13ffa15 	stw	r4,-24(fp)
 2025c24:	e17ffb15 	stw	r5,-20(fp)
 2025c28:	3007883a 	mov	r3,r6
 2025c2c:	e1fffd15 	stw	r7,-12(fp)
 2025c30:	e0800217 	ldw	r2,8(fp)
 2025c34:	e0fffc05 	stb	r3,-16(fp)
 2025c38:	e0bffe05 	stb	r2,-8(fp)
  u8_t optlen;

  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 2025c3c:	e0bffe03 	ldbu	r2,-8(fp)
 2025c40:	1080004c 	andi	r2,r2,1
 2025c44:	10000226 	beq	r2,zero,2025c50 <tcp_create_segment+0x44>
 2025c48:	00800104 	movi	r2,4
 2025c4c:	00000106 	br	2025c54 <tcp_create_segment+0x48>
 2025c50:	0005883a 	mov	r2,zero
 2025c54:	e0bff805 	stb	r2,-32(fp)

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 2025c58:	01000104 	movi	r4,4
 2025c5c:	201b82c0 	call	201b82c <memp_malloc>
 2025c60:	e0bff915 	stw	r2,-28(fp)
 2025c64:	e0bff917 	ldw	r2,-28(fp)
 2025c68:	1000041e 	bne	r2,zero,2025c7c <tcp_create_segment+0x70>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 2025c6c:	e13ffb17 	ldw	r4,-20(fp)
 2025c70:	201d2f40 	call	201d2f4 <pbuf_free>
    return NULL;
 2025c74:	0005883a 	mov	r2,zero
 2025c78:	0000a406 	br	2025f0c <tcp_create_segment+0x300>
  }
  seg->flags = optflags;
 2025c7c:	e0bff917 	ldw	r2,-28(fp)
 2025c80:	e0fffe03 	ldbu	r3,-8(fp)
 2025c84:	10c00345 	stb	r3,13(r2)
  seg->next = NULL;
 2025c88:	e0bff917 	ldw	r2,-28(fp)
 2025c8c:	10000015 	stw	zero,0(r2)
  seg->p = p;
 2025c90:	e0bff917 	ldw	r2,-28(fp)
 2025c94:	e0fffb17 	ldw	r3,-20(fp)
 2025c98:	10c00115 	stw	r3,4(r2)
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
  seg->len = p->tot_len - optlen;
 2025c9c:	e0bffb17 	ldw	r2,-20(fp)
 2025ca0:	10c0020b 	ldhu	r3,8(r2)
 2025ca4:	e0bff803 	ldbu	r2,-32(fp)
 2025ca8:	1885c83a 	sub	r2,r3,r2
 2025cac:	1007883a 	mov	r3,r2
 2025cb0:	e0bff917 	ldw	r2,-28(fp)
 2025cb4:	10c0020d 	sth	r3,8(r2)
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
 2025cb8:	e0bff917 	ldw	r2,-28(fp)
 2025cbc:	1000028d 	sth	zero,10(r2)
  seg->chksum_swapped = 0;
 2025cc0:	e0bff917 	ldw	r2,-28(fp)
 2025cc4:	10000305 	stb	zero,12(r2)
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_add_header(p, TCP_HLEN)) {
 2025cc8:	01400504 	movi	r5,20
 2025ccc:	e13ffb17 	ldw	r4,-20(fp)
 2025cd0:	201cff40 	call	201cff4 <pbuf_add_header>
 2025cd4:	10803fcc 	andi	r2,r2,255
 2025cd8:	10000b26 	beq	r2,zero,2025d08 <tcp_create_segment+0xfc>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
 2025cdc:	008085f4 	movhi	r2,535
 2025ce0:	10bd8204 	addi	r2,r2,-2552
 2025ce4:	10805217 	ldw	r2,328(r2)
 2025ce8:	10c00044 	addi	r3,r2,1
 2025cec:	008085f4 	movhi	r2,535
 2025cf0:	10bd8204 	addi	r2,r2,-2552
 2025cf4:	10c05215 	stw	r3,328(r2)
    tcp_seg_free(seg);
 2025cf8:	e13ff917 	ldw	r4,-28(fp)
 2025cfc:	2020ee00 	call	2020ee0 <tcp_seg_free>
    return NULL;
 2025d00:	0005883a 	mov	r2,zero
 2025d04:	00008106 	br	2025f0c <tcp_create_segment+0x300>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 2025d08:	e0bff917 	ldw	r2,-28(fp)
 2025d0c:	10800117 	ldw	r2,4(r2)
 2025d10:	10c00117 	ldw	r3,4(r2)
 2025d14:	e0bff917 	ldw	r2,-28(fp)
 2025d18:	10c00415 	stw	r3,16(r2)
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 2025d1c:	e0bff917 	ldw	r2,-28(fp)
 2025d20:	14000417 	ldw	r16,16(r2)
 2025d24:	e0bffa17 	ldw	r2,-24(fp)
 2025d28:	1080078b 	ldhu	r2,30(r2)
 2025d2c:	10bfffcc 	andi	r2,r2,65535
 2025d30:	1009883a 	mov	r4,r2
 2025d34:	20394740 	call	2039474 <lwip_htons>
 2025d38:	100b883a 	mov	r5,r2
 2025d3c:	28bfffcc 	andi	r2,r5,65535
 2025d40:	11003fcc 	andi	r4,r2,255
 2025d44:	80800003 	ldbu	r2,0(r16)
 2025d48:	1004703a 	and	r2,r2,zero
 2025d4c:	1007883a 	mov	r3,r2
 2025d50:	2005883a 	mov	r2,r4
 2025d54:	1884b03a 	or	r2,r3,r2
 2025d58:	80800005 	stb	r2,0(r16)
 2025d5c:	28bfffcc 	andi	r2,r5,65535
 2025d60:	1004d23a 	srli	r2,r2,8
 2025d64:	113fffcc 	andi	r4,r2,65535
 2025d68:	80800043 	ldbu	r2,1(r16)
 2025d6c:	1004703a 	and	r2,r2,zero
 2025d70:	1007883a 	mov	r3,r2
 2025d74:	2005883a 	mov	r2,r4
 2025d78:	1884b03a 	or	r2,r3,r2
 2025d7c:	80800045 	stb	r2,1(r16)
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 2025d80:	e0bff917 	ldw	r2,-28(fp)
 2025d84:	14000417 	ldw	r16,16(r2)
 2025d88:	e0bffa17 	ldw	r2,-24(fp)
 2025d8c:	1080080b 	ldhu	r2,32(r2)
 2025d90:	10bfffcc 	andi	r2,r2,65535
 2025d94:	1009883a 	mov	r4,r2
 2025d98:	20394740 	call	2039474 <lwip_htons>
 2025d9c:	100b883a 	mov	r5,r2
 2025da0:	28bfffcc 	andi	r2,r5,65535
 2025da4:	11003fcc 	andi	r4,r2,255
 2025da8:	80800083 	ldbu	r2,2(r16)
 2025dac:	1004703a 	and	r2,r2,zero
 2025db0:	1007883a 	mov	r3,r2
 2025db4:	2005883a 	mov	r2,r4
 2025db8:	1884b03a 	or	r2,r3,r2
 2025dbc:	80800085 	stb	r2,2(r16)
 2025dc0:	28bfffcc 	andi	r2,r5,65535
 2025dc4:	1004d23a 	srli	r2,r2,8
 2025dc8:	113fffcc 	andi	r4,r2,65535
 2025dcc:	808000c3 	ldbu	r2,3(r16)
 2025dd0:	1004703a 	and	r2,r2,zero
 2025dd4:	1007883a 	mov	r3,r2
 2025dd8:	2005883a 	mov	r2,r4
 2025ddc:	1884b03a 	or	r2,r3,r2
 2025de0:	808000c5 	stb	r2,3(r16)
  seg->tcphdr->seqno = lwip_htonl(seqno);
 2025de4:	e0bff917 	ldw	r2,-28(fp)
 2025de8:	14000417 	ldw	r16,16(r2)
 2025dec:	e13ffd17 	ldw	r4,-12(fp)
 2025df0:	20394b00 	call	20394b0 <lwip_htonl>
 2025df4:	11403fcc 	andi	r5,r2,255
 2025df8:	80c00103 	ldbu	r3,4(r16)
 2025dfc:	1806703a 	and	r3,r3,zero
 2025e00:	1809883a 	mov	r4,r3
 2025e04:	2807883a 	mov	r3,r5
 2025e08:	20c6b03a 	or	r3,r4,r3
 2025e0c:	80c00105 	stb	r3,4(r16)
 2025e10:	1006d23a 	srli	r3,r2,8
 2025e14:	19403fcc 	andi	r5,r3,255
 2025e18:	80c00143 	ldbu	r3,5(r16)
 2025e1c:	1806703a 	and	r3,r3,zero
 2025e20:	1809883a 	mov	r4,r3
 2025e24:	2807883a 	mov	r3,r5
 2025e28:	20c6b03a 	or	r3,r4,r3
 2025e2c:	80c00145 	stb	r3,5(r16)
 2025e30:	1006d43a 	srli	r3,r2,16
 2025e34:	19403fcc 	andi	r5,r3,255
 2025e38:	80c00183 	ldbu	r3,6(r16)
 2025e3c:	1806703a 	and	r3,r3,zero
 2025e40:	1809883a 	mov	r4,r3
 2025e44:	2807883a 	mov	r3,r5
 2025e48:	20c6b03a 	or	r3,r4,r3
 2025e4c:	80c00185 	stb	r3,6(r16)
 2025e50:	1008d63a 	srli	r4,r2,24
 2025e54:	808001c3 	ldbu	r2,7(r16)
 2025e58:	1004703a 	and	r2,r2,zero
 2025e5c:	1007883a 	mov	r3,r2
 2025e60:	2005883a 	mov	r2,r4
 2025e64:	1884b03a 	or	r2,r3,r2
 2025e68:	808001c5 	stb	r2,7(r16)
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
 2025e6c:	e0bff917 	ldw	r2,-28(fp)
 2025e70:	14000417 	ldw	r16,16(r2)
 2025e74:	e0bff803 	ldbu	r2,-32(fp)
 2025e78:	1004d0ba 	srli	r2,r2,2
 2025e7c:	10803fcc 	andi	r2,r2,255
 2025e80:	10800144 	addi	r2,r2,5
 2025e84:	1004933a 	slli	r2,r2,12
 2025e88:	1007883a 	mov	r3,r2
 2025e8c:	e0bffc03 	ldbu	r2,-16(fp)
 2025e90:	1884b03a 	or	r2,r3,r2
 2025e94:	10bfffcc 	andi	r2,r2,65535
 2025e98:	1009883a 	mov	r4,r2
 2025e9c:	20394740 	call	2039474 <lwip_htons>
 2025ea0:	100b883a 	mov	r5,r2
 2025ea4:	28bfffcc 	andi	r2,r5,65535
 2025ea8:	11003fcc 	andi	r4,r2,255
 2025eac:	80800303 	ldbu	r2,12(r16)
 2025eb0:	1004703a 	and	r2,r2,zero
 2025eb4:	1007883a 	mov	r3,r2
 2025eb8:	2005883a 	mov	r2,r4
 2025ebc:	1884b03a 	or	r2,r3,r2
 2025ec0:	80800305 	stb	r2,12(r16)
 2025ec4:	28bfffcc 	andi	r2,r5,65535
 2025ec8:	1004d23a 	srli	r2,r2,8
 2025ecc:	113fffcc 	andi	r4,r2,65535
 2025ed0:	80800343 	ldbu	r2,13(r16)
 2025ed4:	1004703a 	and	r2,r2,zero
 2025ed8:	1007883a 	mov	r3,r2
 2025edc:	2005883a 	mov	r2,r4
 2025ee0:	1884b03a 	or	r2,r3,r2
 2025ee4:	80800345 	stb	r2,13(r16)
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 2025ee8:	e0bff917 	ldw	r2,-28(fp)
 2025eec:	10800417 	ldw	r2,16(r2)
 2025ef0:	10c00483 	ldbu	r3,18(r2)
 2025ef4:	1806703a 	and	r3,r3,zero
 2025ef8:	10c00485 	stb	r3,18(r2)
 2025efc:	10c004c3 	ldbu	r3,19(r2)
 2025f00:	1806703a 	and	r3,r3,zero
 2025f04:	10c004c5 	stb	r3,19(r2)
  return seg;
 2025f08:	e0bff917 	ldw	r2,-28(fp)
}
 2025f0c:	e6ffff04 	addi	sp,fp,-4
 2025f10:	dfc00217 	ldw	ra,8(sp)
 2025f14:	df000117 	ldw	fp,4(sp)
 2025f18:	dc000017 	ldw	r16,0(sp)
 2025f1c:	dec00304 	addi	sp,sp,12
 2025f20:	f800283a 	ret

02025f24 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, const struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 2025f24:	defff604 	addi	sp,sp,-40
 2025f28:	dfc00915 	stw	ra,36(sp)
 2025f2c:	df000815 	stw	fp,32(sp)
 2025f30:	df000804 	addi	fp,sp,32
 2025f34:	e13ffa15 	stw	r4,-24(fp)
 2025f38:	3009883a 	mov	r4,r6
 2025f3c:	e1fffd15 	stw	r7,-12(fp)
 2025f40:	e0c00317 	ldw	r3,12(fp)
 2025f44:	e0800417 	ldw	r2,16(fp)
 2025f48:	e17ffb0d 	sth	r5,-20(fp)
 2025f4c:	e13ffc0d 	sth	r4,-16(fp)
 2025f50:	e0fffe05 	stb	r3,-8(fp)
 2025f54:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *p;
  u16_t alloc = length;
 2025f58:	e0bffb0b 	ldhu	r2,-20(fp)
 2025f5c:	e0bff80d 	sth	r2,-32(fp)
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 2025f60:	e0fffb0b 	ldhu	r3,-20(fp)
 2025f64:	e0bffc0b 	ldhu	r2,-16(fp)
 2025f68:	1880182e 	bgeu	r3,r2,2025fcc <tcp_pbuf_prealloc+0xa8>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 2025f6c:	e0bffe03 	ldbu	r2,-8(fp)
 2025f70:	1080008c 	andi	r2,r2,2
 2025f74:	10000d1e 	bne	r2,zero,2025fac <tcp_pbuf_prealloc+0x88>
        (!(pcb->flags & TF_NODELAY) &&
 2025f78:	e0800217 	ldw	r2,8(fp)
 2025f7c:	1080088b 	ldhu	r2,34(r2)
 2025f80:	10bfffcc 	andi	r2,r2,65535
 2025f84:	1080100c 	andi	r2,r2,64
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 2025f88:	1000101e 	bne	r2,zero,2025fcc <tcp_pbuf_prealloc+0xa8>
        (!(pcb->flags & TF_NODELAY) &&
 2025f8c:	e0bfff03 	ldbu	r2,-4(fp)
 2025f90:	10000626 	beq	r2,zero,2025fac <tcp_pbuf_prealloc+0x88>
         (!first_seg ||
          pcb->unsent != NULL ||
 2025f94:	e0800217 	ldw	r2,8(fp)
 2025f98:	10801d17 	ldw	r2,116(r2)
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
 2025f9c:	1000031e 	bne	r2,zero,2025fac <tcp_pbuf_prealloc+0x88>
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
 2025fa0:	e0800217 	ldw	r2,8(fp)
 2025fa4:	10801e17 	ldw	r2,120(r2)
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
 2025fa8:	10000826 	beq	r2,zero,2025fcc <tcp_pbuf_prealloc+0xa8>
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 2025fac:	e0bffb0b 	ldhu	r2,-20(fp)
 2025fb0:	10c16dc4 	addi	r3,r2,1463
 2025fb4:	00bfff04 	movi	r2,-4
 2025fb8:	1884703a 	and	r2,r3,r2
 2025fbc:	e0fffc0b 	ldhu	r3,-16(fp)
 2025fc0:	1880012e 	bgeu	r3,r2,2025fc8 <tcp_pbuf_prealloc+0xa4>
 2025fc4:	1805883a 	mov	r2,r3
 2025fc8:	e0bff80d 	sth	r2,-32(fp)
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 2025fcc:	e0bff80b 	ldhu	r2,-32(fp)
 2025fd0:	0180a004 	movi	r6,640
 2025fd4:	100b883a 	mov	r5,r2
 2025fd8:	e13ffa17 	ldw	r4,-24(fp)
 2025fdc:	201c9740 	call	201c974 <pbuf_alloc>
 2025fe0:	e0bff915 	stw	r2,-28(fp)
  if (p == NULL) {
 2025fe4:	e0bff917 	ldw	r2,-28(fp)
 2025fe8:	1000021e 	bne	r2,zero,2025ff4 <tcp_pbuf_prealloc+0xd0>
    return NULL;
 2025fec:	0005883a 	mov	r2,zero
 2025ff0:	00000f06 	br	2026030 <tcp_pbuf_prealloc+0x10c>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 2025ff4:	e0bff917 	ldw	r2,-28(fp)
 2025ff8:	10c0028b 	ldhu	r3,10(r2)
 2025ffc:	e0bffb0b 	ldhu	r2,-20(fp)
 2026000:	1885c83a 	sub	r2,r3,r2
 2026004:	1007883a 	mov	r3,r2
 2026008:	e0bffd17 	ldw	r2,-12(fp)
 202600c:	10c0000d 	sth	r3,0(r2)
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 2026010:	e0bff917 	ldw	r2,-28(fp)
 2026014:	e0fffb0b 	ldhu	r3,-20(fp)
 2026018:	10c0020d 	sth	r3,8(r2)
 202601c:	e0bff917 	ldw	r2,-28(fp)
 2026020:	10c0020b 	ldhu	r3,8(r2)
 2026024:	e0bff917 	ldw	r2,-28(fp)
 2026028:	10c0028d 	sth	r3,10(r2)
  return p;
 202602c:	e0bff917 	ldw	r2,-28(fp)
}
 2026030:	e037883a 	mov	sp,fp
 2026034:	dfc00117 	ldw	ra,4(sp)
 2026038:	df000017 	ldw	fp,0(sp)
 202603c:	dec00204 	addi	sp,sp,8
 2026040:	f800283a 	ret

02026044 <tcp_seg_add_chksum>:
 * Called by tcp_write and tcp_split_unsent_seg.
 */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
 2026044:	defffa04 	addi	sp,sp,-24
 2026048:	df000515 	stw	fp,20(sp)
 202604c:	df000504 	addi	fp,sp,20
 2026050:	2007883a 	mov	r3,r4
 2026054:	2805883a 	mov	r2,r5
 2026058:	e1bffe15 	stw	r6,-8(fp)
 202605c:	e1ffff15 	stw	r7,-4(fp)
 2026060:	e0fffc0d 	sth	r3,-16(fp)
 2026064:	e0bffd0d 	sth	r2,-12(fp)
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
 2026068:	e0fffc0b 	ldhu	r3,-16(fp)
 202606c:	e0bffe17 	ldw	r2,-8(fp)
 2026070:	1080000b 	ldhu	r2,0(r2)
 2026074:	10bfffcc 	andi	r2,r2,65535
 2026078:	1885883a 	add	r2,r3,r2
 202607c:	e0bffb15 	stw	r2,-20(fp)
  chksum = FOLD_U32T(helper);
 2026080:	e0bffb17 	ldw	r2,-20(fp)
 2026084:	1004d43a 	srli	r2,r2,16
 2026088:	1007883a 	mov	r3,r2
 202608c:	e0bffb17 	ldw	r2,-20(fp)
 2026090:	1885883a 	add	r2,r3,r2
 2026094:	e0bffc0d 	sth	r2,-16(fp)
  if ((len & 1) != 0) {
 2026098:	e0bffd0b 	ldhu	r2,-12(fp)
 202609c:	1080004c 	andi	r2,r2,1
 20260a0:	10000e26 	beq	r2,zero,20260dc <tcp_seg_add_chksum+0x98>
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 20260a4:	e0bfff17 	ldw	r2,-4(fp)
 20260a8:	10800003 	ldbu	r2,0(r2)
 20260ac:	00c00044 	movi	r3,1
 20260b0:	1885c83a 	sub	r2,r3,r2
 20260b4:	1007883a 	mov	r3,r2
 20260b8:	e0bfff17 	ldw	r2,-4(fp)
 20260bc:	10c00005 	stb	r3,0(r2)
    chksum = SWAP_BYTES_IN_WORD(chksum);
 20260c0:	e0bffc0b 	ldhu	r2,-16(fp)
 20260c4:	1004923a 	slli	r2,r2,8
 20260c8:	1007883a 	mov	r3,r2
 20260cc:	e0bffc0b 	ldhu	r2,-16(fp)
 20260d0:	1004d23a 	srli	r2,r2,8
 20260d4:	1884b03a 	or	r2,r3,r2
 20260d8:	e0bffc0d 	sth	r2,-16(fp)
  }
  *seg_chksum = chksum;
 20260dc:	e0bffe17 	ldw	r2,-8(fp)
 20260e0:	e0fffc0b 	ldhu	r3,-16(fp)
 20260e4:	10c0000d 	sth	r3,0(r2)
}
 20260e8:	0001883a 	nop
 20260ec:	e037883a 	mov	sp,fp
 20260f0:	df000017 	ldw	fp,0(sp)
 20260f4:	dec00104 	addi	sp,sp,4
 20260f8:	f800283a 	ret

020260fc <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 20260fc:	defffd04 	addi	sp,sp,-12
 2026100:	df000215 	stw	fp,8(sp)
 2026104:	df000204 	addi	fp,sp,8
 2026108:	e13ffe15 	stw	r4,-8(fp)
 202610c:	2805883a 	mov	r2,r5
 2026110:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 2026114:	e0bffe17 	ldw	r2,-8(fp)
 2026118:	10800617 	ldw	r2,24(r2)
 202611c:	10800120 	cmpeqi	r2,r2,4
 2026120:	10000e1e 	bne	r2,zero,202615c <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
 2026124:	e0bffe17 	ldw	r2,-8(fp)
 2026128:	10800617 	ldw	r2,24(r2)
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 202612c:	108001e0 	cmpeqi	r2,r2,7
 2026130:	10000a1e 	bne	r2,zero,202615c <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
 2026134:	e0bffe17 	ldw	r2,-8(fp)
 2026138:	10800617 	ldw	r2,24(r2)
{
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
 202613c:	108000a0 	cmpeqi	r2,r2,2
 2026140:	1000061e 	bne	r2,zero,202615c <tcp_write_checks+0x60>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
 2026144:	e0bffe17 	ldw	r2,-8(fp)
 2026148:	10800617 	ldw	r2,24(r2)
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
 202614c:	108000e0 	cmpeqi	r2,r2,3
 2026150:	1000021e 	bne	r2,zero,202615c <tcp_write_checks+0x60>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 2026154:	00bffd44 	movi	r2,-11
 2026158:	00002606 	br	20261f4 <tcp_write_checks+0xf8>
  } else if (len == 0) {
 202615c:	e0bfff0b 	ldhu	r2,-4(fp)
 2026160:	1000021e 	bne	r2,zero,202616c <tcp_write_checks+0x70>
    return ERR_OK;
 2026164:	0005883a 	mov	r2,zero
 2026168:	00002206 	br	20261f4 <tcp_write_checks+0xf8>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 202616c:	e0bffe17 	ldw	r2,-8(fp)
 2026170:	10801b0b 	ldhu	r2,108(r2)
 2026174:	10ffffcc 	andi	r3,r2,65535
 2026178:	e0bfff0b 	ldhu	r2,-4(fp)
 202617c:	1880082e 	bgeu	r3,r2,20261a0 <tcp_write_checks+0xa4>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
                len, pcb->snd_buf));
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 2026180:	e0bffe17 	ldw	r2,-8(fp)
 2026184:	1080088b 	ldhu	r2,34(r2)
 2026188:	10802014 	ori	r2,r2,128
 202618c:	1007883a 	mov	r3,r2
 2026190:	e0bffe17 	ldw	r2,-8(fp)
 2026194:	10c0088d 	sth	r3,34(r2)
    return ERR_MEM;
 2026198:	00bfffc4 	movi	r2,-1
 202619c:	00001506 	br	20261f4 <tcp_write_checks+0xf8>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
 20261a0:	e0bffe17 	ldw	r2,-8(fp)
 20261a4:	10801b8b 	ldhu	r2,110(r2)
 20261a8:	10bfffcc 	andi	r2,r2,65535
 20261ac:	10800230 	cmpltui	r2,r2,8
 20261b0:	10000f1e 	bne	r2,zero,20261f0 <tcp_write_checks+0xf4>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
                pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
 20261b4:	008085f4 	movhi	r2,535
 20261b8:	10bd8204 	addi	r2,r2,-2552
 20261bc:	10804e17 	ldw	r2,312(r2)
 20261c0:	10c00044 	addi	r3,r2,1
 20261c4:	008085f4 	movhi	r2,535
 20261c8:	10bd8204 	addi	r2,r2,-2552
 20261cc:	10c04e15 	stw	r3,312(r2)
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 20261d0:	e0bffe17 	ldw	r2,-8(fp)
 20261d4:	1080088b 	ldhu	r2,34(r2)
 20261d8:	10802014 	ori	r2,r2,128
 20261dc:	1007883a 	mov	r3,r2
 20261e0:	e0bffe17 	ldw	r2,-8(fp)
 20261e4:	10c0088d 	sth	r3,34(r2)
    return ERR_MEM;
 20261e8:	00bfffc4 	movi	r2,-1
 20261ec:	00000106 	br	20261f4 <tcp_write_checks+0xf8>
                pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
                pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 20261f0:	0005883a 	mov	r2,zero
}
 20261f4:	e037883a 	mov	sp,fp
 20261f8:	df000017 	ldw	fp,0(sp)
 20261fc:	dec00104 	addi	sp,sp,4
 2026200:	f800283a 	ret

02026204 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 2026204:	deffe104 	addi	sp,sp,-124
 2026208:	dfc01e15 	stw	ra,120(sp)
 202620c:	df001d15 	stw	fp,116(sp)
 2026210:	dc401c15 	stw	r17,112(sp)
 2026214:	dc001b15 	stw	r16,108(sp)
 2026218:	df001d04 	addi	fp,sp,116
 202621c:	e13ffa15 	stw	r4,-24(fp)
 2026220:	e17ffb15 	stw	r5,-20(fp)
 2026224:	3007883a 	mov	r3,r6
 2026228:	3805883a 	mov	r2,r7
 202622c:	e0fffc0d 	sth	r3,-16(fp)
 2026230:	e0bffd05 	stb	r2,-12(fp)
  struct pbuf *concat_p = NULL;
 2026234:	e03fe615 	stw	zero,-104(fp)
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 2026238:	e03fe715 	stw	zero,-100(fp)
 202623c:	e03fe815 	stw	zero,-96(fp)
 2026240:	e03fe915 	stw	zero,-92(fp)
 2026244:	e03fea15 	stw	zero,-88(fp)
  u16_t pos = 0; /* position in 'arg' data */
 2026248:	e03feb0d 	sth	zero,-84(fp)
  u16_t queuelen;
  u8_t optlen;
  u8_t optflags = 0;
 202624c:	e03ff205 	stb	zero,-56(fp)
#if TCP_OVERSIZE
  u16_t oversize = 0;
 2026250:	e03ff70d 	sth	zero,-36(fp)
  u16_t oversize_used = 0;
 2026254:	e03fec0d 	sth	zero,-80(fp)
#if TCP_OVERSIZE_DBGCHECK
  u16_t oversize_add = 0;
#endif /* TCP_OVERSIZE_DBGCHECK*/
#endif /* TCP_OVERSIZE */
  u16_t extendlen = 0;
 2026258:	e03fec8d 	sth	zero,-78(fp)
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
 202625c:	e03ff78d 	sth	zero,-34(fp)
  u8_t concat_chksum_swapped = 0;
 2026260:	e03ff805 	stb	zero,-32(fp)
  u16_t concat_chksummed = 0;
 2026264:	e03fed0d 	sth	zero,-76(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  u16_t mss_local;

  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
 2026268:	e0bffa17 	ldw	r2,-24(fp)
 202626c:	1000021e 	bne	r2,zero,2026278 <tcp_write+0x74>
 2026270:	00bffc04 	movi	r2,-16
 2026274:	00028f06 	br	2026cb4 <tcp_write+0xab0>

  /* don't allocate segments bigger than half the maximum window we ever received */
  mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
 2026278:	e0bffa17 	ldw	r2,-24(fp)
 202627c:	10801a8b 	ldhu	r2,106(r2)
 2026280:	10bfffcc 	andi	r2,r2,65535
 2026284:	1004d07a 	srli	r2,r2,1
 2026288:	1007883a 	mov	r3,r2
 202628c:	e0bffa17 	ldw	r2,-24(fp)
 2026290:	11400e8b 	ldhu	r5,58(r2)
 2026294:	1805883a 	mov	r2,r3
 2026298:	10ffffcc 	andi	r3,r2,65535
 202629c:	293fffcc 	andi	r4,r5,65535
 20262a0:	20c0012e 	bgeu	r4,r3,20262a8 <tcp_write+0xa4>
 20262a4:	2805883a 	mov	r2,r5
 20262a8:	e0bff28d 	sth	r2,-54(fp)
  mss_local = mss_local ? mss_local : pcb->mss;
 20262ac:	e0bff28b 	ldhu	r2,-54(fp)
 20262b0:	1000031e 	bne	r2,zero,20262c0 <tcp_write+0xbc>
 20262b4:	e0bffa17 	ldw	r2,-24(fp)
 20262b8:	10800e8b 	ldhu	r2,58(r2)
 20262bc:	00000106 	br	20262c4 <tcp_write+0xc0>
 20262c0:	e0bff28b 	ldhu	r2,-54(fp)
 20262c4:	e0bff28d 	sth	r2,-54(fp)
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
                                 (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 20262c8:	e0bffb17 	ldw	r2,-20(fp)
 20262cc:	1000021e 	bne	r2,zero,20262d8 <tcp_write+0xd4>
 20262d0:	00bffc04 	movi	r2,-16
 20262d4:	00027706 	br	2026cb4 <tcp_write+0xab0>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
 20262d8:	e0bffc0b 	ldhu	r2,-16(fp)
 20262dc:	100b883a 	mov	r5,r2
 20262e0:	e13ffa17 	ldw	r4,-24(fp)
 20262e4:	20260fc0 	call	20260fc <tcp_write_checks>
 20262e8:	e0bff305 	stb	r2,-52(fp)
  if (err != ERR_OK) {
 20262ec:	e0bff307 	ldb	r2,-52(fp)
 20262f0:	10000226 	beq	r2,zero,20262fc <tcp_write+0xf8>
    return err;
 20262f4:	e0bff303 	ldbu	r2,-52(fp)
 20262f8:	00026e06 	br	2026cb4 <tcp_write+0xab0>
  }
  queuelen = pcb->snd_queuelen;
 20262fc:	e0bffa17 	ldw	r2,-24(fp)
 2026300:	10801b8b 	ldhu	r2,110(r2)
 2026304:	e0bfeb8d 	sth	r2,-82(fp)
    /* ensure that segments can hold at least one data byte... */
    mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
  } else
#endif /* LWIP_TCP_TIMESTAMPS */
  {
    optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 2026308:	e03ff345 	stb	zero,-51(fp)
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 202630c:	e0bffa17 	ldw	r2,-24(fp)
 2026310:	10801d17 	ldw	r2,116(r2)
 2026314:	10016a26 	beq	r2,zero,20268c0 <tcp_write+0x6bc>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 2026318:	e0bffa17 	ldw	r2,-24(fp)
 202631c:	10801d17 	ldw	r2,116(r2)
 2026320:	e0bfe715 	stw	r2,-100(fp)
 2026324:	00000306 	br	2026334 <tcp_write+0x130>
         last_unsent = last_unsent->next);
 2026328:	e0bfe717 	ldw	r2,-100(fp)
 202632c:	10800017 	ldw	r2,0(r2)
 2026330:	e0bfe715 	stw	r2,-100(fp)
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 2026334:	e0bfe717 	ldw	r2,-100(fp)
 2026338:	10800017 	ldw	r2,0(r2)
 202633c:	103ffa1e 	bne	r2,zero,2026328 <__alt_mem_mem_0+0xfd006328>
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
 2026340:	e0bfe717 	ldw	r2,-100(fp)
 2026344:	10800343 	ldbu	r2,13(r2)
 2026348:	10803fcc 	andi	r2,r2,255
 202634c:	1080004c 	andi	r2,r2,1
 2026350:	10000226 	beq	r2,zero,202635c <tcp_write+0x158>
 2026354:	00800104 	movi	r2,4
 2026358:	00000106 	br	2026360 <tcp_write+0x15c>
 202635c:	0005883a 	mov	r2,zero
 2026360:	e0bff38d 	sth	r2,-50(fp)
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
    space = mss_local - (last_unsent->len + unsent_optlen);
 2026364:	e0bfe717 	ldw	r2,-100(fp)
 2026368:	10c0020b 	ldhu	r3,8(r2)
 202636c:	e0bff38b 	ldhu	r2,-50(fp)
 2026370:	1885883a 	add	r2,r3,r2
 2026374:	1007883a 	mov	r3,r2
 2026378:	e0bff28b 	ldhu	r2,-54(fp)
 202637c:	10c5c83a 	sub	r2,r2,r3
 2026380:	e0bfed8d 	sth	r2,-74(fp)
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 2026384:	e0bffa17 	ldw	r2,-24(fp)
 2026388:	10801c0b 	ldhu	r2,112(r2)
 202638c:	e0bff70d 	sth	r2,-36(fp)
    if (oversize > 0) {
 2026390:	e0bff70b 	ldhu	r2,-36(fp)
 2026394:	10bfffcc 	andi	r2,r2,65535
 2026398:	10001a26 	beq	r2,zero,2026404 <tcp_write+0x200>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
      seg = last_unsent;
 202639c:	e0bfe717 	ldw	r2,-100(fp)
 20263a0:	e0bfe815 	stw	r2,-96(fp)
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 20263a4:	e17ff70b 	ldhu	r5,-36(fp)
 20263a8:	e0bffc0b 	ldhu	r2,-16(fp)
 20263ac:	10ffffcc 	andi	r3,r2,65535
 20263b0:	293fffcc 	andi	r4,r5,65535
 20263b4:	20c0012e 	bgeu	r4,r3,20263bc <tcp_write+0x1b8>
 20263b8:	2805883a 	mov	r2,r5
 20263bc:	e17fed8b 	ldhu	r5,-74(fp)
 20263c0:	10ffffcc 	andi	r3,r2,65535
 20263c4:	293fffcc 	andi	r4,r5,65535
 20263c8:	20c0012e 	bgeu	r4,r3,20263d0 <tcp_write+0x1cc>
 20263cc:	2805883a 	mov	r2,r5
 20263d0:	e0bfec0d 	sth	r2,-80(fp)
      pos += oversize_used;
 20263d4:	e0ffeb0b 	ldhu	r3,-84(fp)
 20263d8:	e0bfec0b 	ldhu	r2,-80(fp)
 20263dc:	1885883a 	add	r2,r3,r2
 20263e0:	e0bfeb0d 	sth	r2,-84(fp)
      oversize -= oversize_used;
 20263e4:	e0fff70b 	ldhu	r3,-36(fp)
 20263e8:	e0bfec0b 	ldhu	r2,-80(fp)
 20263ec:	1885c83a 	sub	r2,r3,r2
 20263f0:	e0bff70d 	sth	r2,-36(fp)
      space -= oversize_used;
 20263f4:	e0ffed8b 	ldhu	r3,-74(fp)
 20263f8:	e0bfec0b 	ldhu	r2,-80(fp)
 20263fc:	1885c83a 	sub	r2,r3,r2
 2026400:	e0bfed8d 	sth	r2,-74(fp)
     *
     * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
     * it after rexmit puts a segment from unacked to unsent and at this point,
     * oversize info is lost.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 2026404:	e0ffeb0b 	ldhu	r3,-84(fp)
 2026408:	e0bffc0b 	ldhu	r2,-16(fp)
 202640c:	18812c2e 	bgeu	r3,r2,20268c0 <tcp_write+0x6bc>
 2026410:	e0bfed8b 	ldhu	r2,-74(fp)
 2026414:	10012a26 	beq	r2,zero,20268c0 <tcp_write+0x6bc>
 2026418:	e0bfe717 	ldw	r2,-100(fp)
 202641c:	1080020b 	ldhu	r2,8(r2)
 2026420:	10bfffcc 	andi	r2,r2,65535
 2026424:	10012626 	beq	r2,zero,20268c0 <tcp_write+0x6bc>
      u16_t seglen = LWIP_MIN(space, len - pos);
 2026428:	e0fffc0b 	ldhu	r3,-16(fp)
 202642c:	e0bfeb0b 	ldhu	r2,-84(fp)
 2026430:	1885c83a 	sub	r2,r3,r2
 2026434:	e0ffed8b 	ldhu	r3,-74(fp)
 2026438:	1880010e 	bge	r3,r2,2026440 <tcp_write+0x23c>
 202643c:	1805883a 	mov	r2,r3
 2026440:	e0bff40d 	sth	r2,-48(fp)
      seg = last_unsent;
 2026444:	e0bfe717 	ldw	r2,-100(fp)
 2026448:	e0bfe815 	stw	r2,-96(fp)

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 202644c:	e0bffd03 	ldbu	r2,-12(fp)
 2026450:	1080004c 	andi	r2,r2,1
 2026454:	10002e26 	beq	r2,zero,2026510 <tcp_write+0x30c>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 2026458:	e13ff40b 	ldhu	r4,-48(fp)
 202645c:	e17fed8b 	ldhu	r5,-74(fp)
 2026460:	e0bffd03 	ldbu	r2,-12(fp)
 2026464:	e1bff704 	addi	r6,fp,-36
 2026468:	00c00044 	movi	r3,1
 202646c:	d8c00215 	stw	r3,8(sp)
 2026470:	d8800115 	stw	r2,4(sp)
 2026474:	e0bffa17 	ldw	r2,-24(fp)
 2026478:	d8800015 	stw	r2,0(sp)
 202647c:	300f883a 	mov	r7,r6
 2026480:	280d883a 	mov	r6,r5
 2026484:	200b883a 	mov	r5,r4
 2026488:	0009883a 	mov	r4,zero
 202648c:	2025f240 	call	2025f24 <tcp_pbuf_prealloc>
 2026490:	e0bfe615 	stw	r2,-104(fp)
 2026494:	e0bfe617 	ldw	r2,-104(fp)
 2026498:	1001e726 	beq	r2,zero,2026c38 <tcp_write+0xa34>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        oversize_add = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 202649c:	e0bfe617 	ldw	r2,-104(fp)
 20264a0:	11000117 	ldw	r4,4(r2)
 20264a4:	e0bfeb0b 	ldhu	r2,-84(fp)
 20264a8:	e0fffb17 	ldw	r3,-20(fp)
 20264ac:	1885883a 	add	r2,r3,r2
 20264b0:	e0fff40b 	ldhu	r3,-48(fp)
 20264b4:	180d883a 	mov	r6,r3
 20264b8:	100b883a 	mov	r5,r2
 20264bc:	203a3140 	call	203a314 <lwip_chksum_copy>
 20264c0:	10bfffcc 	andi	r2,r2,65535
 20264c4:	e0fff40b 	ldhu	r3,-48(fp)
 20264c8:	e17ff804 	addi	r5,fp,-32
 20264cc:	e13ff784 	addi	r4,fp,-34
 20264d0:	280f883a 	mov	r7,r5
 20264d4:	200d883a 	mov	r6,r4
 20264d8:	180b883a 	mov	r5,r3
 20264dc:	1009883a 	mov	r4,r2
 20264e0:	20260440 	call	2026044 <tcp_seg_add_chksum>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
 20264e4:	e0ffed0b 	ldhu	r3,-76(fp)
 20264e8:	e0bff40b 	ldhu	r2,-48(fp)
 20264ec:	1885883a 	add	r2,r3,r2
 20264f0:	e0bfed0d 	sth	r2,-76(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
        queuelen += pbuf_clen(concat_p);
 20264f4:	e13fe617 	ldw	r4,-104(fp)
 20264f8:	201d42c0 	call	201d42c <pbuf_clen>
 20264fc:	1007883a 	mov	r3,r2
 2026500:	e0bfeb8b 	ldhu	r2,-82(fp)
 2026504:	1885883a 	add	r2,r3,r2
 2026508:	e0bfeb8d 	sth	r2,-82(fp)
 202650c:	00004206 	br	2026618 <tcp_write+0x414>
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 2026510:	e0bfe717 	ldw	r2,-100(fp)
 2026514:	10800117 	ldw	r2,4(r2)
 2026518:	e0bfee15 	stw	r2,-72(fp)
 202651c:	00000306 	br	202652c <tcp_write+0x328>
 2026520:	e0bfee17 	ldw	r2,-72(fp)
 2026524:	10800017 	ldw	r2,0(r2)
 2026528:	e0bfee15 	stw	r2,-72(fp)
 202652c:	e0bfee17 	ldw	r2,-72(fp)
 2026530:	10800017 	ldw	r2,0(r2)
 2026534:	103ffa1e 	bne	r2,zero,2026520 <__alt_mem_mem_0+0xfd006520>
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 2026538:	e0bfee17 	ldw	r2,-72(fp)
 202653c:	10800303 	ldbu	r2,12(r2)
 2026540:	10803fcc 	andi	r2,r2,255
 2026544:	1080300c 	andi	r2,r2,192
 2026548:	10000b1e 	bne	r2,zero,2026578 <tcp_write+0x374>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 202654c:	e0bfee17 	ldw	r2,-72(fp)
 2026550:	10c00117 	ldw	r3,4(r2)
 2026554:	e0bfee17 	ldw	r2,-72(fp)
 2026558:	1080028b 	ldhu	r2,10(r2)
 202655c:	10bfffcc 	andi	r2,r2,65535
 2026560:	1887883a 	add	r3,r3,r2
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 2026564:	e0bffb17 	ldw	r2,-20(fp)
 2026568:	1880031e 	bne	r3,r2,2026578 <tcp_write+0x374>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
          extendlen = seglen;
 202656c:	e0bff40b 	ldhu	r2,-48(fp)
 2026570:	e0bfec8d 	sth	r2,-78(fp)
 2026574:	00001306 	br	20265c4 <tcp_write+0x3c0>
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 2026578:	e0bff40b 	ldhu	r2,-48(fp)
 202657c:	01800044 	movi	r6,1
 2026580:	100b883a 	mov	r5,r2
 2026584:	0009883a 	mov	r4,zero
 2026588:	201c9740 	call	201c974 <pbuf_alloc>
 202658c:	e0bfe615 	stw	r2,-104(fp)
 2026590:	e0bfe617 	ldw	r2,-104(fp)
 2026594:	1001aa26 	beq	r2,zero,2026c40 <tcp_write+0xa3c>
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
            goto memerr;
          }
          /* reference the non-volatile payload data */
          ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
 2026598:	e0bfeb0b 	ldhu	r2,-84(fp)
 202659c:	e0fffb17 	ldw	r3,-20(fp)
 20265a0:	1887883a 	add	r3,r3,r2
 20265a4:	e0bfe617 	ldw	r2,-104(fp)
 20265a8:	10c00115 	stw	r3,4(r2)
          queuelen += pbuf_clen(concat_p);
 20265ac:	e13fe617 	ldw	r4,-104(fp)
 20265b0:	201d42c0 	call	201d42c <pbuf_clen>
 20265b4:	1007883a 	mov	r3,r2
 20265b8:	e0bfeb8b 	ldhu	r2,-82(fp)
 20265bc:	1885883a 	add	r2,r3,r2
 20265c0:	e0bfeb8d 	sth	r2,-82(fp)
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((const u8_t *)arg + pos, seglen), seglen,
 20265c4:	e0bfeb0b 	ldhu	r2,-84(fp)
 20265c8:	e0fffb17 	ldw	r3,-20(fp)
 20265cc:	1885883a 	add	r2,r3,r2
 20265d0:	e0fff40b 	ldhu	r3,-48(fp)
 20265d4:	180b883a 	mov	r5,r3
 20265d8:	1009883a 	mov	r4,r2
 20265dc:	203a1c40 	call	203a1c4 <inet_chksum>
 20265e0:	0084303a 	nor	r2,zero,r2
 20265e4:	10bfffcc 	andi	r2,r2,65535
 20265e8:	e0fff40b 	ldhu	r3,-48(fp)
 20265ec:	e17ff804 	addi	r5,fp,-32
 20265f0:	e13ff784 	addi	r4,fp,-34
 20265f4:	280f883a 	mov	r7,r5
 20265f8:	200d883a 	mov	r6,r4
 20265fc:	180b883a 	mov	r5,r3
 2026600:	1009883a 	mov	r4,r2
 2026604:	20260440 	call	2026044 <tcp_seg_add_chksum>
                           &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
 2026608:	e0ffed0b 	ldhu	r3,-76(fp)
 202660c:	e0bff40b 	ldhu	r2,-48(fp)
 2026610:	1885883a 	add	r2,r3,r2
 2026614:	e0bfed0d 	sth	r2,-76(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
      }

      pos += seglen;
 2026618:	e0ffeb0b 	ldhu	r3,-84(fp)
 202661c:	e0bff40b 	ldhu	r2,-48(fp)
 2026620:	1885883a 	add	r2,r3,r2
 2026624:	e0bfeb0d 	sth	r2,-84(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 2026628:	0000a506 	br	20268c0 <tcp_write+0x6bc>
    struct pbuf *p;
    u16_t left = len - pos;
 202662c:	e0fffc0b 	ldhu	r3,-16(fp)
 2026630:	e0bfeb0b 	ldhu	r2,-84(fp)
 2026634:	1885c83a 	sub	r2,r3,r2
 2026638:	e0bff48d 	sth	r2,-46(fp)
    u16_t max_len = mss_local - optlen;
 202663c:	e0bff343 	ldbu	r2,-51(fp)
 2026640:	e0fff28b 	ldhu	r3,-54(fp)
 2026644:	1885c83a 	sub	r2,r3,r2
 2026648:	e0bff50d 	sth	r2,-44(fp)
    u16_t seglen = LWIP_MIN(left, max_len);
 202664c:	e17ff48b 	ldhu	r5,-46(fp)
 2026650:	e0bff50b 	ldhu	r2,-44(fp)
 2026654:	10ffffcc 	andi	r3,r2,65535
 2026658:	293fffcc 	andi	r4,r5,65535
 202665c:	20c0012e 	bgeu	r4,r3,2026664 <tcp_write+0x460>
 2026660:	2805883a 	mov	r2,r5
 2026664:	e0bff58d 	sth	r2,-42(fp)
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
 2026668:	e03ff88d 	sth	zero,-30(fp)
    u8_t chksum_swapped = 0;
 202666c:	e03ff905 	stb	zero,-28(fp)
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 2026670:	e0bffd03 	ldbu	r2,-12(fp)
 2026674:	1080004c 	andi	r2,r2,1
 2026678:	10002b26 	beq	r2,zero,2026728 <tcp_write+0x524>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 202667c:	e0fff343 	ldbu	r3,-51(fp)
 2026680:	e0bff58b 	ldhu	r2,-42(fp)
 2026684:	1885883a 	add	r2,r3,r2
 2026688:	113fffcc 	andi	r4,r2,65535
 202668c:	e17ff28b 	ldhu	r5,-54(fp)
 2026690:	e0bffd03 	ldbu	r2,-12(fp)
 2026694:	e0ffea17 	ldw	r3,-88(fp)
 2026698:	1807003a 	cmpeq	r3,r3,zero
 202669c:	18c03fcc 	andi	r3,r3,255
 20266a0:	e1bff704 	addi	r6,fp,-36
 20266a4:	d8c00215 	stw	r3,8(sp)
 20266a8:	d8800115 	stw	r2,4(sp)
 20266ac:	e0bffa17 	ldw	r2,-24(fp)
 20266b0:	d8800015 	stw	r2,0(sp)
 20266b4:	300f883a 	mov	r7,r6
 20266b8:	280d883a 	mov	r6,r5
 20266bc:	200b883a 	mov	r5,r4
 20266c0:	01000e04 	movi	r4,56
 20266c4:	2025f240 	call	2025f24 <tcp_pbuf_prealloc>
 20266c8:	e0bfef15 	stw	r2,-68(fp)
 20266cc:	e0bfef17 	ldw	r2,-68(fp)
 20266d0:	10015d26 	beq	r2,zero,2026c48 <tcp_write+0xa44>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
 20266d4:	e0bfef17 	ldw	r2,-68(fp)
 20266d8:	10c00117 	ldw	r3,4(r2)
 20266dc:	e0bff343 	ldbu	r2,-51(fp)
 20266e0:	1889883a 	add	r4,r3,r2
 20266e4:	e0bfeb0b 	ldhu	r2,-84(fp)
 20266e8:	e0fffb17 	ldw	r3,-20(fp)
 20266ec:	1885883a 	add	r2,r3,r2
 20266f0:	e0fff58b 	ldhu	r3,-42(fp)
 20266f4:	180d883a 	mov	r6,r3
 20266f8:	100b883a 	mov	r5,r2
 20266fc:	203a3140 	call	203a314 <lwip_chksum_copy>
 2026700:	10bfffcc 	andi	r2,r2,65535
 2026704:	e0fff58b 	ldhu	r3,-42(fp)
 2026708:	e17ff904 	addi	r5,fp,-28
 202670c:	e13ff884 	addi	r4,fp,-30
 2026710:	280f883a 	mov	r7,r5
 2026714:	200d883a 	mov	r6,r4
 2026718:	180b883a 	mov	r5,r3
 202671c:	1009883a 	mov	r4,r2
 2026720:	20260440 	call	2026044 <tcp_seg_add_chksum>
 2026724:	00003206 	br	20267f0 <tcp_write+0x5ec>
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 2026728:	e0bff58b 	ldhu	r2,-42(fp)
 202672c:	01800044 	movi	r6,1
 2026730:	100b883a 	mov	r5,r2
 2026734:	01000e04 	movi	r4,56
 2026738:	201c9740 	call	201c974 <pbuf_alloc>
 202673c:	e0bff615 	stw	r2,-40(fp)
 2026740:	e0bff617 	ldw	r2,-40(fp)
 2026744:	10014226 	beq	r2,zero,2026c50 <tcp_write+0xa4c>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((const u8_t *)arg + pos, seglen);
 2026748:	e0bfeb0b 	ldhu	r2,-84(fp)
 202674c:	e0fffb17 	ldw	r3,-20(fp)
 2026750:	1885883a 	add	r2,r3,r2
 2026754:	e0fff58b 	ldhu	r3,-42(fp)
 2026758:	180b883a 	mov	r5,r3
 202675c:	1009883a 	mov	r4,r2
 2026760:	203a1c40 	call	203a1c4 <inet_chksum>
 2026764:	0084303a 	nor	r2,zero,r2
 2026768:	e0bff88d 	sth	r2,-30(fp)
      if (seglen & 1) {
 202676c:	e0bff58b 	ldhu	r2,-42(fp)
 2026770:	1080004c 	andi	r2,r2,1
 2026774:	10000b26 	beq	r2,zero,20267a4 <tcp_write+0x5a0>
        chksum_swapped = 1;
 2026778:	00800044 	movi	r2,1
 202677c:	e0bff905 	stb	r2,-28(fp)
        chksum = SWAP_BYTES_IN_WORD(chksum);
 2026780:	e0bff88b 	ldhu	r2,-30(fp)
 2026784:	10bfffcc 	andi	r2,r2,65535
 2026788:	1004923a 	slli	r2,r2,8
 202678c:	1007883a 	mov	r3,r2
 2026790:	e0bff88b 	ldhu	r2,-30(fp)
 2026794:	10bfffcc 	andi	r2,r2,65535
 2026798:	1004d23a 	srli	r2,r2,8
 202679c:	1884b03a 	or	r2,r3,r2
 20267a0:	e0bff88d 	sth	r2,-30(fp)
      }
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
 20267a4:	e0bfeb0b 	ldhu	r2,-84(fp)
 20267a8:	e0fffb17 	ldw	r3,-20(fp)
 20267ac:	1887883a 	add	r3,r3,r2
 20267b0:	e0bff617 	ldw	r2,-40(fp)
 20267b4:	10c00115 	stw	r3,4(r2)

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 20267b8:	e0bff343 	ldbu	r2,-51(fp)
 20267bc:	0180a004 	movi	r6,640
 20267c0:	100b883a 	mov	r5,r2
 20267c4:	01000e04 	movi	r4,56
 20267c8:	201c9740 	call	201c974 <pbuf_alloc>
 20267cc:	e0bfef15 	stw	r2,-68(fp)
 20267d0:	e0bfef17 	ldw	r2,-68(fp)
 20267d4:	1000031e 	bne	r2,zero,20267e4 <tcp_write+0x5e0>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 20267d8:	e13ff617 	ldw	r4,-40(fp)
 20267dc:	201d2f40 	call	201d2f4 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 20267e0:	00011e06 	br	2026c5c <tcp_write+0xa58>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 20267e4:	e17ff617 	ldw	r5,-40(fp)
 20267e8:	e13fef17 	ldw	r4,-68(fp)
 20267ec:	201d4d40 	call	201d4d4 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 20267f0:	e13fef17 	ldw	r4,-68(fp)
 20267f4:	201d42c0 	call	201d42c <pbuf_clen>
 20267f8:	1007883a 	mov	r3,r2
 20267fc:	e0bfeb8b 	ldhu	r2,-82(fp)
 2026800:	1885883a 	add	r2,r3,r2
 2026804:	e0bfeb8d 	sth	r2,-82(fp)

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
 2026808:	e0bfeb8b 	ldhu	r2,-82(fp)
 202680c:	10800270 	cmpltui	r2,r2,9
 2026810:	1000031e 	bne	r2,zero,2026820 <tcp_write+0x61c>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
                  queuelen, (int)TCP_SND_QUEUELEN));
      pbuf_free(p);
 2026814:	e13fef17 	ldw	r4,-68(fp)
 2026818:	201d2f40 	call	201d2f4 <pbuf_free>
      goto memerr;
 202681c:	00010f06 	br	2026c5c <tcp_write+0xa58>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 2026820:	e0bffa17 	ldw	r2,-24(fp)
 2026824:	10c01917 	ldw	r3,100(r2)
 2026828:	e0bfeb0b 	ldhu	r2,-84(fp)
 202682c:	1887883a 	add	r3,r3,r2
 2026830:	e0bff203 	ldbu	r2,-56(fp)
 2026834:	d8800015 	stw	r2,0(sp)
 2026838:	180f883a 	mov	r7,r3
 202683c:	000d883a 	mov	r6,zero
 2026840:	e17fef17 	ldw	r5,-68(fp)
 2026844:	e13ffa17 	ldw	r4,-24(fp)
 2026848:	2025c0c0 	call	2025c0c <tcp_create_segment>
 202684c:	e0bfe815 	stw	r2,-96(fp)
 2026850:	e0bfe817 	ldw	r2,-96(fp)
 2026854:	10010026 	beq	r2,zero,2026c58 <tcp_write+0xa54>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
 2026858:	e0fff88b 	ldhu	r3,-30(fp)
 202685c:	e0bfe817 	ldw	r2,-96(fp)
 2026860:	10c0028d 	sth	r3,10(r2)
    seg->chksum_swapped = chksum_swapped;
 2026864:	e0fff903 	ldbu	r3,-28(fp)
 2026868:	e0bfe817 	ldw	r2,-96(fp)
 202686c:	10c00305 	stb	r3,12(r2)
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 2026870:	e0bfe817 	ldw	r2,-96(fp)
 2026874:	10800343 	ldbu	r2,13(r2)
 2026878:	10800114 	ori	r2,r2,4
 202687c:	1007883a 	mov	r3,r2
 2026880:	e0bfe817 	ldw	r2,-96(fp)
 2026884:	10c00345 	stb	r3,13(r2)
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 2026888:	e0bfea17 	ldw	r2,-88(fp)
 202688c:	1000031e 	bne	r2,zero,202689c <tcp_write+0x698>
      queue = seg;
 2026890:	e0bfe817 	ldw	r2,-96(fp)
 2026894:	e0bfea15 	stw	r2,-88(fp)
 2026898:	00000306 	br	20268a8 <tcp_write+0x6a4>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
 202689c:	e0bfe917 	ldw	r2,-92(fp)
 20268a0:	e0ffe817 	ldw	r3,-96(fp)
 20268a4:	10c00015 	stw	r3,0(r2)
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
 20268a8:	e0bfe817 	ldw	r2,-96(fp)
 20268ac:	e0bfe915 	stw	r2,-92(fp)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
                lwip_ntohl(seg->tcphdr->seqno),
                lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 20268b0:	e0ffeb0b 	ldhu	r3,-84(fp)
 20268b4:	e0bff58b 	ldhu	r2,-42(fp)
 20268b8:	1885883a 	add	r2,r3,r2
 20268bc:	e0bfeb0d 	sth	r2,-84(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 20268c0:	e0ffeb0b 	ldhu	r3,-84(fp)
 20268c4:	e0bffc0b 	ldhu	r2,-16(fp)
 20268c8:	18bf5836 	bltu	r3,r2,202662c <__alt_mem_mem_0+0xfd00662c>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 20268cc:	e0bfec0b 	ldhu	r2,-80(fp)
 20268d0:	10003d26 	beq	r2,zero,20269c8 <tcp_write+0x7c4>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 20268d4:	e0bfe717 	ldw	r2,-100(fp)
 20268d8:	10800117 	ldw	r2,4(r2)
 20268dc:	e0bff015 	stw	r2,-64(fp)
 20268e0:	00003006 	br	20269a4 <tcp_write+0x7a0>
      p->tot_len += oversize_used;
 20268e4:	e0bff017 	ldw	r2,-64(fp)
 20268e8:	10c0020b 	ldhu	r3,8(r2)
 20268ec:	e0bfec0b 	ldhu	r2,-80(fp)
 20268f0:	1885883a 	add	r2,r3,r2
 20268f4:	1007883a 	mov	r3,r2
 20268f8:	e0bff017 	ldw	r2,-64(fp)
 20268fc:	10c0020d 	sth	r3,8(r2)
      if (p->next == NULL) {
 2026900:	e0bff017 	ldw	r2,-64(fp)
 2026904:	10800017 	ldw	r2,0(r2)
 2026908:	1000231e 	bne	r2,zero,2026998 <tcp_write+0x794>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 202690c:	e0bff017 	ldw	r2,-64(fp)
 2026910:	10c00117 	ldw	r3,4(r2)
 2026914:	e0bff017 	ldw	r2,-64(fp)
 2026918:	1080028b 	ldhu	r2,10(r2)
 202691c:	10bfffcc 	andi	r2,r2,65535
 2026920:	1885883a 	add	r2,r3,r2
 2026924:	e0ffec0b 	ldhu	r3,-80(fp)
 2026928:	180d883a 	mov	r6,r3
 202692c:	e17ffb17 	ldw	r5,-20(fp)
 2026930:	1009883a 	mov	r4,r2
 2026934:	203a3140 	call	203a314 <lwip_chksum_copy>
 2026938:	10ffffcc 	andi	r3,r2,65535
 202693c:	e13fec0b 	ldhu	r4,-80(fp)
 2026940:	e0bfe717 	ldw	r2,-100(fp)
 2026944:	11400284 	addi	r5,r2,10
 2026948:	e0bfe717 	ldw	r2,-100(fp)
 202694c:	10800304 	addi	r2,r2,12
 2026950:	100f883a 	mov	r7,r2
 2026954:	280d883a 	mov	r6,r5
 2026958:	200b883a 	mov	r5,r4
 202695c:	1809883a 	mov	r4,r3
 2026960:	20260440 	call	2026044 <tcp_seg_add_chksum>
 2026964:	e0bfe717 	ldw	r2,-100(fp)
 2026968:	10800343 	ldbu	r2,13(r2)
 202696c:	10800114 	ori	r2,r2,4
 2026970:	1007883a 	mov	r3,r2
 2026974:	e0bfe717 	ldw	r2,-100(fp)
 2026978:	10c00345 	stb	r3,13(r2)
        p->len += oversize_used;
 202697c:	e0bff017 	ldw	r2,-64(fp)
 2026980:	10c0028b 	ldhu	r3,10(r2)
 2026984:	e0bfec0b 	ldhu	r2,-80(fp)
 2026988:	1885883a 	add	r2,r3,r2
 202698c:	1007883a 	mov	r3,r2
 2026990:	e0bff017 	ldw	r2,-64(fp)
 2026994:	10c0028d 	sth	r3,10(r2)
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 2026998:	e0bff017 	ldw	r2,-64(fp)
 202699c:	10800017 	ldw	r2,0(r2)
 20269a0:	e0bff015 	stw	r2,-64(fp)
 20269a4:	e0bff017 	ldw	r2,-64(fp)
 20269a8:	103fce1e 	bne	r2,zero,20268e4 <__alt_mem_mem_0+0xfd0068e4>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 20269ac:	e0bfe717 	ldw	r2,-100(fp)
 20269b0:	10c0020b 	ldhu	r3,8(r2)
 20269b4:	e0bfec0b 	ldhu	r2,-80(fp)
 20269b8:	1885883a 	add	r2,r3,r2
 20269bc:	1007883a 	mov	r3,r2
 20269c0:	e0bfe717 	ldw	r2,-100(fp)
 20269c4:	10c0020d 	sth	r3,8(r2)
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 20269c8:	e0fff70b 	ldhu	r3,-36(fp)
 20269cc:	e0bffa17 	ldw	r2,-24(fp)
 20269d0:	10c01c0d 	sth	r3,112(r2)

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM pbuf can be extended to include the new data.
   */
  if (concat_p != NULL) {
 20269d4:	e0bfe617 	ldw	r2,-104(fp)
 20269d8:	10000e26 	beq	r2,zero,2026a14 <tcp_write+0x810>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
                (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 20269dc:	e0bfe717 	ldw	r2,-100(fp)
 20269e0:	10800117 	ldw	r2,4(r2)
 20269e4:	e17fe617 	ldw	r5,-104(fp)
 20269e8:	1009883a 	mov	r4,r2
 20269ec:	201d4d40 	call	201d4d4 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 20269f0:	e0bfe717 	ldw	r2,-100(fp)
 20269f4:	10c0020b 	ldhu	r3,8(r2)
 20269f8:	e0bfe617 	ldw	r2,-104(fp)
 20269fc:	1080020b 	ldhu	r2,8(r2)
 2026a00:	1885883a 	add	r2,r3,r2
 2026a04:	1007883a 	mov	r3,r2
 2026a08:	e0bfe717 	ldw	r2,-100(fp)
 2026a0c:	10c0020d 	sth	r3,8(r2)
 2026a10:	00002806 	br	2026ab4 <tcp_write+0x8b0>
  } else if (extendlen > 0) {
 2026a14:	e0bfec8b 	ldhu	r2,-78(fp)
 2026a18:	10002626 	beq	r2,zero,2026ab4 <tcp_write+0x8b0>
    struct pbuf *p;
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
                last_unsent != NULL && last_unsent->p != NULL);
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 2026a1c:	e0bfe717 	ldw	r2,-100(fp)
 2026a20:	10800117 	ldw	r2,4(r2)
 2026a24:	e0bff115 	stw	r2,-60(fp)
 2026a28:	00000a06 	br	2026a54 <tcp_write+0x850>
      p->tot_len += extendlen;
 2026a2c:	e0bff117 	ldw	r2,-60(fp)
 2026a30:	10c0020b 	ldhu	r3,8(r2)
 2026a34:	e0bfec8b 	ldhu	r2,-78(fp)
 2026a38:	1885883a 	add	r2,r3,r2
 2026a3c:	1007883a 	mov	r3,r2
 2026a40:	e0bff117 	ldw	r2,-60(fp)
 2026a44:	10c0020d 	sth	r3,8(r2)
    last_unsent->len += concat_p->tot_len;
  } else if (extendlen > 0) {
    struct pbuf *p;
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
                last_unsent != NULL && last_unsent->p != NULL);
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 2026a48:	e0bff117 	ldw	r2,-60(fp)
 2026a4c:	10800017 	ldw	r2,0(r2)
 2026a50:	e0bff115 	stw	r2,-60(fp)
 2026a54:	e0bff117 	ldw	r2,-60(fp)
 2026a58:	10800017 	ldw	r2,0(r2)
 2026a5c:	103ff31e 	bne	r2,zero,2026a2c <__alt_mem_mem_0+0xfd006a2c>
      p->tot_len += extendlen;
    }
    p->tot_len += extendlen;
 2026a60:	e0bff117 	ldw	r2,-60(fp)
 2026a64:	10c0020b 	ldhu	r3,8(r2)
 2026a68:	e0bfec8b 	ldhu	r2,-78(fp)
 2026a6c:	1885883a 	add	r2,r3,r2
 2026a70:	1007883a 	mov	r3,r2
 2026a74:	e0bff117 	ldw	r2,-60(fp)
 2026a78:	10c0020d 	sth	r3,8(r2)
    p->len += extendlen;
 2026a7c:	e0bff117 	ldw	r2,-60(fp)
 2026a80:	10c0028b 	ldhu	r3,10(r2)
 2026a84:	e0bfec8b 	ldhu	r2,-78(fp)
 2026a88:	1885883a 	add	r2,r3,r2
 2026a8c:	1007883a 	mov	r3,r2
 2026a90:	e0bff117 	ldw	r2,-60(fp)
 2026a94:	10c0028d 	sth	r3,10(r2)
    last_unsent->len += extendlen;
 2026a98:	e0bfe717 	ldw	r2,-100(fp)
 2026a9c:	10c0020b 	ldhu	r3,8(r2)
 2026aa0:	e0bfec8b 	ldhu	r2,-78(fp)
 2026aa4:	1885883a 	add	r2,r3,r2
 2026aa8:	1007883a 	mov	r3,r2
 2026aac:	e0bfe717 	ldw	r2,-100(fp)
 2026ab0:	10c0020d 	sth	r3,8(r2)
  }

#if TCP_CHECKSUM_ON_COPY
  if (concat_chksummed) {
 2026ab4:	e0bfed0b 	ldhu	r2,-76(fp)
 2026ab8:	10001e26 	beq	r2,zero,2026b34 <tcp_write+0x930>
    LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
                concat_p != NULL || extendlen > 0);
    /*if concat checksumm swapped - swap it back */
    if (concat_chksum_swapped) {
 2026abc:	e0bff803 	ldbu	r2,-32(fp)
 2026ac0:	10803fcc 	andi	r2,r2,255
 2026ac4:	10000926 	beq	r2,zero,2026aec <tcp_write+0x8e8>
      concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
 2026ac8:	e0bff78b 	ldhu	r2,-34(fp)
 2026acc:	10bfffcc 	andi	r2,r2,65535
 2026ad0:	1004923a 	slli	r2,r2,8
 2026ad4:	1007883a 	mov	r3,r2
 2026ad8:	e0bff78b 	ldhu	r2,-34(fp)
 2026adc:	10bfffcc 	andi	r2,r2,65535
 2026ae0:	1004d23a 	srli	r2,r2,8
 2026ae4:	1884b03a 	or	r2,r3,r2
 2026ae8:	e0bff78d 	sth	r2,-34(fp)
    }
    tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 2026aec:	e0bff78b 	ldhu	r2,-34(fp)
 2026af0:	10ffffcc 	andi	r3,r2,65535
 2026af4:	e13fed0b 	ldhu	r4,-76(fp)
 2026af8:	e0bfe717 	ldw	r2,-100(fp)
 2026afc:	11400284 	addi	r5,r2,10
 2026b00:	e0bfe717 	ldw	r2,-100(fp)
 2026b04:	10800304 	addi	r2,r2,12
 2026b08:	100f883a 	mov	r7,r2
 2026b0c:	280d883a 	mov	r6,r5
 2026b10:	200b883a 	mov	r5,r4
 2026b14:	1809883a 	mov	r4,r3
 2026b18:	20260440 	call	2026044 <tcp_seg_add_chksum>
                       &last_unsent->chksum_swapped);
    last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 2026b1c:	e0bfe717 	ldw	r2,-100(fp)
 2026b20:	10800343 	ldbu	r2,13(r2)
 2026b24:	10800114 	ori	r2,r2,4
 2026b28:	1007883a 	mov	r3,r2
 2026b2c:	e0bfe717 	ldw	r2,-100(fp)
 2026b30:	10c00345 	stb	r3,13(r2)

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 2026b34:	e0bfe717 	ldw	r2,-100(fp)
 2026b38:	1000041e 	bne	r2,zero,2026b4c <tcp_write+0x948>
    pcb->unsent = queue;
 2026b3c:	e0bffa17 	ldw	r2,-24(fp)
 2026b40:	e0ffea17 	ldw	r3,-88(fp)
 2026b44:	10c01d15 	stw	r3,116(r2)
 2026b48:	00000306 	br	2026b58 <tcp_write+0x954>
  } else {
    last_unsent->next = queue;
 2026b4c:	e0bfe717 	ldw	r2,-100(fp)
 2026b50:	e0ffea17 	ldw	r3,-88(fp)
 2026b54:	10c00015 	stw	r3,0(r2)
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 2026b58:	e0bffa17 	ldw	r2,-24(fp)
 2026b5c:	10c01917 	ldw	r3,100(r2)
 2026b60:	e0bffc0b 	ldhu	r2,-16(fp)
 2026b64:	1887883a 	add	r3,r3,r2
 2026b68:	e0bffa17 	ldw	r2,-24(fp)
 2026b6c:	10c01915 	stw	r3,100(r2)
  pcb->snd_buf -= len;
 2026b70:	e0bffa17 	ldw	r2,-24(fp)
 2026b74:	10c01b0b 	ldhu	r3,108(r2)
 2026b78:	e0bffc0b 	ldhu	r2,-16(fp)
 2026b7c:	1885c83a 	sub	r2,r3,r2
 2026b80:	1007883a 	mov	r3,r2
 2026b84:	e0bffa17 	ldw	r2,-24(fp)
 2026b88:	10c01b0d 	sth	r3,108(r2)
  pcb->snd_queuelen = queuelen;
 2026b8c:	e0bffa17 	ldw	r2,-24(fp)
 2026b90:	e0ffeb8b 	ldhu	r3,-82(fp)
 2026b94:	10c01b8d 	sth	r3,110(r2)
    LWIP_ASSERT("tcp_write: valid queue length",
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
 2026b98:	e0bfe817 	ldw	r2,-96(fp)
 2026b9c:	10002426 	beq	r2,zero,2026c30 <tcp_write+0xa2c>
 2026ba0:	e0bfe817 	ldw	r2,-96(fp)
 2026ba4:	10800417 	ldw	r2,16(r2)
 2026ba8:	10002126 	beq	r2,zero,2026c30 <tcp_write+0xa2c>
 2026bac:	e0bffd03 	ldbu	r2,-12(fp)
 2026bb0:	1080008c 	andi	r2,r2,2
 2026bb4:	10001e1e 	bne	r2,zero,2026c30 <tcp_write+0xa2c>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 2026bb8:	e0bfe817 	ldw	r2,-96(fp)
 2026bbc:	14000417 	ldw	r16,16(r2)
 2026bc0:	e0bfe817 	ldw	r2,-96(fp)
 2026bc4:	10800417 	ldw	r2,16(r2)
 2026bc8:	10c00303 	ldbu	r3,12(r2)
 2026bcc:	10800343 	ldbu	r2,13(r2)
 2026bd0:	1004923a 	slli	r2,r2,8
 2026bd4:	10c4b03a 	or	r2,r2,r3
 2026bd8:	1023883a 	mov	r17,r2
 2026bdc:	01000204 	movi	r4,8
 2026be0:	20394740 	call	2039474 <lwip_htons>
 2026be4:	8884b03a 	or	r2,r17,r2
 2026be8:	100b883a 	mov	r5,r2
 2026bec:	28bfffcc 	andi	r2,r5,65535
 2026bf0:	11003fcc 	andi	r4,r2,255
 2026bf4:	80800303 	ldbu	r2,12(r16)
 2026bf8:	1004703a 	and	r2,r2,zero
 2026bfc:	1007883a 	mov	r3,r2
 2026c00:	2005883a 	mov	r2,r4
 2026c04:	1884b03a 	or	r2,r3,r2
 2026c08:	80800305 	stb	r2,12(r16)
 2026c0c:	28bfffcc 	andi	r2,r5,65535
 2026c10:	1004d23a 	srli	r2,r2,8
 2026c14:	113fffcc 	andi	r4,r2,65535
 2026c18:	80800343 	ldbu	r2,13(r16)
 2026c1c:	1004703a 	and	r2,r2,zero
 2026c20:	1007883a 	mov	r3,r2
 2026c24:	2005883a 	mov	r2,r4
 2026c28:	1884b03a 	or	r2,r3,r2
 2026c2c:	80800345 	stb	r2,13(r16)
  }

  return ERR_OK;
 2026c30:	0005883a 	mov	r2,zero
 2026c34:	00001f06 	br	2026cb4 <tcp_write+0xab0>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
 2026c38:	0001883a 	nop
 2026c3c:	00000706 	br	2026c5c <tcp_write+0xa58>
          extendlen = seglen;
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
            goto memerr;
 2026c40:	0001883a 	nop
 2026c44:	00000506 	br	2026c5c <tcp_write+0xa58>
    if (apiflags & TCP_WRITE_FLAG_COPY) {
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
 2026c48:	0001883a 	nop
 2026c4c:	00000306 	br	2026c5c <tcp_write+0xa58>
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
 2026c50:	0001883a 	nop
 2026c54:	00000106 	br	2026c5c <tcp_write+0xa58>
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
      goto memerr;
 2026c58:	0001883a 	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  tcp_set_flags(pcb, TF_NAGLEMEMERR);
 2026c5c:	e0bffa17 	ldw	r2,-24(fp)
 2026c60:	1080088b 	ldhu	r2,34(r2)
 2026c64:	10802014 	ori	r2,r2,128
 2026c68:	1007883a 	mov	r3,r2
 2026c6c:	e0bffa17 	ldw	r2,-24(fp)
 2026c70:	10c0088d 	sth	r3,34(r2)
  TCP_STATS_INC(tcp.memerr);
 2026c74:	008085f4 	movhi	r2,535
 2026c78:	10bd8204 	addi	r2,r2,-2552
 2026c7c:	10804e17 	ldw	r2,312(r2)
 2026c80:	10c00044 	addi	r3,r2,1
 2026c84:	008085f4 	movhi	r2,535
 2026c88:	10bd8204 	addi	r2,r2,-2552
 2026c8c:	10c04e15 	stw	r3,312(r2)

  if (concat_p != NULL) {
 2026c90:	e0bfe617 	ldw	r2,-104(fp)
 2026c94:	10000226 	beq	r2,zero,2026ca0 <tcp_write+0xa9c>
    pbuf_free(concat_p);
 2026c98:	e13fe617 	ldw	r4,-104(fp)
 2026c9c:	201d2f40 	call	201d2f4 <pbuf_free>
  }
  if (queue != NULL) {
 2026ca0:	e0bfea17 	ldw	r2,-88(fp)
 2026ca4:	10000226 	beq	r2,zero,2026cb0 <tcp_write+0xaac>
    tcp_segs_free(queue);
 2026ca8:	e13fea17 	ldw	r4,-88(fp)
 2026cac:	2020e8c0 	call	2020e8c <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
                pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 2026cb0:	00bfffc4 	movi	r2,-1
}
 2026cb4:	e6fffe04 	addi	sp,fp,-8
 2026cb8:	dfc00317 	ldw	ra,12(sp)
 2026cbc:	df000217 	ldw	fp,8(sp)
 2026cc0:	dc400117 	ldw	r17,4(sp)
 2026cc4:	dc000017 	ldw	r16,0(sp)
 2026cc8:	dec00404 	addi	sp,sp,16
 2026ccc:	f800283a 	ret

02026cd0 <tcp_split_unsent_seg>:
 * @param pcb the tcp_pcb for which to split the unsent head
 * @param split the amount of payload to remain in the head
 */
err_t
tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
{
 2026cd0:	defff204 	addi	sp,sp,-56
 2026cd4:	dfc00d15 	stw	ra,52(sp)
 2026cd8:	df000c15 	stw	fp,48(sp)
 2026cdc:	dc400b15 	stw	r17,44(sp)
 2026ce0:	dc000a15 	stw	r16,40(sp)
 2026ce4:	df000c04 	addi	fp,sp,48
 2026ce8:	e13ffc15 	stw	r4,-16(fp)
 2026cec:	2805883a 	mov	r2,r5
 2026cf0:	e0bffd0d 	sth	r2,-12(fp)
  struct tcp_seg *seg = NULL, *useg = NULL;
 2026cf4:	e03ff715 	stw	zero,-36(fp)
 2026cf8:	e03ff815 	stw	zero,-32(fp)
  struct pbuf *p = NULL;
 2026cfc:	e03ff915 	stw	zero,-28(fp)
  u8_t split_flags;
  u8_t remainder_flags;
  u16_t remainder;
  u16_t offset;
#if TCP_CHECKSUM_ON_COPY
  u16_t chksum = 0;
 2026d00:	e03ffb0d 	sth	zero,-20(fp)
  u8_t chksum_swapped = 0;
 2026d04:	e03ffb85 	stb	zero,-18(fp)
  struct pbuf *q;
#endif /* TCP_CHECKSUM_ON_COPY */

  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);

  useg = pcb->unsent;
 2026d08:	e0bffc17 	ldw	r2,-16(fp)
 2026d0c:	10801d17 	ldw	r2,116(r2)
 2026d10:	e0bff815 	stw	r2,-32(fp)
  if (useg == NULL) {
 2026d14:	e0bff817 	ldw	r2,-32(fp)
 2026d18:	1000021e 	bne	r2,zero,2026d24 <tcp_split_unsent_seg+0x54>
    return ERR_MEM;
 2026d1c:	00bfffc4 	movi	r2,-1
 2026d20:	00014a06 	br	202724c <tcp_split_unsent_seg+0x57c>
  }

  if (split == 0) {
 2026d24:	e0bffd0b 	ldhu	r2,-12(fp)
 2026d28:	1000021e 	bne	r2,zero,2026d34 <tcp_split_unsent_seg+0x64>
    LWIP_ASSERT("Can't split segment into length 0", 0);
    return ERR_VAL;
 2026d2c:	00bffe84 	movi	r2,-6
 2026d30:	00014606 	br	202724c <tcp_split_unsent_seg+0x57c>
  }

  if (useg->len <= split) {
 2026d34:	e0bff817 	ldw	r2,-32(fp)
 2026d38:	1080020b 	ldhu	r2,8(r2)
 2026d3c:	10bfffcc 	andi	r2,r2,65535
 2026d40:	e0fffd0b 	ldhu	r3,-12(fp)
 2026d44:	18800236 	bltu	r3,r2,2026d50 <tcp_split_unsent_seg+0x80>
    return ERR_OK;
 2026d48:	0005883a 	mov	r2,zero
 2026d4c:	00013f06 	br	202724c <tcp_split_unsent_seg+0x57c>
   * to split this packet so we may actually exceed the max value by
   * one!
   */
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuelen));

  optflags = useg->flags;
 2026d50:	e0bff817 	ldw	r2,-32(fp)
 2026d54:	10800343 	ldbu	r2,13(r2)
 2026d58:	e0bffa05 	stb	r2,-24(fp)
#if TCP_CHECKSUM_ON_COPY
  /* Remove since checksum is not stored until after tcp_create_segment() */
  optflags &= ~TF_SEG_DATA_CHECKSUMMED;
 2026d5c:	e0fffa03 	ldbu	r3,-24(fp)
 2026d60:	00bffec4 	movi	r2,-5
 2026d64:	1884703a 	and	r2,r3,r2
 2026d68:	e0bffa05 	stb	r2,-24(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 2026d6c:	e0bffa03 	ldbu	r2,-24(fp)
 2026d70:	1080004c 	andi	r2,r2,1
 2026d74:	10000226 	beq	r2,zero,2026d80 <tcp_split_unsent_seg+0xb0>
 2026d78:	00800104 	movi	r2,4
 2026d7c:	00000106 	br	2026d84 <tcp_split_unsent_seg+0xb4>
 2026d80:	0005883a 	mov	r2,zero
 2026d84:	e0bffa45 	stb	r2,-23(fp)
  remainder = useg->len - split;
 2026d88:	e0bff817 	ldw	r2,-32(fp)
 2026d8c:	10c0020b 	ldhu	r3,8(r2)
 2026d90:	e0bffd0b 	ldhu	r2,-12(fp)
 2026d94:	1885c83a 	sub	r2,r3,r2
 2026d98:	e0bffa8d 	sth	r2,-22(fp)

  /* Create new pbuf for the remainder of the split */
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
 2026d9c:	e0fffa43 	ldbu	r3,-23(fp)
 2026da0:	e0bffa8b 	ldhu	r2,-22(fp)
 2026da4:	1885883a 	add	r2,r3,r2
 2026da8:	10bfffcc 	andi	r2,r2,65535
 2026dac:	0180a004 	movi	r6,640
 2026db0:	100b883a 	mov	r5,r2
 2026db4:	01000e04 	movi	r4,56
 2026db8:	201c9740 	call	201c974 <pbuf_alloc>
 2026dbc:	e0bff915 	stw	r2,-28(fp)
  if (p == NULL) {
 2026dc0:	e0bff917 	ldw	r2,-28(fp)
 2026dc4:	10011026 	beq	r2,zero,2027208 <tcp_split_unsent_seg+0x538>
                ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
    goto memerr;
  }

  /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
  offset = useg->p->tot_len - useg->len + split;
 2026dc8:	e0bff817 	ldw	r2,-32(fp)
 2026dcc:	10800117 	ldw	r2,4(r2)
 2026dd0:	10c0020b 	ldhu	r3,8(r2)
 2026dd4:	e0bff817 	ldw	r2,-32(fp)
 2026dd8:	1080020b 	ldhu	r2,8(r2)
 2026ddc:	1885c83a 	sub	r2,r3,r2
 2026de0:	1007883a 	mov	r3,r2
 2026de4:	e0bffd0b 	ldhu	r2,-12(fp)
 2026de8:	1885883a 	add	r2,r3,r2
 2026dec:	e0bff58d 	sth	r2,-42(fp)
  /* Copy remainder into new pbuf, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
 2026df0:	e0bff817 	ldw	r2,-32(fp)
 2026df4:	11000117 	ldw	r4,4(r2)
 2026df8:	e0bff917 	ldw	r2,-28(fp)
 2026dfc:	10c00117 	ldw	r3,4(r2)
 2026e00:	e0bffa43 	ldbu	r2,-23(fp)
 2026e04:	1885883a 	add	r2,r3,r2
 2026e08:	e0fffa8b 	ldhu	r3,-22(fp)
 2026e0c:	e17ff58b 	ldhu	r5,-42(fp)
 2026e10:	280f883a 	mov	r7,r5
 2026e14:	180d883a 	mov	r6,r3
 2026e18:	100b883a 	mov	r5,r2
 2026e1c:	201d8500 	call	201d850 <pbuf_copy_partial>
 2026e20:	10ffffcc 	andi	r3,r2,65535
 2026e24:	e0bffa8b 	ldhu	r2,-22(fp)
 2026e28:	1880f91e 	bne	r3,r2,2027210 <tcp_split_unsent_seg+0x540>
                ("tcp_split_unsent_seg: could not copy pbuf remainder %u\n", remainder));
    goto memerr;
  }
#if TCP_CHECKSUM_ON_COPY
  /* calculate the checksum on remainder data */
  tcp_seg_add_chksum(~inet_chksum((const u8_t *)p->payload + optlen, remainder), remainder,
 2026e2c:	e0bff917 	ldw	r2,-28(fp)
 2026e30:	10c00117 	ldw	r3,4(r2)
 2026e34:	e0bffa43 	ldbu	r2,-23(fp)
 2026e38:	1885883a 	add	r2,r3,r2
 2026e3c:	e0fffa8b 	ldhu	r3,-22(fp)
 2026e40:	180b883a 	mov	r5,r3
 2026e44:	1009883a 	mov	r4,r2
 2026e48:	203a1c40 	call	203a1c4 <inet_chksum>
 2026e4c:	0084303a 	nor	r2,zero,r2
 2026e50:	10bfffcc 	andi	r2,r2,65535
 2026e54:	e0fffa8b 	ldhu	r3,-22(fp)
 2026e58:	e17ffb84 	addi	r5,fp,-18
 2026e5c:	e13ffb04 	addi	r4,fp,-20
 2026e60:	280f883a 	mov	r7,r5
 2026e64:	200d883a 	mov	r6,r4
 2026e68:	180b883a 	mov	r5,r3
 2026e6c:	1009883a 	mov	r4,r2
 2026e70:	20260440 	call	2026044 <tcp_seg_add_chksum>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Options are created when calling tcp_output() */

  /* Migrate flags from original segment */
  split_flags = TCPH_FLAGS(useg->tcphdr);
 2026e74:	e0bff817 	ldw	r2,-32(fp)
 2026e78:	10800417 	ldw	r2,16(r2)
 2026e7c:	10c00303 	ldbu	r3,12(r2)
 2026e80:	10800343 	ldbu	r2,13(r2)
 2026e84:	1004923a 	slli	r2,r2,8
 2026e88:	10c4b03a 	or	r2,r2,r3
 2026e8c:	10bfffcc 	andi	r2,r2,65535
 2026e90:	1009883a 	mov	r4,r2
 2026e94:	20394740 	call	2039474 <lwip_htons>
 2026e98:	10800fcc 	andi	r2,r2,63
 2026e9c:	e0bff505 	stb	r2,-44(fp)
  remainder_flags = 0; /* ACK added in tcp_output() */
 2026ea0:	e03ff545 	stb	zero,-43(fp)

  if (split_flags & TCP_PSH) {
 2026ea4:	e0bff503 	ldbu	r2,-44(fp)
 2026ea8:	1080020c 	andi	r2,r2,8
 2026eac:	10000726 	beq	r2,zero,2026ecc <tcp_split_unsent_seg+0x1fc>
    split_flags &= ~TCP_PSH;
 2026eb0:	e0fff503 	ldbu	r3,-44(fp)
 2026eb4:	00bffdc4 	movi	r2,-9
 2026eb8:	1884703a 	and	r2,r3,r2
 2026ebc:	e0bff505 	stb	r2,-44(fp)
    remainder_flags |= TCP_PSH;
 2026ec0:	e0bff543 	ldbu	r2,-43(fp)
 2026ec4:	10800214 	ori	r2,r2,8
 2026ec8:	e0bff545 	stb	r2,-43(fp)
  }
  if (split_flags & TCP_FIN) {
 2026ecc:	e0bff503 	ldbu	r2,-44(fp)
 2026ed0:	1080004c 	andi	r2,r2,1
 2026ed4:	10000726 	beq	r2,zero,2026ef4 <tcp_split_unsent_seg+0x224>
    split_flags &= ~TCP_FIN;
 2026ed8:	e0fff503 	ldbu	r3,-44(fp)
 2026edc:	00bfff84 	movi	r2,-2
 2026ee0:	1884703a 	and	r2,r3,r2
 2026ee4:	e0bff505 	stb	r2,-44(fp)
    remainder_flags |= TCP_FIN;
 2026ee8:	e0bff543 	ldbu	r2,-43(fp)
 2026eec:	10800054 	ori	r2,r2,1
 2026ef0:	e0bff545 	stb	r2,-43(fp)
  }
  /* SYN should be left on split, RST should not be present with data */

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
 2026ef4:	e43ff543 	ldbu	r16,-43(fp)
 2026ef8:	e0bff817 	ldw	r2,-32(fp)
 2026efc:	10800417 	ldw	r2,16(r2)
 2026f00:	10c00103 	ldbu	r3,4(r2)
 2026f04:	11000143 	ldbu	r4,5(r2)
 2026f08:	2008923a 	slli	r4,r4,8
 2026f0c:	20c6b03a 	or	r3,r4,r3
 2026f10:	11000183 	ldbu	r4,6(r2)
 2026f14:	2008943a 	slli	r4,r4,16
 2026f18:	20c6b03a 	or	r3,r4,r3
 2026f1c:	108001c3 	ldbu	r2,7(r2)
 2026f20:	1004963a 	slli	r2,r2,24
 2026f24:	10c4b03a 	or	r2,r2,r3
 2026f28:	1009883a 	mov	r4,r2
 2026f2c:	20394b00 	call	20394b0 <lwip_htonl>
 2026f30:	1007883a 	mov	r3,r2
 2026f34:	e0bffd0b 	ldhu	r2,-12(fp)
 2026f38:	1887883a 	add	r3,r3,r2
 2026f3c:	e0bffa03 	ldbu	r2,-24(fp)
 2026f40:	d8800015 	stw	r2,0(sp)
 2026f44:	180f883a 	mov	r7,r3
 2026f48:	800d883a 	mov	r6,r16
 2026f4c:	e17ff917 	ldw	r5,-28(fp)
 2026f50:	e13ffc17 	ldw	r4,-16(fp)
 2026f54:	2025c0c0 	call	2025c0c <tcp_create_segment>
 2026f58:	e0bff715 	stw	r2,-36(fp)
  if (seg == NULL) {
 2026f5c:	e0bff717 	ldw	r2,-36(fp)
 2026f60:	1000ad26 	beq	r2,zero,2027218 <tcp_split_unsent_seg+0x548>
                ("tcp_split_unsent_seg: could not create new TCP segment\n"));
    goto memerr;
  }

#if TCP_CHECKSUM_ON_COPY
  seg->chksum = chksum;
 2026f64:	e0fffb0b 	ldhu	r3,-20(fp)
 2026f68:	e0bff717 	ldw	r2,-36(fp)
 2026f6c:	10c0028d 	sth	r3,10(r2)
  seg->chksum_swapped = chksum_swapped;
 2026f70:	e0fffb83 	ldbu	r3,-18(fp)
 2026f74:	e0bff717 	ldw	r2,-36(fp)
 2026f78:	10c00305 	stb	r3,12(r2)
  seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 2026f7c:	e0bff717 	ldw	r2,-36(fp)
 2026f80:	10800343 	ldbu	r2,13(r2)
 2026f84:	10800114 	ori	r2,r2,4
 2026f88:	1007883a 	mov	r3,r2
 2026f8c:	e0bff717 	ldw	r2,-36(fp)
 2026f90:	10c00345 	stb	r3,13(r2)
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Remove this segment from the queue since trimming it may free pbufs */
  pcb->snd_queuelen -= pbuf_clen(useg->p);
 2026f94:	e0bff817 	ldw	r2,-32(fp)
 2026f98:	10800117 	ldw	r2,4(r2)
 2026f9c:	1009883a 	mov	r4,r2
 2026fa0:	201d42c0 	call	201d42c <pbuf_clen>
 2026fa4:	1007883a 	mov	r3,r2
 2026fa8:	e0bffc17 	ldw	r2,-16(fp)
 2026fac:	10801b8b 	ldhu	r2,110(r2)
 2026fb0:	10c5c83a 	sub	r2,r2,r3
 2026fb4:	1007883a 	mov	r3,r2
 2026fb8:	e0bffc17 	ldw	r2,-16(fp)
 2026fbc:	10c01b8d 	sth	r3,110(r2)

  /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
  successfully because we are modifying the original segment */
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
 2026fc0:	e0bff817 	ldw	r2,-32(fp)
 2026fc4:	11000117 	ldw	r4,4(r2)
 2026fc8:	e0bff817 	ldw	r2,-32(fp)
 2026fcc:	10800117 	ldw	r2,4(r2)
 2026fd0:	10c0020b 	ldhu	r3,8(r2)
 2026fd4:	e0bffa8b 	ldhu	r2,-22(fp)
 2026fd8:	1885c83a 	sub	r2,r3,r2
 2026fdc:	10bfffcc 	andi	r2,r2,65535
 2026fe0:	100b883a 	mov	r5,r2
 2026fe4:	201cd3c0 	call	201cd3c <pbuf_realloc>
  useg->len -= remainder;
 2026fe8:	e0bff817 	ldw	r2,-32(fp)
 2026fec:	10c0020b 	ldhu	r3,8(r2)
 2026ff0:	e0bffa8b 	ldhu	r2,-22(fp)
 2026ff4:	1885c83a 	sub	r2,r3,r2
 2026ff8:	1007883a 	mov	r3,r2
 2026ffc:	e0bff817 	ldw	r2,-32(fp)
 2027000:	10c0020d 	sth	r3,8(r2)
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
 2027004:	e0bff817 	ldw	r2,-32(fp)
 2027008:	14000417 	ldw	r16,16(r2)
 202700c:	e0bff817 	ldw	r2,-32(fp)
 2027010:	10800417 	ldw	r2,16(r2)
 2027014:	10c00303 	ldbu	r3,12(r2)
 2027018:	10800343 	ldbu	r2,13(r2)
 202701c:	1004923a 	slli	r2,r2,8
 2027020:	10c4b03a 	or	r2,r2,r3
 2027024:	1023883a 	mov	r17,r2
 2027028:	e0bff503 	ldbu	r2,-44(fp)
 202702c:	1009883a 	mov	r4,r2
 2027030:	20394740 	call	2039474 <lwip_htons>
 2027034:	8884b03a 	or	r2,r17,r2
 2027038:	100b883a 	mov	r5,r2
 202703c:	28bfffcc 	andi	r2,r5,65535
 2027040:	11003fcc 	andi	r4,r2,255
 2027044:	80800303 	ldbu	r2,12(r16)
 2027048:	1004703a 	and	r2,r2,zero
 202704c:	1007883a 	mov	r3,r2
 2027050:	2005883a 	mov	r2,r4
 2027054:	1884b03a 	or	r2,r3,r2
 2027058:	80800305 	stb	r2,12(r16)
 202705c:	28bfffcc 	andi	r2,r5,65535
 2027060:	1004d23a 	srli	r2,r2,8
 2027064:	113fffcc 	andi	r4,r2,65535
 2027068:	80800343 	ldbu	r2,13(r16)
 202706c:	1004703a 	and	r2,r2,zero
 2027070:	1007883a 	mov	r3,r2
 2027074:	2005883a 	mov	r2,r4
 2027078:	1884b03a 	or	r2,r3,r2
 202707c:	80800345 	stb	r2,13(r16)
  /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
  useg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */

  /* Add back to the queue with new trimmed pbuf */
  pcb->snd_queuelen += pbuf_clen(useg->p);
 2027080:	e0bff817 	ldw	r2,-32(fp)
 2027084:	10800117 	ldw	r2,4(r2)
 2027088:	1009883a 	mov	r4,r2
 202708c:	201d42c0 	call	201d42c <pbuf_clen>
 2027090:	1007883a 	mov	r3,r2
 2027094:	e0bffc17 	ldw	r2,-16(fp)
 2027098:	10801b8b 	ldhu	r2,110(r2)
 202709c:	10c5883a 	add	r2,r2,r3
 20270a0:	1007883a 	mov	r3,r2
 20270a4:	e0bffc17 	ldw	r2,-16(fp)
 20270a8:	10c01b8d 	sth	r3,110(r2)

#if TCP_CHECKSUM_ON_COPY
  /* The checksum on the split segment is now incorrect. We need to re-run it over the split */
  useg->chksum = 0;
 20270ac:	e0bff817 	ldw	r2,-32(fp)
 20270b0:	1000028d 	sth	zero,10(r2)
  useg->chksum_swapped = 0;
 20270b4:	e0bff817 	ldw	r2,-32(fp)
 20270b8:	10000305 	stb	zero,12(r2)
  q = useg->p;
 20270bc:	e0bff817 	ldw	r2,-32(fp)
 20270c0:	10800117 	ldw	r2,4(r2)
 20270c4:	e0bff615 	stw	r2,-40(fp)
  offset = q->tot_len - useg->len; /* Offset due to exposed headers */
 20270c8:	e0bff617 	ldw	r2,-40(fp)
 20270cc:	10c0020b 	ldhu	r3,8(r2)
 20270d0:	e0bff817 	ldw	r2,-32(fp)
 20270d4:	1080020b 	ldhu	r2,8(r2)
 20270d8:	1885c83a 	sub	r2,r3,r2
 20270dc:	e0bff58d 	sth	r2,-42(fp)

  /* Advance to the pbuf where the offset ends */
  while (q != NULL && offset > q->len) {
 20270e0:	00000806 	br	2027104 <tcp_split_unsent_seg+0x434>
    offset -= q->len;
 20270e4:	e0bff617 	ldw	r2,-40(fp)
 20270e8:	1080028b 	ldhu	r2,10(r2)
 20270ec:	e0fff58b 	ldhu	r3,-42(fp)
 20270f0:	1885c83a 	sub	r2,r3,r2
 20270f4:	e0bff58d 	sth	r2,-42(fp)
    q = q->next;
 20270f8:	e0bff617 	ldw	r2,-40(fp)
 20270fc:	10800017 	ldw	r2,0(r2)
 2027100:	e0bff615 	stw	r2,-40(fp)
  useg->chksum_swapped = 0;
  q = useg->p;
  offset = q->tot_len - useg->len; /* Offset due to exposed headers */

  /* Advance to the pbuf where the offset ends */
  while (q != NULL && offset > q->len) {
 2027104:	e0bff617 	ldw	r2,-40(fp)
 2027108:	10002426 	beq	r2,zero,202719c <tcp_split_unsent_seg+0x4cc>
 202710c:	e0bff617 	ldw	r2,-40(fp)
 2027110:	1080028b 	ldhu	r2,10(r2)
 2027114:	10ffffcc 	andi	r3,r2,65535
 2027118:	e0bff58b 	ldhu	r2,-42(fp)
 202711c:	18bff136 	bltu	r3,r2,20270e4 <__alt_mem_mem_0+0xfd0070e4>
    offset -= q->len;
    q = q->next;
  }
  LWIP_ASSERT("Found start of payload pbuf", q != NULL);
  /* Checksum the first payload pbuf accounting for offset, then other pbufs are all payload */
  for (; q != NULL; offset = 0, q = q->next) {
 2027120:	00001e06 	br	202719c <tcp_split_unsent_seg+0x4cc>
    tcp_seg_add_chksum(~inet_chksum((const u8_t *)q->payload + offset, q->len - offset), q->len - offset,
 2027124:	e0bff617 	ldw	r2,-40(fp)
 2027128:	10c00117 	ldw	r3,4(r2)
 202712c:	e0bff58b 	ldhu	r2,-42(fp)
 2027130:	1889883a 	add	r4,r3,r2
 2027134:	e0bff617 	ldw	r2,-40(fp)
 2027138:	10c0028b 	ldhu	r3,10(r2)
 202713c:	e0bff58b 	ldhu	r2,-42(fp)
 2027140:	1885c83a 	sub	r2,r3,r2
 2027144:	10bfffcc 	andi	r2,r2,65535
 2027148:	100b883a 	mov	r5,r2
 202714c:	203a1c40 	call	203a1c4 <inet_chksum>
 2027150:	0084303a 	nor	r2,zero,r2
 2027154:	113fffcc 	andi	r4,r2,65535
 2027158:	e0bff617 	ldw	r2,-40(fp)
 202715c:	10c0028b 	ldhu	r3,10(r2)
 2027160:	e0bff58b 	ldhu	r2,-42(fp)
 2027164:	1885c83a 	sub	r2,r3,r2
 2027168:	10ffffcc 	andi	r3,r2,65535
 202716c:	e0bff817 	ldw	r2,-32(fp)
 2027170:	11400284 	addi	r5,r2,10
 2027174:	e0bff817 	ldw	r2,-32(fp)
 2027178:	10800304 	addi	r2,r2,12
 202717c:	100f883a 	mov	r7,r2
 2027180:	280d883a 	mov	r6,r5
 2027184:	180b883a 	mov	r5,r3
 2027188:	20260440 	call	2026044 <tcp_seg_add_chksum>
    offset -= q->len;
    q = q->next;
  }
  LWIP_ASSERT("Found start of payload pbuf", q != NULL);
  /* Checksum the first payload pbuf accounting for offset, then other pbufs are all payload */
  for (; q != NULL; offset = 0, q = q->next) {
 202718c:	e03ff58d 	sth	zero,-42(fp)
 2027190:	e0bff617 	ldw	r2,-40(fp)
 2027194:	10800017 	ldw	r2,0(r2)
 2027198:	e0bff615 	stw	r2,-40(fp)
 202719c:	e0bff617 	ldw	r2,-40(fp)
 20271a0:	103fe01e 	bne	r2,zero,2027124 <__alt_mem_mem_0+0xfd007124>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Update number of segments on the queues. Note that length now may
   * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
   * because the total amount of data is constant when packet is split */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 20271a4:	e0bff717 	ldw	r2,-36(fp)
 20271a8:	10800117 	ldw	r2,4(r2)
 20271ac:	1009883a 	mov	r4,r2
 20271b0:	201d42c0 	call	201d42c <pbuf_clen>
 20271b4:	1007883a 	mov	r3,r2
 20271b8:	e0bffc17 	ldw	r2,-16(fp)
 20271bc:	10801b8b 	ldhu	r2,110(r2)
 20271c0:	10c5883a 	add	r2,r2,r3
 20271c4:	1007883a 	mov	r3,r2
 20271c8:	e0bffc17 	ldw	r2,-16(fp)
 20271cc:	10c01b8d 	sth	r3,110(r2)

  /* Finally insert remainder into queue after split (which stays head) */
  seg->next = useg->next;
 20271d0:	e0bff817 	ldw	r2,-32(fp)
 20271d4:	10c00017 	ldw	r3,0(r2)
 20271d8:	e0bff717 	ldw	r2,-36(fp)
 20271dc:	10c00015 	stw	r3,0(r2)
  useg->next = seg;
 20271e0:	e0bff817 	ldw	r2,-32(fp)
 20271e4:	e0fff717 	ldw	r3,-36(fp)
 20271e8:	10c00015 	stw	r3,0(r2)

#if TCP_OVERSIZE
  /* If remainder is last segment on the unsent, ensure we clear the oversize amount
   * because the remainder is always sized to the exact remaining amount */
  if (seg->next == NULL) {
 20271ec:	e0bff717 	ldw	r2,-36(fp)
 20271f0:	10800017 	ldw	r2,0(r2)
 20271f4:	1000021e 	bne	r2,zero,2027200 <tcp_split_unsent_seg+0x530>
    pcb->unsent_oversize = 0;
 20271f8:	e0bffc17 	ldw	r2,-16(fp)
 20271fc:	10001c0d 	sth	zero,112(r2)
  }
#endif /* TCP_OVERSIZE */

  return ERR_OK;
 2027200:	0005883a 	mov	r2,zero
 2027204:	00001106 	br	202724c <tcp_split_unsent_seg+0x57c>
  /* Create new pbuf for the remainder of the split */
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
    goto memerr;
 2027208:	0001883a 	nop
 202720c:	00000306 	br	202721c <tcp_split_unsent_seg+0x54c>
  offset = useg->p->tot_len - useg->len + split;
  /* Copy remainder into new pbuf, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("tcp_split_unsent_seg: could not copy pbuf remainder %u\n", remainder));
    goto memerr;
 2027210:	0001883a 	nop
 2027214:	00000106 	br	202721c <tcp_split_unsent_seg+0x54c>

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
  if (seg == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("tcp_split_unsent_seg: could not create new TCP segment\n"));
    goto memerr;
 2027218:	0001883a 	nop
  }
#endif /* TCP_OVERSIZE */

  return ERR_OK;
memerr:
  TCP_STATS_INC(tcp.memerr);
 202721c:	008085f4 	movhi	r2,535
 2027220:	10bd8204 	addi	r2,r2,-2552
 2027224:	10804e17 	ldw	r2,312(r2)
 2027228:	10c00044 	addi	r3,r2,1
 202722c:	008085f4 	movhi	r2,535
 2027230:	10bd8204 	addi	r2,r2,-2552
 2027234:	10c04e15 	stw	r3,312(r2)

  LWIP_ASSERT("seg == NULL", seg == NULL);
  if (p != NULL) {
 2027238:	e0bff917 	ldw	r2,-28(fp)
 202723c:	10000226 	beq	r2,zero,2027248 <tcp_split_unsent_seg+0x578>
    pbuf_free(p);
 2027240:	e13ff917 	ldw	r4,-28(fp)
 2027244:	201d2f40 	call	201d2f4 <pbuf_free>
  }

  return ERR_MEM;
 2027248:	00bfffc4 	movi	r2,-1
}
 202724c:	e6fffe04 	addi	sp,fp,-8
 2027250:	dfc00317 	ldw	ra,12(sp)
 2027254:	df000217 	ldw	fp,8(sp)
 2027258:	dc400117 	ldw	r17,4(sp)
 202725c:	dc000017 	ldw	r16,0(sp)
 2027260:	dec00404 	addi	sp,sp,16
 2027264:	f800283a 	ret

02027268 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 2027268:	defffa04 	addi	sp,sp,-24
 202726c:	dfc00515 	stw	ra,20(sp)
 2027270:	df000415 	stw	fp,16(sp)
 2027274:	dc400315 	stw	r17,12(sp)
 2027278:	dc000215 	stw	r16,8(sp)
 202727c:	df000404 	addi	fp,sp,16
 2027280:	e13ffd15 	stw	r4,-12(fp)
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 2027284:	e0bffd17 	ldw	r2,-12(fp)
 2027288:	10801d17 	ldw	r2,116(r2)
 202728c:	10003c26 	beq	r2,zero,2027380 <tcp_send_fin+0x118>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 2027290:	e0bffd17 	ldw	r2,-12(fp)
 2027294:	10801d17 	ldw	r2,116(r2)
 2027298:	e0bffc15 	stw	r2,-16(fp)
 202729c:	00000306 	br	20272ac <tcp_send_fin+0x44>
         last_unsent = last_unsent->next);
 20272a0:	e0bffc17 	ldw	r2,-16(fp)
 20272a4:	10800017 	ldw	r2,0(r2)
 20272a8:	e0bffc15 	stw	r2,-16(fp)
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 20272ac:	e0bffc17 	ldw	r2,-16(fp)
 20272b0:	10800017 	ldw	r2,0(r2)
 20272b4:	103ffa1e 	bne	r2,zero,20272a0 <__alt_mem_mem_0+0xfd0072a0>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 20272b8:	e0bffc17 	ldw	r2,-16(fp)
 20272bc:	10800417 	ldw	r2,16(r2)
 20272c0:	10c00303 	ldbu	r3,12(r2)
 20272c4:	10800343 	ldbu	r2,13(r2)
 20272c8:	1004923a 	slli	r2,r2,8
 20272cc:	10c4b03a 	or	r2,r2,r3
 20272d0:	10bfffcc 	andi	r2,r2,65535
 20272d4:	1009883a 	mov	r4,r2
 20272d8:	20394740 	call	2039474 <lwip_htons>
 20272dc:	10803fcc 	andi	r2,r2,255
 20272e0:	108001cc 	andi	r2,r2,7
 20272e4:	1000261e 	bne	r2,zero,2027380 <tcp_send_fin+0x118>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 20272e8:	e0bffc17 	ldw	r2,-16(fp)
 20272ec:	14000417 	ldw	r16,16(r2)
 20272f0:	e0bffc17 	ldw	r2,-16(fp)
 20272f4:	10800417 	ldw	r2,16(r2)
 20272f8:	10c00303 	ldbu	r3,12(r2)
 20272fc:	10800343 	ldbu	r2,13(r2)
 2027300:	1004923a 	slli	r2,r2,8
 2027304:	10c4b03a 	or	r2,r2,r3
 2027308:	1023883a 	mov	r17,r2
 202730c:	01000044 	movi	r4,1
 2027310:	20394740 	call	2039474 <lwip_htons>
 2027314:	8884b03a 	or	r2,r17,r2
 2027318:	100b883a 	mov	r5,r2
 202731c:	28bfffcc 	andi	r2,r5,65535
 2027320:	11003fcc 	andi	r4,r2,255
 2027324:	80800303 	ldbu	r2,12(r16)
 2027328:	1004703a 	and	r2,r2,zero
 202732c:	1007883a 	mov	r3,r2
 2027330:	2005883a 	mov	r2,r4
 2027334:	1884b03a 	or	r2,r3,r2
 2027338:	80800305 	stb	r2,12(r16)
 202733c:	28bfffcc 	andi	r2,r5,65535
 2027340:	1004d23a 	srli	r2,r2,8
 2027344:	113fffcc 	andi	r4,r2,65535
 2027348:	80800343 	ldbu	r2,13(r16)
 202734c:	1004703a 	and	r2,r2,zero
 2027350:	1007883a 	mov	r3,r2
 2027354:	2005883a 	mov	r2,r4
 2027358:	1884b03a 	or	r2,r3,r2
 202735c:	80800345 	stb	r2,13(r16)
      tcp_set_flags(pcb, TF_FIN);
 2027360:	e0bffd17 	ldw	r2,-12(fp)
 2027364:	1080088b 	ldhu	r2,34(r2)
 2027368:	10800814 	ori	r2,r2,32
 202736c:	1007883a 	mov	r3,r2
 2027370:	e0bffd17 	ldw	r2,-12(fp)
 2027374:	10c0088d 	sth	r3,34(r2)
      return ERR_OK;
 2027378:	0005883a 	mov	r2,zero
 202737c:	00000306 	br	202738c <tcp_send_fin+0x124>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 2027380:	01400044 	movi	r5,1
 2027384:	e13ffd17 	ldw	r4,-12(fp)
 2027388:	20273a80 	call	20273a8 <tcp_enqueue_flags>
}
 202738c:	e6fffe04 	addi	sp,fp,-8
 2027390:	dfc00317 	ldw	ra,12(sp)
 2027394:	df000217 	ldw	fp,8(sp)
 2027398:	dc400117 	ldw	r17,4(sp)
 202739c:	dc000017 	ldw	r16,0(sp)
 20273a0:	dec00404 	addi	sp,sp,16
 20273a4:	f800283a 	ret

020273a8 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 20273a8:	defff604 	addi	sp,sp,-40
 20273ac:	dfc00915 	stw	ra,36(sp)
 20273b0:	df000815 	stw	fp,32(sp)
 20273b4:	df000804 	addi	fp,sp,32
 20273b8:	e13ffe15 	stw	r4,-8(fp)
 20273bc:	2805883a 	mov	r2,r5
 20273c0:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 20273c4:	e03ff905 	stb	zero,-28(fp)
  u8_t optlen = 0;
 20273c8:	e03ffb05 	stb	zero,-20(fp)

  /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */

  /* Get options for this segment. This is a special case since this is the
     only place where a SYN can be sent. */
  if (flags & TCP_SYN) {
 20273cc:	e0bfff03 	ldbu	r2,-4(fp)
 20273d0:	1080008c 	andi	r2,r2,2
 20273d4:	10000226 	beq	r2,zero,20273e0 <tcp_enqueue_flags+0x38>
    optflags = TF_SEG_OPTS_MSS;
 20273d8:	00800044 	movi	r2,1
 20273dc:	e0bff905 	stb	r2,-28(fp)
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host (and in active open SYN segments). */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 20273e0:	e0bff903 	ldbu	r2,-28(fp)
 20273e4:	1080004c 	andi	r2,r2,1
 20273e8:	10000226 	beq	r2,zero,20273f4 <tcp_enqueue_flags+0x4c>
 20273ec:	00800104 	movi	r2,4
 20273f0:	00000106 	br	20273f8 <tcp_enqueue_flags+0x50>
 20273f4:	0005883a 	mov	r2,zero
 20273f8:	e0bffb05 	stb	r2,-20(fp)

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 20273fc:	e0bffb03 	ldbu	r2,-20(fp)
 2027400:	0180a004 	movi	r6,640
 2027404:	100b883a 	mov	r5,r2
 2027408:	01000e04 	movi	r4,56
 202740c:	201c9740 	call	201c974 <pbuf_alloc>
 2027410:	e0bffc15 	stw	r2,-16(fp)
 2027414:	e0bffc17 	ldw	r2,-16(fp)
 2027418:	10000f1e 	bne	r2,zero,2027458 <tcp_enqueue_flags+0xb0>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 202741c:	e0bffe17 	ldw	r2,-8(fp)
 2027420:	1080088b 	ldhu	r2,34(r2)
 2027424:	10802014 	ori	r2,r2,128
 2027428:	1007883a 	mov	r3,r2
 202742c:	e0bffe17 	ldw	r2,-8(fp)
 2027430:	10c0088d 	sth	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
 2027434:	008085f4 	movhi	r2,535
 2027438:	10bd8204 	addi	r2,r2,-2552
 202743c:	10804e17 	ldw	r2,312(r2)
 2027440:	10c00044 	addi	r3,r2,1
 2027444:	008085f4 	movhi	r2,535
 2027448:	10bd8204 	addi	r2,r2,-2552
 202744c:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
 2027450:	00bfffc4 	movi	r2,-1
 2027454:	00005206 	br	20275a0 <tcp_enqueue_flags+0x1f8>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 2027458:	e0ffff03 	ldbu	r3,-4(fp)
 202745c:	e0bffe17 	ldw	r2,-8(fp)
 2027460:	11001917 	ldw	r4,100(r2)
 2027464:	e0bff903 	ldbu	r2,-28(fp)
 2027468:	d8800015 	stw	r2,0(sp)
 202746c:	200f883a 	mov	r7,r4
 2027470:	180d883a 	mov	r6,r3
 2027474:	e17ffc17 	ldw	r5,-16(fp)
 2027478:	e13ffe17 	ldw	r4,-8(fp)
 202747c:	2025c0c0 	call	2025c0c <tcp_create_segment>
 2027480:	e0bffd15 	stw	r2,-12(fp)
 2027484:	e0bffd17 	ldw	r2,-12(fp)
 2027488:	10000f1e 	bne	r2,zero,20274c8 <tcp_enqueue_flags+0x120>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 202748c:	e0bffe17 	ldw	r2,-8(fp)
 2027490:	1080088b 	ldhu	r2,34(r2)
 2027494:	10802014 	ori	r2,r2,128
 2027498:	1007883a 	mov	r3,r2
 202749c:	e0bffe17 	ldw	r2,-8(fp)
 20274a0:	10c0088d 	sth	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
 20274a4:	008085f4 	movhi	r2,535
 20274a8:	10bd8204 	addi	r2,r2,-2552
 20274ac:	10804e17 	ldw	r2,312(r2)
 20274b0:	10c00044 	addi	r3,r2,1
 20274b4:	008085f4 	movhi	r2,535
 20274b8:	10bd8204 	addi	r2,r2,-2552
 20274bc:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
 20274c0:	00bfffc4 	movi	r2,-1
 20274c4:	00003606 	br	20275a0 <tcp_enqueue_flags+0x1f8>
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 20274c8:	e0bffe17 	ldw	r2,-8(fp)
 20274cc:	10801d17 	ldw	r2,116(r2)
 20274d0:	1000041e 	bne	r2,zero,20274e4 <tcp_enqueue_flags+0x13c>
    pcb->unsent = seg;
 20274d4:	e0bffe17 	ldw	r2,-8(fp)
 20274d8:	e0fffd17 	ldw	r3,-12(fp)
 20274dc:	10c01d15 	stw	r3,116(r2)
 20274e0:	00000d06 	br	2027518 <tcp_enqueue_flags+0x170>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 20274e4:	e0bffe17 	ldw	r2,-8(fp)
 20274e8:	10801d17 	ldw	r2,116(r2)
 20274ec:	e0bffa15 	stw	r2,-24(fp)
 20274f0:	00000306 	br	2027500 <tcp_enqueue_flags+0x158>
 20274f4:	e0bffa17 	ldw	r2,-24(fp)
 20274f8:	10800017 	ldw	r2,0(r2)
 20274fc:	e0bffa15 	stw	r2,-24(fp)
 2027500:	e0bffa17 	ldw	r2,-24(fp)
 2027504:	10800017 	ldw	r2,0(r2)
 2027508:	103ffa1e 	bne	r2,zero,20274f4 <__alt_mem_mem_0+0xfd0074f4>
    useg->next = seg;
 202750c:	e0bffa17 	ldw	r2,-24(fp)
 2027510:	e0fffd17 	ldw	r3,-12(fp)
 2027514:	10c00015 	stw	r3,0(r2)
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 2027518:	e0bffe17 	ldw	r2,-8(fp)
 202751c:	10001c0d 	sth	zero,112(r2)
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 2027520:	e0bfff03 	ldbu	r2,-4(fp)
 2027524:	1080008c 	andi	r2,r2,2
 2027528:	1000031e 	bne	r2,zero,2027538 <tcp_enqueue_flags+0x190>
 202752c:	e0bfff03 	ldbu	r2,-4(fp)
 2027530:	1080004c 	andi	r2,r2,1
 2027534:	10000526 	beq	r2,zero,202754c <tcp_enqueue_flags+0x1a4>
    pcb->snd_lbb++;
 2027538:	e0bffe17 	ldw	r2,-8(fp)
 202753c:	10801917 	ldw	r2,100(r2)
 2027540:	10c00044 	addi	r3,r2,1
 2027544:	e0bffe17 	ldw	r2,-8(fp)
 2027548:	10c01915 	stw	r3,100(r2)
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
 202754c:	e0bfff03 	ldbu	r2,-4(fp)
 2027550:	1080004c 	andi	r2,r2,1
 2027554:	10000626 	beq	r2,zero,2027570 <tcp_enqueue_flags+0x1c8>
    tcp_set_flags(pcb, TF_FIN);
 2027558:	e0bffe17 	ldw	r2,-8(fp)
 202755c:	1080088b 	ldhu	r2,34(r2)
 2027560:	10800814 	ori	r2,r2,32
 2027564:	1007883a 	mov	r3,r2
 2027568:	e0bffe17 	ldw	r2,-8(fp)
 202756c:	10c0088d 	sth	r3,34(r2)
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 2027570:	e0bffd17 	ldw	r2,-12(fp)
 2027574:	10800117 	ldw	r2,4(r2)
 2027578:	1009883a 	mov	r4,r2
 202757c:	201d42c0 	call	201d42c <pbuf_clen>
 2027580:	1007883a 	mov	r3,r2
 2027584:	e0bffe17 	ldw	r2,-8(fp)
 2027588:	10801b8b 	ldhu	r2,110(r2)
 202758c:	10c5883a 	add	r2,r2,r3
 2027590:	1007883a 	mov	r3,r2
 2027594:	e0bffe17 	ldw	r2,-8(fp)
 2027598:	10c01b8d 	sth	r3,110(r2)
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 202759c:	0005883a 	mov	r2,zero
}
 20275a0:	e037883a 	mov	sp,fp
 20275a4:	dfc00117 	ldw	ra,4(sp)
 20275a8:	df000017 	ldw	fp,0(sp)
 20275ac:	dec00204 	addi	sp,sp,8
 20275b0:	f800283a 	ret

020275b4 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 20275b4:	defff304 	addi	sp,sp,-52
 20275b8:	dfc00c15 	stw	ra,48(sp)
 20275bc:	df000b15 	stw	fp,44(sp)
 20275c0:	dc400a15 	stw	r17,40(sp)
 20275c4:	dc000915 	stw	r16,36(sp)
 20275c8:	df000b04 	addi	fp,sp,44
 20275cc:	e13ffd15 	stw	r4,-12(fp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 20275d0:	d0e7ef17 	ldw	r3,-24644(gp)
 20275d4:	e0bffd17 	ldw	r2,-12(fp)
 20275d8:	1880021e 	bne	r3,r2,20275e4 <tcp_output+0x30>
    return ERR_OK;
 20275dc:	0005883a 	mov	r2,zero
 20275e0:	0001b806 	br	2027cc4 <tcp_output+0x710>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 20275e4:	e0bffd17 	ldw	r2,-12(fp)
 20275e8:	10c0140b 	ldhu	r3,80(r2)
 20275ec:	e0bffd17 	ldw	r2,-12(fp)
 20275f0:	11401a0b 	ldhu	r5,104(r2)
 20275f4:	1809883a 	mov	r4,r3
 20275f8:	20bfffcc 	andi	r2,r4,65535
 20275fc:	28ffffcc 	andi	r3,r5,65535
 2027600:	1880012e 	bgeu	r3,r2,2027608 <tcp_output+0x54>
 2027604:	2809883a 	mov	r4,r5
 2027608:	20bfffcc 	andi	r2,r4,65535
 202760c:	e0bff815 	stw	r2,-32(fp)

  seg = pcb->unsent;
 2027610:	e0bffd17 	ldw	r2,-12(fp)
 2027614:	10801d17 	ldw	r2,116(r2)
 2027618:	e0bff515 	stw	r2,-44(fp)

  if (seg == NULL) {
 202761c:	e0bff517 	ldw	r2,-44(fp)
 2027620:	1000081e 	bne	r2,zero,2027644 <tcp_output+0x90>
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));

    /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
 2027624:	e0bffd17 	ldw	r2,-12(fp)
 2027628:	1080088b 	ldhu	r2,34(r2)
 202762c:	10bfffcc 	andi	r2,r2,65535
 2027630:	1080008c 	andi	r2,r2,2
 2027634:	10019826 	beq	r2,zero,2027c98 <tcp_output+0x6e4>
      return tcp_send_empty_ack(pcb);
 2027638:	e13ffd17 	ldw	r4,-12(fp)
 202763c:	2028dd00 	call	2028dd0 <tcp_send_empty_ack>
 2027640:	0001a006 	br	2027cc4 <tcp_output+0x710>
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
  }

  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
 2027644:	e0fffd17 	ldw	r3,-12(fp)
 2027648:	e0bffd17 	ldw	r2,-12(fp)
 202764c:	10800104 	addi	r2,r2,4
 2027650:	100d883a 	mov	r6,r2
 2027654:	180b883a 	mov	r5,r3
 2027658:	e13ffd17 	ldw	r4,-12(fp)
 202765c:	2025ba40 	call	2025ba4 <tcp_route>
 2027660:	e0bff915 	stw	r2,-28(fp)
  if (netif == NULL) {
 2027664:	e0bff917 	ldw	r2,-28(fp)
 2027668:	1000021e 	bne	r2,zero,2027674 <tcp_output+0xc0>
    return ERR_RTE;
 202766c:	00bfff04 	movi	r2,-4
 2027670:	00019406 	br	2027cc4 <tcp_output+0x710>
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
 2027674:	e0bffd17 	ldw	r2,-12(fp)
 2027678:	10000326 	beq	r2,zero,2027688 <tcp_output+0xd4>
 202767c:	e0bffd17 	ldw	r2,-12(fp)
 2027680:	10800017 	ldw	r2,0(r2)
 2027684:	10000f1e 	bne	r2,zero,20276c4 <tcp_output+0x110>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
 2027688:	e0bff917 	ldw	r2,-28(fp)
 202768c:	10000326 	beq	r2,zero,202769c <tcp_output+0xe8>
 2027690:	e0bff917 	ldw	r2,-28(fp)
 2027694:	10800104 	addi	r2,r2,4
 2027698:	00000106 	br	20276a0 <tcp_output+0xec>
 202769c:	0005883a 	mov	r2,zero
 20276a0:	e0bffa15 	stw	r2,-24(fp)
    if (local_ip == NULL) {
 20276a4:	e0bffa17 	ldw	r2,-24(fp)
 20276a8:	1000021e 	bne	r2,zero,20276b4 <tcp_output+0x100>
      return ERR_RTE;
 20276ac:	00bfff04 	movi	r2,-4
 20276b0:	00018406 	br	2027cc4 <tcp_output+0x710>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 20276b4:	e0bffa17 	ldw	r2,-24(fp)
 20276b8:	10c00017 	ldw	r3,0(r2)
 20276bc:	e0bffd17 	ldw	r2,-12(fp)
 20276c0:	10c00015 	stw	r3,0(r2)
  }

  /* Handle the current segment not fitting within the window */
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
 20276c4:	e0bff517 	ldw	r2,-44(fp)
 20276c8:	10800417 	ldw	r2,16(r2)
 20276cc:	10c00103 	ldbu	r3,4(r2)
 20276d0:	11000143 	ldbu	r4,5(r2)
 20276d4:	2008923a 	slli	r4,r4,8
 20276d8:	20c6b03a 	or	r3,r4,r3
 20276dc:	11000183 	ldbu	r4,6(r2)
 20276e0:	2008943a 	slli	r4,r4,16
 20276e4:	20c6b03a 	or	r3,r4,r3
 20276e8:	108001c3 	ldbu	r2,7(r2)
 20276ec:	1004963a 	slli	r2,r2,24
 20276f0:	10c4b03a 	or	r2,r2,r3
 20276f4:	1009883a 	mov	r4,r2
 20276f8:	20394b00 	call	20394b0 <lwip_htonl>
 20276fc:	1007883a 	mov	r3,r2
 2027700:	e0bffd17 	ldw	r2,-12(fp)
 2027704:	10801317 	ldw	r2,76(r2)
 2027708:	1887c83a 	sub	r3,r3,r2
 202770c:	e0bff517 	ldw	r2,-44(fp)
 2027710:	1080020b 	ldhu	r2,8(r2)
 2027714:	10bfffcc 	andi	r2,r2,65535
 2027718:	1885883a 	add	r2,r3,r2
 202771c:	e0fff817 	ldw	r3,-32(fp)
 2027720:	18801b2e 	bgeu	r3,r2,2027790 <tcp_output+0x1dc>
     * within the remaining (could be 0) send window and RTO timer is not running (we
     * have no in-flight data). If window is still too small after persist timer fires,
     * then we split the segment. We don't consider the congestion window since a cwnd
     * smaller than 1 SMSS implies in-flight data
     */
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 2027724:	e0bffd17 	ldw	r2,-12(fp)
 2027728:	10801a0b 	ldhu	r2,104(r2)
 202772c:	10ffffcc 	andi	r3,r2,65535
 2027730:	e0bff817 	ldw	r2,-32(fp)
 2027734:	18800e1e 	bne	r3,r2,2027770 <tcp_output+0x1bc>
 2027738:	e0bffd17 	ldw	r2,-12(fp)
 202773c:	10801e17 	ldw	r2,120(r2)
 2027740:	10000b1e 	bne	r2,zero,2027770 <tcp_output+0x1bc>
 2027744:	e0bffd17 	ldw	r2,-12(fp)
 2027748:	10802a43 	ldbu	r2,169(r2)
 202774c:	10803fcc 	andi	r2,r2,255
 2027750:	1000071e 	bne	r2,zero,2027770 <tcp_output+0x1bc>
      pcb->persist_cnt = 0;
 2027754:	e0bffd17 	ldw	r2,-12(fp)
 2027758:	10002a05 	stb	zero,168(r2)
      pcb->persist_backoff = 1;
 202775c:	e0bffd17 	ldw	r2,-12(fp)
 2027760:	00c00044 	movi	r3,1
 2027764:	10c02a45 	stb	r3,169(r2)
      pcb->persist_probe = 0;
 2027768:	e0bffd17 	ldw	r2,-12(fp)
 202776c:	10002a85 	stb	zero,170(r2)
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
 2027770:	e0bffd17 	ldw	r2,-12(fp)
 2027774:	1080088b 	ldhu	r2,34(r2)
 2027778:	10bfffcc 	andi	r2,r2,65535
 202777c:	1080008c 	andi	r2,r2,2
 2027780:	10014726 	beq	r2,zero,2027ca0 <tcp_output+0x6ec>
      return tcp_send_empty_ack(pcb);
 2027784:	e13ffd17 	ldw	r4,-12(fp)
 2027788:	2028dd00 	call	2028dd0 <tcp_send_empty_ack>
 202778c:	00014d06 	br	2027cc4 <tcp_output+0x710>
    }
    goto output_done;
  }
  /* Stop persist timer, above conditions are not active */
  pcb->persist_backoff = 0;
 2027790:	e0bffd17 	ldw	r2,-12(fp)
 2027794:	10002a45 	stb	zero,169(r2)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 2027798:	e0bffd17 	ldw	r2,-12(fp)
 202779c:	10801e17 	ldw	r2,120(r2)
 20277a0:	e0bff615 	stw	r2,-40(fp)
  if (useg != NULL) {
 20277a4:	e0bff617 	ldw	r2,-40(fp)
 20277a8:	10011926 	beq	r2,zero,2027c10 <tcp_output+0x65c>
    for (; useg->next != NULL; useg = useg->next);
 20277ac:	00000306 	br	20277bc <tcp_output+0x208>
 20277b0:	e0bff617 	ldw	r2,-40(fp)
 20277b4:	10800017 	ldw	r2,0(r2)
 20277b8:	e0bff615 	stw	r2,-40(fp)
 20277bc:	e0bff617 	ldw	r2,-40(fp)
 20277c0:	10800017 	ldw	r2,0(r2)
 20277c4:	103ffa1e 	bne	r2,zero,20277b0 <__alt_mem_mem_0+0xfd0077b0>
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 20277c8:	00011106 	br	2027c10 <tcp_output+0x65c>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
 20277cc:	e0bffd17 	ldw	r2,-12(fp)
 20277d0:	10801e17 	ldw	r2,120(r2)
 20277d4:	10001d26 	beq	r2,zero,202784c <tcp_output+0x298>
 20277d8:	e0bffd17 	ldw	r2,-12(fp)
 20277dc:	1080088b 	ldhu	r2,34(r2)
 20277e0:	10bfffcc 	andi	r2,r2,65535
 20277e4:	1080110c 	andi	r2,r2,68
 20277e8:	1000181e 	bne	r2,zero,202784c <tcp_output+0x298>
 20277ec:	e0bffd17 	ldw	r2,-12(fp)
 20277f0:	10801d17 	ldw	r2,116(r2)
 20277f4:	10000c26 	beq	r2,zero,2027828 <tcp_output+0x274>
 20277f8:	e0bffd17 	ldw	r2,-12(fp)
 20277fc:	10801d17 	ldw	r2,116(r2)
 2027800:	10800017 	ldw	r2,0(r2)
 2027804:	1000111e 	bne	r2,zero,202784c <tcp_output+0x298>
 2027808:	e0bffd17 	ldw	r2,-12(fp)
 202780c:	10801d17 	ldw	r2,116(r2)
 2027810:	10c0020b 	ldhu	r3,8(r2)
 2027814:	e0bffd17 	ldw	r2,-12(fp)
 2027818:	10800e8b 	ldhu	r2,58(r2)
 202781c:	18ffffcc 	andi	r3,r3,65535
 2027820:	10bfffcc 	andi	r2,r2,65535
 2027824:	1880092e 	bgeu	r3,r2,202784c <tcp_output+0x298>
 2027828:	e0bffd17 	ldw	r2,-12(fp)
 202782c:	10801b0b 	ldhu	r2,108(r2)
 2027830:	10bfffcc 	andi	r2,r2,65535
 2027834:	10000526 	beq	r2,zero,202784c <tcp_output+0x298>
 2027838:	e0bffd17 	ldw	r2,-12(fp)
 202783c:	10801b8b 	ldhu	r2,110(r2)
 2027840:	10bfffcc 	andi	r2,r2,65535
 2027844:	10800230 	cmpltui	r2,r2,8
 2027848:	1000021e 	bne	r2,zero,2027854 <tcp_output+0x2a0>
 202784c:	00800044 	movi	r2,1
 2027850:	00000106 	br	2027858 <tcp_output+0x2a4>
 2027854:	0005883a 	mov	r2,zero
 2027858:	1000051e 	bne	r2,zero,2027870 <tcp_output+0x2bc>
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
 202785c:	e0bffd17 	ldw	r2,-12(fp)
 2027860:	1080088b 	ldhu	r2,34(r2)
 2027864:	10bfffcc 	andi	r2,r2,65535
 2027868:	1080280c 	andi	r2,r2,160
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
 202786c:	10010326 	beq	r2,zero,2027c7c <tcp_output+0x6c8>
                                 pcb->lastack,
                                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
 2027870:	e0bffd17 	ldw	r2,-12(fp)
 2027874:	10800617 	ldw	r2,24(r2)
 2027878:	108000a0 	cmpeqi	r2,r2,2
 202787c:	10001e1e 	bne	r2,zero,20278f8 <tcp_output+0x344>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 2027880:	e0bff517 	ldw	r2,-44(fp)
 2027884:	14000417 	ldw	r16,16(r2)
 2027888:	e0bff517 	ldw	r2,-44(fp)
 202788c:	10800417 	ldw	r2,16(r2)
 2027890:	10c00303 	ldbu	r3,12(r2)
 2027894:	10800343 	ldbu	r2,13(r2)
 2027898:	1004923a 	slli	r2,r2,8
 202789c:	10c4b03a 	or	r2,r2,r3
 20278a0:	1023883a 	mov	r17,r2
 20278a4:	01000404 	movi	r4,16
 20278a8:	20394740 	call	2039474 <lwip_htons>
 20278ac:	8884b03a 	or	r2,r17,r2
 20278b0:	100b883a 	mov	r5,r2
 20278b4:	28bfffcc 	andi	r2,r5,65535
 20278b8:	11003fcc 	andi	r4,r2,255
 20278bc:	80800303 	ldbu	r2,12(r16)
 20278c0:	1004703a 	and	r2,r2,zero
 20278c4:	1007883a 	mov	r3,r2
 20278c8:	2005883a 	mov	r2,r4
 20278cc:	1884b03a 	or	r2,r3,r2
 20278d0:	80800305 	stb	r2,12(r16)
 20278d4:	28bfffcc 	andi	r2,r5,65535
 20278d8:	1004d23a 	srli	r2,r2,8
 20278dc:	113fffcc 	andi	r4,r2,65535
 20278e0:	80800343 	ldbu	r2,13(r16)
 20278e4:	1004703a 	and	r2,r2,zero
 20278e8:	1007883a 	mov	r3,r2
 20278ec:	2005883a 	mov	r2,r4
 20278f0:	1884b03a 	or	r2,r3,r2
 20278f4:	80800345 	stb	r2,13(r16)
    }

    err = tcp_output_segment(seg, pcb, netif);
 20278f8:	e1bff917 	ldw	r6,-28(fp)
 20278fc:	e17ffd17 	ldw	r5,-12(fp)
 2027900:	e13ff517 	ldw	r4,-44(fp)
 2027904:	2027d240 	call	2027d24 <tcp_output_segment>
 2027908:	e0bffb05 	stb	r2,-20(fp)
    if (err != ERR_OK) {
 202790c:	e0bffb07 	ldb	r2,-20(fp)
 2027910:	10000826 	beq	r2,zero,2027934 <tcp_output+0x380>
      /* segment could not be sent, for whatever reason */
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
 2027914:	e0bffd17 	ldw	r2,-12(fp)
 2027918:	1080088b 	ldhu	r2,34(r2)
 202791c:	10802014 	ori	r2,r2,128
 2027920:	1007883a 	mov	r3,r2
 2027924:	e0bffd17 	ldw	r2,-12(fp)
 2027928:	10c0088d 	sth	r3,34(r2)
      return err;
 202792c:	e0bffb03 	ldbu	r2,-20(fp)
 2027930:	0000e406 	br	2027cc4 <tcp_output+0x710>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
    pcb->unsent = seg->next;
 2027934:	e0bff517 	ldw	r2,-44(fp)
 2027938:	10c00017 	ldw	r3,0(r2)
 202793c:	e0bffd17 	ldw	r2,-12(fp)
 2027940:	10c01d15 	stw	r3,116(r2)
    if (pcb->state != SYN_SENT) {
 2027944:	e0bffd17 	ldw	r2,-12(fp)
 2027948:	10800617 	ldw	r2,24(r2)
 202794c:	108000a0 	cmpeqi	r2,r2,2
 2027950:	1000071e 	bne	r2,zero,2027970 <tcp_output+0x3bc>
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 2027954:	e0bffd17 	ldw	r2,-12(fp)
 2027958:	10c0088b 	ldhu	r3,34(r2)
 202795c:	00bfff04 	movi	r2,-4
 2027960:	1884703a 	and	r2,r3,r2
 2027964:	1007883a 	mov	r3,r2
 2027968:	e0bffd17 	ldw	r2,-12(fp)
 202796c:	10c0088d 	sth	r3,34(r2)
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 2027970:	e0bff517 	ldw	r2,-44(fp)
 2027974:	10800417 	ldw	r2,16(r2)
 2027978:	10c00103 	ldbu	r3,4(r2)
 202797c:	11000143 	ldbu	r4,5(r2)
 2027980:	2008923a 	slli	r4,r4,8
 2027984:	20c6b03a 	or	r3,r4,r3
 2027988:	11000183 	ldbu	r4,6(r2)
 202798c:	2008943a 	slli	r4,r4,16
 2027990:	20c6b03a 	or	r3,r4,r3
 2027994:	108001c3 	ldbu	r2,7(r2)
 2027998:	1004963a 	slli	r2,r2,24
 202799c:	10c4b03a 	or	r2,r2,r3
 20279a0:	1009883a 	mov	r4,r2
 20279a4:	20394b00 	call	20394b0 <lwip_htonl>
 20279a8:	1023883a 	mov	r17,r2
 20279ac:	e0bff517 	ldw	r2,-44(fp)
 20279b0:	1080020b 	ldhu	r2,8(r2)
 20279b4:	143fffcc 	andi	r16,r2,65535
 20279b8:	e0bff517 	ldw	r2,-44(fp)
 20279bc:	10800417 	ldw	r2,16(r2)
 20279c0:	10c00303 	ldbu	r3,12(r2)
 20279c4:	10800343 	ldbu	r2,13(r2)
 20279c8:	1004923a 	slli	r2,r2,8
 20279cc:	10c4b03a 	or	r2,r2,r3
 20279d0:	10bfffcc 	andi	r2,r2,65535
 20279d4:	1009883a 	mov	r4,r2
 20279d8:	20394740 	call	2039474 <lwip_htons>
 20279dc:	10803fcc 	andi	r2,r2,255
 20279e0:	108000cc 	andi	r2,r2,3
 20279e4:	10000226 	beq	r2,zero,20279f0 <tcp_output+0x43c>
 20279e8:	00800044 	movi	r2,1
 20279ec:	00000106 	br	20279f4 <tcp_output+0x440>
 20279f0:	0005883a 	mov	r2,zero
 20279f4:	8085883a 	add	r2,r16,r2
 20279f8:	8885883a 	add	r2,r17,r2
 20279fc:	e0bffc15 	stw	r2,-16(fp)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 2027a00:	e0bffd17 	ldw	r2,-12(fp)
 2027a04:	10c01617 	ldw	r3,88(r2)
 2027a08:	e0bffc17 	ldw	r2,-16(fp)
 2027a0c:	1885c83a 	sub	r2,r3,r2
 2027a10:	1000030e 	bge	r2,zero,2027a20 <tcp_output+0x46c>
      pcb->snd_nxt = snd_nxt;
 2027a14:	e0bffd17 	ldw	r2,-12(fp)
 2027a18:	e0fffc17 	ldw	r3,-16(fp)
 2027a1c:	10c01615 	stw	r3,88(r2)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 2027a20:	e0bff517 	ldw	r2,-44(fp)
 2027a24:	1080020b 	ldhu	r2,8(r2)
 2027a28:	143fffcc 	andi	r16,r2,65535
 2027a2c:	e0bff517 	ldw	r2,-44(fp)
 2027a30:	10800417 	ldw	r2,16(r2)
 2027a34:	10c00303 	ldbu	r3,12(r2)
 2027a38:	10800343 	ldbu	r2,13(r2)
 2027a3c:	1004923a 	slli	r2,r2,8
 2027a40:	10c4b03a 	or	r2,r2,r3
 2027a44:	10bfffcc 	andi	r2,r2,65535
 2027a48:	1009883a 	mov	r4,r2
 2027a4c:	20394740 	call	2039474 <lwip_htons>
 2027a50:	10803fcc 	andi	r2,r2,255
 2027a54:	108000cc 	andi	r2,r2,3
 2027a58:	10000226 	beq	r2,zero,2027a64 <tcp_output+0x4b0>
 2027a5c:	00800044 	movi	r2,1
 2027a60:	00000106 	br	2027a68 <tcp_output+0x4b4>
 2027a64:	0005883a 	mov	r2,zero
 2027a68:	8085883a 	add	r2,r16,r2
 2027a6c:	10006326 	beq	r2,zero,2027bfc <tcp_output+0x648>
      seg->next = NULL;
 2027a70:	e0bff517 	ldw	r2,-44(fp)
 2027a74:	10000015 	stw	zero,0(r2)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 2027a78:	e0bffd17 	ldw	r2,-12(fp)
 2027a7c:	10801e17 	ldw	r2,120(r2)
 2027a80:	1000061e 	bne	r2,zero,2027a9c <tcp_output+0x4e8>
        pcb->unacked = seg;
 2027a84:	e0bffd17 	ldw	r2,-12(fp)
 2027a88:	e0fff517 	ldw	r3,-44(fp)
 2027a8c:	10c01e15 	stw	r3,120(r2)
        useg = seg;
 2027a90:	e0bff517 	ldw	r2,-44(fp)
 2027a94:	e0bff615 	stw	r2,-40(fp)
 2027a98:	00005a06 	br	2027c04 <tcp_output+0x650>
        /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 2027a9c:	e0bff517 	ldw	r2,-44(fp)
 2027aa0:	10800417 	ldw	r2,16(r2)
 2027aa4:	10c00103 	ldbu	r3,4(r2)
 2027aa8:	11000143 	ldbu	r4,5(r2)
 2027aac:	2008923a 	slli	r4,r4,8
 2027ab0:	20c6b03a 	or	r3,r4,r3
 2027ab4:	11000183 	ldbu	r4,6(r2)
 2027ab8:	2008943a 	slli	r4,r4,16
 2027abc:	20c6b03a 	or	r3,r4,r3
 2027ac0:	108001c3 	ldbu	r2,7(r2)
 2027ac4:	1004963a 	slli	r2,r2,24
 2027ac8:	10c4b03a 	or	r2,r2,r3
 2027acc:	1009883a 	mov	r4,r2
 2027ad0:	20394b00 	call	20394b0 <lwip_htonl>
 2027ad4:	1021883a 	mov	r16,r2
 2027ad8:	e0bff617 	ldw	r2,-40(fp)
 2027adc:	10800417 	ldw	r2,16(r2)
 2027ae0:	10c00103 	ldbu	r3,4(r2)
 2027ae4:	11000143 	ldbu	r4,5(r2)
 2027ae8:	2008923a 	slli	r4,r4,8
 2027aec:	20c6b03a 	or	r3,r4,r3
 2027af0:	11000183 	ldbu	r4,6(r2)
 2027af4:	2008943a 	slli	r4,r4,16
 2027af8:	20c6b03a 	or	r3,r4,r3
 2027afc:	108001c3 	ldbu	r2,7(r2)
 2027b00:	1004963a 	slli	r2,r2,24
 2027b04:	10c4b03a 	or	r2,r2,r3
 2027b08:	1009883a 	mov	r4,r2
 2027b0c:	20394b00 	call	20394b0 <lwip_htonl>
 2027b10:	8085c83a 	sub	r2,r16,r2
 2027b14:	1000320e 	bge	r2,zero,2027be0 <tcp_output+0x62c>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 2027b18:	e0bffd17 	ldw	r2,-12(fp)
 2027b1c:	10801e04 	addi	r2,r2,120
 2027b20:	e0bff715 	stw	r2,-36(fp)
          while (*cur_seg &&
 2027b24:	00000306 	br	2027b34 <tcp_output+0x580>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
 2027b28:	e0bff717 	ldw	r2,-36(fp)
 2027b2c:	10800017 	ldw	r2,0(r2)
 2027b30:	e0bff715 	stw	r2,-36(fp)
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 2027b34:	e0bff717 	ldw	r2,-36(fp)
 2027b38:	10800017 	ldw	r2,0(r2)
 2027b3c:	10002026 	beq	r2,zero,2027bc0 <tcp_output+0x60c>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 2027b40:	e0bff717 	ldw	r2,-36(fp)
 2027b44:	10800017 	ldw	r2,0(r2)
 2027b48:	10800417 	ldw	r2,16(r2)
 2027b4c:	10c00103 	ldbu	r3,4(r2)
 2027b50:	11000143 	ldbu	r4,5(r2)
 2027b54:	2008923a 	slli	r4,r4,8
 2027b58:	20c6b03a 	or	r3,r4,r3
 2027b5c:	11000183 	ldbu	r4,6(r2)
 2027b60:	2008943a 	slli	r4,r4,16
 2027b64:	20c6b03a 	or	r3,r4,r3
 2027b68:	108001c3 	ldbu	r2,7(r2)
 2027b6c:	1004963a 	slli	r2,r2,24
 2027b70:	10c4b03a 	or	r2,r2,r3
 2027b74:	1009883a 	mov	r4,r2
 2027b78:	20394b00 	call	20394b0 <lwip_htonl>
 2027b7c:	1021883a 	mov	r16,r2
 2027b80:	e0bff517 	ldw	r2,-44(fp)
 2027b84:	10800417 	ldw	r2,16(r2)
 2027b88:	10c00103 	ldbu	r3,4(r2)
 2027b8c:	11000143 	ldbu	r4,5(r2)
 2027b90:	2008923a 	slli	r4,r4,8
 2027b94:	20c6b03a 	or	r3,r4,r3
 2027b98:	11000183 	ldbu	r4,6(r2)
 2027b9c:	2008943a 	slli	r4,r4,16
 2027ba0:	20c6b03a 	or	r3,r4,r3
 2027ba4:	108001c3 	ldbu	r2,7(r2)
 2027ba8:	1004963a 	slli	r2,r2,24
 2027bac:	10c4b03a 	or	r2,r2,r3
 2027bb0:	1009883a 	mov	r4,r2
 2027bb4:	20394b00 	call	20394b0 <lwip_htonl>
 2027bb8:	8085c83a 	sub	r2,r16,r2
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 2027bbc:	103fda16 	blt	r2,zero,2027b28 <__alt_mem_mem_0+0xfd007b28>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
 2027bc0:	e0bff717 	ldw	r2,-36(fp)
 2027bc4:	10c00017 	ldw	r3,0(r2)
 2027bc8:	e0bff517 	ldw	r2,-44(fp)
 2027bcc:	10c00015 	stw	r3,0(r2)
          (*cur_seg) = seg;
 2027bd0:	e0bff717 	ldw	r2,-36(fp)
 2027bd4:	e0fff517 	ldw	r3,-44(fp)
 2027bd8:	10c00015 	stw	r3,0(r2)
 2027bdc:	00000906 	br	2027c04 <tcp_output+0x650>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 2027be0:	e0bff617 	ldw	r2,-40(fp)
 2027be4:	e0fff517 	ldw	r3,-44(fp)
 2027be8:	10c00015 	stw	r3,0(r2)
          useg = useg->next;
 2027bec:	e0bff617 	ldw	r2,-40(fp)
 2027bf0:	10800017 	ldw	r2,0(r2)
 2027bf4:	e0bff615 	stw	r2,-40(fp)
 2027bf8:	00000206 	br	2027c04 <tcp_output+0x650>
        }
      }
      /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 2027bfc:	e13ff517 	ldw	r4,-44(fp)
 2027c00:	2020ee00 	call	2020ee0 <tcp_seg_free>
    }
    seg = pcb->unsent;
 2027c04:	e0bffd17 	ldw	r2,-12(fp)
 2027c08:	10801d17 	ldw	r2,116(r2)
 2027c0c:	e0bff515 	stw	r2,-44(fp)
  useg = pcb->unacked;
  if (useg != NULL) {
    for (; useg->next != NULL; useg = useg->next);
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 2027c10:	e0bff517 	ldw	r2,-44(fp)
 2027c14:	10001a26 	beq	r2,zero,2027c80 <tcp_output+0x6cc>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 2027c18:	e0bff517 	ldw	r2,-44(fp)
 2027c1c:	10800417 	ldw	r2,16(r2)
 2027c20:	10c00103 	ldbu	r3,4(r2)
 2027c24:	11000143 	ldbu	r4,5(r2)
 2027c28:	2008923a 	slli	r4,r4,8
 2027c2c:	20c6b03a 	or	r3,r4,r3
 2027c30:	11000183 	ldbu	r4,6(r2)
 2027c34:	2008943a 	slli	r4,r4,16
 2027c38:	20c6b03a 	or	r3,r4,r3
 2027c3c:	108001c3 	ldbu	r2,7(r2)
 2027c40:	1004963a 	slli	r2,r2,24
 2027c44:	10c4b03a 	or	r2,r2,r3
 2027c48:	1009883a 	mov	r4,r2
 2027c4c:	20394b00 	call	20394b0 <lwip_htonl>
 2027c50:	1007883a 	mov	r3,r2
 2027c54:	e0bffd17 	ldw	r2,-12(fp)
 2027c58:	10801317 	ldw	r2,76(r2)
 2027c5c:	1887c83a 	sub	r3,r3,r2
 2027c60:	e0bff517 	ldw	r2,-44(fp)
 2027c64:	1080020b 	ldhu	r2,8(r2)
 2027c68:	10bfffcc 	andi	r2,r2,65535
 2027c6c:	1885883a 	add	r2,r3,r2
  useg = pcb->unacked;
  if (useg != NULL) {
    for (; useg->next != NULL; useg = useg->next);
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 2027c70:	e0fff817 	ldw	r3,-32(fp)
 2027c74:	18bed52e 	bgeu	r3,r2,20277cc <__alt_mem_mem_0+0xfd0077cc>
 2027c78:	00000106 	br	2027c80 <tcp_output+0x6cc>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
      break;
 2027c7c:	0001883a 	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 2027c80:	e0bffd17 	ldw	r2,-12(fp)
 2027c84:	10801d17 	ldw	r2,116(r2)
 2027c88:	1000061e 	bne	r2,zero,2027ca4 <tcp_output+0x6f0>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 2027c8c:	e0bffd17 	ldw	r2,-12(fp)
 2027c90:	10001c0d 	sth	zero,112(r2)
 2027c94:	00000306 	br	2027ca4 <tcp_output+0x6f0>
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
      return tcp_send_empty_ack(pcb);
    }
    /* nothing to send: shortcut out of here */
    goto output_done;
 2027c98:	0001883a 	nop
 2027c9c:	00000106 	br	2027ca4 <tcp_output+0x6f0>
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
      return tcp_send_empty_ack(pcb);
    }
    goto output_done;
 2027ca0:	0001883a 	nop
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

output_done:
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
 2027ca4:	e0bffd17 	ldw	r2,-12(fp)
 2027ca8:	10c0088b 	ldhu	r3,34(r2)
 2027cac:	00bfdfc4 	movi	r2,-129
 2027cb0:	1884703a 	and	r2,r3,r2
 2027cb4:	1007883a 	mov	r3,r2
 2027cb8:	e0bffd17 	ldw	r2,-12(fp)
 2027cbc:	10c0088d 	sth	r3,34(r2)
  return ERR_OK;
 2027cc0:	0005883a 	mov	r2,zero
}
 2027cc4:	e6fffe04 	addi	sp,fp,-8
 2027cc8:	dfc00317 	ldw	ra,12(sp)
 2027ccc:	df000217 	ldw	fp,8(sp)
 2027cd0:	dc400117 	ldw	r17,4(sp)
 2027cd4:	dc000017 	ldw	r16,0(sp)
 2027cd8:	dec00404 	addi	sp,sp,16
 2027cdc:	f800283a 	ret

02027ce0 <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
 2027ce0:	defffe04 	addi	sp,sp,-8
 2027ce4:	df000115 	stw	fp,4(sp)
 2027ce8:	df000104 	addi	fp,sp,4
 2027cec:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
 2027cf0:	e0bfff17 	ldw	r2,-4(fp)
 2027cf4:	10800117 	ldw	r2,4(r2)
 2027cf8:	10800383 	ldbu	r2,14(r2)
 2027cfc:	10803fcc 	andi	r2,r2,255
 2027d00:	10800060 	cmpeqi	r2,r2,1
 2027d04:	1000021e 	bne	r2,zero,2027d10 <tcp_output_segment_busy+0x30>
    /* other reference found */
    return 1;
 2027d08:	00800044 	movi	r2,1
 2027d0c:	00000106 	br	2027d14 <tcp_output_segment_busy+0x34>
  }
  /* no other references found */
  return 0;
 2027d10:	0005883a 	mov	r2,zero
}
 2027d14:	e037883a 	mov	sp,fp
 2027d18:	df000017 	ldw	fp,0(sp)
 2027d1c:	dec00104 	addi	sp,sp,4
 2027d20:	f800283a 	ret

02027d24 <tcp_output_segment>:
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
 2027d24:	defff104 	addi	sp,sp,-60
 2027d28:	dfc00e15 	stw	ra,56(sp)
 2027d2c:	df000d15 	stw	fp,52(sp)
 2027d30:	dc400c15 	stw	r17,48(sp)
 2027d34:	dc000b15 	stw	r16,44(sp)
 2027d38:	df000d04 	addi	fp,sp,52
 2027d3c:	e13ffb15 	stw	r4,-20(fp)
 2027d40:	e17ffc15 	stw	r5,-16(fp)
 2027d44:	e1bffd15 	stw	r6,-12(fp)
  err_t err;
  u16_t len;
  u32_t *opts;
#if TCP_CHECKSUM_ON_COPY
  int seg_chksum_was_swapped = 0;
 2027d48:	e03ff615 	stw	zero,-40(fp)

  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);

  if (tcp_output_segment_busy(seg)) {
 2027d4c:	e13ffb17 	ldw	r4,-20(fp)
 2027d50:	2027ce00 	call	2027ce0 <tcp_output_segment_busy>
 2027d54:	10000226 	beq	r2,zero,2027d60 <tcp_output_segment+0x3c>
    /* This should not happen: rexmit functions should have checked this.
       However, since this function modifies p->len, we must not continue in this case. */
    LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
    return ERR_OK;
 2027d58:	0005883a 	mov	r2,zero
 2027d5c:	00012c06 	br	2028210 <tcp_output_segment+0x4ec>
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 2027d60:	e0bffb17 	ldw	r2,-20(fp)
 2027d64:	14000417 	ldw	r16,16(r2)
 2027d68:	e0bffc17 	ldw	r2,-16(fp)
 2027d6c:	10800b17 	ldw	r2,44(r2)
 2027d70:	1009883a 	mov	r4,r2
 2027d74:	20394b00 	call	20394b0 <lwip_htonl>
 2027d78:	11403fcc 	andi	r5,r2,255
 2027d7c:	80c00203 	ldbu	r3,8(r16)
 2027d80:	1806703a 	and	r3,r3,zero
 2027d84:	1809883a 	mov	r4,r3
 2027d88:	2807883a 	mov	r3,r5
 2027d8c:	20c6b03a 	or	r3,r4,r3
 2027d90:	80c00205 	stb	r3,8(r16)
 2027d94:	1006d23a 	srli	r3,r2,8
 2027d98:	19403fcc 	andi	r5,r3,255
 2027d9c:	80c00243 	ldbu	r3,9(r16)
 2027da0:	1806703a 	and	r3,r3,zero
 2027da4:	1809883a 	mov	r4,r3
 2027da8:	2807883a 	mov	r3,r5
 2027dac:	20c6b03a 	or	r3,r4,r3
 2027db0:	80c00245 	stb	r3,9(r16)
 2027db4:	1006d43a 	srli	r3,r2,16
 2027db8:	19403fcc 	andi	r5,r3,255
 2027dbc:	80c00283 	ldbu	r3,10(r16)
 2027dc0:	1806703a 	and	r3,r3,zero
 2027dc4:	1809883a 	mov	r4,r3
 2027dc8:	2807883a 	mov	r3,r5
 2027dcc:	20c6b03a 	or	r3,r4,r3
 2027dd0:	80c00285 	stb	r3,10(r16)
 2027dd4:	1008d63a 	srli	r4,r2,24
 2027dd8:	808002c3 	ldbu	r2,11(r16)
 2027ddc:	1004703a 	and	r2,r2,zero
 2027de0:	1007883a 	mov	r3,r2
 2027de4:	2005883a 	mov	r2,r4
 2027de8:	1884b03a 	or	r2,r3,r2
 2027dec:	808002c5 	stb	r2,11(r16)
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 2027df0:	e0bffb17 	ldw	r2,-20(fp)
 2027df4:	14000417 	ldw	r16,16(r2)
 2027df8:	e0bffc17 	ldw	r2,-16(fp)
 2027dfc:	10800c8b 	ldhu	r2,50(r2)
 2027e00:	10bfffcc 	andi	r2,r2,65535
 2027e04:	1009883a 	mov	r4,r2
 2027e08:	20394740 	call	2039474 <lwip_htons>
 2027e0c:	100b883a 	mov	r5,r2
 2027e10:	28bfffcc 	andi	r2,r5,65535
 2027e14:	11003fcc 	andi	r4,r2,255
 2027e18:	80800383 	ldbu	r2,14(r16)
 2027e1c:	1004703a 	and	r2,r2,zero
 2027e20:	1007883a 	mov	r3,r2
 2027e24:	2005883a 	mov	r2,r4
 2027e28:	1884b03a 	or	r2,r3,r2
 2027e2c:	80800385 	stb	r2,14(r16)
 2027e30:	28bfffcc 	andi	r2,r5,65535
 2027e34:	1004d23a 	srli	r2,r2,8
 2027e38:	113fffcc 	andi	r4,r2,65535
 2027e3c:	808003c3 	ldbu	r2,15(r16)
 2027e40:	1004703a 	and	r2,r2,zero
 2027e44:	1007883a 	mov	r3,r2
 2027e48:	2005883a 	mov	r2,r4
 2027e4c:	1884b03a 	or	r2,r3,r2
 2027e50:	808003c5 	stb	r2,15(r16)
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 2027e54:	e0bffc17 	ldw	r2,-16(fp)
 2027e58:	10c00b17 	ldw	r3,44(r2)
 2027e5c:	e0bffc17 	ldw	r2,-16(fp)
 2027e60:	10800c8b 	ldhu	r2,50(r2)
 2027e64:	10bfffcc 	andi	r2,r2,65535
 2027e68:	1887883a 	add	r3,r3,r2
 2027e6c:	e0bffc17 	ldw	r2,-16(fp)
 2027e70:	10c00d15 	stw	r3,52(r2)

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 2027e74:	e0bffb17 	ldw	r2,-20(fp)
 2027e78:	10800417 	ldw	r2,16(r2)
 2027e7c:	10800504 	addi	r2,r2,20
 2027e80:	e0bff715 	stw	r2,-36(fp)
  if (seg->flags & TF_SEG_OPTS_MSS) {
 2027e84:	e0bffb17 	ldw	r2,-20(fp)
 2027e88:	10800343 	ldbu	r2,13(r2)
 2027e8c:	10803fcc 	andi	r2,r2,255
 2027e90:	1080004c 	andi	r2,r2,1
 2027e94:	10001126 	beq	r2,zero,2027edc <tcp_output_segment+0x1b8>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
 2027e98:	e0bffc17 	ldw	r2,-16(fp)
 2027e9c:	10800104 	addi	r2,r2,4
 2027ea0:	100d883a 	mov	r6,r2
 2027ea4:	e17ffd17 	ldw	r5,-12(fp)
 2027ea8:	01016d04 	movi	r4,1460
 2027eac:	20219a40 	call	20219a4 <tcp_eff_send_mss_netif>
 2027eb0:	e0bff80d 	sth	r2,-32(fp)
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 2027eb4:	e0bff80b 	ldhu	r2,-32(fp)
 2027eb8:	10808134 	orhi	r2,r2,516
 2027ebc:	1009883a 	mov	r4,r2
 2027ec0:	20394b00 	call	20394b0 <lwip_htonl>
 2027ec4:	1007883a 	mov	r3,r2
 2027ec8:	e0bff717 	ldw	r2,-36(fp)
 2027ecc:	10c00015 	stw	r3,0(r2)
    opts += 1;
 2027ed0:	e0bff717 	ldw	r2,-36(fp)
 2027ed4:	10800104 	addi	r2,r2,4
 2027ed8:	e0bff715 	stw	r2,-36(fp)
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
 2027edc:	e0bffc17 	ldw	r2,-16(fp)
 2027ee0:	10800e0b 	ldhu	r2,56(r2)
 2027ee4:	10bfffcc 	andi	r2,r2,65535
 2027ee8:	10a0001c 	xori	r2,r2,32768
 2027eec:	10a00004 	addi	r2,r2,-32768
 2027ef0:	1000020e 	bge	r2,zero,2027efc <tcp_output_segment+0x1d8>
    pcb->rtime = 0;
 2027ef4:	e0bffc17 	ldw	r2,-16(fp)
 2027ef8:	10000e0d 	sth	zero,56(r2)
  }

  if (pcb->rttest == 0) {
 2027efc:	e0bffc17 	ldw	r2,-16(fp)
 2027f00:	10800f17 	ldw	r2,60(r2)
 2027f04:	1000141e 	bne	r2,zero,2027f58 <tcp_output_segment+0x234>
    pcb->rttest = tcp_ticks;
 2027f08:	d0e7e217 	ldw	r3,-24696(gp)
 2027f0c:	e0bffc17 	ldw	r2,-16(fp)
 2027f10:	10c00f15 	stw	r3,60(r2)
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 2027f14:	e0bffb17 	ldw	r2,-20(fp)
 2027f18:	10800417 	ldw	r2,16(r2)
 2027f1c:	10c00103 	ldbu	r3,4(r2)
 2027f20:	11000143 	ldbu	r4,5(r2)
 2027f24:	2008923a 	slli	r4,r4,8
 2027f28:	20c6b03a 	or	r3,r4,r3
 2027f2c:	11000183 	ldbu	r4,6(r2)
 2027f30:	2008943a 	slli	r4,r4,16
 2027f34:	20c6b03a 	or	r3,r4,r3
 2027f38:	108001c3 	ldbu	r2,7(r2)
 2027f3c:	1004963a 	slli	r2,r2,24
 2027f40:	10c4b03a 	or	r2,r2,r3
 2027f44:	1009883a 	mov	r4,r2
 2027f48:	20394b00 	call	20394b0 <lwip_htonl>
 2027f4c:	1007883a 	mov	r3,r2
 2027f50:	e0bffc17 	ldw	r2,-16(fp)
 2027f54:	10c01015 	stw	r3,64(r2)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
                                 lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
                                 seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 2027f58:	e0bffb17 	ldw	r2,-20(fp)
 2027f5c:	10800417 	ldw	r2,16(r2)
 2027f60:	1007883a 	mov	r3,r2
 2027f64:	e0bffb17 	ldw	r2,-20(fp)
 2027f68:	10800117 	ldw	r2,4(r2)
 2027f6c:	10800117 	ldw	r2,4(r2)
 2027f70:	1885c83a 	sub	r2,r3,r2
 2027f74:	e0bff88d 	sth	r2,-30(fp)
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
 2027f78:	e0bffb17 	ldw	r2,-20(fp)
 2027f7c:	10800117 	ldw	r2,4(r2)
 2027f80:	e0fffb17 	ldw	r3,-20(fp)
 2027f84:	18c00117 	ldw	r3,4(r3)
 2027f88:	1900028b 	ldhu	r4,10(r3)
 2027f8c:	e0fff88b 	ldhu	r3,-30(fp)
 2027f90:	20c7c83a 	sub	r3,r4,r3
 2027f94:	10c0028d 	sth	r3,10(r2)
  seg->p->tot_len -= len;
 2027f98:	e0bffb17 	ldw	r2,-20(fp)
 2027f9c:	10800117 	ldw	r2,4(r2)
 2027fa0:	e0fffb17 	ldw	r3,-20(fp)
 2027fa4:	18c00117 	ldw	r3,4(r3)
 2027fa8:	1900020b 	ldhu	r4,8(r3)
 2027fac:	e0fff88b 	ldhu	r3,-30(fp)
 2027fb0:	20c7c83a 	sub	r3,r4,r3
 2027fb4:	10c0020d 	sth	r3,8(r2)

  seg->p->payload = seg->tcphdr;
 2027fb8:	e0bffb17 	ldw	r2,-20(fp)
 2027fbc:	10800117 	ldw	r2,4(r2)
 2027fc0:	e0fffb17 	ldw	r3,-20(fp)
 2027fc4:	18c00417 	ldw	r3,16(r3)
 2027fc8:	10c00115 	stw	r3,4(r2)

  seg->tcphdr->chksum = 0;
 2027fcc:	e0bffb17 	ldw	r2,-20(fp)
 2027fd0:	10800417 	ldw	r2,16(r2)
 2027fd4:	10c00403 	ldbu	r3,16(r2)
 2027fd8:	1806703a 	and	r3,r3,zero
 2027fdc:	10c00405 	stb	r3,16(r2)
 2027fe0:	10c00443 	ldbu	r3,17(r2)
 2027fe4:	1806703a 	and	r3,r3,zero
 2027fe8:	10c00445 	stb	r3,17(r2)
      LWIP_ASSERT("data included but not checksummed",
                  seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 2027fec:	e0bffb17 	ldw	r2,-20(fp)
 2027ff0:	14000117 	ldw	r16,4(r2)
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 2027ff4:	e0bffb17 	ldw	r2,-20(fp)
 2027ff8:	10800117 	ldw	r2,4(r2)
 2027ffc:	1080020b 	ldhu	r2,8(r2)
      LWIP_ASSERT("data included but not checksummed",
                  seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 2028000:	147fffcc 	andi	r17,r2,65535
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 2028004:	e0bffb17 	ldw	r2,-20(fp)
 2028008:	10800417 	ldw	r2,16(r2)
 202800c:	10c00303 	ldbu	r3,12(r2)
 2028010:	10800343 	ldbu	r2,13(r2)
 2028014:	1004923a 	slli	r2,r2,8
 2028018:	10c4b03a 	or	r2,r2,r3
 202801c:	10bfffcc 	andi	r2,r2,65535
 2028020:	1009883a 	mov	r4,r2
 2028024:	20394740 	call	2039474 <lwip_htons>
 2028028:	10bfffcc 	andi	r2,r2,65535
 202802c:	1004d33a 	srli	r2,r2,12
 2028030:	1085883a 	add	r2,r2,r2
 2028034:	1085883a 	add	r2,r2,r2
      LWIP_ASSERT("data included but not checksummed",
                  seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 2028038:	11003fcc 	andi	r4,r2,255
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 202803c:	e0bffc17 	ldw	r2,-16(fp)
 2028040:	e0fffc17 	ldw	r3,-16(fp)
 2028044:	18c00104 	addi	r3,r3,4
      LWIP_ASSERT("data included but not checksummed",
                  seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 2028048:	d8c00115 	stw	r3,4(sp)
 202804c:	d8800015 	stw	r2,0(sp)
 2028050:	200f883a 	mov	r7,r4
 2028054:	880d883a 	mov	r6,r17
 2028058:	01400184 	movi	r5,6
 202805c:	8009883a 	mov	r4,r16
 2028060:	203a1540 	call	203a154 <ip_chksum_pseudo_partial>
 2028064:	10bfffcc 	andi	r2,r2,65535
 2028068:	e0bff915 	stw	r2,-28(fp)
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
    /* add payload checksum */
    if (seg->chksum_swapped) {
 202806c:	e0bffb17 	ldw	r2,-20(fp)
 2028070:	10800303 	ldbu	r2,12(r2)
 2028074:	10803fcc 	andi	r2,r2,255
 2028078:	10001126 	beq	r2,zero,20280c0 <tcp_output_segment+0x39c>
      seg_chksum_was_swapped = 1;
 202807c:	00800044 	movi	r2,1
 2028080:	e0bff615 	stw	r2,-40(fp)
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 2028084:	e0bffb17 	ldw	r2,-20(fp)
 2028088:	1080028b 	ldhu	r2,10(r2)
 202808c:	10bfffcc 	andi	r2,r2,65535
 2028090:	1004923a 	slli	r2,r2,8
 2028094:	1007883a 	mov	r3,r2
 2028098:	e0bffb17 	ldw	r2,-20(fp)
 202809c:	1080028b 	ldhu	r2,10(r2)
 20280a0:	10bfffcc 	andi	r2,r2,65535
 20280a4:	1004d23a 	srli	r2,r2,8
 20280a8:	1884b03a 	or	r2,r3,r2
 20280ac:	1007883a 	mov	r3,r2
 20280b0:	e0bffb17 	ldw	r2,-20(fp)
 20280b4:	10c0028d 	sth	r3,10(r2)
      seg->chksum_swapped = 0;
 20280b8:	e0bffb17 	ldw	r2,-20(fp)
 20280bc:	10000305 	stb	zero,12(r2)
    }
    acc = (u16_t)~acc + seg->chksum;
 20280c0:	e0bff917 	ldw	r2,-28(fp)
 20280c4:	0084303a 	nor	r2,zero,r2
 20280c8:	10ffffcc 	andi	r3,r2,65535
 20280cc:	e0bffb17 	ldw	r2,-20(fp)
 20280d0:	1080028b 	ldhu	r2,10(r2)
 20280d4:	10bfffcc 	andi	r2,r2,65535
 20280d8:	1885883a 	add	r2,r3,r2
 20280dc:	e0bff915 	stw	r2,-28(fp)
    seg->tcphdr->chksum = (u16_t)~FOLD_U32T(acc);
 20280e0:	e0bffb17 	ldw	r2,-20(fp)
 20280e4:	10800417 	ldw	r2,16(r2)
 20280e8:	e0fff917 	ldw	r3,-28(fp)
 20280ec:	1806d43a 	srli	r3,r3,16
 20280f0:	1809883a 	mov	r4,r3
 20280f4:	e0fff917 	ldw	r3,-28(fp)
 20280f8:	20c7883a 	add	r3,r4,r3
 20280fc:	00c6303a 	nor	r3,zero,r3
 2028100:	180d883a 	mov	r6,r3
 2028104:	30ffffcc 	andi	r3,r6,65535
 2028108:	19403fcc 	andi	r5,r3,255
 202810c:	10c00403 	ldbu	r3,16(r2)
 2028110:	1806703a 	and	r3,r3,zero
 2028114:	1809883a 	mov	r4,r3
 2028118:	2807883a 	mov	r3,r5
 202811c:	20c6b03a 	or	r3,r4,r3
 2028120:	10c00405 	stb	r3,16(r2)
 2028124:	30ffffcc 	andi	r3,r6,65535
 2028128:	1806d23a 	srli	r3,r3,8
 202812c:	197fffcc 	andi	r5,r3,65535
 2028130:	10c00443 	ldbu	r3,17(r2)
 2028134:	1806703a 	and	r3,r3,zero
 2028138:	1809883a 	mov	r4,r3
 202813c:	2807883a 	mov	r3,r5
 2028140:	20c6b03a 	or	r3,r4,r3
 2028144:	10c00445 	stb	r3,17(r2)
    seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
                                           seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
#endif /* TCP_CHECKSUM_ON_COPY */
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 2028148:	008085f4 	movhi	r2,535
 202814c:	10bd8204 	addi	r2,r2,-2552
 2028150:	10804817 	ldw	r2,288(r2)
 2028154:	10c00044 	addi	r3,r2,1
 2028158:	008085f4 	movhi	r2,535
 202815c:	10bd8204 	addi	r2,r2,-2552
 2028160:	10c04815 	stw	r3,288(r2)

  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 2028164:	e0bffc17 	ldw	r2,-16(fp)
 2028168:	10c00304 	addi	r3,r2,12
 202816c:	e0bffd17 	ldw	r2,-12(fp)
 2028170:	10c01215 	stw	r3,72(r2)
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 2028174:	e0bffb17 	ldw	r2,-20(fp)
 2028178:	11000117 	ldw	r4,4(r2)
 202817c:	e17ffc17 	ldw	r5,-16(fp)
 2028180:	e0bffc17 	ldw	r2,-16(fp)
 2028184:	11800104 	addi	r6,r2,4
 2028188:	e0bffc17 	ldw	r2,-16(fp)
 202818c:	108002c3 	ldbu	r2,11(r2)
 2028190:	11c03fcc 	andi	r7,r2,255
 2028194:	e0bffc17 	ldw	r2,-16(fp)
 2028198:	10800283 	ldbu	r2,10(r2)
 202819c:	10803fcc 	andi	r2,r2,255
 20281a0:	e0fffd17 	ldw	r3,-12(fp)
 20281a4:	d8c00215 	stw	r3,8(sp)
 20281a8:	00c00184 	movi	r3,6
 20281ac:	d8c00115 	stw	r3,4(sp)
 20281b0:	d8800015 	stw	r2,0(sp)
 20281b4:	203be1c0 	call	203be1c <ip4_output_if>
 20281b8:	e0bffa05 	stb	r2,-24(fp)
                     pcb->tos, IP_PROTO_TCP, netif);
  NETIF_RESET_HINTS(netif);
 20281bc:	e0bffd17 	ldw	r2,-12(fp)
 20281c0:	10001215 	stw	zero,72(r2)

#if TCP_CHECKSUM_ON_COPY
  if (seg_chksum_was_swapped) {
 20281c4:	e0bff617 	ldw	r2,-40(fp)
 20281c8:	10001026 	beq	r2,zero,202820c <tcp_output_segment+0x4e8>
    /* if data is added to this segment later, chksum needs to be swapped,
       so restore this now */
    seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 20281cc:	e0bffb17 	ldw	r2,-20(fp)
 20281d0:	1080028b 	ldhu	r2,10(r2)
 20281d4:	10bfffcc 	andi	r2,r2,65535
 20281d8:	1004923a 	slli	r2,r2,8
 20281dc:	1007883a 	mov	r3,r2
 20281e0:	e0bffb17 	ldw	r2,-20(fp)
 20281e4:	1080028b 	ldhu	r2,10(r2)
 20281e8:	10bfffcc 	andi	r2,r2,65535
 20281ec:	1004d23a 	srli	r2,r2,8
 20281f0:	1884b03a 	or	r2,r3,r2
 20281f4:	1007883a 	mov	r3,r2
 20281f8:	e0bffb17 	ldw	r2,-20(fp)
 20281fc:	10c0028d 	sth	r3,10(r2)
    seg->chksum_swapped = 1;
 2028200:	e0bffb17 	ldw	r2,-20(fp)
 2028204:	00c00044 	movi	r3,1
 2028208:	10c00305 	stb	r3,12(r2)
  }
#endif

  return err;
 202820c:	e0bffa03 	ldbu	r2,-24(fp)
}
 2028210:	e6fffe04 	addi	sp,fp,-8
 2028214:	dfc00317 	ldw	ra,12(sp)
 2028218:	df000217 	ldw	fp,8(sp)
 202821c:	dc400117 	ldw	r17,4(sp)
 2028220:	dc000017 	ldw	r16,0(sp)
 2028224:	dec00404 	addi	sp,sp,16
 2028228:	f800283a 	ret

0202822c <tcp_rexmit_rto_prepare>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
err_t
tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
{
 202822c:	defffa04 	addi	sp,sp,-24
 2028230:	dfc00515 	stw	ra,20(sp)
 2028234:	df000415 	stw	fp,16(sp)
 2028238:	dc400315 	stw	r17,12(sp)
 202823c:	dc000215 	stw	r16,8(sp)
 2028240:	df000404 	addi	fp,sp,16
 2028244:	e13ffd15 	stw	r4,-12(fp)
  struct tcp_seg *seg;

  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);

  if (pcb->unacked == NULL) {
 2028248:	e0bffd17 	ldw	r2,-12(fp)
 202824c:	10801e17 	ldw	r2,120(r2)
 2028250:	1000021e 	bne	r2,zero,202825c <tcp_rexmit_rto_prepare+0x30>
    return ERR_VAL;
 2028254:	00bffe84 	movi	r2,-6
 2028258:	00004c06 	br	202838c <tcp_rexmit_rto_prepare+0x160>

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 202825c:	e0bffd17 	ldw	r2,-12(fp)
 2028260:	10801e17 	ldw	r2,120(r2)
 2028264:	e0bffc15 	stw	r2,-16(fp)
 2028268:	00000806 	br	202828c <tcp_rexmit_rto_prepare+0x60>
    if (tcp_output_segment_busy(seg)) {
 202826c:	e13ffc17 	ldw	r4,-16(fp)
 2028270:	2027ce00 	call	2027ce0 <tcp_output_segment_busy>
 2028274:	10000226 	beq	r2,zero,2028280 <tcp_rexmit_rto_prepare+0x54>
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
 2028278:	00bffe84 	movi	r2,-6
 202827c:	00004306 	br	202838c <tcp_rexmit_rto_prepare+0x160>

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 2028280:	e0bffc17 	ldw	r2,-16(fp)
 2028284:	10800017 	ldw	r2,0(r2)
 2028288:	e0bffc15 	stw	r2,-16(fp)
 202828c:	e0bffc17 	ldw	r2,-16(fp)
 2028290:	10800017 	ldw	r2,0(r2)
 2028294:	103ff51e 	bne	r2,zero,202826c <__alt_mem_mem_0+0xfd00826c>
    if (tcp_output_segment_busy(seg)) {
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
    }
  }
  if (tcp_output_segment_busy(seg)) {
 2028298:	e13ffc17 	ldw	r4,-16(fp)
 202829c:	2027ce00 	call	2027ce0 <tcp_output_segment_busy>
 20282a0:	10000226 	beq	r2,zero,20282ac <tcp_rexmit_rto_prepare+0x80>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
    return ERR_VAL;
 20282a4:	00bffe84 	movi	r2,-6
 20282a8:	00003806 	br	202838c <tcp_rexmit_rto_prepare+0x160>
  }
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 20282ac:	e0bffd17 	ldw	r2,-12(fp)
 20282b0:	10c01d17 	ldw	r3,116(r2)
 20282b4:	e0bffc17 	ldw	r2,-16(fp)
 20282b8:	10c00015 	stw	r3,0(r2)
  if (pcb->unsent == NULL) {
    pcb->unsent_oversize = seg->oversize_left;
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 20282bc:	e0bffd17 	ldw	r2,-12(fp)
 20282c0:	10c01e17 	ldw	r3,120(r2)
 20282c4:	e0bffd17 	ldw	r2,-12(fp)
 20282c8:	10c01d15 	stw	r3,116(r2)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 20282cc:	e0bffd17 	ldw	r2,-12(fp)
 20282d0:	10001e15 	stw	zero,120(r2)

  /* Mark RTO in-progress */
  tcp_set_flags(pcb, TF_RTO);
 20282d4:	e0bffd17 	ldw	r2,-12(fp)
 20282d8:	1080088b 	ldhu	r2,34(r2)
 20282dc:	10820014 	ori	r2,r2,2048
 20282e0:	1007883a 	mov	r3,r2
 20282e4:	e0bffd17 	ldw	r2,-12(fp)
 20282e8:	10c0088d 	sth	r3,34(r2)
  /* Record the next byte following retransmit */
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 20282ec:	e0bffc17 	ldw	r2,-16(fp)
 20282f0:	10800417 	ldw	r2,16(r2)
 20282f4:	10c00103 	ldbu	r3,4(r2)
 20282f8:	11000143 	ldbu	r4,5(r2)
 20282fc:	2008923a 	slli	r4,r4,8
 2028300:	20c6b03a 	or	r3,r4,r3
 2028304:	11000183 	ldbu	r4,6(r2)
 2028308:	2008943a 	slli	r4,r4,16
 202830c:	20c6b03a 	or	r3,r4,r3
 2028310:	108001c3 	ldbu	r2,7(r2)
 2028314:	1004963a 	slli	r2,r2,24
 2028318:	10c4b03a 	or	r2,r2,r3
 202831c:	1009883a 	mov	r4,r2
 2028320:	20394b00 	call	20394b0 <lwip_htonl>
 2028324:	1023883a 	mov	r17,r2
 2028328:	e0bffc17 	ldw	r2,-16(fp)
 202832c:	1080020b 	ldhu	r2,8(r2)
 2028330:	143fffcc 	andi	r16,r2,65535
 2028334:	e0bffc17 	ldw	r2,-16(fp)
 2028338:	10800417 	ldw	r2,16(r2)
 202833c:	10c00303 	ldbu	r3,12(r2)
 2028340:	10800343 	ldbu	r2,13(r2)
 2028344:	1004923a 	slli	r2,r2,8
 2028348:	10c4b03a 	or	r2,r2,r3
 202834c:	10bfffcc 	andi	r2,r2,65535
 2028350:	1009883a 	mov	r4,r2
 2028354:	20394740 	call	2039474 <lwip_htons>
 2028358:	10803fcc 	andi	r2,r2,255
 202835c:	108000cc 	andi	r2,r2,3
 2028360:	10000226 	beq	r2,zero,202836c <tcp_rexmit_rto_prepare+0x140>
 2028364:	00800044 	movi	r2,1
 2028368:	00000106 	br	2028370 <tcp_rexmit_rto_prepare+0x144>
 202836c:	0005883a 	mov	r2,zero
 2028370:	8085883a 	add	r2,r16,r2
 2028374:	8887883a 	add	r3,r17,r2
 2028378:	e0bffd17 	ldw	r2,-12(fp)
 202837c:	10c01515 	stw	r3,84(r2)
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 2028380:	e0bffd17 	ldw	r2,-12(fp)
 2028384:	10000f15 	stw	zero,60(r2)

  return ERR_OK;
 2028388:	0005883a 	mov	r2,zero
}
 202838c:	e6fffe04 	addi	sp,fp,-8
 2028390:	dfc00317 	ldw	ra,12(sp)
 2028394:	df000217 	ldw	fp,8(sp)
 2028398:	dc400117 	ldw	r17,4(sp)
 202839c:	dc000017 	ldw	r16,0(sp)
 20283a0:	dec00404 	addi	sp,sp,16
 20283a4:	f800283a 	ret

020283a8 <tcp_rexmit_rto_commit>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
{
 20283a8:	defffd04 	addi	sp,sp,-12
 20283ac:	dfc00215 	stw	ra,8(sp)
 20283b0:	df000115 	stw	fp,4(sp)
 20283b4:	df000104 	addi	fp,sp,4
 20283b8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 20283bc:	e0bfff17 	ldw	r2,-4(fp)
 20283c0:	10801283 	ldbu	r2,74(r2)
 20283c4:	10803fcc 	andi	r2,r2,255
 20283c8:	10803fe0 	cmpeqi	r2,r2,255
 20283cc:	1000061e 	bne	r2,zero,20283e8 <tcp_rexmit_rto_commit+0x40>
    ++pcb->nrtx;
 20283d0:	e0bfff17 	ldw	r2,-4(fp)
 20283d4:	10801283 	ldbu	r2,74(r2)
 20283d8:	10800044 	addi	r2,r2,1
 20283dc:	1007883a 	mov	r3,r2
 20283e0:	e0bfff17 	ldw	r2,-4(fp)
 20283e4:	10c01285 	stb	r3,74(r2)
  }
  /* Do the actual retransmission */
  tcp_output(pcb);
 20283e8:	e13fff17 	ldw	r4,-4(fp)
 20283ec:	20275b40 	call	20275b4 <tcp_output>
}
 20283f0:	0001883a 	nop
 20283f4:	e037883a 	mov	sp,fp
 20283f8:	dfc00117 	ldw	ra,4(sp)
 20283fc:	df000017 	ldw	fp,0(sp)
 2028400:	dec00204 	addi	sp,sp,8
 2028404:	f800283a 	ret

02028408 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 2028408:	defffd04 	addi	sp,sp,-12
 202840c:	dfc00215 	stw	ra,8(sp)
 2028410:	df000115 	stw	fp,4(sp)
 2028414:	df000104 	addi	fp,sp,4
 2028418:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);

  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
 202841c:	e13fff17 	ldw	r4,-4(fp)
 2028420:	202822c0 	call	202822c <tcp_rexmit_rto_prepare>
 2028424:	10803fcc 	andi	r2,r2,255
 2028428:	1080201c 	xori	r2,r2,128
 202842c:	10bfe004 	addi	r2,r2,-128
 2028430:	1000021e 	bne	r2,zero,202843c <tcp_rexmit_rto+0x34>
    tcp_rexmit_rto_commit(pcb);
 2028434:	e13fff17 	ldw	r4,-4(fp)
 2028438:	20283a80 	call	20283a8 <tcp_rexmit_rto_commit>
  }
}
 202843c:	0001883a 	nop
 2028440:	e037883a 	mov	sp,fp
 2028444:	dfc00117 	ldw	ra,4(sp)
 2028448:	df000017 	ldw	fp,0(sp)
 202844c:	dec00204 	addi	sp,sp,8
 2028450:	f800283a 	ret

02028454 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
err_t
tcp_rexmit(struct tcp_pcb *pcb)
{
 2028454:	defffa04 	addi	sp,sp,-24
 2028458:	dfc00515 	stw	ra,20(sp)
 202845c:	df000415 	stw	fp,16(sp)
 2028460:	dc000315 	stw	r16,12(sp)
 2028464:	df000404 	addi	fp,sp,16
 2028468:	e13ffe15 	stw	r4,-8(fp)
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);

  if (pcb->unacked == NULL) {
 202846c:	e0bffe17 	ldw	r2,-8(fp)
 2028470:	10801e17 	ldw	r2,120(r2)
 2028474:	1000021e 	bne	r2,zero,2028480 <tcp_rexmit+0x2c>
    return ERR_VAL;
 2028478:	00bffe84 	movi	r2,-6
 202847c:	00005006 	br	20285c0 <tcp_rexmit+0x16c>
  }

  seg = pcb->unacked;
 2028480:	e0bffe17 	ldw	r2,-8(fp)
 2028484:	10801e17 	ldw	r2,120(r2)
 2028488:	e0bffd15 	stw	r2,-12(fp)

  /* Give up if the segment is still referenced by the netif driver
     due to deferred transmission. */
  if (tcp_output_segment_busy(seg)) {
 202848c:	e13ffd17 	ldw	r4,-12(fp)
 2028490:	2027ce00 	call	2027ce0 <tcp_output_segment_busy>
 2028494:	10000226 	beq	r2,zero,20284a0 <tcp_rexmit+0x4c>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
    return ERR_VAL;
 2028498:	00bffe84 	movi	r2,-6
 202849c:	00004806 	br	20285c0 <tcp_rexmit+0x16c>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;
 20284a0:	e0bffd17 	ldw	r2,-12(fp)
 20284a4:	10c00017 	ldw	r3,0(r2)
 20284a8:	e0bffe17 	ldw	r2,-8(fp)
 20284ac:	10c01e15 	stw	r3,120(r2)

  cur_seg = &(pcb->unsent);
 20284b0:	e0bffe17 	ldw	r2,-8(fp)
 20284b4:	10801d04 	addi	r2,r2,116
 20284b8:	e0bffc15 	stw	r2,-16(fp)
  while (*cur_seg &&
 20284bc:	00000306 	br	20284cc <tcp_rexmit+0x78>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
 20284c0:	e0bffc17 	ldw	r2,-16(fp)
 20284c4:	10800017 	ldw	r2,0(r2)
 20284c8:	e0bffc15 	stw	r2,-16(fp)
  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 20284cc:	e0bffc17 	ldw	r2,-16(fp)
 20284d0:	10800017 	ldw	r2,0(r2)
 20284d4:	10002026 	beq	r2,zero,2028558 <tcp_rexmit+0x104>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 20284d8:	e0bffc17 	ldw	r2,-16(fp)
 20284dc:	10800017 	ldw	r2,0(r2)
 20284e0:	10800417 	ldw	r2,16(r2)
 20284e4:	10c00103 	ldbu	r3,4(r2)
 20284e8:	11000143 	ldbu	r4,5(r2)
 20284ec:	2008923a 	slli	r4,r4,8
 20284f0:	20c6b03a 	or	r3,r4,r3
 20284f4:	11000183 	ldbu	r4,6(r2)
 20284f8:	2008943a 	slli	r4,r4,16
 20284fc:	20c6b03a 	or	r3,r4,r3
 2028500:	108001c3 	ldbu	r2,7(r2)
 2028504:	1004963a 	slli	r2,r2,24
 2028508:	10c4b03a 	or	r2,r2,r3
 202850c:	1009883a 	mov	r4,r2
 2028510:	20394b00 	call	20394b0 <lwip_htonl>
 2028514:	1021883a 	mov	r16,r2
 2028518:	e0bffd17 	ldw	r2,-12(fp)
 202851c:	10800417 	ldw	r2,16(r2)
 2028520:	10c00103 	ldbu	r3,4(r2)
 2028524:	11000143 	ldbu	r4,5(r2)
 2028528:	2008923a 	slli	r4,r4,8
 202852c:	20c6b03a 	or	r3,r4,r3
 2028530:	11000183 	ldbu	r4,6(r2)
 2028534:	2008943a 	slli	r4,r4,16
 2028538:	20c6b03a 	or	r3,r4,r3
 202853c:	108001c3 	ldbu	r2,7(r2)
 2028540:	1004963a 	slli	r2,r2,24
 2028544:	10c4b03a 	or	r2,r2,r3
 2028548:	1009883a 	mov	r4,r2
 202854c:	20394b00 	call	20394b0 <lwip_htonl>
 2028550:	8085c83a 	sub	r2,r16,r2
  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 2028554:	103fda16 	blt	r2,zero,20284c0 <__alt_mem_mem_0+0xfd0084c0>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 2028558:	e0bffc17 	ldw	r2,-16(fp)
 202855c:	10c00017 	ldw	r3,0(r2)
 2028560:	e0bffd17 	ldw	r2,-12(fp)
 2028564:	10c00015 	stw	r3,0(r2)
  *cur_seg = seg;
 2028568:	e0bffc17 	ldw	r2,-16(fp)
 202856c:	e0fffd17 	ldw	r3,-12(fp)
 2028570:	10c00015 	stw	r3,0(r2)
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 2028574:	e0bffd17 	ldw	r2,-12(fp)
 2028578:	10800017 	ldw	r2,0(r2)
 202857c:	1000021e 	bne	r2,zero,2028588 <tcp_rexmit+0x134>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 2028580:	e0bffe17 	ldw	r2,-8(fp)
 2028584:	10001c0d 	sth	zero,112(r2)
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 2028588:	e0bffe17 	ldw	r2,-8(fp)
 202858c:	10801283 	ldbu	r2,74(r2)
 2028590:	10803fcc 	andi	r2,r2,255
 2028594:	10803fe0 	cmpeqi	r2,r2,255
 2028598:	1000061e 	bne	r2,zero,20285b4 <tcp_rexmit+0x160>
    ++pcb->nrtx;
 202859c:	e0bffe17 	ldw	r2,-8(fp)
 20285a0:	10801283 	ldbu	r2,74(r2)
 20285a4:	10800044 	addi	r2,r2,1
 20285a8:	1007883a 	mov	r3,r2
 20285ac:	e0bffe17 	ldw	r2,-8(fp)
 20285b0:	10c01285 	stb	r3,74(r2)
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 20285b4:	e0bffe17 	ldw	r2,-8(fp)
 20285b8:	10000f15 	stw	zero,60(r2)

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
  return ERR_OK;
 20285bc:	0005883a 	mov	r2,zero
}
 20285c0:	e6ffff04 	addi	sp,fp,-4
 20285c4:	dfc00217 	ldw	ra,8(sp)
 20285c8:	df000117 	ldw	fp,4(sp)
 20285cc:	dc000017 	ldw	r16,0(sp)
 20285d0:	dec00304 	addi	sp,sp,12
 20285d4:	f800283a 	ret

020285d8 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 20285d8:	defffd04 	addi	sp,sp,-12
 20285dc:	dfc00215 	stw	ra,8(sp)
 20285e0:	df000115 	stw	fp,4(sp)
 20285e4:	df000104 	addi	fp,sp,4
 20285e8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);

  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 20285ec:	e0bfff17 	ldw	r2,-4(fp)
 20285f0:	10801e17 	ldw	r2,120(r2)
 20285f4:	10003c26 	beq	r2,zero,20286e8 <tcp_rexmit_fast+0x110>
 20285f8:	e0bfff17 	ldw	r2,-4(fp)
 20285fc:	1080088b 	ldhu	r2,34(r2)
 2028600:	10bfffcc 	andi	r2,r2,65535
 2028604:	1080010c 	andi	r2,r2,4
 2028608:	1000371e 	bne	r2,zero,20286e8 <tcp_rexmit_fast+0x110>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    if (tcp_rexmit(pcb) == ERR_OK) {
 202860c:	e13fff17 	ldw	r4,-4(fp)
 2028610:	20284540 	call	2028454 <tcp_rexmit>
 2028614:	10803fcc 	andi	r2,r2,255
 2028618:	1080201c 	xori	r2,r2,128
 202861c:	10bfe004 	addi	r2,r2,-128
 2028620:	1000311e 	bne	r2,zero,20286e8 <tcp_rexmit_fast+0x110>
      /* Set ssthresh to half of the minimum of the current
       * cwnd and the advertised window */
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 2028624:	e0bfff17 	ldw	r2,-4(fp)
 2028628:	10c01a0b 	ldhu	r3,104(r2)
 202862c:	e0bfff17 	ldw	r2,-4(fp)
 2028630:	1140140b 	ldhu	r5,80(r2)
 2028634:	1809883a 	mov	r4,r3
 2028638:	20bfffcc 	andi	r2,r4,65535
 202863c:	28ffffcc 	andi	r3,r5,65535
 2028640:	1880012e 	bgeu	r3,r2,2028648 <tcp_rexmit_fast+0x70>
 2028644:	2809883a 	mov	r4,r5
 2028648:	20bfffcc 	andi	r2,r4,65535
 202864c:	1006d7fa 	srli	r3,r2,31
 2028650:	1885883a 	add	r2,r3,r2
 2028654:	1005d07a 	srai	r2,r2,1
 2028658:	1007883a 	mov	r3,r2
 202865c:	e0bfff17 	ldw	r2,-4(fp)
 2028660:	10c0148d 	sth	r3,82(r2)

      /* The minimum value for ssthresh should be 2 MSS */
      if (pcb->ssthresh < (2U * pcb->mss)) {
 2028664:	e0bfff17 	ldw	r2,-4(fp)
 2028668:	1080148b 	ldhu	r2,82(r2)
 202866c:	10ffffcc 	andi	r3,r2,65535
 2028670:	e0bfff17 	ldw	r2,-4(fp)
 2028674:	10800e8b 	ldhu	r2,58(r2)
 2028678:	10bfffcc 	andi	r2,r2,65535
 202867c:	1085883a 	add	r2,r2,r2
 2028680:	1880062e 	bgeu	r3,r2,202869c <tcp_rexmit_fast+0xc4>
        LWIP_DEBUGF(TCP_FR_DEBUG,
                    ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                     " should be min 2 mss %"U16_F"...\n",
                     pcb->ssthresh, (u16_t)(2 * pcb->mss)));
        pcb->ssthresh = 2 * pcb->mss;
 2028684:	e0bfff17 	ldw	r2,-4(fp)
 2028688:	10800e8b 	ldhu	r2,58(r2)
 202868c:	1085883a 	add	r2,r2,r2
 2028690:	1007883a 	mov	r3,r2
 2028694:	e0bfff17 	ldw	r2,-4(fp)
 2028698:	10c0148d 	sth	r3,82(r2)
      }

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 202869c:	e0bfff17 	ldw	r2,-4(fp)
 20286a0:	1100148b 	ldhu	r4,82(r2)
 20286a4:	e0bfff17 	ldw	r2,-4(fp)
 20286a8:	10c00e8b 	ldhu	r3,58(r2)
 20286ac:	1805883a 	mov	r2,r3
 20286b0:	1085883a 	add	r2,r2,r2
 20286b4:	10c5883a 	add	r2,r2,r3
 20286b8:	2085883a 	add	r2,r4,r2
 20286bc:	1007883a 	mov	r3,r2
 20286c0:	e0bfff17 	ldw	r2,-4(fp)
 20286c4:	10c0140d 	sth	r3,80(r2)
      tcp_set_flags(pcb, TF_INFR);
 20286c8:	e0bfff17 	ldw	r2,-4(fp)
 20286cc:	1080088b 	ldhu	r2,34(r2)
 20286d0:	10800114 	ori	r2,r2,4
 20286d4:	1007883a 	mov	r3,r2
 20286d8:	e0bfff17 	ldw	r2,-4(fp)
 20286dc:	10c0088d 	sth	r3,34(r2)

      /* Reset the retransmission timer to prevent immediate rto retransmissions */
      pcb->rtime = 0;
 20286e0:	e0bfff17 	ldw	r2,-4(fp)
 20286e4:	10000e0d 	sth	zero,56(r2)
    }
  }
}
 20286e8:	0001883a 	nop
 20286ec:	e037883a 	mov	sp,fp
 20286f0:	dfc00117 	ldw	ra,4(sp)
 20286f4:	df000017 	ldw	fp,0(sp)
 20286f8:	dec00204 	addi	sp,sp,8
 20286fc:	f800283a 	ret

02028700 <tcp_output_alloc_header_common>:

static struct pbuf *
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */,
                        u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
 2028700:	defff404 	addi	sp,sp,-48
 2028704:	dfc00b15 	stw	ra,44(sp)
 2028708:	df000a15 	stw	fp,40(sp)
 202870c:	df000a04 	addi	fp,sp,40
 2028710:	e13ff815 	stw	r4,-32(fp)
 2028714:	2811883a 	mov	r8,r5
 2028718:	e1fffb15 	stw	r7,-20(fp)
 202871c:	e1400217 	ldw	r5,8(fp)
 2028720:	e1000317 	ldw	r4,12(fp)
 2028724:	e0c00417 	ldw	r3,16(fp)
 2028728:	e0800517 	ldw	r2,20(fp)
 202872c:	e23ff90d 	sth	r8,-28(fp)
 2028730:	e1bffa0d 	sth	r6,-24(fp)
 2028734:	e17ffc0d 	sth	r5,-16(fp)
 2028738:	e13ffd0d 	sth	r4,-12(fp)
 202873c:	e0fffe05 	stb	r3,-8(fp)
 2028740:	e0bfff0d 	sth	r2,-4(fp)
  struct tcp_hdr *tcphdr;
  struct pbuf *p;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 2028744:	e0fff90b 	ldhu	r3,-28(fp)
 2028748:	e0bffa0b 	ldhu	r2,-24(fp)
 202874c:	1885883a 	add	r2,r3,r2
 2028750:	10800504 	addi	r2,r2,20
 2028754:	10bfffcc 	andi	r2,r2,65535
 2028758:	0180a004 	movi	r6,640
 202875c:	100b883a 	mov	r5,r2
 2028760:	01000904 	movi	r4,36
 2028764:	201c9740 	call	201c974 <pbuf_alloc>
 2028768:	e0bff615 	stw	r2,-40(fp)
  if (p != NULL) {
 202876c:	e0bff617 	ldw	r2,-40(fp)
 2028770:	1000b526 	beq	r2,zero,2028a48 <tcp_output_alloc_header_common+0x348>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 2028774:	e0bff617 	ldw	r2,-40(fp)
 2028778:	10800117 	ldw	r2,4(r2)
 202877c:	e0bff715 	stw	r2,-36(fp)
    tcphdr->src = lwip_htons(src_port);
 2028780:	e0bffc0b 	ldhu	r2,-16(fp)
 2028784:	1009883a 	mov	r4,r2
 2028788:	20394740 	call	2039474 <lwip_htons>
 202878c:	100d883a 	mov	r6,r2
 2028790:	e0bff717 	ldw	r2,-36(fp)
 2028794:	30ffffcc 	andi	r3,r6,65535
 2028798:	19403fcc 	andi	r5,r3,255
 202879c:	10c00003 	ldbu	r3,0(r2)
 20287a0:	1806703a 	and	r3,r3,zero
 20287a4:	1809883a 	mov	r4,r3
 20287a8:	2807883a 	mov	r3,r5
 20287ac:	20c6b03a 	or	r3,r4,r3
 20287b0:	10c00005 	stb	r3,0(r2)
 20287b4:	30ffffcc 	andi	r3,r6,65535
 20287b8:	1806d23a 	srli	r3,r3,8
 20287bc:	197fffcc 	andi	r5,r3,65535
 20287c0:	10c00043 	ldbu	r3,1(r2)
 20287c4:	1806703a 	and	r3,r3,zero
 20287c8:	1809883a 	mov	r4,r3
 20287cc:	2807883a 	mov	r3,r5
 20287d0:	20c6b03a 	or	r3,r4,r3
 20287d4:	10c00045 	stb	r3,1(r2)
    tcphdr->dest = lwip_htons(dst_port);
 20287d8:	e0bffd0b 	ldhu	r2,-12(fp)
 20287dc:	1009883a 	mov	r4,r2
 20287e0:	20394740 	call	2039474 <lwip_htons>
 20287e4:	100d883a 	mov	r6,r2
 20287e8:	e0bff717 	ldw	r2,-36(fp)
 20287ec:	30ffffcc 	andi	r3,r6,65535
 20287f0:	19403fcc 	andi	r5,r3,255
 20287f4:	10c00083 	ldbu	r3,2(r2)
 20287f8:	1806703a 	and	r3,r3,zero
 20287fc:	1809883a 	mov	r4,r3
 2028800:	2807883a 	mov	r3,r5
 2028804:	20c6b03a 	or	r3,r4,r3
 2028808:	10c00085 	stb	r3,2(r2)
 202880c:	30ffffcc 	andi	r3,r6,65535
 2028810:	1806d23a 	srli	r3,r3,8
 2028814:	197fffcc 	andi	r5,r3,65535
 2028818:	10c000c3 	ldbu	r3,3(r2)
 202881c:	1806703a 	and	r3,r3,zero
 2028820:	1809883a 	mov	r4,r3
 2028824:	2807883a 	mov	r3,r5
 2028828:	20c6b03a 	or	r3,r4,r3
 202882c:	10c000c5 	stb	r3,3(r2)
    tcphdr->seqno = seqno_be;
 2028830:	e0bff717 	ldw	r2,-36(fp)
 2028834:	e0fffb17 	ldw	r3,-20(fp)
 2028838:	19403fcc 	andi	r5,r3,255
 202883c:	10c00103 	ldbu	r3,4(r2)
 2028840:	1806703a 	and	r3,r3,zero
 2028844:	1809883a 	mov	r4,r3
 2028848:	2807883a 	mov	r3,r5
 202884c:	20c6b03a 	or	r3,r4,r3
 2028850:	10c00105 	stb	r3,4(r2)
 2028854:	e0fffb17 	ldw	r3,-20(fp)
 2028858:	1806d23a 	srli	r3,r3,8
 202885c:	19403fcc 	andi	r5,r3,255
 2028860:	10c00143 	ldbu	r3,5(r2)
 2028864:	1806703a 	and	r3,r3,zero
 2028868:	1809883a 	mov	r4,r3
 202886c:	2807883a 	mov	r3,r5
 2028870:	20c6b03a 	or	r3,r4,r3
 2028874:	10c00145 	stb	r3,5(r2)
 2028878:	e0fffb17 	ldw	r3,-20(fp)
 202887c:	1806d43a 	srli	r3,r3,16
 2028880:	19403fcc 	andi	r5,r3,255
 2028884:	10c00183 	ldbu	r3,6(r2)
 2028888:	1806703a 	and	r3,r3,zero
 202888c:	1809883a 	mov	r4,r3
 2028890:	2807883a 	mov	r3,r5
 2028894:	20c6b03a 	or	r3,r4,r3
 2028898:	10c00185 	stb	r3,6(r2)
 202889c:	e0fffb17 	ldw	r3,-20(fp)
 20288a0:	180ad63a 	srli	r5,r3,24
 20288a4:	10c001c3 	ldbu	r3,7(r2)
 20288a8:	1806703a 	and	r3,r3,zero
 20288ac:	1809883a 	mov	r4,r3
 20288b0:	2807883a 	mov	r3,r5
 20288b4:	20c6b03a 	or	r3,r4,r3
 20288b8:	10c001c5 	stb	r3,7(r2)
    tcphdr->ackno = lwip_htonl(ackno);
 20288bc:	e13ff817 	ldw	r4,-32(fp)
 20288c0:	20394b00 	call	20394b0 <lwip_htonl>
 20288c4:	1007883a 	mov	r3,r2
 20288c8:	e0bff717 	ldw	r2,-36(fp)
 20288cc:	19803fcc 	andi	r6,r3,255
 20288d0:	11000203 	ldbu	r4,8(r2)
 20288d4:	2008703a 	and	r4,r4,zero
 20288d8:	200b883a 	mov	r5,r4
 20288dc:	3009883a 	mov	r4,r6
 20288e0:	2908b03a 	or	r4,r5,r4
 20288e4:	11000205 	stb	r4,8(r2)
 20288e8:	1808d23a 	srli	r4,r3,8
 20288ec:	21803fcc 	andi	r6,r4,255
 20288f0:	11000243 	ldbu	r4,9(r2)
 20288f4:	2008703a 	and	r4,r4,zero
 20288f8:	200b883a 	mov	r5,r4
 20288fc:	3009883a 	mov	r4,r6
 2028900:	2908b03a 	or	r4,r5,r4
 2028904:	11000245 	stb	r4,9(r2)
 2028908:	1808d43a 	srli	r4,r3,16
 202890c:	21803fcc 	andi	r6,r4,255
 2028910:	11000283 	ldbu	r4,10(r2)
 2028914:	2008703a 	and	r4,r4,zero
 2028918:	200b883a 	mov	r5,r4
 202891c:	3009883a 	mov	r4,r6
 2028920:	2908b03a 	or	r4,r5,r4
 2028924:	11000285 	stb	r4,10(r2)
 2028928:	180ad63a 	srli	r5,r3,24
 202892c:	10c002c3 	ldbu	r3,11(r2)
 2028930:	1806703a 	and	r3,r3,zero
 2028934:	1809883a 	mov	r4,r3
 2028938:	2807883a 	mov	r3,r5
 202893c:	20c6b03a 	or	r3,r4,r3
 2028940:	10c002c5 	stb	r3,11(r2)
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
 2028944:	e0bff90b 	ldhu	r2,-28(fp)
 2028948:	1004d0ba 	srli	r2,r2,2
 202894c:	10800144 	addi	r2,r2,5
 2028950:	1004933a 	slli	r2,r2,12
 2028954:	1007883a 	mov	r3,r2
 2028958:	e0bffe03 	ldbu	r2,-8(fp)
 202895c:	1884b03a 	or	r2,r3,r2
 2028960:	10bfffcc 	andi	r2,r2,65535
 2028964:	1009883a 	mov	r4,r2
 2028968:	20394740 	call	2039474 <lwip_htons>
 202896c:	100d883a 	mov	r6,r2
 2028970:	e0bff717 	ldw	r2,-36(fp)
 2028974:	30ffffcc 	andi	r3,r6,65535
 2028978:	19403fcc 	andi	r5,r3,255
 202897c:	10c00303 	ldbu	r3,12(r2)
 2028980:	1806703a 	and	r3,r3,zero
 2028984:	1809883a 	mov	r4,r3
 2028988:	2807883a 	mov	r3,r5
 202898c:	20c6b03a 	or	r3,r4,r3
 2028990:	10c00305 	stb	r3,12(r2)
 2028994:	30ffffcc 	andi	r3,r6,65535
 2028998:	1806d23a 	srli	r3,r3,8
 202899c:	197fffcc 	andi	r5,r3,65535
 20289a0:	10c00343 	ldbu	r3,13(r2)
 20289a4:	1806703a 	and	r3,r3,zero
 20289a8:	1809883a 	mov	r4,r3
 20289ac:	2807883a 	mov	r3,r5
 20289b0:	20c6b03a 	or	r3,r4,r3
 20289b4:	10c00345 	stb	r3,13(r2)
    tcphdr->wnd = lwip_htons(wnd);
 20289b8:	e0bfff0b 	ldhu	r2,-4(fp)
 20289bc:	1009883a 	mov	r4,r2
 20289c0:	20394740 	call	2039474 <lwip_htons>
 20289c4:	100d883a 	mov	r6,r2
 20289c8:	e0bff717 	ldw	r2,-36(fp)
 20289cc:	30ffffcc 	andi	r3,r6,65535
 20289d0:	19403fcc 	andi	r5,r3,255
 20289d4:	10c00383 	ldbu	r3,14(r2)
 20289d8:	1806703a 	and	r3,r3,zero
 20289dc:	1809883a 	mov	r4,r3
 20289e0:	2807883a 	mov	r3,r5
 20289e4:	20c6b03a 	or	r3,r4,r3
 20289e8:	10c00385 	stb	r3,14(r2)
 20289ec:	30ffffcc 	andi	r3,r6,65535
 20289f0:	1806d23a 	srli	r3,r3,8
 20289f4:	197fffcc 	andi	r5,r3,65535
 20289f8:	10c003c3 	ldbu	r3,15(r2)
 20289fc:	1806703a 	and	r3,r3,zero
 2028a00:	1809883a 	mov	r4,r3
 2028a04:	2807883a 	mov	r3,r5
 2028a08:	20c6b03a 	or	r3,r4,r3
 2028a0c:	10c003c5 	stb	r3,15(r2)
    tcphdr->chksum = 0;
 2028a10:	e0bff717 	ldw	r2,-36(fp)
 2028a14:	10c00403 	ldbu	r3,16(r2)
 2028a18:	1806703a 	and	r3,r3,zero
 2028a1c:	10c00405 	stb	r3,16(r2)
 2028a20:	10c00443 	ldbu	r3,17(r2)
 2028a24:	1806703a 	and	r3,r3,zero
 2028a28:	10c00445 	stb	r3,17(r2)
    tcphdr->urgp = 0;
 2028a2c:	e0bff717 	ldw	r2,-36(fp)
 2028a30:	10c00483 	ldbu	r3,18(r2)
 2028a34:	1806703a 	and	r3,r3,zero
 2028a38:	10c00485 	stb	r3,18(r2)
 2028a3c:	10c004c3 	ldbu	r3,19(r2)
 2028a40:	1806703a 	and	r3,r3,zero
 2028a44:	10c004c5 	stb	r3,19(r2)
  }
  return p;
 2028a48:	e0bff617 	ldw	r2,-40(fp)
}
 2028a4c:	e037883a 	mov	sp,fp
 2028a50:	dfc00117 	ldw	ra,4(sp)
 2028a54:	df000017 	ldw	fp,0(sp)
 2028a58:	dec00204 	addi	sp,sp,8
 2028a5c:	f800283a 	ret

02028a60 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */)
{
 2028a60:	defff504 	addi	sp,sp,-44
 2028a64:	dfc00a15 	stw	ra,40(sp)
 2028a68:	df000915 	stw	fp,36(sp)
 2028a6c:	df000904 	addi	fp,sp,36
 2028a70:	e13ffc15 	stw	r4,-16(fp)
 2028a74:	2807883a 	mov	r3,r5
 2028a78:	3005883a 	mov	r2,r6
 2028a7c:	e1ffff15 	stw	r7,-4(fp)
 2028a80:	e0fffd0d 	sth	r3,-12(fp)
 2028a84:	e0bffe0d 	sth	r2,-8(fp)
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 2028a88:	e0bffc17 	ldw	r2,-16(fp)
 2028a8c:	12000b17 	ldw	r8,44(r2)
 2028a90:	e17ffd0b 	ldhu	r5,-12(fp)
 2028a94:	e1bffe0b 	ldhu	r6,-8(fp)
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
 2028a98:	e0bffc17 	ldw	r2,-16(fp)
 2028a9c:	1080078b 	ldhu	r2,30(r2)
{
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 2028aa0:	10bfffcc 	andi	r2,r2,65535
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
 2028aa4:	e0fffc17 	ldw	r3,-16(fp)
 2028aa8:	18c0080b 	ldhu	r3,32(r3)
{
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 2028aac:	18ffffcc 	andi	r3,r3,65535
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 2028ab0:	e13ffc17 	ldw	r4,-16(fp)
 2028ab4:	21000c8b 	ldhu	r4,50(r4)
{
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 2028ab8:	213fffcc 	andi	r4,r4,65535
 2028abc:	d9000315 	stw	r4,12(sp)
 2028ac0:	01000404 	movi	r4,16
 2028ac4:	d9000215 	stw	r4,8(sp)
 2028ac8:	d8c00115 	stw	r3,4(sp)
 2028acc:	d8800015 	stw	r2,0(sp)
 2028ad0:	e1ffff17 	ldw	r7,-4(fp)
 2028ad4:	4009883a 	mov	r4,r8
 2028ad8:	20287000 	call	2028700 <tcp_output_alloc_header_common>
 2028adc:	e0bffb15 	stw	r2,-20(fp)
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  if (p != NULL) {
 2028ae0:	e0bffb17 	ldw	r2,-20(fp)
 2028ae4:	10000826 	beq	r2,zero,2028b08 <tcp_output_alloc_header+0xa8>
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 2028ae8:	e0bffc17 	ldw	r2,-16(fp)
 2028aec:	10c00b17 	ldw	r3,44(r2)
 2028af0:	e0bffc17 	ldw	r2,-16(fp)
 2028af4:	10800c8b 	ldhu	r2,50(r2)
 2028af8:	10bfffcc 	andi	r2,r2,65535
 2028afc:	1887883a 	add	r3,r3,r2
 2028b00:	e0bffc17 	ldw	r2,-16(fp)
 2028b04:	10c00d15 	stw	r3,52(r2)
  }
  return p;
 2028b08:	e0bffb17 	ldw	r2,-20(fp)
}
 2028b0c:	e037883a 	mov	sp,fp
 2028b10:	dfc00117 	ldw	ra,4(sp)
 2028b14:	df000017 	ldw	fp,0(sp)
 2028b18:	dec00204 	addi	sp,sp,8
 2028b1c:	f800283a 	ret

02028b20 <tcp_output_fill_options>:

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
{
 2028b20:	defff804 	addi	sp,sp,-32
 2028b24:	df000715 	stw	fp,28(sp)
 2028b28:	df000704 	addi	fp,sp,28
 2028b2c:	e13ffc15 	stw	r4,-16(fp)
 2028b30:	e17ffd15 	stw	r5,-12(fp)
 2028b34:	3007883a 	mov	r3,r6
 2028b38:	3805883a 	mov	r2,r7
 2028b3c:	e0fffe05 	stb	r3,-8(fp)
 2028b40:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;
 2028b44:	e03ff90d 	sth	zero,-28(fp)

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);

  tcphdr = (struct tcp_hdr *)p->payload;
 2028b48:	e0bffd17 	ldw	r2,-12(fp)
 2028b4c:	10800117 	ldw	r2,4(r2)
 2028b50:	e0bffa15 	stw	r2,-24(fp)
  opts = (u32_t *)(void *)(tcphdr + 1);
 2028b54:	e0bffa17 	ldw	r2,-24(fp)
 2028b58:	10800504 	addi	r2,r2,20
 2028b5c:	e0bffb15 	stw	r2,-20(fp)
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
 2028b60:	0001883a 	nop
 2028b64:	e037883a 	mov	sp,fp
 2028b68:	df000017 	ldw	fp,0(sp)
 2028b6c:	dec00104 	addi	sp,sp,4
 2028b70:	f800283a 	ret

02028b74 <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
 2028b74:	defff404 	addi	sp,sp,-48
 2028b78:	dfc00b15 	stw	ra,44(sp)
 2028b7c:	df000a15 	stw	fp,40(sp)
 2028b80:	df000a04 	addi	fp,sp,40
 2028b84:	e13ffc15 	stw	r4,-16(fp)
 2028b88:	e17ffd15 	stw	r5,-12(fp)
 2028b8c:	e1bffe15 	stw	r6,-8(fp)
 2028b90:	e1ffff15 	stw	r7,-4(fp)
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);

  netif = tcp_route(pcb, src, dst);
 2028b94:	e1bfff17 	ldw	r6,-4(fp)
 2028b98:	e17ffe17 	ldw	r5,-8(fp)
 2028b9c:	e13ffc17 	ldw	r4,-16(fp)
 2028ba0:	2025ba40 	call	2025ba4 <tcp_route>
 2028ba4:	e0bffa15 	stw	r2,-24(fp)
  if (netif == NULL) {
 2028ba8:	e0bffa17 	ldw	r2,-24(fp)
 2028bac:	1000031e 	bne	r2,zero,2028bbc <tcp_output_control_segment+0x48>
    err = ERR_RTE;
 2028bb0:	00bfff04 	movi	r2,-4
 2028bb4:	e0bff905 	stb	r2,-28(fp)
 2028bb8:	00004606 	br	2028cd4 <tcp_output_control_segment+0x160>
  } else {
    u8_t ttl, tos;
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
 2028bbc:	e0bffd17 	ldw	r2,-12(fp)
 2028bc0:	10800117 	ldw	r2,4(r2)
 2028bc4:	e0bffb15 	stw	r2,-20(fp)
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 2028bc8:	e0bffd17 	ldw	r2,-12(fp)
 2028bcc:	1080020b 	ldhu	r2,8(r2)
 2028bd0:	10ffffcc 	andi	r3,r2,65535
 2028bd4:	e0bfff17 	ldw	r2,-4(fp)
 2028bd8:	d8800015 	stw	r2,0(sp)
 2028bdc:	e1fffe17 	ldw	r7,-8(fp)
 2028be0:	180d883a 	mov	r6,r3
 2028be4:	01400184 	movi	r5,6
 2028be8:	e13ffd17 	ldw	r4,-12(fp)
 2028bec:	2039e440 	call	2039e44 <ip_chksum_pseudo>
 2028bf0:	100d883a 	mov	r6,r2
 2028bf4:	e0bffb17 	ldw	r2,-20(fp)
 2028bf8:	30ffffcc 	andi	r3,r6,65535
 2028bfc:	19403fcc 	andi	r5,r3,255
 2028c00:	10c00403 	ldbu	r3,16(r2)
 2028c04:	1806703a 	and	r3,r3,zero
 2028c08:	1809883a 	mov	r4,r3
 2028c0c:	2807883a 	mov	r3,r5
 2028c10:	20c6b03a 	or	r3,r4,r3
 2028c14:	10c00405 	stb	r3,16(r2)
 2028c18:	30ffffcc 	andi	r3,r6,65535
 2028c1c:	1806d23a 	srli	r3,r3,8
 2028c20:	197fffcc 	andi	r5,r3,65535
 2028c24:	10c00443 	ldbu	r3,17(r2)
 2028c28:	1806703a 	and	r3,r3,zero
 2028c2c:	1809883a 	mov	r4,r3
 2028c30:	2807883a 	mov	r3,r5
 2028c34:	20c6b03a 	or	r3,r4,r3
 2028c38:	10c00445 	stb	r3,17(r2)
                                        src, dst);
    }
#endif
    if (pcb != NULL) {
 2028c3c:	e0bffc17 	ldw	r2,-16(fp)
 2028c40:	10000b26 	beq	r2,zero,2028c70 <tcp_output_control_segment+0xfc>
      NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
 2028c44:	e0bffc17 	ldw	r2,-16(fp)
 2028c48:	10c00304 	addi	r3,r2,12
 2028c4c:	e0bffa17 	ldw	r2,-24(fp)
 2028c50:	10c01215 	stw	r3,72(r2)
      ttl = pcb->ttl;
 2028c54:	e0bffc17 	ldw	r2,-16(fp)
 2028c58:	108002c3 	ldbu	r2,11(r2)
 2028c5c:	e0bff945 	stb	r2,-27(fp)
      tos = pcb->tos;
 2028c60:	e0bffc17 	ldw	r2,-16(fp)
 2028c64:	10800283 	ldbu	r2,10(r2)
 2028c68:	e0bff985 	stb	r2,-26(fp)
 2028c6c:	00000306 	br	2028c7c <tcp_output_control_segment+0x108>
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
 2028c70:	00801004 	movi	r2,64
 2028c74:	e0bff945 	stb	r2,-27(fp)
      tos = 0;
 2028c78:	e03ff985 	stb	zero,-26(fp)
    }
    TCP_STATS_INC(tcp.xmit);
 2028c7c:	008085f4 	movhi	r2,535
 2028c80:	10bd8204 	addi	r2,r2,-2552
 2028c84:	10804817 	ldw	r2,288(r2)
 2028c88:	10c00044 	addi	r3,r2,1
 2028c8c:	008085f4 	movhi	r2,535
 2028c90:	10bd8204 	addi	r2,r2,-2552
 2028c94:	10c04815 	stw	r3,288(r2)
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
 2028c98:	e13ff943 	ldbu	r4,-27(fp)
 2028c9c:	e0bff983 	ldbu	r2,-26(fp)
 2028ca0:	e0fffa17 	ldw	r3,-24(fp)
 2028ca4:	d8c00215 	stw	r3,8(sp)
 2028ca8:	00c00184 	movi	r3,6
 2028cac:	d8c00115 	stw	r3,4(sp)
 2028cb0:	d8800015 	stw	r2,0(sp)
 2028cb4:	200f883a 	mov	r7,r4
 2028cb8:	e1bfff17 	ldw	r6,-4(fp)
 2028cbc:	e17ffe17 	ldw	r5,-8(fp)
 2028cc0:	e13ffd17 	ldw	r4,-12(fp)
 2028cc4:	203be1c0 	call	203be1c <ip4_output_if>
 2028cc8:	e0bff905 	stb	r2,-28(fp)
    NETIF_RESET_HINTS(netif);
 2028ccc:	e0bffa17 	ldw	r2,-24(fp)
 2028cd0:	10001215 	stw	zero,72(r2)
  }
  pbuf_free(p);
 2028cd4:	e13ffd17 	ldw	r4,-12(fp)
 2028cd8:	201d2f40 	call	201d2f4 <pbuf_free>
  return err;
 2028cdc:	e0bff903 	ldbu	r2,-28(fp)
}
 2028ce0:	e037883a 	mov	sp,fp
 2028ce4:	dfc00117 	ldw	ra,4(sp)
 2028ce8:	df000017 	ldw	fp,0(sp)
 2028cec:	dec00204 	addi	sp,sp,8
 2028cf0:	f800283a 	ret

02028cf4 <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
 2028cf4:	defff104 	addi	sp,sp,-60
 2028cf8:	dfc00e15 	stw	ra,56(sp)
 2028cfc:	df000d15 	stw	fp,52(sp)
 2028d00:	dc000c15 	stw	r16,48(sp)
 2028d04:	df000d04 	addi	fp,sp,52
 2028d08:	e13ff915 	stw	r4,-28(fp)
 2028d0c:	e17ffa15 	stw	r5,-24(fp)
 2028d10:	e1bffb15 	stw	r6,-20(fp)
 2028d14:	e1fffc15 	stw	r7,-16(fp)
 2028d18:	e0c00317 	ldw	r3,12(fp)
 2028d1c:	e0800417 	ldw	r2,16(fp)
 2028d20:	e0fffd0d 	sth	r3,-12(fp)
 2028d24:	e0bffe0d 	sth	r2,-8(fp)
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 2028d28:	e03ff705 	stb	zero,-36(fp)

#if LWIP_WND_SCALE
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
 2028d2c:	00800804 	movi	r2,32
 2028d30:	e0bff78d 	sth	r2,-34(fp)
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
 2028d34:	e43ff703 	ldbu	r16,-36(fp)
 2028d38:	e13ffa17 	ldw	r4,-24(fp)
 2028d3c:	20394b00 	call	20394b0 <lwip_htonl>
 2028d40:	100b883a 	mov	r5,r2
 2028d44:	e0bffd0b 	ldhu	r2,-12(fp)
 2028d48:	e0fffe0b 	ldhu	r3,-8(fp)
 2028d4c:	e13ff78b 	ldhu	r4,-34(fp)
 2028d50:	d9000315 	stw	r4,12(sp)
 2028d54:	01000504 	movi	r4,20
 2028d58:	d9000215 	stw	r4,8(sp)
 2028d5c:	d8c00115 	stw	r3,4(sp)
 2028d60:	d8800015 	stw	r2,0(sp)
 2028d64:	280f883a 	mov	r7,r5
 2028d68:	000d883a 	mov	r6,zero
 2028d6c:	800b883a 	mov	r5,r16
 2028d70:	e13ffb17 	ldw	r4,-20(fp)
 2028d74:	20287000 	call	2028700 <tcp_output_alloc_header_common>
 2028d78:	e0bff815 	stw	r2,-32(fp)
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
 2028d7c:	e0bff817 	ldw	r2,-32(fp)
 2028d80:	10000c26 	beq	r2,zero,2028db4 <tcp_rst+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 2028d84:	e0bff703 	ldbu	r2,-36(fp)
 2028d88:	100f883a 	mov	r7,r2
 2028d8c:	000d883a 	mov	r6,zero
 2028d90:	e17ff817 	ldw	r5,-32(fp)
 2028d94:	e13ff917 	ldw	r4,-28(fp)
 2028d98:	2028b200 	call	2028b20 <tcp_output_fill_options>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
 2028d9c:	e1c00217 	ldw	r7,8(fp)
 2028da0:	e1bffc17 	ldw	r6,-16(fp)
 2028da4:	e17ff817 	ldw	r5,-32(fp)
 2028da8:	e13ff917 	ldw	r4,-28(fp)
 2028dac:	2028b740 	call	2028b74 <tcp_output_control_segment>
 2028db0:	00000106 	br	2028db8 <tcp_rst+0xc4>

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
 2028db4:	0001883a 	nop

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 2028db8:	e6ffff04 	addi	sp,fp,-4
 2028dbc:	dfc00217 	ldw	ra,8(sp)
 2028dc0:	df000117 	ldw	fp,4(sp)
 2028dc4:	dc000017 	ldw	r16,0(sp)
 2028dc8:	dec00304 	addi	sp,sp,12
 2028dcc:	f800283a 	ret

02028dd0 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 2028dd0:	defff904 	addi	sp,sp,-28
 2028dd4:	dfc00615 	stw	ra,24(sp)
 2028dd8:	df000515 	stw	fp,20(sp)
 2028ddc:	dc000415 	stw	r16,16(sp)
 2028de0:	df000504 	addi	fp,sp,20
 2028de4:	e13ffe15 	stw	r4,-8(fp)
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
 2028de8:	e03ffb05 	stb	zero,-20(fp)
  u8_t num_sacks = 0;
 2028dec:	e03ffb45 	stb	zero,-19(fp)
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optflags = TF_SEG_OPTS_TS;
  }
#endif
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 2028df0:	e0bffb03 	ldbu	r2,-20(fp)
 2028df4:	1080004c 	andi	r2,r2,1
 2028df8:	10000226 	beq	r2,zero,2028e04 <tcp_send_empty_ack+0x34>
 2028dfc:	00800104 	movi	r2,4
 2028e00:	00000106 	br	2028e08 <tcp_send_empty_ack+0x38>
 2028e04:	0005883a 	mov	r2,zero
 2028e08:	e0bffb85 	stb	r2,-18(fp)
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 2028e0c:	e43ffb83 	ldbu	r16,-18(fp)
 2028e10:	e0bffe17 	ldw	r2,-8(fp)
 2028e14:	10801617 	ldw	r2,88(r2)
 2028e18:	1009883a 	mov	r4,r2
 2028e1c:	20394b00 	call	20394b0 <lwip_htonl>
 2028e20:	100f883a 	mov	r7,r2
 2028e24:	000d883a 	mov	r6,zero
 2028e28:	800b883a 	mov	r5,r16
 2028e2c:	e13ffe17 	ldw	r4,-8(fp)
 2028e30:	2028a600 	call	2028a60 <tcp_output_alloc_header>
 2028e34:	e0bffc15 	stw	r2,-16(fp)
  if (p == NULL) {
 2028e38:	e0bffc17 	ldw	r2,-16(fp)
 2028e3c:	1000081e 	bne	r2,zero,2028e60 <tcp_send_empty_ack+0x90>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 2028e40:	e0bffe17 	ldw	r2,-8(fp)
 2028e44:	1080088b 	ldhu	r2,34(r2)
 2028e48:	108000d4 	ori	r2,r2,3
 2028e4c:	1007883a 	mov	r3,r2
 2028e50:	e0bffe17 	ldw	r2,-8(fp)
 2028e54:	10c0088d 	sth	r3,34(r2)
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 2028e58:	00bfff84 	movi	r2,-2
 2028e5c:	00002106 	br	2028ee4 <tcp_send_empty_ack+0x114>
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
 2028e60:	e0bffb03 	ldbu	r2,-20(fp)
 2028e64:	e0fffb43 	ldbu	r3,-19(fp)
 2028e68:	180f883a 	mov	r7,r3
 2028e6c:	100d883a 	mov	r6,r2
 2028e70:	e17ffc17 	ldw	r5,-16(fp)
 2028e74:	e13ffe17 	ldw	r4,-8(fp)
 2028e78:	2028b200 	call	2028b20 <tcp_output_fill_options>
  pcb->ts_lastacksent = pcb->rcv_nxt;
#endif

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 2028e7c:	e0fffe17 	ldw	r3,-8(fp)
 2028e80:	e0bffe17 	ldw	r2,-8(fp)
 2028e84:	10800104 	addi	r2,r2,4
 2028e88:	100f883a 	mov	r7,r2
 2028e8c:	180d883a 	mov	r6,r3
 2028e90:	e17ffc17 	ldw	r5,-16(fp)
 2028e94:	e13ffe17 	ldw	r4,-8(fp)
 2028e98:	2028b740 	call	2028b74 <tcp_output_control_segment>
 2028e9c:	e0bffd05 	stb	r2,-12(fp)
  if (err != ERR_OK) {
 2028ea0:	e0bffd07 	ldb	r2,-12(fp)
 2028ea4:	10000726 	beq	r2,zero,2028ec4 <tcp_send_empty_ack+0xf4>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 2028ea8:	e0bffe17 	ldw	r2,-8(fp)
 2028eac:	1080088b 	ldhu	r2,34(r2)
 2028eb0:	108000d4 	ori	r2,r2,3
 2028eb4:	1007883a 	mov	r3,r2
 2028eb8:	e0bffe17 	ldw	r2,-8(fp)
 2028ebc:	10c0088d 	sth	r3,34(r2)
 2028ec0:	00000706 	br	2028ee0 <tcp_send_empty_ack+0x110>
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 2028ec4:	e0bffe17 	ldw	r2,-8(fp)
 2028ec8:	10c0088b 	ldhu	r3,34(r2)
 2028ecc:	00bfff04 	movi	r2,-4
 2028ed0:	1884703a 	and	r2,r3,r2
 2028ed4:	1007883a 	mov	r3,r2
 2028ed8:	e0bffe17 	ldw	r2,-8(fp)
 2028edc:	10c0088d 	sth	r3,34(r2)
  }

  return err;
 2028ee0:	e0bffd03 	ldbu	r2,-12(fp)
}
 2028ee4:	e6ffff04 	addi	sp,fp,-4
 2028ee8:	dfc00217 	ldw	ra,8(sp)
 2028eec:	df000117 	ldw	fp,4(sp)
 2028ef0:	dc000017 	ldw	r16,0(sp)
 2028ef4:	dec00304 	addi	sp,sp,12
 2028ef8:	f800283a 	ret

02028efc <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 2028efc:	defff904 	addi	sp,sp,-28
 2028f00:	dfc00615 	stw	ra,24(sp)
 2028f04:	df000515 	stw	fp,20(sp)
 2028f08:	dc000415 	stw	r16,16(sp)
 2028f0c:	df000504 	addi	fp,sp,20
 2028f10:	e13ffe15 	stw	r4,-8(fp)
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 2028f14:	e03ffb05 	stb	zero,-20(fp)
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
 2028f18:	e43ffb03 	ldbu	r16,-20(fp)
 2028f1c:	e0bffe17 	ldw	r2,-8(fp)
 2028f20:	10801617 	ldw	r2,88(r2)
 2028f24:	10bfffc4 	addi	r2,r2,-1
 2028f28:	1009883a 	mov	r4,r2
 2028f2c:	20394b00 	call	20394b0 <lwip_htonl>
 2028f30:	100f883a 	mov	r7,r2
 2028f34:	000d883a 	mov	r6,zero
 2028f38:	800b883a 	mov	r5,r16
 2028f3c:	e13ffe17 	ldw	r4,-8(fp)
 2028f40:	2028a600 	call	2028a60 <tcp_output_alloc_header>
 2028f44:	e0bffc15 	stw	r2,-16(fp)
  if (p == NULL) {
 2028f48:	e0bffc17 	ldw	r2,-16(fp)
 2028f4c:	1000021e 	bne	r2,zero,2028f58 <tcp_keepalive+0x5c>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
 2028f50:	00bfffc4 	movi	r2,-1
 2028f54:	00001006 	br	2028f98 <tcp_keepalive+0x9c>
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 2028f58:	e0bffb03 	ldbu	r2,-20(fp)
 2028f5c:	100f883a 	mov	r7,r2
 2028f60:	000d883a 	mov	r6,zero
 2028f64:	e17ffc17 	ldw	r5,-16(fp)
 2028f68:	e13ffe17 	ldw	r4,-8(fp)
 2028f6c:	2028b200 	call	2028b20 <tcp_output_fill_options>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 2028f70:	e0fffe17 	ldw	r3,-8(fp)
 2028f74:	e0bffe17 	ldw	r2,-8(fp)
 2028f78:	10800104 	addi	r2,r2,4
 2028f7c:	100f883a 	mov	r7,r2
 2028f80:	180d883a 	mov	r6,r3
 2028f84:	e17ffc17 	ldw	r5,-16(fp)
 2028f88:	e13ffe17 	ldw	r4,-8(fp)
 2028f8c:	2028b740 	call	2028b74 <tcp_output_control_segment>
 2028f90:	e0bffd05 	stb	r2,-12(fp)

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 2028f94:	e0bffd03 	ldbu	r2,-12(fp)
}
 2028f98:	e6ffff04 	addi	sp,fp,-4
 2028f9c:	dfc00217 	ldw	ra,8(sp)
 2028fa0:	df000117 	ldw	fp,4(sp)
 2028fa4:	dc000017 	ldw	r16,0(sp)
 2028fa8:	dec00304 	addi	sp,sp,12
 2028fac:	f800283a 	ret

02028fb0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 2028fb0:	defff404 	addi	sp,sp,-48
 2028fb4:	dfc00b15 	stw	ra,44(sp)
 2028fb8:	df000a15 	stw	fp,40(sp)
 2028fbc:	dc000915 	stw	r16,36(sp)
 2028fc0:	df000a04 	addi	fp,sp,40
 2028fc4:	e13ffe15 	stw	r4,-8(fp)
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 2028fc8:	e03ff605 	stb	zero,-40(fp)
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
 2028fcc:	e0bffe17 	ldw	r2,-8(fp)
 2028fd0:	10801d17 	ldw	r2,116(r2)
 2028fd4:	e0bff715 	stw	r2,-36(fp)
  if (seg == NULL) {
 2028fd8:	e0bff717 	ldw	r2,-36(fp)
 2028fdc:	1000021e 	bne	r2,zero,2028fe8 <tcp_zero_window_probe+0x38>
    /* Not expected, persist timer should be off when the send buffer is empty */
    return ERR_OK;
 2028fe0:	0005883a 	mov	r2,zero
 2028fe4:	00009706 	br	2029244 <tcp_zero_window_probe+0x294>

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
 2028fe8:	e0bffe17 	ldw	r2,-8(fp)
 2028fec:	10802a83 	ldbu	r2,170(r2)
 2028ff0:	10803fcc 	andi	r2,r2,255
 2028ff4:	10803fe0 	cmpeqi	r2,r2,255
 2028ff8:	1000061e 	bne	r2,zero,2029014 <tcp_zero_window_probe+0x64>
    ++pcb->persist_probe;
 2028ffc:	e0bffe17 	ldw	r2,-8(fp)
 2029000:	10802a83 	ldbu	r2,170(r2)
 2029004:	10800044 	addi	r2,r2,1
 2029008:	1007883a 	mov	r3,r2
 202900c:	e0bffe17 	ldw	r2,-8(fp)
 2029010:	10c02a85 	stb	r3,170(r2)
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 2029014:	e0bff717 	ldw	r2,-36(fp)
 2029018:	10800417 	ldw	r2,16(r2)
 202901c:	10c00303 	ldbu	r3,12(r2)
 2029020:	10800343 	ldbu	r2,13(r2)
 2029024:	1004923a 	slli	r2,r2,8
 2029028:	10c4b03a 	or	r2,r2,r3
 202902c:	10bfffcc 	andi	r2,r2,65535
 2029030:	1009883a 	mov	r4,r2
 2029034:	20394740 	call	2039474 <lwip_htons>
 2029038:	10803fcc 	andi	r2,r2,255
 202903c:	1080004c 	andi	r2,r2,1
 2029040:	10000626 	beq	r2,zero,202905c <tcp_zero_window_probe+0xac>
 2029044:	e0bff717 	ldw	r2,-36(fp)
 2029048:	1080020b 	ldhu	r2,8(r2)
 202904c:	10bfffcc 	andi	r2,r2,65535
 2029050:	1000021e 	bne	r2,zero,202905c <tcp_zero_window_probe+0xac>
 2029054:	00800044 	movi	r2,1
 2029058:	00000106 	br	2029060 <tcp_zero_window_probe+0xb0>
 202905c:	0005883a 	mov	r2,zero
 2029060:	e0bff805 	stb	r2,-32(fp)
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 2029064:	e0bff803 	ldbu	r2,-32(fp)
 2029068:	1005003a 	cmpeq	r2,r2,zero
 202906c:	10803fcc 	andi	r2,r2,255
 2029070:	e0bff88d 	sth	r2,-30(fp)

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
 2029074:	e17ff603 	ldbu	r5,-40(fp)
 2029078:	e1bff88b 	ldhu	r6,-30(fp)
 202907c:	e0bff717 	ldw	r2,-36(fp)
 2029080:	10800417 	ldw	r2,16(r2)
 2029084:	10c00103 	ldbu	r3,4(r2)
 2029088:	11000143 	ldbu	r4,5(r2)
 202908c:	2008923a 	slli	r4,r4,8
 2029090:	20c6b03a 	or	r3,r4,r3
 2029094:	11000183 	ldbu	r4,6(r2)
 2029098:	2008943a 	slli	r4,r4,16
 202909c:	20c6b03a 	or	r3,r4,r3
 20290a0:	108001c3 	ldbu	r2,7(r2)
 20290a4:	1004963a 	slli	r2,r2,24
 20290a8:	10c4b03a 	or	r2,r2,r3
 20290ac:	100f883a 	mov	r7,r2
 20290b0:	e13ffe17 	ldw	r4,-8(fp)
 20290b4:	2028a600 	call	2028a60 <tcp_output_alloc_header>
 20290b8:	e0bff915 	stw	r2,-28(fp)
  if (p == NULL) {
 20290bc:	e0bff917 	ldw	r2,-28(fp)
 20290c0:	1000021e 	bne	r2,zero,20290cc <tcp_zero_window_probe+0x11c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
 20290c4:	00bfffc4 	movi	r2,-1
 20290c8:	00005e06 	br	2029244 <tcp_zero_window_probe+0x294>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 20290cc:	e0bff917 	ldw	r2,-28(fp)
 20290d0:	10800117 	ldw	r2,4(r2)
 20290d4:	e0bffa15 	stw	r2,-24(fp)

  if (is_fin) {
 20290d8:	e0bff803 	ldbu	r2,-32(fp)
 20290dc:	10002026 	beq	r2,zero,2029160 <tcp_zero_window_probe+0x1b0>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 20290e0:	e0bffa17 	ldw	r2,-24(fp)
 20290e4:	10c00303 	ldbu	r3,12(r2)
 20290e8:	10800343 	ldbu	r2,13(r2)
 20290ec:	1004923a 	slli	r2,r2,8
 20290f0:	10c4b03a 	or	r2,r2,r3
 20290f4:	1007883a 	mov	r3,r2
 20290f8:	00b03fc4 	movi	r2,-16129
 20290fc:	1884703a 	and	r2,r3,r2
 2029100:	1021883a 	mov	r16,r2
 2029104:	01000444 	movi	r4,17
 2029108:	20394740 	call	2039474 <lwip_htons>
 202910c:	8084b03a 	or	r2,r16,r2
 2029110:	100d883a 	mov	r6,r2
 2029114:	e0bffa17 	ldw	r2,-24(fp)
 2029118:	30ffffcc 	andi	r3,r6,65535
 202911c:	19403fcc 	andi	r5,r3,255
 2029120:	10c00303 	ldbu	r3,12(r2)
 2029124:	1806703a 	and	r3,r3,zero
 2029128:	1809883a 	mov	r4,r3
 202912c:	2807883a 	mov	r3,r5
 2029130:	20c6b03a 	or	r3,r4,r3
 2029134:	10c00305 	stb	r3,12(r2)
 2029138:	30ffffcc 	andi	r3,r6,65535
 202913c:	1806d23a 	srli	r3,r3,8
 2029140:	197fffcc 	andi	r5,r3,65535
 2029144:	10c00343 	ldbu	r3,13(r2)
 2029148:	1806703a 	and	r3,r3,zero
 202914c:	1809883a 	mov	r4,r3
 2029150:	2807883a 	mov	r3,r5
 2029154:	20c6b03a 	or	r3,r4,r3
 2029158:	10c00345 	stb	r3,13(r2)
 202915c:	00001106 	br	20291a4 <tcp_zero_window_probe+0x1f4>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
 2029160:	e0bff917 	ldw	r2,-28(fp)
 2029164:	10800117 	ldw	r2,4(r2)
 2029168:	10800504 	addi	r2,r2,20
 202916c:	e0bffb15 	stw	r2,-20(fp)
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 2029170:	e0bff717 	ldw	r2,-36(fp)
 2029174:	11000117 	ldw	r4,4(r2)
 2029178:	e0bff717 	ldw	r2,-36(fp)
 202917c:	10800117 	ldw	r2,4(r2)
 2029180:	10c0020b 	ldhu	r3,8(r2)
 2029184:	e0bff717 	ldw	r2,-36(fp)
 2029188:	1080020b 	ldhu	r2,8(r2)
 202918c:	1885c83a 	sub	r2,r3,r2
 2029190:	10bfffcc 	andi	r2,r2,65535
 2029194:	100f883a 	mov	r7,r2
 2029198:	01800044 	movi	r6,1
 202919c:	e17ffb17 	ldw	r5,-20(fp)
 20291a0:	201d8500 	call	201d850 <pbuf_copy_partial>
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 20291a4:	e0bff717 	ldw	r2,-36(fp)
 20291a8:	10800417 	ldw	r2,16(r2)
 20291ac:	10c00103 	ldbu	r3,4(r2)
 20291b0:	11000143 	ldbu	r4,5(r2)
 20291b4:	2008923a 	slli	r4,r4,8
 20291b8:	20c6b03a 	or	r3,r4,r3
 20291bc:	11000183 	ldbu	r4,6(r2)
 20291c0:	2008943a 	slli	r4,r4,16
 20291c4:	20c6b03a 	or	r3,r4,r3
 20291c8:	108001c3 	ldbu	r2,7(r2)
 20291cc:	1004963a 	slli	r2,r2,24
 20291d0:	10c4b03a 	or	r2,r2,r3
 20291d4:	1009883a 	mov	r4,r2
 20291d8:	20394b00 	call	20394b0 <lwip_htonl>
 20291dc:	10800044 	addi	r2,r2,1
 20291e0:	e0bffc15 	stw	r2,-16(fp)
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 20291e4:	e0bffe17 	ldw	r2,-8(fp)
 20291e8:	10c01617 	ldw	r3,88(r2)
 20291ec:	e0bffc17 	ldw	r2,-16(fp)
 20291f0:	1885c83a 	sub	r2,r3,r2
 20291f4:	1000030e 	bge	r2,zero,2029204 <tcp_zero_window_probe+0x254>
    pcb->snd_nxt = snd_nxt;
 20291f8:	e0bffe17 	ldw	r2,-8(fp)
 20291fc:	e0fffc17 	ldw	r3,-16(fp)
 2029200:	10c01615 	stw	r3,88(r2)
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 2029204:	e0bff603 	ldbu	r2,-40(fp)
 2029208:	100f883a 	mov	r7,r2
 202920c:	000d883a 	mov	r6,zero
 2029210:	e17ff917 	ldw	r5,-28(fp)
 2029214:	e13ffe17 	ldw	r4,-8(fp)
 2029218:	2028b200 	call	2028b20 <tcp_output_fill_options>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 202921c:	e0fffe17 	ldw	r3,-8(fp)
 2029220:	e0bffe17 	ldw	r2,-8(fp)
 2029224:	10800104 	addi	r2,r2,4
 2029228:	100f883a 	mov	r7,r2
 202922c:	180d883a 	mov	r6,r3
 2029230:	e17ff917 	ldw	r5,-28(fp)
 2029234:	e13ffe17 	ldw	r4,-8(fp)
 2029238:	2028b740 	call	2028b74 <tcp_output_control_segment>
 202923c:	e0bffd05 	stb	r2,-12(fp)

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 2029240:	e0bffd03 	ldbu	r2,-12(fp)
}
 2029244:	e6ffff04 	addi	sp,fp,-4
 2029248:	dfc00217 	ldw	ra,8(sp)
 202924c:	df000117 	ldw	fp,4(sp)
 2029250:	dc000017 	ldw	r16,0(sp)
 2029254:	dec00304 	addi	sp,sp,12
 2029258:	f800283a 	ret

0202925c <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 202925c:	defffd04 	addi	sp,sp,-12
 2029260:	dfc00215 	stw	ra,8(sp)
 2029264:	df000115 	stw	fp,4(sp)
 2029268:	df000104 	addi	fp,sp,4
 202926c:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 2029270:	201ee100 	call	201ee10 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 2029274:	d0a7e117 	ldw	r2,-24700(gp)
 2029278:	1000021e 	bne	r2,zero,2029284 <tcpip_tcp_timer+0x28>
 202927c:	d0a7e517 	ldw	r2,-24684(gp)
 2029280:	10000626 	beq	r2,zero,202929c <tcpip_tcp_timer+0x40>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 2029284:	000d883a 	mov	r6,zero
 2029288:	014080f4 	movhi	r5,515
 202928c:	29649704 	addi	r5,r5,-28068
 2029290:	01003e84 	movi	r4,250
 2029294:	20295680 	call	2029568 <sys_timeout>
 2029298:	00000106 	br	20292a0 <tcpip_tcp_timer+0x44>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 202929c:	d027f215 	stw	zero,-24632(gp)
  }
}
 20292a0:	0001883a 	nop
 20292a4:	e037883a 	mov	sp,fp
 20292a8:	dfc00117 	ldw	ra,4(sp)
 20292ac:	df000017 	ldw	fp,0(sp)
 20292b0:	dec00204 	addi	sp,sp,8
 20292b4:	f800283a 	ret

020292b8 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 20292b8:	defffe04 	addi	sp,sp,-8
 20292bc:	dfc00115 	stw	ra,4(sp)
 20292c0:	df000015 	stw	fp,0(sp)
 20292c4:	d839883a 	mov	fp,sp
  LWIP_ASSERT_CORE_LOCKED();

  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 20292c8:	d0a7f217 	ldw	r2,-24632(gp)
 20292cc:	10000b1e 	bne	r2,zero,20292fc <tcp_timer_needed+0x44>
 20292d0:	d0a7e117 	ldw	r2,-24700(gp)
 20292d4:	1000021e 	bne	r2,zero,20292e0 <tcp_timer_needed+0x28>
 20292d8:	d0a7e517 	ldw	r2,-24684(gp)
 20292dc:	10000726 	beq	r2,zero,20292fc <tcp_timer_needed+0x44>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 20292e0:	00800044 	movi	r2,1
 20292e4:	d0a7f215 	stw	r2,-24632(gp)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 20292e8:	000d883a 	mov	r6,zero
 20292ec:	014080f4 	movhi	r5,515
 20292f0:	29649704 	addi	r5,r5,-28068
 20292f4:	01003e84 	movi	r4,250
 20292f8:	20295680 	call	2029568 <sys_timeout>
  }
}
 20292fc:	0001883a 	nop
 2029300:	e037883a 	mov	sp,fp
 2029304:	dfc00117 	ldw	ra,4(sp)
 2029308:	df000017 	ldw	fp,0(sp)
 202930c:	dec00204 	addi	sp,sp,8
 2029310:	f800283a 	ret

02029314 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
 2029314:	defff904 	addi	sp,sp,-28
 2029318:	dfc00615 	stw	ra,24(sp)
 202931c:	df000515 	stw	fp,20(sp)
 2029320:	df000504 	addi	fp,sp,20
 2029324:	e13ffd15 	stw	r4,-12(fp)
 2029328:	e17ffe15 	stw	r5,-8(fp)
 202932c:	e1bfff15 	stw	r6,-4(fp)
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 2029330:	01000304 	movi	r4,12
 2029334:	201b82c0 	call	201b82c <memp_malloc>
 2029338:	e0bffc15 	stw	r2,-16(fp)
  if (timeout == NULL) {
 202933c:	e0bffc17 	ldw	r2,-16(fp)
 2029340:	10003726 	beq	r2,zero,2029420 <sys_timeout_abs+0x10c>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }

  timeout->next = NULL;
 2029344:	e0bffc17 	ldw	r2,-16(fp)
 2029348:	10000015 	stw	zero,0(r2)
  timeout->h = handler;
 202934c:	e0bffc17 	ldw	r2,-16(fp)
 2029350:	e0fffe17 	ldw	r3,-8(fp)
 2029354:	10c00215 	stw	r3,8(r2)
  timeout->arg = arg;
 2029358:	e0bffc17 	ldw	r2,-16(fp)
 202935c:	e0ffff17 	ldw	r3,-4(fp)
 2029360:	10c00315 	stw	r3,12(r2)
  timeout->time = abs_time;
 2029364:	e0bffc17 	ldw	r2,-16(fp)
 2029368:	e0fffd17 	ldw	r3,-12(fp)
 202936c:	10c00115 	stw	r3,4(r2)
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
                             (void *)timeout, abs_time, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 2029370:	d0a7f017 	ldw	r2,-24640(gp)
 2029374:	1000031e 	bne	r2,zero,2029384 <sys_timeout_abs+0x70>
    next_timeout = timeout;
 2029378:	e0bffc17 	ldw	r2,-16(fp)
 202937c:	d0a7f015 	stw	r2,-24640(gp)
    return;
 2029380:	00002806 	br	2029424 <sys_timeout_abs+0x110>
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
 2029384:	e0bffc17 	ldw	r2,-16(fp)
 2029388:	10c00117 	ldw	r3,4(r2)
 202938c:	d0a7f017 	ldw	r2,-24640(gp)
 2029390:	10800117 	ldw	r2,4(r2)
 2029394:	1885c83a 	sub	r2,r3,r2
 2029398:	1000060e 	bge	r2,zero,20293b4 <sys_timeout_abs+0xa0>
    timeout->next = next_timeout;
 202939c:	d0e7f017 	ldw	r3,-24640(gp)
 20293a0:	e0bffc17 	ldw	r2,-16(fp)
 20293a4:	10c00015 	stw	r3,0(r2)
    next_timeout = timeout;
 20293a8:	e0bffc17 	ldw	r2,-16(fp)
 20293ac:	d0a7f015 	stw	r2,-24640(gp)
 20293b0:	00001c06 	br	2029424 <sys_timeout_abs+0x110>
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
 20293b4:	d0a7f017 	ldw	r2,-24640(gp)
 20293b8:	e0bffb15 	stw	r2,-20(fp)
 20293bc:	00001506 	br	2029414 <sys_timeout_abs+0x100>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
 20293c0:	e0bffb17 	ldw	r2,-20(fp)
 20293c4:	10800017 	ldw	r2,0(r2)
 20293c8:	10000726 	beq	r2,zero,20293e8 <sys_timeout_abs+0xd4>
 20293cc:	e0bffc17 	ldw	r2,-16(fp)
 20293d0:	10c00117 	ldw	r3,4(r2)
 20293d4:	e0bffb17 	ldw	r2,-20(fp)
 20293d8:	10800017 	ldw	r2,0(r2)
 20293dc:	10800117 	ldw	r2,4(r2)
 20293e0:	1885c83a 	sub	r2,r3,r2
 20293e4:	1000080e 	bge	r2,zero,2029408 <sys_timeout_abs+0xf4>
        timeout->next = t->next;
 20293e8:	e0bffb17 	ldw	r2,-20(fp)
 20293ec:	10c00017 	ldw	r3,0(r2)
 20293f0:	e0bffc17 	ldw	r2,-16(fp)
 20293f4:	10c00015 	stw	r3,0(r2)
        t->next = timeout;
 20293f8:	e0bffb17 	ldw	r2,-20(fp)
 20293fc:	e0fffc17 	ldw	r3,-16(fp)
 2029400:	10c00015 	stw	r3,0(r2)
        break;
 2029404:	00000706 	br	2029424 <sys_timeout_abs+0x110>
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
 2029408:	e0bffb17 	ldw	r2,-20(fp)
 202940c:	10800017 	ldw	r2,0(r2)
 2029410:	e0bffb15 	stw	r2,-20(fp)
 2029414:	e0bffb17 	ldw	r2,-20(fp)
 2029418:	103fe91e 	bne	r2,zero,20293c0 <__alt_mem_mem_0+0xfd0093c0>
 202941c:	00000106 	br	2029424 <sys_timeout_abs+0x110>
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
 2029420:	0001883a 	nop
        t->next = timeout;
        break;
      }
    }
  }
}
 2029424:	e037883a 	mov	sp,fp
 2029428:	dfc00117 	ldw	ra,4(sp)
 202942c:	df000017 	ldw	fp,0(sp)
 2029430:	dec00204 	addi	sp,sp,8
 2029434:	f800283a 	ret

02029438 <lwip_cyclic_timer>:
#if !LWIP_TESTMODE
static
#endif
void
lwip_cyclic_timer(void *arg)
{
 2029438:	defffa04 	addi	sp,sp,-24
 202943c:	dfc00515 	stw	ra,20(sp)
 2029440:	df000415 	stw	fp,16(sp)
 2029444:	df000404 	addi	fp,sp,16
 2029448:	e13fff15 	stw	r4,-4(fp)
  u32_t now;
  u32_t next_timeout_time;
  const struct lwip_cyclic_timer *cyclic = (const struct lwip_cyclic_timer *)arg;
 202944c:	e0bfff17 	ldw	r2,-4(fp)
 2029450:	e0bffc15 	stw	r2,-16(fp)

#if LWIP_DEBUG_TIMERNAMES
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
#endif
  cyclic->handler();
 2029454:	e0bffc17 	ldw	r2,-16(fp)
 2029458:	10800117 	ldw	r2,4(r2)
 202945c:	103ee83a 	callr	r2

  now = sys_now();
 2029460:	2014c9c0 	call	2014c9c <sys_now>
 2029464:	e0bffd15 	stw	r2,-12(fp)
  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */
 2029468:	e0bffc17 	ldw	r2,-16(fp)
 202946c:	10c00017 	ldw	r3,0(r2)
 2029470:	d0a7f117 	ldw	r2,-24636(gp)
 2029474:	1885883a 	add	r2,r3,r2
 2029478:	e0bffe15 	stw	r2,-8(fp)
  if (TIME_LESS_THAN(next_timeout_time, now)) {
 202947c:	e0fffe17 	ldw	r3,-8(fp)
 2029480:	e0bffd17 	ldw	r2,-12(fp)
 2029484:	1885c83a 	sub	r2,r3,r2
 2029488:	10000a0e 	bge	r2,zero,20294b4 <lwip_cyclic_timer+0x7c>
    /* timer would immediately expire again -> "overload" -> restart without any correction */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
 202948c:	e0bffc17 	ldw	r2,-16(fp)
 2029490:	10c00017 	ldw	r3,0(r2)
 2029494:	e0bffd17 	ldw	r2,-12(fp)
 2029498:	1885883a 	add	r2,r3,r2
 202949c:	e1bfff17 	ldw	r6,-4(fp)
 20294a0:	014080f4 	movhi	r5,515
 20294a4:	29650e04 	addi	r5,r5,-27592
 20294a8:	1009883a 	mov	r4,r2
 20294ac:	20293140 	call	2029314 <sys_timeout_abs>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
#endif
  }
}
 20294b0:	00000506 	br	20294c8 <lwip_cyclic_timer+0x90>
  } else {
    /* correct cyclic interval with handler execution delay and sys_check_timeouts jitter */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
 20294b4:	e1bfff17 	ldw	r6,-4(fp)
 20294b8:	014080f4 	movhi	r5,515
 20294bc:	29650e04 	addi	r5,r5,-27592
 20294c0:	e13ffe17 	ldw	r4,-8(fp)
 20294c4:	20293140 	call	2029314 <sys_timeout_abs>
#endif
  }
}
 20294c8:	0001883a 	nop
 20294cc:	e037883a 	mov	sp,fp
 20294d0:	dfc00117 	ldw	ra,4(sp)
 20294d4:	df000017 	ldw	fp,0(sp)
 20294d8:	dec00204 	addi	sp,sp,8
 20294dc:	f800283a 	ret

020294e0 <sys_timeouts_init>:

/** Initialize this module */
void sys_timeouts_init(void)
{
 20294e0:	defffd04 	addi	sp,sp,-12
 20294e4:	dfc00215 	stw	ra,8(sp)
 20294e8:	df000115 	stw	fp,4(sp)
 20294ec:	df000104 	addi	fp,sp,4
  size_t i;
  /* tcp_tmr() at index 0 is started on demand */
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 20294f0:	00800044 	movi	r2,1
 20294f4:	e0bfff15 	stw	r2,-4(fp)
 20294f8:	00001206 	br	2029544 <sys_timeouts_init+0x64>
    /* we have to cast via size_t to get rid of const warning
      (this is OK as cyclic_timer() casts back to const* */
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
 20294fc:	00808134 	movhi	r2,516
 2029500:	109bfb04 	addi	r2,r2,28652
 2029504:	e0ffff17 	ldw	r3,-4(fp)
 2029508:	180690fa 	slli	r3,r3,3
 202950c:	10c5883a 	add	r2,r2,r3
 2029510:	11000017 	ldw	r4,0(r2)
 2029514:	e0bfff17 	ldw	r2,-4(fp)
 2029518:	100690fa 	slli	r3,r2,3
 202951c:	00808134 	movhi	r2,516
 2029520:	109bfb04 	addi	r2,r2,28652
 2029524:	1885883a 	add	r2,r3,r2
 2029528:	100d883a 	mov	r6,r2
 202952c:	014080f4 	movhi	r5,515
 2029530:	29650e04 	addi	r5,r5,-27592
 2029534:	20295680 	call	2029568 <sys_timeout>
/** Initialize this module */
void sys_timeouts_init(void)
{
  size_t i;
  /* tcp_tmr() at index 0 is started on demand */
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 2029538:	e0bfff17 	ldw	r2,-4(fp)
 202953c:	10800044 	addi	r2,r2,1
 2029540:	e0bfff15 	stw	r2,-4(fp)
 2029544:	e0bfff17 	ldw	r2,-4(fp)
 2029548:	108001b0 	cmpltui	r2,r2,6
 202954c:	103feb1e 	bne	r2,zero,20294fc <__alt_mem_mem_0+0xfd0094fc>
    /* we have to cast via size_t to get rid of const warning
      (this is OK as cyclic_timer() casts back to const* */
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
  }
}
 2029550:	0001883a 	nop
 2029554:	e037883a 	mov	sp,fp
 2029558:	dfc00117 	ldw	ra,4(sp)
 202955c:	df000017 	ldw	fp,0(sp)
 2029560:	dec00204 	addi	sp,sp,8
 2029564:	f800283a 	ret

02029568 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 2029568:	defffa04 	addi	sp,sp,-24
 202956c:	dfc00515 	stw	ra,20(sp)
 2029570:	df000415 	stw	fp,16(sp)
 2029574:	df000404 	addi	fp,sp,16
 2029578:	e13ffd15 	stw	r4,-12(fp)
 202957c:	e17ffe15 	stw	r5,-8(fp)
 2029580:	e1bfff15 	stw	r6,-4(fp)

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */
 2029584:	2014c9c0 	call	2014c9c <sys_now>
 2029588:	1007883a 	mov	r3,r2
 202958c:	e0bffd17 	ldw	r2,-12(fp)
 2029590:	1885883a 	add	r2,r3,r2
 2029594:	e0bffc15 	stw	r2,-16(fp)

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
 2029598:	e1bfff17 	ldw	r6,-4(fp)
 202959c:	e17ffe17 	ldw	r5,-8(fp)
 20295a0:	e13ffc17 	ldw	r4,-16(fp)
 20295a4:	20293140 	call	2029314 <sys_timeout_abs>
#endif
}
 20295a8:	0001883a 	nop
 20295ac:	e037883a 	mov	sp,fp
 20295b0:	dfc00117 	ldw	ra,4(sp)
 20295b4:	df000017 	ldw	fp,0(sp)
 20295b8:	dec00204 	addi	sp,sp,8
 20295bc:	f800283a 	ret

020295c0 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 20295c0:	defffa04 	addi	sp,sp,-24
 20295c4:	dfc00515 	stw	ra,20(sp)
 20295c8:	df000415 	stw	fp,16(sp)
 20295cc:	df000404 	addi	fp,sp,16
 20295d0:	e13ffe15 	stw	r4,-8(fp)
 20295d4:	e17fff15 	stw	r5,-4(fp)
  struct sys_timeo *prev_t, *t;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
 20295d8:	d0a7f017 	ldw	r2,-24640(gp)
 20295dc:	10002326 	beq	r2,zero,202966c <sys_untimeout+0xac>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 20295e0:	d0a7f017 	ldw	r2,-24640(gp)
 20295e4:	e0bffd15 	stw	r2,-12(fp)
 20295e8:	e03ffc15 	stw	zero,-16(fp)
 20295ec:	00001b06 	br	202965c <sys_untimeout+0x9c>
    if ((t->h == handler) && (t->arg == arg)) {
 20295f0:	e0bffd17 	ldw	r2,-12(fp)
 20295f4:	10c00217 	ldw	r3,8(r2)
 20295f8:	e0bffe17 	ldw	r2,-8(fp)
 20295fc:	1880121e 	bne	r3,r2,2029648 <sys_untimeout+0x88>
 2029600:	e0bffd17 	ldw	r2,-12(fp)
 2029604:	10c00317 	ldw	r3,12(r2)
 2029608:	e0bfff17 	ldw	r2,-4(fp)
 202960c:	18800e1e 	bne	r3,r2,2029648 <sys_untimeout+0x88>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 2029610:	e0bffc17 	ldw	r2,-16(fp)
 2029614:	1000041e 	bne	r2,zero,2029628 <sys_untimeout+0x68>
        next_timeout = t->next;
 2029618:	e0bffd17 	ldw	r2,-12(fp)
 202961c:	10800017 	ldw	r2,0(r2)
 2029620:	d0a7f015 	stw	r2,-24640(gp)
 2029624:	00000406 	br	2029638 <sys_untimeout+0x78>
      } else {
        prev_t->next = t->next;
 2029628:	e0bffd17 	ldw	r2,-12(fp)
 202962c:	10c00017 	ldw	r3,0(r2)
 2029630:	e0bffc17 	ldw	r2,-16(fp)
 2029634:	10c00015 	stw	r3,0(r2)
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 2029638:	e17ffd17 	ldw	r5,-12(fp)
 202963c:	01000304 	movi	r4,12
 2029640:	201b9640 	call	201b964 <memp_free>
      return;
 2029644:	00000a06 	br	2029670 <sys_untimeout+0xb0>

  if (next_timeout == NULL) {
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 2029648:	e0bffd17 	ldw	r2,-12(fp)
 202964c:	e0bffc15 	stw	r2,-16(fp)
 2029650:	e0bffd17 	ldw	r2,-12(fp)
 2029654:	10800017 	ldw	r2,0(r2)
 2029658:	e0bffd15 	stw	r2,-12(fp)
 202965c:	e0bffd17 	ldw	r2,-12(fp)
 2029660:	103fe31e 	bne	r2,zero,20295f0 <__alt_mem_mem_0+0xfd0095f0>
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
 2029664:	0001883a 	nop
 2029668:	00000106 	br	2029670 <sys_untimeout+0xb0>
  struct sys_timeo *prev_t, *t;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
    return;
 202966c:	0001883a 	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
 2029670:	e037883a 	mov	sp,fp
 2029674:	dfc00117 	ldw	ra,4(sp)
 2029678:	df000017 	ldw	fp,0(sp)
 202967c:	dec00204 	addi	sp,sp,8
 2029680:	f800283a 	ret

02029684 <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void
sys_check_timeouts(void)
{
 2029684:	defffa04 	addi	sp,sp,-24
 2029688:	dfc00515 	stw	ra,20(sp)
 202968c:	df000415 	stw	fp,16(sp)
 2029690:	df000404 	addi	fp,sp,16
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  /* Process only timers expired at the start of the function. */
  now = sys_now();
 2029694:	2014c9c0 	call	2014c9c <sys_now>
 2029698:	e0bffc15 	stw	r2,-16(fp)
    sys_timeout_handler handler;
    void *arg;

    PBUF_CHECK_FREE_OOSEQ();

    tmptimeout = next_timeout;
 202969c:	d0a7f017 	ldw	r2,-24640(gp)
 20296a0:	e0bffd15 	stw	r2,-12(fp)
    if (tmptimeout == NULL) {
 20296a4:	e0bffd17 	ldw	r2,-12(fp)
 20296a8:	10001a26 	beq	r2,zero,2029714 <sys_check_timeouts+0x90>
      return;
    }

    if (TIME_LESS_THAN(now, tmptimeout->time)) {
 20296ac:	e0bffd17 	ldw	r2,-12(fp)
 20296b0:	10800117 	ldw	r2,4(r2)
 20296b4:	e0fffc17 	ldw	r3,-16(fp)
 20296b8:	1885c83a 	sub	r2,r3,r2
 20296bc:	10001716 	blt	r2,zero,202971c <sys_check_timeouts+0x98>
      return;
    }

    /* Timeout has expired */
    next_timeout = tmptimeout->next;
 20296c0:	e0bffd17 	ldw	r2,-12(fp)
 20296c4:	10800017 	ldw	r2,0(r2)
 20296c8:	d0a7f015 	stw	r2,-24640(gp)
    handler = tmptimeout->h;
 20296cc:	e0bffd17 	ldw	r2,-12(fp)
 20296d0:	10800217 	ldw	r2,8(r2)
 20296d4:	e0bffe15 	stw	r2,-8(fp)
    arg = tmptimeout->arg;
 20296d8:	e0bffd17 	ldw	r2,-12(fp)
 20296dc:	10800317 	ldw	r2,12(r2)
 20296e0:	e0bfff15 	stw	r2,-4(fp)
    current_timeout_due_time = tmptimeout->time;
 20296e4:	e0bffd17 	ldw	r2,-12(fp)
 20296e8:	10800117 	ldw	r2,4(r2)
 20296ec:	d0a7f115 	stw	r2,-24636(gp)
    if (handler != NULL) {
      LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s t=%"U32_F" arg=%p\n",
                                 tmptimeout->handler_name, sys_now() - tmptimeout->time, arg));
    }
#endif /* LWIP_DEBUG_TIMERNAMES */
    memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 20296f0:	e17ffd17 	ldw	r5,-12(fp)
 20296f4:	01000304 	movi	r4,12
 20296f8:	201b9640 	call	201b964 <memp_free>
    if (handler != NULL) {
 20296fc:	e0bffe17 	ldw	r2,-8(fp)
 2029700:	103fe626 	beq	r2,zero,202969c <__alt_mem_mem_0+0xfd00969c>
      handler(arg);
 2029704:	e0bffe17 	ldw	r2,-8(fp)
 2029708:	e13fff17 	ldw	r4,-4(fp)
 202970c:	103ee83a 	callr	r2
    }
    LWIP_TCPIP_THREAD_ALIVE();

    /* Repeat until all expired timers have been called */
  } while (1);
 2029710:	003fe206 	br	202969c <__alt_mem_mem_0+0xfd00969c>

    PBUF_CHECK_FREE_OOSEQ();

    tmptimeout = next_timeout;
    if (tmptimeout == NULL) {
      return;
 2029714:	0001883a 	nop
 2029718:	00000106 	br	2029720 <sys_check_timeouts+0x9c>
    }

    if (TIME_LESS_THAN(now, tmptimeout->time)) {
      return;
 202971c:	0001883a 	nop
    }
    LWIP_TCPIP_THREAD_ALIVE();

    /* Repeat until all expired timers have been called */
  } while (1);
}
 2029720:	e037883a 	mov	sp,fp
 2029724:	dfc00117 	ldw	ra,4(sp)
 2029728:	df000017 	ldw	fp,0(sp)
 202972c:	dec00204 	addi	sp,sp,8
 2029730:	f800283a 	ret

02029734 <sys_restart_timeouts>:
 * time (e.g. while saving energy) to prevent all timer functions of that
 * period being called.
 */
void
sys_restart_timeouts(void)
{
 2029734:	defffb04 	addi	sp,sp,-20
 2029738:	dfc00415 	stw	ra,16(sp)
 202973c:	df000315 	stw	fp,12(sp)
 2029740:	df000304 	addi	fp,sp,12
  u32_t now;
  u32_t base;
  struct sys_timeo *t;

  if (next_timeout == NULL) {
 2029744:	d0a7f017 	ldw	r2,-24640(gp)
 2029748:	10001626 	beq	r2,zero,20297a4 <sys_restart_timeouts+0x70>
    return;
  }

  now = sys_now();
 202974c:	2014c9c0 	call	2014c9c <sys_now>
 2029750:	e0bffe15 	stw	r2,-8(fp)
  base = next_timeout->time;
 2029754:	d0a7f017 	ldw	r2,-24640(gp)
 2029758:	10800117 	ldw	r2,4(r2)
 202975c:	e0bfff15 	stw	r2,-4(fp)

  for (t = next_timeout; t != NULL; t = t->next) {
 2029760:	d0a7f017 	ldw	r2,-24640(gp)
 2029764:	e0bffd15 	stw	r2,-12(fp)
 2029768:	00000b06 	br	2029798 <sys_restart_timeouts+0x64>
    t->time = (t->time - base) + now;
 202976c:	e0bffd17 	ldw	r2,-12(fp)
 2029770:	10c00117 	ldw	r3,4(r2)
 2029774:	e0bfff17 	ldw	r2,-4(fp)
 2029778:	1887c83a 	sub	r3,r3,r2
 202977c:	e0bffe17 	ldw	r2,-8(fp)
 2029780:	1887883a 	add	r3,r3,r2
 2029784:	e0bffd17 	ldw	r2,-12(fp)
 2029788:	10c00115 	stw	r3,4(r2)
  }

  now = sys_now();
  base = next_timeout->time;

  for (t = next_timeout; t != NULL; t = t->next) {
 202978c:	e0bffd17 	ldw	r2,-12(fp)
 2029790:	10800017 	ldw	r2,0(r2)
 2029794:	e0bffd15 	stw	r2,-12(fp)
 2029798:	e0bffd17 	ldw	r2,-12(fp)
 202979c:	103ff31e 	bne	r2,zero,202976c <__alt_mem_mem_0+0xfd00976c>
 20297a0:	00000106 	br	20297a8 <sys_restart_timeouts+0x74>
  u32_t now;
  u32_t base;
  struct sys_timeo *t;

  if (next_timeout == NULL) {
    return;
 20297a4:	0001883a 	nop
  base = next_timeout->time;

  for (t = next_timeout; t != NULL; t = t->next) {
    t->time = (t->time - base) + now;
  }
}
 20297a8:	e037883a 	mov	sp,fp
 20297ac:	dfc00117 	ldw	ra,4(sp)
 20297b0:	df000017 	ldw	fp,0(sp)
 20297b4:	dec00204 	addi	sp,sp,8
 20297b8:	f800283a 	ret

020297bc <sys_timeouts_sleeptime>:
/** Return the time left before the next timeout is due. If no timeouts are
 * enqueued, returns 0xffffffff
 */
u32_t
sys_timeouts_sleeptime(void)
{
 20297bc:	defffc04 	addi	sp,sp,-16
 20297c0:	dfc00315 	stw	ra,12(sp)
 20297c4:	df000215 	stw	fp,8(sp)
 20297c8:	df000204 	addi	fp,sp,8
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
 20297cc:	d0a7f017 	ldw	r2,-24640(gp)
 20297d0:	1000021e 	bne	r2,zero,20297dc <sys_timeouts_sleeptime+0x20>
    return SYS_TIMEOUTS_SLEEPTIME_INFINITE;
 20297d4:	00bfffc4 	movi	r2,-1
 20297d8:	00000f06 	br	2029818 <sys_timeouts_sleeptime+0x5c>
  }
  now = sys_now();
 20297dc:	2014c9c0 	call	2014c9c <sys_now>
 20297e0:	e0bffe15 	stw	r2,-8(fp)
  if (TIME_LESS_THAN(next_timeout->time, now)) {
 20297e4:	d0a7f017 	ldw	r2,-24640(gp)
 20297e8:	10c00117 	ldw	r3,4(r2)
 20297ec:	e0bffe17 	ldw	r2,-8(fp)
 20297f0:	1885c83a 	sub	r2,r3,r2
 20297f4:	1000020e 	bge	r2,zero,2029800 <sys_timeouts_sleeptime+0x44>
    return 0;
 20297f8:	0005883a 	mov	r2,zero
 20297fc:	00000606 	br	2029818 <sys_timeouts_sleeptime+0x5c>
  } else {
    u32_t ret = (u32_t)(next_timeout->time - now);
 2029800:	d0a7f017 	ldw	r2,-24640(gp)
 2029804:	10c00117 	ldw	r3,4(r2)
 2029808:	e0bffe17 	ldw	r2,-8(fp)
 202980c:	1885c83a 	sub	r2,r3,r2
 2029810:	e0bfff15 	stw	r2,-4(fp)
    LWIP_ASSERT("invalid sleeptime", ret <= LWIP_MAX_TIMEOUT);
    return ret;
 2029814:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 2029818:	e037883a 	mov	sp,fp
 202981c:	dfc00117 	ldw	ra,4(sp)
 2029820:	df000017 	ldw	fp,0(sp)
 2029824:	dec00204 	addi	sp,sp,8
 2029828:	f800283a 	ret

0202982c <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 202982c:	deffff04 	addi	sp,sp,-4
 2029830:	df000015 	stw	fp,0(sp)
 2029834:	d839883a 	mov	fp,sp
#ifdef LWIP_RAND
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RAND */
}
 2029838:	0001883a 	nop
 202983c:	e037883a 	mov	sp,fp
 2029840:	df000017 	ldw	fp,0(sp)
 2029844:	dec00104 	addi	sp,sp,4
 2029848:	f800283a 	ret

0202984c <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
 202984c:	defffd04 	addi	sp,sp,-12
 2029850:	df000215 	stw	fp,8(sp)
 2029854:	df000204 	addi	fp,sp,8
  u16_t n = 0;
 2029858:	e03ffe0d 	sth	zero,-8(fp)
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 202985c:	d0a0150b 	ldhu	r2,-32684(gp)
 2029860:	10c00044 	addi	r3,r2,1
 2029864:	d0e0150d 	sth	r3,-32684(gp)
 2029868:	10ffffcc 	andi	r3,r2,65535
 202986c:	00bfffd4 	movui	r2,65535
 2029870:	1880021e 	bne	r3,r2,202987c <udp_new_port+0x30>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 2029874:	00b00004 	movi	r2,-16384
 2029878:	d0a0150d 	sth	r2,-32684(gp)
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 202987c:	d0a7f317 	ldw	r2,-24628(gp)
 2029880:	e0bfff15 	stw	r2,-4(fp)
 2029884:	00001106 	br	20298cc <udp_new_port+0x80>
    if (pcb->local_port == udp_port) {
 2029888:	e0bfff17 	ldw	r2,-4(fp)
 202988c:	10c0058b 	ldhu	r3,22(r2)
 2029890:	d0a0150b 	ldhu	r2,-32684(gp)
 2029894:	18ffffcc 	andi	r3,r3,65535
 2029898:	10bfffcc 	andi	r2,r2,65535
 202989c:	1880081e 	bne	r3,r2,20298c0 <udp_new_port+0x74>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 20298a0:	e0bffe0b 	ldhu	r2,-8(fp)
 20298a4:	10800044 	addi	r2,r2,1
 20298a8:	e0bffe0d 	sth	r2,-8(fp)
 20298ac:	e0bffe0b 	ldhu	r2,-8(fp)
 20298b0:	10900030 	cmpltui	r2,r2,16384
 20298b4:	103fe91e 	bne	r2,zero,202985c <__alt_mem_mem_0+0xfd00985c>
        return 0;
 20298b8:	0005883a 	mov	r2,zero
 20298bc:	00000606 	br	20298d8 <udp_new_port+0x8c>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 20298c0:	e0bfff17 	ldw	r2,-4(fp)
 20298c4:	10800417 	ldw	r2,16(r2)
 20298c8:	e0bfff15 	stw	r2,-4(fp)
 20298cc:	e0bfff17 	ldw	r2,-4(fp)
 20298d0:	103fed1e 	bne	r2,zero,2029888 <__alt_mem_mem_0+0xfd009888>
        return 0;
      }
      goto again;
    }
  }
  return udp_port;
 20298d4:	d0a0150b 	ldhu	r2,-32684(gp)
}
 20298d8:	e037883a 	mov	sp,fp
 20298dc:	df000017 	ldw	fp,0(sp)
 20298e0:	dec00104 	addi	sp,sp,4
 20298e4:	f800283a 	ret

020298e8 <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
 20298e8:	defffc04 	addi	sp,sp,-16
 20298ec:	df000315 	stw	fp,12(sp)
 20298f0:	df000304 	addi	fp,sp,12
 20298f4:	e13ffd15 	stw	r4,-12(fp)
 20298f8:	e17ffe15 	stw	r5,-8(fp)
 20298fc:	3005883a 	mov	r2,r6
 2029900:	e0bfff05 	stb	r2,-4(fp)

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 2029904:	e0bffd17 	ldw	r2,-12(fp)
 2029908:	10800203 	ldbu	r2,8(r2)
 202990c:	10803fcc 	andi	r2,r2,255
 2029910:	10000c26 	beq	r2,zero,2029944 <udp_input_local_match+0x5c>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 2029914:	e0bffd17 	ldw	r2,-12(fp)
 2029918:	10c00203 	ldbu	r3,8(r2)
 202991c:	008085f4 	movhi	r2,535
 2029920:	10be4204 	addi	r2,r2,-1784
 2029924:	10800117 	ldw	r2,4(r2)
 2029928:	10801003 	ldbu	r2,64(r2)
 202992c:	10800044 	addi	r2,r2,1

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 2029930:	18c03fcc 	andi	r3,r3,255
 2029934:	10803fcc 	andi	r2,r2,255
 2029938:	18800226 	beq	r3,r2,2029944 <udp_input_local_match+0x5c>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
    return 0;
 202993c:	0005883a 	mov	r2,zero
 2029940:	00002706 	br	20299e0 <udp_input_local_match+0xf8>
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 2029944:	e0bfff03 	ldbu	r2,-4(fp)
 2029948:	10001726 	beq	r2,zero,20299a8 <udp_input_local_match+0xc0>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 202994c:	e0bffd17 	ldw	r2,-12(fp)
 2029950:	10001326 	beq	r2,zero,20299a0 <udp_input_local_match+0xb8>
 2029954:	e0bffd17 	ldw	r2,-12(fp)
 2029958:	10800017 	ldw	r2,0(r2)
 202995c:	10001026 	beq	r2,zero,20299a0 <udp_input_local_match+0xb8>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 2029960:	008085f4 	movhi	r2,535
 2029964:	10be4204 	addi	r2,r2,-1784
 2029968:	10800517 	ldw	r2,20(r2)
    if (broadcast != 0) {
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 202996c:	10bfffe0 	cmpeqi	r2,r2,-1
 2029970:	10000b1e 	bne	r2,zero,20299a0 <udp_input_local_match+0xb8>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 2029974:	e0bffd17 	ldw	r2,-12(fp)
 2029978:	10c00017 	ldw	r3,0(r2)
 202997c:	008085f4 	movhi	r2,535
 2029980:	10be4204 	addi	r2,r2,-1784
 2029984:	10800517 	ldw	r2,20(r2)
 2029988:	1886f03a 	xor	r3,r3,r2
 202998c:	e0bffe17 	ldw	r2,-8(fp)
 2029990:	10800204 	addi	r2,r2,8
 2029994:	10800017 	ldw	r2,0(r2)
 2029998:	1884703a 	and	r2,r3,r2
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 202999c:	10000f1e 	bne	r2,zero,20299dc <udp_input_local_match+0xf4>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
          return 1;
 20299a0:	00800044 	movi	r2,1
 20299a4:	00000e06 	br	20299e0 <udp_input_local_match+0xf8>
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: all or exact match */
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 20299a8:	e0bffd17 	ldw	r2,-12(fp)
 20299ac:	10000926 	beq	r2,zero,20299d4 <udp_input_local_match+0xec>
 20299b0:	e0bffd17 	ldw	r2,-12(fp)
 20299b4:	10800017 	ldw	r2,0(r2)
 20299b8:	10000626 	beq	r2,zero,20299d4 <udp_input_local_match+0xec>
 20299bc:	e0bffd17 	ldw	r2,-12(fp)
 20299c0:	10c00017 	ldw	r3,0(r2)
 20299c4:	008085f4 	movhi	r2,535
 20299c8:	10be4204 	addi	r2,r2,-1784
 20299cc:	10800517 	ldw	r2,20(r2)
 20299d0:	1880021e 	bne	r3,r2,20299dc <udp_input_local_match+0xf4>
        return 1;
 20299d4:	00800044 	movi	r2,1
 20299d8:	00000106 	br	20299e0 <udp_input_local_match+0xf8>
      }
  }

  return 0;
 20299dc:	0005883a 	mov	r2,zero
}
 20299e0:	e037883a 	mov	sp,fp
 20299e4:	df000017 	ldw	fp,0(sp)
 20299e8:	dec00104 	addi	sp,sp,4
 20299ec:	f800283a 	ret

020299f0 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 20299f0:	defff404 	addi	sp,sp,-48
 20299f4:	dfc00b15 	stw	ra,44(sp)
 20299f8:	df000a15 	stw	fp,40(sp)
 20299fc:	df000a04 	addi	fp,sp,40
 2029a00:	e13ffe15 	stw	r4,-8(fp)
 2029a04:	e17fff15 	stw	r5,-4(fp)
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  u16_t src, dest;
  u8_t broadcast;
  u8_t for_us = 0;
 2029a08:	e03ffa05 	stb	zero,-24(fp)
  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);

  PERF_START;

  UDP_STATS_INC(udp.recv);
 2029a0c:	008085f4 	movhi	r2,535
 2029a10:	10bd8204 	addi	r2,r2,-2552
 2029a14:	10803d17 	ldw	r2,244(r2)
 2029a18:	10c00044 	addi	r3,r2,1
 2029a1c:	008085f4 	movhi	r2,535
 2029a20:	10bd8204 	addi	r2,r2,-2552
 2029a24:	10c03d15 	stw	r3,244(r2)

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 2029a28:	e0bffe17 	ldw	r2,-8(fp)
 2029a2c:	1080028b 	ldhu	r2,10(r2)
 2029a30:	10bfffcc 	andi	r2,r2,65535
 2029a34:	10800228 	cmpgeui	r2,r2,8
 2029a38:	1000111e 	bne	r2,zero,2029a80 <udp_input+0x90>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 2029a3c:	008085f4 	movhi	r2,535
 2029a40:	10bd8204 	addi	r2,r2,-2552
 2029a44:	10804117 	ldw	r2,260(r2)
 2029a48:	10c00044 	addi	r3,r2,1
 2029a4c:	008085f4 	movhi	r2,535
 2029a50:	10bd8204 	addi	r2,r2,-2552
 2029a54:	10c04115 	stw	r3,260(r2)
    UDP_STATS_INC(udp.drop);
 2029a58:	008085f4 	movhi	r2,535
 2029a5c:	10bd8204 	addi	r2,r2,-2552
 2029a60:	10803f17 	ldw	r2,252(r2)
 2029a64:	10c00044 	addi	r3,r2,1
 2029a68:	008085f4 	movhi	r2,535
 2029a6c:	10bd8204 	addi	r2,r2,-2552
 2029a70:	10c03f15 	stw	r3,252(r2)
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
 2029a74:	e13ffe17 	ldw	r4,-8(fp)
 2029a78:	201d2f40 	call	201d2f4 <pbuf_free>
    goto end;
 2029a7c:	0000f706 	br	2029e5c <udp_input+0x46c>
  }

  udphdr = (struct udp_hdr *)p->payload;
 2029a80:	e0bffe17 	ldw	r2,-8(fp)
 2029a84:	10800117 	ldw	r2,4(r2)
 2029a88:	e0bffb15 	stw	r2,-20(fp)

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 2029a8c:	008085f4 	movhi	r2,535
 2029a90:	10be4204 	addi	r2,r2,-1784
 2029a94:	10c00517 	ldw	r3,20(r2)
 2029a98:	008085f4 	movhi	r2,535
 2029a9c:	10be4204 	addi	r2,r2,-1784
 2029aa0:	10800017 	ldw	r2,0(r2)
 2029aa4:	100b883a 	mov	r5,r2
 2029aa8:	1809883a 	mov	r4,r3
 2029aac:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
 2029ab0:	e0bffc05 	stb	r2,-16(fp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 2029ab4:	e0bffb17 	ldw	r2,-20(fp)
 2029ab8:	10c00003 	ldbu	r3,0(r2)
 2029abc:	10800043 	ldbu	r2,1(r2)
 2029ac0:	1004923a 	slli	r2,r2,8
 2029ac4:	10c4b03a 	or	r2,r2,r3
 2029ac8:	10bfffcc 	andi	r2,r2,65535
 2029acc:	1009883a 	mov	r4,r2
 2029ad0:	20394740 	call	2039474 <lwip_htons>
 2029ad4:	e0bffc8d 	sth	r2,-14(fp)
  dest = lwip_ntohs(udphdr->dest);
 2029ad8:	e0bffb17 	ldw	r2,-20(fp)
 2029adc:	10c00083 	ldbu	r3,2(r2)
 2029ae0:	108000c3 	ldbu	r2,3(r2)
 2029ae4:	1004923a 	slli	r2,r2,8
 2029ae8:	10c4b03a 	or	r2,r2,r3
 2029aec:	10bfffcc 	andi	r2,r2,65535
 2029af0:	1009883a 	mov	r4,r2
 2029af4:	20394740 	call	2039474 <lwip_htons>
 2029af8:	e0bffd0d 	sth	r2,-12(fp)
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));

  pcb = NULL;
 2029afc:	e03ff715 	stw	zero,-36(fp)
  prev = NULL;
 2029b00:	e03ff815 	stw	zero,-32(fp)
  uncon_pcb = NULL;
 2029b04:	e03ff915 	stw	zero,-28(fp)
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 2029b08:	d0a7f317 	ldw	r2,-24628(gp)
 2029b0c:	e0bff715 	stw	r2,-36(fp)
 2029b10:	00005c06 	br	2029c84 <udp_input+0x294>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
 2029b14:	e0bff717 	ldw	r2,-36(fp)
 2029b18:	1080058b 	ldhu	r2,22(r2)
 2029b1c:	10ffffcc 	andi	r3,r2,65535
 2029b20:	e0bffd0b 	ldhu	r2,-12(fp)
 2029b24:	1880521e 	bne	r3,r2,2029c70 <udp_input+0x280>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 2029b28:	e0bffc03 	ldbu	r2,-16(fp)
 2029b2c:	100d883a 	mov	r6,r2
 2029b30:	e17fff17 	ldw	r5,-4(fp)
 2029b34:	e13ff717 	ldw	r4,-36(fp)
 2029b38:	20298e80 	call	20298e8 <udp_input_local_match>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
 2029b3c:	10803fcc 	andi	r2,r2,255
 2029b40:	10004b26 	beq	r2,zero,2029c70 <udp_input+0x280>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 2029b44:	e0bff717 	ldw	r2,-36(fp)
 2029b48:	10800503 	ldbu	r2,20(r2)
 2029b4c:	10803fcc 	andi	r2,r2,255
 2029b50:	1080010c 	andi	r2,r2,4
 2029b54:	1000241e 	bne	r2,zero,2029be8 <udp_input+0x1f8>
        if (uncon_pcb == NULL) {
 2029b58:	e0bff917 	ldw	r2,-28(fp)
 2029b5c:	1000031e 	bne	r2,zero,2029b6c <udp_input+0x17c>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
 2029b60:	e0bff717 	ldw	r2,-36(fp)
 2029b64:	e0bff915 	stw	r2,-28(fp)
 2029b68:	00001f06 	br	2029be8 <udp_input+0x1f8>
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 2029b6c:	e0bffc03 	ldbu	r2,-16(fp)
 2029b70:	10001426 	beq	r2,zero,2029bc4 <udp_input+0x1d4>
 2029b74:	008085f4 	movhi	r2,535
 2029b78:	10be4204 	addi	r2,r2,-1784
 2029b7c:	10800517 	ldw	r2,20(r2)
 2029b80:	10bfffd8 	cmpnei	r2,r2,-1
 2029b84:	10000f1e 	bne	r2,zero,2029bc4 <udp_input+0x1d4>
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 2029b88:	e0bff917 	ldw	r2,-28(fp)
 2029b8c:	10c00017 	ldw	r3,0(r2)
 2029b90:	e0bfff17 	ldw	r2,-4(fp)
 2029b94:	10800104 	addi	r2,r2,4
 2029b98:	10800017 	ldw	r2,0(r2)
 2029b9c:	18801126 	beq	r3,r2,2029be4 <udp_input+0x1f4>
            /* uncon_pcb does not match the input netif, check this pcb */
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
 2029ba0:	e0bff717 	ldw	r2,-36(fp)
 2029ba4:	10c00017 	ldw	r3,0(r2)
 2029ba8:	e0bfff17 	ldw	r2,-4(fp)
 2029bac:	10800104 	addi	r2,r2,4
 2029bb0:	10800017 	ldw	r2,0(r2)
 2029bb4:	18800b1e 	bne	r3,r2,2029be4 <udp_input+0x1f4>
              /* better match */
              uncon_pcb = pcb;
 2029bb8:	e0bff717 	ldw	r2,-36(fp)
 2029bbc:	e0bff915 	stw	r2,-28(fp)
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 2029bc0:	00000806 	br	2029be4 <udp_input+0x1f4>
            }
          }
#endif /* LWIP_IPV4 */
        }
#if SO_REUSE
        else if (!ip_addr_isany(&pcb->local_ip)) {
 2029bc4:	e0bff717 	ldw	r2,-36(fp)
 2029bc8:	10000726 	beq	r2,zero,2029be8 <udp_input+0x1f8>
 2029bcc:	e0bff717 	ldw	r2,-36(fp)
 2029bd0:	10800017 	ldw	r2,0(r2)
 2029bd4:	10000426 	beq	r2,zero,2029be8 <udp_input+0x1f8>
          /* prefer specific IPs over catch-all */
          uncon_pcb = pcb;
 2029bd8:	e0bff717 	ldw	r2,-36(fp)
 2029bdc:	e0bff915 	stw	r2,-28(fp)
 2029be0:	00000106 	br	2029be8 <udp_input+0x1f8>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 2029be4:	0001883a 	nop
        }
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
 2029be8:	e0bff717 	ldw	r2,-36(fp)
 2029bec:	1080060b 	ldhu	r2,24(r2)
 2029bf0:	10ffffcc 	andi	r3,r2,65535
 2029bf4:	e0bffc8b 	ldhu	r2,-14(fp)
 2029bf8:	18801d1e 	bne	r3,r2,2029c70 <udp_input+0x280>
          (ip_addr_isany_val(pcb->remote_ip) ||
 2029bfc:	e0bff717 	ldw	r2,-36(fp)
 2029c00:	10800117 	ldw	r2,4(r2)
        }
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
 2029c04:	10000626 	beq	r2,zero,2029c20 <udp_input+0x230>
          (ip_addr_isany_val(pcb->remote_ip) ||
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 2029c08:	e0bff717 	ldw	r2,-36(fp)
 2029c0c:	10c00117 	ldw	r3,4(r2)
 2029c10:	008085f4 	movhi	r2,535
 2029c14:	10be4204 	addi	r2,r2,-1784
 2029c18:	10800417 	ldw	r2,16(r2)
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
          (ip_addr_isany_val(pcb->remote_ip) ||
 2029c1c:	1880141e 	bne	r3,r2,2029c70 <udp_input+0x280>
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
 2029c20:	e0bff817 	ldw	r2,-32(fp)
 2029c24:	10000a26 	beq	r2,zero,2029c50 <udp_input+0x260>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 2029c28:	e0bff717 	ldw	r2,-36(fp)
 2029c2c:	10c00417 	ldw	r3,16(r2)
 2029c30:	e0bff817 	ldw	r2,-32(fp)
 2029c34:	10c00415 	stw	r3,16(r2)
          pcb->next = udp_pcbs;
 2029c38:	d0e7f317 	ldw	r3,-24628(gp)
 2029c3c:	e0bff717 	ldw	r2,-36(fp)
 2029c40:	10c00415 	stw	r3,16(r2)
          udp_pcbs = pcb;
 2029c44:	e0bff717 	ldw	r2,-36(fp)
 2029c48:	d0a7f315 	stw	r2,-24628(gp)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 2029c4c:	00000f06 	br	2029c8c <udp_input+0x29c>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
 2029c50:	008085f4 	movhi	r2,535
 2029c54:	10bd8204 	addi	r2,r2,-2552
 2029c58:	10804717 	ldw	r2,284(r2)
 2029c5c:	10c00044 	addi	r3,r2,1
 2029c60:	008085f4 	movhi	r2,535
 2029c64:	10bd8204 	addi	r2,r2,-2552
 2029c68:	10c04715 	stw	r3,284(r2)
        }
        break;
 2029c6c:	00000706 	br	2029c8c <udp_input+0x29c>
      }
    }

    prev = pcb;
 2029c70:	e0bff717 	ldw	r2,-36(fp)
 2029c74:	e0bff815 	stw	r2,-32(fp)
  uncon_pcb = NULL;
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 2029c78:	e0bff717 	ldw	r2,-36(fp)
 2029c7c:	10800417 	ldw	r2,16(r2)
 2029c80:	e0bff715 	stw	r2,-36(fp)
 2029c84:	e0bff717 	ldw	r2,-36(fp)
 2029c88:	103fa21e 	bne	r2,zero,2029b14 <__alt_mem_mem_0+0xfd009b14>
    }

    prev = pcb;
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
 2029c8c:	e0bff717 	ldw	r2,-36(fp)
 2029c90:	1000021e 	bne	r2,zero,2029c9c <udp_input+0x2ac>
    pcb = uncon_pcb;
 2029c94:	e0bff917 	ldw	r2,-28(fp)
 2029c98:	e0bff715 	stw	r2,-36(fp)
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL) {
 2029c9c:	e0bff717 	ldw	r2,-36(fp)
 2029ca0:	10000326 	beq	r2,zero,2029cb0 <udp_input+0x2c0>
    for_us = 1;
 2029ca4:	00800044 	movi	r2,1
 2029ca8:	e0bffa05 	stb	r2,-24(fp)
 2029cac:	00000806 	br	2029cd0 <udp_input+0x2e0>
      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    }
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    if (!ip_current_is_v6()) {
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 2029cb0:	e0bfff17 	ldw	r2,-4(fp)
 2029cb4:	10800104 	addi	r2,r2,4
 2029cb8:	10c00017 	ldw	r3,0(r2)
 2029cbc:	008085f4 	movhi	r2,535
 2029cc0:	10be4204 	addi	r2,r2,-1784
 2029cc4:	10800517 	ldw	r2,20(r2)
 2029cc8:	1885003a 	cmpeq	r2,r3,r2
 2029ccc:	e0bffa05 	stb	r2,-24(fp)
    }
#endif /* LWIP_IPV4 */
  }

  if (for_us) {
 2029cd0:	e0bffa03 	ldbu	r2,-24(fp)
 2029cd4:	10005e26 	beq	r2,zero,2029e50 <udp_input+0x460>
          goto chkerr;
        }
      } else
#endif /* LWIP_UDPLITE */
      {
        if (udphdr->chksum != 0) {
 2029cd8:	e0bffb17 	ldw	r2,-20(fp)
 2029cdc:	10c00183 	ldbu	r3,6(r2)
 2029ce0:	108001c3 	ldbu	r2,7(r2)
 2029ce4:	1004923a 	slli	r2,r2,8
 2029ce8:	10c4b03a 	or	r2,r2,r3
 2029cec:	10bfffcc 	andi	r2,r2,65535
 2029cf0:	10000e26 	beq	r2,zero,2029d2c <udp_input+0x33c>
          if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
 2029cf4:	e0bffe17 	ldw	r2,-8(fp)
 2029cf8:	1080020b 	ldhu	r2,8(r2)
 2029cfc:	10ffffcc 	andi	r3,r2,65535
 2029d00:	008085f4 	movhi	r2,535
 2029d04:	10be4704 	addi	r2,r2,-1764
 2029d08:	d8800015 	stw	r2,0(sp)
 2029d0c:	01c085f4 	movhi	r7,535
 2029d10:	39fe4604 	addi	r7,r7,-1768
 2029d14:	180d883a 	mov	r6,r3
 2029d18:	01400444 	movi	r5,17
 2029d1c:	e13ffe17 	ldw	r4,-8(fp)
 2029d20:	2039e440 	call	2039e44 <ip_chksum_pseudo>
 2029d24:	10bfffcc 	andi	r2,r2,65535
 2029d28:	10004d1e 	bne	r2,zero,2029e60 <udp_input+0x470>
          }
        }
      }
    }
#endif /* CHECKSUM_CHECK_UDP */
    if (pbuf_remove_header(p, UDP_HLEN)) {
 2029d2c:	01400204 	movi	r5,8
 2029d30:	e13ffe17 	ldw	r4,-8(fp)
 2029d34:	201d06c0 	call	201d06c <pbuf_remove_header>
 2029d38:	10803fcc 	andi	r2,r2,255
 2029d3c:	10000a26 	beq	r2,zero,2029d68 <udp_input+0x378>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
 2029d40:	008085f4 	movhi	r2,535
 2029d44:	10bd8204 	addi	r2,r2,-2552
 2029d48:	10803f17 	ldw	r2,252(r2)
 2029d4c:	10c00044 	addi	r3,r2,1
 2029d50:	008085f4 	movhi	r2,535
 2029d54:	10bd8204 	addi	r2,r2,-2552
 2029d58:	10c03f15 	stw	r3,252(r2)
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
 2029d5c:	e13ffe17 	ldw	r4,-8(fp)
 2029d60:	201d2f40 	call	201d2f4 <pbuf_free>
      goto end;
 2029d64:	00003d06 	br	2029e5c <udp_input+0x46c>
    }

    if (pcb != NULL) {
 2029d68:	e0bff717 	ldw	r2,-36(fp)
 2029d6c:	10001226 	beq	r2,zero,2029db8 <udp_input+0x3c8>
          }
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 2029d70:	e0bff717 	ldw	r2,-36(fp)
 2029d74:	10800717 	ldw	r2,28(r2)
 2029d78:	10000c26 	beq	r2,zero,2029dac <udp_input+0x3bc>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 2029d7c:	e0bff717 	ldw	r2,-36(fp)
 2029d80:	10800717 	ldw	r2,28(r2)
 2029d84:	e0fff717 	ldw	r3,-36(fp)
 2029d88:	19000817 	ldw	r4,32(r3)
 2029d8c:	e0fffc8b 	ldhu	r3,-14(fp)
 2029d90:	d8c00015 	stw	r3,0(sp)
 2029d94:	01c085f4 	movhi	r7,535
 2029d98:	39fe4604 	addi	r7,r7,-1768
 2029d9c:	e1bffe17 	ldw	r6,-8(fp)
 2029da0:	e17ff717 	ldw	r5,-36(fp)
 2029da4:	103ee83a 	callr	r2
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
 2029da8:	00003e06 	br	2029ea4 <udp_input+0x4b4>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
 2029dac:	e13ffe17 	ldw	r4,-8(fp)
 2029db0:	201d2f40 	call	201d2f4 <pbuf_free>
        goto end;
 2029db4:	00002906 	br	2029e5c <udp_input+0x46c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP || LWIP_ICMP6
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 2029db8:	e0bffc03 	ldbu	r2,-16(fp)
 2029dbc:	1000131e 	bne	r2,zero,2029e0c <udp_input+0x41c>
 2029dc0:	008085f4 	movhi	r2,535
 2029dc4:	10be4204 	addi	r2,r2,-1784
 2029dc8:	10800517 	ldw	r2,20(r2)
 2029dcc:	10803c0c 	andi	r2,r2,240
 2029dd0:	10803820 	cmpeqi	r2,r2,224
 2029dd4:	10000d1e 	bne	r2,zero,2029e0c <udp_input+0x41c>
        /* move payload pointer back to ip header */
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 2029dd8:	008085f4 	movhi	r2,535
 2029ddc:	10be4204 	addi	r2,r2,-1784
 2029de0:	1080030b 	ldhu	r2,12(r2)
 2029de4:	10800204 	addi	r2,r2,8
 2029de8:	10bfffcc 	andi	r2,r2,65535
 2029dec:	10a0001c 	xori	r2,r2,32768
 2029df0:	10a00004 	addi	r2,r2,-32768
 2029df4:	100b883a 	mov	r5,r2
 2029df8:	e13ffe17 	ldw	r4,-8(fp)
 2029dfc:	201d1f40 	call	201d1f4 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 2029e00:	014000c4 	movi	r5,3
 2029e04:	e13ffe17 	ldw	r4,-8(fp)
 2029e08:	203b3380 	call	203b338 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP || LWIP_ICMP6 */
      UDP_STATS_INC(udp.proterr);
 2029e0c:	008085f4 	movhi	r2,535
 2029e10:	10bd8204 	addi	r2,r2,-2552
 2029e14:	10804417 	ldw	r2,272(r2)
 2029e18:	10c00044 	addi	r3,r2,1
 2029e1c:	008085f4 	movhi	r2,535
 2029e20:	10bd8204 	addi	r2,r2,-2552
 2029e24:	10c04415 	stw	r3,272(r2)
      UDP_STATS_INC(udp.drop);
 2029e28:	008085f4 	movhi	r2,535
 2029e2c:	10bd8204 	addi	r2,r2,-2552
 2029e30:	10803f17 	ldw	r2,252(r2)
 2029e34:	10c00044 	addi	r3,r2,1
 2029e38:	008085f4 	movhi	r2,535
 2029e3c:	10bd8204 	addi	r2,r2,-2552
 2029e40:	10c03f15 	stw	r3,252(r2)
      MIB2_STATS_INC(mib2.udpnoports);
      pbuf_free(p);
 2029e44:	e13ffe17 	ldw	r4,-8(fp)
 2029e48:	201d2f40 	call	201d2f4 <pbuf_free>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
 2029e4c:	00001506 	br	2029ea4 <udp_input+0x4b4>
      UDP_STATS_INC(udp.drop);
      MIB2_STATS_INC(mib2.udpnoports);
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
 2029e50:	e13ffe17 	ldw	r4,-8(fp)
 2029e54:	201d2f40 	call	201d2f4 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
  return;
 2029e58:	00001206 	br	2029ea4 <udp_input+0x4b4>
 2029e5c:	00001106 	br	2029ea4 <udp_input+0x4b4>
      {
        if (udphdr->chksum != 0) {
          if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
                               ip_current_src_addr(),
                               ip_current_dest_addr()) != 0) {
            goto chkerr;
 2029e60:	0001883a 	nop
  return;
#if CHECKSUM_CHECK_UDP
chkerr:
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
              ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
 2029e64:	008085f4 	movhi	r2,535
 2029e68:	10bd8204 	addi	r2,r2,-2552
 2029e6c:	10804017 	ldw	r2,256(r2)
 2029e70:	10c00044 	addi	r3,r2,1
 2029e74:	008085f4 	movhi	r2,535
 2029e78:	10bd8204 	addi	r2,r2,-2552
 2029e7c:	10c04015 	stw	r3,256(r2)
  UDP_STATS_INC(udp.drop);
 2029e80:	008085f4 	movhi	r2,535
 2029e84:	10bd8204 	addi	r2,r2,-2552
 2029e88:	10803f17 	ldw	r2,252(r2)
 2029e8c:	10c00044 	addi	r3,r2,1
 2029e90:	008085f4 	movhi	r2,535
 2029e94:	10bd8204 	addi	r2,r2,-2552
 2029e98:	10c03f15 	stw	r3,252(r2)
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
 2029e9c:	e13ffe17 	ldw	r4,-8(fp)
 2029ea0:	201d2f40 	call	201d2f4 <pbuf_free>
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 2029ea4:	e037883a 	mov	sp,fp
 2029ea8:	dfc00117 	ldw	ra,4(sp)
 2029eac:	df000017 	ldw	fp,0(sp)
 2029eb0:	dec00204 	addi	sp,sp,8
 2029eb4:	f800283a 	ret

02029eb8 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
 2029eb8:	defffc04 	addi	sp,sp,-16
 2029ebc:	dfc00315 	stw	ra,12(sp)
 2029ec0:	df000215 	stw	fp,8(sp)
 2029ec4:	df000204 	addi	fp,sp,8
 2029ec8:	e13ffe15 	stw	r4,-8(fp)
 2029ecc:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("udp_send: invalid pcb", pcb != NULL, return ERR_ARG);
 2029ed0:	e0bffe17 	ldw	r2,-8(fp)
 2029ed4:	1000021e 	bne	r2,zero,2029ee0 <udp_send+0x28>
 2029ed8:	00bffc04 	movi	r2,-16
 2029edc:	00000e06 	br	2029f18 <udp_send+0x60>
  LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 2029ee0:	e0bfff17 	ldw	r2,-4(fp)
 2029ee4:	1000021e 	bne	r2,zero,2029ef0 <udp_send+0x38>
 2029ee8:	00bffc04 	movi	r2,-16
 2029eec:	00000a06 	br	2029f18 <udp_send+0x60>
  if (IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
    return ERR_VAL;
  }

  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 2029ef0:	e0bffe17 	ldw	r2,-8(fp)
 2029ef4:	10c00104 	addi	r3,r2,4
 2029ef8:	e0bffe17 	ldw	r2,-8(fp)
 2029efc:	1080060b 	ldhu	r2,24(r2)
 2029f00:	10bfffcc 	andi	r2,r2,65535
 2029f04:	100f883a 	mov	r7,r2
 2029f08:	180d883a 	mov	r6,r3
 2029f0c:	e17fff17 	ldw	r5,-4(fp)
 2029f10:	e13ffe17 	ldw	r4,-8(fp)
 2029f14:	2029fc00 	call	2029fc0 <udp_sendto>
}
 2029f18:	e037883a 	mov	sp,fp
 2029f1c:	dfc00117 	ldw	ra,4(sp)
 2029f20:	df000017 	ldw	fp,0(sp)
 2029f24:	dec00204 	addi	sp,sp,8
 2029f28:	f800283a 	ret

02029f2c <udp_send_chksum>:
 * Same as udp_send() but with checksum
 */
err_t
udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
                u8_t have_chksum, u16_t chksum)
{
 2029f2c:	defff804 	addi	sp,sp,-32
 2029f30:	dfc00715 	stw	ra,28(sp)
 2029f34:	df000615 	stw	fp,24(sp)
 2029f38:	df000604 	addi	fp,sp,24
 2029f3c:	e13ffc15 	stw	r4,-16(fp)
 2029f40:	e17ffd15 	stw	r5,-12(fp)
 2029f44:	3007883a 	mov	r3,r6
 2029f48:	3805883a 	mov	r2,r7
 2029f4c:	e0fffe05 	stb	r3,-8(fp)
 2029f50:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("udp_send_chksum: invalid pcb", pcb != NULL, return ERR_ARG);
 2029f54:	e0bffc17 	ldw	r2,-16(fp)
 2029f58:	1000021e 	bne	r2,zero,2029f64 <udp_send_chksum+0x38>
 2029f5c:	00bffc04 	movi	r2,-16
 2029f60:	00001206 	br	2029fac <udp_send_chksum+0x80>
  LWIP_ERROR("udp_send_chksum: invalid pbuf", p != NULL, return ERR_ARG);
 2029f64:	e0bffd17 	ldw	r2,-12(fp)
 2029f68:	1000021e 	bne	r2,zero,2029f74 <udp_send_chksum+0x48>
 2029f6c:	00bffc04 	movi	r2,-16
 2029f70:	00000e06 	br	2029fac <udp_send_chksum+0x80>
  if (IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
    return ERR_VAL;
  }

  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
 2029f74:	e0bffc17 	ldw	r2,-16(fp)
 2029f78:	11000104 	addi	r4,r2,4
 2029f7c:	e0bffc17 	ldw	r2,-16(fp)
 2029f80:	1080060b 	ldhu	r2,24(r2)
 2029f84:	117fffcc 	andi	r5,r2,65535
 2029f88:	e0bffe03 	ldbu	r2,-8(fp)
 2029f8c:	e0ffff0b 	ldhu	r3,-4(fp)
 2029f90:	d8c00115 	stw	r3,4(sp)
 2029f94:	d8800015 	stw	r2,0(sp)
 2029f98:	280f883a 	mov	r7,r5
 2029f9c:	200d883a 	mov	r6,r4
 2029fa0:	e17ffd17 	ldw	r5,-12(fp)
 2029fa4:	e13ffc17 	ldw	r4,-16(fp)
 2029fa8:	202a0180 	call	202a018 <udp_sendto_chksum>
                           have_chksum, chksum);
}
 2029fac:	e037883a 	mov	sp,fp
 2029fb0:	dfc00117 	ldw	ra,4(sp)
 2029fb4:	df000017 	ldw	fp,0(sp)
 2029fb8:	dec00204 	addi	sp,sp,8
 2029fbc:	f800283a 	ret

02029fc0 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
           const ip_addr_t *dst_ip, u16_t dst_port)
{
 2029fc0:	defff804 	addi	sp,sp,-32
 2029fc4:	dfc00715 	stw	ra,28(sp)
 2029fc8:	df000615 	stw	fp,24(sp)
 2029fcc:	df000604 	addi	fp,sp,24
 2029fd0:	e13ffc15 	stw	r4,-16(fp)
 2029fd4:	e17ffd15 	stw	r5,-12(fp)
 2029fd8:	e1bffe15 	stw	r6,-8(fp)
 2029fdc:	3805883a 	mov	r2,r7
 2029fe0:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 2029fe4:	e0bfff0b 	ldhu	r2,-4(fp)
 2029fe8:	d8000115 	stw	zero,4(sp)
 2029fec:	d8000015 	stw	zero,0(sp)
 2029ff0:	100f883a 	mov	r7,r2
 2029ff4:	e1bffe17 	ldw	r6,-8(fp)
 2029ff8:	e17ffd17 	ldw	r5,-12(fp)
 2029ffc:	e13ffc17 	ldw	r4,-16(fp)
 202a000:	202a0180 	call	202a018 <udp_sendto_chksum>
}
 202a004:	e037883a 	mov	sp,fp
 202a008:	dfc00117 	ldw	ra,4(sp)
 202a00c:	df000017 	ldw	fp,0(sp)
 202a010:	dec00204 	addi	sp,sp,8
 202a014:	f800283a 	ret

0202a018 <udp_sendto_chksum>:
/** @ingroup udp_raw
 * Same as udp_sendto(), but with checksum */
err_t
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
 202a018:	defff404 	addi	sp,sp,-48
 202a01c:	dfc00b15 	stw	ra,44(sp)
 202a020:	df000a15 	stw	fp,40(sp)
 202a024:	df000a04 	addi	fp,sp,40
 202a028:	e13ffa15 	stw	r4,-24(fp)
 202a02c:	e17ffb15 	stw	r5,-20(fp)
 202a030:	e1bffc15 	stw	r6,-16(fp)
 202a034:	3809883a 	mov	r4,r7
 202a038:	e0c00217 	ldw	r3,8(fp)
 202a03c:	e0800317 	ldw	r2,12(fp)
 202a040:	e13ffd0d 	sth	r4,-12(fp)
 202a044:	e0fffe05 	stb	r3,-8(fp)
 202a048:	e0bfff0d 	sth	r2,-4(fp)
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  struct netif *netif;

  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 202a04c:	e0bffa17 	ldw	r2,-24(fp)
 202a050:	1000021e 	bne	r2,zero,202a05c <udp_sendto_chksum+0x44>
 202a054:	00bffc04 	movi	r2,-16
 202a058:	00002d06 	br	202a110 <udp_sendto_chksum+0xf8>
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 202a05c:	e0bffb17 	ldw	r2,-20(fp)
 202a060:	1000021e 	bne	r2,zero,202a06c <udp_sendto_chksum+0x54>
 202a064:	00bffc04 	movi	r2,-16
 202a068:	00002906 	br	202a110 <udp_sendto_chksum+0xf8>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 202a06c:	e0bffc17 	ldw	r2,-16(fp)
 202a070:	1000021e 	bne	r2,zero,202a07c <udp_sendto_chksum+0x64>
 202a074:	00bffc04 	movi	r2,-16
 202a078:	00002506 	br	202a110 <udp_sendto_chksum+0xf8>
    return ERR_VAL;
  }

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 202a07c:	e0bffa17 	ldw	r2,-24(fp)
 202a080:	10800203 	ldbu	r2,8(r2)
 202a084:	10803fcc 	andi	r2,r2,255
 202a088:	10000726 	beq	r2,zero,202a0a8 <udp_sendto_chksum+0x90>
    netif = netif_get_by_index(pcb->netif_idx);
 202a08c:	e0bffa17 	ldw	r2,-24(fp)
 202a090:	10800203 	ldbu	r2,8(r2)
 202a094:	10803fcc 	andi	r2,r2,255
 202a098:	1009883a 	mov	r4,r2
 202a09c:	201c62c0 	call	201c62c <netif_get_by_index>
 202a0a0:	e0bff915 	stw	r2,-28(fp)
 202a0a4:	00000306 	br	202a0b4 <udp_sendto_chksum+0x9c>

    if (netif == NULL)
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    {
      /* find the outgoing network interface for this packet */
      netif = ip_route(&pcb->local_ip, dst_ip);
 202a0a8:	e13ffc17 	ldw	r4,-16(fp)
 202a0ac:	203b5c40 	call	203b5c4 <ip4_route>
 202a0b0:	e0bff915 	stw	r2,-28(fp)
    }
  }

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 202a0b4:	e0bff917 	ldw	r2,-28(fp)
 202a0b8:	1000091e 	bne	r2,zero,202a0e0 <udp_sendto_chksum+0xc8>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
    ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
    LWIP_DEBUGF(UDP_DEBUG, ("\n"));
    UDP_STATS_INC(udp.rterr);
 202a0bc:	008085f4 	movhi	r2,535
 202a0c0:	10bd8204 	addi	r2,r2,-2552
 202a0c4:	10804317 	ldw	r2,268(r2)
 202a0c8:	10c00044 	addi	r3,r2,1
 202a0cc:	008085f4 	movhi	r2,535
 202a0d0:	10bd8204 	addi	r2,r2,-2552
 202a0d4:	10c04315 	stw	r3,268(r2)
    return ERR_RTE;
 202a0d8:	00bfff04 	movi	r2,-4
 202a0dc:	00000c06 	br	202a110 <udp_sendto_chksum+0xf8>
  }
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 202a0e0:	e13ffd0b 	ldhu	r4,-12(fp)
 202a0e4:	e0bffe03 	ldbu	r2,-8(fp)
 202a0e8:	e0ffff0b 	ldhu	r3,-4(fp)
 202a0ec:	d8c00215 	stw	r3,8(sp)
 202a0f0:	d8800115 	stw	r2,4(sp)
 202a0f4:	e0bff917 	ldw	r2,-28(fp)
 202a0f8:	d8800015 	stw	r2,0(sp)
 202a0fc:	200f883a 	mov	r7,r4
 202a100:	e1bffc17 	ldw	r6,-16(fp)
 202a104:	e17ffb17 	ldw	r5,-20(fp)
 202a108:	e13ffa17 	ldw	r4,-24(fp)
 202a10c:	202a1840 	call	202a184 <udp_sendto_if_chksum>
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 202a110:	e037883a 	mov	sp,fp
 202a114:	dfc00117 	ldw	ra,4(sp)
 202a118:	df000017 	ldw	fp,0(sp)
 202a11c:	dec00204 	addi	sp,sp,8
 202a120:	f800283a 	ret

0202a124 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
              const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 202a124:	defff704 	addi	sp,sp,-36
 202a128:	dfc00815 	stw	ra,32(sp)
 202a12c:	df000715 	stw	fp,28(sp)
 202a130:	df000704 	addi	fp,sp,28
 202a134:	e13ffc15 	stw	r4,-16(fp)
 202a138:	e17ffd15 	stw	r5,-12(fp)
 202a13c:	e1bffe15 	stw	r6,-8(fp)
 202a140:	3805883a 	mov	r2,r7
 202a144:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
 202a148:	e0ffff0b 	ldhu	r3,-4(fp)
 202a14c:	d8000215 	stw	zero,8(sp)
 202a150:	d8000115 	stw	zero,4(sp)
 202a154:	e0800217 	ldw	r2,8(fp)
 202a158:	d8800015 	stw	r2,0(sp)
 202a15c:	180f883a 	mov	r7,r3
 202a160:	e1bffe17 	ldw	r6,-8(fp)
 202a164:	e17ffd17 	ldw	r5,-12(fp)
 202a168:	e13ffc17 	ldw	r4,-16(fp)
 202a16c:	202a1840 	call	202a184 <udp_sendto_if_chksum>
}
 202a170:	e037883a 	mov	sp,fp
 202a174:	dfc00117 	ldw	ra,4(sp)
 202a178:	df000017 	ldw	fp,0(sp)
 202a17c:	dec00204 	addi	sp,sp,8
 202a180:	f800283a 	ret

0202a184 <udp_sendto_if_chksum>:
/** Same as udp_sendto_if(), but with checksum */
err_t
udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                     u16_t dst_port, struct netif *netif, u8_t have_chksum,
                     u16_t chksum)
{
 202a184:	defff304 	addi	sp,sp,-52
 202a188:	dfc00c15 	stw	ra,48(sp)
 202a18c:	df000b15 	stw	fp,44(sp)
 202a190:	df000b04 	addi	fp,sp,44
 202a194:	e13ffa15 	stw	r4,-24(fp)
 202a198:	e17ffb15 	stw	r5,-20(fp)
 202a19c:	e1bffc15 	stw	r6,-16(fp)
 202a1a0:	3809883a 	mov	r4,r7
 202a1a4:	e0c00317 	ldw	r3,12(fp)
 202a1a8:	e0800417 	ldw	r2,16(fp)
 202a1ac:	e13ffd0d 	sth	r4,-12(fp)
 202a1b0:	e0fffe05 	stb	r3,-8(fp)
 202a1b4:	e0bfff0d 	sth	r2,-4(fp)
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  const ip_addr_t *src_ip;

  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 202a1b8:	e0bffa17 	ldw	r2,-24(fp)
 202a1bc:	1000021e 	bne	r2,zero,202a1c8 <udp_sendto_if_chksum+0x44>
 202a1c0:	00bffc04 	movi	r2,-16
 202a1c4:	00003206 	br	202a290 <udp_sendto_if_chksum+0x10c>
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 202a1c8:	e0bffb17 	ldw	r2,-20(fp)
 202a1cc:	1000021e 	bne	r2,zero,202a1d8 <udp_sendto_if_chksum+0x54>
 202a1d0:	00bffc04 	movi	r2,-16
 202a1d4:	00002e06 	br	202a290 <udp_sendto_if_chksum+0x10c>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 202a1d8:	e0bffc17 	ldw	r2,-16(fp)
 202a1dc:	1000021e 	bne	r2,zero,202a1e8 <udp_sendto_if_chksum+0x64>
 202a1e0:	00bffc04 	movi	r2,-16
 202a1e4:	00002a06 	br	202a290 <udp_sendto_if_chksum+0x10c>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 202a1e8:	e0800217 	ldw	r2,8(fp)
 202a1ec:	1000021e 	bne	r2,zero,202a1f8 <udp_sendto_if_chksum+0x74>
 202a1f0:	00bffc04 	movi	r2,-16
 202a1f4:	00002606 	br	202a290 <udp_sendto_if_chksum+0x10c>
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 202a1f8:	e0bffa17 	ldw	r2,-24(fp)
 202a1fc:	10000826 	beq	r2,zero,202a220 <udp_sendto_if_chksum+0x9c>
 202a200:	e0bffa17 	ldw	r2,-24(fp)
 202a204:	10800017 	ldw	r2,0(r2)
 202a208:	10000526 	beq	r2,zero,202a220 <udp_sendto_if_chksum+0x9c>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 202a20c:	e0bffa17 	ldw	r2,-24(fp)
 202a210:	10800017 	ldw	r2,0(r2)
 202a214:	10803c0c 	andi	r2,r2,240
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 202a218:	10803818 	cmpnei	r2,r2,224
 202a21c:	1000041e 	bne	r2,zero,202a230 <udp_sendto_if_chksum+0xac>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
      /* if the local_ip is any or multicast
       * use the outgoing network interface IP address as source address */
      src_ip = netif_ip_addr4(netif);
 202a220:	e0800217 	ldw	r2,8(fp)
 202a224:	10800104 	addi	r2,r2,4
 202a228:	e0bff915 	stw	r2,-28(fp)
 202a22c:	00000a06 	br	202a258 <udp_sendto_if_chksum+0xd4>
    } else {
      /* check if UDP PCB local IP address is correct
       * this could be an old address if netif->ip_addr has changed */
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 202a230:	e0bffa17 	ldw	r2,-24(fp)
 202a234:	10c00017 	ldw	r3,0(r2)
 202a238:	e0800217 	ldw	r2,8(fp)
 202a23c:	10800104 	addi	r2,r2,4
 202a240:	10800017 	ldw	r2,0(r2)
 202a244:	18800226 	beq	r3,r2,202a250 <udp_sendto_if_chksum+0xcc>
        /* local_ip doesn't match, drop the packet */
        return ERR_RTE;
 202a248:	00bfff04 	movi	r2,-4
 202a24c:	00001006 	br	202a290 <udp_sendto_if_chksum+0x10c>
      }
      /* use UDP PCB local IP address as source address */
      src_ip = &pcb->local_ip;
 202a250:	e0bffa17 	ldw	r2,-24(fp)
 202a254:	e0bff915 	stw	r2,-28(fp)
    }
#endif /* LWIP_IPV4 */
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
 202a258:	e17ffd0b 	ldhu	r5,-12(fp)
 202a25c:	e0bffe03 	ldbu	r2,-8(fp)
 202a260:	e0ffff0b 	ldhu	r3,-4(fp)
 202a264:	e13ff917 	ldw	r4,-28(fp)
 202a268:	d9000315 	stw	r4,12(sp)
 202a26c:	d8c00215 	stw	r3,8(sp)
 202a270:	d8800115 	stw	r2,4(sp)
 202a274:	e0800217 	ldw	r2,8(fp)
 202a278:	d8800015 	stw	r2,0(sp)
 202a27c:	280f883a 	mov	r7,r5
 202a280:	e1bffc17 	ldw	r6,-16(fp)
 202a284:	e17ffb17 	ldw	r5,-20(fp)
 202a288:	e13ffa17 	ldw	r4,-24(fp)
 202a28c:	202a30c0 	call	202a30c <udp_sendto_if_src_chksum>
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 202a290:	e037883a 	mov	sp,fp
 202a294:	dfc00117 	ldw	ra,4(sp)
 202a298:	df000017 	ldw	fp,0(sp)
 202a29c:	dec00204 	addi	sp,sp,8
 202a2a0:	f800283a 	ret

0202a2a4 <udp_sendto_if_src>:
/** @ingroup udp_raw
 * Same as @ref udp_sendto_if, but with source address */
err_t
udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
                  const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *src_ip)
{
 202a2a4:	defff604 	addi	sp,sp,-40
 202a2a8:	dfc00915 	stw	ra,36(sp)
 202a2ac:	df000815 	stw	fp,32(sp)
 202a2b0:	df000804 	addi	fp,sp,32
 202a2b4:	e13ffc15 	stw	r4,-16(fp)
 202a2b8:	e17ffd15 	stw	r5,-12(fp)
 202a2bc:	e1bffe15 	stw	r6,-8(fp)
 202a2c0:	3805883a 	mov	r2,r7
 202a2c4:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0, src_ip);
 202a2c8:	e0ffff0b 	ldhu	r3,-4(fp)
 202a2cc:	e0800317 	ldw	r2,12(fp)
 202a2d0:	d8800315 	stw	r2,12(sp)
 202a2d4:	d8000215 	stw	zero,8(sp)
 202a2d8:	d8000115 	stw	zero,4(sp)
 202a2dc:	e0800217 	ldw	r2,8(fp)
 202a2e0:	d8800015 	stw	r2,0(sp)
 202a2e4:	180f883a 	mov	r7,r3
 202a2e8:	e1bffe17 	ldw	r6,-8(fp)
 202a2ec:	e17ffd17 	ldw	r5,-12(fp)
 202a2f0:	e13ffc17 	ldw	r4,-16(fp)
 202a2f4:	202a30c0 	call	202a30c <udp_sendto_if_src_chksum>
}
 202a2f8:	e037883a 	mov	sp,fp
 202a2fc:	dfc00117 	ldw	ra,4(sp)
 202a300:	df000017 	ldw	fp,0(sp)
 202a304:	dec00204 	addi	sp,sp,8
 202a308:	f800283a 	ret

0202a30c <udp_sendto_if_src_chksum>:
/** Same as udp_sendto_if_src(), but with checksum */
err_t
udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
                         u16_t chksum, const ip_addr_t *src_ip)
{
 202a30c:	defff004 	addi	sp,sp,-64
 202a310:	dfc00f15 	stw	ra,60(sp)
 202a314:	df000e15 	stw	fp,56(sp)
 202a318:	df000e04 	addi	fp,sp,56
 202a31c:	e13ffa15 	stw	r4,-24(fp)
 202a320:	e17ffb15 	stw	r5,-20(fp)
 202a324:	e1bffc15 	stw	r6,-16(fp)
 202a328:	3809883a 	mov	r4,r7
 202a32c:	e0c00317 	ldw	r3,12(fp)
 202a330:	e0800417 	ldw	r2,16(fp)
 202a334:	e13ffd0d 	sth	r4,-12(fp)
 202a338:	e0fffe05 	stb	r3,-8(fp)
 202a33c:	e0bfff0d 	sth	r2,-4(fp)
  u8_t ip_proto;
  u8_t ttl;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 202a340:	e0bffa17 	ldw	r2,-24(fp)
 202a344:	1000021e 	bne	r2,zero,202a350 <udp_sendto_if_src_chksum+0x44>
 202a348:	00bffc04 	movi	r2,-16
 202a34c:	0000fe06 	br	202a748 <udp_sendto_if_src_chksum+0x43c>
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 202a350:	e0bffb17 	ldw	r2,-20(fp)
 202a354:	1000021e 	bne	r2,zero,202a360 <udp_sendto_if_src_chksum+0x54>
 202a358:	00bffc04 	movi	r2,-16
 202a35c:	0000fa06 	br	202a748 <udp_sendto_if_src_chksum+0x43c>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 202a360:	e0bffc17 	ldw	r2,-16(fp)
 202a364:	1000021e 	bne	r2,zero,202a370 <udp_sendto_if_src_chksum+0x64>
 202a368:	00bffc04 	movi	r2,-16
 202a36c:	0000f606 	br	202a748 <udp_sendto_if_src_chksum+0x43c>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 202a370:	e0800517 	ldw	r2,20(fp)
 202a374:	1000021e 	bne	r2,zero,202a380 <udp_sendto_if_src_chksum+0x74>
 202a378:	00bffc04 	movi	r2,-16
 202a37c:	0000f206 	br	202a748 <udp_sendto_if_src_chksum+0x43c>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 202a380:	e0800217 	ldw	r2,8(fp)
 202a384:	1000021e 	bne	r2,zero,202a390 <udp_sendto_if_src_chksum+0x84>
 202a388:	00bffc04 	movi	r2,-16
 202a38c:	0000ee06 	br	202a748 <udp_sendto_if_src_chksum+0x43c>
    return ERR_VAL;
  }
#endif /* LWIP_IPV4 && IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 202a390:	e0bffa17 	ldw	r2,-24(fp)
 202a394:	1080058b 	ldhu	r2,22(r2)
 202a398:	10bfffcc 	andi	r2,r2,65535
 202a39c:	10000d1e 	bne	r2,zero,202a3d4 <udp_sendto_if_src_chksum+0xc8>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 202a3a0:	e0fffa17 	ldw	r3,-24(fp)
 202a3a4:	e0bffa17 	ldw	r2,-24(fp)
 202a3a8:	1080058b 	ldhu	r2,22(r2)
 202a3ac:	10bfffcc 	andi	r2,r2,65535
 202a3b0:	100d883a 	mov	r6,r2
 202a3b4:	180b883a 	mov	r5,r3
 202a3b8:	e13ffa17 	ldw	r4,-24(fp)
 202a3bc:	202a75c0 	call	202a75c <udp_bind>
 202a3c0:	e0bff685 	stb	r2,-38(fp)
    if (err != ERR_OK) {
 202a3c4:	e0bff687 	ldb	r2,-38(fp)
 202a3c8:	10000226 	beq	r2,zero,202a3d4 <udp_sendto_if_src_chksum+0xc8>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 202a3cc:	e0bff683 	ldbu	r2,-38(fp)
 202a3d0:	0000dd06 	br	202a748 <udp_sendto_if_src_chksum+0x43c>
    }
  }

  /* packet too large to add a UDP header without causing an overflow? */
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 202a3d4:	e0bffb17 	ldw	r2,-20(fp)
 202a3d8:	1080020b 	ldhu	r2,8(r2)
 202a3dc:	10800204 	addi	r2,r2,8
 202a3e0:	1007883a 	mov	r3,r2
 202a3e4:	e0bffb17 	ldw	r2,-20(fp)
 202a3e8:	1080020b 	ldhu	r2,8(r2)
 202a3ec:	18ffffcc 	andi	r3,r3,65535
 202a3f0:	10bfffcc 	andi	r2,r2,65535
 202a3f4:	1880022e 	bgeu	r3,r2,202a400 <udp_sendto_if_src_chksum+0xf4>
    return ERR_MEM;
 202a3f8:	00bfffc4 	movi	r2,-1
 202a3fc:	0000d206 	br	202a748 <udp_sendto_if_src_chksum+0x43c>
  }
  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_add_header(p, UDP_HLEN)) {
 202a400:	01400204 	movi	r5,8
 202a404:	e13ffb17 	ldw	r4,-20(fp)
 202a408:	201cff40 	call	201cff4 <pbuf_add_header>
 202a40c:	10803fcc 	andi	r2,r2,255
 202a410:	10001126 	beq	r2,zero,202a458 <udp_sendto_if_src_chksum+0x14c>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 202a414:	0180a004 	movi	r6,640
 202a418:	01400204 	movi	r5,8
 202a41c:	01000904 	movi	r4,36
 202a420:	201c9740 	call	201c974 <pbuf_alloc>
 202a424:	e0bff515 	stw	r2,-44(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 202a428:	e0bff517 	ldw	r2,-44(fp)
 202a42c:	1000021e 	bne	r2,zero,202a438 <udp_sendto_if_src_chksum+0x12c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 202a430:	00bfffc4 	movi	r2,-1
 202a434:	0000c406 	br	202a748 <udp_sendto_if_src_chksum+0x43c>
    }
    if (p->tot_len != 0) {
 202a438:	e0bffb17 	ldw	r2,-20(fp)
 202a43c:	1080020b 	ldhu	r2,8(r2)
 202a440:	10bfffcc 	andi	r2,r2,65535
 202a444:	10000626 	beq	r2,zero,202a460 <udp_sendto_if_src_chksum+0x154>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 202a448:	e17ffb17 	ldw	r5,-20(fp)
 202a44c:	e13ff517 	ldw	r4,-44(fp)
 202a450:	201d5800 	call	201d580 <pbuf_chain>
 202a454:	00000206 	br	202a460 <udp_sendto_if_src_chksum+0x154>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 202a458:	e0bffb17 	ldw	r2,-20(fp)
 202a45c:	e0bff515 	stw	r2,-44(fp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 202a460:	e0bff517 	ldw	r2,-44(fp)
 202a464:	10800117 	ldw	r2,4(r2)
 202a468:	e0bff715 	stw	r2,-36(fp)
  udphdr->src = lwip_htons(pcb->local_port);
 202a46c:	e0bffa17 	ldw	r2,-24(fp)
 202a470:	1080058b 	ldhu	r2,22(r2)
 202a474:	10bfffcc 	andi	r2,r2,65535
 202a478:	1009883a 	mov	r4,r2
 202a47c:	20394740 	call	2039474 <lwip_htons>
 202a480:	100d883a 	mov	r6,r2
 202a484:	e0bff717 	ldw	r2,-36(fp)
 202a488:	30ffffcc 	andi	r3,r6,65535
 202a48c:	19403fcc 	andi	r5,r3,255
 202a490:	10c00003 	ldbu	r3,0(r2)
 202a494:	1806703a 	and	r3,r3,zero
 202a498:	1809883a 	mov	r4,r3
 202a49c:	2807883a 	mov	r3,r5
 202a4a0:	20c6b03a 	or	r3,r4,r3
 202a4a4:	10c00005 	stb	r3,0(r2)
 202a4a8:	30ffffcc 	andi	r3,r6,65535
 202a4ac:	1806d23a 	srli	r3,r3,8
 202a4b0:	197fffcc 	andi	r5,r3,65535
 202a4b4:	10c00043 	ldbu	r3,1(r2)
 202a4b8:	1806703a 	and	r3,r3,zero
 202a4bc:	1809883a 	mov	r4,r3
 202a4c0:	2807883a 	mov	r3,r5
 202a4c4:	20c6b03a 	or	r3,r4,r3
 202a4c8:	10c00045 	stb	r3,1(r2)
  udphdr->dest = lwip_htons(dst_port);
 202a4cc:	e0bffd0b 	ldhu	r2,-12(fp)
 202a4d0:	1009883a 	mov	r4,r2
 202a4d4:	20394740 	call	2039474 <lwip_htons>
 202a4d8:	100d883a 	mov	r6,r2
 202a4dc:	e0bff717 	ldw	r2,-36(fp)
 202a4e0:	30ffffcc 	andi	r3,r6,65535
 202a4e4:	19403fcc 	andi	r5,r3,255
 202a4e8:	10c00083 	ldbu	r3,2(r2)
 202a4ec:	1806703a 	and	r3,r3,zero
 202a4f0:	1809883a 	mov	r4,r3
 202a4f4:	2807883a 	mov	r3,r5
 202a4f8:	20c6b03a 	or	r3,r4,r3
 202a4fc:	10c00085 	stb	r3,2(r2)
 202a500:	30ffffcc 	andi	r3,r6,65535
 202a504:	1806d23a 	srli	r3,r3,8
 202a508:	197fffcc 	andi	r5,r3,65535
 202a50c:	10c000c3 	ldbu	r3,3(r2)
 202a510:	1806703a 	and	r3,r3,zero
 202a514:	1809883a 	mov	r4,r3
 202a518:	2807883a 	mov	r3,r5
 202a51c:	20c6b03a 	or	r3,r4,r3
 202a520:	10c000c5 	stb	r3,3(r2)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000;
 202a524:	e0bff717 	ldw	r2,-36(fp)
 202a528:	10c00183 	ldbu	r3,6(r2)
 202a52c:	1806703a 	and	r3,r3,zero
 202a530:	10c00185 	stb	r3,6(r2)
 202a534:	10c001c3 	ldbu	r3,7(r2)
 202a538:	1806703a 	and	r3,r3,zero
 202a53c:	10c001c5 	stb	r3,7(r2)
    ip_proto = IP_PROTO_UDPLITE;
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = lwip_htons(q->tot_len);
 202a540:	e0bff517 	ldw	r2,-44(fp)
 202a544:	1080020b 	ldhu	r2,8(r2)
 202a548:	10bfffcc 	andi	r2,r2,65535
 202a54c:	1009883a 	mov	r4,r2
 202a550:	20394740 	call	2039474 <lwip_htons>
 202a554:	100d883a 	mov	r6,r2
 202a558:	e0bff717 	ldw	r2,-36(fp)
 202a55c:	30ffffcc 	andi	r3,r6,65535
 202a560:	19403fcc 	andi	r5,r3,255
 202a564:	10c00103 	ldbu	r3,4(r2)
 202a568:	1806703a 	and	r3,r3,zero
 202a56c:	1809883a 	mov	r4,r3
 202a570:	2807883a 	mov	r3,r5
 202a574:	20c6b03a 	or	r3,r4,r3
 202a578:	10c00105 	stb	r3,4(r2)
 202a57c:	30ffffcc 	andi	r3,r6,65535
 202a580:	1806d23a 	srli	r3,r3,8
 202a584:	197fffcc 	andi	r5,r3,65535
 202a588:	10c00143 	ldbu	r3,5(r2)
 202a58c:	1806703a 	and	r3,r3,zero
 202a590:	1809883a 	mov	r4,r3
 202a594:	2807883a 	mov	r3,r5
 202a598:	20c6b03a 	or	r3,r4,r3
 202a59c:	10c00145 	stb	r3,5(r2)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
      /* Checksum is mandatory over IPv6. */
      if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 202a5a0:	e0bffa17 	ldw	r2,-24(fp)
 202a5a4:	10800503 	ldbu	r2,20(r2)
 202a5a8:	10803fcc 	andi	r2,r2,255
 202a5ac:	1080004c 	andi	r2,r2,1
 202a5b0:	10003d1e 	bne	r2,zero,202a6a8 <udp_sendto_if_src_chksum+0x39c>
        u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
        if (have_chksum) {
 202a5b4:	e0bffe03 	ldbu	r2,-8(fp)
 202a5b8:	10001a26 	beq	r2,zero,202a624 <udp_sendto_if_src_chksum+0x318>
          u32_t acc;
          udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
                                               q->tot_len, UDP_HLEN, src_ip, dst_ip);
 202a5bc:	e0bff517 	ldw	r2,-44(fp)
 202a5c0:	1080020b 	ldhu	r2,8(r2)
      if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
        u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
        if (have_chksum) {
          u32_t acc;
          udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
 202a5c4:	10ffffcc 	andi	r3,r2,65535
 202a5c8:	e0bffc17 	ldw	r2,-16(fp)
 202a5cc:	d8800115 	stw	r2,4(sp)
 202a5d0:	e0800517 	ldw	r2,20(fp)
 202a5d4:	d8800015 	stw	r2,0(sp)
 202a5d8:	01c00204 	movi	r7,8
 202a5dc:	180d883a 	mov	r6,r3
 202a5e0:	01400444 	movi	r5,17
 202a5e4:	e13ff517 	ldw	r4,-44(fp)
 202a5e8:	203a1540 	call	203a154 <ip_chksum_pseudo_partial>
 202a5ec:	e0bff60d 	sth	r2,-40(fp)
                                               q->tot_len, UDP_HLEN, src_ip, dst_ip);
          acc = udpchksum + (u16_t)~(chksum);
 202a5f0:	e0fff60b 	ldhu	r3,-40(fp)
 202a5f4:	e0bfff0b 	ldhu	r2,-4(fp)
 202a5f8:	0084303a 	nor	r2,zero,r2
 202a5fc:	10bfffcc 	andi	r2,r2,65535
 202a600:	1885883a 	add	r2,r3,r2
 202a604:	e0bff815 	stw	r2,-32(fp)
          udpchksum = FOLD_U32T(acc);
 202a608:	e0bff817 	ldw	r2,-32(fp)
 202a60c:	1004d43a 	srli	r2,r2,16
 202a610:	1007883a 	mov	r3,r2
 202a614:	e0bff817 	ldw	r2,-32(fp)
 202a618:	1885883a 	add	r2,r3,r2
 202a61c:	e0bff60d 	sth	r2,-40(fp)
 202a620:	00000b06 	br	202a650 <udp_sendto_if_src_chksum+0x344>
        } else
#endif /* LWIP_CHECKSUM_ON_COPY */
        {
          udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
 202a624:	e0bff517 	ldw	r2,-44(fp)
 202a628:	1080020b 	ldhu	r2,8(r2)
 202a62c:	10ffffcc 	andi	r3,r2,65535
 202a630:	e0bffc17 	ldw	r2,-16(fp)
 202a634:	d8800015 	stw	r2,0(sp)
 202a638:	e1c00517 	ldw	r7,20(fp)
 202a63c:	180d883a 	mov	r6,r3
 202a640:	01400444 	movi	r5,17
 202a644:	e13ff517 	ldw	r4,-44(fp)
 202a648:	2039e440 	call	2039e44 <ip_chksum_pseudo>
 202a64c:	e0bff60d 	sth	r2,-40(fp)
                                       src_ip, dst_ip);
        }

        /* chksum zero must become 0xffff, as zero means 'no checksum' */
        if (udpchksum == 0x0000) {
 202a650:	e0bff60b 	ldhu	r2,-40(fp)
 202a654:	1000021e 	bne	r2,zero,202a660 <udp_sendto_if_src_chksum+0x354>
          udpchksum = 0xffff;
 202a658:	00bfffc4 	movi	r2,-1
 202a65c:	e0bff60d 	sth	r2,-40(fp)
        }
        udphdr->chksum = udpchksum;
 202a660:	e0bff717 	ldw	r2,-36(fp)
 202a664:	e0fff60b 	ldhu	r3,-40(fp)
 202a668:	19403fcc 	andi	r5,r3,255
 202a66c:	10c00183 	ldbu	r3,6(r2)
 202a670:	1806703a 	and	r3,r3,zero
 202a674:	1809883a 	mov	r4,r3
 202a678:	2807883a 	mov	r3,r5
 202a67c:	20c6b03a 	or	r3,r4,r3
 202a680:	10c00185 	stb	r3,6(r2)
 202a684:	e0fff60b 	ldhu	r3,-40(fp)
 202a688:	1806d23a 	srli	r3,r3,8
 202a68c:	197fffcc 	andi	r5,r3,65535
 202a690:	10c001c3 	ldbu	r3,7(r2)
 202a694:	1806703a 	and	r3,r3,zero
 202a698:	1809883a 	mov	r4,r3
 202a69c:	2807883a 	mov	r3,r5
 202a6a0:	20c6b03a 	or	r3,r4,r3
 202a6a4:	10c001c5 	stb	r3,7(r2)
      }
    }
#endif /* CHECKSUM_GEN_UDP */
    ip_proto = IP_PROTO_UDP;
 202a6a8:	00800444 	movi	r2,17
 202a6ac:	e0bff905 	stb	r2,-28(fp)

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
#else /* LWIP_MULTICAST_TX_OPTIONS */
  ttl = pcb->ttl;
 202a6b0:	e0bffa17 	ldw	r2,-24(fp)
 202a6b4:	108002c3 	ldbu	r2,11(r2)
 202a6b8:	e0bff945 	stb	r2,-27(fp)
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
  /* output to IP */
  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 202a6bc:	e0bffa17 	ldw	r2,-24(fp)
 202a6c0:	10c00304 	addi	r3,r2,12
 202a6c4:	e0800217 	ldw	r2,8(fp)
 202a6c8:	10c01215 	stw	r3,72(r2)
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 202a6cc:	e17ff943 	ldbu	r5,-27(fp)
 202a6d0:	e0bffa17 	ldw	r2,-24(fp)
 202a6d4:	10800283 	ldbu	r2,10(r2)
 202a6d8:	10803fcc 	andi	r2,r2,255
 202a6dc:	e0fff903 	ldbu	r3,-28(fp)
 202a6e0:	e1000217 	ldw	r4,8(fp)
 202a6e4:	d9000215 	stw	r4,8(sp)
 202a6e8:	d8c00115 	stw	r3,4(sp)
 202a6ec:	d8800015 	stw	r2,0(sp)
 202a6f0:	280f883a 	mov	r7,r5
 202a6f4:	e1bffc17 	ldw	r6,-16(fp)
 202a6f8:	e1400517 	ldw	r5,20(fp)
 202a6fc:	e13ff517 	ldw	r4,-44(fp)
 202a700:	203bec40 	call	203bec4 <ip4_output_if_src>
 202a704:	e0bff685 	stb	r2,-38(fp)
  NETIF_RESET_HINTS(netif);
 202a708:	e0800217 	ldw	r2,8(fp)
 202a70c:	10001215 	stw	zero,72(r2)

  /* @todo: must this be increased even if error occurred? */
  MIB2_STATS_INC(mib2.udpoutdatagrams);

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 202a710:	e0fff517 	ldw	r3,-44(fp)
 202a714:	e0bffb17 	ldw	r2,-20(fp)
 202a718:	18800326 	beq	r3,r2,202a728 <udp_sendto_if_src_chksum+0x41c>
    /* free the header pbuf */
    pbuf_free(q);
 202a71c:	e13ff517 	ldw	r4,-44(fp)
 202a720:	201d2f40 	call	201d2f4 <pbuf_free>
    q = NULL;
 202a724:	e03ff515 	stw	zero,-44(fp)
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
 202a728:	008085f4 	movhi	r2,535
 202a72c:	10bd8204 	addi	r2,r2,-2552
 202a730:	10803c17 	ldw	r2,240(r2)
 202a734:	10c00044 	addi	r3,r2,1
 202a738:	008085f4 	movhi	r2,535
 202a73c:	10bd8204 	addi	r2,r2,-2552
 202a740:	10c03c15 	stw	r3,240(r2)
  return err;
 202a744:	e0bff683 	ldbu	r2,-38(fp)
}
 202a748:	e037883a 	mov	sp,fp
 202a74c:	dfc00117 	ldw	ra,4(sp)
 202a750:	df000017 	ldw	fp,0(sp)
 202a754:	dec00204 	addi	sp,sp,8
 202a758:	f800283a 	ret

0202a75c <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 202a75c:	defff904 	addi	sp,sp,-28
 202a760:	dfc00615 	stw	ra,24(sp)
 202a764:	df000515 	stw	fp,20(sp)
 202a768:	df000504 	addi	fp,sp,20
 202a76c:	e13ffd15 	stw	r4,-12(fp)
 202a770:	e17ffe15 	stw	r5,-8(fp)
 202a774:	3005883a 	mov	r2,r6
 202a778:	e0bfff0d 	sth	r2,-4(fp)

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 202a77c:	e0bffe17 	ldw	r2,-8(fp)
 202a780:	1000021e 	bne	r2,zero,202a78c <udp_bind+0x30>
    ipaddr = IP4_ADDR_ANY;
 202a784:	d0a00e04 	addi	r2,gp,-32712
 202a788:	e0bffe15 	stw	r2,-8(fp)
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 202a78c:	e0bffd17 	ldw	r2,-12(fp)
 202a790:	1000021e 	bne	r2,zero,202a79c <udp_bind+0x40>
 202a794:	00bffc04 	movi	r2,-16
 202a798:	00005506 	br	202a8f0 <udp_bind+0x194>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 202a79c:	e03ffc05 	stb	zero,-16(fp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 202a7a0:	d0a7f317 	ldw	r2,-24628(gp)
 202a7a4:	e0bffb15 	stw	r2,-20(fp)
 202a7a8:	00000906 	br	202a7d0 <udp_bind+0x74>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 202a7ac:	e0fffd17 	ldw	r3,-12(fp)
 202a7b0:	e0bffb17 	ldw	r2,-20(fp)
 202a7b4:	1880031e 	bne	r3,r2,202a7c4 <udp_bind+0x68>
      rebind = 1;
 202a7b8:	00800044 	movi	r2,1
 202a7bc:	e0bffc05 	stb	r2,-16(fp)
      break;
 202a7c0:	00000506 	br	202a7d8 <udp_bind+0x7c>
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 202a7c4:	e0bffb17 	ldw	r2,-20(fp)
 202a7c8:	10800417 	ldw	r2,16(r2)
 202a7cc:	e0bffb15 	stw	r2,-20(fp)
 202a7d0:	e0bffb17 	ldw	r2,-20(fp)
 202a7d4:	103ff51e 	bne	r2,zero,202a7ac <__alt_mem_mem_0+0xfd00a7ac>
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  /* no port specified? */
  if (port == 0) {
 202a7d8:	e0bfff0b 	ldhu	r2,-4(fp)
 202a7dc:	1000061e 	bne	r2,zero,202a7f8 <udp_bind+0x9c>
    port = udp_new_port();
 202a7e0:	202984c0 	call	202984c <udp_new_port>
 202a7e4:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
 202a7e8:	e0bfff0b 	ldhu	r2,-4(fp)
 202a7ec:	10002d1e 	bne	r2,zero,202a8a4 <udp_bind+0x148>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 202a7f0:	00bffe04 	movi	r2,-8
 202a7f4:	00003e06 	br	202a8f0 <udp_bind+0x194>
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 202a7f8:	d0a7f317 	ldw	r2,-24628(gp)
 202a7fc:	e0bffb15 	stw	r2,-20(fp)
 202a800:	00002606 	br	202a89c <udp_bind+0x140>
      if (pcb != ipcb) {
 202a804:	e0fffd17 	ldw	r3,-12(fp)
 202a808:	e0bffb17 	ldw	r2,-20(fp)
 202a80c:	18802026 	beq	r3,r2,202a890 <udp_bind+0x134>
        /* By default, we don't allow to bind to a port that any other udp
           PCB is already bound to, unless *all* PCBs with that port have tha
           REUSEADDR flag set. */
#if SO_REUSE
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 202a810:	e0bffd17 	ldw	r2,-12(fp)
 202a814:	10800243 	ldbu	r2,9(r2)
 202a818:	10803fcc 	andi	r2,r2,255
 202a81c:	1080010c 	andi	r2,r2,4
 202a820:	10000526 	beq	r2,zero,202a838 <udp_bind+0xdc>
            !ip_get_option(ipcb, SOF_REUSEADDR))
 202a824:	e0bffb17 	ldw	r2,-20(fp)
 202a828:	10800243 	ldbu	r2,9(r2)
 202a82c:	10803fcc 	andi	r2,r2,255
 202a830:	1080010c 	andi	r2,r2,4
      if (pcb != ipcb) {
        /* By default, we don't allow to bind to a port that any other udp
           PCB is already bound to, unless *all* PCBs with that port have tha
           REUSEADDR flag set. */
#if SO_REUSE
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 202a834:	1000161e 	bne	r2,zero,202a890 <udp_bind+0x134>
            !ip_get_option(ipcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
 202a838:	e0bffb17 	ldw	r2,-20(fp)
 202a83c:	1080058b 	ldhu	r2,22(r2)
 202a840:	10ffffcc 	andi	r3,r2,65535
 202a844:	e0bfff0b 	ldhu	r2,-4(fp)
 202a848:	1880111e 	bne	r3,r2,202a890 <udp_bind+0x134>
              (((IP_GET_TYPE(&ipcb->local_ip) == IP_GET_TYPE(ipaddr)) &&
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 202a84c:	e0bffb17 	ldw	r2,-20(fp)
 202a850:	10c00017 	ldw	r3,0(r2)
 202a854:	e0bffe17 	ldw	r2,-8(fp)
 202a858:	10800017 	ldw	r2,0(r2)
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(ipcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
 202a85c:	18800a26 	beq	r3,r2,202a888 <udp_bind+0x12c>
              (((IP_GET_TYPE(&ipcb->local_ip) == IP_GET_TYPE(ipaddr)) &&
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 202a860:	e0bffe17 	ldw	r2,-8(fp)
 202a864:	10000826 	beq	r2,zero,202a888 <udp_bind+0x12c>
              ip_addr_isany(ipaddr) ||
 202a868:	e0bffe17 	ldw	r2,-8(fp)
 202a86c:	10800017 	ldw	r2,0(r2)
 202a870:	10000526 	beq	r2,zero,202a888 <udp_bind+0x12c>
              ip_addr_isany(&ipcb->local_ip))) ||
 202a874:	e0bffb17 	ldw	r2,-20(fp)
              (IP_GET_TYPE(&ipcb->local_ip) == IPADDR_TYPE_ANY) ||
 202a878:	10000326 	beq	r2,zero,202a888 <udp_bind+0x12c>
          if ((ipcb->local_port == port) &&
              (((IP_GET_TYPE(&ipcb->local_ip) == IP_GET_TYPE(ipaddr)) &&
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
              ip_addr_isany(ipaddr) ||
              ip_addr_isany(&ipcb->local_ip))) ||
 202a87c:	e0bffb17 	ldw	r2,-20(fp)
 202a880:	10800017 	ldw	r2,0(r2)
 202a884:	1000021e 	bne	r2,zero,202a890 <udp_bind+0x134>
              (IP_GET_TYPE(&ipcb->local_ip) == IPADDR_TYPE_ANY) ||
              (IP_GET_TYPE(ipaddr) == IPADDR_TYPE_ANY))) {
            /* other PCB already binds to this local IP and port */
            LWIP_DEBUGF(UDP_DEBUG,
                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
            return ERR_USE;
 202a888:	00bffe04 	movi	r2,-8
 202a88c:	00001806 	br	202a8f0 <udp_bind+0x194>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 202a890:	e0bffb17 	ldw	r2,-20(fp)
 202a894:	10800417 	ldw	r2,16(r2)
 202a898:	e0bffb15 	stw	r2,-20(fp)
 202a89c:	e0bffb17 	ldw	r2,-20(fp)
 202a8a0:	103fd81e 	bne	r2,zero,202a804 <__alt_mem_mem_0+0xfd00a804>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 202a8a4:	e0bffe17 	ldw	r2,-8(fp)
 202a8a8:	10000326 	beq	r2,zero,202a8b8 <udp_bind+0x15c>
 202a8ac:	e0bffe17 	ldw	r2,-8(fp)
 202a8b0:	10800017 	ldw	r2,0(r2)
 202a8b4:	00000106 	br	202a8bc <udp_bind+0x160>
 202a8b8:	0005883a 	mov	r2,zero
 202a8bc:	e0fffd17 	ldw	r3,-12(fp)
 202a8c0:	18800015 	stw	r2,0(r3)

  pcb->local_port = port;
 202a8c4:	e0bffd17 	ldw	r2,-12(fp)
 202a8c8:	e0ffff0b 	ldhu	r3,-4(fp)
 202a8cc:	10c0058d 	sth	r3,22(r2)
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 202a8d0:	e0bffc03 	ldbu	r2,-16(fp)
 202a8d4:	1000051e 	bne	r2,zero,202a8ec <udp_bind+0x190>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 202a8d8:	d0e7f317 	ldw	r3,-24628(gp)
 202a8dc:	e0bffd17 	ldw	r2,-12(fp)
 202a8e0:	10c00415 	stw	r3,16(r2)
    udp_pcbs = pcb;
 202a8e4:	e0bffd17 	ldw	r2,-12(fp)
 202a8e8:	d0a7f315 	stw	r2,-24628(gp)
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 202a8ec:	0005883a 	mov	r2,zero
}
 202a8f0:	e037883a 	mov	sp,fp
 202a8f4:	dfc00117 	ldw	ra,4(sp)
 202a8f8:	df000017 	ldw	fp,0(sp)
 202a8fc:	dec00204 	addi	sp,sp,8
 202a900:	f800283a 	ret

0202a904 <udp_bind_netif>:
 *
 * @see udp_disconnect()
 */
void
udp_bind_netif(struct udp_pcb *pcb, const struct netif *netif)
{
 202a904:	defffd04 	addi	sp,sp,-12
 202a908:	df000215 	stw	fp,8(sp)
 202a90c:	df000204 	addi	fp,sp,8
 202a910:	e13ffe15 	stw	r4,-8(fp)
 202a914:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  if (netif != NULL) {
 202a918:	e0bfff17 	ldw	r2,-4(fp)
 202a91c:	10000726 	beq	r2,zero,202a93c <udp_bind_netif+0x38>
    pcb->netif_idx = netif_get_index(netif);
 202a920:	e0bfff17 	ldw	r2,-4(fp)
 202a924:	10801003 	ldbu	r2,64(r2)
 202a928:	10800044 	addi	r2,r2,1
 202a92c:	1007883a 	mov	r3,r2
 202a930:	e0bffe17 	ldw	r2,-8(fp)
 202a934:	10c00205 	stb	r3,8(r2)
  } else {
    pcb->netif_idx = NETIF_NO_INDEX;
  }
}
 202a938:	00000206 	br	202a944 <udp_bind_netif+0x40>
  LWIP_ASSERT_CORE_LOCKED();

  if (netif != NULL) {
    pcb->netif_idx = netif_get_index(netif);
  } else {
    pcb->netif_idx = NETIF_NO_INDEX;
 202a93c:	e0bffe17 	ldw	r2,-8(fp)
 202a940:	10000205 	stb	zero,8(r2)
  }
}
 202a944:	0001883a 	nop
 202a948:	e037883a 	mov	sp,fp
 202a94c:	df000017 	ldw	fp,0(sp)
 202a950:	dec00104 	addi	sp,sp,4
 202a954:	f800283a 	ret

0202a958 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 202a958:	defff904 	addi	sp,sp,-28
 202a95c:	dfc00615 	stw	ra,24(sp)
 202a960:	df000515 	stw	fp,20(sp)
 202a964:	df000504 	addi	fp,sp,20
 202a968:	e13ffd15 	stw	r4,-12(fp)
 202a96c:	e17ffe15 	stw	r5,-8(fp)
 202a970:	3005883a 	mov	r2,r6
 202a974:	e0bfff0d 	sth	r2,-4(fp)
  struct udp_pcb *ipcb;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 202a978:	e0bffd17 	ldw	r2,-12(fp)
 202a97c:	1000021e 	bne	r2,zero,202a988 <udp_connect+0x30>
 202a980:	00bffc04 	movi	r2,-16
 202a984:	00003906 	br	202aa6c <udp_connect+0x114>
  LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 202a988:	e0bffe17 	ldw	r2,-8(fp)
 202a98c:	1000021e 	bne	r2,zero,202a998 <udp_connect+0x40>
 202a990:	00bffc04 	movi	r2,-16
 202a994:	00003506 	br	202aa6c <udp_connect+0x114>

  if (pcb->local_port == 0) {
 202a998:	e0bffd17 	ldw	r2,-12(fp)
 202a99c:	1080058b 	ldhu	r2,22(r2)
 202a9a0:	10bfffcc 	andi	r2,r2,65535
 202a9a4:	10000d1e 	bne	r2,zero,202a9dc <udp_connect+0x84>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 202a9a8:	e0fffd17 	ldw	r3,-12(fp)
 202a9ac:	e0bffd17 	ldw	r2,-12(fp)
 202a9b0:	1080058b 	ldhu	r2,22(r2)
 202a9b4:	10bfffcc 	andi	r2,r2,65535
 202a9b8:	100d883a 	mov	r6,r2
 202a9bc:	180b883a 	mov	r5,r3
 202a9c0:	e13ffd17 	ldw	r4,-12(fp)
 202a9c4:	202a75c0 	call	202a75c <udp_bind>
 202a9c8:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
 202a9cc:	e0bffc07 	ldb	r2,-16(fp)
 202a9d0:	10000226 	beq	r2,zero,202a9dc <udp_connect+0x84>
      return err;
 202a9d4:	e0bffc03 	ldbu	r2,-16(fp)
 202a9d8:	00002406 	br	202aa6c <udp_connect+0x114>
    }
  }

  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 202a9dc:	e0bffe17 	ldw	r2,-8(fp)
 202a9e0:	10000326 	beq	r2,zero,202a9f0 <udp_connect+0x98>
 202a9e4:	e0bffe17 	ldw	r2,-8(fp)
 202a9e8:	10800017 	ldw	r2,0(r2)
 202a9ec:	00000106 	br	202a9f4 <udp_connect+0x9c>
 202a9f0:	0005883a 	mov	r2,zero
 202a9f4:	e0fffd17 	ldw	r3,-12(fp)
 202a9f8:	18800115 	stw	r2,4(r3)
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNKNOWN)) {
    ip6_addr_select_zone(ip_2_ip6(&pcb->remote_ip), ip_2_ip6(&pcb->local_ip));
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  pcb->remote_port = port;
 202a9fc:	e0bffd17 	ldw	r2,-12(fp)
 202aa00:	e0ffff0b 	ldhu	r3,-4(fp)
 202aa04:	10c0060d 	sth	r3,24(r2)
  pcb->flags |= UDP_FLAGS_CONNECTED;
 202aa08:	e0bffd17 	ldw	r2,-12(fp)
 202aa0c:	10800503 	ldbu	r2,20(r2)
 202aa10:	10800114 	ori	r2,r2,4
 202aa14:	1007883a 	mov	r3,r2
 202aa18:	e0bffd17 	ldw	r2,-12(fp)
 202aa1c:	10c00505 	stb	r3,20(r2)
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                          pcb->remote_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 202aa20:	d0a7f317 	ldw	r2,-24628(gp)
 202aa24:	e0bffb15 	stw	r2,-20(fp)
 202aa28:	00000806 	br	202aa4c <udp_connect+0xf4>
    if (pcb == ipcb) {
 202aa2c:	e0fffd17 	ldw	r3,-12(fp)
 202aa30:	e0bffb17 	ldw	r2,-20(fp)
 202aa34:	1880021e 	bne	r3,r2,202aa40 <udp_connect+0xe8>
      /* already on the list, just return */
      return ERR_OK;
 202aa38:	0005883a 	mov	r2,zero
 202aa3c:	00000b06 	br	202aa6c <udp_connect+0x114>
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                          pcb->remote_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 202aa40:	e0bffb17 	ldw	r2,-20(fp)
 202aa44:	10800417 	ldw	r2,16(r2)
 202aa48:	e0bffb15 	stw	r2,-20(fp)
 202aa4c:	e0bffb17 	ldw	r2,-20(fp)
 202aa50:	103ff61e 	bne	r2,zero,202aa2c <__alt_mem_mem_0+0xfd00aa2c>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 202aa54:	d0e7f317 	ldw	r3,-24628(gp)
 202aa58:	e0bffd17 	ldw	r2,-12(fp)
 202aa5c:	10c00415 	stw	r3,16(r2)
  udp_pcbs = pcb;
 202aa60:	e0bffd17 	ldw	r2,-12(fp)
 202aa64:	d0a7f315 	stw	r2,-24628(gp)
  return ERR_OK;
 202aa68:	0005883a 	mov	r2,zero
}
 202aa6c:	e037883a 	mov	sp,fp
 202aa70:	dfc00117 	ldw	ra,4(sp)
 202aa74:	df000017 	ldw	fp,0(sp)
 202aa78:	dec00204 	addi	sp,sp,8
 202aa7c:	f800283a 	ret

0202aa80 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
 202aa80:	defffe04 	addi	sp,sp,-8
 202aa84:	df000115 	stw	fp,4(sp)
 202aa88:	df000104 	addi	fp,sp,4
 202aa8c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_disconnect: invalid pcb", pcb != NULL, return);
 202aa90:	e0bfff17 	ldw	r2,-4(fp)
 202aa94:	10000e26 	beq	r2,zero,202aad0 <udp_disconnect+0x50>
#if LWIP_IPV4 && LWIP_IPV6
  if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
    ip_addr_copy(pcb->remote_ip, *IP_ANY_TYPE);
  } else {
#endif
    ip_addr_set_any(IP_IS_V6_VAL(pcb->remote_ip), &pcb->remote_ip);
 202aa98:	e0bfff17 	ldw	r2,-4(fp)
 202aa9c:	10000115 	stw	zero,4(r2)
#if LWIP_IPV4 && LWIP_IPV6
  }
#endif
  pcb->remote_port = 0;
 202aaa0:	e0bfff17 	ldw	r2,-4(fp)
 202aaa4:	1000060d 	sth	zero,24(r2)
  pcb->netif_idx = NETIF_NO_INDEX;
 202aaa8:	e0bfff17 	ldw	r2,-4(fp)
 202aaac:	10000205 	stb	zero,8(r2)
  /* mark PCB as unconnected */
  udp_clear_flags(pcb, UDP_FLAGS_CONNECTED);
 202aab0:	e0bfff17 	ldw	r2,-4(fp)
 202aab4:	10c00503 	ldbu	r3,20(r2)
 202aab8:	00bffec4 	movi	r2,-5
 202aabc:	1884703a 	and	r2,r3,r2
 202aac0:	1007883a 	mov	r3,r2
 202aac4:	e0bfff17 	ldw	r2,-4(fp)
 202aac8:	10c00505 	stb	r3,20(r2)
 202aacc:	00000106 	br	202aad4 <udp_disconnect+0x54>
void
udp_disconnect(struct udp_pcb *pcb)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_disconnect: invalid pcb", pcb != NULL, return);
 202aad0:	0001883a 	nop
#endif
  pcb->remote_port = 0;
  pcb->netif_idx = NETIF_NO_INDEX;
  /* mark PCB as unconnected */
  udp_clear_flags(pcb, UDP_FLAGS_CONNECTED);
}
 202aad4:	e037883a 	mov	sp,fp
 202aad8:	df000017 	ldw	fp,0(sp)
 202aadc:	dec00104 	addi	sp,sp,4
 202aae0:	f800283a 	ret

0202aae4 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 202aae4:	defffc04 	addi	sp,sp,-16
 202aae8:	df000315 	stw	fp,12(sp)
 202aaec:	df000304 	addi	fp,sp,12
 202aaf0:	e13ffd15 	stw	r4,-12(fp)
 202aaf4:	e17ffe15 	stw	r5,-8(fp)
 202aaf8:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 202aafc:	e0bffd17 	ldw	r2,-12(fp)
 202ab00:	10000726 	beq	r2,zero,202ab20 <udp_recv+0x3c>

  /* remember recv() callback and user data */
  pcb->recv = recv;
 202ab04:	e0bffd17 	ldw	r2,-12(fp)
 202ab08:	e0fffe17 	ldw	r3,-8(fp)
 202ab0c:	10c00715 	stw	r3,28(r2)
  pcb->recv_arg = recv_arg;
 202ab10:	e0bffd17 	ldw	r2,-12(fp)
 202ab14:	e0ffff17 	ldw	r3,-4(fp)
 202ab18:	10c00815 	stw	r3,32(r2)
 202ab1c:	00000106 	br	202ab24 <udp_recv+0x40>
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 202ab20:	0001883a 	nop

  /* remember recv() callback and user data */
  pcb->recv = recv;
  pcb->recv_arg = recv_arg;
}
 202ab24:	e037883a 	mov	sp,fp
 202ab28:	df000017 	ldw	fp,0(sp)
 202ab2c:	dec00104 	addi	sp,sp,4
 202ab30:	f800283a 	ret

0202ab34 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 202ab34:	defffc04 	addi	sp,sp,-16
 202ab38:	dfc00315 	stw	ra,12(sp)
 202ab3c:	df000215 	stw	fp,8(sp)
 202ab40:	df000204 	addi	fp,sp,8
 202ab44:	e13fff15 	stw	r4,-4(fp)
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 202ab48:	e0bfff17 	ldw	r2,-4(fp)
 202ab4c:	10001f26 	beq	r2,zero,202abcc <udp_remove+0x98>

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 202ab50:	d0e7f317 	ldw	r3,-24628(gp)
 202ab54:	e0bfff17 	ldw	r2,-4(fp)
 202ab58:	1880041e 	bne	r3,r2,202ab6c <udp_remove+0x38>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 202ab5c:	d0a7f317 	ldw	r2,-24628(gp)
 202ab60:	10800417 	ldw	r2,16(r2)
 202ab64:	d0a7f315 	stw	r2,-24628(gp)
 202ab68:	00001406 	br	202abbc <udp_remove+0x88>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 202ab6c:	d0a7f317 	ldw	r2,-24628(gp)
 202ab70:	e0bffe15 	stw	r2,-8(fp)
 202ab74:	00000f06 	br	202abb4 <udp_remove+0x80>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 202ab78:	e0bffe17 	ldw	r2,-8(fp)
 202ab7c:	10800417 	ldw	r2,16(r2)
 202ab80:	10000926 	beq	r2,zero,202aba8 <udp_remove+0x74>
 202ab84:	e0bffe17 	ldw	r2,-8(fp)
 202ab88:	10c00417 	ldw	r3,16(r2)
 202ab8c:	e0bfff17 	ldw	r2,-4(fp)
 202ab90:	1880051e 	bne	r3,r2,202aba8 <udp_remove+0x74>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 202ab94:	e0bfff17 	ldw	r2,-4(fp)
 202ab98:	10c00417 	ldw	r3,16(r2)
 202ab9c:	e0bffe17 	ldw	r2,-8(fp)
 202aba0:	10c00415 	stw	r3,16(r2)
        break;
 202aba4:	00000506 	br	202abbc <udp_remove+0x88>
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 202aba8:	e0bffe17 	ldw	r2,-8(fp)
 202abac:	10800417 	ldw	r2,16(r2)
 202abb0:	e0bffe15 	stw	r2,-8(fp)
 202abb4:	e0bffe17 	ldw	r2,-8(fp)
 202abb8:	103fef1e 	bne	r2,zero,202ab78 <__alt_mem_mem_0+0xfd00ab78>
        pcb2->next = pcb->next;
        break;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 202abbc:	e17fff17 	ldw	r5,-4(fp)
 202abc0:	01000044 	movi	r4,1
 202abc4:	201b9640 	call	201b964 <memp_free>
 202abc8:	00000106 	br	202abd0 <udp_remove+0x9c>
{
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 202abcc:	0001883a 	nop
        break;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
}
 202abd0:	e037883a 	mov	sp,fp
 202abd4:	dfc00117 	ldw	ra,4(sp)
 202abd8:	df000017 	ldw	fp,0(sp)
 202abdc:	dec00204 	addi	sp,sp,8
 202abe0:	f800283a 	ret

0202abe4 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 202abe4:	defffd04 	addi	sp,sp,-12
 202abe8:	dfc00215 	stw	ra,8(sp)
 202abec:	df000115 	stw	fp,4(sp)
 202abf0:	df000104 	addi	fp,sp,4
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 202abf4:	01000044 	movi	r4,1
 202abf8:	201b82c0 	call	201b82c <memp_malloc>
 202abfc:	e0bfff15 	stw	r2,-4(fp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 202ac00:	e0bfff17 	ldw	r2,-4(fp)
 202ac04:	10000726 	beq	r2,zero,202ac24 <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 202ac08:	01800904 	movi	r6,36
 202ac0c:	000b883a 	mov	r5,zero
 202ac10:	e13fff17 	ldw	r4,-4(fp)
 202ac14:	2005fa00 	call	2005fa0 <memset>
    pcb->ttl = UDP_TTL;
 202ac18:	e0bfff17 	ldw	r2,-4(fp)
 202ac1c:	00c01004 	movi	r3,64
 202ac20:	10c002c5 	stb	r3,11(r2)
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
 202ac24:	e0bfff17 	ldw	r2,-4(fp)
}
 202ac28:	e037883a 	mov	sp,fp
 202ac2c:	dfc00117 	ldw	ra,4(sp)
 202ac30:	df000017 	ldw	fp,0(sp)
 202ac34:	dec00204 	addi	sp,sp,8
 202ac38:	f800283a 	ret

0202ac3c <udp_new_ip_type>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new_ip_type(u8_t type)
{
 202ac3c:	defffc04 	addi	sp,sp,-16
 202ac40:	dfc00315 	stw	ra,12(sp)
 202ac44:	df000215 	stw	fp,8(sp)
 202ac48:	df000204 	addi	fp,sp,8
 202ac4c:	2005883a 	mov	r2,r4
 202ac50:	e0bfff05 	stb	r2,-4(fp)
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = udp_new();
 202ac54:	202abe40 	call	202abe4 <udp_new>
 202ac58:	e0bffe15 	stw	r2,-8(fp)
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
 202ac5c:	e0bffe17 	ldw	r2,-8(fp)
}
 202ac60:	e037883a 	mov	sp,fp
 202ac64:	dfc00117 	ldw	ra,4(sp)
 202ac68:	df000017 	ldw	fp,0(sp)
 202ac6c:	dec00204 	addi	sp,sp,8
 202ac70:	f800283a 	ret

0202ac74 <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 202ac74:	defffc04 	addi	sp,sp,-16
 202ac78:	df000315 	stw	fp,12(sp)
 202ac7c:	df000304 	addi	fp,sp,12
 202ac80:	e13ffe15 	stw	r4,-8(fp)
 202ac84:	e17fff15 	stw	r5,-4(fp)
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 202ac88:	e0bffe17 	ldw	r2,-8(fp)
 202ac8c:	10001926 	beq	r2,zero,202acf4 <udp_netif_ip_addr_changed+0x80>
 202ac90:	e0bffe17 	ldw	r2,-8(fp)
 202ac94:	10800017 	ldw	r2,0(r2)
 202ac98:	10001626 	beq	r2,zero,202acf4 <udp_netif_ip_addr_changed+0x80>
 202ac9c:	e0bfff17 	ldw	r2,-4(fp)
 202aca0:	10001426 	beq	r2,zero,202acf4 <udp_netif_ip_addr_changed+0x80>
 202aca4:	e0bfff17 	ldw	r2,-4(fp)
 202aca8:	10800017 	ldw	r2,0(r2)
 202acac:	10001126 	beq	r2,zero,202acf4 <udp_netif_ip_addr_changed+0x80>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 202acb0:	d0a7f317 	ldw	r2,-24628(gp)
 202acb4:	e0bffd15 	stw	r2,-12(fp)
 202acb8:	00000c06 	br	202acec <udp_netif_ip_addr_changed+0x78>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 202acbc:	e0bffd17 	ldw	r2,-12(fp)
 202acc0:	10c00017 	ldw	r3,0(r2)
 202acc4:	e0bffe17 	ldw	r2,-8(fp)
 202acc8:	10800017 	ldw	r2,0(r2)
 202accc:	1880041e 	bne	r3,r2,202ace0 <udp_netif_ip_addr_changed+0x6c>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 202acd0:	e0bfff17 	ldw	r2,-4(fp)
 202acd4:	10c00017 	ldw	r3,0(r2)
 202acd8:	e0bffd17 	ldw	r2,-12(fp)
 202acdc:	10c00015 	stw	r3,0(r2)
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 202ace0:	e0bffd17 	ldw	r2,-12(fp)
 202ace4:	10800417 	ldw	r2,16(r2)
 202ace8:	e0bffd15 	stw	r2,-12(fp)
 202acec:	e0bffd17 	ldw	r2,-12(fp)
 202acf0:	103ff21e 	bne	r2,zero,202acbc <__alt_mem_mem_0+0xfd00acbc>
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
      }
    }
  }
}
 202acf4:	0001883a 	nop
 202acf8:	e037883a 	mov	sp,fp
 202acfc:	df000017 	ldw	fp,0(sp)
 202ad00:	dec00104 	addi	sp,sp,4
 202ad04:	f800283a 	ret

0202ad08 <ethernet_input>:
 * @see ETHARP_SUPPORT_VLAN
 * @see LWIP_HOOK_VLAN_CHECK
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 202ad08:	defff904 	addi	sp,sp,-28
 202ad0c:	dfc00615 	stw	ra,24(sp)
 202ad10:	df000515 	stw	fp,20(sp)
 202ad14:	df000504 	addi	fp,sp,20
 202ad18:	e13ffe15 	stw	r4,-8(fp)
 202ad1c:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr *ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  u16_t next_hdr_offset = SIZEOF_ETH_HDR;
 202ad20:	00800404 	movi	r2,16
 202ad24:	e0bffb0d 	sth	r2,-20(fp)
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  LWIP_ASSERT_CORE_LOCKED();

  if (p->len <= SIZEOF_ETH_HDR) {
 202ad28:	e0bffe17 	ldw	r2,-8(fp)
 202ad2c:	1080028b 	ldhu	r2,10(r2)
 202ad30:	10bfffcc 	andi	r2,r2,65535
 202ad34:	10800468 	cmpgeui	r2,r2,17
 202ad38:	10000f1e 	bne	r2,zero,202ad78 <ethernet_input+0x70>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
 202ad3c:	008085f4 	movhi	r2,535
 202ad40:	10bd8204 	addi	r2,r2,-2552
 202ad44:	10801417 	ldw	r2,80(r2)
 202ad48:	10c00044 	addi	r3,r2,1
 202ad4c:	008085f4 	movhi	r2,535
 202ad50:	10bd8204 	addi	r2,r2,-2552
 202ad54:	10c01415 	stw	r3,80(r2)
    ETHARP_STATS_INC(etharp.drop);
 202ad58:	008085f4 	movhi	r2,535
 202ad5c:	10bd8204 	addi	r2,r2,-2552
 202ad60:	10800f17 	ldw	r2,60(r2)
 202ad64:	10c00044 	addi	r3,r2,1
 202ad68:	008085f4 	movhi	r2,535
 202ad6c:	10bd8204 	addi	r2,r2,-2552
 202ad70:	10c00f15 	stw	r3,60(r2)
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
 202ad74:	00008306 	br	202af84 <ethernet_input+0x27c>
  }

  if (p->if_idx == NETIF_NO_INDEX) {
 202ad78:	e0bffe17 	ldw	r2,-8(fp)
 202ad7c:	108003c3 	ldbu	r2,15(r2)
 202ad80:	10803fcc 	andi	r2,r2,255
 202ad84:	1000061e 	bne	r2,zero,202ada0 <ethernet_input+0x98>
    p->if_idx = netif_get_index(netif);
 202ad88:	e0bfff17 	ldw	r2,-4(fp)
 202ad8c:	10801003 	ldbu	r2,64(r2)
 202ad90:	10800044 	addi	r2,r2,1
 202ad94:	1007883a 	mov	r3,r2
 202ad98:	e0bffe17 	ldw	r2,-8(fp)
 202ad9c:	10c003c5 	stb	r3,15(r2)
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 202ada0:	e0bffe17 	ldw	r2,-8(fp)
 202ada4:	10800117 	ldw	r2,4(r2)
 202ada8:	e0bffc15 	stw	r2,-16(fp)
               (unsigned char)ethhdr->dest.addr[3], (unsigned char)ethhdr->dest.addr[4], (unsigned char)ethhdr->dest.addr[5],
               (unsigned char)ethhdr->src.addr[0],  (unsigned char)ethhdr->src.addr[1],  (unsigned char)ethhdr->src.addr[2],
               (unsigned char)ethhdr->src.addr[3],  (unsigned char)ethhdr->src.addr[4],  (unsigned char)ethhdr->src.addr[5],
               lwip_htons(ethhdr->type)));

  type = ethhdr->type;
 202adac:	e0bffc17 	ldw	r2,-16(fp)
 202adb0:	10c00383 	ldbu	r3,14(r2)
 202adb4:	108003c3 	ldbu	r2,15(r2)
 202adb8:	1004923a 	slli	r2,r2,8
 202adbc:	10c4b03a 	or	r2,r2,r3
 202adc0:	e0bffd0d 	sth	r2,-12(fp)

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 202adc4:	e0bffc17 	ldw	r2,-16(fp)
 202adc8:	10800083 	ldbu	r2,2(r2)
 202adcc:	10803fcc 	andi	r2,r2,255
 202add0:	1080004c 	andi	r2,r2,1
 202add4:	10002226 	beq	r2,zero,202ae60 <ethernet_input+0x158>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
 202add8:	e0bffc17 	ldw	r2,-16(fp)
 202addc:	10800083 	ldbu	r2,2(r2)
 202ade0:	10803fcc 	andi	r2,r2,255
 202ade4:	10800058 	cmpnei	r2,r2,1
 202ade8:	1000101e 	bne	r2,zero,202ae2c <ethernet_input+0x124>
#if LWIP_IPV4
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 202adec:	e0bffc17 	ldw	r2,-16(fp)
 202adf0:	108000c3 	ldbu	r2,3(r2)
 202adf4:	10803fcc 	andi	r2,r2,255
 202adf8:	1000191e 	bne	r2,zero,202ae60 <ethernet_input+0x158>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
 202adfc:	e0bffc17 	ldw	r2,-16(fp)
 202ae00:	10800103 	ldbu	r2,4(r2)

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
#if LWIP_IPV4
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 202ae04:	10803fcc 	andi	r2,r2,255
 202ae08:	10801798 	cmpnei	r2,r2,94
 202ae0c:	1000141e 	bne	r2,zero,202ae60 <ethernet_input+0x158>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 202ae10:	e0bffe17 	ldw	r2,-8(fp)
 202ae14:	10800343 	ldbu	r2,13(r2)
 202ae18:	10800414 	ori	r2,r2,16
 202ae1c:	1007883a 	mov	r3,r2
 202ae20:	e0bffe17 	ldw	r2,-8(fp)
 202ae24:	10c00345 	stb	r3,13(r2)
 202ae28:	00000d06 	br	202ae60 <ethernet_input+0x158>
             (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
      /* mark the pbuf as link-layer multicast */
      p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 202ae2c:	e0bffc17 	ldw	r2,-16(fp)
 202ae30:	10800084 	addi	r2,r2,2
 202ae34:	01800184 	movi	r6,6
 202ae38:	d1601584 	addi	r5,gp,-32682
 202ae3c:	1009883a 	mov	r4,r2
 202ae40:	20424280 	call	2042428 <memcmp>
 202ae44:	1000061e 	bne	r2,zero,202ae60 <ethernet_input+0x158>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 202ae48:	e0bffe17 	ldw	r2,-8(fp)
 202ae4c:	10800343 	ldbu	r2,13(r2)
 202ae50:	10800214 	ori	r2,r2,8
 202ae54:	1007883a 	mov	r3,r2
 202ae58:	e0bffe17 	ldw	r2,-8(fp)
 202ae5c:	10c00345 	stb	r3,13(r2)
    }
  }

  switch (type) {
 202ae60:	e0bffd0b 	ldhu	r2,-12(fp)
 202ae64:	10c00220 	cmpeqi	r3,r2,8
 202ae68:	1800031e 	bne	r3,zero,202ae78 <ethernet_input+0x170>
 202ae6c:	10818220 	cmpeqi	r2,r2,1544
 202ae70:	1000101e 	bne	r2,zero,202aeb4 <ethernet_input+0x1ac>
 202ae74:	00002d06 	br	202af2c <ethernet_input+0x224>
#if LWIP_IPV4 && LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 202ae78:	e0bfff17 	ldw	r2,-4(fp)
 202ae7c:	10800f43 	ldbu	r2,61(r2)
 202ae80:	10803fcc 	andi	r2,r2,255
 202ae84:	1080020c 	andi	r2,r2,8
 202ae88:	10003926 	beq	r2,zero,202af70 <ethernet_input+0x268>
        goto free_and_return;
      }
      /* skip Ethernet header (min. size checked above) */
      if (pbuf_remove_header(p, next_hdr_offset)) {
 202ae8c:	e0bffb0b 	ldhu	r2,-20(fp)
 202ae90:	100b883a 	mov	r5,r2
 202ae94:	e13ffe17 	ldw	r4,-8(fp)
 202ae98:	201d06c0 	call	201d06c <pbuf_remove_header>
 202ae9c:	10803fcc 	andi	r2,r2,255
 202aea0:	1000351e 	bne	r2,zero,202af78 <ethernet_input+0x270>
                     p->tot_len, next_hdr_offset));
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip4_input(p, netif);
 202aea4:	e17fff17 	ldw	r5,-4(fp)
 202aea8:	e13ffe17 	ldw	r4,-8(fp)
 202aeac:	203b7b40 	call	203b7b4 <ip4_input>
      }
      break;
 202aeb0:	00002d06 	br	202af68 <ethernet_input+0x260>

    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 202aeb4:	e0bfff17 	ldw	r2,-4(fp)
 202aeb8:	10800f43 	ldbu	r2,61(r2)
 202aebc:	10803fcc 	andi	r2,r2,255
 202aec0:	1080020c 	andi	r2,r2,8
 202aec4:	10002e26 	beq	r2,zero,202af80 <ethernet_input+0x278>
        goto free_and_return;
      }
      /* skip Ethernet header (min. size checked above) */
      if (pbuf_remove_header(p, next_hdr_offset)) {
 202aec8:	e0bffb0b 	ldhu	r2,-20(fp)
 202aecc:	100b883a 	mov	r5,r2
 202aed0:	e13ffe17 	ldw	r4,-8(fp)
 202aed4:	201d06c0 	call	201d06c <pbuf_remove_header>
 202aed8:	10803fcc 	andi	r2,r2,255
 202aedc:	10000f26 	beq	r2,zero,202af1c <ethernet_input+0x214>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                    ("ethernet_input: ARP response packet dropped, too short (%"U16_F"/%"U16_F")\n",
                     p->tot_len, next_hdr_offset));
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
        ETHARP_STATS_INC(etharp.lenerr);
 202aee0:	008085f4 	movhi	r2,535
 202aee4:	10bd8204 	addi	r2,r2,-2552
 202aee8:	10801117 	ldw	r2,68(r2)
 202aeec:	10c00044 	addi	r3,r2,1
 202aef0:	008085f4 	movhi	r2,535
 202aef4:	10bd8204 	addi	r2,r2,-2552
 202aef8:	10c01115 	stw	r3,68(r2)
        ETHARP_STATS_INC(etharp.drop);
 202aefc:	008085f4 	movhi	r2,535
 202af00:	10bd8204 	addi	r2,r2,-2552
 202af04:	10800f17 	ldw	r2,60(r2)
 202af08:	10c00044 	addi	r3,r2,1
 202af0c:	008085f4 	movhi	r2,535
 202af10:	10bd8204 	addi	r2,r2,-2552
 202af14:	10c00f15 	stw	r3,60(r2)
        goto free_and_return;
 202af18:	00001a06 	br	202af84 <ethernet_input+0x27c>
      } else {
        /* pass p to ARP module */
        etharp_input(p, netif);
 202af1c:	e17fff17 	ldw	r5,-4(fp)
 202af20:	e13ffe17 	ldw	r4,-8(fp)
 202af24:	20192d00 	call	20192d0 <etharp_input>
      }
      break;
 202af28:	00000f06 	br	202af68 <ethernet_input+0x260>
#ifdef LWIP_HOOK_UNKNOWN_ETH_PROTOCOL
      if (LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(p, netif) == ERR_OK) {
        break;
      }
#endif
      ETHARP_STATS_INC(etharp.proterr);
 202af2c:	008085f4 	movhi	r2,535
 202af30:	10bd8204 	addi	r2,r2,-2552
 202af34:	10801417 	ldw	r2,80(r2)
 202af38:	10c00044 	addi	r3,r2,1
 202af3c:	008085f4 	movhi	r2,535
 202af40:	10bd8204 	addi	r2,r2,-2552
 202af44:	10c01415 	stw	r3,80(r2)
      ETHARP_STATS_INC(etharp.drop);
 202af48:	008085f4 	movhi	r2,535
 202af4c:	10bd8204 	addi	r2,r2,-2552
 202af50:	10800f17 	ldw	r2,60(r2)
 202af54:	10c00044 	addi	r3,r2,1
 202af58:	008085f4 	movhi	r2,535
 202af5c:	10bd8204 	addi	r2,r2,-2552
 202af60:	10c00f15 	stw	r3,60(r2)
      MIB2_STATS_NETIF_INC(netif, ifinunknownprotos);
      goto free_and_return;
 202af64:	00000706 	br	202af84 <ethernet_input+0x27c>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
 202af68:	0005883a 	mov	r2,zero
 202af6c:	00000806 	br	202af90 <ethernet_input+0x288>
  switch (type) {
#if LWIP_IPV4 && LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
 202af70:	0001883a 	nop
 202af74:	00000306 	br	202af84 <ethernet_input+0x27c>
      if (pbuf_remove_header(p, next_hdr_offset)) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                    ("ethernet_input: IPv4 packet dropped, too short (%"U16_F"/%"U16_F")\n",
                     p->tot_len, next_hdr_offset));
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
        goto free_and_return;
 202af78:	0001883a 	nop
 202af7c:	00000106 	br	202af84 <ethernet_input+0x27c>
      }
      break;

    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
 202af80:	0001883a 	nop
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 202af84:	e13ffe17 	ldw	r4,-8(fp)
 202af88:	201d2f40 	call	201d2f4 <pbuf_free>
  return ERR_OK;
 202af8c:	0005883a 	mov	r2,zero
}
 202af90:	e037883a 	mov	sp,fp
 202af94:	dfc00117 	ldw	ra,4(sp)
 202af98:	df000017 	ldw	fp,0(sp)
 202af9c:	dec00204 	addi	sp,sp,8
 202afa0:	f800283a 	ret

0202afa4 <ethernet_output>:
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
err_t
ethernet_output(struct netif * netif, struct pbuf * p,
                const struct eth_addr * src, const struct eth_addr * dst,
                u16_t eth_type) {
 202afa4:	defff704 	addi	sp,sp,-36
 202afa8:	dfc00815 	stw	ra,32(sp)
 202afac:	df000715 	stw	fp,28(sp)
 202afb0:	df000704 	addi	fp,sp,28
 202afb4:	e13ffb15 	stw	r4,-20(fp)
 202afb8:	e17ffc15 	stw	r5,-16(fp)
 202afbc:	e1bffd15 	stw	r6,-12(fp)
 202afc0:	e1fffe15 	stw	r7,-8(fp)
 202afc4:	e0800217 	ldw	r2,8(fp)
 202afc8:	e0bfff0d 	sth	r2,-4(fp)
  struct eth_hdr *ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
 202afcc:	e0bfff0b 	ldhu	r2,-4(fp)
 202afd0:	1009883a 	mov	r4,r2
 202afd4:	20394740 	call	2039474 <lwip_htons>
 202afd8:	e0bff90d 	sth	r2,-28(fp)

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && (defined(LWIP_HOOK_VLAN_SET) || LWIP_VLAN_PCP) */
  {
    if (pbuf_add_header(p, SIZEOF_ETH_HDR) != 0) {
 202afdc:	01400404 	movi	r5,16
 202afe0:	e13ffc17 	ldw	r4,-16(fp)
 202afe4:	201cff40 	call	201cff4 <pbuf_add_header>
 202afe8:	10803fcc 	andi	r2,r2,255
 202afec:	1000271e 	bne	r2,zero,202b08c <ethernet_output+0xe8>
    }
  }

  LWIP_ASSERT_CORE_LOCKED();

  ethhdr = (struct eth_hdr *)p->payload;
 202aff0:	e0bffc17 	ldw	r2,-16(fp)
 202aff4:	10800117 	ldw	r2,4(r2)
 202aff8:	e0bffa15 	stw	r2,-24(fp)
  ethhdr->type = eth_type_be;
 202affc:	e0bffa17 	ldw	r2,-24(fp)
 202b000:	e0fff90b 	ldhu	r3,-28(fp)
 202b004:	19403fcc 	andi	r5,r3,255
 202b008:	10c00383 	ldbu	r3,14(r2)
 202b00c:	1806703a 	and	r3,r3,zero
 202b010:	1809883a 	mov	r4,r3
 202b014:	2807883a 	mov	r3,r5
 202b018:	20c6b03a 	or	r3,r4,r3
 202b01c:	10c00385 	stb	r3,14(r2)
 202b020:	e0fff90b 	ldhu	r3,-28(fp)
 202b024:	1806d23a 	srli	r3,r3,8
 202b028:	197fffcc 	andi	r5,r3,65535
 202b02c:	10c003c3 	ldbu	r3,15(r2)
 202b030:	1806703a 	and	r3,r3,zero
 202b034:	1809883a 	mov	r4,r3
 202b038:	2807883a 	mov	r3,r5
 202b03c:	20c6b03a 	or	r3,r4,r3
 202b040:	10c003c5 	stb	r3,15(r2)
  SMEMCPY(&ethhdr->dest, dst, ETH_HWADDR_LEN);
 202b044:	e0bffa17 	ldw	r2,-24(fp)
 202b048:	10800084 	addi	r2,r2,2
 202b04c:	01800184 	movi	r6,6
 202b050:	e17ffe17 	ldw	r5,-8(fp)
 202b054:	1009883a 	mov	r4,r2
 202b058:	2005e580 	call	2005e58 <memcpy>
  SMEMCPY(&ethhdr->src,  src, ETH_HWADDR_LEN);
 202b05c:	e0bffa17 	ldw	r2,-24(fp)
 202b060:	10800204 	addi	r2,r2,8
 202b064:	01800184 	movi	r6,6
 202b068:	e17ffd17 	ldw	r5,-12(fp)
 202b06c:	1009883a 	mov	r4,r2
 202b070:	2005e580 	call	2005e58 <memcpy>
              (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
              ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
 202b074:	e0bffb17 	ldw	r2,-20(fp)
 202b078:	10800617 	ldw	r2,24(r2)
 202b07c:	e17ffc17 	ldw	r5,-16(fp)
 202b080:	e13ffb17 	ldw	r4,-20(fp)
 202b084:	103ee83a 	callr	r2
 202b088:	00000906 	br	202b0b0 <ethernet_output+0x10c>
    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && (defined(LWIP_HOOK_VLAN_SET) || LWIP_VLAN_PCP) */
  {
    if (pbuf_add_header(p, SIZEOF_ETH_HDR) != 0) {
      goto pbuf_header_failed;
 202b08c:	0001883a 	nop
  return netif->linkoutput(netif, p);

pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
              ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
 202b090:	008085f4 	movhi	r2,535
 202b094:	10bd8204 	addi	r2,r2,-2552
 202b098:	10800517 	ldw	r2,20(r2)
 202b09c:	10c00044 	addi	r3,r2,1
 202b0a0:	008085f4 	movhi	r2,535
 202b0a4:	10bd8204 	addi	r2,r2,-2552
 202b0a8:	10c00515 	stw	r3,20(r2)
  return ERR_BUF;
 202b0ac:	00bfff84 	movi	r2,-2
}
 202b0b0:	e037883a 	mov	sp,fp
 202b0b4:	dfc00117 	ldw	ra,4(sp)
 202b0b8:	df000017 	ldw	fp,0(sp)
 202b0bc:	dec00204 	addi	sp,sp,8
 202b0c0:	f800283a 	ret

0202b0c4 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 202b0c4:	defffd04 	addi	sp,sp,-12
 202b0c8:	dfc00215 	stw	ra,8(sp)
 202b0cc:	df000115 	stw	fp,4(sp)
 202b0d0:	df000104 	addi	fp,sp,4
 202b0d4:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 202b0d8:	d1600804 	addi	r5,gp,-32736
 202b0dc:	e13fff17 	ldw	r4,-4(fp)
 202b0e0:	202e1380 	call	202e138 <alt_dev_llist_insert>
}
 202b0e4:	e037883a 	mov	sp,fp
 202b0e8:	dfc00117 	ldw	ra,4(sp)
 202b0ec:	df000017 	ldw	fp,0(sp)
 202b0f0:	dec00204 	addi	sp,sp,8
 202b0f4:	f800283a 	ret

0202b0f8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 202b0f8:	defffd04 	addi	sp,sp,-12
 202b0fc:	dfc00215 	stw	ra,8(sp)
 202b100:	df000115 	stw	fp,4(sp)
 202b104:	df000104 	addi	fp,sp,4
 202b108:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU_0, cpu_0);
 202b10c:	202eb980 	call	202eb98 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 202b110:	00800044 	movi	r2,1
 202b114:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 202b118:	0001883a 	nop
 202b11c:	e037883a 	mov	sp,fp
 202b120:	dfc00117 	ldw	ra,4(sp)
 202b124:	df000017 	ldw	fp,0(sp)
 202b128:	dec00204 	addi	sp,sp,8
 202b12c:	f800283a 	ret

0202b130 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 202b130:	defffe04 	addi	sp,sp,-8
 202b134:	dfc00115 	stw	ra,4(sp)
 202b138:	df000015 	stw	fp,0(sp)
 202b13c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
 202b140:	01c0fa04 	movi	r7,1000
 202b144:	018000c4 	movi	r6,3
 202b148:	000b883a 	mov	r5,zero
 202b14c:	01014134 	movhi	r4,1284
 202b150:	21040804 	addi	r4,r4,4128
 202b154:	202cb500 	call	202cb50 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 202b158:	01800084 	movi	r6,2
 202b15c:	000b883a 	mov	r5,zero
 202b160:	01008174 	movhi	r4,517
 202b164:	21265404 	addi	r4,r4,-26288
 202b168:	202b3400 	call	202b340 <altera_avalon_jtag_uart_init>
 202b16c:	01008174 	movhi	r4,517
 202b170:	21264a04 	addi	r4,r4,-26328
 202b174:	202b0c40 	call	202b0c4 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TSE_RX_0, sgdma_tse_rx_0);
 202b178:	000d883a 	mov	r6,zero
 202b17c:	000b883a 	mov	r5,zero
 202b180:	01008174 	movhi	r4,517
 202b184:	212a6404 	addi	r4,r4,-22128
 202b188:	202ca300 	call	202ca30 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TSE_TX_0, sgdma_tse_tx_0);
 202b18c:	01800044 	movi	r6,1
 202b190:	000b883a 	mov	r5,zero
 202b194:	01008174 	movhi	r4,517
 202b198:	212a7004 	addi	r4,r4,-22080
 202b19c:	202ca300 	call	202ca30 <alt_avalon_sgdma_init>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
 202b1a0:	01800104 	movi	r6,4
 202b1a4:	000b883a 	mov	r5,zero
 202b1a8:	01008174 	movhi	r4,517
 202b1ac:	212a8604 	addi	r4,r4,-21992
 202b1b0:	202ccdc0 	call	202ccdc <altera_avalon_uart_init>
 202b1b4:	01008174 	movhi	r4,517
 202b1b8:	212a7c04 	addi	r4,r4,-22032
 202b1bc:	202b0c40 	call	202b0c4 <alt_dev_reg>
    ALTERA_ETH_TSE_INIT ( TSE_MAC_0, tse_mac_0);
 202b1c0:	0001883a 	nop
}
 202b1c4:	0001883a 	nop
 202b1c8:	e037883a 	mov	sp,fp
 202b1cc:	dfc00117 	ldw	ra,4(sp)
 202b1d0:	df000017 	ldw	fp,0(sp)
 202b1d4:	dec00204 	addi	sp,sp,8
 202b1d8:	f800283a 	ret

0202b1dc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 202b1dc:	defffa04 	addi	sp,sp,-24
 202b1e0:	dfc00515 	stw	ra,20(sp)
 202b1e4:	df000415 	stw	fp,16(sp)
 202b1e8:	df000404 	addi	fp,sp,16
 202b1ec:	e13ffd15 	stw	r4,-12(fp)
 202b1f0:	e17ffe15 	stw	r5,-8(fp)
 202b1f4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 202b1f8:	e0bffd17 	ldw	r2,-12(fp)
 202b1fc:	10800017 	ldw	r2,0(r2)
 202b200:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 202b204:	e0bffc17 	ldw	r2,-16(fp)
 202b208:	10c00a04 	addi	r3,r2,40
 202b20c:	e0bffd17 	ldw	r2,-12(fp)
 202b210:	10800217 	ldw	r2,8(r2)
 202b214:	100f883a 	mov	r7,r2
 202b218:	e1bfff17 	ldw	r6,-4(fp)
 202b21c:	e17ffe17 	ldw	r5,-8(fp)
 202b220:	1809883a 	mov	r4,r3
 202b224:	202b88c0 	call	202b88c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 202b228:	e037883a 	mov	sp,fp
 202b22c:	dfc00117 	ldw	ra,4(sp)
 202b230:	df000017 	ldw	fp,0(sp)
 202b234:	dec00204 	addi	sp,sp,8
 202b238:	f800283a 	ret

0202b23c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 202b23c:	defffa04 	addi	sp,sp,-24
 202b240:	dfc00515 	stw	ra,20(sp)
 202b244:	df000415 	stw	fp,16(sp)
 202b248:	df000404 	addi	fp,sp,16
 202b24c:	e13ffd15 	stw	r4,-12(fp)
 202b250:	e17ffe15 	stw	r5,-8(fp)
 202b254:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 202b258:	e0bffd17 	ldw	r2,-12(fp)
 202b25c:	10800017 	ldw	r2,0(r2)
 202b260:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 202b264:	e0bffc17 	ldw	r2,-16(fp)
 202b268:	10c00a04 	addi	r3,r2,40
 202b26c:	e0bffd17 	ldw	r2,-12(fp)
 202b270:	10800217 	ldw	r2,8(r2)
 202b274:	100f883a 	mov	r7,r2
 202b278:	e1bfff17 	ldw	r6,-4(fp)
 202b27c:	e17ffe17 	ldw	r5,-8(fp)
 202b280:	1809883a 	mov	r4,r3
 202b284:	202bae40 	call	202bae4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 202b288:	e037883a 	mov	sp,fp
 202b28c:	dfc00117 	ldw	ra,4(sp)
 202b290:	df000017 	ldw	fp,0(sp)
 202b294:	dec00204 	addi	sp,sp,8
 202b298:	f800283a 	ret

0202b29c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 202b29c:	defffc04 	addi	sp,sp,-16
 202b2a0:	dfc00315 	stw	ra,12(sp)
 202b2a4:	df000215 	stw	fp,8(sp)
 202b2a8:	df000204 	addi	fp,sp,8
 202b2ac:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 202b2b0:	e0bfff17 	ldw	r2,-4(fp)
 202b2b4:	10800017 	ldw	r2,0(r2)
 202b2b8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 202b2bc:	e0bffe17 	ldw	r2,-8(fp)
 202b2c0:	10c00a04 	addi	r3,r2,40
 202b2c4:	e0bfff17 	ldw	r2,-4(fp)
 202b2c8:	10800217 	ldw	r2,8(r2)
 202b2cc:	100b883a 	mov	r5,r2
 202b2d0:	1809883a 	mov	r4,r3
 202b2d4:	202b7340 	call	202b734 <altera_avalon_jtag_uart_close>
}
 202b2d8:	e037883a 	mov	sp,fp
 202b2dc:	dfc00117 	ldw	ra,4(sp)
 202b2e0:	df000017 	ldw	fp,0(sp)
 202b2e4:	dec00204 	addi	sp,sp,8
 202b2e8:	f800283a 	ret

0202b2ec <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 202b2ec:	defffa04 	addi	sp,sp,-24
 202b2f0:	dfc00515 	stw	ra,20(sp)
 202b2f4:	df000415 	stw	fp,16(sp)
 202b2f8:	df000404 	addi	fp,sp,16
 202b2fc:	e13ffd15 	stw	r4,-12(fp)
 202b300:	e17ffe15 	stw	r5,-8(fp)
 202b304:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 202b308:	e0bffd17 	ldw	r2,-12(fp)
 202b30c:	10800017 	ldw	r2,0(r2)
 202b310:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 202b314:	e0bffc17 	ldw	r2,-16(fp)
 202b318:	10800a04 	addi	r2,r2,40
 202b31c:	e1bfff17 	ldw	r6,-4(fp)
 202b320:	e17ffe17 	ldw	r5,-8(fp)
 202b324:	1009883a 	mov	r4,r2
 202b328:	202b79c0 	call	202b79c <altera_avalon_jtag_uart_ioctl>
}
 202b32c:	e037883a 	mov	sp,fp
 202b330:	dfc00117 	ldw	ra,4(sp)
 202b334:	df000017 	ldw	fp,0(sp)
 202b338:	dec00204 	addi	sp,sp,8
 202b33c:	f800283a 	ret

0202b340 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 202b340:	defff304 	addi	sp,sp,-52
 202b344:	dfc00c15 	stw	ra,48(sp)
 202b348:	df000b15 	stw	fp,44(sp)
 202b34c:	df000b04 	addi	fp,sp,44
 202b350:	e13ff915 	stw	r4,-28(fp)
 202b354:	e17ffa15 	stw	r5,-24(fp)
 202b358:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
 202b35c:	e0bff917 	ldw	r2,-28(fp)
 202b360:	10800a04 	addi	r2,r2,40
 202b364:	e0bff615 	stw	r2,-40(fp)
 202b368:	00800044 	movi	r2,1
 202b36c:	e0bff88d 	sth	r2,-30(fp)
 202b370:	e0bff88b 	ldhu	r2,-30(fp)
 202b374:	10000226 	beq	r2,zero,202b380 <altera_avalon_jtag_uart_init+0x40>
 202b378:	e0bff88b 	ldhu	r2,-30(fp)
 202b37c:	00000106 	br	202b384 <altera_avalon_jtag_uart_init+0x44>
 202b380:	00800044 	movi	r2,1
 202b384:	e0fff88b 	ldhu	r3,-30(fp)
 202b388:	180b883a 	mov	r5,r3
 202b38c:	1009883a 	mov	r4,r2
 202b390:	200d7f00 	call	200d7f0 <xQueueCreateCountingSemaphore>
 202b394:	1007883a 	mov	r3,r2
 202b398:	e0bff617 	ldw	r2,-40(fp)
 202b39c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 202b3a0:	e0bff917 	ldw	r2,-28(fp)
 202b3a4:	10800b04 	addi	r2,r2,44
 202b3a8:	e0bff715 	stw	r2,-36(fp)
 202b3ac:	00800044 	movi	r2,1
 202b3b0:	e0bff80d 	sth	r2,-32(fp)
 202b3b4:	e0bff80b 	ldhu	r2,-32(fp)
 202b3b8:	10000226 	beq	r2,zero,202b3c4 <altera_avalon_jtag_uart_init+0x84>
 202b3bc:	e0bff80b 	ldhu	r2,-32(fp)
 202b3c0:	00000106 	br	202b3c8 <altera_avalon_jtag_uart_init+0x88>
 202b3c4:	00800044 	movi	r2,1
 202b3c8:	e0fff80b 	ldhu	r3,-32(fp)
 202b3cc:	180b883a 	mov	r5,r3
 202b3d0:	1009883a 	mov	r4,r2
 202b3d4:	200d7f00 	call	200d7f0 <xQueueCreateCountingSemaphore>
 202b3d8:	1007883a 	mov	r3,r2
 202b3dc:	e0bff717 	ldw	r2,-36(fp)
 202b3e0:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 202b3e4:	e0bff917 	ldw	r2,-28(fp)
 202b3e8:	00c00044 	movi	r3,1
 202b3ec:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 202b3f0:	e0bff917 	ldw	r2,-28(fp)
 202b3f4:	10800017 	ldw	r2,0(r2)
 202b3f8:	10800104 	addi	r2,r2,4
 202b3fc:	1007883a 	mov	r3,r2
 202b400:	e0bff917 	ldw	r2,-28(fp)
 202b404:	10800817 	ldw	r2,32(r2)
 202b408:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 202b40c:	e0bffa17 	ldw	r2,-24(fp)
 202b410:	e0fffb17 	ldw	r3,-20(fp)
 202b414:	d8000015 	stw	zero,0(sp)
 202b418:	e1fff917 	ldw	r7,-28(fp)
 202b41c:	018080f4 	movhi	r6,515
 202b420:	31ad2204 	addi	r6,r6,-19320
 202b424:	180b883a 	mov	r5,r3
 202b428:	1009883a 	mov	r4,r2
 202b42c:	202e4880 	call	202e488 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 202b430:	e0bff917 	ldw	r2,-28(fp)
 202b434:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 202b438:	e0bff917 	ldw	r2,-28(fp)
 202b43c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 202b440:	d0e7f917 	ldw	r3,-24604(gp)
 202b444:	e1fff917 	ldw	r7,-28(fp)
 202b448:	018080f4 	movhi	r6,515
 202b44c:	31ada504 	addi	r6,r6,-18796
 202b450:	180b883a 	mov	r5,r3
 202b454:	1009883a 	mov	r4,r2
 202b458:	202de7c0 	call	202de7c <alt_alarm_start>
 202b45c:	1000040e 	bge	r2,zero,202b470 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 202b460:	e0fff917 	ldw	r3,-28(fp)
 202b464:	00a00034 	movhi	r2,32768
 202b468:	10bfffc4 	addi	r2,r2,-1
 202b46c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 202b470:	0001883a 	nop
 202b474:	e037883a 	mov	sp,fp
 202b478:	dfc00117 	ldw	ra,4(sp)
 202b47c:	df000017 	ldw	fp,0(sp)
 202b480:	dec00204 	addi	sp,sp,8
 202b484:	f800283a 	ret

0202b488 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 202b488:	defff804 	addi	sp,sp,-32
 202b48c:	df000715 	stw	fp,28(sp)
 202b490:	df000704 	addi	fp,sp,28
 202b494:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 202b498:	e0bfff17 	ldw	r2,-4(fp)
 202b49c:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 202b4a0:	e0bffb17 	ldw	r2,-20(fp)
 202b4a4:	10800017 	ldw	r2,0(r2)
 202b4a8:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 202b4ac:	e0bffc17 	ldw	r2,-16(fp)
 202b4b0:	10800104 	addi	r2,r2,4
 202b4b4:	10800037 	ldwio	r2,0(r2)
 202b4b8:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 202b4bc:	e0bffd17 	ldw	r2,-12(fp)
 202b4c0:	1080c00c 	andi	r2,r2,768
 202b4c4:	10006d26 	beq	r2,zero,202b67c <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 202b4c8:	e0bffd17 	ldw	r2,-12(fp)
 202b4cc:	1080400c 	andi	r2,r2,256
 202b4d0:	10003526 	beq	r2,zero,202b5a8 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 202b4d4:	00800074 	movhi	r2,1
 202b4d8:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 202b4dc:	e0bffb17 	ldw	r2,-20(fp)
 202b4e0:	10800c17 	ldw	r2,48(r2)
 202b4e4:	10800044 	addi	r2,r2,1
 202b4e8:	1081ffcc 	andi	r2,r2,2047
 202b4ec:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 202b4f0:	e0bffb17 	ldw	r2,-20(fp)
 202b4f4:	10c00d17 	ldw	r3,52(r2)
 202b4f8:	e0bffe17 	ldw	r2,-8(fp)
 202b4fc:	18801526 	beq	r3,r2,202b554 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 202b500:	e0bffc17 	ldw	r2,-16(fp)
 202b504:	10800037 	ldwio	r2,0(r2)
 202b508:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 202b50c:	e0bff917 	ldw	r2,-28(fp)
 202b510:	10a0000c 	andi	r2,r2,32768
 202b514:	10001126 	beq	r2,zero,202b55c <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 202b518:	e0bffb17 	ldw	r2,-20(fp)
 202b51c:	10800c17 	ldw	r2,48(r2)
 202b520:	e0fff917 	ldw	r3,-28(fp)
 202b524:	1809883a 	mov	r4,r3
 202b528:	e0fffb17 	ldw	r3,-20(fp)
 202b52c:	1885883a 	add	r2,r3,r2
 202b530:	10801004 	addi	r2,r2,64
 202b534:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 202b538:	e0bffb17 	ldw	r2,-20(fp)
 202b53c:	10800c17 	ldw	r2,48(r2)
 202b540:	10800044 	addi	r2,r2,1
 202b544:	10c1ffcc 	andi	r3,r2,2047
 202b548:	e0bffb17 	ldw	r2,-20(fp)
 202b54c:	10c00c15 	stw	r3,48(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 202b550:	003fe206 	br	202b4dc <__alt_mem_mem_0+0xfd00b4dc>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 202b554:	0001883a 	nop
 202b558:	00000106 	br	202b560 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 202b55c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 202b560:	e0bff917 	ldw	r2,-28(fp)
 202b564:	10bfffec 	andhi	r2,r2,65535
 202b568:	10000f26 	beq	r2,zero,202b5a8 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 202b56c:	e0bffb17 	ldw	r2,-20(fp)
 202b570:	10c00817 	ldw	r3,32(r2)
 202b574:	00bfff84 	movi	r2,-2
 202b578:	1886703a 	and	r3,r3,r2
 202b57c:	e0bffb17 	ldw	r2,-20(fp)
 202b580:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 202b584:	e0bffc17 	ldw	r2,-16(fp)
 202b588:	10800104 	addi	r2,r2,4
 202b58c:	1007883a 	mov	r3,r2
 202b590:	e0bffb17 	ldw	r2,-20(fp)
 202b594:	10800817 	ldw	r2,32(r2)
 202b598:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 202b59c:	e0bffc17 	ldw	r2,-16(fp)
 202b5a0:	10800104 	addi	r2,r2,4
 202b5a4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 202b5a8:	e0bffd17 	ldw	r2,-12(fp)
 202b5ac:	1080800c 	andi	r2,r2,512
 202b5b0:	103fbe26 	beq	r2,zero,202b4ac <__alt_mem_mem_0+0xfd00b4ac>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 202b5b4:	e0bffd17 	ldw	r2,-12(fp)
 202b5b8:	1004d43a 	srli	r2,r2,16
 202b5bc:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 202b5c0:	00001406 	br	202b614 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 202b5c4:	e0bffc17 	ldw	r2,-16(fp)
 202b5c8:	e0fffb17 	ldw	r3,-20(fp)
 202b5cc:	18c00f17 	ldw	r3,60(r3)
 202b5d0:	e13ffb17 	ldw	r4,-20(fp)
 202b5d4:	20c7883a 	add	r3,r4,r3
 202b5d8:	18c21004 	addi	r3,r3,2112
 202b5dc:	18c00003 	ldbu	r3,0(r3)
 202b5e0:	18c03fcc 	andi	r3,r3,255
 202b5e4:	18c0201c 	xori	r3,r3,128
 202b5e8:	18ffe004 	addi	r3,r3,-128
 202b5ec:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 202b5f0:	e0bffb17 	ldw	r2,-20(fp)
 202b5f4:	10800f17 	ldw	r2,60(r2)
 202b5f8:	10800044 	addi	r2,r2,1
 202b5fc:	10c1ffcc 	andi	r3,r2,2047
 202b600:	e0bffb17 	ldw	r2,-20(fp)
 202b604:	10c00f15 	stw	r3,60(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 202b608:	e0bffa17 	ldw	r2,-24(fp)
 202b60c:	10bfffc4 	addi	r2,r2,-1
 202b610:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 202b614:	e0bffa17 	ldw	r2,-24(fp)
 202b618:	10000526 	beq	r2,zero,202b630 <altera_avalon_jtag_uart_irq+0x1a8>
 202b61c:	e0bffb17 	ldw	r2,-20(fp)
 202b620:	10c00f17 	ldw	r3,60(r2)
 202b624:	e0bffb17 	ldw	r2,-20(fp)
 202b628:	10800e17 	ldw	r2,56(r2)
 202b62c:	18bfe51e 	bne	r3,r2,202b5c4 <__alt_mem_mem_0+0xfd00b5c4>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 202b630:	e0bffa17 	ldw	r2,-24(fp)
 202b634:	103f9d26 	beq	r2,zero,202b4ac <__alt_mem_mem_0+0xfd00b4ac>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 202b638:	e0bffb17 	ldw	r2,-20(fp)
 202b63c:	10c00817 	ldw	r3,32(r2)
 202b640:	00bfff44 	movi	r2,-3
 202b644:	1886703a 	and	r3,r3,r2
 202b648:	e0bffb17 	ldw	r2,-20(fp)
 202b64c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 202b650:	e0bffb17 	ldw	r2,-20(fp)
 202b654:	10800017 	ldw	r2,0(r2)
 202b658:	10800104 	addi	r2,r2,4
 202b65c:	1007883a 	mov	r3,r2
 202b660:	e0bffb17 	ldw	r2,-20(fp)
 202b664:	10800817 	ldw	r2,32(r2)
 202b668:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 202b66c:	e0bffc17 	ldw	r2,-16(fp)
 202b670:	10800104 	addi	r2,r2,4
 202b674:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 202b678:	003f8c06 	br	202b4ac <__alt_mem_mem_0+0xfd00b4ac>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 202b67c:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 202b680:	0001883a 	nop
 202b684:	e037883a 	mov	sp,fp
 202b688:	df000017 	ldw	fp,0(sp)
 202b68c:	dec00104 	addi	sp,sp,4
 202b690:	f800283a 	ret

0202b694 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 202b694:	defff804 	addi	sp,sp,-32
 202b698:	df000715 	stw	fp,28(sp)
 202b69c:	df000704 	addi	fp,sp,28
 202b6a0:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 202b6a4:	e0bffb17 	ldw	r2,-20(fp)
 202b6a8:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 202b6ac:	e0bff917 	ldw	r2,-28(fp)
 202b6b0:	10800017 	ldw	r2,0(r2)
 202b6b4:	10800104 	addi	r2,r2,4
 202b6b8:	10800037 	ldwio	r2,0(r2)
 202b6bc:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 202b6c0:	e0bffa17 	ldw	r2,-24(fp)
 202b6c4:	1081000c 	andi	r2,r2,1024
 202b6c8:	10000b26 	beq	r2,zero,202b6f8 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 202b6cc:	e0bff917 	ldw	r2,-28(fp)
 202b6d0:	10800017 	ldw	r2,0(r2)
 202b6d4:	10800104 	addi	r2,r2,4
 202b6d8:	1007883a 	mov	r3,r2
 202b6dc:	e0bff917 	ldw	r2,-28(fp)
 202b6e0:	10800817 	ldw	r2,32(r2)
 202b6e4:	10810014 	ori	r2,r2,1024
 202b6e8:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 202b6ec:	e0bff917 	ldw	r2,-28(fp)
 202b6f0:	10000915 	stw	zero,36(r2)
 202b6f4:	00000a06 	br	202b720 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 202b6f8:	e0bff917 	ldw	r2,-28(fp)
 202b6fc:	10c00917 	ldw	r3,36(r2)
 202b700:	00a00034 	movhi	r2,32768
 202b704:	10bfff04 	addi	r2,r2,-4
 202b708:	10c00536 	bltu	r2,r3,202b720 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 202b70c:	e0bff917 	ldw	r2,-28(fp)
 202b710:	10800917 	ldw	r2,36(r2)
 202b714:	10c00044 	addi	r3,r2,1
 202b718:	e0bff917 	ldw	r2,-28(fp)
 202b71c:	10c00915 	stw	r3,36(r2)
 202b720:	d0a7f917 	ldw	r2,-24604(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 202b724:	e037883a 	mov	sp,fp
 202b728:	df000017 	ldw	fp,0(sp)
 202b72c:	dec00104 	addi	sp,sp,4
 202b730:	f800283a 	ret

0202b734 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 202b734:	defffd04 	addi	sp,sp,-12
 202b738:	df000215 	stw	fp,8(sp)
 202b73c:	df000204 	addi	fp,sp,8
 202b740:	e13ffe15 	stw	r4,-8(fp)
 202b744:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 202b748:	00000506 	br	202b760 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 202b74c:	e0bfff17 	ldw	r2,-4(fp)
 202b750:	1090000c 	andi	r2,r2,16384
 202b754:	10000226 	beq	r2,zero,202b760 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 202b758:	00bffd44 	movi	r2,-11
 202b75c:	00000b06 	br	202b78c <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 202b760:	e0bffe17 	ldw	r2,-8(fp)
 202b764:	10c00f17 	ldw	r3,60(r2)
 202b768:	e0bffe17 	ldw	r2,-8(fp)
 202b76c:	10800e17 	ldw	r2,56(r2)
 202b770:	18800526 	beq	r3,r2,202b788 <altera_avalon_jtag_uart_close+0x54>
 202b774:	e0bffe17 	ldw	r2,-8(fp)
 202b778:	10c00917 	ldw	r3,36(r2)
 202b77c:	e0bffe17 	ldw	r2,-8(fp)
 202b780:	10800117 	ldw	r2,4(r2)
 202b784:	18bff136 	bltu	r3,r2,202b74c <__alt_mem_mem_0+0xfd00b74c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 202b788:	0005883a 	mov	r2,zero
}
 202b78c:	e037883a 	mov	sp,fp
 202b790:	df000017 	ldw	fp,0(sp)
 202b794:	dec00104 	addi	sp,sp,4
 202b798:	f800283a 	ret

0202b79c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 202b79c:	defffa04 	addi	sp,sp,-24
 202b7a0:	df000515 	stw	fp,20(sp)
 202b7a4:	df000504 	addi	fp,sp,20
 202b7a8:	e13ffd15 	stw	r4,-12(fp)
 202b7ac:	e17ffe15 	stw	r5,-8(fp)
 202b7b0:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 202b7b4:	00bff9c4 	movi	r2,-25
 202b7b8:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 202b7bc:	e0bffe17 	ldw	r2,-8(fp)
 202b7c0:	10da8060 	cmpeqi	r3,r2,27137
 202b7c4:	1800031e 	bne	r3,zero,202b7d4 <altera_avalon_jtag_uart_ioctl+0x38>
 202b7c8:	109a80a0 	cmpeqi	r2,r2,27138
 202b7cc:	1000181e 	bne	r2,zero,202b830 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 202b7d0:	00002906 	br	202b878 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 202b7d4:	e0bffd17 	ldw	r2,-12(fp)
 202b7d8:	10c00117 	ldw	r3,4(r2)
 202b7dc:	00a00034 	movhi	r2,32768
 202b7e0:	10bfffc4 	addi	r2,r2,-1
 202b7e4:	18802126 	beq	r3,r2,202b86c <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 202b7e8:	e0bfff17 	ldw	r2,-4(fp)
 202b7ec:	10800017 	ldw	r2,0(r2)
 202b7f0:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 202b7f4:	e0bffc17 	ldw	r2,-16(fp)
 202b7f8:	10800090 	cmplti	r2,r2,2
 202b7fc:	1000061e 	bne	r2,zero,202b818 <altera_avalon_jtag_uart_ioctl+0x7c>
 202b800:	e0fffc17 	ldw	r3,-16(fp)
 202b804:	00a00034 	movhi	r2,32768
 202b808:	10bfffc4 	addi	r2,r2,-1
 202b80c:	18800226 	beq	r3,r2,202b818 <altera_avalon_jtag_uart_ioctl+0x7c>
 202b810:	e0bffc17 	ldw	r2,-16(fp)
 202b814:	00000206 	br	202b820 <altera_avalon_jtag_uart_ioctl+0x84>
 202b818:	00a00034 	movhi	r2,32768
 202b81c:	10bfff84 	addi	r2,r2,-2
 202b820:	e0fffd17 	ldw	r3,-12(fp)
 202b824:	18800115 	stw	r2,4(r3)
      rc = 0;
 202b828:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 202b82c:	00000f06 	br	202b86c <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 202b830:	e0bffd17 	ldw	r2,-12(fp)
 202b834:	10c00117 	ldw	r3,4(r2)
 202b838:	00a00034 	movhi	r2,32768
 202b83c:	10bfffc4 	addi	r2,r2,-1
 202b840:	18800c26 	beq	r3,r2,202b874 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 202b844:	e0bffd17 	ldw	r2,-12(fp)
 202b848:	10c00917 	ldw	r3,36(r2)
 202b84c:	e0bffd17 	ldw	r2,-12(fp)
 202b850:	10800117 	ldw	r2,4(r2)
 202b854:	1885803a 	cmpltu	r2,r3,r2
 202b858:	10c03fcc 	andi	r3,r2,255
 202b85c:	e0bfff17 	ldw	r2,-4(fp)
 202b860:	10c00015 	stw	r3,0(r2)
      rc = 0;
 202b864:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 202b868:	00000206 	br	202b874 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 202b86c:	0001883a 	nop
 202b870:	00000106 	br	202b878 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 202b874:	0001883a 	nop

  default:
    break;
  }

  return rc;
 202b878:	e0bffb17 	ldw	r2,-20(fp)
}
 202b87c:	e037883a 	mov	sp,fp
 202b880:	df000017 	ldw	fp,0(sp)
 202b884:	dec00104 	addi	sp,sp,4
 202b888:	f800283a 	ret

0202b88c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 202b88c:	defff004 	addi	sp,sp,-64
 202b890:	dfc00f15 	stw	ra,60(sp)
 202b894:	df000e15 	stw	fp,56(sp)
 202b898:	df000e04 	addi	fp,sp,56
 202b89c:	e13ffb15 	stw	r4,-20(fp)
 202b8a0:	e17ffc15 	stw	r5,-16(fp)
 202b8a4:	e1bffd15 	stw	r6,-12(fp)
 202b8a8:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 202b8ac:	e0bffc17 	ldw	r2,-16(fp)
 202b8b0:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 202b8b4:	e0bffb17 	ldw	r2,-20(fp)
 202b8b8:	10800a17 	ldw	r2,40(r2)
 202b8bc:	e0bff915 	stw	r2,-28(fp)
 202b8c0:	e03ffa0d 	sth	zero,-24(fp)
 * converted into the functions return value.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (xSemaphoreHandle sem, alt_u16 timeout)
{
	return xSemaphoreTake(sem, timeout) ? 0 : -1;
 202b8c4:	e0bffa0b 	ldhu	r2,-24(fp)
 202b8c8:	100b883a 	mov	r5,r2
 202b8cc:	e13ff917 	ldw	r4,-28(fp)
 202b8d0:	200ddd40 	call	200ddd4 <xQueueSemaphoreTake>

  while (space > 0)
 202b8d4:	00004706 	br	202b9f4 <altera_avalon_jtag_uart_read+0x168>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 202b8d8:	e0bffb17 	ldw	r2,-20(fp)
 202b8dc:	10800c17 	ldw	r2,48(r2)
 202b8e0:	e0bff515 	stw	r2,-44(fp)
      out = sp->rx_out;
 202b8e4:	e0bffb17 	ldw	r2,-20(fp)
 202b8e8:	10800d17 	ldw	r2,52(r2)
 202b8ec:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
 202b8f0:	e0fff517 	ldw	r3,-44(fp)
 202b8f4:	e0bff617 	ldw	r2,-40(fp)
 202b8f8:	18800536 	bltu	r3,r2,202b910 <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 202b8fc:	e0fff517 	ldw	r3,-44(fp)
 202b900:	e0bff617 	ldw	r2,-40(fp)
 202b904:	1885c83a 	sub	r2,r3,r2
 202b908:	e0bff315 	stw	r2,-52(fp)
 202b90c:	00000406 	br	202b920 <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 202b910:	00c20004 	movi	r3,2048
 202b914:	e0bff617 	ldw	r2,-40(fp)
 202b918:	1885c83a 	sub	r2,r3,r2
 202b91c:	e0bff315 	stw	r2,-52(fp)

      if (n == 0)
 202b920:	e0bff317 	ldw	r2,-52(fp)
 202b924:	10001e26 	beq	r2,zero,202b9a0 <altera_avalon_jtag_uart_read+0x114>
        break; /* No more data available */

      if (n > space)
 202b928:	e0fffd17 	ldw	r3,-12(fp)
 202b92c:	e0bff317 	ldw	r2,-52(fp)
 202b930:	1880022e 	bgeu	r3,r2,202b93c <altera_avalon_jtag_uart_read+0xb0>
        n = space;
 202b934:	e0bffd17 	ldw	r2,-12(fp)
 202b938:	e0bff315 	stw	r2,-52(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 202b93c:	e0bffb17 	ldw	r2,-20(fp)
 202b940:	10c01004 	addi	r3,r2,64
 202b944:	e0bff617 	ldw	r2,-40(fp)
 202b948:	1885883a 	add	r2,r3,r2
 202b94c:	e1bff317 	ldw	r6,-52(fp)
 202b950:	100b883a 	mov	r5,r2
 202b954:	e13ff217 	ldw	r4,-56(fp)
 202b958:	2005e580 	call	2005e58 <memcpy>
      ptr   += n;
 202b95c:	e0fff217 	ldw	r3,-56(fp)
 202b960:	e0bff317 	ldw	r2,-52(fp)
 202b964:	1885883a 	add	r2,r3,r2
 202b968:	e0bff215 	stw	r2,-56(fp)
      space -= n;
 202b96c:	e0fffd17 	ldw	r3,-12(fp)
 202b970:	e0bff317 	ldw	r2,-52(fp)
 202b974:	1885c83a 	sub	r2,r3,r2
 202b978:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 202b97c:	e0fff617 	ldw	r3,-40(fp)
 202b980:	e0bff317 	ldw	r2,-52(fp)
 202b984:	1885883a 	add	r2,r3,r2
 202b988:	10c1ffcc 	andi	r3,r2,2047
 202b98c:	e0bffb17 	ldw	r2,-20(fp)
 202b990:	10c00d15 	stw	r3,52(r2)
    }
    while (space > 0);
 202b994:	e0bffd17 	ldw	r2,-12(fp)
 202b998:	00bfcf16 	blt	zero,r2,202b8d8 <__alt_mem_mem_0+0xfd00b8d8>
 202b99c:	00000106 	br	202b9a4 <altera_avalon_jtag_uart_read+0x118>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 202b9a0:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 202b9a4:	e0fff217 	ldw	r3,-56(fp)
 202b9a8:	e0bffc17 	ldw	r2,-16(fp)
 202b9ac:	1880141e 	bne	r3,r2,202ba00 <altera_avalon_jtag_uart_read+0x174>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 202b9b0:	e0bffe17 	ldw	r2,-8(fp)
 202b9b4:	1090000c 	andi	r2,r2,16384
 202b9b8:	1000131e 	bne	r2,zero,202ba08 <altera_avalon_jtag_uart_read+0x17c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 202b9bc:	0001883a 	nop
 202b9c0:	e0bffb17 	ldw	r2,-20(fp)
 202b9c4:	10c00c17 	ldw	r3,48(r2)
 202b9c8:	e0bff517 	ldw	r2,-44(fp)
 202b9cc:	1880051e 	bne	r3,r2,202b9e4 <altera_avalon_jtag_uart_read+0x158>
 202b9d0:	e0bffb17 	ldw	r2,-20(fp)
 202b9d4:	10c00917 	ldw	r3,36(r2)
 202b9d8:	e0bffb17 	ldw	r2,-20(fp)
 202b9dc:	10800117 	ldw	r2,4(r2)
 202b9e0:	18bff736 	bltu	r3,r2,202b9c0 <__alt_mem_mem_0+0xfd00b9c0>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 202b9e4:	e0bffb17 	ldw	r2,-20(fp)
 202b9e8:	10c00c17 	ldw	r3,48(r2)
 202b9ec:	e0bff517 	ldw	r2,-44(fp)
 202b9f0:	18800726 	beq	r3,r2,202ba10 <altera_avalon_jtag_uart_read+0x184>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 202b9f4:	e0bffd17 	ldw	r2,-12(fp)
 202b9f8:	00bfb716 	blt	zero,r2,202b8d8 <__alt_mem_mem_0+0xfd00b8d8>
 202b9fc:	00000506 	br	202ba14 <altera_avalon_jtag_uart_read+0x188>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 202ba00:	0001883a 	nop
 202ba04:	00000306 	br	202ba14 <altera_avalon_jtag_uart_read+0x188>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 202ba08:	0001883a 	nop
 202ba0c:	00000106 	br	202ba14 <altera_avalon_jtag_uart_read+0x188>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 202ba10:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 202ba14:	e0bffb17 	ldw	r2,-20(fp)
 202ba18:	10800a17 	ldw	r2,40(r2)
 202ba1c:	000f883a 	mov	r7,zero
 202ba20:	000d883a 	mov	r6,zero
 202ba24:	000b883a 	mov	r5,zero
 202ba28:	1009883a 	mov	r4,r2
 202ba2c:	200d8480 	call	200d848 <xQueueGenericSend>

  if (ptr != buffer)
 202ba30:	e0fff217 	ldw	r3,-56(fp)
 202ba34:	e0bffc17 	ldw	r2,-16(fp)
 202ba38:	18801826 	beq	r3,r2,202ba9c <altera_avalon_jtag_uart_read+0x210>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202ba3c:	0005303a 	rdctl	r2,status
 202ba40:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202ba44:	e0fff817 	ldw	r3,-32(fp)
 202ba48:	00bfff84 	movi	r2,-2
 202ba4c:	1884703a 	and	r2,r3,r2
 202ba50:	1001703a 	wrctl	status,r2
  
  return context;
 202ba54:	e0bff817 	ldw	r2,-32(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 202ba58:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 202ba5c:	e0bffb17 	ldw	r2,-20(fp)
 202ba60:	10800817 	ldw	r2,32(r2)
 202ba64:	10c00054 	ori	r3,r2,1
 202ba68:	e0bffb17 	ldw	r2,-20(fp)
 202ba6c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 202ba70:	e0bffb17 	ldw	r2,-20(fp)
 202ba74:	10800017 	ldw	r2,0(r2)
 202ba78:	10800104 	addi	r2,r2,4
 202ba7c:	1007883a 	mov	r3,r2
 202ba80:	e0bffb17 	ldw	r2,-20(fp)
 202ba84:	10800817 	ldw	r2,32(r2)
 202ba88:	18800035 	stwio	r2,0(r3)
 202ba8c:	e0bff717 	ldw	r2,-36(fp)
 202ba90:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202ba94:	e0bff417 	ldw	r2,-48(fp)
 202ba98:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 202ba9c:	e0fff217 	ldw	r3,-56(fp)
 202baa0:	e0bffc17 	ldw	r2,-16(fp)
 202baa4:	18800426 	beq	r3,r2,202bab8 <altera_avalon_jtag_uart_read+0x22c>
    return ptr - buffer;
 202baa8:	e0fff217 	ldw	r3,-56(fp)
 202baac:	e0bffc17 	ldw	r2,-16(fp)
 202bab0:	1885c83a 	sub	r2,r3,r2
 202bab4:	00000606 	br	202bad0 <altera_avalon_jtag_uart_read+0x244>
  else if (flags & O_NONBLOCK)
 202bab8:	e0bffe17 	ldw	r2,-8(fp)
 202babc:	1090000c 	andi	r2,r2,16384
 202bac0:	10000226 	beq	r2,zero,202bacc <altera_avalon_jtag_uart_read+0x240>
    return -EWOULDBLOCK;
 202bac4:	00bffd44 	movi	r2,-11
 202bac8:	00000106 	br	202bad0 <altera_avalon_jtag_uart_read+0x244>
  else
    return -EIO;
 202bacc:	00bffec4 	movi	r2,-5
}
 202bad0:	e037883a 	mov	sp,fp
 202bad4:	dfc00117 	ldw	ra,4(sp)
 202bad8:	df000017 	ldw	fp,0(sp)
 202badc:	dec00204 	addi	sp,sp,8
 202bae0:	f800283a 	ret

0202bae4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 202bae4:	defff004 	addi	sp,sp,-64
 202bae8:	dfc00f15 	stw	ra,60(sp)
 202baec:	df000e15 	stw	fp,56(sp)
 202baf0:	df000e04 	addi	fp,sp,56
 202baf4:	e13ffb15 	stw	r4,-20(fp)
 202baf8:	e17ffc15 	stw	r5,-16(fp)
 202bafc:	e1bffd15 	stw	r6,-12(fp)
 202bb00:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 202bb04:	e03ff215 	stw	zero,-56(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 202bb08:	e0bffc17 	ldw	r2,-16(fp)
 202bb0c:	e0bff415 	stw	r2,-48(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 202bb10:	e0bffb17 	ldw	r2,-20(fp)
 202bb14:	10800b17 	ldw	r2,44(r2)
 202bb18:	e0bff915 	stw	r2,-28(fp)
 202bb1c:	e03ffa0d 	sth	zero,-24(fp)
 202bb20:	e0bffa0b 	ldhu	r2,-24(fp)
 202bb24:	100b883a 	mov	r5,r2
 202bb28:	e13ff917 	ldw	r4,-28(fp)
 202bb2c:	200ddd40 	call	200ddd4 <xQueueSemaphoreTake>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 202bb30:	00003706 	br	202bc10 <altera_avalon_jtag_uart_write+0x12c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 202bb34:	e0bffb17 	ldw	r2,-20(fp)
 202bb38:	10800e17 	ldw	r2,56(r2)
 202bb3c:	e0bff615 	stw	r2,-40(fp)
      out = sp->tx_out;
 202bb40:	e0bffb17 	ldw	r2,-20(fp)
 202bb44:	10800f17 	ldw	r2,60(r2)
 202bb48:	e0bff215 	stw	r2,-56(fp)

      if (in < out)
 202bb4c:	e0fff617 	ldw	r3,-40(fp)
 202bb50:	e0bff217 	ldw	r2,-56(fp)
 202bb54:	1880062e 	bgeu	r3,r2,202bb70 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 202bb58:	e0fff217 	ldw	r3,-56(fp)
 202bb5c:	e0bff617 	ldw	r2,-40(fp)
 202bb60:	1885c83a 	sub	r2,r3,r2
 202bb64:	10bfffc4 	addi	r2,r2,-1
 202bb68:	e0bff315 	stw	r2,-52(fp)
 202bb6c:	00000b06 	br	202bb9c <altera_avalon_jtag_uart_write+0xb8>
      else if (out > 0)
 202bb70:	e0bff217 	ldw	r2,-56(fp)
 202bb74:	10000526 	beq	r2,zero,202bb8c <altera_avalon_jtag_uart_write+0xa8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 202bb78:	00c20004 	movi	r3,2048
 202bb7c:	e0bff617 	ldw	r2,-40(fp)
 202bb80:	1885c83a 	sub	r2,r3,r2
 202bb84:	e0bff315 	stw	r2,-52(fp)
 202bb88:	00000406 	br	202bb9c <altera_avalon_jtag_uart_write+0xb8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 202bb8c:	00c1ffc4 	movi	r3,2047
 202bb90:	e0bff617 	ldw	r2,-40(fp)
 202bb94:	1885c83a 	sub	r2,r3,r2
 202bb98:	e0bff315 	stw	r2,-52(fp)

      if (n == 0)
 202bb9c:	e0bff317 	ldw	r2,-52(fp)
 202bba0:	10001e26 	beq	r2,zero,202bc1c <altera_avalon_jtag_uart_write+0x138>
        break;

      if (n > count)
 202bba4:	e0fffd17 	ldw	r3,-12(fp)
 202bba8:	e0bff317 	ldw	r2,-52(fp)
 202bbac:	1880022e 	bgeu	r3,r2,202bbb8 <altera_avalon_jtag_uart_write+0xd4>
        n = count;
 202bbb0:	e0bffd17 	ldw	r2,-12(fp)
 202bbb4:	e0bff315 	stw	r2,-52(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 202bbb8:	e0bffb17 	ldw	r2,-20(fp)
 202bbbc:	10c21004 	addi	r3,r2,2112
 202bbc0:	e0bff617 	ldw	r2,-40(fp)
 202bbc4:	1885883a 	add	r2,r3,r2
 202bbc8:	e1bff317 	ldw	r6,-52(fp)
 202bbcc:	e17ffc17 	ldw	r5,-16(fp)
 202bbd0:	1009883a 	mov	r4,r2
 202bbd4:	2005e580 	call	2005e58 <memcpy>
      ptr   += n;
 202bbd8:	e0fffc17 	ldw	r3,-16(fp)
 202bbdc:	e0bff317 	ldw	r2,-52(fp)
 202bbe0:	1885883a 	add	r2,r3,r2
 202bbe4:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 202bbe8:	e0fffd17 	ldw	r3,-12(fp)
 202bbec:	e0bff317 	ldw	r2,-52(fp)
 202bbf0:	1885c83a 	sub	r2,r3,r2
 202bbf4:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 202bbf8:	e0fff617 	ldw	r3,-40(fp)
 202bbfc:	e0bff317 	ldw	r2,-52(fp)
 202bc00:	1885883a 	add	r2,r3,r2
 202bc04:	10c1ffcc 	andi	r3,r2,2047
 202bc08:	e0bffb17 	ldw	r2,-20(fp)
 202bc0c:	10c00e15 	stw	r3,56(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 202bc10:	e0bffd17 	ldw	r2,-12(fp)
 202bc14:	00bfc716 	blt	zero,r2,202bb34 <__alt_mem_mem_0+0xfd00bb34>
 202bc18:	00000106 	br	202bc20 <altera_avalon_jtag_uart_write+0x13c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 202bc1c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202bc20:	0005303a 	rdctl	r2,status
 202bc24:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202bc28:	e0fff817 	ldw	r3,-32(fp)
 202bc2c:	00bfff84 	movi	r2,-2
 202bc30:	1884703a 	and	r2,r3,r2
 202bc34:	1001703a 	wrctl	status,r2
  
  return context;
 202bc38:	e0bff817 	ldw	r2,-32(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 202bc3c:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 202bc40:	e0bffb17 	ldw	r2,-20(fp)
 202bc44:	10800817 	ldw	r2,32(r2)
 202bc48:	10c00094 	ori	r3,r2,2
 202bc4c:	e0bffb17 	ldw	r2,-20(fp)
 202bc50:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 202bc54:	e0bffb17 	ldw	r2,-20(fp)
 202bc58:	10800017 	ldw	r2,0(r2)
 202bc5c:	10800104 	addi	r2,r2,4
 202bc60:	1007883a 	mov	r3,r2
 202bc64:	e0bffb17 	ldw	r2,-20(fp)
 202bc68:	10800817 	ldw	r2,32(r2)
 202bc6c:	18800035 	stwio	r2,0(r3)
 202bc70:	e0bff717 	ldw	r2,-36(fp)
 202bc74:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202bc78:	e0bff517 	ldw	r2,-44(fp)
 202bc7c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 202bc80:	e0bffd17 	ldw	r2,-12(fp)
 202bc84:	0080100e 	bge	zero,r2,202bcc8 <altera_avalon_jtag_uart_write+0x1e4>
    {
      if (flags & O_NONBLOCK)
 202bc88:	e0bffe17 	ldw	r2,-8(fp)
 202bc8c:	1090000c 	andi	r2,r2,16384
 202bc90:	1000101e 	bne	r2,zero,202bcd4 <altera_avalon_jtag_uart_write+0x1f0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 202bc94:	0001883a 	nop
 202bc98:	e0bffb17 	ldw	r2,-20(fp)
 202bc9c:	10c00f17 	ldw	r3,60(r2)
 202bca0:	e0bff217 	ldw	r2,-56(fp)
 202bca4:	1880051e 	bne	r3,r2,202bcbc <altera_avalon_jtag_uart_write+0x1d8>
 202bca8:	e0bffb17 	ldw	r2,-20(fp)
 202bcac:	10c00917 	ldw	r3,36(r2)
 202bcb0:	e0bffb17 	ldw	r2,-20(fp)
 202bcb4:	10800117 	ldw	r2,4(r2)
 202bcb8:	18bff736 	bltu	r3,r2,202bc98 <__alt_mem_mem_0+0xfd00bc98>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 202bcbc:	e0bffb17 	ldw	r2,-20(fp)
 202bcc0:	10800917 	ldw	r2,36(r2)
 202bcc4:	1000051e 	bne	r2,zero,202bcdc <altera_avalon_jtag_uart_write+0x1f8>
         break;
    }
  }
  while (count > 0);
 202bcc8:	e0bffd17 	ldw	r2,-12(fp)
 202bccc:	00bfd016 	blt	zero,r2,202bc10 <__alt_mem_mem_0+0xfd00bc10>
 202bcd0:	00000306 	br	202bce0 <altera_avalon_jtag_uart_write+0x1fc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 202bcd4:	0001883a 	nop
 202bcd8:	00000106 	br	202bce0 <altera_avalon_jtag_uart_write+0x1fc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 202bcdc:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 202bce0:	e0bffb17 	ldw	r2,-20(fp)
 202bce4:	10800b17 	ldw	r2,44(r2)
 202bce8:	000f883a 	mov	r7,zero
 202bcec:	000d883a 	mov	r6,zero
 202bcf0:	000b883a 	mov	r5,zero
 202bcf4:	1009883a 	mov	r4,r2
 202bcf8:	200d8480 	call	200d848 <xQueueGenericSend>

  if (ptr != start)
 202bcfc:	e0fffc17 	ldw	r3,-16(fp)
 202bd00:	e0bff417 	ldw	r2,-48(fp)
 202bd04:	18800426 	beq	r3,r2,202bd18 <altera_avalon_jtag_uart_write+0x234>
    return ptr - start;
 202bd08:	e0fffc17 	ldw	r3,-16(fp)
 202bd0c:	e0bff417 	ldw	r2,-48(fp)
 202bd10:	1885c83a 	sub	r2,r3,r2
 202bd14:	00000606 	br	202bd30 <altera_avalon_jtag_uart_write+0x24c>
  else if (flags & O_NONBLOCK)
 202bd18:	e0bffe17 	ldw	r2,-8(fp)
 202bd1c:	1090000c 	andi	r2,r2,16384
 202bd20:	10000226 	beq	r2,zero,202bd2c <altera_avalon_jtag_uart_write+0x248>
    return -EWOULDBLOCK;
 202bd24:	00bffd44 	movi	r2,-11
 202bd28:	00000106 	br	202bd30 <altera_avalon_jtag_uart_write+0x24c>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 202bd2c:	00bffec4 	movi	r2,-5
}
 202bd30:	e037883a 	mov	sp,fp
 202bd34:	dfc00117 	ldw	ra,4(sp)
 202bd38:	df000017 	ldw	fp,0(sp)
 202bd3c:	dec00204 	addi	sp,sp,8
 202bd40:	f800283a 	ret

0202bd44 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202bd44:	defffe04 	addi	sp,sp,-8
 202bd48:	dfc00115 	stw	ra,4(sp)
 202bd4c:	df000015 	stw	fp,0(sp)
 202bd50:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202bd54:	d0a01b17 	ldw	r2,-32660(gp)
 202bd58:	10000326 	beq	r2,zero,202bd68 <alt_get_errno+0x24>
 202bd5c:	d0a01b17 	ldw	r2,-32660(gp)
 202bd60:	103ee83a 	callr	r2
 202bd64:	00000106 	br	202bd6c <alt_get_errno+0x28>
 202bd68:	d0a7a404 	addi	r2,gp,-24944
}
 202bd6c:	e037883a 	mov	sp,fp
 202bd70:	dfc00117 	ldw	ra,4(sp)
 202bd74:	df000017 	ldw	fp,0(sp)
 202bd78:	dec00204 	addi	sp,sp,8
 202bd7c:	f800283a 	ret

0202bd80 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 202bd80:	defffc04 	addi	sp,sp,-16
 202bd84:	df000315 	stw	fp,12(sp)
 202bd88:	df000304 	addi	fp,sp,12
 202bd8c:	e13ffe15 	stw	r4,-8(fp)
 202bd90:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 202bd94:	e0bffe17 	ldw	r2,-8(fp)
 202bd98:	10800317 	ldw	r2,12(r2)
 202bd9c:	10800037 	ldwio	r2,0(r2)
 202bda0:	1080040c 	andi	r2,r2,16
 202bda4:	10000226 	beq	r2,zero,202bdb0 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 202bda8:	00bffc04 	movi	r2,-16
 202bdac:	00003906 	br	202be94 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 202bdb0:	e0bffe17 	ldw	r2,-8(fp)
 202bdb4:	10800317 	ldw	r2,12(r2)
 202bdb8:	10800404 	addi	r2,r2,16
 202bdbc:	e0fffe17 	ldw	r3,-8(fp)
 202bdc0:	18c00317 	ldw	r3,12(r3)
 202bdc4:	18c00404 	addi	r3,r3,16
 202bdc8:	19000037 	ldwio	r4,0(r3)
 202bdcc:	00fff7c4 	movi	r3,-33
 202bdd0:	20c6703a 	and	r3,r4,r3
 202bdd4:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 202bdd8:	e0bffe17 	ldw	r2,-8(fp)
 202bddc:	10800317 	ldw	r2,12(r2)
 202bde0:	00c03fc4 	movi	r3,255
 202bde4:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 202bde8:	e0bffe17 	ldw	r2,-8(fp)
 202bdec:	10800317 	ldw	r2,12(r2)
 202bdf0:	10800804 	addi	r2,r2,32
 202bdf4:	e0ffff17 	ldw	r3,-4(fp)
 202bdf8:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 202bdfc:	e0bffe17 	ldw	r2,-8(fp)
 202be00:	10800917 	ldw	r2,36(r2)
 202be04:	10001126 	beq	r2,zero,202be4c <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202be08:	e0bffe17 	ldw	r2,-8(fp)
 202be0c:	10800317 	ldw	r2,12(r2)
 202be10:	10800404 	addi	r2,r2,16
 202be14:	10800037 	ldwio	r2,0(r2)
 202be18:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 202be1c:	e0bffe17 	ldw	r2,-8(fp)
 202be20:	10c00b17 	ldw	r3,44(r2)
 202be24:	e0bffd17 	ldw	r2,-12(fp)
 202be28:	1884b03a 	or	r2,r3,r2
 202be2c:	10801814 	ori	r2,r2,96
 202be30:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 202be34:	e0bffe17 	ldw	r2,-8(fp)
 202be38:	10800317 	ldw	r2,12(r2)
 202be3c:	10800404 	addi	r2,r2,16
 202be40:	e0fffd17 	ldw	r3,-12(fp)
 202be44:	10c00035 	stwio	r3,0(r2)
 202be48:	00001106 	br	202be90 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202be4c:	e0bffe17 	ldw	r2,-8(fp)
 202be50:	10800317 	ldw	r2,12(r2)
 202be54:	10800404 	addi	r2,r2,16
 202be58:	10800037 	ldwio	r2,0(r2)
 202be5c:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 202be60:	e0bffd17 	ldw	r2,-12(fp)
 202be64:	10801814 	ori	r2,r2,96
 202be68:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 202be6c:	e0fffd17 	ldw	r3,-12(fp)
 202be70:	00bffbc4 	movi	r2,-17
 202be74:	1884703a 	and	r2,r3,r2
 202be78:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 202be7c:	e0bffe17 	ldw	r2,-8(fp)
 202be80:	10800317 	ldw	r2,12(r2)
 202be84:	10800404 	addi	r2,r2,16
 202be88:	e0fffd17 	ldw	r3,-12(fp)
 202be8c:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 202be90:	0005883a 	mov	r2,zero
}
 202be94:	e037883a 	mov	sp,fp
 202be98:	df000017 	ldw	fp,0(sp)
 202be9c:	dec00104 	addi	sp,sp,4
 202bea0:	f800283a 	ret

0202bea4 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 202bea4:	defffc04 	addi	sp,sp,-16
 202bea8:	df000315 	stw	fp,12(sp)
 202beac:	df000304 	addi	fp,sp,12
 202beb0:	e13ffe15 	stw	r4,-8(fp)
 202beb4:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 202beb8:	0001883a 	nop
 202bebc:	e0bffe17 	ldw	r2,-8(fp)
 202bec0:	10800317 	ldw	r2,12(r2)
 202bec4:	10800037 	ldwio	r2,0(r2)
 202bec8:	1080040c 	andi	r2,r2,16
 202becc:	103ffb1e 	bne	r2,zero,202bebc <__alt_mem_mem_0+0xfd00bebc>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 202bed0:	e0bffe17 	ldw	r2,-8(fp)
 202bed4:	10800317 	ldw	r2,12(r2)
 202bed8:	10800404 	addi	r2,r2,16
 202bedc:	e0fffe17 	ldw	r3,-8(fp)
 202bee0:	18c00317 	ldw	r3,12(r3)
 202bee4:	18c00404 	addi	r3,r3,16
 202bee8:	19000037 	ldwio	r4,0(r3)
 202beec:	00fff7c4 	movi	r3,-33
 202bef0:	20c6703a 	and	r3,r4,r3
 202bef4:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 202bef8:	e0bffe17 	ldw	r2,-8(fp)
 202befc:	10800317 	ldw	r2,12(r2)
 202bf00:	00c03fc4 	movi	r3,255
 202bf04:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 202bf08:	e0bffe17 	ldw	r2,-8(fp)
 202bf0c:	10800317 	ldw	r2,12(r2)
 202bf10:	10800804 	addi	r2,r2,32
 202bf14:	e0ffff17 	ldw	r3,-4(fp)
 202bf18:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 202bf1c:	e0bffe17 	ldw	r2,-8(fp)
 202bf20:	10800317 	ldw	r2,12(r2)
 202bf24:	10800404 	addi	r2,r2,16
 202bf28:	e0fffe17 	ldw	r3,-8(fp)
 202bf2c:	18c00317 	ldw	r3,12(r3)
 202bf30:	18c00404 	addi	r3,r3,16
 202bf34:	18c00037 	ldwio	r3,0(r3)
 202bf38:	18c01814 	ori	r3,r3,96
 202bf3c:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 202bf40:	0001883a 	nop
 202bf44:	e0bffe17 	ldw	r2,-8(fp)
 202bf48:	10800317 	ldw	r2,12(r2)
 202bf4c:	10800037 	ldwio	r2,0(r2)
 202bf50:	1080040c 	andi	r2,r2,16
 202bf54:	103ffb1e 	bne	r2,zero,202bf44 <__alt_mem_mem_0+0xfd00bf44>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 202bf58:	e0bffe17 	ldw	r2,-8(fp)
 202bf5c:	10800317 	ldw	r2,12(r2)
 202bf60:	10800404 	addi	r2,r2,16
 202bf64:	e0fffe17 	ldw	r3,-8(fp)
 202bf68:	18c00317 	ldw	r3,12(r3)
 202bf6c:	18c00404 	addi	r3,r3,16
 202bf70:	19000037 	ldwio	r4,0(r3)
 202bf74:	00fff7c4 	movi	r3,-33
 202bf78:	20c6703a 	and	r3,r4,r3
 202bf7c:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 202bf80:	e0bffe17 	ldw	r2,-8(fp)
 202bf84:	10800317 	ldw	r2,12(r2)
 202bf88:	10800037 	ldwio	r2,0(r2)
 202bf8c:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 202bf90:	e0bffe17 	ldw	r2,-8(fp)
 202bf94:	10800317 	ldw	r2,12(r2)
 202bf98:	00c03fc4 	movi	r3,255
 202bf9c:	10c00035 	stwio	r3,0(r2)

  return status;
 202bfa0:	e0bffd03 	ldbu	r2,-12(fp)
}
 202bfa4:	e037883a 	mov	sp,fp
 202bfa8:	df000017 	ldw	fp,0(sp)
 202bfac:	dec00104 	addi	sp,sp,4
 202bfb0:	f800283a 	ret

0202bfb4 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 202bfb4:	defff404 	addi	sp,sp,-48
 202bfb8:	dfc00b15 	stw	ra,44(sp)
 202bfbc:	df000a15 	stw	fp,40(sp)
 202bfc0:	df000a04 	addi	fp,sp,40
 202bfc4:	e13ffb15 	stw	r4,-20(fp)
 202bfc8:	e17ffc15 	stw	r5,-16(fp)
 202bfcc:	e1bffd15 	stw	r6,-12(fp)
 202bfd0:	e1fffe15 	stw	r7,-8(fp)
 202bfd4:	e0800217 	ldw	r2,8(fp)
 202bfd8:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 202bfdc:	e0bfff0b 	ldhu	r2,-4(fp)
 202bfe0:	d8000415 	stw	zero,16(sp)
 202bfe4:	d8000315 	stw	zero,12(sp)
 202bfe8:	e0c00417 	ldw	r3,16(fp)
 202bfec:	d8c00215 	stw	r3,8(sp)
 202bff0:	e0c00317 	ldw	r3,12(fp)
 202bff4:	d8c00115 	stw	r3,4(sp)
 202bff8:	d8800015 	stw	r2,0(sp)
 202bffc:	e1fffe17 	ldw	r7,-8(fp)
 202c000:	e1bffd17 	ldw	r6,-12(fp)
 202c004:	e17ffc17 	ldw	r5,-16(fp)
 202c008:	e13ffb17 	ldw	r4,-20(fp)
 202c00c:	202c0280 	call	202c028 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 202c010:	0001883a 	nop
 202c014:	e037883a 	mov	sp,fp
 202c018:	dfc00117 	ldw	ra,4(sp)
 202c01c:	df000017 	ldw	fp,0(sp)
 202c020:	dec00204 	addi	sp,sp,8
 202c024:	f800283a 	ret

0202c028 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 202c028:	defff204 	addi	sp,sp,-56
 202c02c:	dfc00d15 	stw	ra,52(sp)
 202c030:	df000c15 	stw	fp,48(sp)
 202c034:	df000c04 	addi	fp,sp,48
 202c038:	e13ffb15 	stw	r4,-20(fp)
 202c03c:	e17ffc15 	stw	r5,-16(fp)
 202c040:	e1bffd15 	stw	r6,-12(fp)
 202c044:	e1fffe15 	stw	r7,-8(fp)
 202c048:	e0800217 	ldw	r2,8(fp)
 202c04c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 202c050:	e0bfff0b 	ldhu	r2,-4(fp)
 202c054:	d8000615 	stw	zero,24(sp)
 202c058:	e0c00617 	ldw	r3,24(fp)
 202c05c:	d8c00515 	stw	r3,20(sp)
 202c060:	e0c00517 	ldw	r3,20(fp)
 202c064:	d8c00415 	stw	r3,16(sp)
 202c068:	e0c00417 	ldw	r3,16(fp)
 202c06c:	d8c00315 	stw	r3,12(sp)
 202c070:	e0c00317 	ldw	r3,12(fp)
 202c074:	d8c00215 	stw	r3,8(sp)
 202c078:	d8000115 	stw	zero,4(sp)
 202c07c:	d8800015 	stw	r2,0(sp)
 202c080:	e1fffe17 	ldw	r7,-8(fp)
 202c084:	e1bffd17 	ldw	r6,-12(fp)
 202c088:	e17ffc17 	ldw	r5,-16(fp)
 202c08c:	e13ffb17 	ldw	r4,-20(fp)
 202c090:	202c5bc0 	call	202c5bc <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 202c094:	0001883a 	nop
 202c098:	e037883a 	mov	sp,fp
 202c09c:	dfc00117 	ldw	ra,4(sp)
 202c0a0:	df000017 	ldw	fp,0(sp)
 202c0a4:	dec00204 	addi	sp,sp,8
 202c0a8:	f800283a 	ret

0202c0ac <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 202c0ac:	defff804 	addi	sp,sp,-32
 202c0b0:	dfc00715 	stw	ra,28(sp)
 202c0b4:	df000615 	stw	fp,24(sp)
 202c0b8:	df000604 	addi	fp,sp,24
 202c0bc:	e13ffc15 	stw	r4,-16(fp)
 202c0c0:	e17ffd15 	stw	r5,-12(fp)
 202c0c4:	e1bffe15 	stw	r6,-8(fp)
 202c0c8:	3805883a 	mov	r2,r7
 202c0cc:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 202c0d0:	e0ffff0b 	ldhu	r3,-4(fp)
 202c0d4:	d8000115 	stw	zero,4(sp)
 202c0d8:	e0800217 	ldw	r2,8(fp)
 202c0dc:	d8800015 	stw	r2,0(sp)
 202c0e0:	180f883a 	mov	r7,r3
 202c0e4:	e1bffe17 	ldw	r6,-8(fp)
 202c0e8:	e17ffd17 	ldw	r5,-12(fp)
 202c0ec:	e13ffc17 	ldw	r4,-16(fp)
 202c0f0:	202c10c0 	call	202c10c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 202c0f4:	0001883a 	nop
 202c0f8:	e037883a 	mov	sp,fp
 202c0fc:	dfc00117 	ldw	ra,4(sp)
 202c100:	df000017 	ldw	fp,0(sp)
 202c104:	dec00204 	addi	sp,sp,8
 202c108:	f800283a 	ret

0202c10c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 202c10c:	defff304 	addi	sp,sp,-52
 202c110:	dfc00c15 	stw	ra,48(sp)
 202c114:	df000b15 	stw	fp,44(sp)
 202c118:	df000b04 	addi	fp,sp,44
 202c11c:	e13ffc15 	stw	r4,-16(fp)
 202c120:	e17ffd15 	stw	r5,-12(fp)
 202c124:	e1bffe15 	stw	r6,-8(fp)
 202c128:	3805883a 	mov	r2,r7
 202c12c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 202c130:	e0bfff0b 	ldhu	r2,-4(fp)
 202c134:	d8000615 	stw	zero,24(sp)
 202c138:	e0c00317 	ldw	r3,12(fp)
 202c13c:	d8c00515 	stw	r3,20(sp)
 202c140:	d8000415 	stw	zero,16(sp)
 202c144:	e0c00217 	ldw	r3,8(fp)
 202c148:	d8c00315 	stw	r3,12(sp)
 202c14c:	d8000215 	stw	zero,8(sp)
 202c150:	d8000115 	stw	zero,4(sp)
 202c154:	d8800015 	stw	r2,0(sp)
 202c158:	e1fffe17 	ldw	r7,-8(fp)
 202c15c:	000d883a 	mov	r6,zero
 202c160:	e17ffd17 	ldw	r5,-12(fp)
 202c164:	e13ffc17 	ldw	r4,-16(fp)
 202c168:	202c5bc0 	call	202c5bc <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 202c16c:	0001883a 	nop
 202c170:	e037883a 	mov	sp,fp
 202c174:	dfc00117 	ldw	ra,4(sp)
 202c178:	df000017 	ldw	fp,0(sp)
 202c17c:	dec00204 	addi	sp,sp,8
 202c180:	f800283a 	ret

0202c184 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 202c184:	defff404 	addi	sp,sp,-48
 202c188:	dfc00b15 	stw	ra,44(sp)
 202c18c:	df000a15 	stw	fp,40(sp)
 202c190:	df000a04 	addi	fp,sp,40
 202c194:	e13ffb15 	stw	r4,-20(fp)
 202c198:	e17ffc15 	stw	r5,-16(fp)
 202c19c:	e1bffd15 	stw	r6,-12(fp)
 202c1a0:	3807883a 	mov	r3,r7
 202c1a4:	e0800517 	ldw	r2,20(fp)
 202c1a8:	e0fffe0d 	sth	r3,-8(fp)
 202c1ac:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 202c1b0:	e0fffe0b 	ldhu	r3,-8(fp)
 202c1b4:	e0bfff03 	ldbu	r2,-4(fp)
 202c1b8:	d8800415 	stw	r2,16(sp)
 202c1bc:	d8000315 	stw	zero,12(sp)
 202c1c0:	e0800417 	ldw	r2,16(fp)
 202c1c4:	d8800215 	stw	r2,8(sp)
 202c1c8:	e0800317 	ldw	r2,12(fp)
 202c1cc:	d8800115 	stw	r2,4(sp)
 202c1d0:	e0800217 	ldw	r2,8(fp)
 202c1d4:	d8800015 	stw	r2,0(sp)
 202c1d8:	180f883a 	mov	r7,r3
 202c1dc:	e1bffd17 	ldw	r6,-12(fp)
 202c1e0:	e17ffc17 	ldw	r5,-16(fp)
 202c1e4:	e13ffb17 	ldw	r4,-20(fp)
 202c1e8:	202c2040 	call	202c204 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 202c1ec:	0001883a 	nop
 202c1f0:	e037883a 	mov	sp,fp
 202c1f4:	dfc00117 	ldw	ra,4(sp)
 202c1f8:	df000017 	ldw	fp,0(sp)
 202c1fc:	dec00204 	addi	sp,sp,8
 202c200:	f800283a 	ret

0202c204 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 202c204:	defff204 	addi	sp,sp,-56
 202c208:	dfc00d15 	stw	ra,52(sp)
 202c20c:	df000c15 	stw	fp,48(sp)
 202c210:	df000c04 	addi	fp,sp,48
 202c214:	e13ffb15 	stw	r4,-20(fp)
 202c218:	e17ffc15 	stw	r5,-16(fp)
 202c21c:	e1bffd15 	stw	r6,-12(fp)
 202c220:	3807883a 	mov	r3,r7
 202c224:	e0800617 	ldw	r2,24(fp)
 202c228:	e0fffe0d 	sth	r3,-8(fp)
 202c22c:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 202c230:	e0bffe0b 	ldhu	r2,-8(fp)
 202c234:	e0ffff03 	ldbu	r3,-4(fp)
 202c238:	d8c00615 	stw	r3,24(sp)
 202c23c:	d8000515 	stw	zero,20(sp)
 202c240:	e0c00517 	ldw	r3,20(fp)
 202c244:	d8c00415 	stw	r3,16(sp)
 202c248:	e0c00317 	ldw	r3,12(fp)
 202c24c:	d8c00315 	stw	r3,12(sp)
 202c250:	e0c00217 	ldw	r3,8(fp)
 202c254:	d8c00215 	stw	r3,8(sp)
 202c258:	e0c00417 	ldw	r3,16(fp)
 202c25c:	d8c00115 	stw	r3,4(sp)
 202c260:	d8800015 	stw	r2,0(sp)
 202c264:	000f883a 	mov	r7,zero
 202c268:	e1bffd17 	ldw	r6,-12(fp)
 202c26c:	e17ffc17 	ldw	r5,-16(fp)
 202c270:	e13ffb17 	ldw	r4,-20(fp)
 202c274:	202c5bc0 	call	202c5bc <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 202c278:	0001883a 	nop
 202c27c:	e037883a 	mov	sp,fp
 202c280:	dfc00117 	ldw	ra,4(sp)
 202c284:	df000017 	ldw	fp,0(sp)
 202c288:	dec00204 	addi	sp,sp,8
 202c28c:	f800283a 	ret

0202c290 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 202c290:	defffb04 	addi	sp,sp,-20
 202c294:	df000415 	stw	fp,16(sp)
 202c298:	df000404 	addi	fp,sp,16
 202c29c:	e13ffc15 	stw	r4,-16(fp)
 202c2a0:	e17ffd15 	stw	r5,-12(fp)
 202c2a4:	e1bffe15 	stw	r6,-8(fp)
 202c2a8:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 202c2ac:	e0bffc17 	ldw	r2,-16(fp)
 202c2b0:	e0fffd17 	ldw	r3,-12(fp)
 202c2b4:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 202c2b8:	e0bffc17 	ldw	r2,-16(fp)
 202c2bc:	e0ffff17 	ldw	r3,-4(fp)
 202c2c0:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 202c2c4:	e0bffc17 	ldw	r2,-16(fp)
 202c2c8:	e0fffe17 	ldw	r3,-8(fp)
 202c2cc:	10c00b15 	stw	r3,44(r2)
}
 202c2d0:	0001883a 	nop
 202c2d4:	e037883a 	mov	sp,fp
 202c2d8:	df000017 	ldw	fp,0(sp)
 202c2dc:	dec00104 	addi	sp,sp,4
 202c2e0:	f800283a 	ret

0202c2e4 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 202c2e4:	defffd04 	addi	sp,sp,-12
 202c2e8:	df000215 	stw	fp,8(sp)
 202c2ec:	df000204 	addi	fp,sp,8
 202c2f0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202c2f4:	e0bfff17 	ldw	r2,-4(fp)
 202c2f8:	10800317 	ldw	r2,12(r2)
 202c2fc:	10800404 	addi	r2,r2,16
 202c300:	10800037 	ldwio	r2,0(r2)
 202c304:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 202c308:	e0bffe17 	ldw	r2,-8(fp)
 202c30c:	10800814 	ori	r2,r2,32
 202c310:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 202c314:	e0bfff17 	ldw	r2,-4(fp)
 202c318:	10800317 	ldw	r2,12(r2)
 202c31c:	10800404 	addi	r2,r2,16
 202c320:	e0fffe17 	ldw	r3,-8(fp)
 202c324:	10c00035 	stwio	r3,0(r2)
}
 202c328:	0001883a 	nop
 202c32c:	e037883a 	mov	sp,fp
 202c330:	df000017 	ldw	fp,0(sp)
 202c334:	dec00104 	addi	sp,sp,4
 202c338:	f800283a 	ret

0202c33c <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 202c33c:	defffd04 	addi	sp,sp,-12
 202c340:	df000215 	stw	fp,8(sp)
 202c344:	df000204 	addi	fp,sp,8
 202c348:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202c34c:	e0bfff17 	ldw	r2,-4(fp)
 202c350:	10800317 	ldw	r2,12(r2)
 202c354:	10800404 	addi	r2,r2,16
 202c358:	10800037 	ldwio	r2,0(r2)
 202c35c:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 202c360:	e0fffe17 	ldw	r3,-8(fp)
 202c364:	00bff7c4 	movi	r2,-33
 202c368:	1884703a 	and	r2,r3,r2
 202c36c:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 202c370:	e0bfff17 	ldw	r2,-4(fp)
 202c374:	10800317 	ldw	r2,12(r2)
 202c378:	10800404 	addi	r2,r2,16
 202c37c:	e0fffe17 	ldw	r3,-8(fp)
 202c380:	10c00035 	stwio	r3,0(r2)
}
 202c384:	0001883a 	nop
 202c388:	e037883a 	mov	sp,fp
 202c38c:	df000017 	ldw	fp,0(sp)
 202c390:	dec00104 	addi	sp,sp,4
 202c394:	f800283a 	ret

0202c398 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 202c398:	defffe04 	addi	sp,sp,-8
 202c39c:	df000115 	stw	fp,4(sp)
 202c3a0:	df000104 	addi	fp,sp,4
 202c3a4:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 202c3a8:	e0bfff17 	ldw	r2,-4(fp)
 202c3ac:	10800784 	addi	r2,r2,30
 202c3b0:	10800023 	ldbuio	r2,0(r2)
 202c3b4:	10803fcc 	andi	r2,r2,255
 202c3b8:	10801fcc 	andi	r2,r2,127
 202c3bc:	10000226 	beq	r2,zero,202c3c8 <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 202c3c0:	00bffec4 	movi	r2,-5
 202c3c4:	00000906 	br	202c3ec <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 202c3c8:	e0bfff17 	ldw	r2,-4(fp)
 202c3cc:	108007c4 	addi	r2,r2,31
 202c3d0:	10800023 	ldbuio	r2,0(r2)
 202c3d4:	10803fcc 	andi	r2,r2,255
 202c3d8:	1080200c 	andi	r2,r2,128
 202c3dc:	10000226 	beq	r2,zero,202c3e8 <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 202c3e0:	00bfe244 	movi	r2,-119
 202c3e4:	00000106 	br	202c3ec <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 202c3e8:	0005883a 	mov	r2,zero
}
 202c3ec:	e037883a 	mov	sp,fp
 202c3f0:	df000017 	ldw	fp,0(sp)
 202c3f4:	dec00104 	addi	sp,sp,4
 202c3f8:	f800283a 	ret

0202c3fc <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 202c3fc:	defffc04 	addi	sp,sp,-16
 202c400:	dfc00315 	stw	ra,12(sp)
 202c404:	df000215 	stw	fp,8(sp)
 202c408:	df000204 	addi	fp,sp,8
 202c40c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 202c410:	d1601904 	addi	r5,gp,-32668
 202c414:	e13fff17 	ldw	r4,-4(fp)
 202c418:	202e1dc0 	call	202e1dc <alt_find_dev>
 202c41c:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 202c420:	e0bffe17 	ldw	r2,-8(fp)
 202c424:	1000041e 	bne	r2,zero,202c438 <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
 202c428:	202bd440 	call	202bd44 <alt_get_errno>
 202c42c:	1007883a 	mov	r3,r2
 202c430:	008004c4 	movi	r2,19
 202c434:	18800015 	stw	r2,0(r3)
  }

  return dev;
 202c438:	e0bffe17 	ldw	r2,-8(fp)
}
 202c43c:	e037883a 	mov	sp,fp
 202c440:	dfc00117 	ldw	ra,4(sp)
 202c444:	df000017 	ldw	fp,0(sp)
 202c448:	dec00204 	addi	sp,sp,8
 202c44c:	f800283a 	ret

0202c450 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 202c450:	defff104 	addi	sp,sp,-60
 202c454:	dfc00e15 	stw	ra,56(sp)
 202c458:	df000d15 	stw	fp,52(sp)
 202c45c:	df000d04 	addi	fp,sp,52
 202c460:	e13ffa15 	stw	r4,-24(fp)
 202c464:	e17ffb15 	stw	r5,-20(fp)
 202c468:	e1bffc15 	stw	r6,-16(fp)
 202c46c:	e1fffd15 	stw	r7,-12(fp)
 202c470:	e0c00217 	ldw	r3,8(fp)
 202c474:	e0800617 	ldw	r2,24(fp)
 202c478:	e0fffe0d 	sth	r3,-8(fp)
 202c47c:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 202c480:	e0bffe0b 	ldhu	r2,-8(fp)
 202c484:	e0ffff03 	ldbu	r3,-4(fp)
 202c488:	d8c00615 	stw	r3,24(sp)
 202c48c:	d8000515 	stw	zero,20(sp)
 202c490:	d8000415 	stw	zero,16(sp)
 202c494:	e0c00517 	ldw	r3,20(fp)
 202c498:	d8c00315 	stw	r3,12(sp)
 202c49c:	e0c00417 	ldw	r3,16(fp)
 202c4a0:	d8c00215 	stw	r3,8(sp)
 202c4a4:	e0c00317 	ldw	r3,12(fp)
 202c4a8:	d8c00115 	stw	r3,4(sp)
 202c4ac:	d8800015 	stw	r2,0(sp)
 202c4b0:	e1fffd17 	ldw	r7,-12(fp)
 202c4b4:	e1bffc17 	ldw	r6,-16(fp)
 202c4b8:	e17ffb17 	ldw	r5,-20(fp)
 202c4bc:	e13ffa17 	ldw	r4,-24(fp)
 202c4c0:	202c5bc0 	call	202c5bc <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 202c4c4:	0001883a 	nop
 202c4c8:	e037883a 	mov	sp,fp
 202c4cc:	dfc00117 	ldw	ra,4(sp)
 202c4d0:	df000017 	ldw	fp,0(sp)
 202c4d4:	dec00204 	addi	sp,sp,8
 202c4d8:	f800283a 	ret

0202c4dc <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 202c4dc:	defffc04 	addi	sp,sp,-16
 202c4e0:	df000315 	stw	fp,12(sp)
 202c4e4:	df000304 	addi	fp,sp,12
 202c4e8:	e13ffe15 	stw	r4,-8(fp)
 202c4ec:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202c4f0:	e0bffe17 	ldw	r2,-8(fp)
 202c4f4:	10800317 	ldw	r2,12(r2)
 202c4f8:	10800404 	addi	r2,r2,16
 202c4fc:	10800037 	ldwio	r2,0(r2)
 202c500:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 202c504:	e0fffd17 	ldw	r3,-12(fp)
 202c508:	00a00434 	movhi	r2,32784
 202c50c:	10bfffc4 	addi	r2,r2,-1
 202c510:	1884703a 	and	r2,r3,r2
 202c514:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 202c518:	e0bfff17 	ldw	r2,-4(fp)
 202c51c:	1004953a 	slli	r2,r2,20
 202c520:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 202c524:	e0bffd17 	ldw	r2,-12(fp)
 202c528:	1884b03a 	or	r2,r3,r2
 202c52c:	10800134 	orhi	r2,r2,4
 202c530:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 202c534:	e0bffe17 	ldw	r2,-8(fp)
 202c538:	10800317 	ldw	r2,12(r2)
 202c53c:	10800404 	addi	r2,r2,16
 202c540:	e0fffd17 	ldw	r3,-12(fp)
 202c544:	10c00035 	stwio	r3,0(r2)
  
  return;
 202c548:	0001883a 	nop
}
 202c54c:	e037883a 	mov	sp,fp
 202c550:	df000017 	ldw	fp,0(sp)
 202c554:	dec00104 	addi	sp,sp,4
 202c558:	f800283a 	ret

0202c55c <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 202c55c:	defffd04 	addi	sp,sp,-12
 202c560:	df000215 	stw	fp,8(sp)
 202c564:	df000204 	addi	fp,sp,8
 202c568:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202c56c:	e0bfff17 	ldw	r2,-4(fp)
 202c570:	10800317 	ldw	r2,12(r2)
 202c574:	10800404 	addi	r2,r2,16
 202c578:	10800037 	ldwio	r2,0(r2)
 202c57c:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 202c580:	e0fffe17 	ldw	r3,-8(fp)
 202c584:	00bfff34 	movhi	r2,65532
 202c588:	10bfffc4 	addi	r2,r2,-1
 202c58c:	1884703a 	and	r2,r3,r2
 202c590:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 202c594:	e0bfff17 	ldw	r2,-4(fp)
 202c598:	10800317 	ldw	r2,12(r2)
 202c59c:	10800404 	addi	r2,r2,16
 202c5a0:	e0fffe17 	ldw	r3,-8(fp)
 202c5a4:	10c00035 	stwio	r3,0(r2)
  
  return;
 202c5a8:	0001883a 	nop
}
 202c5ac:	e037883a 	mov	sp,fp
 202c5b0:	df000017 	ldw	fp,0(sp)
 202c5b4:	dec00104 	addi	sp,sp,4
 202c5b8:	f800283a 	ret

0202c5bc <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 202c5bc:	defff804 	addi	sp,sp,-32
 202c5c0:	dfc00715 	stw	ra,28(sp)
 202c5c4:	df000615 	stw	fp,24(sp)
 202c5c8:	df000604 	addi	fp,sp,24
 202c5cc:	e13ffa15 	stw	r4,-24(fp)
 202c5d0:	e17ffb15 	stw	r5,-20(fp)
 202c5d4:	e1bffc15 	stw	r6,-16(fp)
 202c5d8:	e1fffd15 	stw	r7,-12(fp)
 202c5dc:	e0c00217 	ldw	r3,8(fp)
 202c5e0:	e0800817 	ldw	r2,32(fp)
 202c5e4:	e0fffe0d 	sth	r3,-8(fp)
 202c5e8:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 202c5ec:	e0bffb17 	ldw	r2,-20(fp)
 202c5f0:	108007c4 	addi	r2,r2,31
 202c5f4:	e0fffb17 	ldw	r3,-20(fp)
 202c5f8:	18c007c3 	ldbu	r3,31(r3)
 202c5fc:	19003fcc 	andi	r4,r3,255
 202c600:	00ffdfc4 	movi	r3,-129
 202c604:	20c6703a 	and	r3,r4,r3
 202c608:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 202c60c:	e0bffa17 	ldw	r2,-24(fp)
 202c610:	e0fffc17 	ldw	r3,-16(fp)
 202c614:	19403fcc 	andi	r5,r3,255
 202c618:	10c00003 	ldbu	r3,0(r2)
 202c61c:	1806703a 	and	r3,r3,zero
 202c620:	1809883a 	mov	r4,r3
 202c624:	2807883a 	mov	r3,r5
 202c628:	20c6b03a 	or	r3,r4,r3
 202c62c:	10c00005 	stb	r3,0(r2)
 202c630:	e0fffc17 	ldw	r3,-16(fp)
 202c634:	1806d23a 	srli	r3,r3,8
 202c638:	19403fcc 	andi	r5,r3,255
 202c63c:	10c00043 	ldbu	r3,1(r2)
 202c640:	1806703a 	and	r3,r3,zero
 202c644:	1809883a 	mov	r4,r3
 202c648:	2807883a 	mov	r3,r5
 202c64c:	20c6b03a 	or	r3,r4,r3
 202c650:	10c00045 	stb	r3,1(r2)
 202c654:	e0fffc17 	ldw	r3,-16(fp)
 202c658:	1806d43a 	srli	r3,r3,16
 202c65c:	19403fcc 	andi	r5,r3,255
 202c660:	10c00083 	ldbu	r3,2(r2)
 202c664:	1806703a 	and	r3,r3,zero
 202c668:	1809883a 	mov	r4,r3
 202c66c:	2807883a 	mov	r3,r5
 202c670:	20c6b03a 	or	r3,r4,r3
 202c674:	10c00085 	stb	r3,2(r2)
 202c678:	e0fffc17 	ldw	r3,-16(fp)
 202c67c:	180ad63a 	srli	r5,r3,24
 202c680:	10c000c3 	ldbu	r3,3(r2)
 202c684:	1806703a 	and	r3,r3,zero
 202c688:	1809883a 	mov	r4,r3
 202c68c:	2807883a 	mov	r3,r5
 202c690:	20c6b03a 	or	r3,r4,r3
 202c694:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 202c698:	e0bffa17 	ldw	r2,-24(fp)
 202c69c:	e0fffd17 	ldw	r3,-12(fp)
 202c6a0:	19403fcc 	andi	r5,r3,255
 202c6a4:	10c00203 	ldbu	r3,8(r2)
 202c6a8:	1806703a 	and	r3,r3,zero
 202c6ac:	1809883a 	mov	r4,r3
 202c6b0:	2807883a 	mov	r3,r5
 202c6b4:	20c6b03a 	or	r3,r4,r3
 202c6b8:	10c00205 	stb	r3,8(r2)
 202c6bc:	e0fffd17 	ldw	r3,-12(fp)
 202c6c0:	1806d23a 	srli	r3,r3,8
 202c6c4:	19403fcc 	andi	r5,r3,255
 202c6c8:	10c00243 	ldbu	r3,9(r2)
 202c6cc:	1806703a 	and	r3,r3,zero
 202c6d0:	1809883a 	mov	r4,r3
 202c6d4:	2807883a 	mov	r3,r5
 202c6d8:	20c6b03a 	or	r3,r4,r3
 202c6dc:	10c00245 	stb	r3,9(r2)
 202c6e0:	e0fffd17 	ldw	r3,-12(fp)
 202c6e4:	1806d43a 	srli	r3,r3,16
 202c6e8:	19403fcc 	andi	r5,r3,255
 202c6ec:	10c00283 	ldbu	r3,10(r2)
 202c6f0:	1806703a 	and	r3,r3,zero
 202c6f4:	1809883a 	mov	r4,r3
 202c6f8:	2807883a 	mov	r3,r5
 202c6fc:	20c6b03a 	or	r3,r4,r3
 202c700:	10c00285 	stb	r3,10(r2)
 202c704:	e0fffd17 	ldw	r3,-12(fp)
 202c708:	180ad63a 	srli	r5,r3,24
 202c70c:	10c002c3 	ldbu	r3,11(r2)
 202c710:	1806703a 	and	r3,r3,zero
 202c714:	1809883a 	mov	r4,r3
 202c718:	2807883a 	mov	r3,r5
 202c71c:	20c6b03a 	or	r3,r4,r3
 202c720:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 202c724:	e0bffa17 	ldw	r2,-24(fp)
 202c728:	e0fffb17 	ldw	r3,-20(fp)
 202c72c:	19403fcc 	andi	r5,r3,255
 202c730:	10c00403 	ldbu	r3,16(r2)
 202c734:	1806703a 	and	r3,r3,zero
 202c738:	1809883a 	mov	r4,r3
 202c73c:	2807883a 	mov	r3,r5
 202c740:	20c6b03a 	or	r3,r4,r3
 202c744:	10c00405 	stb	r3,16(r2)
 202c748:	e0fffb17 	ldw	r3,-20(fp)
 202c74c:	1806d23a 	srli	r3,r3,8
 202c750:	19403fcc 	andi	r5,r3,255
 202c754:	10c00443 	ldbu	r3,17(r2)
 202c758:	1806703a 	and	r3,r3,zero
 202c75c:	1809883a 	mov	r4,r3
 202c760:	2807883a 	mov	r3,r5
 202c764:	20c6b03a 	or	r3,r4,r3
 202c768:	10c00445 	stb	r3,17(r2)
 202c76c:	e0fffb17 	ldw	r3,-20(fp)
 202c770:	1806d43a 	srli	r3,r3,16
 202c774:	19403fcc 	andi	r5,r3,255
 202c778:	10c00483 	ldbu	r3,18(r2)
 202c77c:	1806703a 	and	r3,r3,zero
 202c780:	1809883a 	mov	r4,r3
 202c784:	2807883a 	mov	r3,r5
 202c788:	20c6b03a 	or	r3,r4,r3
 202c78c:	10c00485 	stb	r3,18(r2)
 202c790:	e0fffb17 	ldw	r3,-20(fp)
 202c794:	180ad63a 	srli	r5,r3,24
 202c798:	10c004c3 	ldbu	r3,19(r2)
 202c79c:	1806703a 	and	r3,r3,zero
 202c7a0:	1809883a 	mov	r4,r3
 202c7a4:	2807883a 	mov	r3,r5
 202c7a8:	20c6b03a 	or	r3,r4,r3
 202c7ac:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 202c7b0:	e0bffa17 	ldw	r2,-24(fp)
 202c7b4:	10c00103 	ldbu	r3,4(r2)
 202c7b8:	1806703a 	and	r3,r3,zero
 202c7bc:	10c00105 	stb	r3,4(r2)
 202c7c0:	10c00143 	ldbu	r3,5(r2)
 202c7c4:	1806703a 	and	r3,r3,zero
 202c7c8:	10c00145 	stb	r3,5(r2)
 202c7cc:	10c00183 	ldbu	r3,6(r2)
 202c7d0:	1806703a 	and	r3,r3,zero
 202c7d4:	10c00185 	stb	r3,6(r2)
 202c7d8:	10c001c3 	ldbu	r3,7(r2)
 202c7dc:	1806703a 	and	r3,r3,zero
 202c7e0:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 202c7e4:	e0bffa17 	ldw	r2,-24(fp)
 202c7e8:	10c00303 	ldbu	r3,12(r2)
 202c7ec:	1806703a 	and	r3,r3,zero
 202c7f0:	10c00305 	stb	r3,12(r2)
 202c7f4:	10c00343 	ldbu	r3,13(r2)
 202c7f8:	1806703a 	and	r3,r3,zero
 202c7fc:	10c00345 	stb	r3,13(r2)
 202c800:	10c00383 	ldbu	r3,14(r2)
 202c804:	1806703a 	and	r3,r3,zero
 202c808:	10c00385 	stb	r3,14(r2)
 202c80c:	10c003c3 	ldbu	r3,15(r2)
 202c810:	1806703a 	and	r3,r3,zero
 202c814:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 202c818:	e0bffa17 	ldw	r2,-24(fp)
 202c81c:	10c00503 	ldbu	r3,20(r2)
 202c820:	1806703a 	and	r3,r3,zero
 202c824:	10c00505 	stb	r3,20(r2)
 202c828:	10c00543 	ldbu	r3,21(r2)
 202c82c:	1806703a 	and	r3,r3,zero
 202c830:	10c00545 	stb	r3,21(r2)
 202c834:	10c00583 	ldbu	r3,22(r2)
 202c838:	1806703a 	and	r3,r3,zero
 202c83c:	10c00585 	stb	r3,22(r2)
 202c840:	10c005c3 	ldbu	r3,23(r2)
 202c844:	1806703a 	and	r3,r3,zero
 202c848:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 202c84c:	e0bffa17 	ldw	r2,-24(fp)
 202c850:	e0fffe17 	ldw	r3,-8(fp)
 202c854:	19403fcc 	andi	r5,r3,255
 202c858:	10c00603 	ldbu	r3,24(r2)
 202c85c:	1806703a 	and	r3,r3,zero
 202c860:	1809883a 	mov	r4,r3
 202c864:	2807883a 	mov	r3,r5
 202c868:	20c6b03a 	or	r3,r4,r3
 202c86c:	10c00605 	stb	r3,24(r2)
 202c870:	e0fffe17 	ldw	r3,-8(fp)
 202c874:	1806d23a 	srli	r3,r3,8
 202c878:	19403fcc 	andi	r5,r3,255
 202c87c:	10c00643 	ldbu	r3,25(r2)
 202c880:	1806703a 	and	r3,r3,zero
 202c884:	1809883a 	mov	r4,r3
 202c888:	2807883a 	mov	r3,r5
 202c88c:	20c6b03a 	or	r3,r4,r3
 202c890:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 202c894:	e0bffa17 	ldw	r2,-24(fp)
 202c898:	10c00703 	ldbu	r3,28(r2)
 202c89c:	1806703a 	and	r3,r3,zero
 202c8a0:	10c00705 	stb	r3,28(r2)
 202c8a4:	10c00743 	ldbu	r3,29(r2)
 202c8a8:	1806703a 	and	r3,r3,zero
 202c8ac:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 202c8b0:	e0bffa17 	ldw	r2,-24(fp)
 202c8b4:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 202c8b8:	e0800617 	ldw	r2,24(fp)
 202c8bc:	1007883a 	mov	r3,r2
 202c8c0:	e0bffa17 	ldw	r2,-24(fp)
 202c8c4:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 202c8c8:	e0800717 	ldw	r2,28(fp)
 202c8cc:	1007883a 	mov	r3,r2
 202c8d0:	e0bffa17 	ldw	r2,-24(fp)
 202c8d4:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 202c8d8:	e0800317 	ldw	r2,12(fp)
 202c8dc:	10000226 	beq	r2,zero,202c8e8 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 202c8e0:	00bfe044 	movi	r2,-127
 202c8e4:	00000106 	br	202c8ec <alt_avalon_sgdma_construct_descriptor_burst+0x330>
 202c8e8:	00bfe004 	movi	r2,-128
 202c8ec:	e0c00417 	ldw	r3,16(fp)
 202c8f0:	18000226 	beq	r3,zero,202c8fc <alt_avalon_sgdma_construct_descriptor_burst+0x340>
 202c8f4:	00c00084 	movi	r3,2
 202c8f8:	00000106 	br	202c900 <alt_avalon_sgdma_construct_descriptor_burst+0x344>
 202c8fc:	0007883a 	mov	r3,zero
 202c900:	10c4b03a 	or	r2,r2,r3
 202c904:	1007883a 	mov	r3,r2
 202c908:	e0800517 	ldw	r2,20(fp)
 202c90c:	10000226 	beq	r2,zero,202c918 <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
 202c910:	00800104 	movi	r2,4
 202c914:	00000106 	br	202c91c <alt_avalon_sgdma_construct_descriptor_burst+0x360>
 202c918:	0005883a 	mov	r2,zero
 202c91c:	1884b03a 	or	r2,r3,r2
 202c920:	1007883a 	mov	r3,r2
 202c924:	e0bfff03 	ldbu	r2,-4(fp)
 202c928:	10000426 	beq	r2,zero,202c93c <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 202c92c:	e0bfff03 	ldbu	r2,-4(fp)
 202c930:	108003cc 	andi	r2,r2,15
 202c934:	100490fa 	slli	r2,r2,3
 202c938:	00000106 	br	202c940 <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 202c93c:	0005883a 	mov	r2,zero
 202c940:	1884b03a 	or	r2,r3,r2
 202c944:	1007883a 	mov	r3,r2
 202c948:	e0bffa17 	ldw	r2,-24(fp)
 202c94c:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
 202c950:	01400804 	movi	r5,32
 202c954:	e13ffa17 	ldw	r4,-24(fp)
 202c958:	202e0b40 	call	202e0b4 <alt_dcache_flush>
}
 202c95c:	0001883a 	nop
 202c960:	e037883a 	mov	sp,fp
 202c964:	dfc00117 	ldw	ra,4(sp)
 202c968:	df000017 	ldw	fp,0(sp)
 202c96c:	dec00204 	addi	sp,sp,8
 202c970:	f800283a 	ret

0202c974 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 202c974:	defff904 	addi	sp,sp,-28
 202c978:	dfc00615 	stw	ra,24(sp)
 202c97c:	df000515 	stw	fp,20(sp)
 202c980:	df000504 	addi	fp,sp,20
 202c984:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 202c988:	e0bfff17 	ldw	r2,-4(fp)
 202c98c:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 202c990:	e0bffb17 	ldw	r2,-20(fp)
 202c994:	10800317 	ldw	r2,12(r2)
 202c998:	10800404 	addi	r2,r2,16
 202c99c:	e0fffb17 	ldw	r3,-20(fp)
 202c9a0:	18c00317 	ldw	r3,12(r3)
 202c9a4:	18c00404 	addi	r3,r3,16
 202c9a8:	18c00037 	ldwio	r3,0(r3)
 202c9ac:	18e00034 	orhi	r3,r3,32768
 202c9b0:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202c9b4:	e0bffb17 	ldw	r2,-20(fp)
 202c9b8:	10800317 	ldw	r2,12(r2)
 202c9bc:	10800404 	addi	r2,r2,16
 202c9c0:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 202c9c4:	e0bffb17 	ldw	r2,-20(fp)
 202c9c8:	10800917 	ldw	r2,36(r2)
 202c9cc:	10001226 	beq	r2,zero,202ca18 <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202c9d0:	0005303a 	rdctl	r2,status
 202c9d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202c9d8:	e0fffd17 	ldw	r3,-12(fp)
 202c9dc:	00bfff84 	movi	r2,-2
 202c9e0:	1884703a 	and	r2,r3,r2
 202c9e4:	1001703a 	wrctl	status,r2
  
  return context;
 202c9e8:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 202c9ec:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 202c9f0:	e0bffb17 	ldw	r2,-20(fp)
 202c9f4:	10800917 	ldw	r2,36(r2)
 202c9f8:	e0fffb17 	ldw	r3,-20(fp)
 202c9fc:	18c00a17 	ldw	r3,40(r3)
 202ca00:	1809883a 	mov	r4,r3
 202ca04:	103ee83a 	callr	r2
 202ca08:	e0bffc17 	ldw	r2,-16(fp)
 202ca0c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202ca10:	e0bffe17 	ldw	r2,-8(fp)
 202ca14:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 202ca18:	0001883a 	nop
 202ca1c:	e037883a 	mov	sp,fp
 202ca20:	dfc00117 	ldw	ra,4(sp)
 202ca24:	df000017 	ldw	fp,0(sp)
 202ca28:	dec00204 	addi	sp,sp,8
 202ca2c:	f800283a 	ret

0202ca30 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 202ca30:	defffa04 	addi	sp,sp,-24
 202ca34:	dfc00515 	stw	ra,20(sp)
 202ca38:	df000415 	stw	fp,16(sp)
 202ca3c:	df000404 	addi	fp,sp,16
 202ca40:	e13ffd15 	stw	r4,-12(fp)
 202ca44:	e17ffe15 	stw	r5,-8(fp)
 202ca48:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 202ca4c:	e0bffd17 	ldw	r2,-12(fp)
 202ca50:	10800317 	ldw	r2,12(r2)
 202ca54:	10800404 	addi	r2,r2,16
 202ca58:	00c00074 	movhi	r3,1
 202ca5c:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 202ca60:	e0bffd17 	ldw	r2,-12(fp)
 202ca64:	10800317 	ldw	r2,12(r2)
 202ca68:	10800404 	addi	r2,r2,16
 202ca6c:	00c00074 	movhi	r3,1
 202ca70:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 202ca74:	e0bffd17 	ldw	r2,-12(fp)
 202ca78:	10800317 	ldw	r2,12(r2)
 202ca7c:	10800404 	addi	r2,r2,16
 202ca80:	0007883a 	mov	r3,zero
 202ca84:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 202ca88:	e0bffd17 	ldw	r2,-12(fp)
 202ca8c:	10800317 	ldw	r2,12(r2)
 202ca90:	00c03fc4 	movi	r3,255
 202ca94:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 202ca98:	d1601904 	addi	r5,gp,-32668
 202ca9c:	e13ffd17 	ldw	r4,-12(fp)
 202caa0:	202e1380 	call	202e138 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 202caa4:	d8000015 	stw	zero,0(sp)
 202caa8:	e1fffd17 	ldw	r7,-12(fp)
 202caac:	018080f4 	movhi	r6,515
 202cab0:	31b25d04 	addi	r6,r6,-13964
 202cab4:	e17fff17 	ldw	r5,-4(fp)
 202cab8:	e13ffe17 	ldw	r4,-8(fp)
 202cabc:	202e4880 	call	202e488 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 202cac0:	0001883a 	nop
 202cac4:	e037883a 	mov	sp,fp
 202cac8:	dfc00117 	ldw	ra,4(sp)
 202cacc:	df000017 	ldw	fp,0(sp)
 202cad0:	dec00204 	addi	sp,sp,8
 202cad4:	f800283a 	ret

0202cad8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 202cad8:	defffa04 	addi	sp,sp,-24
 202cadc:	dfc00515 	stw	ra,20(sp)
 202cae0:	df000415 	stw	fp,16(sp)
 202cae4:	df000404 	addi	fp,sp,16
 202cae8:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 202caec:	0007883a 	mov	r3,zero
 202caf0:	e0bfff17 	ldw	r2,-4(fp)
 202caf4:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 202caf8:	e0bfff17 	ldw	r2,-4(fp)
 202cafc:	10800104 	addi	r2,r2,4
 202cb00:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202cb04:	0005303a 	rdctl	r2,status
 202cb08:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202cb0c:	e0fffd17 	ldw	r3,-12(fp)
 202cb10:	00bfff84 	movi	r2,-2
 202cb14:	1884703a 	and	r2,r3,r2
 202cb18:	1001703a 	wrctl	status,r2
  
  return context;
 202cb1c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 202cb20:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 202cb24:	202e8fc0 	call	202e8fc <alt_tick>
 202cb28:	e0bffc17 	ldw	r2,-16(fp)
 202cb2c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202cb30:	e0bffe17 	ldw	r2,-8(fp)
 202cb34:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 202cb38:	0001883a 	nop
 202cb3c:	e037883a 	mov	sp,fp
 202cb40:	dfc00117 	ldw	ra,4(sp)
 202cb44:	df000017 	ldw	fp,0(sp)
 202cb48:	dec00204 	addi	sp,sp,8
 202cb4c:	f800283a 	ret

0202cb50 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 202cb50:	defff804 	addi	sp,sp,-32
 202cb54:	dfc00715 	stw	ra,28(sp)
 202cb58:	df000615 	stw	fp,24(sp)
 202cb5c:	df000604 	addi	fp,sp,24
 202cb60:	e13ffc15 	stw	r4,-16(fp)
 202cb64:	e17ffd15 	stw	r5,-12(fp)
 202cb68:	e1bffe15 	stw	r6,-8(fp)
 202cb6c:	e1ffff15 	stw	r7,-4(fp)
 202cb70:	e0bfff17 	ldw	r2,-4(fp)
 202cb74:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 202cb78:	d0a7f917 	ldw	r2,-24604(gp)
 202cb7c:	1000021e 	bne	r2,zero,202cb88 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 202cb80:	e0bffb17 	ldw	r2,-20(fp)
 202cb84:	d0a7f915 	stw	r2,-24604(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 202cb88:	e0bffc17 	ldw	r2,-16(fp)
 202cb8c:	10800104 	addi	r2,r2,4
 202cb90:	00c001c4 	movi	r3,7
 202cb94:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 202cb98:	d8000015 	stw	zero,0(sp)
 202cb9c:	e1fffc17 	ldw	r7,-16(fp)
 202cba0:	018080f4 	movhi	r6,515
 202cba4:	31b2b604 	addi	r6,r6,-13608
 202cba8:	e17ffe17 	ldw	r5,-8(fp)
 202cbac:	e13ffd17 	ldw	r4,-12(fp)
 202cbb0:	202e4880 	call	202e488 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 202cbb4:	0001883a 	nop
 202cbb8:	e037883a 	mov	sp,fp
 202cbbc:	dfc00117 	ldw	ra,4(sp)
 202cbc0:	df000017 	ldw	fp,0(sp)
 202cbc4:	dec00204 	addi	sp,sp,8
 202cbc8:	f800283a 	ret

0202cbcc <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 202cbcc:	defffa04 	addi	sp,sp,-24
 202cbd0:	dfc00515 	stw	ra,20(sp)
 202cbd4:	df000415 	stw	fp,16(sp)
 202cbd8:	df000404 	addi	fp,sp,16
 202cbdc:	e13ffd15 	stw	r4,-12(fp)
 202cbe0:	e17ffe15 	stw	r5,-8(fp)
 202cbe4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 202cbe8:	e0bffd17 	ldw	r2,-12(fp)
 202cbec:	10800017 	ldw	r2,0(r2)
 202cbf0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
 202cbf4:	e0bffc17 	ldw	r2,-16(fp)
 202cbf8:	10c00a04 	addi	r3,r2,40
 202cbfc:	e0bffd17 	ldw	r2,-12(fp)
 202cc00:	10800217 	ldw	r2,8(r2)
 202cc04:	100f883a 	mov	r7,r2
 202cc08:	e1bfff17 	ldw	r6,-4(fp)
 202cc0c:	e17ffe17 	ldw	r5,-8(fp)
 202cc10:	1809883a 	mov	r4,r3
 202cc14:	202d1900 	call	202d190 <altera_avalon_uart_read>
      fd->fd_flags);
}
 202cc18:	e037883a 	mov	sp,fp
 202cc1c:	dfc00117 	ldw	ra,4(sp)
 202cc20:	df000017 	ldw	fp,0(sp)
 202cc24:	dec00204 	addi	sp,sp,8
 202cc28:	f800283a 	ret

0202cc2c <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 202cc2c:	defffa04 	addi	sp,sp,-24
 202cc30:	dfc00515 	stw	ra,20(sp)
 202cc34:	df000415 	stw	fp,16(sp)
 202cc38:	df000404 	addi	fp,sp,16
 202cc3c:	e13ffd15 	stw	r4,-12(fp)
 202cc40:	e17ffe15 	stw	r5,-8(fp)
 202cc44:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 202cc48:	e0bffd17 	ldw	r2,-12(fp)
 202cc4c:	10800017 	ldw	r2,0(r2)
 202cc50:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
 202cc54:	e0bffc17 	ldw	r2,-16(fp)
 202cc58:	10c00a04 	addi	r3,r2,40
 202cc5c:	e0bffd17 	ldw	r2,-12(fp)
 202cc60:	10800217 	ldw	r2,8(r2)
 202cc64:	100f883a 	mov	r7,r2
 202cc68:	e1bfff17 	ldw	r6,-4(fp)
 202cc6c:	e17ffe17 	ldw	r5,-8(fp)
 202cc70:	1809883a 	mov	r4,r3
 202cc74:	202d3e40 	call	202d3e4 <altera_avalon_uart_write>
      fd->fd_flags);
}
 202cc78:	e037883a 	mov	sp,fp
 202cc7c:	dfc00117 	ldw	ra,4(sp)
 202cc80:	df000017 	ldw	fp,0(sp)
 202cc84:	dec00204 	addi	sp,sp,8
 202cc88:	f800283a 	ret

0202cc8c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
 202cc8c:	defffc04 	addi	sp,sp,-16
 202cc90:	dfc00315 	stw	ra,12(sp)
 202cc94:	df000215 	stw	fp,8(sp)
 202cc98:	df000204 	addi	fp,sp,8
 202cc9c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 202cca0:	e0bfff17 	ldw	r2,-4(fp)
 202cca4:	10800017 	ldw	r2,0(r2)
 202cca8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
 202ccac:	e0bffe17 	ldw	r2,-8(fp)
 202ccb0:	10c00a04 	addi	r3,r2,40
 202ccb4:	e0bfff17 	ldw	r2,-4(fp)
 202ccb8:	10800217 	ldw	r2,8(r2)
 202ccbc:	100b883a 	mov	r5,r2
 202ccc0:	1809883a 	mov	r4,r3
 202ccc4:	202d1000 	call	202d100 <altera_avalon_uart_close>
}
 202ccc8:	e037883a 	mov	sp,fp
 202cccc:	dfc00117 	ldw	ra,4(sp)
 202ccd0:	df000017 	ldw	fp,0(sp)
 202ccd4:	dec00204 	addi	sp,sp,8
 202ccd8:	f800283a 	ret

0202ccdc <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
 202ccdc:	defff504 	addi	sp,sp,-44
 202cce0:	dfc00a15 	stw	ra,40(sp)
 202cce4:	df000915 	stw	fp,36(sp)
 202cce8:	df000904 	addi	fp,sp,36
 202ccec:	e13ffd15 	stw	r4,-12(fp)
 202ccf0:	e17ffe15 	stw	r5,-8(fp)
 202ccf4:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
 202ccf8:	e0bffd17 	ldw	r2,-12(fp)
 202ccfc:	10800017 	ldw	r2,0(r2)
 202cd00:	e0bff815 	stw	r2,-32(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 202cd04:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 202cd08:	1000301e 	bne	r2,zero,202cdcc <altera_avalon_uart_init+0xf0>
 202cd0c:	e0bffd17 	ldw	r2,-12(fp)
 202cd10:	10800704 	addi	r2,r2,28
 202cd14:	e0bff915 	stw	r2,-28(fp)
 202cd18:	00800044 	movi	r2,1
 202cd1c:	e0bffc0d 	sth	r2,-16(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 202cd20:	e0bffc0b 	ldhu	r2,-16(fp)
 202cd24:	10000226 	beq	r2,zero,202cd30 <altera_avalon_uart_init+0x54>
 202cd28:	e0bffc0b 	ldhu	r2,-16(fp)
 202cd2c:	00000106 	br	202cd34 <altera_avalon_uart_init+0x58>
 202cd30:	00800044 	movi	r2,1
 202cd34:	e0fffc0b 	ldhu	r3,-16(fp)
 202cd38:	180b883a 	mov	r5,r3
 202cd3c:	1009883a 	mov	r4,r2
 202cd40:	200d7f00 	call	200d7f0 <xQueueCreateCountingSemaphore>
 202cd44:	1007883a 	mov	r3,r2
 202cd48:	e0bff917 	ldw	r2,-28(fp)
 202cd4c:	10c00015 	stw	r3,0(r2)
	return *sem ? 0 : -1;
 202cd50:	e0bff917 	ldw	r2,-28(fp)
 202cd54:	10800017 	ldw	r2,0(r2)
 202cd58:	10000226 	beq	r2,zero,202cd64 <altera_avalon_uart_init+0x88>
 202cd5c:	0005883a 	mov	r2,zero
 202cd60:	00000106 	br	202cd68 <altera_avalon_uart_init+0x8c>
 202cd64:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 202cd68:	1000181e 	bne	r2,zero,202cdcc <altera_avalon_uart_init+0xf0>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
 202cd6c:	e0bffd17 	ldw	r2,-12(fp)
 202cd70:	10800804 	addi	r2,r2,32
 202cd74:	e0bffa15 	stw	r2,-24(fp)
 202cd78:	00800044 	movi	r2,1
 202cd7c:	e0bffc8d 	sth	r2,-14(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 202cd80:	e0bffc8b 	ldhu	r2,-14(fp)
 202cd84:	10000226 	beq	r2,zero,202cd90 <altera_avalon_uart_init+0xb4>
 202cd88:	e0bffc8b 	ldhu	r2,-14(fp)
 202cd8c:	00000106 	br	202cd94 <altera_avalon_uart_init+0xb8>
 202cd90:	00800044 	movi	r2,1
 202cd94:	e0fffc8b 	ldhu	r3,-14(fp)
 202cd98:	180b883a 	mov	r5,r3
 202cd9c:	1009883a 	mov	r4,r2
 202cda0:	200d7f00 	call	200d7f0 <xQueueCreateCountingSemaphore>
 202cda4:	1007883a 	mov	r3,r2
 202cda8:	e0bffa17 	ldw	r2,-24(fp)
 202cdac:	10c00015 	stw	r3,0(r2)
	return *sem ? 0 : -1;
 202cdb0:	e0bffa17 	ldw	r2,-24(fp)
 202cdb4:	10800017 	ldw	r2,0(r2)
 202cdb8:	10000226 	beq	r2,zero,202cdc4 <altera_avalon_uart_init+0xe8>
 202cdbc:	0005883a 	mov	r2,zero
 202cdc0:	00000106 	br	202cdc8 <altera_avalon_uart_init+0xec>
 202cdc4:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 202cdc8:	10000226 	beq	r2,zero,202cdd4 <altera_avalon_uart_init+0xf8>
 202cdcc:	00800044 	movi	r2,1
 202cdd0:	00000106 	br	202cdd8 <altera_avalon_uart_init+0xfc>
 202cdd4:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 202cdd8:	e0bffb15 	stw	r2,-20(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
 202cddc:	e0bffb17 	ldw	r2,-20(fp)
 202cde0:	10000f1e 	bne	r2,zero,202ce20 <altera_avalon_uart_init+0x144>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
 202cde4:	e0bffd17 	ldw	r2,-12(fp)
 202cde8:	00c32004 	movi	r3,3200
 202cdec:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
 202cdf0:	e0bff817 	ldw	r2,-32(fp)
 202cdf4:	10800304 	addi	r2,r2,12
 202cdf8:	e0fffd17 	ldw	r3,-12(fp)
 202cdfc:	18c00117 	ldw	r3,4(r3)
 202ce00:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
 202ce04:	d8000015 	stw	zero,0(sp)
 202ce08:	e1fffd17 	ldw	r7,-12(fp)
 202ce0c:	018080f4 	movhi	r6,515
 202ce10:	31b38e04 	addi	r6,r6,-12744
 202ce14:	e17fff17 	ldw	r5,-4(fp)
 202ce18:	e13ffe17 	ldw	r4,-8(fp)
 202ce1c:	202e4880 	call	202e488 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
 202ce20:	0001883a 	nop
 202ce24:	e037883a 	mov	sp,fp
 202ce28:	dfc00117 	ldw	ra,4(sp)
 202ce2c:	df000017 	ldw	fp,0(sp)
 202ce30:	dec00204 	addi	sp,sp,8
 202ce34:	f800283a 	ret

0202ce38 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
 202ce38:	defffa04 	addi	sp,sp,-24
 202ce3c:	dfc00515 	stw	ra,20(sp)
 202ce40:	df000415 	stw	fp,16(sp)
 202ce44:	df000404 	addi	fp,sp,16
 202ce48:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
 202ce4c:	e0bfff17 	ldw	r2,-4(fp)
 202ce50:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
 202ce54:	e0bffc17 	ldw	r2,-16(fp)
 202ce58:	10800017 	ldw	r2,0(r2)
 202ce5c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
 202ce60:	e0bffd17 	ldw	r2,-12(fp)
 202ce64:	10800204 	addi	r2,r2,8
 202ce68:	10800037 	ldwio	r2,0(r2)
 202ce6c:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
 202ce70:	e0bffd17 	ldw	r2,-12(fp)
 202ce74:	10800204 	addi	r2,r2,8
 202ce78:	0007883a 	mov	r3,zero
 202ce7c:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
 202ce80:	e0bffd17 	ldw	r2,-12(fp)
 202ce84:	10800204 	addi	r2,r2,8
 202ce88:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
 202ce8c:	e0bffe17 	ldw	r2,-8(fp)
 202ce90:	1080200c 	andi	r2,r2,128
 202ce94:	10000326 	beq	r2,zero,202cea4 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
 202ce98:	e17ffe17 	ldw	r5,-8(fp)
 202ce9c:	e13ffc17 	ldw	r4,-16(fp)
 202cea0:	202ced40 	call	202ced4 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
 202cea4:	e0bffe17 	ldw	r2,-8(fp)
 202cea8:	1081100c 	andi	r2,r2,1088
 202ceac:	10000326 	beq	r2,zero,202cebc <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
 202ceb0:	e17ffe17 	ldw	r5,-8(fp)
 202ceb4:	e13ffc17 	ldw	r4,-16(fp)
 202ceb8:	202cfb80 	call	202cfb8 <altera_avalon_uart_txirq>
  }
  

}
 202cebc:	0001883a 	nop
 202cec0:	e037883a 	mov	sp,fp
 202cec4:	dfc00117 	ldw	ra,4(sp)
 202cec8:	df000017 	ldw	fp,0(sp)
 202cecc:	dec00204 	addi	sp,sp,8
 202ced0:	f800283a 	ret

0202ced4 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 202ced4:	defffc04 	addi	sp,sp,-16
 202ced8:	df000315 	stw	fp,12(sp)
 202cedc:	df000304 	addi	fp,sp,12
 202cee0:	e13ffe15 	stw	r4,-8(fp)
 202cee4:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
 202cee8:	e0bfff17 	ldw	r2,-4(fp)
 202ceec:	108000cc 	andi	r2,r2,3
 202cef0:	10002c1e 	bne	r2,zero,202cfa4 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
 202cef4:	e0bffe17 	ldw	r2,-8(fp)
 202cef8:	10800317 	ldw	r2,12(r2)
 202cefc:	e0bffe17 	ldw	r2,-8(fp)
 202cf00:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 202cf04:	e0bffe17 	ldw	r2,-8(fp)
 202cf08:	10800317 	ldw	r2,12(r2)
 202cf0c:	10800044 	addi	r2,r2,1
 202cf10:	10800fcc 	andi	r2,r2,63
 202cf14:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
 202cf18:	e0bffe17 	ldw	r2,-8(fp)
 202cf1c:	10800317 	ldw	r2,12(r2)
 202cf20:	e0fffe17 	ldw	r3,-8(fp)
 202cf24:	18c00017 	ldw	r3,0(r3)
 202cf28:	18c00037 	ldwio	r3,0(r3)
 202cf2c:	1809883a 	mov	r4,r3
 202cf30:	e0fffe17 	ldw	r3,-8(fp)
 202cf34:	1885883a 	add	r2,r3,r2
 202cf38:	10800904 	addi	r2,r2,36
 202cf3c:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
 202cf40:	e0bffe17 	ldw	r2,-8(fp)
 202cf44:	e0fffd17 	ldw	r3,-12(fp)
 202cf48:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 202cf4c:	e0bffe17 	ldw	r2,-8(fp)
 202cf50:	10800317 	ldw	r2,12(r2)
 202cf54:	10800044 	addi	r2,r2,1
 202cf58:	10800fcc 	andi	r2,r2,63
 202cf5c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
 202cf60:	e0bffe17 	ldw	r2,-8(fp)
 202cf64:	10c00217 	ldw	r3,8(r2)
 202cf68:	e0bffd17 	ldw	r2,-12(fp)
 202cf6c:	18800e1e 	bne	r3,r2,202cfa8 <altera_avalon_uart_rxirq+0xd4>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 202cf70:	e0bffe17 	ldw	r2,-8(fp)
 202cf74:	10c00117 	ldw	r3,4(r2)
 202cf78:	00bfdfc4 	movi	r2,-129
 202cf7c:	1886703a 	and	r3,r3,r2
 202cf80:	e0bffe17 	ldw	r2,-8(fp)
 202cf84:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
 202cf88:	e0bffe17 	ldw	r2,-8(fp)
 202cf8c:	10800017 	ldw	r2,0(r2)
 202cf90:	10800304 	addi	r2,r2,12
 202cf94:	e0fffe17 	ldw	r3,-8(fp)
 202cf98:	18c00117 	ldw	r3,4(r3)
 202cf9c:	10c00035 	stwio	r3,0(r2)
 202cfa0:	00000106 	br	202cfa8 <altera_avalon_uart_rxirq+0xd4>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
 202cfa4:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
 202cfa8:	e037883a 	mov	sp,fp
 202cfac:	df000017 	ldw	fp,0(sp)
 202cfb0:	dec00104 	addi	sp,sp,4
 202cfb4:	f800283a 	ret

0202cfb8 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 202cfb8:	defffb04 	addi	sp,sp,-20
 202cfbc:	df000415 	stw	fp,16(sp)
 202cfc0:	df000404 	addi	fp,sp,16
 202cfc4:	e13ffc15 	stw	r4,-16(fp)
 202cfc8:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
 202cfcc:	e0bffc17 	ldw	r2,-16(fp)
 202cfd0:	10c00417 	ldw	r3,16(r2)
 202cfd4:	e0bffc17 	ldw	r2,-16(fp)
 202cfd8:	10800517 	ldw	r2,20(r2)
 202cfdc:	18803226 	beq	r3,r2,202d0a8 <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 202cfe0:	e0bffc17 	ldw	r2,-16(fp)
 202cfe4:	10800617 	ldw	r2,24(r2)
 202cfe8:	1080008c 	andi	r2,r2,2
 202cfec:	10000326 	beq	r2,zero,202cffc <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 202cff0:	e0bffd17 	ldw	r2,-12(fp)
 202cff4:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 202cff8:	10001d26 	beq	r2,zero,202d070 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
 202cffc:	e0bffc17 	ldw	r2,-16(fp)
 202d000:	10800417 	ldw	r2,16(r2)
 202d004:	e0bffc17 	ldw	r2,-16(fp)
 202d008:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
 202d00c:	e0bffc17 	ldw	r2,-16(fp)
 202d010:	10800017 	ldw	r2,0(r2)
 202d014:	10800104 	addi	r2,r2,4
 202d018:	e0fffc17 	ldw	r3,-16(fp)
 202d01c:	18c00417 	ldw	r3,16(r3)
 202d020:	e13ffc17 	ldw	r4,-16(fp)
 202d024:	20c7883a 	add	r3,r4,r3
 202d028:	18c01904 	addi	r3,r3,100
 202d02c:	18c00003 	ldbu	r3,0(r3)
 202d030:	18c03fcc 	andi	r3,r3,255
 202d034:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
 202d038:	e0bffc17 	ldw	r2,-16(fp)
 202d03c:	10800417 	ldw	r2,16(r2)
 202d040:	10800044 	addi	r2,r2,1
 202d044:	e0fffc17 	ldw	r3,-16(fp)
 202d048:	18800415 	stw	r2,16(r3)
 202d04c:	10c00fcc 	andi	r3,r2,63
 202d050:	e0bffc17 	ldw	r2,-16(fp)
 202d054:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 202d058:	e0bffc17 	ldw	r2,-16(fp)
 202d05c:	10800117 	ldw	r2,4(r2)
 202d060:	10c01014 	ori	r3,r2,64
 202d064:	e0bffc17 	ldw	r2,-16(fp)
 202d068:	10c00115 	stw	r3,4(r2)
 202d06c:	00000e06 	br	202d0a8 <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
 202d070:	e0bffc17 	ldw	r2,-16(fp)
 202d074:	10800017 	ldw	r2,0(r2)
 202d078:	10800204 	addi	r2,r2,8
 202d07c:	10800037 	ldwio	r2,0(r2)
 202d080:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 202d084:	e0bffd17 	ldw	r2,-12(fp)
 202d088:	1082000c 	andi	r2,r2,2048
 202d08c:	1000061e 	bne	r2,zero,202d0a8 <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 202d090:	e0bffc17 	ldw	r2,-16(fp)
 202d094:	10c00117 	ldw	r3,4(r2)
 202d098:	00bfefc4 	movi	r2,-65
 202d09c:	1886703a 	and	r3,r3,r2
 202d0a0:	e0bffc17 	ldw	r2,-16(fp)
 202d0a4:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
 202d0a8:	e0bffc17 	ldw	r2,-16(fp)
 202d0ac:	10c00417 	ldw	r3,16(r2)
 202d0b0:	e0bffc17 	ldw	r2,-16(fp)
 202d0b4:	10800517 	ldw	r2,20(r2)
 202d0b8:	1880061e 	bne	r3,r2,202d0d4 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 202d0bc:	e0bffc17 	ldw	r2,-16(fp)
 202d0c0:	10c00117 	ldw	r3,4(r2)
 202d0c4:	00beefc4 	movi	r2,-1089
 202d0c8:	1886703a 	and	r3,r3,r2
 202d0cc:	e0bffc17 	ldw	r2,-16(fp)
 202d0d0:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202d0d4:	e0bffc17 	ldw	r2,-16(fp)
 202d0d8:	10800017 	ldw	r2,0(r2)
 202d0dc:	10800304 	addi	r2,r2,12
 202d0e0:	e0fffc17 	ldw	r3,-16(fp)
 202d0e4:	18c00117 	ldw	r3,4(r3)
 202d0e8:	10c00035 	stwio	r3,0(r2)
}
 202d0ec:	0001883a 	nop
 202d0f0:	e037883a 	mov	sp,fp
 202d0f4:	df000017 	ldw	fp,0(sp)
 202d0f8:	dec00104 	addi	sp,sp,4
 202d0fc:	f800283a 	ret

0202d100 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
 202d100:	defffd04 	addi	sp,sp,-12
 202d104:	df000215 	stw	fp,8(sp)
 202d108:	df000204 	addi	fp,sp,8
 202d10c:	e13ffe15 	stw	r4,-8(fp)
 202d110:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 202d114:	00000506 	br	202d12c <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 202d118:	e0bfff17 	ldw	r2,-4(fp)
 202d11c:	1090000c 	andi	r2,r2,16384
 202d120:	10000226 	beq	r2,zero,202d12c <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
 202d124:	00bffd44 	movi	r2,-11
 202d128:	00000606 	br	202d144 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 202d12c:	e0bffe17 	ldw	r2,-8(fp)
 202d130:	10c00417 	ldw	r3,16(r2)
 202d134:	e0bffe17 	ldw	r2,-8(fp)
 202d138:	10800517 	ldw	r2,20(r2)
 202d13c:	18bff61e 	bne	r3,r2,202d118 <__alt_mem_mem_0+0xfd00d118>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 202d140:	0005883a 	mov	r2,zero
}
 202d144:	e037883a 	mov	sp,fp
 202d148:	df000017 	ldw	fp,0(sp)
 202d14c:	dec00104 	addi	sp,sp,4
 202d150:	f800283a 	ret

0202d154 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202d154:	defffe04 	addi	sp,sp,-8
 202d158:	dfc00115 	stw	ra,4(sp)
 202d15c:	df000015 	stw	fp,0(sp)
 202d160:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202d164:	d0a01b17 	ldw	r2,-32660(gp)
 202d168:	10000326 	beq	r2,zero,202d178 <alt_get_errno+0x24>
 202d16c:	d0a01b17 	ldw	r2,-32660(gp)
 202d170:	103ee83a 	callr	r2
 202d174:	00000106 	br	202d17c <alt_get_errno+0x28>
 202d178:	d0a7a404 	addi	r2,gp,-24944
}
 202d17c:	e037883a 	mov	sp,fp
 202d180:	dfc00117 	ldw	ra,4(sp)
 202d184:	df000017 	ldw	fp,0(sp)
 202d188:	dec00204 	addi	sp,sp,8
 202d18c:	f800283a 	ret

0202d190 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
 202d190:	deffef04 	addi	sp,sp,-68
 202d194:	dfc01015 	stw	ra,64(sp)
 202d198:	df000f15 	stw	fp,60(sp)
 202d19c:	df000f04 	addi	fp,sp,60
 202d1a0:	e13ffb15 	stw	r4,-20(fp)
 202d1a4:	e17ffc15 	stw	r5,-16(fp)
 202d1a8:	e1bffd15 	stw	r6,-12(fp)
 202d1ac:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
 202d1b0:	e03ff105 	stb	zero,-60(fp)
  int             count = 0;
 202d1b4:	e03ff215 	stw	zero,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
 202d1b8:	e0bffe17 	ldw	r2,-8(fp)
 202d1bc:	1090000c 	andi	r2,r2,16384
 202d1c0:	1005003a 	cmpeq	r2,r2,zero
 202d1c4:	10803fcc 	andi	r2,r2,255
 202d1c8:	e0bff315 	stw	r2,-52(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
 202d1cc:	e0bffb17 	ldw	r2,-20(fp)
 202d1d0:	10800717 	ldw	r2,28(r2)
 202d1d4:	e0bff915 	stw	r2,-28(fp)
 202d1d8:	e03ffa0d 	sth	zero,-24(fp)
 * converted into the functions return value.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (xSemaphoreHandle sem, alt_u16 timeout)
{
	return xSemaphoreTake(sem, timeout) ? 0 : -1;
 202d1dc:	e0bffa0b 	ldhu	r2,-24(fp)
 202d1e0:	100b883a 	mov	r5,r2
 202d1e4:	e13ff917 	ldw	r4,-28(fp)
 202d1e8:	200ddd40 	call	200ddd4 <xQueueSemaphoreTake>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 202d1ec:	00001306 	br	202d23c <altera_avalon_uart_read+0xac>
    {
      count++;
 202d1f0:	e0bff217 	ldw	r2,-56(fp)
 202d1f4:	10800044 	addi	r2,r2,1
 202d1f8:	e0bff215 	stw	r2,-56(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
 202d1fc:	e0bffc17 	ldw	r2,-16(fp)
 202d200:	10c00044 	addi	r3,r2,1
 202d204:	e0fffc15 	stw	r3,-16(fp)
 202d208:	e0fffb17 	ldw	r3,-20(fp)
 202d20c:	18c00217 	ldw	r3,8(r3)
 202d210:	e13ffb17 	ldw	r4,-20(fp)
 202d214:	20c7883a 	add	r3,r4,r3
 202d218:	18c00904 	addi	r3,r3,36
 202d21c:	18c00003 	ldbu	r3,0(r3)
 202d220:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
 202d224:	e0bffb17 	ldw	r2,-20(fp)
 202d228:	10800217 	ldw	r2,8(r2)
 202d22c:	10800044 	addi	r2,r2,1
 202d230:	10c00fcc 	andi	r3,r2,63
 202d234:	e0bffb17 	ldw	r2,-20(fp)
 202d238:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 202d23c:	e0fff217 	ldw	r3,-56(fp)
 202d240:	e0bffd17 	ldw	r2,-12(fp)
 202d244:	1880050e 	bge	r3,r2,202d25c <altera_avalon_uart_read+0xcc>
 202d248:	e0bffb17 	ldw	r2,-20(fp)
 202d24c:	10c00217 	ldw	r3,8(r2)
 202d250:	e0bffb17 	ldw	r2,-20(fp)
 202d254:	10800317 	ldw	r2,12(r2)
 202d258:	18bfe51e 	bne	r3,r2,202d1f0 <__alt_mem_mem_0+0xfd00d1f0>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
 202d25c:	e0bff217 	ldw	r2,-56(fp)
 202d260:	1000251e 	bne	r2,zero,202d2f8 <altera_avalon_uart_read+0x168>
 202d264:	e0bffb17 	ldw	r2,-20(fp)
 202d268:	10c00217 	ldw	r3,8(r2)
 202d26c:	e0bffb17 	ldw	r2,-20(fp)
 202d270:	10800317 	ldw	r2,12(r2)
 202d274:	1880201e 	bne	r3,r2,202d2f8 <altera_avalon_uart_read+0x168>
    {
      if (!block)
 202d278:	e0bff317 	ldw	r2,-52(fp)
 202d27c:	1000071e 	bne	r2,zero,202d29c <altera_avalon_uart_read+0x10c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
 202d280:	202d1540 	call	202d154 <alt_get_errno>
 202d284:	1007883a 	mov	r3,r2
 202d288:	008002c4 	movi	r2,11
 202d28c:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
 202d290:	00800044 	movi	r2,1
 202d294:	e0bff105 	stb	r2,-60(fp)
        break;
 202d298:	00001b06 	br	202d308 <altera_avalon_uart_read+0x178>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202d29c:	0005303a 	rdctl	r2,status
 202d2a0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202d2a4:	e0fff617 	ldw	r3,-40(fp)
 202d2a8:	00bfff84 	movi	r2,-2
 202d2ac:	1884703a 	and	r2,r3,r2
 202d2b0:	1001703a 	wrctl	status,r2
  
  return context;
 202d2b4:	e0bff617 	ldw	r2,-40(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
 202d2b8:	e0bff515 	stw	r2,-44(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 202d2bc:	e0bffb17 	ldw	r2,-20(fp)
 202d2c0:	10800117 	ldw	r2,4(r2)
 202d2c4:	10c02014 	ori	r3,r2,128
 202d2c8:	e0bffb17 	ldw	r2,-20(fp)
 202d2cc:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202d2d0:	e0bffb17 	ldw	r2,-20(fp)
 202d2d4:	10800017 	ldw	r2,0(r2)
 202d2d8:	10800304 	addi	r2,r2,12
 202d2dc:	e0fffb17 	ldw	r3,-20(fp)
 202d2e0:	18c00117 	ldw	r3,4(r3)
 202d2e4:	10c00035 	stwio	r3,0(r2)
 202d2e8:	e0bff517 	ldw	r2,-44(fp)
 202d2ec:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202d2f0:	e0bff717 	ldw	r2,-36(fp)
 202d2f4:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
 202d2f8:	e0bff217 	ldw	r2,-56(fp)
 202d2fc:	1000021e 	bne	r2,zero,202d308 <altera_avalon_uart_read+0x178>
 202d300:	e0bffd17 	ldw	r2,-12(fp)
 202d304:	103fcd1e 	bne	r2,zero,202d23c <__alt_mem_mem_0+0xfd00d23c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 202d308:	e0bffb17 	ldw	r2,-20(fp)
 202d30c:	10800717 	ldw	r2,28(r2)
 202d310:	000f883a 	mov	r7,zero
 202d314:	000d883a 	mov	r6,zero
 202d318:	000b883a 	mov	r5,zero
 202d31c:	1009883a 	mov	r4,r2
 202d320:	200d8480 	call	200d848 <xQueueGenericSend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202d324:	0005303a 	rdctl	r2,status
 202d328:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202d32c:	e0fff817 	ldw	r3,-32(fp)
 202d330:	00bfff84 	movi	r2,-2
 202d334:	1884703a 	and	r2,r3,r2
 202d338:	1001703a 	wrctl	status,r2
  
  return context;
 202d33c:	e0bff817 	ldw	r2,-32(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
 202d340:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 202d344:	e0bffb17 	ldw	r2,-20(fp)
 202d348:	10800117 	ldw	r2,4(r2)
 202d34c:	10c02014 	ori	r3,r2,128
 202d350:	e0bffb17 	ldw	r2,-20(fp)
 202d354:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202d358:	e0bffb17 	ldw	r2,-20(fp)
 202d35c:	10800017 	ldw	r2,0(r2)
 202d360:	10800304 	addi	r2,r2,12
 202d364:	e0fffb17 	ldw	r3,-20(fp)
 202d368:	18c00117 	ldw	r3,4(r3)
 202d36c:	10c00035 	stwio	r3,0(r2)
 202d370:	e0bff517 	ldw	r2,-44(fp)
 202d374:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202d378:	e0bff417 	ldw	r2,-48(fp)
 202d37c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
 202d380:	e0bff103 	ldbu	r2,-60(fp)
 202d384:	10000226 	beq	r2,zero,202d390 <altera_avalon_uart_read+0x200>
    return -EWOULDBLOCK;
 202d388:	00bffd44 	movi	r2,-11
 202d38c:	00000106 	br	202d394 <altera_avalon_uart_read+0x204>
  }
  else {
    return count;
 202d390:	e0bff217 	ldw	r2,-56(fp)
  }
}
 202d394:	e037883a 	mov	sp,fp
 202d398:	dfc00117 	ldw	ra,4(sp)
 202d39c:	df000017 	ldw	fp,0(sp)
 202d3a0:	dec00204 	addi	sp,sp,8
 202d3a4:	f800283a 	ret

0202d3a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202d3a8:	defffe04 	addi	sp,sp,-8
 202d3ac:	dfc00115 	stw	ra,4(sp)
 202d3b0:	df000015 	stw	fp,0(sp)
 202d3b4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202d3b8:	d0a01b17 	ldw	r2,-32660(gp)
 202d3bc:	10000326 	beq	r2,zero,202d3cc <alt_get_errno+0x24>
 202d3c0:	d0a01b17 	ldw	r2,-32660(gp)
 202d3c4:	103ee83a 	callr	r2
 202d3c8:	00000106 	br	202d3d0 <alt_get_errno+0x28>
 202d3cc:	d0a7a404 	addi	r2,gp,-24944
}
 202d3d0:	e037883a 	mov	sp,fp
 202d3d4:	dfc00117 	ldw	ra,4(sp)
 202d3d8:	df000017 	ldw	fp,0(sp)
 202d3dc:	dec00204 	addi	sp,sp,8
 202d3e0:	f800283a 	ret

0202d3e4 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
 202d3e4:	deffef04 	addi	sp,sp,-68
 202d3e8:	dfc01015 	stw	ra,64(sp)
 202d3ec:	df000f15 	stw	fp,60(sp)
 202d3f0:	df000f04 	addi	fp,sp,60
 202d3f4:	e13ffb15 	stw	r4,-20(fp)
 202d3f8:	e17ffc15 	stw	r5,-16(fp)
 202d3fc:	e1bffd15 	stw	r6,-12(fp)
 202d400:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
 202d404:	e0bffd17 	ldw	r2,-12(fp)
 202d408:	e0bff115 	stw	r2,-60(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
 202d40c:	e0bffe17 	ldw	r2,-8(fp)
 202d410:	1090000c 	andi	r2,r2,16384
 202d414:	e0bff215 	stw	r2,-56(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 202d418:	e0bffb17 	ldw	r2,-20(fp)
 202d41c:	10800817 	ldw	r2,32(r2)
 202d420:	e0bff915 	stw	r2,-28(fp)
 202d424:	e03ffa0d 	sth	zero,-24(fp)
 202d428:	e0bffa0b 	ldhu	r2,-24(fp)
 202d42c:	100b883a 	mov	r5,r2
 202d430:	e13ff917 	ldw	r4,-28(fp)
 202d434:	200ddd40 	call	200ddd4 <xQueueSemaphoreTake>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 202d438:	00003c06 	br	202d52c <altera_avalon_uart_write+0x148>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 202d43c:	e0bffb17 	ldw	r2,-20(fp)
 202d440:	10800517 	ldw	r2,20(r2)
 202d444:	10800044 	addi	r2,r2,1
 202d448:	10800fcc 	andi	r2,r2,63
 202d44c:	e0bff415 	stw	r2,-48(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
 202d450:	e0bffb17 	ldw	r2,-20(fp)
 202d454:	10c00417 	ldw	r3,16(r2)
 202d458:	e0bff417 	ldw	r2,-48(fp)
 202d45c:	1880221e 	bne	r3,r2,202d4e8 <altera_avalon_uart_write+0x104>
    {
      if (no_block)
 202d460:	e0bff217 	ldw	r2,-56(fp)
 202d464:	10000526 	beq	r2,zero,202d47c <altera_avalon_uart_write+0x98>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
 202d468:	202d3a80 	call	202d3a8 <alt_get_errno>
 202d46c:	1007883a 	mov	r3,r2
 202d470:	008002c4 	movi	r2,11
 202d474:	18800015 	stw	r2,0(r3)
        break;
 202d478:	00002e06 	br	202d534 <altera_avalon_uart_write+0x150>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202d47c:	0005303a 	rdctl	r2,status
 202d480:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202d484:	e0fff617 	ldw	r3,-40(fp)
 202d488:	00bfff84 	movi	r2,-2
 202d48c:	1884703a 	and	r2,r3,r2
 202d490:	1001703a 	wrctl	status,r2
  
  return context;
 202d494:	e0bff617 	ldw	r2,-40(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
 202d498:	e0bff515 	stw	r2,-44(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 202d49c:	e0bffb17 	ldw	r2,-20(fp)
 202d4a0:	10800117 	ldw	r2,4(r2)
 202d4a4:	10c11014 	ori	r3,r2,1088
 202d4a8:	e0bffb17 	ldw	r2,-20(fp)
 202d4ac:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202d4b0:	e0bffb17 	ldw	r2,-20(fp)
 202d4b4:	10800017 	ldw	r2,0(r2)
 202d4b8:	10800304 	addi	r2,r2,12
 202d4bc:	e0fffb17 	ldw	r3,-20(fp)
 202d4c0:	18c00117 	ldw	r3,4(r3)
 202d4c4:	10c00035 	stwio	r3,0(r2)
 202d4c8:	e0bff517 	ldw	r2,-44(fp)
 202d4cc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202d4d0:	e0bff317 	ldw	r2,-52(fp)
 202d4d4:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
 202d4d8:	e0bffb17 	ldw	r2,-20(fp)
 202d4dc:	10c00417 	ldw	r3,16(r2)
 202d4e0:	e0bff417 	ldw	r2,-48(fp)
 202d4e4:	18bffc26 	beq	r3,r2,202d4d8 <__alt_mem_mem_0+0xfd00d4d8>
      }
    }

    count--;
 202d4e8:	e0bff117 	ldw	r2,-60(fp)
 202d4ec:	10bfffc4 	addi	r2,r2,-1
 202d4f0:	e0bff115 	stw	r2,-60(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
 202d4f4:	e0bffb17 	ldw	r2,-20(fp)
 202d4f8:	10c00517 	ldw	r3,20(r2)
 202d4fc:	e0bffc17 	ldw	r2,-16(fp)
 202d500:	11000044 	addi	r4,r2,1
 202d504:	e13ffc15 	stw	r4,-16(fp)
 202d508:	10800003 	ldbu	r2,0(r2)
 202d50c:	1009883a 	mov	r4,r2
 202d510:	e0bffb17 	ldw	r2,-20(fp)
 202d514:	10c5883a 	add	r2,r2,r3
 202d518:	10801904 	addi	r2,r2,100
 202d51c:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
 202d520:	e0bffb17 	ldw	r2,-20(fp)
 202d524:	e0fff417 	ldw	r3,-48(fp)
 202d528:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 202d52c:	e0bff117 	ldw	r2,-60(fp)
 202d530:	103fc21e 	bne	r2,zero,202d43c <__alt_mem_mem_0+0xfd00d43c>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 202d534:	e0bffb17 	ldw	r2,-20(fp)
 202d538:	10800817 	ldw	r2,32(r2)
 202d53c:	000f883a 	mov	r7,zero
 202d540:	000d883a 	mov	r6,zero
 202d544:	000b883a 	mov	r5,zero
 202d548:	1009883a 	mov	r4,r2
 202d54c:	200d8480 	call	200d848 <xQueueGenericSend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202d550:	0005303a 	rdctl	r2,status
 202d554:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202d558:	e0fff817 	ldw	r3,-32(fp)
 202d55c:	00bfff84 	movi	r2,-2
 202d560:	1884703a 	and	r2,r3,r2
 202d564:	1001703a 	wrctl	status,r2
  
  return context;
 202d568:	e0bff817 	ldw	r2,-32(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
 202d56c:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 202d570:	e0bffb17 	ldw	r2,-20(fp)
 202d574:	10800117 	ldw	r2,4(r2)
 202d578:	10c11014 	ori	r3,r2,1088
 202d57c:	e0bffb17 	ldw	r2,-20(fp)
 202d580:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202d584:	e0bffb17 	ldw	r2,-20(fp)
 202d588:	10800017 	ldw	r2,0(r2)
 202d58c:	10800304 	addi	r2,r2,12
 202d590:	e0fffb17 	ldw	r3,-20(fp)
 202d594:	18c00117 	ldw	r3,4(r3)
 202d598:	10c00035 	stwio	r3,0(r2)
 202d59c:	e0bff517 	ldw	r2,-44(fp)
 202d5a0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202d5a4:	e0bff717 	ldw	r2,-36(fp)
 202d5a8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
 202d5ac:	e0fffd17 	ldw	r3,-12(fp)
 202d5b0:	e0bff117 	ldw	r2,-60(fp)
 202d5b4:	1885c83a 	sub	r2,r3,r2
}
 202d5b8:	e037883a 	mov	sp,fp
 202d5bc:	dfc00117 	ldw	ra,4(sp)
 202d5c0:	df000017 	ldw	fp,0(sp)
 202d5c4:	dec00204 	addi	sp,sp,8
 202d5c8:	f800283a 	ret

0202d5cc <__env_lock>:
xSemaphoreHandle alt_envsem;

/* __env_lock needs to provide recursive mutex locking */

void __env_lock ( struct _reent *_r )
{
 202d5cc:	defffd04 	addi	sp,sp,-12
 202d5d0:	dfc00215 	stw	ra,8(sp)
 202d5d4:	df000115 	stw	fp,4(sp)
 202d5d8:	df000104 	addi	fp,sp,4
 202d5dc:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 202d5e0:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 202d5e4:	10000b26 	beq	r2,zero,202d614 <__env_lock+0x48>
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
 202d5e8:	00000206 	br	202d5f4 <__env_lock+0x28>
		vTaskDelay(1);
 202d5ec:	01000044 	movi	r4,1
 202d5f0:	200f0980 	call	200f098 <vTaskDelay>
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
 202d5f4:	d0a7f417 	ldw	r2,-24624(gp)
 202d5f8:	01400284 	movi	r5,10
 202d5fc:	1009883a 	mov	r4,r2
 202d600:	200d7540 	call	200d754 <xQueueTakeMutexRecursive>
 202d604:	10800058 	cmpnei	r2,r2,1
 202d608:	103ff81e 	bne	r2,zero,202d5ec <__alt_mem_mem_0+0xfd00d5ec>
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
 202d60c:	0001883a 	nop
 202d610:	00000106 	br	202d618 <__env_lock+0x4c>

void __env_lock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 202d614:	0001883a 	nop
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
}
 202d618:	e037883a 	mov	sp,fp
 202d61c:	dfc00117 	ldw	ra,4(sp)
 202d620:	df000017 	ldw	fp,0(sp)
 202d624:	dec00204 	addi	sp,sp,8
 202d628:	f800283a 	ret

0202d62c <__env_unlock>:

/* __env_unlock needs to provide recursive mutex unlocking */

void __env_unlock ( struct _reent *_r )
{
 202d62c:	defffd04 	addi	sp,sp,-12
 202d630:	dfc00215 	stw	ra,8(sp)
 202d634:	df000115 	stw	fp,4(sp)
 202d638:	df000104 	addi	fp,sp,4
 202d63c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 202d640:	2010a200 	call	2010a20 <xTaskGetSchedulerState>
 202d644:	10000426 	beq	r2,zero,202d658 <__env_unlock+0x2c>
		return;
	  
	xSemaphoreGiveRecursive(alt_envsem);
 202d648:	d0a7f417 	ldw	r2,-24624(gp)
 202d64c:	1009883a 	mov	r4,r2
 202d650:	200d6c40 	call	200d6c4 <xQueueGiveMutexRecursive>
 202d654:	00000106 	br	202d65c <__env_unlock+0x30>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 202d658:	0001883a 	nop
	  
	xSemaphoreGiveRecursive(alt_envsem);
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 202d65c:	e037883a 	mov	sp,fp
 202d660:	dfc00117 	ldw	ra,4(sp)
 202d664:	df000017 	ldw	fp,0(sp)
 202d668:	dec00204 	addi	sp,sp,8
 202d66c:	f800283a 	ret

0202d670 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 202d670:	defffc04 	addi	sp,sp,-16
 202d674:	dfc00315 	stw	ra,12(sp)
 202d678:	df000215 	stw	fp,8(sp)
 202d67c:	df000204 	addi	fp,sp,8
 202d680:	e13fff15 	stw	r4,-4(fp)
void *pvReturn = NULL;
 202d684:	e03ffe15 	stw	zero,-8(fp)
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 202d688:	e0bfff17 	ldw	r2,-4(fp)
 202d68c:	108000cc 	andi	r2,r2,3
 202d690:	10000526 	beq	r2,zero,202d6a8 <pvPortMalloc+0x38>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 202d694:	e0ffff17 	ldw	r3,-4(fp)
 202d698:	00bfff04 	movi	r2,-4
 202d69c:	1884703a 	and	r2,r3,r2
 202d6a0:	10800104 	addi	r2,r2,4
 202d6a4:	e0bfff15 	stw	r2,-4(fp)
		}
	}
	#endif

	vTaskSuspendAll();
 202d6a8:	200f8840 	call	200f884 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 202d6ac:	d0a7f617 	ldw	r2,-24616(gp)
 202d6b0:	1000051e 	bne	r2,zero,202d6c8 <pvPortMalloc+0x58>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 202d6b4:	00808174 	movhi	r2,517
 202d6b8:	10b46504 	addi	r2,r2,-11884
 202d6bc:	00ffff04 	movi	r3,-4
 202d6c0:	10c4703a 	and	r2,r2,r3
 202d6c4:	d0a7f615 	stw	r2,-24616(gp)
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 202d6c8:	d0e7f517 	ldw	r3,-24620(gp)
 202d6cc:	e0bfff17 	ldw	r2,-4(fp)
 202d6d0:	1887883a 	add	r3,r3,r2
 202d6d4:	00800434 	movhi	r2,16
 202d6d8:	10bffec4 	addi	r2,r2,-5
 202d6dc:	10c00d36 	bltu	r2,r3,202d714 <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
 202d6e0:	d0e7f517 	ldw	r3,-24620(gp)
 202d6e4:	e0bfff17 	ldw	r2,-4(fp)
 202d6e8:	1885883a 	add	r2,r3,r2
 202d6ec:	d0e7f517 	ldw	r3,-24620(gp)
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 202d6f0:	1880082e 	bgeu	r3,r2,202d714 <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 202d6f4:	d0e7f617 	ldw	r3,-24616(gp)
 202d6f8:	d0a7f517 	ldw	r2,-24620(gp)
 202d6fc:	1885883a 	add	r2,r3,r2
 202d700:	e0bffe15 	stw	r2,-8(fp)
			xNextFreeByte += xWantedSize;
 202d704:	d0e7f517 	ldw	r3,-24620(gp)
 202d708:	e0bfff17 	ldw	r2,-4(fp)
 202d70c:	1885883a 	add	r2,r3,r2
 202d710:	d0a7f515 	stw	r2,-24620(gp)
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 202d714:	200f8b00 	call	200f8b0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 202d718:	e0bffe17 	ldw	r2,-8(fp)
}
 202d71c:	e037883a 	mov	sp,fp
 202d720:	dfc00117 	ldw	ra,4(sp)
 202d724:	df000017 	ldw	fp,0(sp)
 202d728:	dec00204 	addi	sp,sp,8
 202d72c:	f800283a 	ret

0202d730 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 202d730:	defffe04 	addi	sp,sp,-8
 202d734:	df000115 	stw	fp,4(sp)
 202d738:	df000104 	addi	fp,sp,4
 202d73c:	e13fff15 	stw	r4,-4(fp)
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
 202d740:	0001883a 	nop
 202d744:	e037883a 	mov	sp,fp
 202d748:	df000017 	ldw	fp,0(sp)
 202d74c:	dec00104 	addi	sp,sp,4
 202d750:	f800283a 	ret

0202d754 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 202d754:	deffff04 	addi	sp,sp,-4
 202d758:	df000015 	stw	fp,0(sp)
 202d75c:	d839883a 	mov	fp,sp
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
 202d760:	d027f515 	stw	zero,-24620(gp)
}
 202d764:	0001883a 	nop
 202d768:	e037883a 	mov	sp,fp
 202d76c:	df000017 	ldw	fp,0(sp)
 202d770:	dec00104 	addi	sp,sp,4
 202d774:	f800283a 	ret

0202d778 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 202d778:	deffff04 	addi	sp,sp,-4
 202d77c:	df000015 	stw	fp,0(sp)
 202d780:	d839883a 	mov	fp,sp
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 202d784:	d0e7f517 	ldw	r3,-24620(gp)
 202d788:	00800434 	movhi	r2,16
 202d78c:	10bfff04 	addi	r2,r2,-4
 202d790:	10c5c83a 	sub	r2,r2,r3
}
 202d794:	e037883a 	mov	sp,fp
 202d798:	df000017 	ldw	fp,0(sp)
 202d79c:	dec00104 	addi	sp,sp,4
 202d7a0:	f800283a 	ret

0202d7a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 202d7a4:	defffe04 	addi	sp,sp,-8
 202d7a8:	df000115 	stw	fp,4(sp)
 202d7ac:	df000104 	addi	fp,sp,4
 202d7b0:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 202d7b4:	e0bfff17 	ldw	r2,-4(fp)
 202d7b8:	10c00204 	addi	r3,r2,8
 202d7bc:	e0bfff17 	ldw	r2,-4(fp)
 202d7c0:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 202d7c4:	e0bfff17 	ldw	r2,-4(fp)
 202d7c8:	00ffffc4 	movi	r3,-1
 202d7cc:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 202d7d0:	e0bfff17 	ldw	r2,-4(fp)
 202d7d4:	10c00204 	addi	r3,r2,8
 202d7d8:	e0bfff17 	ldw	r2,-4(fp)
 202d7dc:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 202d7e0:	e0bfff17 	ldw	r2,-4(fp)
 202d7e4:	10c00204 	addi	r3,r2,8
 202d7e8:	e0bfff17 	ldw	r2,-4(fp)
 202d7ec:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 202d7f0:	e0bfff17 	ldw	r2,-4(fp)
 202d7f4:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 202d7f8:	0001883a 	nop
 202d7fc:	e037883a 	mov	sp,fp
 202d800:	df000017 	ldw	fp,0(sp)
 202d804:	dec00104 	addi	sp,sp,4
 202d808:	f800283a 	ret

0202d80c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 202d80c:	defffe04 	addi	sp,sp,-8
 202d810:	df000115 	stw	fp,4(sp)
 202d814:	df000104 	addi	fp,sp,4
 202d818:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 202d81c:	e0bfff17 	ldw	r2,-4(fp)
 202d820:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 202d824:	0001883a 	nop
 202d828:	e037883a 	mov	sp,fp
 202d82c:	df000017 	ldw	fp,0(sp)
 202d830:	dec00104 	addi	sp,sp,4
 202d834:	f800283a 	ret

0202d838 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 202d838:	defffc04 	addi	sp,sp,-16
 202d83c:	df000315 	stw	fp,12(sp)
 202d840:	df000304 	addi	fp,sp,12
 202d844:	e13ffe15 	stw	r4,-8(fp)
 202d848:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
 202d84c:	e0bffe17 	ldw	r2,-8(fp)
 202d850:	10800117 	ldw	r2,4(r2)
 202d854:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 202d858:	e0bfff17 	ldw	r2,-4(fp)
 202d85c:	e0fffd17 	ldw	r3,-12(fp)
 202d860:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 202d864:	e0bffd17 	ldw	r2,-12(fp)
 202d868:	10c00217 	ldw	r3,8(r2)
 202d86c:	e0bfff17 	ldw	r2,-4(fp)
 202d870:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 202d874:	e0bffd17 	ldw	r2,-12(fp)
 202d878:	10800217 	ldw	r2,8(r2)
 202d87c:	e0ffff17 	ldw	r3,-4(fp)
 202d880:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
 202d884:	e0bffd17 	ldw	r2,-12(fp)
 202d888:	e0ffff17 	ldw	r3,-4(fp)
 202d88c:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 202d890:	e0bfff17 	ldw	r2,-4(fp)
 202d894:	e0fffe17 	ldw	r3,-8(fp)
 202d898:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 202d89c:	e0bffe17 	ldw	r2,-8(fp)
 202d8a0:	10800017 	ldw	r2,0(r2)
 202d8a4:	10c00044 	addi	r3,r2,1
 202d8a8:	e0bffe17 	ldw	r2,-8(fp)
 202d8ac:	10c00015 	stw	r3,0(r2)
}
 202d8b0:	0001883a 	nop
 202d8b4:	e037883a 	mov	sp,fp
 202d8b8:	df000017 	ldw	fp,0(sp)
 202d8bc:	dec00104 	addi	sp,sp,4
 202d8c0:	f800283a 	ret

0202d8c4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 202d8c4:	defffb04 	addi	sp,sp,-20
 202d8c8:	df000415 	stw	fp,16(sp)
 202d8cc:	df000404 	addi	fp,sp,16
 202d8d0:	e13ffe15 	stw	r4,-8(fp)
 202d8d4:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 202d8d8:	e0bfff17 	ldw	r2,-4(fp)
 202d8dc:	10800017 	ldw	r2,0(r2)
 202d8e0:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 202d8e4:	e0bffd17 	ldw	r2,-12(fp)
 202d8e8:	10bfffd8 	cmpnei	r2,r2,-1
 202d8ec:	1000041e 	bne	r2,zero,202d900 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 202d8f0:	e0bffe17 	ldw	r2,-8(fp)
 202d8f4:	10800417 	ldw	r2,16(r2)
 202d8f8:	e0bffc15 	stw	r2,-16(fp)
 202d8fc:	00000c06 	br	202d930 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 202d900:	e0bffe17 	ldw	r2,-8(fp)
 202d904:	10800204 	addi	r2,r2,8
 202d908:	e0bffc15 	stw	r2,-16(fp)
 202d90c:	00000306 	br	202d91c <vListInsert+0x58>
 202d910:	e0bffc17 	ldw	r2,-16(fp)
 202d914:	10800117 	ldw	r2,4(r2)
 202d918:	e0bffc15 	stw	r2,-16(fp)
 202d91c:	e0bffc17 	ldw	r2,-16(fp)
 202d920:	10800117 	ldw	r2,4(r2)
 202d924:	10800017 	ldw	r2,0(r2)
 202d928:	e0fffd17 	ldw	r3,-12(fp)
 202d92c:	18bff82e 	bgeu	r3,r2,202d910 <__alt_mem_mem_0+0xfd00d910>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 202d930:	e0bffc17 	ldw	r2,-16(fp)
 202d934:	10c00117 	ldw	r3,4(r2)
 202d938:	e0bfff17 	ldw	r2,-4(fp)
 202d93c:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 202d940:	e0bfff17 	ldw	r2,-4(fp)
 202d944:	10800117 	ldw	r2,4(r2)
 202d948:	e0ffff17 	ldw	r3,-4(fp)
 202d94c:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
 202d950:	e0bfff17 	ldw	r2,-4(fp)
 202d954:	e0fffc17 	ldw	r3,-16(fp)
 202d958:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
 202d95c:	e0bffc17 	ldw	r2,-16(fp)
 202d960:	e0ffff17 	ldw	r3,-4(fp)
 202d964:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 202d968:	e0bfff17 	ldw	r2,-4(fp)
 202d96c:	e0fffe17 	ldw	r3,-8(fp)
 202d970:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 202d974:	e0bffe17 	ldw	r2,-8(fp)
 202d978:	10800017 	ldw	r2,0(r2)
 202d97c:	10c00044 	addi	r3,r2,1
 202d980:	e0bffe17 	ldw	r2,-8(fp)
 202d984:	10c00015 	stw	r3,0(r2)
}
 202d988:	0001883a 	nop
 202d98c:	e037883a 	mov	sp,fp
 202d990:	df000017 	ldw	fp,0(sp)
 202d994:	dec00104 	addi	sp,sp,4
 202d998:	f800283a 	ret

0202d99c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 202d99c:	defffd04 	addi	sp,sp,-12
 202d9a0:	df000215 	stw	fp,8(sp)
 202d9a4:	df000204 	addi	fp,sp,8
 202d9a8:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 202d9ac:	e0bfff17 	ldw	r2,-4(fp)
 202d9b0:	10800417 	ldw	r2,16(r2)
 202d9b4:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 202d9b8:	e0bfff17 	ldw	r2,-4(fp)
 202d9bc:	10800117 	ldw	r2,4(r2)
 202d9c0:	e0ffff17 	ldw	r3,-4(fp)
 202d9c4:	18c00217 	ldw	r3,8(r3)
 202d9c8:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 202d9cc:	e0bfff17 	ldw	r2,-4(fp)
 202d9d0:	10800217 	ldw	r2,8(r2)
 202d9d4:	e0ffff17 	ldw	r3,-4(fp)
 202d9d8:	18c00117 	ldw	r3,4(r3)
 202d9dc:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 202d9e0:	e0bffe17 	ldw	r2,-8(fp)
 202d9e4:	10c00117 	ldw	r3,4(r2)
 202d9e8:	e0bfff17 	ldw	r2,-4(fp)
 202d9ec:	1880041e 	bne	r3,r2,202da00 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 202d9f0:	e0bfff17 	ldw	r2,-4(fp)
 202d9f4:	10c00217 	ldw	r3,8(r2)
 202d9f8:	e0bffe17 	ldw	r2,-8(fp)
 202d9fc:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 202da00:	e0bfff17 	ldw	r2,-4(fp)
 202da04:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
 202da08:	e0bffe17 	ldw	r2,-8(fp)
 202da0c:	10800017 	ldw	r2,0(r2)
 202da10:	10ffffc4 	addi	r3,r2,-1
 202da14:	e0bffe17 	ldw	r2,-8(fp)
 202da18:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
 202da1c:	e0bffe17 	ldw	r2,-8(fp)
 202da20:	10800017 	ldw	r2,0(r2)
}
 202da24:	e037883a 	mov	sp,fp
 202da28:	df000017 	ldw	fp,0(sp)
 202da2c:	dec00104 	addi	sp,sp,4
 202da30:	f800283a 	ret

0202da34 <prvReadGp>:
void vPortSysTickHandler( void * context, alt_u32 id );

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 202da34:	defffe04 	addi	sp,sp,-8
 202da38:	df000115 	stw	fp,4(sp)
 202da3c:	df000104 	addi	fp,sp,4
 202da40:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 202da44:	e0bfff17 	ldw	r2,-4(fp)
 202da48:	16800015 	stw	gp,0(r2)
}
 202da4c:	0001883a 	nop
 202da50:	e037883a 	mov	sp,fp
 202da54:	df000017 	ldw	fp,0(sp)
 202da58:	dec00104 	addi	sp,sp,4
 202da5c:	f800283a 	ret

0202da60 <enh_alt_irq_disable_all>:


static volatile alt_irq_context lastContext;

void enh_alt_irq_disable_all()
{
 202da60:	defffd04 	addi	sp,sp,-12
 202da64:	df000215 	stw	fp,8(sp)
 202da68:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202da6c:	0005303a 	rdctl	r2,status
 202da70:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202da74:	e0ffff17 	ldw	r3,-4(fp)
 202da78:	00bfff84 	movi	r2,-2
 202da7c:	1884703a 	and	r2,r3,r2
 202da80:	1001703a 	wrctl	status,r2
  
  return context;
 202da84:	e0bfff17 	ldw	r2,-4(fp)
	alt_irq_context ctxt = alt_irq_disable_all();
 202da88:	e0bffe15 	stw	r2,-8(fp)
	lastContext |= ctxt;
 202da8c:	d0e7f717 	ldw	r3,-24612(gp)
 202da90:	e0bffe17 	ldw	r2,-8(fp)
 202da94:	1884b03a 	or	r2,r3,r2
 202da98:	d0a7f715 	stw	r2,-24612(gp)
}
 202da9c:	0001883a 	nop
 202daa0:	e037883a 	mov	sp,fp
 202daa4:	df000017 	ldw	fp,0(sp)
 202daa8:	dec00104 	addi	sp,sp,4
 202daac:	f800283a 	ret

0202dab0 <enh_alt_irq_enable_all>:

void enh_alt_irq_enable_all()
{
 202dab0:	defffd04 	addi	sp,sp,-12
 202dab4:	df000215 	stw	fp,8(sp)
 202dab8:	df000204 	addi	fp,sp,8
	alt_irq_context restore = lastContext;
 202dabc:	d0a7f717 	ldw	r2,-24612(gp)
 202dac0:	e0bffe15 	stw	r2,-8(fp)
	lastContext = 0;
 202dac4:	d027f715 	stw	zero,-24612(gp)
 202dac8:	e0bffe17 	ldw	r2,-8(fp)
 202dacc:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202dad0:	e0bfff17 	ldw	r2,-4(fp)
 202dad4:	1001703a 	wrctl	status,r2
	alt_irq_enable_all(restore);
}
 202dad8:	0001883a 	nop
 202dadc:	e037883a 	mov	sp,fp
 202dae0:	df000017 	ldw	fp,0(sp)
 202dae4:	dec00104 	addi	sp,sp,4
 202dae8:	f800283a 	ret

0202daec <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 202daec:	defff904 	addi	sp,sp,-28
 202daf0:	dfc00615 	stw	ra,24(sp)
 202daf4:	df000515 	stw	fp,20(sp)
 202daf8:	df000504 	addi	fp,sp,20
 202dafc:	e13ffd15 	stw	r4,-12(fp)
 202db00:	e17ffe15 	stw	r5,-8(fp)
 202db04:	e1bfff15 	stw	r6,-4(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 202db08:	e0bffd17 	ldw	r2,-12(fp)
 202db0c:	10bfff04 	addi	r2,r2,-4
 202db10:	e0bffb15 	stw	r2,-20(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 202db14:	e0bffc04 	addi	r2,fp,-16
 202db18:	1009883a 	mov	r4,r2
 202db1c:	202da340 	call	202da34 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 202db20:	e0fffd17 	ldw	r3,-12(fp)
 202db24:	00b7abb4 	movhi	r2,57006
 202db28:	10afbbc4 	addi	r2,r2,-16657
 202db2c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 202db30:	e0bffd17 	ldw	r2,-12(fp)
 202db34:	10bfff04 	addi	r2,r2,-4
 202db38:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 202db3c:	e0fffb17 	ldw	r3,-20(fp)
 202db40:	e0bffd17 	ldw	r2,-12(fp)
 202db44:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 202db48:	e0bffd17 	ldw	r2,-12(fp)
 202db4c:	10bfff04 	addi	r2,r2,-4
 202db50:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 202db54:	e0fffc17 	ldw	r3,-16(fp)
 202db58:	e0bffd17 	ldw	r2,-12(fp)
 202db5c:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 202db60:	e0bffd17 	ldw	r2,-12(fp)
 202db64:	10bff704 	addi	r2,r2,-36
 202db68:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 202db6c:	e0fffe17 	ldw	r3,-8(fp)
 202db70:	e0bffd17 	ldw	r2,-12(fp)
 202db74:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 202db78:	e0bffd17 	ldw	r2,-12(fp)
 202db7c:	10bfff04 	addi	r2,r2,-4
 202db80:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 202db84:	e0bffd17 	ldw	r2,-12(fp)
 202db88:	00c00044 	movi	r3,1
 202db8c:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 202db90:	e0bffd17 	ldw	r2,-12(fp)
 202db94:	10bff404 	addi	r2,r2,-48
 202db98:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 202db9c:	e0ffff17 	ldw	r3,-4(fp)
 202dba0:	e0bffd17 	ldw	r2,-12(fp)
 202dba4:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 202dba8:	e0bffd17 	ldw	r2,-12(fp)
 202dbac:	10bffb04 	addi	r2,r2,-20
 202dbb0:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 202dbb4:	e0bffd17 	ldw	r2,-12(fp)
}
 202dbb8:	e037883a 	mov	sp,fp
 202dbbc:	dfc00117 	ldw	ra,4(sp)
 202dbc0:	df000017 	ldw	fp,0(sp)
 202dbc4:	dec00204 	addi	sp,sp,8
 202dbc8:	f800283a 	ret

0202dbcc <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 202dbcc:	defffe04 	addi	sp,sp,-8
 202dbd0:	dfc00115 	stw	ra,4(sp)
 202dbd4:	df000015 	stw	fp,0(sp)
 202dbd8:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 202dbdc:	202dc240 	call	202dc24 <prvSetupTimerInterrupt>
 202dbe0:	00808034 	movhi	r2,512
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 202dbe4:	10803104 	addi	r2,r2,196
 202dbe8:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 202dbec:	0005883a 	mov	r2,zero
}
 202dbf0:	e037883a 	mov	sp,fp
 202dbf4:	dfc00117 	ldw	ra,4(sp)
 202dbf8:	df000017 	ldw	fp,0(sp)
 202dbfc:	dec00204 	addi	sp,sp,8
 202dc00:	f800283a 	ret

0202dc04 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 202dc04:	deffff04 	addi	sp,sp,-4
 202dc08:	df000015 	stw	fp,0(sp)
 202dc0c:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 202dc10:	0001883a 	nop
 202dc14:	e037883a 	mov	sp,fp
 202dc18:	df000017 	ldw	fp,0(sp)
 202dc1c:	dec00104 	addi	sp,sp,4
 202dc20:	f800283a 	ret

0202dc24 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 202dc24:	defffe04 	addi	sp,sp,-8
 202dc28:	dfc00115 	stw	ra,4(sp)
 202dc2c:	df000015 	stw	fp,0(sp)
 202dc30:	d839883a 	mov	fp,sp
	/* Try to register the interrupt handler. */
	if ( -EINVAL == alt_irq_register( SYS_CLK_IRQ, 0x0, vPortSysTickHandler ) )
 202dc34:	018080f4 	movhi	r6,515
 202dc38:	31b73004 	addi	r6,r6,-9024
 202dc3c:	000b883a 	mov	r5,zero
 202dc40:	010000c4 	movi	r4,3
 202dc44:	202dd0c0 	call	202dd0c <alt_irq_register>
 202dc48:	10bffa98 	cmpnei	r2,r2,-22
 202dc4c:	1000021e 	bne	r2,zero,202dc58 <prvSetupTimerInterrupt+0x34>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 202dc50:	003da03a 	break	0
 202dc54:	00001006 	br	202dc98 <prvSetupTimerInterrupt+0x74>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 202dc58:	00c00204 	movi	r3,8
 202dc5c:	00814134 	movhi	r2,1284
 202dc60:	10840904 	addi	r2,r2,4132
 202dc64:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 202dc68:	00e1a814 	movui	r3,34464
 202dc6c:	00814134 	movhi	r2,1284
 202dc70:	10840a04 	addi	r2,r2,4136
 202dc74:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 202dc78:	00c00044 	movi	r3,1
 202dc7c:	00814134 	movhi	r2,1284
 202dc80:	10840b04 	addi	r2,r2,4140
 202dc84:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );
 202dc88:	00c001c4 	movi	r3,7
 202dc8c:	00814134 	movhi	r2,1284
 202dc90:	10840904 	addi	r2,r2,4132
 202dc94:	10c00035 	stwio	r3,0(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 202dc98:	00ffff84 	movi	r3,-2
 202dc9c:	00814134 	movhi	r2,1284
 202dca0:	10840804 	addi	r2,r2,4128
 202dca4:	10c00035 	stwio	r3,0(r2)
}
 202dca8:	0001883a 	nop
 202dcac:	e037883a 	mov	sp,fp
 202dcb0:	dfc00117 	ldw	ra,4(sp)
 202dcb4:	df000017 	ldw	fp,0(sp)
 202dcb8:	dec00204 	addi	sp,sp,8
 202dcbc:	f800283a 	ret

0202dcc0 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context, alt_u32 id )
{
 202dcc0:	defffc04 	addi	sp,sp,-16
 202dcc4:	dfc00315 	stw	ra,12(sp)
 202dcc8:	df000215 	stw	fp,8(sp)
 202dccc:	df000204 	addi	fp,sp,8
 202dcd0:	e13ffe15 	stw	r4,-8(fp)
 202dcd4:	e17fff15 	stw	r5,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 202dcd8:	200fca00 	call	200fca0 <xTaskIncrementTick>
 202dcdc:	10000126 	beq	r2,zero,202dce4 <vPortSysTickHandler+0x24>
	{
        vTaskSwitchContext();
 202dce0:	200fe500 	call	200fe50 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 202dce4:	00ffff84 	movi	r3,-2
 202dce8:	00814134 	movhi	r2,1284
 202dcec:	10840804 	addi	r2,r2,4128
 202dcf0:	10c00035 	stwio	r3,0(r2)
}
 202dcf4:	0001883a 	nop
 202dcf8:	e037883a 	mov	sp,fp
 202dcfc:	dfc00117 	ldw	ra,4(sp)
 202dd00:	df000017 	ldw	fp,0(sp)
 202dd04:	dec00204 	addi	sp,sp,8
 202dd08:	f800283a 	ret

0202dd0c <alt_irq_register>:
 * when it is registered. Interrupts should only be enabled after the FreeRTOS.org
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int alt_irq_register( alt_u32 id, void* context, alt_isr_func handler)
{
 202dd0c:	defff104 	addi	sp,sp,-60
 202dd10:	df000e15 	stw	fp,56(sp)
 202dd14:	df000e04 	addi	fp,sp,56
 202dd18:	e13ffd15 	stw	r4,-12(fp)
 202dd1c:	e17ffe15 	stw	r5,-8(fp)
 202dd20:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;  
 202dd24:	00bffa84 	movi	r2,-22
 202dd28:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
 202dd2c:	e0bffd17 	ldw	r2,-12(fp)
 202dd30:	10800828 	cmpgeui	r2,r2,32
 202dd34:	10004c1e 	bne	r2,zero,202de68 <alt_irq_register+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202dd38:	0005303a 	rdctl	r2,status
 202dd3c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202dd40:	e0fff617 	ldw	r3,-40(fp)
 202dd44:	00bfff84 	movi	r2,-2
 202dd48:	1884703a 	and	r2,r3,r2
 202dd4c:	1001703a 	wrctl	status,r2
  
  return context;
 202dd50:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */
	
		status = alt_irq_disable_all();
 202dd54:	e0bff415 	stw	r2,-48(fp)
	
		alt_irq[id].handler = handler;
 202dd58:	008085f4 	movhi	r2,535
 202dd5c:	10bdf204 	addi	r2,r2,-2104
 202dd60:	e0fffd17 	ldw	r3,-12(fp)
 202dd64:	180690fa 	slli	r3,r3,3
 202dd68:	10c5883a 	add	r2,r2,r3
 202dd6c:	e0ffff17 	ldw	r3,-4(fp)
 202dd70:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
 202dd74:	008085f4 	movhi	r2,535
 202dd78:	10bdf204 	addi	r2,r2,-2104
 202dd7c:	e0fffd17 	ldw	r3,-12(fp)
 202dd80:	180690fa 	slli	r3,r3,3
 202dd84:	10c5883a 	add	r2,r2,r3
 202dd88:	10800104 	addi	r2,r2,4
 202dd8c:	e0fffe17 	ldw	r3,-8(fp)
 202dd90:	10c00015 	stw	r3,0(r2)
	
		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 202dd94:	e0bfff17 	ldw	r2,-4(fp)
 202dd98:	10001926 	beq	r2,zero,202de00 <alt_irq_register+0xf4>
 202dd9c:	e0bffd17 	ldw	r2,-12(fp)
 202dda0:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202dda4:	0005303a 	rdctl	r2,status
 202dda8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202ddac:	e0fff717 	ldw	r3,-36(fp)
 202ddb0:	00bfff84 	movi	r2,-2
 202ddb4:	1884703a 	and	r2,r3,r2
 202ddb8:	1001703a 	wrctl	status,r2
  
  return context;
 202ddbc:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 202ddc0:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 202ddc4:	00c00044 	movi	r3,1
 202ddc8:	e0bff317 	ldw	r2,-52(fp)
 202ddcc:	1884983a 	sll	r2,r3,r2
 202ddd0:	1007883a 	mov	r3,r2
 202ddd4:	d0a7f817 	ldw	r2,-24608(gp)
 202ddd8:	1884b03a 	or	r2,r3,r2
 202dddc:	d0a7f815 	stw	r2,-24608(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 202dde0:	d0a7f817 	ldw	r2,-24608(gp)
 202dde4:	100170fa 	wrctl	ienable,r2
 202dde8:	e0bff817 	ldw	r2,-32(fp)
 202ddec:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202ddf0:	e0bff917 	ldw	r2,-28(fp)
 202ddf4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 202ddf8:	0005883a 	mov	r2,zero
 202ddfc:	00001906 	br	202de64 <alt_irq_register+0x158>
 202de00:	e0bffd17 	ldw	r2,-12(fp)
 202de04:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202de08:	0005303a 	rdctl	r2,status
 202de0c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202de10:	e0fffa17 	ldw	r3,-24(fp)
 202de14:	00bfff84 	movi	r2,-2
 202de18:	1884703a 	and	r2,r3,r2
 202de1c:	1001703a 	wrctl	status,r2
  
  return context;
 202de20:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 202de24:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
 202de28:	00c00044 	movi	r3,1
 202de2c:	e0bff517 	ldw	r2,-44(fp)
 202de30:	1884983a 	sll	r2,r3,r2
 202de34:	0084303a 	nor	r2,zero,r2
 202de38:	1007883a 	mov	r3,r2
 202de3c:	d0a7f817 	ldw	r2,-24608(gp)
 202de40:	1884703a 	and	r2,r3,r2
 202de44:	d0a7f815 	stw	r2,-24608(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 202de48:	d0a7f817 	ldw	r2,-24608(gp)
 202de4c:	100170fa 	wrctl	ienable,r2
 202de50:	e0bffb17 	ldw	r2,-20(fp)
 202de54:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202de58:	e0bffc17 	ldw	r2,-16(fp)
 202de5c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 202de60:	0005883a 	mov	r2,zero
 202de64:	e0bff215 	stw	r2,-56(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 202de68:	e0bff217 	ldw	r2,-56(fp)
}
 202de6c:	e037883a 	mov	sp,fp
 202de70:	df000017 	ldw	fp,0(sp)
 202de74:	dec00104 	addi	sp,sp,4
 202de78:	f800283a 	ret

0202de7c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 202de7c:	defff504 	addi	sp,sp,-44
 202de80:	df000a15 	stw	fp,40(sp)
 202de84:	df000a04 	addi	fp,sp,40
 202de88:	e13ffc15 	stw	r4,-16(fp)
 202de8c:	e17ffd15 	stw	r5,-12(fp)
 202de90:	e1bffe15 	stw	r6,-8(fp)
 202de94:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 202de98:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 202de9c:	d0a7f917 	ldw	r2,-24604(gp)
  
  if (alt_ticks_per_second ())
 202dea0:	10003c26 	beq	r2,zero,202df94 <alt_alarm_start+0x118>
  {
    if (alarm)
 202dea4:	e0bffc17 	ldw	r2,-16(fp)
 202dea8:	10003826 	beq	r2,zero,202df8c <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 202deac:	e0bffc17 	ldw	r2,-16(fp)
 202deb0:	e0fffe17 	ldw	r3,-8(fp)
 202deb4:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 202deb8:	e0bffc17 	ldw	r2,-16(fp)
 202debc:	e0ffff17 	ldw	r3,-4(fp)
 202dec0:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202dec4:	0005303a 	rdctl	r2,status
 202dec8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202decc:	e0fff917 	ldw	r3,-28(fp)
 202ded0:	00bfff84 	movi	r2,-2
 202ded4:	1884703a 	and	r2,r3,r2
 202ded8:	1001703a 	wrctl	status,r2
  
  return context;
 202dedc:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 202dee0:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 202dee4:	d0a7fa17 	ldw	r2,-24600(gp)
      
      current_nticks = alt_nticks();
 202dee8:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 202deec:	e0fffd17 	ldw	r3,-12(fp)
 202def0:	e0bff617 	ldw	r2,-40(fp)
 202def4:	1885883a 	add	r2,r3,r2
 202def8:	10c00044 	addi	r3,r2,1
 202defc:	e0bffc17 	ldw	r2,-16(fp)
 202df00:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 202df04:	e0bffc17 	ldw	r2,-16(fp)
 202df08:	10c00217 	ldw	r3,8(r2)
 202df0c:	e0bff617 	ldw	r2,-40(fp)
 202df10:	1880042e 	bgeu	r3,r2,202df24 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 202df14:	e0bffc17 	ldw	r2,-16(fp)
 202df18:	00c00044 	movi	r3,1
 202df1c:	10c00405 	stb	r3,16(r2)
 202df20:	00000206 	br	202df2c <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 202df24:	e0bffc17 	ldw	r2,-16(fp)
 202df28:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 202df2c:	e0bffc17 	ldw	r2,-16(fp)
 202df30:	d0e01d04 	addi	r3,gp,-32652
 202df34:	e0fffa15 	stw	r3,-24(fp)
 202df38:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 202df3c:	e0bffb17 	ldw	r2,-20(fp)
 202df40:	e0fffa17 	ldw	r3,-24(fp)
 202df44:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 202df48:	e0bffa17 	ldw	r2,-24(fp)
 202df4c:	10c00017 	ldw	r3,0(r2)
 202df50:	e0bffb17 	ldw	r2,-20(fp)
 202df54:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 202df58:	e0bffa17 	ldw	r2,-24(fp)
 202df5c:	10800017 	ldw	r2,0(r2)
 202df60:	e0fffb17 	ldw	r3,-20(fp)
 202df64:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 202df68:	e0bffa17 	ldw	r2,-24(fp)
 202df6c:	e0fffb17 	ldw	r3,-20(fp)
 202df70:	10c00015 	stw	r3,0(r2)
 202df74:	e0bff817 	ldw	r2,-32(fp)
 202df78:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202df7c:	e0bff717 	ldw	r2,-36(fp)
 202df80:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 202df84:	0005883a 	mov	r2,zero
 202df88:	00000306 	br	202df98 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 202df8c:	00bffa84 	movi	r2,-22
 202df90:	00000106 	br	202df98 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 202df94:	00bfde84 	movi	r2,-134
  }
}
 202df98:	e037883a 	mov	sp,fp
 202df9c:	df000017 	ldw	fp,0(sp)
 202dfa0:	dec00104 	addi	sp,sp,4
 202dfa4:	f800283a 	ret

0202dfa8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202dfa8:	defffe04 	addi	sp,sp,-8
 202dfac:	dfc00115 	stw	ra,4(sp)
 202dfb0:	df000015 	stw	fp,0(sp)
 202dfb4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202dfb8:	d0a01b17 	ldw	r2,-32660(gp)
 202dfbc:	10000326 	beq	r2,zero,202dfcc <alt_get_errno+0x24>
 202dfc0:	d0a01b17 	ldw	r2,-32660(gp)
 202dfc4:	103ee83a 	callr	r2
 202dfc8:	00000106 	br	202dfd0 <alt_get_errno+0x28>
 202dfcc:	d0a7a404 	addi	r2,gp,-24944
}
 202dfd0:	e037883a 	mov	sp,fp
 202dfd4:	dfc00117 	ldw	ra,4(sp)
 202dfd8:	df000017 	ldw	fp,0(sp)
 202dfdc:	dec00204 	addi	sp,sp,8
 202dfe0:	f800283a 	ret

0202dfe4 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 202dfe4:	defffb04 	addi	sp,sp,-20
 202dfe8:	dfc00415 	stw	ra,16(sp)
 202dfec:	df000315 	stw	fp,12(sp)
 202dff0:	df000304 	addi	fp,sp,12
 202dff4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 202dff8:	e0bfff17 	ldw	r2,-4(fp)
 202dffc:	10000616 	blt	r2,zero,202e018 <alt_close+0x34>
 202e000:	e0bfff17 	ldw	r2,-4(fp)
 202e004:	10c00324 	muli	r3,r2,12
 202e008:	00808174 	movhi	r2,517
 202e00c:	10a61a04 	addi	r2,r2,-26520
 202e010:	1885883a 	add	r2,r3,r2
 202e014:	00000106 	br	202e01c <alt_close+0x38>
 202e018:	0005883a 	mov	r2,zero
 202e01c:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 202e020:	e0bffd17 	ldw	r2,-12(fp)
 202e024:	10001926 	beq	r2,zero,202e08c <alt_close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 202e028:	e0bffd17 	ldw	r2,-12(fp)
 202e02c:	10800017 	ldw	r2,0(r2)
 202e030:	10800417 	ldw	r2,16(r2)
 202e034:	10000626 	beq	r2,zero,202e050 <alt_close+0x6c>
 202e038:	e0bffd17 	ldw	r2,-12(fp)
 202e03c:	10800017 	ldw	r2,0(r2)
 202e040:	10800417 	ldw	r2,16(r2)
 202e044:	e13ffd17 	ldw	r4,-12(fp)
 202e048:	103ee83a 	callr	r2
 202e04c:	00000106 	br	202e054 <alt_close+0x70>
 202e050:	0005883a 	mov	r2,zero
 202e054:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 202e058:	e13fff17 	ldw	r4,-4(fp)
 202e05c:	2012f280 	call	2012f28 <alt_release_fd>
    if (rval < 0)
 202e060:	e0bffe17 	ldw	r2,-8(fp)
 202e064:	1000070e 	bge	r2,zero,202e084 <alt_close+0xa0>
    {
      ALT_ERRNO = -rval;
 202e068:	202dfa80 	call	202dfa8 <alt_get_errno>
 202e06c:	1007883a 	mov	r3,r2
 202e070:	e0bffe17 	ldw	r2,-8(fp)
 202e074:	0085c83a 	sub	r2,zero,r2
 202e078:	18800015 	stw	r2,0(r3)
      return -1;
 202e07c:	00bfffc4 	movi	r2,-1
 202e080:	00000706 	br	202e0a0 <alt_close+0xbc>
    }
    return 0;
 202e084:	0005883a 	mov	r2,zero
 202e088:	00000506 	br	202e0a0 <alt_close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 202e08c:	202dfa80 	call	202dfa8 <alt_get_errno>
 202e090:	1007883a 	mov	r3,r2
 202e094:	00801444 	movi	r2,81
 202e098:	18800015 	stw	r2,0(r3)
    return -1;
 202e09c:	00bfffc4 	movi	r2,-1
  }
}
 202e0a0:	e037883a 	mov	sp,fp
 202e0a4:	dfc00117 	ldw	ra,4(sp)
 202e0a8:	df000017 	ldw	fp,0(sp)
 202e0ac:	dec00204 	addi	sp,sp,8
 202e0b0:	f800283a 	ret

0202e0b4 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 202e0b4:	defffd04 	addi	sp,sp,-12
 202e0b8:	df000215 	stw	fp,8(sp)
 202e0bc:	df000204 	addi	fp,sp,8
 202e0c0:	e13ffe15 	stw	r4,-8(fp)
 202e0c4:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 202e0c8:	0001883a 	nop
 202e0cc:	e037883a 	mov	sp,fp
 202e0d0:	df000017 	ldw	fp,0(sp)
 202e0d4:	dec00104 	addi	sp,sp,4
 202e0d8:	f800283a 	ret

0202e0dc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 202e0dc:	deffff04 	addi	sp,sp,-4
 202e0e0:	df000015 	stw	fp,0(sp)
 202e0e4:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 202e0e8:	0001883a 	nop
 202e0ec:	e037883a 	mov	sp,fp
 202e0f0:	df000017 	ldw	fp,0(sp)
 202e0f4:	dec00104 	addi	sp,sp,4
 202e0f8:	f800283a 	ret

0202e0fc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202e0fc:	defffe04 	addi	sp,sp,-8
 202e100:	dfc00115 	stw	ra,4(sp)
 202e104:	df000015 	stw	fp,0(sp)
 202e108:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202e10c:	d0a01b17 	ldw	r2,-32660(gp)
 202e110:	10000326 	beq	r2,zero,202e120 <alt_get_errno+0x24>
 202e114:	d0a01b17 	ldw	r2,-32660(gp)
 202e118:	103ee83a 	callr	r2
 202e11c:	00000106 	br	202e124 <alt_get_errno+0x28>
 202e120:	d0a7a404 	addi	r2,gp,-24944
}
 202e124:	e037883a 	mov	sp,fp
 202e128:	dfc00117 	ldw	ra,4(sp)
 202e12c:	df000017 	ldw	fp,0(sp)
 202e130:	dec00204 	addi	sp,sp,8
 202e134:	f800283a 	ret

0202e138 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 202e138:	defffa04 	addi	sp,sp,-24
 202e13c:	dfc00515 	stw	ra,20(sp)
 202e140:	df000415 	stw	fp,16(sp)
 202e144:	df000404 	addi	fp,sp,16
 202e148:	e13ffe15 	stw	r4,-8(fp)
 202e14c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 202e150:	e0bffe17 	ldw	r2,-8(fp)
 202e154:	10000326 	beq	r2,zero,202e164 <alt_dev_llist_insert+0x2c>
 202e158:	e0bffe17 	ldw	r2,-8(fp)
 202e15c:	10800217 	ldw	r2,8(r2)
 202e160:	1000061e 	bne	r2,zero,202e17c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 202e164:	202e0fc0 	call	202e0fc <alt_get_errno>
 202e168:	1007883a 	mov	r3,r2
 202e16c:	00800584 	movi	r2,22
 202e170:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 202e174:	00bffa84 	movi	r2,-22
 202e178:	00001306 	br	202e1c8 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 202e17c:	e0bffe17 	ldw	r2,-8(fp)
 202e180:	e0ffff17 	ldw	r3,-4(fp)
 202e184:	e0fffc15 	stw	r3,-16(fp)
 202e188:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 202e18c:	e0bffd17 	ldw	r2,-12(fp)
 202e190:	e0fffc17 	ldw	r3,-16(fp)
 202e194:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 202e198:	e0bffc17 	ldw	r2,-16(fp)
 202e19c:	10c00017 	ldw	r3,0(r2)
 202e1a0:	e0bffd17 	ldw	r2,-12(fp)
 202e1a4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 202e1a8:	e0bffc17 	ldw	r2,-16(fp)
 202e1ac:	10800017 	ldw	r2,0(r2)
 202e1b0:	e0fffd17 	ldw	r3,-12(fp)
 202e1b4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 202e1b8:	e0bffc17 	ldw	r2,-16(fp)
 202e1bc:	e0fffd17 	ldw	r3,-12(fp)
 202e1c0:	10c00015 	stw	r3,0(r2)

  return 0;  
 202e1c4:	0005883a 	mov	r2,zero
}
 202e1c8:	e037883a 	mov	sp,fp
 202e1cc:	dfc00117 	ldw	ra,4(sp)
 202e1d0:	df000017 	ldw	fp,0(sp)
 202e1d4:	dec00204 	addi	sp,sp,8
 202e1d8:	f800283a 	ret

0202e1dc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 202e1dc:	defffa04 	addi	sp,sp,-24
 202e1e0:	dfc00515 	stw	ra,20(sp)
 202e1e4:	df000415 	stw	fp,16(sp)
 202e1e8:	df000404 	addi	fp,sp,16
 202e1ec:	e13ffe15 	stw	r4,-8(fp)
 202e1f0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 202e1f4:	e0bfff17 	ldw	r2,-4(fp)
 202e1f8:	10800017 	ldw	r2,0(r2)
 202e1fc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 202e200:	e13ffe17 	ldw	r4,-8(fp)
 202e204:	20073a40 	call	20073a4 <strlen>
 202e208:	10800044 	addi	r2,r2,1
 202e20c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 202e210:	00000d06 	br	202e248 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 202e214:	e0bffc17 	ldw	r2,-16(fp)
 202e218:	10800217 	ldw	r2,8(r2)
 202e21c:	e0fffd17 	ldw	r3,-12(fp)
 202e220:	180d883a 	mov	r6,r3
 202e224:	e17ffe17 	ldw	r5,-8(fp)
 202e228:	1009883a 	mov	r4,r2
 202e22c:	20424280 	call	2042428 <memcmp>
 202e230:	1000021e 	bne	r2,zero,202e23c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 202e234:	e0bffc17 	ldw	r2,-16(fp)
 202e238:	00000706 	br	202e258 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 202e23c:	e0bffc17 	ldw	r2,-16(fp)
 202e240:	10800017 	ldw	r2,0(r2)
 202e244:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 202e248:	e0fffc17 	ldw	r3,-16(fp)
 202e24c:	e0bfff17 	ldw	r2,-4(fp)
 202e250:	18bff01e 	bne	r3,r2,202e214 <__alt_mem_mem_0+0xfd00e214>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 202e254:	0005883a 	mov	r2,zero
}
 202e258:	e037883a 	mov	sp,fp
 202e25c:	dfc00117 	ldw	ra,4(sp)
 202e260:	df000017 	ldw	fp,0(sp)
 202e264:	dec00204 	addi	sp,sp,8
 202e268:	f800283a 	ret

0202e26c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 202e26c:	defffb04 	addi	sp,sp,-20
 202e270:	dfc00415 	stw	ra,16(sp)
 202e274:	df000315 	stw	fp,12(sp)
 202e278:	df000304 	addi	fp,sp,12
 202e27c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 202e280:	d0a00617 	ldw	r2,-32744(gp)
 202e284:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 202e288:	00003106 	br	202e350 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 202e28c:	e0bffd17 	ldw	r2,-12(fp)
 202e290:	10800217 	ldw	r2,8(r2)
 202e294:	1009883a 	mov	r4,r2
 202e298:	20073a40 	call	20073a4 <strlen>
 202e29c:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 202e2a0:	e0bffd17 	ldw	r2,-12(fp)
 202e2a4:	10c00217 	ldw	r3,8(r2)
 202e2a8:	e0bffe17 	ldw	r2,-8(fp)
 202e2ac:	10bfffc4 	addi	r2,r2,-1
 202e2b0:	1885883a 	add	r2,r3,r2
 202e2b4:	10800003 	ldbu	r2,0(r2)
 202e2b8:	10803fcc 	andi	r2,r2,255
 202e2bc:	1080201c 	xori	r2,r2,128
 202e2c0:	10bfe004 	addi	r2,r2,-128
 202e2c4:	10800bd8 	cmpnei	r2,r2,47
 202e2c8:	1000031e 	bne	r2,zero,202e2d8 <alt_find_file+0x6c>
    {
      len -= 1;
 202e2cc:	e0bffe17 	ldw	r2,-8(fp)
 202e2d0:	10bfffc4 	addi	r2,r2,-1
 202e2d4:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 202e2d8:	e0bffe17 	ldw	r2,-8(fp)
 202e2dc:	e0ffff17 	ldw	r3,-4(fp)
 202e2e0:	1885883a 	add	r2,r3,r2
 202e2e4:	10800003 	ldbu	r2,0(r2)
 202e2e8:	10803fcc 	andi	r2,r2,255
 202e2ec:	1080201c 	xori	r2,r2,128
 202e2f0:	10bfe004 	addi	r2,r2,-128
 202e2f4:	10800be0 	cmpeqi	r2,r2,47
 202e2f8:	1000081e 	bne	r2,zero,202e31c <alt_find_file+0xb0>
 202e2fc:	e0bffe17 	ldw	r2,-8(fp)
 202e300:	e0ffff17 	ldw	r3,-4(fp)
 202e304:	1885883a 	add	r2,r3,r2
 202e308:	10800003 	ldbu	r2,0(r2)
 202e30c:	10803fcc 	andi	r2,r2,255
 202e310:	1080201c 	xori	r2,r2,128
 202e314:	10bfe004 	addi	r2,r2,-128
 202e318:	10000a1e 	bne	r2,zero,202e344 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 202e31c:	e0bffd17 	ldw	r2,-12(fp)
 202e320:	10800217 	ldw	r2,8(r2)
 202e324:	e0fffe17 	ldw	r3,-8(fp)
 202e328:	180d883a 	mov	r6,r3
 202e32c:	e17fff17 	ldw	r5,-4(fp)
 202e330:	1009883a 	mov	r4,r2
 202e334:	20424280 	call	2042428 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 202e338:	1000021e 	bne	r2,zero,202e344 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 202e33c:	e0bffd17 	ldw	r2,-12(fp)
 202e340:	00000706 	br	202e360 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 202e344:	e0bffd17 	ldw	r2,-12(fp)
 202e348:	10800017 	ldw	r2,0(r2)
 202e34c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 202e350:	e0fffd17 	ldw	r3,-12(fp)
 202e354:	d0a00604 	addi	r2,gp,-32744
 202e358:	18bfcc1e 	bne	r3,r2,202e28c <__alt_mem_mem_0+0xfd00e28c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 202e35c:	0005883a 	mov	r2,zero
}
 202e360:	e037883a 	mov	sp,fp
 202e364:	dfc00117 	ldw	ra,4(sp)
 202e368:	df000017 	ldw	fp,0(sp)
 202e36c:	dec00204 	addi	sp,sp,8
 202e370:	f800283a 	ret

0202e374 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 202e374:	defff804 	addi	sp,sp,-32
 202e378:	dfc00715 	stw	ra,28(sp)
 202e37c:	df000615 	stw	fp,24(sp)
 202e380:	df000604 	addi	fp,sp,24
 202e384:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
 202e388:	00bffa04 	movi	r2,-24
 202e38c:	e0bffb15 	stw	r2,-20(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 202e390:	d0a7bd17 	ldw	r2,-24844(gp)
 202e394:	e0bffc15 	stw	r2,-16(fp)
 202e398:	e03ffd0d 	sth	zero,-12(fp)
 202e39c:	e0bffd0b 	ldhu	r2,-12(fp)
 202e3a0:	100b883a 	mov	r5,r2
 202e3a4:	e13ffc17 	ldw	r4,-16(fp)
 202e3a8:	200ddd40 	call	200ddd4 <xQueueSemaphoreTake>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 202e3ac:	e03ffa15 	stw	zero,-24(fp)
 202e3b0:	00001906 	br	202e418 <alt_get_fd+0xa4>
  {
    if (!alt_fd_list[i].dev)
 202e3b4:	00808174 	movhi	r2,517
 202e3b8:	10a61a04 	addi	r2,r2,-26520
 202e3bc:	e0fffa17 	ldw	r3,-24(fp)
 202e3c0:	18c00324 	muli	r3,r3,12
 202e3c4:	10c5883a 	add	r2,r2,r3
 202e3c8:	10800017 	ldw	r2,0(r2)
 202e3cc:	10000f1e 	bne	r2,zero,202e40c <alt_get_fd+0x98>
    {
      alt_fd_list[i].dev = dev;
 202e3d0:	00808174 	movhi	r2,517
 202e3d4:	10a61a04 	addi	r2,r2,-26520
 202e3d8:	e0fffa17 	ldw	r3,-24(fp)
 202e3dc:	18c00324 	muli	r3,r3,12
 202e3e0:	10c5883a 	add	r2,r2,r3
 202e3e4:	e0fffe17 	ldw	r3,-8(fp)
 202e3e8:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 202e3ec:	d0e00a17 	ldw	r3,-32728(gp)
 202e3f0:	e0bffa17 	ldw	r2,-24(fp)
 202e3f4:	1880020e 	bge	r3,r2,202e400 <alt_get_fd+0x8c>
      {
        alt_max_fd = i;
 202e3f8:	e0bffa17 	ldw	r2,-24(fp)
 202e3fc:	d0a00a15 	stw	r2,-32728(gp)
      }
      rc = i;
 202e400:	e0bffa17 	ldw	r2,-24(fp)
 202e404:	e0bffb15 	stw	r2,-20(fp)
      goto alt_get_fd_exit;
 202e408:	00000606 	br	202e424 <alt_get_fd+0xb0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 202e40c:	e0bffa17 	ldw	r2,-24(fp)
 202e410:	10800044 	addi	r2,r2,1
 202e414:	e0bffa15 	stw	r2,-24(fp)
 202e418:	e0bffa17 	ldw	r2,-24(fp)
 202e41c:	10800410 	cmplti	r2,r2,16
 202e420:	103fe41e 	bne	r2,zero,202e3b4 <__alt_mem_mem_0+0xfd00e3b4>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 202e424:	d0a7bd17 	ldw	r2,-24844(gp)
 202e428:	000f883a 	mov	r7,zero
 202e42c:	000d883a 	mov	r6,zero
 202e430:	000b883a 	mov	r5,zero
 202e434:	1009883a 	mov	r4,r2
 202e438:	200d8480 	call	200d848 <xQueueGenericSend>

  return rc;
 202e43c:	e0bffb17 	ldw	r2,-20(fp)
}
 202e440:	e037883a 	mov	sp,fp
 202e444:	dfc00117 	ldw	ra,4(sp)
 202e448:	df000017 	ldw	fp,0(sp)
 202e44c:	dec00204 	addi	sp,sp,8
 202e450:	f800283a 	ret

0202e454 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 202e454:	defffe04 	addi	sp,sp,-8
 202e458:	dfc00115 	stw	ra,4(sp)
 202e45c:	df000015 	stw	fp,0(sp)
 202e460:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 202e464:	01500004 	movi	r5,16384
 202e468:	0009883a 	mov	r4,zero
 202e46c:	203e0740 	call	203e074 <alt_icache_flush>
#endif
}
 202e470:	0001883a 	nop
 202e474:	e037883a 	mov	sp,fp
 202e478:	dfc00117 	ldw	ra,4(sp)
 202e47c:	df000017 	ldw	fp,0(sp)
 202e480:	dec00204 	addi	sp,sp,8
 202e484:	f800283a 	ret

0202e488 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 202e488:	defff904 	addi	sp,sp,-28
 202e48c:	dfc00615 	stw	ra,24(sp)
 202e490:	df000515 	stw	fp,20(sp)
 202e494:	df000504 	addi	fp,sp,20
 202e498:	e13ffc15 	stw	r4,-16(fp)
 202e49c:	e17ffd15 	stw	r5,-12(fp)
 202e4a0:	e1bffe15 	stw	r6,-8(fp)
 202e4a4:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 202e4a8:	e0800217 	ldw	r2,8(fp)
 202e4ac:	d8800015 	stw	r2,0(sp)
 202e4b0:	e1ffff17 	ldw	r7,-4(fp)
 202e4b4:	e1bffe17 	ldw	r6,-8(fp)
 202e4b8:	e17ffd17 	ldw	r5,-12(fp)
 202e4bc:	e13ffc17 	ldw	r4,-16(fp)
 202e4c0:	202e6380 	call	202e638 <alt_iic_isr_register>
}  
 202e4c4:	e037883a 	mov	sp,fp
 202e4c8:	dfc00117 	ldw	ra,4(sp)
 202e4cc:	df000017 	ldw	fp,0(sp)
 202e4d0:	dec00204 	addi	sp,sp,8
 202e4d4:	f800283a 	ret

0202e4d8 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 202e4d8:	defff904 	addi	sp,sp,-28
 202e4dc:	df000615 	stw	fp,24(sp)
 202e4e0:	df000604 	addi	fp,sp,24
 202e4e4:	e13ffe15 	stw	r4,-8(fp)
 202e4e8:	e17fff15 	stw	r5,-4(fp)
 202e4ec:	e0bfff17 	ldw	r2,-4(fp)
 202e4f0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202e4f4:	0005303a 	rdctl	r2,status
 202e4f8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202e4fc:	e0fffb17 	ldw	r3,-20(fp)
 202e500:	00bfff84 	movi	r2,-2
 202e504:	1884703a 	and	r2,r3,r2
 202e508:	1001703a 	wrctl	status,r2
  
  return context;
 202e50c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 202e510:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 202e514:	00c00044 	movi	r3,1
 202e518:	e0bffa17 	ldw	r2,-24(fp)
 202e51c:	1884983a 	sll	r2,r3,r2
 202e520:	1007883a 	mov	r3,r2
 202e524:	d0a7f817 	ldw	r2,-24608(gp)
 202e528:	1884b03a 	or	r2,r3,r2
 202e52c:	d0a7f815 	stw	r2,-24608(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 202e530:	d0a7f817 	ldw	r2,-24608(gp)
 202e534:	100170fa 	wrctl	ienable,r2
 202e538:	e0bffc17 	ldw	r2,-16(fp)
 202e53c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202e540:	e0bffd17 	ldw	r2,-12(fp)
 202e544:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 202e548:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 202e54c:	0001883a 	nop
}
 202e550:	e037883a 	mov	sp,fp
 202e554:	df000017 	ldw	fp,0(sp)
 202e558:	dec00104 	addi	sp,sp,4
 202e55c:	f800283a 	ret

0202e560 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 202e560:	defff904 	addi	sp,sp,-28
 202e564:	df000615 	stw	fp,24(sp)
 202e568:	df000604 	addi	fp,sp,24
 202e56c:	e13ffe15 	stw	r4,-8(fp)
 202e570:	e17fff15 	stw	r5,-4(fp)
 202e574:	e0bfff17 	ldw	r2,-4(fp)
 202e578:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202e57c:	0005303a 	rdctl	r2,status
 202e580:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202e584:	e0fffb17 	ldw	r3,-20(fp)
 202e588:	00bfff84 	movi	r2,-2
 202e58c:	1884703a 	and	r2,r3,r2
 202e590:	1001703a 	wrctl	status,r2
  
  return context;
 202e594:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 202e598:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 202e59c:	00c00044 	movi	r3,1
 202e5a0:	e0bffa17 	ldw	r2,-24(fp)
 202e5a4:	1884983a 	sll	r2,r3,r2
 202e5a8:	0084303a 	nor	r2,zero,r2
 202e5ac:	1007883a 	mov	r3,r2
 202e5b0:	d0a7f817 	ldw	r2,-24608(gp)
 202e5b4:	1884703a 	and	r2,r3,r2
 202e5b8:	d0a7f815 	stw	r2,-24608(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 202e5bc:	d0a7f817 	ldw	r2,-24608(gp)
 202e5c0:	100170fa 	wrctl	ienable,r2
 202e5c4:	e0bffc17 	ldw	r2,-16(fp)
 202e5c8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202e5cc:	e0bffd17 	ldw	r2,-12(fp)
 202e5d0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 202e5d4:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 202e5d8:	0001883a 	nop
}
 202e5dc:	e037883a 	mov	sp,fp
 202e5e0:	df000017 	ldw	fp,0(sp)
 202e5e4:	dec00104 	addi	sp,sp,4
 202e5e8:	f800283a 	ret

0202e5ec <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 202e5ec:	defffc04 	addi	sp,sp,-16
 202e5f0:	df000315 	stw	fp,12(sp)
 202e5f4:	df000304 	addi	fp,sp,12
 202e5f8:	e13ffe15 	stw	r4,-8(fp)
 202e5fc:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 202e600:	000530fa 	rdctl	r2,ienable
 202e604:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 202e608:	00c00044 	movi	r3,1
 202e60c:	e0bfff17 	ldw	r2,-4(fp)
 202e610:	1884983a 	sll	r2,r3,r2
 202e614:	1007883a 	mov	r3,r2
 202e618:	e0bffd17 	ldw	r2,-12(fp)
 202e61c:	1884703a 	and	r2,r3,r2
 202e620:	1004c03a 	cmpne	r2,r2,zero
 202e624:	10803fcc 	andi	r2,r2,255
}
 202e628:	e037883a 	mov	sp,fp
 202e62c:	df000017 	ldw	fp,0(sp)
 202e630:	dec00104 	addi	sp,sp,4
 202e634:	f800283a 	ret

0202e638 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 202e638:	defff504 	addi	sp,sp,-44
 202e63c:	dfc00a15 	stw	ra,40(sp)
 202e640:	df000915 	stw	fp,36(sp)
 202e644:	df000904 	addi	fp,sp,36
 202e648:	e13ffc15 	stw	r4,-16(fp)
 202e64c:	e17ffd15 	stw	r5,-12(fp)
 202e650:	e1bffe15 	stw	r6,-8(fp)
 202e654:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 202e658:	00bffa84 	movi	r2,-22
 202e65c:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 202e660:	e0bffd17 	ldw	r2,-12(fp)
 202e664:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 202e668:	e0bff817 	ldw	r2,-32(fp)
 202e66c:	10800808 	cmpgei	r2,r2,32
 202e670:	1000271e 	bne	r2,zero,202e710 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202e674:	0005303a 	rdctl	r2,status
 202e678:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202e67c:	e0fffb17 	ldw	r3,-20(fp)
 202e680:	00bfff84 	movi	r2,-2
 202e684:	1884703a 	and	r2,r3,r2
 202e688:	1001703a 	wrctl	status,r2
  
  return context;
 202e68c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 202e690:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 202e694:	008085f4 	movhi	r2,535
 202e698:	10bdf204 	addi	r2,r2,-2104
 202e69c:	e0fff817 	ldw	r3,-32(fp)
 202e6a0:	180690fa 	slli	r3,r3,3
 202e6a4:	10c5883a 	add	r2,r2,r3
 202e6a8:	e0fffe17 	ldw	r3,-8(fp)
 202e6ac:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 202e6b0:	008085f4 	movhi	r2,535
 202e6b4:	10bdf204 	addi	r2,r2,-2104
 202e6b8:	e0fff817 	ldw	r3,-32(fp)
 202e6bc:	180690fa 	slli	r3,r3,3
 202e6c0:	10c5883a 	add	r2,r2,r3
 202e6c4:	10800104 	addi	r2,r2,4
 202e6c8:	e0ffff17 	ldw	r3,-4(fp)
 202e6cc:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 202e6d0:	e0bffe17 	ldw	r2,-8(fp)
 202e6d4:	10000526 	beq	r2,zero,202e6ec <alt_iic_isr_register+0xb4>
 202e6d8:	e0bff817 	ldw	r2,-32(fp)
 202e6dc:	100b883a 	mov	r5,r2
 202e6e0:	e13ffc17 	ldw	r4,-16(fp)
 202e6e4:	202e4d80 	call	202e4d8 <alt_ic_irq_enable>
 202e6e8:	00000406 	br	202e6fc <alt_iic_isr_register+0xc4>
 202e6ec:	e0bff817 	ldw	r2,-32(fp)
 202e6f0:	100b883a 	mov	r5,r2
 202e6f4:	e13ffc17 	ldw	r4,-16(fp)
 202e6f8:	202e5600 	call	202e560 <alt_ic_irq_disable>
 202e6fc:	e0bff715 	stw	r2,-36(fp)
 202e700:	e0bffa17 	ldw	r2,-24(fp)
 202e704:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202e708:	e0bff917 	ldw	r2,-28(fp)
 202e70c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 202e710:	e0bff717 	ldw	r2,-36(fp)
}
 202e714:	e037883a 	mov	sp,fp
 202e718:	dfc00117 	ldw	ra,4(sp)
 202e71c:	df000017 	ldw	fp,0(sp)
 202e720:	dec00204 	addi	sp,sp,8
 202e724:	f800283a 	ret

0202e728 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202e728:	defffe04 	addi	sp,sp,-8
 202e72c:	dfc00115 	stw	ra,4(sp)
 202e730:	df000015 	stw	fp,0(sp)
 202e734:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202e738:	d0a01b17 	ldw	r2,-32660(gp)
 202e73c:	10000326 	beq	r2,zero,202e74c <alt_get_errno+0x24>
 202e740:	d0a01b17 	ldw	r2,-32660(gp)
 202e744:	103ee83a 	callr	r2
 202e748:	00000106 	br	202e750 <alt_get_errno+0x28>
 202e74c:	d0a7a404 	addi	r2,gp,-24944
}
 202e750:	e037883a 	mov	sp,fp
 202e754:	dfc00117 	ldw	ra,4(sp)
 202e758:	df000017 	ldw	fp,0(sp)
 202e75c:	dec00204 	addi	sp,sp,8
 202e760:	f800283a 	ret

0202e764 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 202e764:	defff904 	addi	sp,sp,-28
 202e768:	dfc00615 	stw	ra,24(sp)
 202e76c:	df000515 	stw	fp,20(sp)
 202e770:	df000504 	addi	fp,sp,20
 202e774:	e13ffd15 	stw	r4,-12(fp)
 202e778:	e17ffe15 	stw	r5,-8(fp)
 202e77c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 202e780:	e0bffd17 	ldw	r2,-12(fp)
 202e784:	10000616 	blt	r2,zero,202e7a0 <alt_read+0x3c>
 202e788:	e0bffd17 	ldw	r2,-12(fp)
 202e78c:	10c00324 	muli	r3,r2,12
 202e790:	00808174 	movhi	r2,517
 202e794:	10a61a04 	addi	r2,r2,-26520
 202e798:	1885883a 	add	r2,r3,r2
 202e79c:	00000106 	br	202e7a4 <alt_read+0x40>
 202e7a0:	0005883a 	mov	r2,zero
 202e7a4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 202e7a8:	e0bffb17 	ldw	r2,-20(fp)
 202e7ac:	10002226 	beq	r2,zero,202e838 <alt_read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 202e7b0:	e0bffb17 	ldw	r2,-20(fp)
 202e7b4:	10800217 	ldw	r2,8(r2)
 202e7b8:	108000cc 	andi	r2,r2,3
 202e7bc:	10800060 	cmpeqi	r2,r2,1
 202e7c0:	1000181e 	bne	r2,zero,202e824 <alt_read+0xc0>
        (fd->dev->read))
 202e7c4:	e0bffb17 	ldw	r2,-20(fp)
 202e7c8:	10800017 	ldw	r2,0(r2)
 202e7cc:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 202e7d0:	10001426 	beq	r2,zero,202e824 <alt_read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 202e7d4:	e0bffb17 	ldw	r2,-20(fp)
 202e7d8:	10800017 	ldw	r2,0(r2)
 202e7dc:	10800517 	ldw	r2,20(r2)
 202e7e0:	e0ffff17 	ldw	r3,-4(fp)
 202e7e4:	180d883a 	mov	r6,r3
 202e7e8:	e17ffe17 	ldw	r5,-8(fp)
 202e7ec:	e13ffb17 	ldw	r4,-20(fp)
 202e7f0:	103ee83a 	callr	r2
 202e7f4:	e0bffc15 	stw	r2,-16(fp)
 202e7f8:	e0bffc17 	ldw	r2,-16(fp)
 202e7fc:	1000070e 	bge	r2,zero,202e81c <alt_read+0xb8>
        {
          ALT_ERRNO = -rval;
 202e800:	202e7280 	call	202e728 <alt_get_errno>
 202e804:	1007883a 	mov	r3,r2
 202e808:	e0bffc17 	ldw	r2,-16(fp)
 202e80c:	0085c83a 	sub	r2,zero,r2
 202e810:	18800015 	stw	r2,0(r3)
          return -1;
 202e814:	00bfffc4 	movi	r2,-1
 202e818:	00000c06 	br	202e84c <alt_read+0xe8>
        }
        return rval;
 202e81c:	e0bffc17 	ldw	r2,-16(fp)
 202e820:	00000a06 	br	202e84c <alt_read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 202e824:	202e7280 	call	202e728 <alt_get_errno>
 202e828:	1007883a 	mov	r3,r2
 202e82c:	00800344 	movi	r2,13
 202e830:	18800015 	stw	r2,0(r3)
 202e834:	00000406 	br	202e848 <alt_read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 202e838:	202e7280 	call	202e728 <alt_get_errno>
 202e83c:	1007883a 	mov	r3,r2
 202e840:	00801444 	movi	r2,81
 202e844:	18800015 	stw	r2,0(r3)
  }
  return -1;
 202e848:	00bfffc4 	movi	r2,-1
}
 202e84c:	e037883a 	mov	sp,fp
 202e850:	dfc00117 	ldw	ra,4(sp)
 202e854:	df000017 	ldw	fp,0(sp)
 202e858:	dec00204 	addi	sp,sp,8
 202e85c:	f800283a 	ret

0202e860 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 202e860:	defffa04 	addi	sp,sp,-24
 202e864:	df000515 	stw	fp,20(sp)
 202e868:	df000504 	addi	fp,sp,20
 202e86c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202e870:	0005303a 	rdctl	r2,status
 202e874:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202e878:	e0fffc17 	ldw	r3,-16(fp)
 202e87c:	00bfff84 	movi	r2,-2
 202e880:	1884703a 	and	r2,r3,r2
 202e884:	1001703a 	wrctl	status,r2
  
  return context;
 202e888:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 202e88c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 202e890:	e0bfff17 	ldw	r2,-4(fp)
 202e894:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 202e898:	e0bffd17 	ldw	r2,-12(fp)
 202e89c:	10800017 	ldw	r2,0(r2)
 202e8a0:	e0fffd17 	ldw	r3,-12(fp)
 202e8a4:	18c00117 	ldw	r3,4(r3)
 202e8a8:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 202e8ac:	e0bffd17 	ldw	r2,-12(fp)
 202e8b0:	10800117 	ldw	r2,4(r2)
 202e8b4:	e0fffd17 	ldw	r3,-12(fp)
 202e8b8:	18c00017 	ldw	r3,0(r3)
 202e8bc:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 202e8c0:	e0bffd17 	ldw	r2,-12(fp)
 202e8c4:	e0fffd17 	ldw	r3,-12(fp)
 202e8c8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 202e8cc:	e0bffd17 	ldw	r2,-12(fp)
 202e8d0:	e0fffd17 	ldw	r3,-12(fp)
 202e8d4:	10c00015 	stw	r3,0(r2)
 202e8d8:	e0bffb17 	ldw	r2,-20(fp)
 202e8dc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202e8e0:	e0bffe17 	ldw	r2,-8(fp)
 202e8e4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 202e8e8:	0001883a 	nop
 202e8ec:	e037883a 	mov	sp,fp
 202e8f0:	df000017 	ldw	fp,0(sp)
 202e8f4:	dec00104 	addi	sp,sp,4
 202e8f8:	f800283a 	ret

0202e8fc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 202e8fc:	defffb04 	addi	sp,sp,-20
 202e900:	dfc00415 	stw	ra,16(sp)
 202e904:	df000315 	stw	fp,12(sp)
 202e908:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 202e90c:	d0a01d17 	ldw	r2,-32652(gp)
 202e910:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 202e914:	d0a7fa17 	ldw	r2,-24600(gp)
 202e918:	10800044 	addi	r2,r2,1
 202e91c:	d0a7fa15 	stw	r2,-24600(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 202e920:	00002e06 	br	202e9dc <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 202e924:	e0bffd17 	ldw	r2,-12(fp)
 202e928:	10800017 	ldw	r2,0(r2)
 202e92c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 202e930:	e0bffd17 	ldw	r2,-12(fp)
 202e934:	10800403 	ldbu	r2,16(r2)
 202e938:	10803fcc 	andi	r2,r2,255
 202e93c:	10000426 	beq	r2,zero,202e950 <alt_tick+0x54>
 202e940:	d0a7fa17 	ldw	r2,-24600(gp)
 202e944:	1000021e 	bne	r2,zero,202e950 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 202e948:	e0bffd17 	ldw	r2,-12(fp)
 202e94c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 202e950:	e0bffd17 	ldw	r2,-12(fp)
 202e954:	10800217 	ldw	r2,8(r2)
 202e958:	d0e7fa17 	ldw	r3,-24600(gp)
 202e95c:	18801d36 	bltu	r3,r2,202e9d4 <alt_tick+0xd8>
 202e960:	e0bffd17 	ldw	r2,-12(fp)
 202e964:	10800403 	ldbu	r2,16(r2)
 202e968:	10803fcc 	andi	r2,r2,255
 202e96c:	1000191e 	bne	r2,zero,202e9d4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 202e970:	e0bffd17 	ldw	r2,-12(fp)
 202e974:	10800317 	ldw	r2,12(r2)
 202e978:	e0fffd17 	ldw	r3,-12(fp)
 202e97c:	18c00517 	ldw	r3,20(r3)
 202e980:	1809883a 	mov	r4,r3
 202e984:	103ee83a 	callr	r2
 202e988:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 202e98c:	e0bfff17 	ldw	r2,-4(fp)
 202e990:	1000031e 	bne	r2,zero,202e9a0 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 202e994:	e13ffd17 	ldw	r4,-12(fp)
 202e998:	202e8600 	call	202e860 <alt_alarm_stop>
 202e99c:	00000d06 	br	202e9d4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 202e9a0:	e0bffd17 	ldw	r2,-12(fp)
 202e9a4:	10c00217 	ldw	r3,8(r2)
 202e9a8:	e0bfff17 	ldw	r2,-4(fp)
 202e9ac:	1887883a 	add	r3,r3,r2
 202e9b0:	e0bffd17 	ldw	r2,-12(fp)
 202e9b4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 202e9b8:	e0bffd17 	ldw	r2,-12(fp)
 202e9bc:	10c00217 	ldw	r3,8(r2)
 202e9c0:	d0a7fa17 	ldw	r2,-24600(gp)
 202e9c4:	1880032e 	bgeu	r3,r2,202e9d4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 202e9c8:	e0bffd17 	ldw	r2,-12(fp)
 202e9cc:	00c00044 	movi	r3,1
 202e9d0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 202e9d4:	e0bffe17 	ldw	r2,-8(fp)
 202e9d8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 202e9dc:	e0fffd17 	ldw	r3,-12(fp)
 202e9e0:	d0a01d04 	addi	r2,gp,-32652
 202e9e4:	18bfcf1e 	bne	r3,r2,202e924 <__alt_mem_mem_0+0xfd00e924>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 202e9e8:	202dcc00 	call	202dcc0 <vPortSysTickHandler>
}
 202e9ec:	0001883a 	nop
 202e9f0:	e037883a 	mov	sp,fp
 202e9f4:	dfc00117 	ldw	ra,4(sp)
 202e9f8:	df000017 	ldw	fp,0(sp)
 202e9fc:	dec00204 	addi	sp,sp,8
 202ea00:	f800283a 	ret

0202ea04 <alt_uncached_malloc>:
 * Return pointer to the block of memory or NULL if can't allocate it.
 */

volatile void* 
alt_uncached_malloc(size_t size)
{
 202ea04:	defffd04 	addi	sp,sp,-12
 202ea08:	dfc00215 	stw	ra,8(sp)
 202ea0c:	df000115 	stw	fp,4(sp)
 202ea10:	df000104 	addi	fp,sp,4
 202ea14:	e13fff15 	stw	r4,-4(fp)
  ALT_LINK_ERROR("alt_uncached_malloc() is not available because CPU is not configured to use bit 31 of address to bypass data cache");
  return NULL;
#endif /* No address mask option enabled. */
#else /* No data cache */
  /* Just use regular malloc. */
  return malloc(size);
 202ea18:	e13fff17 	ldw	r4,-4(fp)
 202ea1c:	20424000 	call	2042400 <malloc>
#endif /* No data cache */
}
 202ea20:	e037883a 	mov	sp,fp
 202ea24:	dfc00117 	ldw	ra,4(sp)
 202ea28:	df000017 	ldw	fp,0(sp)
 202ea2c:	dec00204 	addi	sp,sp,8
 202ea30:	f800283a 	ret

0202ea34 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 202ea34:	defffd04 	addi	sp,sp,-12
 202ea38:	dfc00215 	stw	ra,8(sp)
 202ea3c:	df000115 	stw	fp,4(sp)
 202ea40:	df000104 	addi	fp,sp,4
 202ea44:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 202ea48:	e13fff17 	ldw	r4,-4(fp)
 202ea4c:	203df1c0 	call	203df1c <alt_busy_sleep>
}
 202ea50:	e037883a 	mov	sp,fp
 202ea54:	dfc00117 	ldw	ra,4(sp)
 202ea58:	df000017 	ldw	fp,0(sp)
 202ea5c:	dec00204 	addi	sp,sp,8
 202ea60:	f800283a 	ret

0202ea64 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202ea64:	defffe04 	addi	sp,sp,-8
 202ea68:	dfc00115 	stw	ra,4(sp)
 202ea6c:	df000015 	stw	fp,0(sp)
 202ea70:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202ea74:	d0a01b17 	ldw	r2,-32660(gp)
 202ea78:	10000326 	beq	r2,zero,202ea88 <alt_get_errno+0x24>
 202ea7c:	d0a01b17 	ldw	r2,-32660(gp)
 202ea80:	103ee83a 	callr	r2
 202ea84:	00000106 	br	202ea8c <alt_get_errno+0x28>
 202ea88:	d0a7a404 	addi	r2,gp,-24944
}
 202ea8c:	e037883a 	mov	sp,fp
 202ea90:	dfc00117 	ldw	ra,4(sp)
 202ea94:	df000017 	ldw	fp,0(sp)
 202ea98:	dec00204 	addi	sp,sp,8
 202ea9c:	f800283a 	ret

0202eaa0 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 202eaa0:	defff904 	addi	sp,sp,-28
 202eaa4:	dfc00615 	stw	ra,24(sp)
 202eaa8:	df000515 	stw	fp,20(sp)
 202eaac:	df000504 	addi	fp,sp,20
 202eab0:	e13ffd15 	stw	r4,-12(fp)
 202eab4:	e17ffe15 	stw	r5,-8(fp)
 202eab8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 202eabc:	e0bffd17 	ldw	r2,-12(fp)
 202eac0:	10000616 	blt	r2,zero,202eadc <alt_write+0x3c>
 202eac4:	e0bffd17 	ldw	r2,-12(fp)
 202eac8:	10c00324 	muli	r3,r2,12
 202eacc:	00808174 	movhi	r2,517
 202ead0:	10a61a04 	addi	r2,r2,-26520
 202ead4:	1885883a 	add	r2,r3,r2
 202ead8:	00000106 	br	202eae0 <alt_write+0x40>
 202eadc:	0005883a 	mov	r2,zero
 202eae0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 202eae4:	e0bffb17 	ldw	r2,-20(fp)
 202eae8:	10002126 	beq	r2,zero,202eb70 <alt_write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 202eaec:	e0bffb17 	ldw	r2,-20(fp)
 202eaf0:	10800217 	ldw	r2,8(r2)
 202eaf4:	108000cc 	andi	r2,r2,3
 202eaf8:	10001826 	beq	r2,zero,202eb5c <alt_write+0xbc>
 202eafc:	e0bffb17 	ldw	r2,-20(fp)
 202eb00:	10800017 	ldw	r2,0(r2)
 202eb04:	10800617 	ldw	r2,24(r2)
 202eb08:	10001426 	beq	r2,zero,202eb5c <alt_write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 202eb0c:	e0bffb17 	ldw	r2,-20(fp)
 202eb10:	10800017 	ldw	r2,0(r2)
 202eb14:	10800617 	ldw	r2,24(r2)
 202eb18:	e0ffff17 	ldw	r3,-4(fp)
 202eb1c:	180d883a 	mov	r6,r3
 202eb20:	e17ffe17 	ldw	r5,-8(fp)
 202eb24:	e13ffb17 	ldw	r4,-20(fp)
 202eb28:	103ee83a 	callr	r2
 202eb2c:	e0bffc15 	stw	r2,-16(fp)
 202eb30:	e0bffc17 	ldw	r2,-16(fp)
 202eb34:	1000070e 	bge	r2,zero,202eb54 <alt_write+0xb4>
      {
        ALT_ERRNO = -rval;
 202eb38:	202ea640 	call	202ea64 <alt_get_errno>
 202eb3c:	1007883a 	mov	r3,r2
 202eb40:	e0bffc17 	ldw	r2,-16(fp)
 202eb44:	0085c83a 	sub	r2,zero,r2
 202eb48:	18800015 	stw	r2,0(r3)
        return -1;
 202eb4c:	00bfffc4 	movi	r2,-1
 202eb50:	00000c06 	br	202eb84 <alt_write+0xe4>
      }
      return rval;
 202eb54:	e0bffc17 	ldw	r2,-16(fp)
 202eb58:	00000a06 	br	202eb84 <alt_write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 202eb5c:	202ea640 	call	202ea64 <alt_get_errno>
 202eb60:	1007883a 	mov	r3,r2
 202eb64:	00800344 	movi	r2,13
 202eb68:	18800015 	stw	r2,0(r3)
 202eb6c:	00000406 	br	202eb80 <alt_write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 202eb70:	202ea640 	call	202ea64 <alt_get_errno>
 202eb74:	1007883a 	mov	r3,r2
 202eb78:	00801444 	movi	r2,81
 202eb7c:	18800015 	stw	r2,0(r3)
  }
  return -1;
 202eb80:	00bfffc4 	movi	r2,-1
}
 202eb84:	e037883a 	mov	sp,fp
 202eb88:	dfc00117 	ldw	ra,4(sp)
 202eb8c:	df000017 	ldw	fp,0(sp)
 202eb90:	dec00204 	addi	sp,sp,8
 202eb94:	f800283a 	ret

0202eb98 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 202eb98:	deffff04 	addi	sp,sp,-4
 202eb9c:	df000015 	stw	fp,0(sp)
 202eba0:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 202eba4:	000170fa 	wrctl	ienable,zero
}
 202eba8:	0001883a 	nop
 202ebac:	e037883a 	mov	sp,fp
 202ebb0:	df000017 	ldw	fp,0(sp)
 202ebb4:	dec00104 	addi	sp,sp,4
 202ebb8:	f800283a 	ret

0202ebbc <lwip_socket_thread_init>:
#endif /* LWIP_IPV4 && LWIP_IPV6 */

/** LWIP_NETCONN_SEM_PER_THREAD==1: initialize thread-local semaphore */
void
lwip_socket_thread_init(void)
{
 202ebbc:	deffff04 	addi	sp,sp,-4
 202ebc0:	df000015 	stw	fp,0(sp)
 202ebc4:	d839883a 	mov	fp,sp
  netconn_thread_init();
}
 202ebc8:	0001883a 	nop
 202ebcc:	e037883a 	mov	sp,fp
 202ebd0:	df000017 	ldw	fp,0(sp)
 202ebd4:	dec00104 	addi	sp,sp,4
 202ebd8:	f800283a 	ret

0202ebdc <lwip_socket_thread_cleanup>:

/** LWIP_NETCONN_SEM_PER_THREAD==1: destroy thread-local semaphore */
void
lwip_socket_thread_cleanup(void)
{
 202ebdc:	deffff04 	addi	sp,sp,-4
 202ebe0:	df000015 	stw	fp,0(sp)
 202ebe4:	d839883a 	mov	fp,sp
  netconn_thread_cleanup();
}
 202ebe8:	0001883a 	nop
 202ebec:	e037883a 	mov	sp,fp
 202ebf0:	df000017 	ldw	fp,0(sp)
 202ebf4:	dec00104 	addi	sp,sp,4
 202ebf8:	f800283a 	ret

0202ebfc <tryget_socket_unconn_nouse>:
#endif /* LWIP_NETCONN_FULLDUPLEX */

/* Translate a socket 'int' into a pointer (only fails if the index is invalid) */
static struct lwip_sock *
tryget_socket_unconn_nouse(int fd)
{
 202ebfc:	defffd04 	addi	sp,sp,-12
 202ec00:	df000215 	stw	fp,8(sp)
 202ec04:	df000204 	addi	fp,sp,8
 202ec08:	e13fff15 	stw	r4,-4(fp)
  int s = fd - LWIP_SOCKET_OFFSET;
 202ec0c:	e0bfff17 	ldw	r2,-4(fp)
 202ec10:	10bffc04 	addi	r2,r2,-16
 202ec14:	e0bffe15 	stw	r2,-8(fp)
  if ((s < 0) || (s >= NUM_SOCKETS)) {
 202ec18:	e0bffe17 	ldw	r2,-8(fp)
 202ec1c:	10000316 	blt	r2,zero,202ec2c <tryget_socket_unconn_nouse+0x30>
 202ec20:	e0bffe17 	ldw	r2,-8(fp)
 202ec24:	10800a90 	cmplti	r2,r2,42
 202ec28:	1000021e 	bne	r2,zero,202ec34 <tryget_socket_unconn_nouse+0x38>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("tryget_socket_unconn(%d): invalid\n", fd));
    return NULL;
 202ec2c:	0005883a 	mov	r2,zero
 202ec30:	00000506 	br	202ec48 <tryget_socket_unconn_nouse+0x4c>
  }
  return &sockets[s];
 202ec34:	e0bffe17 	ldw	r2,-8(fp)
 202ec38:	1006913a 	slli	r3,r2,4
 202ec3c:	00808574 	movhi	r2,533
 202ec40:	10b46404 	addi	r2,r2,-11888
 202ec44:	1885883a 	add	r2,r3,r2
}
 202ec48:	e037883a 	mov	sp,fp
 202ec4c:	df000017 	ldw	fp,0(sp)
 202ec50:	dec00104 	addi	sp,sp,4
 202ec54:	f800283a 	ret

0202ec58 <lwip_socket_dbg_get_socket>:

struct lwip_sock *
lwip_socket_dbg_get_socket(int fd)
{
 202ec58:	defffd04 	addi	sp,sp,-12
 202ec5c:	dfc00215 	stw	ra,8(sp)
 202ec60:	df000115 	stw	fp,4(sp)
 202ec64:	df000104 	addi	fp,sp,4
 202ec68:	e13fff15 	stw	r4,-4(fp)
  return tryget_socket_unconn_nouse(fd);
 202ec6c:	e13fff17 	ldw	r4,-4(fp)
 202ec70:	202ebfc0 	call	202ebfc <tryget_socket_unconn_nouse>
}
 202ec74:	e037883a 	mov	sp,fp
 202ec78:	dfc00117 	ldw	ra,4(sp)
 202ec7c:	df000017 	ldw	fp,0(sp)
 202ec80:	dec00204 	addi	sp,sp,8
 202ec84:	f800283a 	ret

0202ec88 <tryget_socket_unconn>:

/* Translate a socket 'int' into a pointer (only fails if the index is invalid) */
static struct lwip_sock *
tryget_socket_unconn(int fd)
{
 202ec88:	defffc04 	addi	sp,sp,-16
 202ec8c:	dfc00315 	stw	ra,12(sp)
 202ec90:	df000215 	stw	fp,8(sp)
 202ec94:	df000204 	addi	fp,sp,8
 202ec98:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *ret = tryget_socket_unconn_nouse(fd);
 202ec9c:	e13fff17 	ldw	r4,-4(fp)
 202eca0:	202ebfc0 	call	202ebfc <tryget_socket_unconn_nouse>
 202eca4:	e0bffe15 	stw	r2,-8(fp)
  if (ret != NULL) {
    if (!sock_inc_used(ret)) {
      return NULL;
    }
  }
  return ret;
 202eca8:	e0bffe17 	ldw	r2,-8(fp)
}
 202ecac:	e037883a 	mov	sp,fp
 202ecb0:	dfc00117 	ldw	ra,4(sp)
 202ecb4:	df000017 	ldw	fp,0(sp)
 202ecb8:	dec00204 	addi	sp,sp,8
 202ecbc:	f800283a 	ret

0202ecc0 <tryget_socket_unconn_locked>:

/* Like tryget_socket_unconn(), but called under SYS_ARCH_PROTECT lock. */
static struct lwip_sock *
tryget_socket_unconn_locked(int fd)
{
 202ecc0:	defffc04 	addi	sp,sp,-16
 202ecc4:	dfc00315 	stw	ra,12(sp)
 202ecc8:	df000215 	stw	fp,8(sp)
 202eccc:	df000204 	addi	fp,sp,8
 202ecd0:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *ret = tryget_socket_unconn_nouse(fd);
 202ecd4:	e13fff17 	ldw	r4,-4(fp)
 202ecd8:	202ebfc0 	call	202ebfc <tryget_socket_unconn_nouse>
 202ecdc:	e0bffe15 	stw	r2,-8(fp)
  if (ret != NULL) {
    if (!sock_inc_used_locked(ret)) {
      return NULL;
    }
  }
  return ret;
 202ece0:	e0bffe17 	ldw	r2,-8(fp)
}
 202ece4:	e037883a 	mov	sp,fp
 202ece8:	dfc00117 	ldw	ra,4(sp)
 202ecec:	df000017 	ldw	fp,0(sp)
 202ecf0:	dec00204 	addi	sp,sp,8
 202ecf4:	f800283a 	ret

0202ecf8 <tryget_socket>:
 * @param fd externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int fd)
{
 202ecf8:	defffc04 	addi	sp,sp,-16
 202ecfc:	dfc00315 	stw	ra,12(sp)
 202ed00:	df000215 	stw	fp,8(sp)
 202ed04:	df000204 	addi	fp,sp,8
 202ed08:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *sock = tryget_socket_unconn(fd);
 202ed0c:	e13fff17 	ldw	r4,-4(fp)
 202ed10:	202ec880 	call	202ec88 <tryget_socket_unconn>
 202ed14:	e0bffe15 	stw	r2,-8(fp)
  if (sock != NULL) {
 202ed18:	e0bffe17 	ldw	r2,-8(fp)
 202ed1c:	10000526 	beq	r2,zero,202ed34 <tryget_socket+0x3c>
    if (sock->conn) {
 202ed20:	e0bffe17 	ldw	r2,-8(fp)
 202ed24:	10800017 	ldw	r2,0(r2)
 202ed28:	10000226 	beq	r2,zero,202ed34 <tryget_socket+0x3c>
      return sock;
 202ed2c:	e0bffe17 	ldw	r2,-8(fp)
 202ed30:	00000106 	br	202ed38 <tryget_socket+0x40>
    }
    done_socket(sock);
  }
  return NULL;
 202ed34:	0005883a 	mov	r2,zero
}
 202ed38:	e037883a 	mov	sp,fp
 202ed3c:	dfc00117 	ldw	ra,4(sp)
 202ed40:	df000017 	ldw	fp,0(sp)
 202ed44:	dec00204 	addi	sp,sp,8
 202ed48:	f800283a 	ret

0202ed4c <get_socket>:
 * @param fd externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
get_socket(int fd)
{
 202ed4c:	defffc04 	addi	sp,sp,-16
 202ed50:	dfc00315 	stw	ra,12(sp)
 202ed54:	df000215 	stw	fp,8(sp)
 202ed58:	df000204 	addi	fp,sp,8
 202ed5c:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *sock = tryget_socket(fd);
 202ed60:	e13fff17 	ldw	r4,-4(fp)
 202ed64:	202ecf80 	call	202ecf8 <tryget_socket>
 202ed68:	e0bffe15 	stw	r2,-8(fp)
  if (!sock) {
 202ed6c:	e0bffe17 	ldw	r2,-8(fp)
 202ed70:	1000061e 	bne	r2,zero,202ed8c <get_socket+0x40>
    if ((fd < LWIP_SOCKET_OFFSET) || (fd >= (LWIP_SOCKET_OFFSET + NUM_SOCKETS))) {
      LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", fd));
    }
    set_errno(EBADF);
 202ed74:	20423b80 	call	20423b8 <__errno>
 202ed78:	1007883a 	mov	r3,r2
 202ed7c:	00800244 	movi	r2,9
 202ed80:	18800015 	stw	r2,0(r3)
    return NULL;
 202ed84:	0005883a 	mov	r2,zero
 202ed88:	00000106 	br	202ed90 <get_socket+0x44>
  }
  return sock;
 202ed8c:	e0bffe17 	ldw	r2,-8(fp)
}
 202ed90:	e037883a 	mov	sp,fp
 202ed94:	dfc00117 	ldw	ra,4(sp)
 202ed98:	df000017 	ldw	fp,0(sp)
 202ed9c:	dec00204 	addi	sp,sp,8
 202eda0:	f800283a 	ret

0202eda4 <alloc_socket>:
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
 202eda4:	defffa04 	addi	sp,sp,-24
 202eda8:	dfc00515 	stw	ra,20(sp)
 202edac:	df000415 	stw	fp,16(sp)
 202edb0:	df000404 	addi	fp,sp,16
 202edb4:	e13ffe15 	stw	r4,-8(fp)
 202edb8:	e17fff15 	stw	r5,-4(fp)
  int i;
  SYS_ARCH_DECL_PROTECT(lev);
  LWIP_UNUSED_ARG(accepted);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 202edbc:	e03ffc15 	stw	zero,-16(fp)
 202edc0:	00004106 	br	202eec8 <alloc_socket+0x124>
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
 202edc4:	2014cec0 	call	2014cec <sys_arch_protect>
 202edc8:	e0bffd15 	stw	r2,-12(fp)
    if (!sockets[i].conn) {
 202edcc:	00808574 	movhi	r2,533
 202edd0:	10b46404 	addi	r2,r2,-11888
 202edd4:	e0fffc17 	ldw	r3,-16(fp)
 202edd8:	1806913a 	slli	r3,r3,4
 202eddc:	10c5883a 	add	r2,r2,r3
 202ede0:	10800017 	ldw	r2,0(r2)
 202ede4:	1000331e 	bne	r2,zero,202eeb4 <alloc_socket+0x110>
        continue;
      }
      sockets[i].fd_used    = 1;
      sockets[i].fd_free_pending = 0;
#endif
      sockets[i].conn       = newconn;
 202ede8:	00808574 	movhi	r2,533
 202edec:	10b46404 	addi	r2,r2,-11888
 202edf0:	e0fffc17 	ldw	r3,-16(fp)
 202edf4:	1806913a 	slli	r3,r3,4
 202edf8:	10c5883a 	add	r2,r2,r3
 202edfc:	e0fffe17 	ldw	r3,-8(fp)
 202ee00:	10c00015 	stw	r3,0(r2)
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
 202ee04:	e13ffd17 	ldw	r4,-12(fp)
 202ee08:	2014d200 	call	2014d20 <sys_arch_unprotect>
      sockets[i].lastdata.pbuf = NULL;
 202ee0c:	00808574 	movhi	r2,533
 202ee10:	10b46404 	addi	r2,r2,-11888
 202ee14:	e0fffc17 	ldw	r3,-16(fp)
 202ee18:	1806913a 	slli	r3,r3,4
 202ee1c:	10c5883a 	add	r2,r2,r3
 202ee20:	10800104 	addi	r2,r2,4
 202ee24:	10000015 	stw	zero,0(r2)
#if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
      LWIP_ASSERT("sockets[i].select_waiting == 0", sockets[i].select_waiting == 0);
      sockets[i].rcvevent   = 0;
 202ee28:	00808574 	movhi	r2,533
 202ee2c:	10b46404 	addi	r2,r2,-11888
 202ee30:	e0fffc17 	ldw	r3,-16(fp)
 202ee34:	1806913a 	slli	r3,r3,4
 202ee38:	10c5883a 	add	r2,r2,r3
 202ee3c:	10800204 	addi	r2,r2,8
 202ee40:	1000000d 	sth	zero,0(r2)
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
 202ee44:	e0bffe17 	ldw	r2,-8(fp)
 202ee48:	10800017 	ldw	r2,0(r2)
 202ee4c:	10803c0c 	andi	r2,r2,240
 202ee50:	10800418 	cmpnei	r2,r2,16
 202ee54:	1000021e 	bne	r2,zero,202ee60 <alloc_socket+0xbc>
 202ee58:	e0bfff17 	ldw	r2,-4(fp)
 202ee5c:	10000226 	beq	r2,zero,202ee68 <alloc_socket+0xc4>
 202ee60:	00800044 	movi	r2,1
 202ee64:	00000106 	br	202ee6c <alloc_socket+0xc8>
 202ee68:	0005883a 	mov	r2,zero
 202ee6c:	1009883a 	mov	r4,r2
 202ee70:	00808574 	movhi	r2,533
 202ee74:	10b46404 	addi	r2,r2,-11888
 202ee78:	e0fffc17 	ldw	r3,-16(fp)
 202ee7c:	1806913a 	slli	r3,r3,4
 202ee80:	10c5883a 	add	r2,r2,r3
 202ee84:	10800284 	addi	r2,r2,10
 202ee88:	1100000d 	sth	r4,0(r2)
      sockets[i].errevent   = 0;
 202ee8c:	00808574 	movhi	r2,533
 202ee90:	10b46404 	addi	r2,r2,-11888
 202ee94:	e0fffc17 	ldw	r3,-16(fp)
 202ee98:	1806913a 	slli	r3,r3,4
 202ee9c:	10c5883a 	add	r2,r2,r3
 202eea0:	10800304 	addi	r2,r2,12
 202eea4:	1000000d 	sth	zero,0(r2)
#endif /* LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL */
      return i + LWIP_SOCKET_OFFSET;
 202eea8:	e0bffc17 	ldw	r2,-16(fp)
 202eeac:	10800404 	addi	r2,r2,16
 202eeb0:	00000906 	br	202eed8 <alloc_socket+0x134>
    }
    SYS_ARCH_UNPROTECT(lev);
 202eeb4:	e13ffd17 	ldw	r4,-12(fp)
 202eeb8:	2014d200 	call	2014d20 <sys_arch_unprotect>
  int i;
  SYS_ARCH_DECL_PROTECT(lev);
  LWIP_UNUSED_ARG(accepted);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 202eebc:	e0bffc17 	ldw	r2,-16(fp)
 202eec0:	10800044 	addi	r2,r2,1
 202eec4:	e0bffc15 	stw	r2,-16(fp)
 202eec8:	e0bffc17 	ldw	r2,-16(fp)
 202eecc:	10800a90 	cmplti	r2,r2,42
 202eed0:	103fbc1e 	bne	r2,zero,202edc4 <__alt_mem_mem_0+0xfd00edc4>
#endif /* LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL */
      return i + LWIP_SOCKET_OFFSET;
    }
    SYS_ARCH_UNPROTECT(lev);
  }
  return -1;
 202eed4:	00bfffc4 	movi	r2,-1
}
 202eed8:	e037883a 	mov	sp,fp
 202eedc:	dfc00117 	ldw	ra,4(sp)
 202eee0:	df000017 	ldw	fp,0(sp)
 202eee4:	dec00204 	addi	sp,sp,8
 202eee8:	f800283a 	ret

0202eeec <free_socket_locked>:
 * @param lastdata lastdata is stored here, must be freed externally
 */
static int
free_socket_locked(struct lwip_sock *sock, int is_tcp, struct netconn **conn,
                   union lwip_sock_lastdata *lastdata)
{
 202eeec:	defffb04 	addi	sp,sp,-20
 202eef0:	df000415 	stw	fp,16(sp)
 202eef4:	df000404 	addi	fp,sp,16
 202eef8:	e13ffc15 	stw	r4,-16(fp)
 202eefc:	e17ffd15 	stw	r5,-12(fp)
 202ef00:	e1bffe15 	stw	r6,-8(fp)
 202ef04:	e1ffff15 	stw	r7,-4(fp)
  }
#else /* LWIP_NETCONN_FULLDUPLEX */
  LWIP_UNUSED_ARG(is_tcp);
#endif /* LWIP_NETCONN_FULLDUPLEX */

  *lastdata = sock->lastdata;
 202ef08:	e0bfff17 	ldw	r2,-4(fp)
 202ef0c:	e0fffc17 	ldw	r3,-16(fp)
 202ef10:	18c00117 	ldw	r3,4(r3)
 202ef14:	10c00015 	stw	r3,0(r2)
  sock->lastdata.pbuf = NULL;
 202ef18:	e0bffc17 	ldw	r2,-16(fp)
 202ef1c:	10000115 	stw	zero,4(r2)
  *conn = sock->conn;
 202ef20:	e0bffc17 	ldw	r2,-16(fp)
 202ef24:	10c00017 	ldw	r3,0(r2)
 202ef28:	e0bffe17 	ldw	r2,-8(fp)
 202ef2c:	10c00015 	stw	r3,0(r2)
  sock->conn = NULL;
 202ef30:	e0bffc17 	ldw	r2,-16(fp)
 202ef34:	10000015 	stw	zero,0(r2)
  return 1;
 202ef38:	00800044 	movi	r2,1
}
 202ef3c:	e037883a 	mov	sp,fp
 202ef40:	df000017 	ldw	fp,0(sp)
 202ef44:	dec00104 	addi	sp,sp,4
 202ef48:	f800283a 	ret

0202ef4c <free_socket_free_elements>:

/** Free a socket's leftover members.
 */
static void
free_socket_free_elements(int is_tcp, struct netconn *conn, union lwip_sock_lastdata *lastdata)
{
 202ef4c:	defffb04 	addi	sp,sp,-20
 202ef50:	dfc00415 	stw	ra,16(sp)
 202ef54:	df000315 	stw	fp,12(sp)
 202ef58:	df000304 	addi	fp,sp,12
 202ef5c:	e13ffd15 	stw	r4,-12(fp)
 202ef60:	e17ffe15 	stw	r5,-8(fp)
 202ef64:	e1bfff15 	stw	r6,-4(fp)
  if (lastdata->pbuf != NULL) {
 202ef68:	e0bfff17 	ldw	r2,-4(fp)
 202ef6c:	10800017 	ldw	r2,0(r2)
 202ef70:	10000b26 	beq	r2,zero,202efa0 <free_socket_free_elements+0x54>
    if (is_tcp) {
 202ef74:	e0bffd17 	ldw	r2,-12(fp)
 202ef78:	10000526 	beq	r2,zero,202ef90 <free_socket_free_elements+0x44>
      pbuf_free(lastdata->pbuf);
 202ef7c:	e0bfff17 	ldw	r2,-4(fp)
 202ef80:	10800017 	ldw	r2,0(r2)
 202ef84:	1009883a 	mov	r4,r2
 202ef88:	201d2f40 	call	201d2f4 <pbuf_free>
 202ef8c:	00000406 	br	202efa0 <free_socket_free_elements+0x54>
    } else {
      netbuf_delete(lastdata->netbuf);
 202ef90:	e0bfff17 	ldw	r2,-4(fp)
 202ef94:	10800017 	ldw	r2,0(r2)
 202ef98:	1009883a 	mov	r4,r2
 202ef9c:	2041f400 	call	2041f40 <netbuf_delete>
    }
  }
  if (conn != NULL) {
 202efa0:	e0bffe17 	ldw	r2,-8(fp)
 202efa4:	10000226 	beq	r2,zero,202efb0 <free_socket_free_elements+0x64>
    /* netconn_prepare_delete() has already been called, here we only free the conn */
    netconn_delete(conn);
 202efa8:	e13ffe17 	ldw	r4,-8(fp)
 202efac:	203e2900 	call	203e290 <netconn_delete>
  }
}
 202efb0:	0001883a 	nop
 202efb4:	e037883a 	mov	sp,fp
 202efb8:	dfc00117 	ldw	ra,4(sp)
 202efbc:	df000017 	ldw	fp,0(sp)
 202efc0:	dec00204 	addi	sp,sp,8
 202efc4:	f800283a 	ret

0202efc8 <free_socket>:
 * @param sock the socket to free
 * @param is_tcp != 0 for TCP sockets, used to free lastdata
 */
static void
free_socket(struct lwip_sock *sock, int is_tcp)
{
 202efc8:	defff804 	addi	sp,sp,-32
 202efcc:	dfc00715 	stw	ra,28(sp)
 202efd0:	df000615 	stw	fp,24(sp)
 202efd4:	df000604 	addi	fp,sp,24
 202efd8:	e13ffe15 	stw	r4,-8(fp)
 202efdc:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn;
  union lwip_sock_lastdata lastdata;
  SYS_ARCH_DECL_PROTECT(lev);

  /* Protect socket array */
  SYS_ARCH_PROTECT(lev);
 202efe0:	2014cec0 	call	2014cec <sys_arch_protect>
 202efe4:	e0bffa15 	stw	r2,-24(fp)

  freed = free_socket_locked(sock, is_tcp, &conn, &lastdata);
 202efe8:	e0fffd04 	addi	r3,fp,-12
 202efec:	e0bffc04 	addi	r2,fp,-16
 202eff0:	180f883a 	mov	r7,r3
 202eff4:	100d883a 	mov	r6,r2
 202eff8:	e17fff17 	ldw	r5,-4(fp)
 202effc:	e13ffe17 	ldw	r4,-8(fp)
 202f000:	202eeec0 	call	202eeec <free_socket_locked>
 202f004:	e0bffb15 	stw	r2,-20(fp)
  SYS_ARCH_UNPROTECT(lev);
 202f008:	e13ffa17 	ldw	r4,-24(fp)
 202f00c:	2014d200 	call	2014d20 <sys_arch_unprotect>
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (freed) {
 202f010:	e0bffb17 	ldw	r2,-20(fp)
 202f014:	10000626 	beq	r2,zero,202f030 <free_socket+0x68>
    free_socket_free_elements(is_tcp, conn, &lastdata);
 202f018:	e0bffc17 	ldw	r2,-16(fp)
 202f01c:	e0fffd04 	addi	r3,fp,-12
 202f020:	180d883a 	mov	r6,r3
 202f024:	100b883a 	mov	r5,r2
 202f028:	e13fff17 	ldw	r4,-4(fp)
 202f02c:	202ef4c0 	call	202ef4c <free_socket_free_elements>
  }
}
 202f030:	0001883a 	nop
 202f034:	e037883a 	mov	sp,fp
 202f038:	dfc00117 	ldw	ra,4(sp)
 202f03c:	df000017 	ldw	fp,0(sp)
 202f040:	dec00204 	addi	sp,sp,8
 202f044:	f800283a 	ret

0202f048 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
 202f048:	deffed04 	addi	sp,sp,-76
 202f04c:	dfc01215 	stw	ra,72(sp)
 202f050:	df001115 	stw	fp,68(sp)
 202f054:	dc001015 	stw	r16,64(sp)
 202f058:	df001104 	addi	fp,sp,68
 202f05c:	e13ffc15 	stw	r4,-16(fp)
 202f060:	e17ffd15 	stw	r5,-12(fp)
 202f064:	e1bffe15 	stw	r6,-8(fp)
  struct lwip_sock *sock, *nsock;
  struct netconn *newconn;
  ip_addr_t naddr;
  u16_t port = 0;
 202f068:	e03ff70d 	sth	zero,-36(fp)
  err_t err;
  int recvevent;
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
 202f06c:	e13ffc17 	ldw	r4,-16(fp)
 202f070:	202ed4c0 	call	202ed4c <get_socket>
 202f074:	e0bff015 	stw	r2,-64(fp)
  if (!sock) {
 202f078:	e0bff017 	ldw	r2,-64(fp)
 202f07c:	1000021e 	bne	r2,zero,202f088 <lwip_accept+0x40>
    return -1;
 202f080:	00bfffc4 	movi	r2,-1
 202f084:	0000a206 	br	202f310 <lwip_accept+0x2c8>
  }

  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
 202f088:	e0bff017 	ldw	r2,-64(fp)
 202f08c:	10800017 	ldw	r2,0(r2)
 202f090:	e0fff504 	addi	r3,fp,-44
 202f094:	180b883a 	mov	r5,r3
 202f098:	1009883a 	mov	r4,r2
 202f09c:	203e5d00 	call	203e5d0 <netconn_accept>
 202f0a0:	e0bff105 	stb	r2,-60(fp)
  if (err != ERR_OK) {
 202f0a4:	e0bff107 	ldb	r2,-60(fp)
 202f0a8:	10001f26 	beq	r2,zero,202f128 <lwip_accept+0xe0>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
 202f0ac:	e0bff017 	ldw	r2,-64(fp)
 202f0b0:	10800017 	ldw	r2,0(r2)
 202f0b4:	10800017 	ldw	r2,0(r2)
 202f0b8:	10803c0c 	andi	r2,r2,240
 202f0bc:	10800420 	cmpeqi	r2,r2,16
 202f0c0:	1000051e 	bne	r2,zero,202f0d8 <lwip_accept+0x90>
      set_errno(EOPNOTSUPP);
 202f0c4:	20423b80 	call	20423b8 <__errno>
 202f0c8:	1007883a 	mov	r3,r2
 202f0cc:	008017c4 	movi	r2,95
 202f0d0:	18800015 	stw	r2,0(r3)
 202f0d4:	00001206 	br	202f120 <lwip_accept+0xd8>
    } else if (err == ERR_CLSD) {
 202f0d8:	e0bff107 	ldb	r2,-60(fp)
 202f0dc:	10bffc58 	cmpnei	r2,r2,-15
 202f0e0:	1000051e 	bne	r2,zero,202f0f8 <lwip_accept+0xb0>
      set_errno(EINVAL);
 202f0e4:	20423b80 	call	20423b8 <__errno>
 202f0e8:	1007883a 	mov	r3,r2
 202f0ec:	00800584 	movi	r2,22
 202f0f0:	18800015 	stw	r2,0(r3)
 202f0f4:	00000a06 	br	202f120 <lwip_accept+0xd8>
    } else {
      set_errno(err_to_errno(err));
 202f0f8:	e0bff107 	ldb	r2,-60(fp)
 202f0fc:	1009883a 	mov	r4,r2
 202f100:	2041e900 	call	2041e90 <err_to_errno>
 202f104:	10000626 	beq	r2,zero,202f120 <lwip_accept+0xd8>
 202f108:	20423b80 	call	20423b8 <__errno>
 202f10c:	1021883a 	mov	r16,r2
 202f110:	e0bff107 	ldb	r2,-60(fp)
 202f114:	1009883a 	mov	r4,r2
 202f118:	2041e900 	call	2041e90 <err_to_errno>
 202f11c:	80800015 	stw	r2,0(r16)
    }
    done_socket(sock);
    return -1;
 202f120:	00bfffc4 	movi	r2,-1
 202f124:	00007a06 	br	202f310 <lwip_accept+0x2c8>
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);

  newsock = alloc_socket(newconn, 1);
 202f128:	e0bff517 	ldw	r2,-44(fp)
 202f12c:	01400044 	movi	r5,1
 202f130:	1009883a 	mov	r4,r2
 202f134:	202eda40 	call	202eda4 <alloc_socket>
 202f138:	e0bff215 	stw	r2,-56(fp)
  if (newsock == -1) {
 202f13c:	e0bff217 	ldw	r2,-56(fp)
 202f140:	10bfffd8 	cmpnei	r2,r2,-1
 202f144:	1000091e 	bne	r2,zero,202f16c <lwip_accept+0x124>
    netconn_delete(newconn);
 202f148:	e0bff517 	ldw	r2,-44(fp)
 202f14c:	1009883a 	mov	r4,r2
 202f150:	203e2900 	call	203e290 <netconn_delete>
    set_errno(ENFILE);
 202f154:	20423b80 	call	20423b8 <__errno>
 202f158:	1007883a 	mov	r3,r2
 202f15c:	008005c4 	movi	r2,23
 202f160:	18800015 	stw	r2,0(r3)
    done_socket(sock);
    return -1;
 202f164:	00bfffc4 	movi	r2,-1
 202f168:	00006906 	br	202f310 <lwip_accept+0x2c8>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= LWIP_SOCKET_OFFSET) && (newsock < NUM_SOCKETS + LWIP_SOCKET_OFFSET));
  nsock = &sockets[newsock - LWIP_SOCKET_OFFSET];
 202f16c:	e0bff217 	ldw	r2,-56(fp)
 202f170:	10bffc04 	addi	r2,r2,-16
 202f174:	1006913a 	slli	r3,r2,4
 202f178:	00808574 	movhi	r2,533
 202f17c:	10b46404 	addi	r2,r2,-11888
 202f180:	1885883a 	add	r2,r3,r2
 202f184:	e0bff315 	stw	r2,-52(fp)
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  SYS_ARCH_PROTECT(lev);
 202f188:	2014cec0 	call	2014cec <sys_arch_protect>
 202f18c:	e0bff415 	stw	r2,-48(fp)
  recvevent = (s16_t)(-1 - newconn->callback_arg.socket);
 202f190:	e0bff517 	ldw	r2,-44(fp)
 202f194:	10800717 	ldw	r2,28(r2)
 202f198:	0084303a 	nor	r2,zero,r2
 202f19c:	10bfffcc 	andi	r2,r2,65535
 202f1a0:	10a0001c 	xori	r2,r2,32768
 202f1a4:	10a00004 	addi	r2,r2,-32768
 202f1a8:	e0bfef15 	stw	r2,-68(fp)
  newconn->callback_arg.socket = newsock;
 202f1ac:	e0bff517 	ldw	r2,-44(fp)
 202f1b0:	e0fff217 	ldw	r3,-56(fp)
 202f1b4:	10c00715 	stw	r3,28(r2)
  SYS_ARCH_UNPROTECT(lev);
 202f1b8:	e13ff417 	ldw	r4,-48(fp)
 202f1bc:	2014d200 	call	2014d20 <sys_arch_unprotect>

  if (newconn->callback) {
 202f1c0:	e0bff517 	ldw	r2,-44(fp)
 202f1c4:	10800b17 	ldw	r2,44(r2)
 202f1c8:	10000d26 	beq	r2,zero,202f200 <lwip_accept+0x1b8>
    LOCK_TCPIP_CORE();
    while (recvevent > 0) {
 202f1cc:	00000a06 	br	202f1f8 <lwip_accept+0x1b0>
      recvevent--;
 202f1d0:	e0bfef17 	ldw	r2,-68(fp)
 202f1d4:	10bfffc4 	addi	r2,r2,-1
 202f1d8:	e0bfef15 	stw	r2,-68(fp)
      newconn->callback(newconn, NETCONN_EVT_RCVPLUS, 0);
 202f1dc:	e0bff517 	ldw	r2,-44(fp)
 202f1e0:	10800b17 	ldw	r2,44(r2)
 202f1e4:	e0fff517 	ldw	r3,-44(fp)
 202f1e8:	000d883a 	mov	r6,zero
 202f1ec:	000b883a 	mov	r5,zero
 202f1f0:	1809883a 	mov	r4,r3
 202f1f4:	103ee83a 	callr	r2
  newconn->callback_arg.socket = newsock;
  SYS_ARCH_UNPROTECT(lev);

  if (newconn->callback) {
    LOCK_TCPIP_CORE();
    while (recvevent > 0) {
 202f1f8:	e0bfef17 	ldw	r2,-68(fp)
 202f1fc:	00bff416 	blt	zero,r2,202f1d0 <__alt_mem_mem_0+0xfd00f1d0>
  }

  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
   * not be NULL if addr is valid.
   */
  if ((addr != NULL) && (addrlen != NULL)) {
 202f200:	e0bffd17 	ldw	r2,-12(fp)
 202f204:	10004126 	beq	r2,zero,202f30c <lwip_accept+0x2c4>
 202f208:	e0bffe17 	ldw	r2,-8(fp)
 202f20c:	10003f26 	beq	r2,zero,202f30c <lwip_accept+0x2c4>
    union sockaddr_aligned tempaddr;
    /* get the IP address and port of the remote host */
    err = netconn_peer(newconn, &naddr, &port);
 202f210:	e0bff517 	ldw	r2,-44(fp)
 202f214:	e13ff704 	addi	r4,fp,-36
 202f218:	e0fff604 	addi	r3,fp,-40
 202f21c:	000f883a 	mov	r7,zero
 202f220:	200d883a 	mov	r6,r4
 202f224:	180b883a 	mov	r5,r3
 202f228:	1009883a 	mov	r4,r2
 202f22c:	203e2e80 	call	203e2e8 <netconn_getaddr>
 202f230:	e0bff105 	stb	r2,-60(fp)
    if (err != ERR_OK) {
 202f234:	e0bff107 	ldb	r2,-60(fp)
 202f238:	10000f26 	beq	r2,zero,202f278 <lwip_accept+0x230>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
      free_socket(nsock, 1);
 202f23c:	01400044 	movi	r5,1
 202f240:	e13ff317 	ldw	r4,-52(fp)
 202f244:	202efc80 	call	202efc8 <free_socket>
      set_errno(err_to_errno(err));
 202f248:	e0bff107 	ldb	r2,-60(fp)
 202f24c:	1009883a 	mov	r4,r2
 202f250:	2041e900 	call	2041e90 <err_to_errno>
 202f254:	10000626 	beq	r2,zero,202f270 <lwip_accept+0x228>
 202f258:	20423b80 	call	20423b8 <__errno>
 202f25c:	1021883a 	mov	r16,r2
 202f260:	e0bff107 	ldb	r2,-60(fp)
 202f264:	1009883a 	mov	r4,r2
 202f268:	2041e900 	call	2041e90 <err_to_errno>
 202f26c:	80800015 	stw	r2,0(r16)
      done_socket(sock);
      return -1;
 202f270:	00bfffc4 	movi	r2,-1
 202f274:	00002606 	br	202f310 <lwip_accept+0x2c8>
    }

    IPADDR_PORT_TO_SOCKADDR(&tempaddr, &naddr, port);
 202f278:	e0bff804 	addi	r2,fp,-32
 202f27c:	00c00404 	movi	r3,16
 202f280:	10c00005 	stb	r3,0(r2)
 202f284:	e0bff804 	addi	r2,fp,-32
 202f288:	00c00084 	movi	r3,2
 202f28c:	10c00045 	stb	r3,1(r2)
 202f290:	e43ff804 	addi	r16,fp,-32
 202f294:	e0bff70b 	ldhu	r2,-36(fp)
 202f298:	10bfffcc 	andi	r2,r2,65535
 202f29c:	1009883a 	mov	r4,r2
 202f2a0:	20394740 	call	2039474 <lwip_htons>
 202f2a4:	8080008d 	sth	r2,2(r16)
 202f2a8:	e0bff804 	addi	r2,fp,-32
 202f2ac:	e0fff617 	ldw	r3,-40(fp)
 202f2b0:	10c00115 	stw	r3,4(r2)
 202f2b4:	e0bff804 	addi	r2,fp,-32
 202f2b8:	10800204 	addi	r2,r2,8
 202f2bc:	01800204 	movi	r6,8
 202f2c0:	000b883a 	mov	r5,zero
 202f2c4:	1009883a 	mov	r4,r2
 202f2c8:	2005fa00 	call	2005fa0 <memset>
    if (*addrlen > IPADDR_SOCKADDR_GET_LEN(&tempaddr)) {
 202f2cc:	e0bffe17 	ldw	r2,-8(fp)
 202f2d0:	10800017 	ldw	r2,0(r2)
 202f2d4:	e0fff803 	ldbu	r3,-32(fp)
 202f2d8:	18c03fcc 	andi	r3,r3,255
 202f2dc:	1880042e 	bgeu	r3,r2,202f2f0 <lwip_accept+0x2a8>
      *addrlen = IPADDR_SOCKADDR_GET_LEN(&tempaddr);
 202f2e0:	e0bff803 	ldbu	r2,-32(fp)
 202f2e4:	10c03fcc 	andi	r3,r2,255
 202f2e8:	e0bffe17 	ldw	r2,-8(fp)
 202f2ec:	10c00015 	stw	r3,0(r2)
    }
    MEMCPY(addr, &tempaddr, *addrlen);
 202f2f0:	e0bffe17 	ldw	r2,-8(fp)
 202f2f4:	10c00017 	ldw	r3,0(r2)
 202f2f8:	e0bff804 	addi	r2,fp,-32
 202f2fc:	180d883a 	mov	r6,r3
 202f300:	100b883a 	mov	r5,r2
 202f304:	e13ffd17 	ldw	r4,-12(fp)
 202f308:	2005e580 	call	2005e58 <memcpy>
  }

  set_errno(0);
  done_socket(sock);
  done_socket(nsock);
  return newsock;
 202f30c:	e0bff217 	ldw	r2,-56(fp)
}
 202f310:	e6ffff04 	addi	sp,fp,-4
 202f314:	dfc00217 	ldw	ra,8(sp)
 202f318:	df000117 	ldw	fp,4(sp)
 202f31c:	dc000017 	ldw	r16,0(sp)
 202f320:	dec00304 	addi	sp,sp,12
 202f324:	f800283a 	ret

0202f328 <lwip_bind>:

int
lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
 202f328:	defff704 	addi	sp,sp,-36
 202f32c:	dfc00815 	stw	ra,32(sp)
 202f330:	df000715 	stw	fp,28(sp)
 202f334:	dc000615 	stw	r16,24(sp)
 202f338:	df000704 	addi	fp,sp,28
 202f33c:	e13ffc15 	stw	r4,-16(fp)
 202f340:	e17ffd15 	stw	r5,-12(fp)
 202f344:	e1bffe15 	stw	r6,-8(fp)
  struct lwip_sock *sock;
  ip_addr_t local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
 202f348:	e13ffc17 	ldw	r4,-16(fp)
 202f34c:	202ed4c0 	call	202ed4c <get_socket>
 202f350:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 202f354:	e0bff917 	ldw	r2,-28(fp)
 202f358:	1000021e 	bne	r2,zero,202f364 <lwip_bind+0x3c>
    return -1;
 202f35c:	00bfffc4 	movi	r2,-1
 202f360:	00003606 	br	202f43c <lwip_bind+0x114>
    done_socket(sock);
    return -1;
  }

  /* check size, family and alignment of 'name' */
  LWIP_ERROR("lwip_bind: invalid address", (IS_SOCK_ADDR_LEN_VALID(namelen) &&
 202f364:	e0bffe17 	ldw	r2,-8(fp)
 202f368:	10800418 	cmpnei	r2,r2,16
 202f36c:	1000081e 	bne	r2,zero,202f390 <lwip_bind+0x68>
 202f370:	e0bffd17 	ldw	r2,-12(fp)
 202f374:	10800043 	ldbu	r2,1(r2)
 202f378:	10803fcc 	andi	r2,r2,255
 202f37c:	10800098 	cmpnei	r2,r2,2
 202f380:	1000031e 	bne	r2,zero,202f390 <lwip_bind+0x68>
 202f384:	e0bffd17 	ldw	r2,-12(fp)
 202f388:	108000cc 	andi	r2,r2,3
 202f38c:	10000a26 	beq	r2,zero,202f3b8 <lwip_bind+0x90>
 202f390:	013ffc04 	movi	r4,-16
 202f394:	2041e900 	call	2041e90 <err_to_errno>
 202f398:	10000526 	beq	r2,zero,202f3b0 <lwip_bind+0x88>
 202f39c:	20423b80 	call	20423b8 <__errno>
 202f3a0:	1021883a 	mov	r16,r2
 202f3a4:	013ffc04 	movi	r4,-16
 202f3a8:	2041e900 	call	2041e90 <err_to_errno>
 202f3ac:	80800015 	stw	r2,0(r16)
 202f3b0:	00bfffc4 	movi	r2,-1
 202f3b4:	00002106 	br	202f43c <lwip_bind+0x114>
             IS_SOCK_ADDR_TYPE_VALID(name) && IS_SOCK_ADDR_ALIGNED(name)),
             set_errno(err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
  LWIP_UNUSED_ARG(namelen);

  SOCKADDR_TO_IPADDR_PORT(name, &local_addr, local_port);
 202f3b8:	e0bffd17 	ldw	r2,-12(fp)
 202f3bc:	10800117 	ldw	r2,4(r2)
 202f3c0:	e0bffb15 	stw	r2,-20(fp)
 202f3c4:	e0bffd17 	ldw	r2,-12(fp)
 202f3c8:	1080008b 	ldhu	r2,2(r2)
 202f3cc:	10bfffcc 	andi	r2,r2,65535
 202f3d0:	1009883a 	mov	r4,r2
 202f3d4:	20394740 	call	2039474 <lwip_htons>
 202f3d8:	e0bffa0d 	sth	r2,-24(fp)
    unmap_ipv4_mapped_ipv6(ip_2_ip4(&local_addr), ip_2_ip6(&local_addr));
    IP_SET_TYPE_VAL(local_addr, IPADDR_TYPE_V4);
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

  err = netconn_bind(sock->conn, &local_addr, local_port);
 202f3dc:	e0bff917 	ldw	r2,-28(fp)
 202f3e0:	10800017 	ldw	r2,0(r2)
 202f3e4:	e13ffa0b 	ldhu	r4,-24(fp)
 202f3e8:	e0fffb04 	addi	r3,fp,-20
 202f3ec:	200d883a 	mov	r6,r4
 202f3f0:	180b883a 	mov	r5,r3
 202f3f4:	1009883a 	mov	r4,r2
 202f3f8:	203e38c0 	call	203e38c <netconn_bind>
 202f3fc:	e0bffa85 	stb	r2,-22(fp)

  if (err != ERR_OK) {
 202f400:	e0bffa87 	ldb	r2,-22(fp)
 202f404:	10000c26 	beq	r2,zero,202f438 <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    set_errno(err_to_errno(err));
 202f408:	e0bffa87 	ldb	r2,-22(fp)
 202f40c:	1009883a 	mov	r4,r2
 202f410:	2041e900 	call	2041e90 <err_to_errno>
 202f414:	10000626 	beq	r2,zero,202f430 <lwip_bind+0x108>
 202f418:	20423b80 	call	20423b8 <__errno>
 202f41c:	1021883a 	mov	r16,r2
 202f420:	e0bffa87 	ldb	r2,-22(fp)
 202f424:	1009883a 	mov	r4,r2
 202f428:	2041e900 	call	2041e90 <err_to_errno>
 202f42c:	80800015 	stw	r2,0(r16)
    done_socket(sock);
    return -1;
 202f430:	00bfffc4 	movi	r2,-1
 202f434:	00000106 	br	202f43c <lwip_bind+0x114>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  set_errno(0);
  done_socket(sock);
  return 0;
 202f438:	0005883a 	mov	r2,zero
}
 202f43c:	e6ffff04 	addi	sp,fp,-4
 202f440:	dfc00217 	ldw	ra,8(sp)
 202f444:	df000117 	ldw	fp,4(sp)
 202f448:	dc000017 	ldw	r16,0(sp)
 202f44c:	dec00304 	addi	sp,sp,12
 202f450:	f800283a 	ret

0202f454 <lwip_close>:

int
lwip_close(int s)
{
 202f454:	defff904 	addi	sp,sp,-28
 202f458:	dfc00615 	stw	ra,24(sp)
 202f45c:	df000515 	stw	fp,20(sp)
 202f460:	dc000415 	stw	r16,16(sp)
 202f464:	df000504 	addi	fp,sp,20
 202f468:	e13ffe15 	stw	r4,-8(fp)
  struct lwip_sock *sock;
  int is_tcp = 0;
 202f46c:	e03ffb15 	stw	zero,-20(fp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
 202f470:	e13ffe17 	ldw	r4,-8(fp)
 202f474:	202ed4c0 	call	202ed4c <get_socket>
 202f478:	e0bffc15 	stw	r2,-16(fp)
  if (!sock) {
 202f47c:	e0bffc17 	ldw	r2,-16(fp)
 202f480:	1000021e 	bne	r2,zero,202f48c <lwip_close+0x38>
    return -1;
 202f484:	00bfffc4 	movi	r2,-1
 202f488:	00002106 	br	202f510 <lwip_close+0xbc>
  }

  if (sock->conn != NULL) {
 202f48c:	e0bffc17 	ldw	r2,-16(fp)
 202f490:	10800017 	ldw	r2,0(r2)
 202f494:	10000726 	beq	r2,zero,202f4b4 <lwip_close+0x60>
    is_tcp = NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP;
 202f498:	e0bffc17 	ldw	r2,-16(fp)
 202f49c:	10800017 	ldw	r2,0(r2)
 202f4a0:	10800017 	ldw	r2,0(r2)
 202f4a4:	10803c0c 	andi	r2,r2,240
 202f4a8:	10800420 	cmpeqi	r2,r2,16
 202f4ac:	10803fcc 	andi	r2,r2,255
 202f4b0:	e0bffb15 	stw	r2,-20(fp)
#if LWIP_IPV6_MLD
  /* drop all possibly joined MLD6 memberships */
  lwip_socket_drop_registered_mld6_memberships(s);
#endif /* LWIP_IPV6_MLD */

  err = netconn_prepare_delete(sock->conn);
 202f4b4:	e0bffc17 	ldw	r2,-16(fp)
 202f4b8:	10800017 	ldw	r2,0(r2)
 202f4bc:	1009883a 	mov	r4,r2
 202f4c0:	203e21c0 	call	203e21c <netconn_prepare_delete>
 202f4c4:	e0bffd05 	stb	r2,-12(fp)
  if (err != ERR_OK) {
 202f4c8:	e0bffd07 	ldb	r2,-12(fp)
 202f4cc:	10000c26 	beq	r2,zero,202f500 <lwip_close+0xac>
    set_errno(err_to_errno(err));
 202f4d0:	e0bffd07 	ldb	r2,-12(fp)
 202f4d4:	1009883a 	mov	r4,r2
 202f4d8:	2041e900 	call	2041e90 <err_to_errno>
 202f4dc:	10000626 	beq	r2,zero,202f4f8 <lwip_close+0xa4>
 202f4e0:	20423b80 	call	20423b8 <__errno>
 202f4e4:	1021883a 	mov	r16,r2
 202f4e8:	e0bffd07 	ldb	r2,-12(fp)
 202f4ec:	1009883a 	mov	r4,r2
 202f4f0:	2041e900 	call	2041e90 <err_to_errno>
 202f4f4:	80800015 	stw	r2,0(r16)
    done_socket(sock);
    return -1;
 202f4f8:	00bfffc4 	movi	r2,-1
 202f4fc:	00000406 	br	202f510 <lwip_close+0xbc>
  }

  free_socket(sock, is_tcp);
 202f500:	e17ffb17 	ldw	r5,-20(fp)
 202f504:	e13ffc17 	ldw	r4,-16(fp)
 202f508:	202efc80 	call	202efc8 <free_socket>
  set_errno(0);
  return 0;
 202f50c:	0005883a 	mov	r2,zero
}
 202f510:	e6ffff04 	addi	sp,fp,-4
 202f514:	dfc00217 	ldw	ra,8(sp)
 202f518:	df000117 	ldw	fp,4(sp)
 202f51c:	dc000017 	ldw	r16,0(sp)
 202f520:	dec00304 	addi	sp,sp,12
 202f524:	f800283a 	ret

0202f528 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
 202f528:	defff604 	addi	sp,sp,-40
 202f52c:	dfc00915 	stw	ra,36(sp)
 202f530:	df000815 	stw	fp,32(sp)
 202f534:	dc000715 	stw	r16,28(sp)
 202f538:	df000804 	addi	fp,sp,32
 202f53c:	e13ffc15 	stw	r4,-16(fp)
 202f540:	e17ffd15 	stw	r5,-12(fp)
 202f544:	e1bffe15 	stw	r6,-8(fp)
  struct lwip_sock *sock;
  err_t err;

  sock = get_socket(s);
 202f548:	e13ffc17 	ldw	r4,-16(fp)
 202f54c:	202ed4c0 	call	202ed4c <get_socket>
 202f550:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 202f554:	e0bff917 	ldw	r2,-28(fp)
 202f558:	1000021e 	bne	r2,zero,202f564 <lwip_connect+0x3c>
    return -1;
 202f55c:	00bfffc4 	movi	r2,-1
 202f560:	00004406 	br	202f674 <lwip_connect+0x14c>
    done_socket(sock);
    return -1;
  }

  LWIP_UNUSED_ARG(namelen);
  if (name->sa_family == AF_UNSPEC) {
 202f564:	e0bffd17 	ldw	r2,-12(fp)
 202f568:	10800043 	ldbu	r2,1(r2)
 202f56c:	10803fcc 	andi	r2,r2,255
 202f570:	1000061e 	bne	r2,zero,202f58c <lwip_connect+0x64>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
 202f574:	e0bff917 	ldw	r2,-28(fp)
 202f578:	10800017 	ldw	r2,0(r2)
 202f57c:	1009883a 	mov	r4,r2
 202f580:	203e5080 	call	203e508 <netconn_disconnect>
 202f584:	e0bff805 	stb	r2,-32(fp)
 202f588:	00002b06 	br	202f638 <lwip_connect+0x110>
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    /* check size, family and alignment of 'name' */
    LWIP_ERROR("lwip_connect: invalid address", IS_SOCK_ADDR_LEN_VALID(namelen) &&
 202f58c:	e0bffe17 	ldw	r2,-8(fp)
 202f590:	10800418 	cmpnei	r2,r2,16
 202f594:	10000c1e 	bne	r2,zero,202f5c8 <lwip_connect+0xa0>
 202f598:	e0bffd17 	ldw	r2,-12(fp)
 202f59c:	10800043 	ldbu	r2,1(r2)
 202f5a0:	10803fcc 	andi	r2,r2,255
 202f5a4:	10000526 	beq	r2,zero,202f5bc <lwip_connect+0x94>
 202f5a8:	e0bffd17 	ldw	r2,-12(fp)
 202f5ac:	10800043 	ldbu	r2,1(r2)
 202f5b0:	10803fcc 	andi	r2,r2,255
 202f5b4:	10800098 	cmpnei	r2,r2,2
 202f5b8:	1000031e 	bne	r2,zero,202f5c8 <lwip_connect+0xa0>
 202f5bc:	e0bffd17 	ldw	r2,-12(fp)
 202f5c0:	108000cc 	andi	r2,r2,3
 202f5c4:	10000a26 	beq	r2,zero,202f5f0 <lwip_connect+0xc8>
 202f5c8:	013ffc04 	movi	r4,-16
 202f5cc:	2041e900 	call	2041e90 <err_to_errno>
 202f5d0:	10000526 	beq	r2,zero,202f5e8 <lwip_connect+0xc0>
 202f5d4:	20423b80 	call	20423b8 <__errno>
 202f5d8:	1021883a 	mov	r16,r2
 202f5dc:	013ffc04 	movi	r4,-16
 202f5e0:	2041e900 	call	2041e90 <err_to_errno>
 202f5e4:	80800015 	stw	r2,0(r16)
 202f5e8:	00bfffc4 	movi	r2,-1
 202f5ec:	00002106 	br	202f674 <lwip_connect+0x14c>
               IS_SOCK_ADDR_TYPE_VALID_OR_UNSPEC(name) && IS_SOCK_ADDR_ALIGNED(name),
               set_errno(err_to_errno(ERR_ARG)); done_socket(sock); return -1;);

    SOCKADDR_TO_IPADDR_PORT(name, &remote_addr, remote_port);
 202f5f0:	e0bffd17 	ldw	r2,-12(fp)
 202f5f4:	10800117 	ldw	r2,4(r2)
 202f5f8:	e0bffb15 	stw	r2,-20(fp)
 202f5fc:	e0bffd17 	ldw	r2,-12(fp)
 202f600:	1080008b 	ldhu	r2,2(r2)
 202f604:	10bfffcc 	andi	r2,r2,65535
 202f608:	1009883a 	mov	r4,r2
 202f60c:	20394740 	call	2039474 <lwip_htons>
 202f610:	e0bffa0d 	sth	r2,-24(fp)
      unmap_ipv4_mapped_ipv6(ip_2_ip4(&remote_addr), ip_2_ip6(&remote_addr));
      IP_SET_TYPE_VAL(remote_addr, IPADDR_TYPE_V4);
    }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

    err = netconn_connect(sock->conn, &remote_addr, remote_port);
 202f614:	e0bff917 	ldw	r2,-28(fp)
 202f618:	10800017 	ldw	r2,0(r2)
 202f61c:	e13ffa0b 	ldhu	r4,-24(fp)
 202f620:	e0fffb04 	addi	r3,fp,-20
 202f624:	200d883a 	mov	r6,r4
 202f628:	180b883a 	mov	r5,r3
 202f62c:	1009883a 	mov	r4,r2
 202f630:	203e4800 	call	203e480 <netconn_connect>
 202f634:	e0bff805 	stb	r2,-32(fp)
  }

  if (err != ERR_OK) {
 202f638:	e0bff807 	ldb	r2,-32(fp)
 202f63c:	10000c26 	beq	r2,zero,202f670 <lwip_connect+0x148>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    set_errno(err_to_errno(err));
 202f640:	e0bff807 	ldb	r2,-32(fp)
 202f644:	1009883a 	mov	r4,r2
 202f648:	2041e900 	call	2041e90 <err_to_errno>
 202f64c:	10000626 	beq	r2,zero,202f668 <lwip_connect+0x140>
 202f650:	20423b80 	call	20423b8 <__errno>
 202f654:	1021883a 	mov	r16,r2
 202f658:	e0bff807 	ldb	r2,-32(fp)
 202f65c:	1009883a 	mov	r4,r2
 202f660:	2041e900 	call	2041e90 <err_to_errno>
 202f664:	80800015 	stw	r2,0(r16)
    done_socket(sock);
    return -1;
 202f668:	00bfffc4 	movi	r2,-1
 202f66c:	00000106 	br	202f674 <lwip_connect+0x14c>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  set_errno(0);
  done_socket(sock);
  return 0;
 202f670:	0005883a 	mov	r2,zero
}
 202f674:	e6ffff04 	addi	sp,fp,-4
 202f678:	dfc00217 	ldw	ra,8(sp)
 202f67c:	df000117 	ldw	fp,4(sp)
 202f680:	dc000017 	ldw	r16,0(sp)
 202f684:	dec00304 	addi	sp,sp,12
 202f688:	f800283a 	ret

0202f68c <lwip_listen>:
 * @param backlog (ATTENTION: needs TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
 202f68c:	defff904 	addi	sp,sp,-28
 202f690:	dfc00615 	stw	ra,24(sp)
 202f694:	df000515 	stw	fp,20(sp)
 202f698:	dc000415 	stw	r16,16(sp)
 202f69c:	df000504 	addi	fp,sp,20
 202f6a0:	e13ffd15 	stw	r4,-12(fp)
 202f6a4:	e17ffe15 	stw	r5,-8(fp)
  struct lwip_sock *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
 202f6a8:	e13ffd17 	ldw	r4,-12(fp)
 202f6ac:	202ed4c0 	call	202ed4c <get_socket>
 202f6b0:	e0bffb15 	stw	r2,-20(fp)
  if (!sock) {
 202f6b4:	e0bffb17 	ldw	r2,-20(fp)
 202f6b8:	1000021e 	bne	r2,zero,202f6c4 <lwip_listen+0x38>
    return -1;
 202f6bc:	00bfffc4 	movi	r2,-1
 202f6c0:	00002b06 	br	202f770 <lwip_listen+0xe4>
  }

  /* limit the "backlog" parameter to fit in an u8_t */
  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
 202f6c4:	e0bffe17 	ldw	r2,-8(fp)
 202f6c8:	10803fc8 	cmpgei	r2,r2,255
 202f6cc:	1000041e 	bne	r2,zero,202f6e0 <lwip_listen+0x54>
 202f6d0:	e0bffe17 	ldw	r2,-8(fp)
 202f6d4:	1000030e 	bge	r2,zero,202f6e4 <lwip_listen+0x58>
 202f6d8:	0005883a 	mov	r2,zero
 202f6dc:	00000106 	br	202f6e4 <lwip_listen+0x58>
 202f6e0:	00803fc4 	movi	r2,255
 202f6e4:	e0bffe15 	stw	r2,-8(fp)

  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
 202f6e8:	e0bffb17 	ldw	r2,-20(fp)
 202f6ec:	10c00017 	ldw	r3,0(r2)
 202f6f0:	e0bffe17 	ldw	r2,-8(fp)
 202f6f4:	10803fcc 	andi	r2,r2,255
 202f6f8:	100b883a 	mov	r5,r2
 202f6fc:	1809883a 	mov	r4,r3
 202f700:	203e5640 	call	203e564 <netconn_listen_with_backlog>
 202f704:	e0bffc05 	stb	r2,-16(fp)

  if (err != ERR_OK) {
 202f708:	e0bffc07 	ldb	r2,-16(fp)
 202f70c:	10001726 	beq	r2,zero,202f76c <lwip_listen+0xe0>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
 202f710:	e0bffb17 	ldw	r2,-20(fp)
 202f714:	10800017 	ldw	r2,0(r2)
 202f718:	10800017 	ldw	r2,0(r2)
 202f71c:	10803c0c 	andi	r2,r2,240
 202f720:	10800420 	cmpeqi	r2,r2,16
 202f724:	1000051e 	bne	r2,zero,202f73c <lwip_listen+0xb0>
      set_errno(EOPNOTSUPP);
 202f728:	20423b80 	call	20423b8 <__errno>
 202f72c:	1007883a 	mov	r3,r2
 202f730:	008017c4 	movi	r2,95
 202f734:	18800015 	stw	r2,0(r3)
 202f738:	00000a06 	br	202f764 <lwip_listen+0xd8>
    } else {
      set_errno(err_to_errno(err));
 202f73c:	e0bffc07 	ldb	r2,-16(fp)
 202f740:	1009883a 	mov	r4,r2
 202f744:	2041e900 	call	2041e90 <err_to_errno>
 202f748:	10000626 	beq	r2,zero,202f764 <lwip_listen+0xd8>
 202f74c:	20423b80 	call	20423b8 <__errno>
 202f750:	1021883a 	mov	r16,r2
 202f754:	e0bffc07 	ldb	r2,-16(fp)
 202f758:	1009883a 	mov	r4,r2
 202f75c:	2041e900 	call	2041e90 <err_to_errno>
 202f760:	80800015 	stw	r2,0(r16)
    }
    done_socket(sock);
    return -1;
 202f764:	00bfffc4 	movi	r2,-1
 202f768:	00000106 	br	202f770 <lwip_listen+0xe4>
  }

  set_errno(0);
  done_socket(sock);
  return 0;
 202f76c:	0005883a 	mov	r2,zero
}
 202f770:	e6ffff04 	addi	sp,fp,-4
 202f774:	dfc00217 	ldw	ra,8(sp)
 202f778:	df000117 	ldw	fp,4(sp)
 202f77c:	dc000017 	ldw	r16,0(sp)
 202f780:	dec00304 	addi	sp,sp,12
 202f784:	f800283a 	ret

0202f788 <lwip_recv_tcp>:
 * until "len" bytes are received or we're otherwise done.
 * Keeps sock->lastdata for peeking or partly copying.
 */
static ssize_t
lwip_recv_tcp(struct lwip_sock *sock, void *mem, size_t len, int flags)
{
 202f788:	defff404 	addi	sp,sp,-48
 202f78c:	dfc00b15 	stw	ra,44(sp)
 202f790:	df000a15 	stw	fp,40(sp)
 202f794:	dc000915 	stw	r16,36(sp)
 202f798:	df000a04 	addi	fp,sp,40
 202f79c:	e13ffb15 	stw	r4,-20(fp)
 202f7a0:	e17ffc15 	stw	r5,-16(fp)
 202f7a4:	e1bffd15 	stw	r6,-12(fp)
 202f7a8:	e1fffe15 	stw	r7,-8(fp)
  u8_t apiflags = NETCONN_NOAUTORCVD;
 202f7ac:	00800204 	movi	r2,8
 202f7b0:	e0bff605 	stb	r2,-40(fp)
  ssize_t recvd = 0;
 202f7b4:	e03ff715 	stw	zero,-36(fp)
  ssize_t recv_left = (len <= SSIZE_MAX) ? (ssize_t)len : SSIZE_MAX;
 202f7b8:	e0bffd17 	ldw	r2,-12(fp)
 202f7bc:	10000216 	blt	r2,zero,202f7c8 <lwip_recv_tcp+0x40>
 202f7c0:	e0bffd17 	ldw	r2,-12(fp)
 202f7c4:	00000206 	br	202f7d0 <lwip_recv_tcp+0x48>
 202f7c8:	00a00034 	movhi	r2,32768
 202f7cc:	10bfffc4 	addi	r2,r2,-1
 202f7d0:	e0bff815 	stw	r2,-32(fp)

  LWIP_ASSERT("no socket given", sock != NULL);
  LWIP_ASSERT("this should be checked internally", NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP);

  if (flags & MSG_DONTWAIT) {
 202f7d4:	e0bffe17 	ldw	r2,-8(fp)
 202f7d8:	1080020c 	andi	r2,r2,8
 202f7dc:	10000326 	beq	r2,zero,202f7ec <lwip_recv_tcp+0x64>
    apiflags |= NETCONN_DONTBLOCK;
 202f7e0:	e0bff603 	ldbu	r2,-40(fp)
 202f7e4:	10800114 	ori	r2,r2,4
 202f7e8:	e0bff605 	stb	r2,-40(fp)
    err_t err;
    u16_t copylen;

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: top while sock->lastdata=%p\n", (void *)sock->lastdata.pbuf));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata.pbuf) {
 202f7ec:	e0bffb17 	ldw	r2,-20(fp)
 202f7f0:	10800117 	ldw	r2,4(r2)
 202f7f4:	10000426 	beq	r2,zero,202f808 <lwip_recv_tcp+0x80>
      p = sock->lastdata.pbuf;
 202f7f8:	e0bffb17 	ldw	r2,-20(fp)
 202f7fc:	10800117 	ldw	r2,4(r2)
 202f800:	e0bffa15 	stw	r2,-24(fp)
 202f804:	00002106 	br	202f88c <lwip_recv_tcp+0x104>
    } else {
      /* No data was left from the previous operation, so we try to get
         some from the network. */
      err = netconn_recv_tcp_pbuf_flags(sock->conn, &p, apiflags);
 202f808:	e0bffb17 	ldw	r2,-20(fp)
 202f80c:	10800017 	ldw	r2,0(r2)
 202f810:	e13ff603 	ldbu	r4,-40(fp)
 202f814:	e0fffa04 	addi	r3,fp,-24
 202f818:	200d883a 	mov	r6,r4
 202f81c:	180b883a 	mov	r5,r3
 202f820:	1009883a 	mov	r4,r2
 202f824:	203ec880 	call	203ec88 <netconn_recv_tcp_pbuf_flags>
 202f828:	e0bff985 	stb	r2,-26(fp)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: netconn_recv err=%d, pbuf=%p\n",
                                  err, (void *)p));

      if (err != ERR_OK) {
 202f82c:	e0bff987 	ldb	r2,-26(fp)
 202f830:	10001326 	beq	r2,zero,202f880 <lwip_recv_tcp+0xf8>
        if (recvd > 0) {
 202f834:	e0bff717 	ldw	r2,-36(fp)
 202f838:	00805816 	blt	zero,r2,202f99c <lwip_recv_tcp+0x214>
          goto lwip_recv_tcp_done;
        }
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: p == NULL, error is \"%s\"!\n",
                                    lwip_strerr(err)));
        set_errno(err_to_errno(err));
 202f83c:	e0bff987 	ldb	r2,-26(fp)
 202f840:	1009883a 	mov	r4,r2
 202f844:	2041e900 	call	2041e90 <err_to_errno>
 202f848:	10000626 	beq	r2,zero,202f864 <lwip_recv_tcp+0xdc>
 202f84c:	20423b80 	call	20423b8 <__errno>
 202f850:	1021883a 	mov	r16,r2
 202f854:	e0bff987 	ldb	r2,-26(fp)
 202f858:	1009883a 	mov	r4,r2
 202f85c:	2041e900 	call	2041e90 <err_to_errno>
 202f860:	80800015 	stw	r2,0(r16)
        if (err == ERR_CLSD) {
 202f864:	e0bff987 	ldb	r2,-26(fp)
 202f868:	10bffc58 	cmpnei	r2,r2,-15
 202f86c:	1000021e 	bne	r2,zero,202f878 <lwip_recv_tcp+0xf0>
          return 0;
 202f870:	0005883a 	mov	r2,zero
 202f874:	00005606 	br	202f9d0 <lwip_recv_tcp+0x248>
        } else {
          return -1;
 202f878:	00bfffc4 	movi	r2,-1
 202f87c:	00005406 	br	202f9d0 <lwip_recv_tcp+0x248>
        }
      }
      LWIP_ASSERT("p != NULL", p != NULL);
      sock->lastdata.pbuf = p;
 202f880:	e0fffa17 	ldw	r3,-24(fp)
 202f884:	e0bffb17 	ldw	r2,-20(fp)
 202f888:	10c00115 	stw	r3,4(r2)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: buflen=%"U16_F" recv_left=%d off=%d\n",
                                p->tot_len, (int)recv_left, (int)recvd));

    if (recv_left > p->tot_len) {
 202f88c:	e0bffa17 	ldw	r2,-24(fp)
 202f890:	1080020b 	ldhu	r2,8(r2)
 202f894:	10ffffcc 	andi	r3,r2,65535
 202f898:	e0bff817 	ldw	r2,-32(fp)
 202f89c:	1880040e 	bge	r3,r2,202f8b0 <lwip_recv_tcp+0x128>
      copylen = p->tot_len;
 202f8a0:	e0bffa17 	ldw	r2,-24(fp)
 202f8a4:	1080020b 	ldhu	r2,8(r2)
 202f8a8:	e0bff90d 	sth	r2,-28(fp)
 202f8ac:	00000206 	br	202f8b8 <lwip_recv_tcp+0x130>
    } else {
      copylen = (u16_t)recv_left;
 202f8b0:	e0bff817 	ldw	r2,-32(fp)
 202f8b4:	e0bff90d 	sth	r2,-28(fp)
    }
    if (recvd + copylen < recvd) {
 202f8b8:	e0fff90b 	ldhu	r3,-28(fp)
 202f8bc:	e0bff717 	ldw	r2,-36(fp)
 202f8c0:	1887883a 	add	r3,r3,r2
 202f8c4:	e0bff717 	ldw	r2,-36(fp)
 202f8c8:	1880030e 	bge	r3,r2,202f8d8 <lwip_recv_tcp+0x150>
      /* overflow */
      copylen = (u16_t)(SSIZE_MAX - recvd);
 202f8cc:	e0bff717 	ldw	r2,-36(fp)
 202f8d0:	0084303a 	nor	r2,zero,r2
 202f8d4:	e0bff90d 	sth	r2,-28(fp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t *)mem + recvd, copylen, 0);
 202f8d8:	e13ffa17 	ldw	r4,-24(fp)
 202f8dc:	e0bff717 	ldw	r2,-36(fp)
 202f8e0:	e0fffc17 	ldw	r3,-16(fp)
 202f8e4:	1885883a 	add	r2,r3,r2
 202f8e8:	e0fff90b 	ldhu	r3,-28(fp)
 202f8ec:	000f883a 	mov	r7,zero
 202f8f0:	180d883a 	mov	r6,r3
 202f8f4:	100b883a 	mov	r5,r2
 202f8f8:	201d8500 	call	201d850 <pbuf_copy_partial>

    recvd += copylen;
 202f8fc:	e0bff90b 	ldhu	r2,-28(fp)
 202f900:	e0fff717 	ldw	r3,-36(fp)
 202f904:	1885883a 	add	r2,r3,r2
 202f908:	e0bff715 	stw	r2,-36(fp)

    /* TCP combines multiple pbufs for one recv */
    LWIP_ASSERT("invalid copylen, len would underflow", recv_left >= copylen);
    recv_left -= copylen;
 202f90c:	e0bff90b 	ldhu	r2,-28(fp)
 202f910:	e0fff817 	ldw	r3,-32(fp)
 202f914:	1885c83a 	sub	r2,r3,r2
 202f918:	e0bff815 	stw	r2,-32(fp)

    /* Unless we peek the incoming message... */
    if ((flags & MSG_PEEK) == 0) {
 202f91c:	e0bffe17 	ldw	r2,-8(fp)
 202f920:	1080004c 	andi	r2,r2,1
 202f924:	1000141e 	bne	r2,zero,202f978 <lwip_recv_tcp+0x1f0>
      /* ... check if there is data left in the pbuf */
      LWIP_ASSERT("invalid copylen", p->tot_len >= copylen);
      if (p->tot_len - copylen > 0) {
 202f928:	e0bffa17 	ldw	r2,-24(fp)
 202f92c:	1080020b 	ldhu	r2,8(r2)
 202f930:	10ffffcc 	andi	r3,r2,65535
 202f934:	e0bff90b 	ldhu	r2,-28(fp)
 202f938:	1885c83a 	sub	r2,r3,r2
 202f93c:	0080090e 	bge	zero,r2,202f964 <lwip_recv_tcp+0x1dc>
        /* If so, it should be saved in the sock structure for the next recv call.
           We store the pbuf but hide/free the consumed data: */
        sock->lastdata.pbuf = pbuf_free_header(p, copylen);
 202f940:	e0bffa17 	ldw	r2,-24(fp)
 202f944:	e0fff90b 	ldhu	r3,-28(fp)
 202f948:	180b883a 	mov	r5,r3
 202f94c:	1009883a 	mov	r4,r2
 202f950:	201d2380 	call	201d238 <pbuf_free_header>
 202f954:	1007883a 	mov	r3,r2
 202f958:	e0bffb17 	ldw	r2,-20(fp)
 202f95c:	10c00115 	stw	r3,4(r2)
 202f960:	00000506 	br	202f978 <lwip_recv_tcp+0x1f0>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: lastdata now pbuf=%p\n", (void *)sock->lastdata.pbuf));
      } else {
        sock->lastdata.pbuf = NULL;
 202f964:	e0bffb17 	ldw	r2,-20(fp)
 202f968:	10000115 	stw	zero,4(r2)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: deleting pbuf=%p\n", (void *)p));
        pbuf_free(p);
 202f96c:	e0bffa17 	ldw	r2,-24(fp)
 202f970:	1009883a 	mov	r4,r2
 202f974:	201d2f40 	call	201d2f4 <pbuf_free>
      }
    }
    /* once we have some data to return, only add more if we don't need to wait */
    apiflags |= NETCONN_DONTBLOCK | NETCONN_NOFIN;
 202f978:	e0bff603 	ldbu	r2,-40(fp)
 202f97c:	10800514 	ori	r2,r2,20
 202f980:	e0bff605 	stb	r2,-40(fp)
    /* @todo: do we need to support peeking more than one pbuf? */
  } while ((recv_left > 0) && !(flags & MSG_PEEK));
 202f984:	e0bff817 	ldw	r2,-32(fp)
 202f988:	0080050e 	bge	zero,r2,202f9a0 <lwip_recv_tcp+0x218>
 202f98c:	e0bffe17 	ldw	r2,-8(fp)
 202f990:	1080004c 	andi	r2,r2,1
 202f994:	103f9526 	beq	r2,zero,202f7ec <__alt_mem_mem_0+0xfd00f7ec>
 202f998:	00000106 	br	202f9a0 <lwip_recv_tcp+0x218>

      if (err != ERR_OK) {
        if (recvd > 0) {
          /* already received data, return that (this trusts in getting the same error from
             netconn layer again next time netconn_recv is called) */
          goto lwip_recv_tcp_done;
 202f99c:	0001883a 	nop
    /* once we have some data to return, only add more if we don't need to wait */
    apiflags |= NETCONN_DONTBLOCK | NETCONN_NOFIN;
    /* @todo: do we need to support peeking more than one pbuf? */
  } while ((recv_left > 0) && !(flags & MSG_PEEK));
lwip_recv_tcp_done:
  if ((recvd > 0) && !(flags & MSG_PEEK)) {
 202f9a0:	e0bff717 	ldw	r2,-36(fp)
 202f9a4:	0080090e 	bge	zero,r2,202f9cc <lwip_recv_tcp+0x244>
 202f9a8:	e0bffe17 	ldw	r2,-8(fp)
 202f9ac:	1080004c 	andi	r2,r2,1
 202f9b0:	1000061e 	bne	r2,zero,202f9cc <lwip_recv_tcp+0x244>
    /* ensure window update after copying all data */
    netconn_tcp_recvd(sock->conn, (size_t)recvd);
 202f9b4:	e0bffb17 	ldw	r2,-20(fp)
 202f9b8:	10800017 	ldw	r2,0(r2)
 202f9bc:	e0fff717 	ldw	r3,-36(fp)
 202f9c0:	180b883a 	mov	r5,r3
 202f9c4:	1009883a 	mov	r4,r2
 202f9c8:	203ea1c0 	call	203ea1c <netconn_tcp_recvd>
  }
  set_errno(0);
  return recvd;
 202f9cc:	e0bff717 	ldw	r2,-36(fp)
}
 202f9d0:	e6ffff04 	addi	sp,fp,-4
 202f9d4:	dfc00217 	ldw	ra,8(sp)
 202f9d8:	df000117 	ldw	fp,4(sp)
 202f9dc:	dc000017 	ldw	r16,0(sp)
 202f9e0:	dec00304 	addi	sp,sp,12
 202f9e4:	f800283a 	ret

0202f9e8 <lwip_sock_make_addr>:

/* Convert a netbuf's address data to struct sockaddr */
static int
lwip_sock_make_addr(struct netconn *conn, ip_addr_t *fromaddr, u16_t port,
                    struct sockaddr *from, socklen_t *fromlen)
{
 202f9e8:	defff404 	addi	sp,sp,-48
 202f9ec:	dfc00b15 	stw	ra,44(sp)
 202f9f0:	df000a15 	stw	fp,40(sp)
 202f9f4:	dc000915 	stw	r16,36(sp)
 202f9f8:	df000a04 	addi	fp,sp,40
 202f9fc:	e13ffb15 	stw	r4,-20(fp)
 202fa00:	e17ffc15 	stw	r5,-16(fp)
 202fa04:	3005883a 	mov	r2,r6
 202fa08:	e1fffe15 	stw	r7,-8(fp)
 202fa0c:	e0bffd0d 	sth	r2,-12(fp)
  int truncated = 0;
 202fa10:	e03ff615 	stw	zero,-40(fp)
    ip4_2_ipv4_mapped_ipv6(ip_2_ip6(fromaddr), ip_2_ip4(fromaddr));
    IP_SET_TYPE(fromaddr, IPADDR_TYPE_V6);
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

  IPADDR_PORT_TO_SOCKADDR(&saddr, fromaddr, port);
 202fa14:	e0bff704 	addi	r2,fp,-36
 202fa18:	00c00404 	movi	r3,16
 202fa1c:	10c00005 	stb	r3,0(r2)
 202fa20:	e0bff704 	addi	r2,fp,-36
 202fa24:	00c00084 	movi	r3,2
 202fa28:	10c00045 	stb	r3,1(r2)
 202fa2c:	e43ff704 	addi	r16,fp,-36
 202fa30:	e0bffd0b 	ldhu	r2,-12(fp)
 202fa34:	1009883a 	mov	r4,r2
 202fa38:	20394740 	call	2039474 <lwip_htons>
 202fa3c:	8080008d 	sth	r2,2(r16)
 202fa40:	e0bff704 	addi	r2,fp,-36
 202fa44:	e0fffc17 	ldw	r3,-16(fp)
 202fa48:	18c00017 	ldw	r3,0(r3)
 202fa4c:	10c00115 	stw	r3,4(r2)
 202fa50:	e0bff704 	addi	r2,fp,-36
 202fa54:	10800204 	addi	r2,r2,8
 202fa58:	01800204 	movi	r6,8
 202fa5c:	000b883a 	mov	r5,zero
 202fa60:	1009883a 	mov	r4,r2
 202fa64:	2005fa00 	call	2005fa0 <memset>
  if (*fromlen < IPADDR_SOCKADDR_GET_LEN(&saddr)) {
 202fa68:	e0800217 	ldw	r2,8(fp)
 202fa6c:	10c00017 	ldw	r3,0(r2)
 202fa70:	e0bff703 	ldbu	r2,-36(fp)
 202fa74:	10803fcc 	andi	r2,r2,255
 202fa78:	1880032e 	bgeu	r3,r2,202fa88 <lwip_sock_make_addr+0xa0>
    truncated = 1;
 202fa7c:	00800044 	movi	r2,1
 202fa80:	e0bff615 	stw	r2,-40(fp)
 202fa84:	00000906 	br	202faac <lwip_sock_make_addr+0xc4>
  } else if (*fromlen > IPADDR_SOCKADDR_GET_LEN(&saddr)) {
 202fa88:	e0800217 	ldw	r2,8(fp)
 202fa8c:	10800017 	ldw	r2,0(r2)
 202fa90:	e0fff703 	ldbu	r3,-36(fp)
 202fa94:	18c03fcc 	andi	r3,r3,255
 202fa98:	1880042e 	bgeu	r3,r2,202faac <lwip_sock_make_addr+0xc4>
    *fromlen = IPADDR_SOCKADDR_GET_LEN(&saddr);
 202fa9c:	e0bff703 	ldbu	r2,-36(fp)
 202faa0:	10c03fcc 	andi	r3,r2,255
 202faa4:	e0800217 	ldw	r2,8(fp)
 202faa8:	10c00015 	stw	r3,0(r2)
  }
  MEMCPY(from, &saddr, *fromlen);
 202faac:	e0800217 	ldw	r2,8(fp)
 202fab0:	10c00017 	ldw	r3,0(r2)
 202fab4:	e0bff704 	addi	r2,fp,-36
 202fab8:	180d883a 	mov	r6,r3
 202fabc:	100b883a 	mov	r5,r2
 202fac0:	e13ffe17 	ldw	r4,-8(fp)
 202fac4:	2005e580 	call	2005e58 <memcpy>
  return truncated;
 202fac8:	e0bff617 	ldw	r2,-40(fp)
}
 202facc:	e6ffff04 	addi	sp,fp,-4
 202fad0:	dfc00217 	ldw	ra,8(sp)
 202fad4:	df000117 	ldw	fp,4(sp)
 202fad8:	dc000017 	ldw	r16,0(sp)
 202fadc:	dec00304 	addi	sp,sp,12
 202fae0:	f800283a 	ret

0202fae4 <lwip_recv_tcp_from>:

#if LWIP_TCP
/* Helper function to get a tcp socket's remote address info */
static int
lwip_recv_tcp_from(struct lwip_sock *sock, struct sockaddr *from, socklen_t *fromlen, const char *dbg_fn, int dbg_s, ssize_t dbg_ret)
{
 202fae4:	defff704 	addi	sp,sp,-36
 202fae8:	dfc00815 	stw	ra,32(sp)
 202faec:	df000715 	stw	fp,28(sp)
 202faf0:	df000704 	addi	fp,sp,28
 202faf4:	e13ffc15 	stw	r4,-16(fp)
 202faf8:	e17ffd15 	stw	r5,-12(fp)
 202fafc:	e1bffe15 	stw	r6,-8(fp)
 202fb00:	e1ffff15 	stw	r7,-4(fp)
  if (sock == NULL) {
 202fb04:	e0bffc17 	ldw	r2,-16(fp)
 202fb08:	1000021e 	bne	r2,zero,202fb14 <lwip_recv_tcp_from+0x30>
    return 0;
 202fb0c:	0005883a 	mov	r2,zero
 202fb10:	00001e06 	br	202fb8c <lwip_recv_tcp_from+0xa8>
  LWIP_UNUSED_ARG(dbg_fn);
  LWIP_UNUSED_ARG(dbg_s);
  LWIP_UNUSED_ARG(dbg_ret);

#if !SOCKETS_DEBUG
  if (from && fromlen)
 202fb14:	e0bffd17 	ldw	r2,-12(fp)
 202fb18:	10001b26 	beq	r2,zero,202fb88 <lwip_recv_tcp_from+0xa4>
 202fb1c:	e0bffe17 	ldw	r2,-8(fp)
 202fb20:	10001926 	beq	r2,zero,202fb88 <lwip_recv_tcp_from+0xa4>
#endif /* !SOCKETS_DEBUG */
  {
    /* get remote addr/port from tcp_pcb */
    u16_t port;
    ip_addr_t tmpaddr;
    netconn_getaddr(sock->conn, &tmpaddr, &port, 0);
 202fb24:	e0bffc17 	ldw	r2,-16(fp)
 202fb28:	10800017 	ldw	r2,0(r2)
 202fb2c:	e0fffb04 	addi	r3,fp,-20
 202fb30:	000f883a 	mov	r7,zero
 202fb34:	e1bffa04 	addi	r6,fp,-24
 202fb38:	180b883a 	mov	r5,r3
 202fb3c:	1009883a 	mov	r4,r2
 202fb40:	203e2e80 	call	203e2e8 <netconn_getaddr>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("%s(%d):  addr=", dbg_fn, dbg_s));
    ip_addr_debug_print_val(SOCKETS_DEBUG, tmpaddr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, (int)dbg_ret));
    if (from && fromlen) {
 202fb44:	e0bffd17 	ldw	r2,-12(fp)
 202fb48:	10000f26 	beq	r2,zero,202fb88 <lwip_recv_tcp_from+0xa4>
 202fb4c:	e0bffe17 	ldw	r2,-8(fp)
 202fb50:	10000d26 	beq	r2,zero,202fb88 <lwip_recv_tcp_from+0xa4>
      return lwip_sock_make_addr(sock->conn, &tmpaddr, port, from, fromlen);
 202fb54:	e0bffc17 	ldw	r2,-16(fp)
 202fb58:	10c00017 	ldw	r3,0(r2)
 202fb5c:	e0bffa0b 	ldhu	r2,-24(fp)
 202fb60:	117fffcc 	andi	r5,r2,65535
 202fb64:	e13ffb04 	addi	r4,fp,-20
 202fb68:	e0bffe17 	ldw	r2,-8(fp)
 202fb6c:	d8800015 	stw	r2,0(sp)
 202fb70:	e1fffd17 	ldw	r7,-12(fp)
 202fb74:	280d883a 	mov	r6,r5
 202fb78:	200b883a 	mov	r5,r4
 202fb7c:	1809883a 	mov	r4,r3
 202fb80:	202f9e80 	call	202f9e8 <lwip_sock_make_addr>
 202fb84:	00000106 	br	202fb8c <lwip_recv_tcp_from+0xa8>
    }
  }
  return 0;
 202fb88:	0005883a 	mov	r2,zero
}
 202fb8c:	e037883a 	mov	sp,fp
 202fb90:	dfc00117 	ldw	ra,4(sp)
 202fb94:	df000017 	ldw	fp,0(sp)
 202fb98:	dec00204 	addi	sp,sp,8
 202fb9c:	f800283a 	ret

0202fba0 <lwip_recvfrom_udp_raw>:
/* Helper function to receive a netbuf from a udp or raw netconn.
 * Keeps sock->lastdata for peeking.
 */
static err_t
lwip_recvfrom_udp_raw(struct lwip_sock *sock, int flags, struct msghdr *msg, u16_t *datagram_len, int dbg_s)
{
 202fba0:	defff304 	addi	sp,sp,-52
 202fba4:	dfc00c15 	stw	ra,48(sp)
 202fba8:	df000b15 	stw	fp,44(sp)
 202fbac:	df000b04 	addi	fp,sp,44
 202fbb0:	e13ffc15 	stw	r4,-16(fp)
 202fbb4:	e17ffd15 	stw	r5,-12(fp)
 202fbb8:	e1bffe15 	stw	r6,-8(fp)
 202fbbc:	e1ffff15 	stw	r7,-4(fp)
  err_t err;
  u16_t buflen, copylen, copied;
  msg_iovlen_t i;

  LWIP_UNUSED_ARG(dbg_s);
  LWIP_ERROR("lwip_recvfrom_udp_raw: invalid arguments", (msg->msg_iov != NULL) || (msg->msg_iovlen <= 0), return ERR_ARG;);
 202fbc0:	e0bffe17 	ldw	r2,-8(fp)
 202fbc4:	10800217 	ldw	r2,8(r2)
 202fbc8:	1000051e 	bne	r2,zero,202fbe0 <lwip_recvfrom_udp_raw+0x40>
 202fbcc:	e0bffe17 	ldw	r2,-8(fp)
 202fbd0:	10800317 	ldw	r2,12(r2)
 202fbd4:	0080020e 	bge	zero,r2,202fbe0 <lwip_recvfrom_udp_raw+0x40>
 202fbd8:	00bffc04 	movi	r2,-16
 202fbdc:	00008a06 	br	202fe08 <lwip_recvfrom_udp_raw+0x268>

  if (flags & MSG_DONTWAIT) {
 202fbe0:	e0bffd17 	ldw	r2,-12(fp)
 202fbe4:	1080020c 	andi	r2,r2,8
 202fbe8:	10000326 	beq	r2,zero,202fbf8 <lwip_recvfrom_udp_raw+0x58>
    apiflags = NETCONN_DONTBLOCK;
 202fbec:	00800104 	movi	r2,4
 202fbf0:	e0bff605 	stb	r2,-40(fp)
 202fbf4:	00000106 	br	202fbfc <lwip_recvfrom_udp_raw+0x5c>
  } else {
    apiflags = 0;
 202fbf8:	e03ff605 	stb	zero,-40(fp)
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw[UDP/RAW]: top sock->lastdata=%p\n", (void *)sock->lastdata.netbuf));
  /* Check if there is data left from the last recv operation. */
  buf = sock->lastdata.netbuf;
 202fbfc:	e0bffc17 	ldw	r2,-16(fp)
 202fc00:	10800117 	ldw	r2,4(r2)
 202fc04:	e0bffb15 	stw	r2,-20(fp)
  if (buf == NULL) {
 202fc08:	e0bffb17 	ldw	r2,-20(fp)
 202fc0c:	1000101e 	bne	r2,zero,202fc50 <lwip_recvfrom_udp_raw+0xb0>
    /* No data was left from the previous operation, so we try to get
        some from the network. */
    err = netconn_recv_udp_raw_netbuf_flags(sock->conn, &buf, apiflags);
 202fc10:	e0bffc17 	ldw	r2,-16(fp)
 202fc14:	10800017 	ldw	r2,0(r2)
 202fc18:	e13ff603 	ldbu	r4,-40(fp)
 202fc1c:	e0fffb04 	addi	r3,fp,-20
 202fc20:	200d883a 	mov	r6,r4
 202fc24:	180b883a 	mov	r5,r3
 202fc28:	1009883a 	mov	r4,r2
 202fc2c:	203ed540 	call	203ed54 <netconn_recv_udp_raw_netbuf_flags>
 202fc30:	e0bff905 	stb	r2,-28(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw[UDP/RAW]: netconn_recv err=%d, netbuf=%p\n",
                                err, (void *)buf));

    if (err != ERR_OK) {
 202fc34:	e0bff907 	ldb	r2,-28(fp)
 202fc38:	10000226 	beq	r2,zero,202fc44 <lwip_recvfrom_udp_raw+0xa4>
      return err;
 202fc3c:	e0bff903 	ldbu	r2,-28(fp)
 202fc40:	00007106 	br	202fe08 <lwip_recvfrom_udp_raw+0x268>
    }
    LWIP_ASSERT("buf != NULL", buf != NULL);
    sock->lastdata.netbuf = buf;
 202fc44:	e0fffb17 	ldw	r3,-20(fp)
 202fc48:	e0bffc17 	ldw	r2,-16(fp)
 202fc4c:	10c00115 	stw	r3,4(r2)
  }
  buflen = buf->p->tot_len;
 202fc50:	e0bffb17 	ldw	r2,-20(fp)
 202fc54:	10800017 	ldw	r2,0(r2)
 202fc58:	1080020b 	ldhu	r2,8(r2)
 202fc5c:	e0bff98d 	sth	r2,-26(fp)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw: buflen=%"U16_F"\n", buflen));

  copied = 0;
 202fc60:	e03ff70d 	sth	zero,-36(fp)
  /* copy the pbuf payload into the iovs */
  for (i = 0; (i < msg->msg_iovlen) && (copied < buflen); i++) {
 202fc64:	e03ff815 	stw	zero,-32(fp)
 202fc68:	00002b06 	br	202fd18 <lwip_recvfrom_udp_raw+0x178>
    u16_t len_left = (u16_t)(buflen - copied);
 202fc6c:	e0fff98b 	ldhu	r3,-26(fp)
 202fc70:	e0bff70b 	ldhu	r2,-36(fp)
 202fc74:	1885c83a 	sub	r2,r3,r2
 202fc78:	e0bffa0d 	sth	r2,-24(fp)
    if (msg->msg_iov[i].iov_len > len_left) {
 202fc7c:	e0bffe17 	ldw	r2,-8(fp)
 202fc80:	10c00217 	ldw	r3,8(r2)
 202fc84:	e0bff817 	ldw	r2,-32(fp)
 202fc88:	100490fa 	slli	r2,r2,3
 202fc8c:	1885883a 	add	r2,r3,r2
 202fc90:	10800117 	ldw	r2,4(r2)
 202fc94:	e0fffa0b 	ldhu	r3,-24(fp)
 202fc98:	1880032e 	bgeu	r3,r2,202fca8 <lwip_recvfrom_udp_raw+0x108>
      copylen = len_left;
 202fc9c:	e0bffa0b 	ldhu	r2,-24(fp)
 202fca0:	e0bff68d 	sth	r2,-38(fp)
 202fca4:	00000706 	br	202fcc4 <lwip_recvfrom_udp_raw+0x124>
    } else {
      copylen = (u16_t)msg->msg_iov[i].iov_len;
 202fca8:	e0bffe17 	ldw	r2,-8(fp)
 202fcac:	10c00217 	ldw	r3,8(r2)
 202fcb0:	e0bff817 	ldw	r2,-32(fp)
 202fcb4:	100490fa 	slli	r2,r2,3
 202fcb8:	1885883a 	add	r2,r3,r2
 202fcbc:	10800117 	ldw	r2,4(r2)
 202fcc0:	e0bff68d 	sth	r2,-38(fp)
    }

    /* copy the contents of the received buffer into
        the supplied memory buffer */
    pbuf_copy_partial(buf->p, (u8_t *)msg->msg_iov[i].iov_base, copylen, copied);
 202fcc4:	e0bffb17 	ldw	r2,-20(fp)
 202fcc8:	11000017 	ldw	r4,0(r2)
 202fccc:	e0bffe17 	ldw	r2,-8(fp)
 202fcd0:	10c00217 	ldw	r3,8(r2)
 202fcd4:	e0bff817 	ldw	r2,-32(fp)
 202fcd8:	100490fa 	slli	r2,r2,3
 202fcdc:	1885883a 	add	r2,r3,r2
 202fce0:	10800017 	ldw	r2,0(r2)
 202fce4:	e0fff68b 	ldhu	r3,-38(fp)
 202fce8:	e17ff70b 	ldhu	r5,-36(fp)
 202fcec:	280f883a 	mov	r7,r5
 202fcf0:	180d883a 	mov	r6,r3
 202fcf4:	100b883a 	mov	r5,r2
 202fcf8:	201d8500 	call	201d850 <pbuf_copy_partial>
    copied = (u16_t)(copied + copylen);
 202fcfc:	e0fff70b 	ldhu	r3,-36(fp)
 202fd00:	e0bff68b 	ldhu	r2,-38(fp)
 202fd04:	1885883a 	add	r2,r3,r2
 202fd08:	e0bff70d 	sth	r2,-36(fp)
  buflen = buf->p->tot_len;
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw: buflen=%"U16_F"\n", buflen));

  copied = 0;
  /* copy the pbuf payload into the iovs */
  for (i = 0; (i < msg->msg_iovlen) && (copied < buflen); i++) {
 202fd0c:	e0bff817 	ldw	r2,-32(fp)
 202fd10:	10800044 	addi	r2,r2,1
 202fd14:	e0bff815 	stw	r2,-32(fp)
 202fd18:	e0bffe17 	ldw	r2,-8(fp)
 202fd1c:	10800317 	ldw	r2,12(r2)
 202fd20:	e0fff817 	ldw	r3,-32(fp)
 202fd24:	1880030e 	bge	r3,r2,202fd34 <lwip_recvfrom_udp_raw+0x194>
 202fd28:	e0fff70b 	ldhu	r3,-36(fp)
 202fd2c:	e0bff98b 	ldhu	r2,-26(fp)
 202fd30:	18bfce36 	bltu	r3,r2,202fc6c <__alt_mem_mem_0+0xfd00fc6c>
    copied = (u16_t)(copied + copylen);
  }

  /* Check to see from where the data was.*/
#if !SOCKETS_DEBUG
  if (msg->msg_name && msg->msg_namelen)
 202fd34:	e0bffe17 	ldw	r2,-8(fp)
 202fd38:	10800017 	ldw	r2,0(r2)
 202fd3c:	10001a26 	beq	r2,zero,202fda8 <lwip_recvfrom_udp_raw+0x208>
 202fd40:	e0bffe17 	ldw	r2,-8(fp)
 202fd44:	10800117 	ldw	r2,4(r2)
 202fd48:	10001726 	beq	r2,zero,202fda8 <lwip_recvfrom_udp_raw+0x208>
#endif /* !SOCKETS_DEBUG */
  {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw(%d):  addr=", dbg_s));
    ip_addr_debug_print_val(SOCKETS_DEBUG, *netbuf_fromaddr(buf));
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", netbuf_fromport(buf), copied));
    if (msg->msg_name && msg->msg_namelen) {
 202fd4c:	e0bffe17 	ldw	r2,-8(fp)
 202fd50:	10800017 	ldw	r2,0(r2)
 202fd54:	10001426 	beq	r2,zero,202fda8 <lwip_recvfrom_udp_raw+0x208>
 202fd58:	e0bffe17 	ldw	r2,-8(fp)
 202fd5c:	10800117 	ldw	r2,4(r2)
 202fd60:	10001126 	beq	r2,zero,202fda8 <lwip_recvfrom_udp_raw+0x208>
      lwip_sock_make_addr(sock->conn, netbuf_fromaddr(buf), netbuf_fromport(buf),
 202fd64:	e0bffc17 	ldw	r2,-16(fp)
 202fd68:	10c00017 	ldw	r3,0(r2)
 202fd6c:	e0bffb17 	ldw	r2,-20(fp)
 202fd70:	11000204 	addi	r4,r2,8
 202fd74:	e0bffb17 	ldw	r2,-20(fp)
 202fd78:	1080030b 	ldhu	r2,12(r2)
 202fd7c:	117fffcc 	andi	r5,r2,65535
                          (struct sockaddr *)msg->msg_name, &msg->msg_namelen);
 202fd80:	e0bffe17 	ldw	r2,-8(fp)
 202fd84:	11800017 	ldw	r6,0(r2)
  {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw(%d):  addr=", dbg_s));
    ip_addr_debug_print_val(SOCKETS_DEBUG, *netbuf_fromaddr(buf));
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", netbuf_fromport(buf), copied));
    if (msg->msg_name && msg->msg_namelen) {
      lwip_sock_make_addr(sock->conn, netbuf_fromaddr(buf), netbuf_fromport(buf),
 202fd88:	e0bffe17 	ldw	r2,-8(fp)
 202fd8c:	10800104 	addi	r2,r2,4
 202fd90:	d8800015 	stw	r2,0(sp)
 202fd94:	300f883a 	mov	r7,r6
 202fd98:	280d883a 	mov	r6,r5
 202fd9c:	200b883a 	mov	r5,r4
 202fda0:	1809883a 	mov	r4,r3
 202fda4:	202f9e80 	call	202f9e8 <lwip_sock_make_addr>
                          (struct sockaddr *)msg->msg_name, &msg->msg_namelen);
    }
  }

  /* Initialize flag output */
  msg->msg_flags = 0;
 202fda8:	e0bffe17 	ldw	r2,-8(fp)
 202fdac:	10000615 	stw	zero,24(r2)

  if (msg->msg_control) {
 202fdb0:	e0bffe17 	ldw	r2,-8(fp)
 202fdb4:	10800417 	ldw	r2,16(r2)
 202fdb8:	10000526 	beq	r2,zero,202fdd0 <lwip_recvfrom_udp_raw+0x230>
    u8_t wrote_msg = 0;
 202fdbc:	e03ffa85 	stb	zero,-22(fp)
#endif /* LWIP_IPV4 */
      }
    }
#endif /* LWIP_NETBUF_RECVINFO */

    if (!wrote_msg) {
 202fdc0:	e0bffa83 	ldbu	r2,-22(fp)
 202fdc4:	1000021e 	bne	r2,zero,202fdd0 <lwip_recvfrom_udp_raw+0x230>
      msg->msg_controllen = 0;
 202fdc8:	e0bffe17 	ldw	r2,-8(fp)
 202fdcc:	10000515 	stw	zero,20(r2)
    }
  }

  /* If we don't peek the incoming message: zero lastdata pointer and free the netbuf */
  if ((flags & MSG_PEEK) == 0) {
 202fdd0:	e0bffd17 	ldw	r2,-12(fp)
 202fdd4:	1080004c 	andi	r2,r2,1
 202fdd8:	1000051e 	bne	r2,zero,202fdf0 <lwip_recvfrom_udp_raw+0x250>
    sock->lastdata.netbuf = NULL;
 202fddc:	e0bffc17 	ldw	r2,-16(fp)
 202fde0:	10000115 	stw	zero,4(r2)
    netbuf_delete(buf);
 202fde4:	e0bffb17 	ldw	r2,-20(fp)
 202fde8:	1009883a 	mov	r4,r2
 202fdec:	2041f400 	call	2041f40 <netbuf_delete>
  }
  if (datagram_len) {
 202fdf0:	e0bfff17 	ldw	r2,-4(fp)
 202fdf4:	10000326 	beq	r2,zero,202fe04 <lwip_recvfrom_udp_raw+0x264>
    *datagram_len = buflen;
 202fdf8:	e0bfff17 	ldw	r2,-4(fp)
 202fdfc:	e0fff98b 	ldhu	r3,-26(fp)
 202fe00:	10c0000d 	sth	r3,0(r2)
  }
  return ERR_OK;
 202fe04:	0005883a 	mov	r2,zero
}
 202fe08:	e037883a 	mov	sp,fp
 202fe0c:	dfc00117 	ldw	ra,4(sp)
 202fe10:	df000017 	ldw	fp,0(sp)
 202fe14:	dec00204 	addi	sp,sp,8
 202fe18:	f800283a 	ret

0202fe1c <lwip_recvfrom>:

ssize_t
lwip_recvfrom(int s, void *mem, size_t len, int flags,
              struct sockaddr *from, socklen_t *fromlen)
{
 202fe1c:	deffeb04 	addi	sp,sp,-84
 202fe20:	dfc01415 	stw	ra,80(sp)
 202fe24:	df001315 	stw	fp,76(sp)
 202fe28:	dc001215 	stw	r16,72(sp)
 202fe2c:	df001304 	addi	fp,sp,76
 202fe30:	e13ffb15 	stw	r4,-20(fp)
 202fe34:	e17ffc15 	stw	r5,-16(fp)
 202fe38:	e1bffd15 	stw	r6,-12(fp)
 202fe3c:	e1fffe15 	stw	r7,-8(fp)
  struct lwip_sock *sock;
  ssize_t ret;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
 202fe40:	e13ffb17 	ldw	r4,-20(fp)
 202fe44:	202ed4c0 	call	202ed4c <get_socket>
 202fe48:	e0bfef15 	stw	r2,-68(fp)
  if (!sock) {
 202fe4c:	e0bfef17 	ldw	r2,-68(fp)
 202fe50:	1000021e 	bne	r2,zero,202fe5c <lwip_recvfrom+0x40>
    return -1;
 202fe54:	00bfffc4 	movi	r2,-1
 202fe58:	00005506 	br	202ffb0 <lwip_recvfrom+0x194>
  }
#if LWIP_TCP
  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 202fe5c:	e0bfef17 	ldw	r2,-68(fp)
 202fe60:	10800017 	ldw	r2,0(r2)
 202fe64:	10800017 	ldw	r2,0(r2)
 202fe68:	10803c0c 	andi	r2,r2,240
 202fe6c:	10800418 	cmpnei	r2,r2,16
 202fe70:	1000121e 	bne	r2,zero,202febc <lwip_recvfrom+0xa0>
    ret = lwip_recv_tcp(sock, mem, len, flags);
 202fe74:	e1fffe17 	ldw	r7,-8(fp)
 202fe78:	e1bffd17 	ldw	r6,-12(fp)
 202fe7c:	e17ffc17 	ldw	r5,-16(fp)
 202fe80:	e13fef17 	ldw	r4,-68(fp)
 202fe84:	202f7880 	call	202f788 <lwip_recv_tcp>
 202fe88:	e0bff015 	stw	r2,-64(fp)
    lwip_recv_tcp_from(sock, from, fromlen, "lwip_recvfrom", s, ret);
 202fe8c:	e0bff017 	ldw	r2,-64(fp)
 202fe90:	d8800115 	stw	r2,4(sp)
 202fe94:	e0bffb17 	ldw	r2,-20(fp)
 202fe98:	d8800015 	stw	r2,0(sp)
 202fe9c:	01c08134 	movhi	r7,516
 202fea0:	39dc2304 	addi	r7,r7,28812
 202fea4:	e1800317 	ldw	r6,12(fp)
 202fea8:	e1400217 	ldw	r5,8(fp)
 202feac:	e13fef17 	ldw	r4,-68(fp)
 202feb0:	202fae40 	call	202fae4 <lwip_recv_tcp_from>
    done_socket(sock);
    return ret;
 202feb4:	e0bff017 	ldw	r2,-64(fp)
 202feb8:	00003d06 	br	202ffb0 <lwip_recvfrom+0x194>
  } else
#endif
  {
    u16_t datagram_len = 0;
 202febc:	e03ff18d 	sth	zero,-58(fp)
    struct iovec vec;
    struct msghdr msg;
    err_t err;
    vec.iov_base = mem;
 202fec0:	e0bffc17 	ldw	r2,-16(fp)
 202fec4:	e0bff215 	stw	r2,-56(fp)
    vec.iov_len = len;
 202fec8:	e0bffd17 	ldw	r2,-12(fp)
 202fecc:	e0bff315 	stw	r2,-52(fp)
    msg.msg_control = NULL;
 202fed0:	e03ff815 	stw	zero,-32(fp)
    msg.msg_controllen = 0;
 202fed4:	e03ff915 	stw	zero,-28(fp)
    msg.msg_flags = 0;
 202fed8:	e03ffa15 	stw	zero,-24(fp)
    msg.msg_iov = &vec;
 202fedc:	e0bff204 	addi	r2,fp,-56
 202fee0:	e0bff615 	stw	r2,-40(fp)
    msg.msg_iovlen = 1;
 202fee4:	00800044 	movi	r2,1
 202fee8:	e0bff715 	stw	r2,-36(fp)
    msg.msg_name = from;
 202feec:	e0800217 	ldw	r2,8(fp)
 202fef0:	e0bff415 	stw	r2,-48(fp)
    msg.msg_namelen = (fromlen ? *fromlen : 0);
 202fef4:	e0800317 	ldw	r2,12(fp)
 202fef8:	10000326 	beq	r2,zero,202ff08 <lwip_recvfrom+0xec>
 202fefc:	e0800317 	ldw	r2,12(fp)
 202ff00:	10800017 	ldw	r2,0(r2)
 202ff04:	00000106 	br	202ff0c <lwip_recvfrom+0xf0>
 202ff08:	0005883a 	mov	r2,zero
 202ff0c:	e0bff515 	stw	r2,-44(fp)
    err = lwip_recvfrom_udp_raw(sock, flags, &msg, &datagram_len, s);
 202ff10:	e13ff184 	addi	r4,fp,-58
 202ff14:	e0fff404 	addi	r3,fp,-48
 202ff18:	e0bffb17 	ldw	r2,-20(fp)
 202ff1c:	d8800015 	stw	r2,0(sp)
 202ff20:	200f883a 	mov	r7,r4
 202ff24:	180d883a 	mov	r6,r3
 202ff28:	e17ffe17 	ldw	r5,-8(fp)
 202ff2c:	e13fef17 	ldw	r4,-68(fp)
 202ff30:	202fba00 	call	202fba0 <lwip_recvfrom_udp_raw>
 202ff34:	e0bff105 	stb	r2,-60(fp)
    if (err != ERR_OK) {
 202ff38:	e0bff107 	ldb	r2,-60(fp)
 202ff3c:	10000c26 	beq	r2,zero,202ff70 <lwip_recvfrom+0x154>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom[UDP/RAW](%d): buf == NULL, error is \"%s\"!\n",
                                  s, lwip_strerr(err)));
      set_errno(err_to_errno(err));
 202ff40:	e0bff107 	ldb	r2,-60(fp)
 202ff44:	1009883a 	mov	r4,r2
 202ff48:	2041e900 	call	2041e90 <err_to_errno>
 202ff4c:	10000626 	beq	r2,zero,202ff68 <lwip_recvfrom+0x14c>
 202ff50:	20423b80 	call	20423b8 <__errno>
 202ff54:	1021883a 	mov	r16,r2
 202ff58:	e0bff107 	ldb	r2,-60(fp)
 202ff5c:	1009883a 	mov	r4,r2
 202ff60:	2041e900 	call	2041e90 <err_to_errno>
 202ff64:	80800015 	stw	r2,0(r16)
      done_socket(sock);
      return -1;
 202ff68:	00bfffc4 	movi	r2,-1
 202ff6c:	00001006 	br	202ffb0 <lwip_recvfrom+0x194>
    }
    ret = (ssize_t)LWIP_MIN(LWIP_MIN(len, datagram_len), SSIZE_MAX);
 202ff70:	e0bff18b 	ldhu	r2,-58(fp)
 202ff74:	10bfffcc 	andi	r2,r2,65535
 202ff78:	e0fffd17 	ldw	r3,-12(fp)
 202ff7c:	1880012e 	bgeu	r3,r2,202ff84 <lwip_recvfrom+0x168>
 202ff80:	1805883a 	mov	r2,r3
 202ff84:	00e00034 	movhi	r3,32768
 202ff88:	10c00236 	bltu	r2,r3,202ff94 <lwip_recvfrom+0x178>
 202ff8c:	00a00034 	movhi	r2,32768
 202ff90:	10bfffc4 	addi	r2,r2,-1
 202ff94:	e0bff015 	stw	r2,-64(fp)
    if (fromlen) {
 202ff98:	e0800317 	ldw	r2,12(fp)
 202ff9c:	10000326 	beq	r2,zero,202ffac <lwip_recvfrom+0x190>
      *fromlen = msg.msg_namelen;
 202ffa0:	e0fff517 	ldw	r3,-44(fp)
 202ffa4:	e0800317 	ldw	r2,12(fp)
 202ffa8:	10c00015 	stw	r3,0(r2)
    }
  }

  set_errno(0);
  done_socket(sock);
  return ret;
 202ffac:	e0bff017 	ldw	r2,-64(fp)
}
 202ffb0:	e6ffff04 	addi	sp,fp,-4
 202ffb4:	dfc00217 	ldw	ra,8(sp)
 202ffb8:	df000117 	ldw	fp,4(sp)
 202ffbc:	dc000017 	ldw	r16,0(sp)
 202ffc0:	dec00304 	addi	sp,sp,12
 202ffc4:	f800283a 	ret

0202ffc8 <lwip_read>:

ssize_t
lwip_read(int s, void *mem, size_t len)
{
 202ffc8:	defff904 	addi	sp,sp,-28
 202ffcc:	dfc00615 	stw	ra,24(sp)
 202ffd0:	df000515 	stw	fp,20(sp)
 202ffd4:	df000504 	addi	fp,sp,20
 202ffd8:	e13ffd15 	stw	r4,-12(fp)
 202ffdc:	e17ffe15 	stw	r5,-8(fp)
 202ffe0:	e1bfff15 	stw	r6,-4(fp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
 202ffe4:	d8000115 	stw	zero,4(sp)
 202ffe8:	d8000015 	stw	zero,0(sp)
 202ffec:	000f883a 	mov	r7,zero
 202fff0:	e1bfff17 	ldw	r6,-4(fp)
 202fff4:	e17ffe17 	ldw	r5,-8(fp)
 202fff8:	e13ffd17 	ldw	r4,-12(fp)
 202fffc:	202fe1c0 	call	202fe1c <lwip_recvfrom>
}
 2030000:	e037883a 	mov	sp,fp
 2030004:	dfc00117 	ldw	ra,4(sp)
 2030008:	df000017 	ldw	fp,0(sp)
 203000c:	dec00204 	addi	sp,sp,8
 2030010:	f800283a 	ret

02030014 <lwip_readv>:

ssize_t
lwip_readv(int s, const struct iovec *iov, int iovcnt)
{
 2030014:	defff404 	addi	sp,sp,-48
 2030018:	dfc00b15 	stw	ra,44(sp)
 203001c:	df000a15 	stw	fp,40(sp)
 2030020:	df000a04 	addi	fp,sp,40
 2030024:	e13ffd15 	stw	r4,-12(fp)
 2030028:	e17ffe15 	stw	r5,-8(fp)
 203002c:	e1bfff15 	stw	r6,-4(fp)
  struct msghdr msg;

  msg.msg_name = NULL;
 2030030:	e03ff615 	stw	zero,-40(fp)
  msg.msg_namelen = 0;
 2030034:	e03ff715 	stw	zero,-36(fp)
  /* Hack: we have to cast via number to cast from 'const' pointer to non-const.
     Blame the opengroup standard for this inconsistency. */
  msg.msg_iov = LWIP_CONST_CAST(struct iovec *, iov);
 2030038:	e0bffe17 	ldw	r2,-8(fp)
 203003c:	e0bff815 	stw	r2,-32(fp)
  msg.msg_iovlen = iovcnt;
 2030040:	e0bfff17 	ldw	r2,-4(fp)
 2030044:	e0bff915 	stw	r2,-28(fp)
  msg.msg_control = NULL;
 2030048:	e03ffa15 	stw	zero,-24(fp)
  msg.msg_controllen = 0;
 203004c:	e03ffb15 	stw	zero,-20(fp)
  msg.msg_flags = 0;
 2030050:	e03ffc15 	stw	zero,-16(fp)
  return lwip_recvmsg(s, &msg, 0);
 2030054:	000d883a 	mov	r6,zero
 2030058:	e17ff604 	addi	r5,fp,-40
 203005c:	e13ffd17 	ldw	r4,-12(fp)
 2030060:	20300c80 	call	20300c8 <lwip_recvmsg>
}
 2030064:	e037883a 	mov	sp,fp
 2030068:	dfc00117 	ldw	ra,4(sp)
 203006c:	df000017 	ldw	fp,0(sp)
 2030070:	dec00204 	addi	sp,sp,8
 2030074:	f800283a 	ret

02030078 <lwip_recv>:

ssize_t
lwip_recv(int s, void *mem, size_t len, int flags)
{
 2030078:	defff804 	addi	sp,sp,-32
 203007c:	dfc00715 	stw	ra,28(sp)
 2030080:	df000615 	stw	fp,24(sp)
 2030084:	df000604 	addi	fp,sp,24
 2030088:	e13ffc15 	stw	r4,-16(fp)
 203008c:	e17ffd15 	stw	r5,-12(fp)
 2030090:	e1bffe15 	stw	r6,-8(fp)
 2030094:	e1ffff15 	stw	r7,-4(fp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
 2030098:	d8000115 	stw	zero,4(sp)
 203009c:	d8000015 	stw	zero,0(sp)
 20300a0:	e1ffff17 	ldw	r7,-4(fp)
 20300a4:	e1bffe17 	ldw	r6,-8(fp)
 20300a8:	e17ffd17 	ldw	r5,-12(fp)
 20300ac:	e13ffc17 	ldw	r4,-16(fp)
 20300b0:	202fe1c0 	call	202fe1c <lwip_recvfrom>
}
 20300b4:	e037883a 	mov	sp,fp
 20300b8:	dfc00117 	ldw	ra,4(sp)
 20300bc:	df000017 	ldw	fp,0(sp)
 20300c0:	dec00204 	addi	sp,sp,8
 20300c4:	f800283a 	ret

020300c8 <lwip_recvmsg>:

ssize_t
lwip_recvmsg(int s, struct msghdr *message, int flags)
{
 20300c8:	defff304 	addi	sp,sp,-52
 20300cc:	dfc00c15 	stw	ra,48(sp)
 20300d0:	df000b15 	stw	fp,44(sp)
 20300d4:	dc000a15 	stw	r16,40(sp)
 20300d8:	df000b04 	addi	fp,sp,44
 20300dc:	e13ffc15 	stw	r4,-16(fp)
 20300e0:	e17ffd15 	stw	r5,-12(fp)
 20300e4:	e1bffe15 	stw	r6,-8(fp)
  struct lwip_sock *sock;
  msg_iovlen_t i;
  ssize_t buflen;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvmsg(%d, message=%p, flags=0x%x)\n", s, (void *)message, flags));
  LWIP_ERROR("lwip_recvmsg: invalid message pointer", message != NULL, return ERR_ARG;);
 20300e8:	e0bffd17 	ldw	r2,-12(fp)
 20300ec:	1000021e 	bne	r2,zero,20300f8 <lwip_recvmsg+0x30>
 20300f0:	00bffc04 	movi	r2,-16
 20300f4:	0000bd06 	br	20303ec <lwip_recvmsg+0x324>
  LWIP_ERROR("lwip_recvmsg: unsupported flags", (flags & ~(MSG_PEEK|MSG_DONTWAIT)) == 0,
 20300f8:	e0fffe17 	ldw	r3,-8(fp)
 20300fc:	00bffd84 	movi	r2,-10
 2030100:	1884703a 	and	r2,r3,r2
 2030104:	10000626 	beq	r2,zero,2030120 <lwip_recvmsg+0x58>
 2030108:	20423b80 	call	20423b8 <__errno>
 203010c:	1007883a 	mov	r3,r2
 2030110:	008017c4 	movi	r2,95
 2030114:	18800015 	stw	r2,0(r3)
 2030118:	00bfffc4 	movi	r2,-1
 203011c:	0000b306 	br	20303ec <lwip_recvmsg+0x324>
             set_errno(EOPNOTSUPP); return -1;);

  if ((message->msg_iovlen <= 0) || (message->msg_iovlen > IOV_MAX)) {
 2030120:	e0bffd17 	ldw	r2,-12(fp)
 2030124:	10800317 	ldw	r2,12(r2)
 2030128:	0080040e 	bge	zero,r2,203013c <lwip_recvmsg+0x74>
 203012c:	e0bffd17 	ldw	r2,-12(fp)
 2030130:	10800317 	ldw	r2,12(r2)
 2030134:	00ffffd4 	movui	r3,65535
 2030138:	1880060e 	bge	r3,r2,2030154 <lwip_recvmsg+0x8c>
    set_errno(EMSGSIZE);
 203013c:	20423b80 	call	20423b8 <__errno>
 2030140:	1007883a 	mov	r3,r2
 2030144:	00801e84 	movi	r2,122
 2030148:	18800015 	stw	r2,0(r3)
    return -1;
 203014c:	00bfffc4 	movi	r2,-1
 2030150:	0000a606 	br	20303ec <lwip_recvmsg+0x324>
  }

  sock = get_socket(s);
 2030154:	e13ffc17 	ldw	r4,-16(fp)
 2030158:	202ed4c0 	call	202ed4c <get_socket>
 203015c:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 2030160:	e0bff917 	ldw	r2,-28(fp)
 2030164:	1000021e 	bne	r2,zero,2030170 <lwip_recvmsg+0xa8>
    return -1;
 2030168:	00bfffc4 	movi	r2,-1
 203016c:	00009f06 	br	20303ec <lwip_recvmsg+0x324>
  }

  /* check for valid vectors */
  buflen = 0;
 2030170:	e03ff715 	stw	zero,-36(fp)
  for (i = 0; i < message->msg_iovlen; i++) {
 2030174:	e03ff615 	stw	zero,-40(fp)
 2030178:	00002f06 	br	2030238 <lwip_recvmsg+0x170>
    if ((message->msg_iov[i].iov_base == NULL) || ((ssize_t)message->msg_iov[i].iov_len <= 0) ||
 203017c:	e0bffd17 	ldw	r2,-12(fp)
 2030180:	10c00217 	ldw	r3,8(r2)
 2030184:	e0bff617 	ldw	r2,-40(fp)
 2030188:	100490fa 	slli	r2,r2,3
 203018c:	1885883a 	add	r2,r3,r2
 2030190:	10800017 	ldw	r2,0(r2)
 2030194:	10001126 	beq	r2,zero,20301dc <lwip_recvmsg+0x114>
 2030198:	e0bffd17 	ldw	r2,-12(fp)
 203019c:	10c00217 	ldw	r3,8(r2)
 20301a0:	e0bff617 	ldw	r2,-40(fp)
 20301a4:	100490fa 	slli	r2,r2,3
 20301a8:	1885883a 	add	r2,r3,r2
 20301ac:	10800117 	ldw	r2,4(r2)
 20301b0:	00800a0e 	bge	zero,r2,20301dc <lwip_recvmsg+0x114>
        ((size_t)(ssize_t)message->msg_iov[i].iov_len != message->msg_iov[i].iov_len) ||
        ((ssize_t)(buflen + (ssize_t)message->msg_iov[i].iov_len) <= 0)) {
 20301b4:	e0bffd17 	ldw	r2,-12(fp)
 20301b8:	10c00217 	ldw	r3,8(r2)
 20301bc:	e0bff617 	ldw	r2,-40(fp)
 20301c0:	100490fa 	slli	r2,r2,3
 20301c4:	1885883a 	add	r2,r3,r2
 20301c8:	10800117 	ldw	r2,4(r2)
 20301cc:	1007883a 	mov	r3,r2
 20301d0:	e0bff717 	ldw	r2,-36(fp)
 20301d4:	1885883a 	add	r2,r3,r2

  /* check for valid vectors */
  buflen = 0;
  for (i = 0; i < message->msg_iovlen; i++) {
    if ((message->msg_iov[i].iov_base == NULL) || ((ssize_t)message->msg_iov[i].iov_len <= 0) ||
        ((size_t)(ssize_t)message->msg_iov[i].iov_len != message->msg_iov[i].iov_len) ||
 20301d8:	00800a16 	blt	zero,r2,2030204 <lwip_recvmsg+0x13c>
        ((ssize_t)(buflen + (ssize_t)message->msg_iov[i].iov_len) <= 0)) {
      set_errno(err_to_errno(ERR_VAL));
 20301dc:	013ffe84 	movi	r4,-6
 20301e0:	2041e900 	call	2041e90 <err_to_errno>
 20301e4:	10000526 	beq	r2,zero,20301fc <lwip_recvmsg+0x134>
 20301e8:	20423b80 	call	20423b8 <__errno>
 20301ec:	1021883a 	mov	r16,r2
 20301f0:	013ffe84 	movi	r4,-6
 20301f4:	2041e900 	call	2041e90 <err_to_errno>
 20301f8:	80800015 	stw	r2,0(r16)
      done_socket(sock);
      return -1;
 20301fc:	00bfffc4 	movi	r2,-1
 2030200:	00007a06 	br	20303ec <lwip_recvmsg+0x324>
    }
    buflen = (ssize_t)(buflen + (ssize_t)message->msg_iov[i].iov_len);
 2030204:	e0bffd17 	ldw	r2,-12(fp)
 2030208:	10c00217 	ldw	r3,8(r2)
 203020c:	e0bff617 	ldw	r2,-40(fp)
 2030210:	100490fa 	slli	r2,r2,3
 2030214:	1885883a 	add	r2,r3,r2
 2030218:	10800117 	ldw	r2,4(r2)
 203021c:	1007883a 	mov	r3,r2
 2030220:	e0bff717 	ldw	r2,-36(fp)
 2030224:	10c5883a 	add	r2,r2,r3
 2030228:	e0bff715 	stw	r2,-36(fp)
    return -1;
  }

  /* check for valid vectors */
  buflen = 0;
  for (i = 0; i < message->msg_iovlen; i++) {
 203022c:	e0bff617 	ldw	r2,-40(fp)
 2030230:	10800044 	addi	r2,r2,1
 2030234:	e0bff615 	stw	r2,-40(fp)
 2030238:	e0bffd17 	ldw	r2,-12(fp)
 203023c:	10800317 	ldw	r2,12(r2)
 2030240:	e0fff617 	ldw	r3,-40(fp)
 2030244:	18bfcd16 	blt	r3,r2,203017c <__alt_mem_mem_0+0xfd01017c>
      return -1;
    }
    buflen = (ssize_t)(buflen + (ssize_t)message->msg_iov[i].iov_len);
  }

  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 2030248:	e0bff917 	ldw	r2,-28(fp)
 203024c:	10800017 	ldw	r2,0(r2)
 2030250:	10800017 	ldw	r2,0(r2)
 2030254:	10803c0c 	andi	r2,r2,240
 2030258:	10800418 	cmpnei	r2,r2,16
 203025c:	1000401e 	bne	r2,zero,2030360 <lwip_recvmsg+0x298>
#if LWIP_TCP
    int recv_flags = flags;
 2030260:	e0bffe17 	ldw	r2,-8(fp)
 2030264:	e0bff815 	stw	r2,-32(fp)
    message->msg_flags = 0;
 2030268:	e0bffd17 	ldw	r2,-12(fp)
 203026c:	10000615 	stw	zero,24(r2)
    /* recv the data */
    buflen = 0;
 2030270:	e03ff715 	stw	zero,-36(fp)
    for (i = 0; i < message->msg_iovlen; i++) {
 2030274:	e03ff615 	stw	zero,-40(fp)
 2030278:	00003106 	br	2030340 <lwip_recvmsg+0x278>
      /* try to receive into this vector's buffer */
      ssize_t recvd_local = lwip_recv_tcp(sock, message->msg_iov[i].iov_base, message->msg_iov[i].iov_len, recv_flags);
 203027c:	e0bffd17 	ldw	r2,-12(fp)
 2030280:	10c00217 	ldw	r3,8(r2)
 2030284:	e0bff617 	ldw	r2,-40(fp)
 2030288:	100490fa 	slli	r2,r2,3
 203028c:	1885883a 	add	r2,r3,r2
 2030290:	11000017 	ldw	r4,0(r2)
 2030294:	e0bffd17 	ldw	r2,-12(fp)
 2030298:	10c00217 	ldw	r3,8(r2)
 203029c:	e0bff617 	ldw	r2,-40(fp)
 20302a0:	100490fa 	slli	r2,r2,3
 20302a4:	1885883a 	add	r2,r3,r2
 20302a8:	10800117 	ldw	r2,4(r2)
 20302ac:	e1fff817 	ldw	r7,-32(fp)
 20302b0:	100d883a 	mov	r6,r2
 20302b4:	200b883a 	mov	r5,r4
 20302b8:	e13ff917 	ldw	r4,-28(fp)
 20302bc:	202f7880 	call	202f788 <lwip_recv_tcp>
 20302c0:	e0bffa15 	stw	r2,-24(fp)
      if (recvd_local > 0) {
 20302c4:	e0bffa17 	ldw	r2,-24(fp)
 20302c8:	0080040e 	bge	zero,r2,20302dc <lwip_recvmsg+0x214>
        /* sum up received bytes */
        buflen += recvd_local;
 20302cc:	e0fff717 	ldw	r3,-36(fp)
 20302d0:	e0bffa17 	ldw	r2,-24(fp)
 20302d4:	1885883a 	add	r2,r3,r2
 20302d8:	e0bff715 	stw	r2,-36(fp)
      }
      if ((recvd_local < 0) || (recvd_local < (int)message->msg_iov[i].iov_len) ||
 20302dc:	e0bffa17 	ldw	r2,-24(fp)
 20302e0:	10000c16 	blt	r2,zero,2030314 <lwip_recvmsg+0x24c>
 20302e4:	e0bffd17 	ldw	r2,-12(fp)
 20302e8:	10c00217 	ldw	r3,8(r2)
 20302ec:	e0bff617 	ldw	r2,-40(fp)
 20302f0:	100490fa 	slli	r2,r2,3
 20302f4:	1885883a 	add	r2,r3,r2
 20302f8:	10800117 	ldw	r2,4(r2)
 20302fc:	1007883a 	mov	r3,r2
 2030300:	e0bffa17 	ldw	r2,-24(fp)
 2030304:	10c00316 	blt	r2,r3,2030314 <lwip_recvmsg+0x24c>
          (flags & MSG_PEEK)) {
 2030308:	e0bffe17 	ldw	r2,-8(fp)
 203030c:	1080004c 	andi	r2,r2,1
      ssize_t recvd_local = lwip_recv_tcp(sock, message->msg_iov[i].iov_base, message->msg_iov[i].iov_len, recv_flags);
      if (recvd_local > 0) {
        /* sum up received bytes */
        buflen += recvd_local;
      }
      if ((recvd_local < 0) || (recvd_local < (int)message->msg_iov[i].iov_len) ||
 2030310:	10000526 	beq	r2,zero,2030328 <lwip_recvmsg+0x260>
          (flags & MSG_PEEK)) {
        /* returned prematurely (or peeking, which might actually be limitated to the first iov) */
        if (buflen <= 0) {
 2030314:	e0bff717 	ldw	r2,-36(fp)
 2030318:	00800e16 	blt	zero,r2,2030354 <lwip_recvmsg+0x28c>
          /* nothing received at all, propagate the error */
          buflen = recvd_local;
 203031c:	e0bffa17 	ldw	r2,-24(fp)
 2030320:	e0bff715 	stw	r2,-36(fp)
        }
        break;
 2030324:	00000b06 	br	2030354 <lwip_recvmsg+0x28c>
      }
      /* pass MSG_DONTWAIT to lwip_recv_tcp() to prevent waiting for more data */
      recv_flags |= MSG_DONTWAIT;
 2030328:	e0bff817 	ldw	r2,-32(fp)
 203032c:	10800214 	ori	r2,r2,8
 2030330:	e0bff815 	stw	r2,-32(fp)
#if LWIP_TCP
    int recv_flags = flags;
    message->msg_flags = 0;
    /* recv the data */
    buflen = 0;
    for (i = 0; i < message->msg_iovlen; i++) {
 2030334:	e0bff617 	ldw	r2,-40(fp)
 2030338:	10800044 	addi	r2,r2,1
 203033c:	e0bff615 	stw	r2,-40(fp)
 2030340:	e0bffd17 	ldw	r2,-12(fp)
 2030344:	10800317 	ldw	r2,12(r2)
 2030348:	e0fff617 	ldw	r3,-40(fp)
 203034c:	18bfcb16 	blt	r3,r2,203027c <__alt_mem_mem_0+0xfd01027c>
 2030350:	00000106 	br	2030358 <lwip_recvmsg+0x290>
        /* returned prematurely (or peeking, which might actually be limitated to the first iov) */
        if (buflen <= 0) {
          /* nothing received at all, propagate the error */
          buflen = recvd_local;
        }
        break;
 2030354:	0001883a 	nop
      /* reset socket error since we have received something */
      set_errno(0);
    }
    /* " If the socket is connected, the msg_name and msg_namelen members shall be ignored." */
    done_socket(sock);
    return buflen;
 2030358:	e0bff717 	ldw	r2,-36(fp)
 203035c:	00002306 	br	20303ec <lwip_recvmsg+0x324>
#endif /* LWIP_TCP */
  }
  /* else, UDP and RAW NETCONNs */
#if LWIP_UDP || LWIP_RAW
  {
    u16_t datagram_len = 0;
 2030360:	e03ffb8d 	sth	zero,-18(fp)
    err_t err;
    err = lwip_recvfrom_udp_raw(sock, flags, message, &datagram_len, s);
 2030364:	e0fffb84 	addi	r3,fp,-18
 2030368:	e0bffc17 	ldw	r2,-16(fp)
 203036c:	d8800015 	stw	r2,0(sp)
 2030370:	180f883a 	mov	r7,r3
 2030374:	e1bffd17 	ldw	r6,-12(fp)
 2030378:	e17ffe17 	ldw	r5,-8(fp)
 203037c:	e13ff917 	ldw	r4,-28(fp)
 2030380:	202fba00 	call	202fba0 <lwip_recvfrom_udp_raw>
 2030384:	e0bffb05 	stb	r2,-20(fp)
    if (err != ERR_OK) {
 2030388:	e0bffb07 	ldb	r2,-20(fp)
 203038c:	10000c26 	beq	r2,zero,20303c0 <lwip_recvmsg+0x2f8>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvmsg[UDP/RAW](%d): buf == NULL, error is \"%s\"!\n",
                                  s, lwip_strerr(err)));
      set_errno(err_to_errno(err));
 2030390:	e0bffb07 	ldb	r2,-20(fp)
 2030394:	1009883a 	mov	r4,r2
 2030398:	2041e900 	call	2041e90 <err_to_errno>
 203039c:	10000626 	beq	r2,zero,20303b8 <lwip_recvmsg+0x2f0>
 20303a0:	20423b80 	call	20423b8 <__errno>
 20303a4:	1021883a 	mov	r16,r2
 20303a8:	e0bffb07 	ldb	r2,-20(fp)
 20303ac:	1009883a 	mov	r4,r2
 20303b0:	2041e900 	call	2041e90 <err_to_errno>
 20303b4:	80800015 	stw	r2,0(r16)
      done_socket(sock);
      return -1;
 20303b8:	00bfffc4 	movi	r2,-1
 20303bc:	00000b06 	br	20303ec <lwip_recvmsg+0x324>
    }
    if (datagram_len > buflen) {
 20303c0:	e0bffb8b 	ldhu	r2,-18(fp)
 20303c4:	10bfffcc 	andi	r2,r2,65535
 20303c8:	e0fff717 	ldw	r3,-36(fp)
 20303cc:	1880050e 	bge	r3,r2,20303e4 <lwip_recvmsg+0x31c>
      message->msg_flags |= MSG_TRUNC;
 20303d0:	e0bffd17 	ldw	r2,-12(fp)
 20303d4:	10800617 	ldw	r2,24(r2)
 20303d8:	10c00114 	ori	r3,r2,4
 20303dc:	e0bffd17 	ldw	r2,-12(fp)
 20303e0:	10c00615 	stw	r3,24(r2)
    }

    set_errno(0);
    done_socket(sock);
    return (int)datagram_len;
 20303e4:	e0bffb8b 	ldhu	r2,-18(fp)
 20303e8:	10bfffcc 	andi	r2,r2,65535
#else /* LWIP_UDP || LWIP_RAW */
  set_errno(err_to_errno(ERR_ARG));
  done_socket(sock);
  return -1;
#endif /* LWIP_UDP || LWIP_RAW */
}
 20303ec:	e6ffff04 	addi	sp,fp,-4
 20303f0:	dfc00217 	ldw	ra,8(sp)
 20303f4:	df000117 	ldw	fp,4(sp)
 20303f8:	dc000017 	ldw	r16,0(sp)
 20303fc:	dec00304 	addi	sp,sp,12
 2030400:	f800283a 	ret

02030404 <lwip_send>:

ssize_t
lwip_send(int s, const void *data, size_t size, int flags)
{
 2030404:	defff404 	addi	sp,sp,-48
 2030408:	dfc00b15 	stw	ra,44(sp)
 203040c:	df000a15 	stw	fp,40(sp)
 2030410:	dc000915 	stw	r16,36(sp)
 2030414:	df000a04 	addi	fp,sp,40
 2030418:	e13ffb15 	stw	r4,-20(fp)
 203041c:	e17ffc15 	stw	r5,-16(fp)
 2030420:	e1bffd15 	stw	r6,-12(fp)
 2030424:	e1fffe15 	stw	r7,-8(fp)
  size_t written;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
 2030428:	e13ffb17 	ldw	r4,-20(fp)
 203042c:	202ed4c0 	call	202ed4c <get_socket>
 2030430:	e0bff815 	stw	r2,-32(fp)
  if (!sock) {
 2030434:	e0bff817 	ldw	r2,-32(fp)
 2030438:	1000021e 	bne	r2,zero,2030444 <lwip_send+0x40>
    return -1;
 203043c:	00bfffc4 	movi	r2,-1
 2030440:	00003806 	br	2030524 <lwip_send+0x120>
  }

  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
 2030444:	e0bff817 	ldw	r2,-32(fp)
 2030448:	10800017 	ldw	r2,0(r2)
 203044c:	10800017 	ldw	r2,0(r2)
 2030450:	10803c0c 	andi	r2,r2,240
 2030454:	10800420 	cmpeqi	r2,r2,16
 2030458:	1000081e 	bne	r2,zero,203047c <lwip_send+0x78>
#if (LWIP_UDP || LWIP_RAW)
    done_socket(sock);
    return lwip_sendto(s, data, size, flags, NULL, 0);
 203045c:	d8000115 	stw	zero,4(sp)
 2030460:	d8000015 	stw	zero,0(sp)
 2030464:	e1fffe17 	ldw	r7,-8(fp)
 2030468:	e1bffd17 	ldw	r6,-12(fp)
 203046c:	e17ffc17 	ldw	r5,-16(fp)
 2030470:	e13ffb17 	ldw	r4,-20(fp)
 2030474:	20309980 	call	2030998 <lwip_sendto>
 2030478:	00002a06 	br	2030524 <lwip_send+0x120>
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = (u8_t)(NETCONN_COPY |
                       ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
 203047c:	e0bffe17 	ldw	r2,-8(fp)
 2030480:	1080040c 	andi	r2,r2,16
    done_socket(sock);
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = (u8_t)(NETCONN_COPY |
 2030484:	10000226 	beq	r2,zero,2030490 <lwip_send+0x8c>
 2030488:	008000c4 	movi	r2,3
 203048c:	00000106 	br	2030494 <lwip_send+0x90>
 2030490:	00800044 	movi	r2,1
                       ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
                       ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0));
 2030494:	e0fffe17 	ldw	r3,-8(fp)
 2030498:	18c0020c 	andi	r3,r3,8
    done_socket(sock);
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = (u8_t)(NETCONN_COPY |
 203049c:	18000226 	beq	r3,zero,20304a8 <lwip_send+0xa4>
 20304a0:	00c00104 	movi	r3,4
 20304a4:	00000106 	br	20304ac <lwip_send+0xa8>
 20304a8:	0007883a 	mov	r3,zero
 20304ac:	10c4b03a 	or	r2,r2,r3
 20304b0:	e0bff905 	stb	r2,-28(fp)
                       ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
                       ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0));
  written = 0;
 20304b4:	e03ffa15 	stw	zero,-24(fp)
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
 20304b8:	e0bff817 	ldw	r2,-32(fp)
 20304bc:	10c00017 	ldw	r3,0(r2)
 20304c0:	e13ff903 	ldbu	r4,-28(fp)
 20304c4:	e0bffa04 	addi	r2,fp,-24
 20304c8:	d8800015 	stw	r2,0(sp)
 20304cc:	200f883a 	mov	r7,r4
 20304d0:	e1bffd17 	ldw	r6,-12(fp)
 20304d4:	e17ffc17 	ldw	r5,-16(fp)
 20304d8:	1809883a 	mov	r4,r3
 20304dc:	203efb40 	call	203efb4 <netconn_write_partly>
 20304e0:	e0bff945 	stb	r2,-27(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  set_errno(err_to_errno(err));
 20304e4:	e0bff947 	ldb	r2,-27(fp)
 20304e8:	1009883a 	mov	r4,r2
 20304ec:	2041e900 	call	2041e90 <err_to_errno>
 20304f0:	10000626 	beq	r2,zero,203050c <lwip_send+0x108>
 20304f4:	20423b80 	call	20423b8 <__errno>
 20304f8:	1021883a 	mov	r16,r2
 20304fc:	e0bff947 	ldb	r2,-27(fp)
 2030500:	1009883a 	mov	r4,r2
 2030504:	2041e900 	call	2041e90 <err_to_errno>
 2030508:	80800015 	stw	r2,0(r16)
  done_socket(sock);
  /* casting 'written' to ssize_t is OK here since the netconn API limits it to SSIZE_MAX */
  return (err == ERR_OK ? (ssize_t)written : -1);
 203050c:	e0bff947 	ldb	r2,-27(fp)
 2030510:	1000021e 	bne	r2,zero,203051c <lwip_send+0x118>
 2030514:	e0bffa17 	ldw	r2,-24(fp)
 2030518:	00000206 	br	2030524 <lwip_send+0x120>
 203051c:	00bfffc4 	movi	r2,-1
 2030520:	0001883a 	nop
}
 2030524:	e6ffff04 	addi	sp,fp,-4
 2030528:	dfc00217 	ldw	ra,8(sp)
 203052c:	df000117 	ldw	fp,4(sp)
 2030530:	dc000017 	ldw	r16,0(sp)
 2030534:	dec00304 	addi	sp,sp,12
 2030538:	f800283a 	ret

0203053c <lwip_sendmsg>:

ssize_t
lwip_sendmsg(int s, const struct msghdr *msg, int flags)
{
 203053c:	deffed04 	addi	sp,sp,-76
 2030540:	dfc01215 	stw	ra,72(sp)
 2030544:	df001115 	stw	fp,68(sp)
 2030548:	dc001015 	stw	r16,64(sp)
 203054c:	df001104 	addi	fp,sp,68
 2030550:	e13ffc15 	stw	r4,-16(fp)
 2030554:	e17ffd15 	stw	r5,-12(fp)
 2030558:	e1bffe15 	stw	r6,-8(fp)
  struct lwip_sock *sock;
#if LWIP_TCP
  u8_t write_flags;
  size_t written;
#endif
  err_t err = ERR_OK;
 203055c:	e03ff005 	stb	zero,-64(fp)

  sock = get_socket(s);
 2030560:	e13ffc17 	ldw	r4,-16(fp)
 2030564:	202ed4c0 	call	202ed4c <get_socket>
 2030568:	e0bff315 	stw	r2,-52(fp)
  if (!sock) {
 203056c:	e0bff317 	ldw	r2,-52(fp)
 2030570:	1000021e 	bne	r2,zero,203057c <lwip_sendmsg+0x40>
    return -1;
 2030574:	00bfffc4 	movi	r2,-1
 2030578:	00010106 	br	2030980 <lwip_sendmsg+0x444>
  }

  LWIP_ERROR("lwip_sendmsg: invalid msghdr", msg != NULL,
 203057c:	e0bffd17 	ldw	r2,-12(fp)
 2030580:	10000a1e 	bne	r2,zero,20305ac <lwip_sendmsg+0x70>
 2030584:	013ffc04 	movi	r4,-16
 2030588:	2041e900 	call	2041e90 <err_to_errno>
 203058c:	10000526 	beq	r2,zero,20305a4 <lwip_sendmsg+0x68>
 2030590:	20423b80 	call	20423b8 <__errno>
 2030594:	1021883a 	mov	r16,r2
 2030598:	013ffc04 	movi	r4,-16
 203059c:	2041e900 	call	2041e90 <err_to_errno>
 20305a0:	80800015 	stw	r2,0(r16)
 20305a4:	00bfffc4 	movi	r2,-1
 20305a8:	0000f506 	br	2030980 <lwip_sendmsg+0x444>
             set_errno(err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
  LWIP_ERROR("lwip_sendmsg: invalid msghdr iov", msg->msg_iov != NULL,
 20305ac:	e0bffd17 	ldw	r2,-12(fp)
 20305b0:	10800217 	ldw	r2,8(r2)
 20305b4:	10000a1e 	bne	r2,zero,20305e0 <lwip_sendmsg+0xa4>
 20305b8:	013ffc04 	movi	r4,-16
 20305bc:	2041e900 	call	2041e90 <err_to_errno>
 20305c0:	10000526 	beq	r2,zero,20305d8 <lwip_sendmsg+0x9c>
 20305c4:	20423b80 	call	20423b8 <__errno>
 20305c8:	1021883a 	mov	r16,r2
 20305cc:	013ffc04 	movi	r4,-16
 20305d0:	2041e900 	call	2041e90 <err_to_errno>
 20305d4:	80800015 	stw	r2,0(r16)
 20305d8:	00bfffc4 	movi	r2,-1
 20305dc:	0000e806 	br	2030980 <lwip_sendmsg+0x444>
             set_errno(err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
  LWIP_ERROR("lwip_sendmsg: maximum iovs exceeded", (msg->msg_iovlen > 0) && (msg->msg_iovlen <= IOV_MAX),
 20305e0:	e0bffd17 	ldw	r2,-12(fp)
 20305e4:	10800317 	ldw	r2,12(r2)
 20305e8:	0080040e 	bge	zero,r2,20305fc <lwip_sendmsg+0xc0>
 20305ec:	e0bffd17 	ldw	r2,-12(fp)
 20305f0:	10800317 	ldw	r2,12(r2)
 20305f4:	00ffffd4 	movui	r3,65535
 20305f8:	1880060e 	bge	r3,r2,2030614 <lwip_sendmsg+0xd8>
 20305fc:	20423b80 	call	20423b8 <__errno>
 2030600:	1007883a 	mov	r3,r2
 2030604:	00801e84 	movi	r2,122
 2030608:	18800015 	stw	r2,0(r3)
 203060c:	00bfffc4 	movi	r2,-1
 2030610:	0000db06 	br	2030980 <lwip_sendmsg+0x444>
             set_errno(EMSGSIZE); done_socket(sock); return -1;);
  LWIP_ERROR("lwip_sendmsg: unsupported flags", (flags & ~(MSG_DONTWAIT | MSG_MORE)) == 0,
 2030614:	e0fffe17 	ldw	r3,-8(fp)
 2030618:	00bff9c4 	movi	r2,-25
 203061c:	1884703a 	and	r2,r3,r2
 2030620:	10000626 	beq	r2,zero,203063c <lwip_sendmsg+0x100>
 2030624:	20423b80 	call	20423b8 <__errno>
 2030628:	1007883a 	mov	r3,r2
 203062c:	008017c4 	movi	r2,95
 2030630:	18800015 	stw	r2,0(r3)
 2030634:	00bfffc4 	movi	r2,-1
 2030638:	0000d106 	br	2030980 <lwip_sendmsg+0x444>

  LWIP_UNUSED_ARG(msg->msg_control);
  LWIP_UNUSED_ARG(msg->msg_controllen);
  LWIP_UNUSED_ARG(msg->msg_flags);

  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 203063c:	e0bff317 	ldw	r2,-52(fp)
 2030640:	10800017 	ldw	r2,0(r2)
 2030644:	10800017 	ldw	r2,0(r2)
 2030648:	10803c0c 	andi	r2,r2,240
 203064c:	10800418 	cmpnei	r2,r2,16
 2030650:	10002f1e 	bne	r2,zero,2030710 <lwip_sendmsg+0x1d4>
#if LWIP_TCP
    write_flags = (u8_t)(NETCONN_COPY |
                         ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
 2030654:	e0bffe17 	ldw	r2,-8(fp)
 2030658:	1080040c 	andi	r2,r2,16
  LWIP_UNUSED_ARG(msg->msg_controllen);
  LWIP_UNUSED_ARG(msg->msg_flags);

  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
#if LWIP_TCP
    write_flags = (u8_t)(NETCONN_COPY |
 203065c:	10000226 	beq	r2,zero,2030668 <lwip_sendmsg+0x12c>
 2030660:	008000c4 	movi	r2,3
 2030664:	00000106 	br	203066c <lwip_sendmsg+0x130>
 2030668:	00800044 	movi	r2,1
                         ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
                         ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0));
 203066c:	e0fffe17 	ldw	r3,-8(fp)
 2030670:	18c0020c 	andi	r3,r3,8
  LWIP_UNUSED_ARG(msg->msg_controllen);
  LWIP_UNUSED_ARG(msg->msg_flags);

  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
#if LWIP_TCP
    write_flags = (u8_t)(NETCONN_COPY |
 2030674:	18000226 	beq	r3,zero,2030680 <lwip_sendmsg+0x144>
 2030678:	00c00104 	movi	r3,4
 203067c:	00000106 	br	2030684 <lwip_sendmsg+0x148>
 2030680:	0007883a 	mov	r3,zero
 2030684:	10c4b03a 	or	r2,r2,r3
 2030688:	e0bff405 	stb	r2,-48(fp)
                         ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
                         ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0));

    written = 0;
 203068c:	e03ff615 	stw	zero,-40(fp)
    err = netconn_write_vectors_partly(sock->conn, (struct netvector *)msg->msg_iov, (u16_t)msg->msg_iovlen, write_flags, &written);
 2030690:	e0bff317 	ldw	r2,-52(fp)
 2030694:	10c00017 	ldw	r3,0(r2)
 2030698:	e0bffd17 	ldw	r2,-12(fp)
 203069c:	11000217 	ldw	r4,8(r2)
 20306a0:	e0bffd17 	ldw	r2,-12(fp)
 20306a4:	10800317 	ldw	r2,12(r2)
 20306a8:	117fffcc 	andi	r5,r2,65535
 20306ac:	e1bff403 	ldbu	r6,-48(fp)
 20306b0:	e0bff604 	addi	r2,fp,-40
 20306b4:	d8800015 	stw	r2,0(sp)
 20306b8:	300f883a 	mov	r7,r6
 20306bc:	280d883a 	mov	r6,r5
 20306c0:	200b883a 	mov	r5,r4
 20306c4:	1809883a 	mov	r4,r3
 20306c8:	203f01c0 	call	203f01c <netconn_write_vectors_partly>
 20306cc:	e0bff005 	stb	r2,-64(fp)
    set_errno(err_to_errno(err));
 20306d0:	e0bff007 	ldb	r2,-64(fp)
 20306d4:	1009883a 	mov	r4,r2
 20306d8:	2041e900 	call	2041e90 <err_to_errno>
 20306dc:	10000626 	beq	r2,zero,20306f8 <lwip_sendmsg+0x1bc>
 20306e0:	20423b80 	call	20423b8 <__errno>
 20306e4:	1021883a 	mov	r16,r2
 20306e8:	e0bff007 	ldb	r2,-64(fp)
 20306ec:	1009883a 	mov	r4,r2
 20306f0:	2041e900 	call	2041e90 <err_to_errno>
 20306f4:	80800015 	stw	r2,0(r16)
    done_socket(sock);
    /* casting 'written' to ssize_t is OK here since the netconn API limits it to SSIZE_MAX */
    return (err == ERR_OK ? (ssize_t)written : -1);
 20306f8:	e0bff007 	ldb	r2,-64(fp)
 20306fc:	1000021e 	bne	r2,zero,2030708 <lwip_sendmsg+0x1cc>
 2030700:	e0bff617 	ldw	r2,-40(fp)
 2030704:	00009e06 	br	2030980 <lwip_sendmsg+0x444>
 2030708:	00bfffc4 	movi	r2,-1
 203070c:	00009c06 	br	2030980 <lwip_sendmsg+0x444>
  /* else, UDP and RAW NETCONNs */
#if LWIP_UDP || LWIP_RAW
  {
    struct netbuf chain_buf;
    msg_iovlen_t i;
    ssize_t size = 0;
 2030710:	e03ff215 	stw	zero,-56(fp)

    LWIP_UNUSED_ARG(flags);
    LWIP_ERROR("lwip_sendmsg: invalid msghdr name", (((msg->msg_name == NULL) && (msg->msg_namelen == 0)) ||
 2030714:	e0bffd17 	ldw	r2,-12(fp)
 2030718:	10800017 	ldw	r2,0(r2)
 203071c:	1000031e 	bne	r2,zero,203072c <lwip_sendmsg+0x1f0>
 2030720:	e0bffd17 	ldw	r2,-12(fp)
 2030724:	10800117 	ldw	r2,4(r2)
 2030728:	10000e26 	beq	r2,zero,2030764 <lwip_sendmsg+0x228>
 203072c:	e0bffd17 	ldw	r2,-12(fp)
 2030730:	10800117 	ldw	r2,4(r2)
 2030734:	10800420 	cmpeqi	r2,r2,16
 2030738:	10000a1e 	bne	r2,zero,2030764 <lwip_sendmsg+0x228>
 203073c:	013ffc04 	movi	r4,-16
 2030740:	2041e900 	call	2041e90 <err_to_errno>
 2030744:	10000526 	beq	r2,zero,203075c <lwip_sendmsg+0x220>
 2030748:	20423b80 	call	20423b8 <__errno>
 203074c:	1021883a 	mov	r16,r2
 2030750:	013ffc04 	movi	r4,-16
 2030754:	2041e900 	call	2041e90 <err_to_errno>
 2030758:	80800015 	stw	r2,0(r16)
 203075c:	00bfffc4 	movi	r2,-1
 2030760:	00008706 	br	2030980 <lwip_sendmsg+0x444>
               IS_SOCK_ADDR_LEN_VALID(msg->msg_namelen)),
               set_errno(err_to_errno(ERR_ARG)); done_socket(sock); return -1;);

    /* initialize chain buffer with destination */
    memset(&chain_buf, 0, sizeof(struct netbuf));
 2030764:	e0bff704 	addi	r2,fp,-36
 2030768:	01800504 	movi	r6,20
 203076c:	000b883a 	mov	r5,zero
 2030770:	1009883a 	mov	r4,r2
 2030774:	2005fa00 	call	2005fa0 <memset>
    if (msg->msg_name) {
 2030778:	e0bffd17 	ldw	r2,-12(fp)
 203077c:	10800017 	ldw	r2,0(r2)
 2030780:	10000d26 	beq	r2,zero,20307b8 <lwip_sendmsg+0x27c>
      u16_t remote_port;
      SOCKADDR_TO_IPADDR_PORT((const struct sockaddr *)msg->msg_name, &chain_buf.addr, remote_port);
 2030784:	e0bffd17 	ldw	r2,-12(fp)
 2030788:	10800017 	ldw	r2,0(r2)
 203078c:	10800117 	ldw	r2,4(r2)
 2030790:	e0bff915 	stw	r2,-28(fp)
 2030794:	e0bffd17 	ldw	r2,-12(fp)
 2030798:	10800017 	ldw	r2,0(r2)
 203079c:	1080008b 	ldhu	r2,2(r2)
 20307a0:	10bfffcc 	andi	r2,r2,65535
 20307a4:	1009883a 	mov	r4,r2
 20307a8:	20394740 	call	2039474 <lwip_htons>
 20307ac:	e0bff48d 	sth	r2,-46(fp)
      netbuf_fromport(&chain_buf) = remote_port;
 20307b0:	e0bff48b 	ldhu	r2,-46(fp)
 20307b4:	e0bffa0d 	sth	r2,-24(fp)
      err = ERR_OK;
    }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
    /* create a chained netbuf from the IO vectors. NOTE: we assemble a pbuf chain
       manually to avoid having to allocate, chain, and delete a netbuf for each iov */
    for (i = 0; i < msg->msg_iovlen; i++) {
 20307b8:	e03ff115 	stw	zero,-60(fp)
 20307bc:	00004106 	br	20308c4 <lwip_sendmsg+0x388>
      struct pbuf *p;
      if (msg->msg_iov[i].iov_len > 0xFFFF) {
 20307c0:	e0bffd17 	ldw	r2,-12(fp)
 20307c4:	10c00217 	ldw	r3,8(r2)
 20307c8:	e0bff117 	ldw	r2,-60(fp)
 20307cc:	100490fa 	slli	r2,r2,3
 20307d0:	1885883a 	add	r2,r3,r2
 20307d4:	10800117 	ldw	r2,4(r2)
 20307d8:	00ffffd4 	movui	r3,65535
 20307dc:	18805f36 	bltu	r3,r2,203095c <lwip_sendmsg+0x420>
        /* overflow */
        goto sendmsg_emsgsize;
      }
      p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
 20307e0:	01801044 	movi	r6,65
 20307e4:	000b883a 	mov	r5,zero
 20307e8:	01000e04 	movi	r4,56
 20307ec:	201c9740 	call	201c974 <pbuf_alloc>
 20307f0:	e0bff515 	stw	r2,-44(fp)
      if (p == NULL) {
 20307f4:	e0bff517 	ldw	r2,-44(fp)
 20307f8:	1000031e 	bne	r2,zero,2030808 <lwip_sendmsg+0x2cc>
        err = ERR_MEM; /* let netbuf_delete() cleanup chain_buf */
 20307fc:	00bfffc4 	movi	r2,-1
 2030800:	e0bff005 	stb	r2,-64(fp)
        break;
 2030804:	00003306 	br	20308d4 <lwip_sendmsg+0x398>
      }
      p->payload = msg->msg_iov[i].iov_base;
 2030808:	e0bffd17 	ldw	r2,-12(fp)
 203080c:	10c00217 	ldw	r3,8(r2)
 2030810:	e0bff117 	ldw	r2,-60(fp)
 2030814:	100490fa 	slli	r2,r2,3
 2030818:	1885883a 	add	r2,r3,r2
 203081c:	10c00017 	ldw	r3,0(r2)
 2030820:	e0bff517 	ldw	r2,-44(fp)
 2030824:	10c00115 	stw	r3,4(r2)
      p->len = p->tot_len = (u16_t)msg->msg_iov[i].iov_len;
 2030828:	e0bffd17 	ldw	r2,-12(fp)
 203082c:	10c00217 	ldw	r3,8(r2)
 2030830:	e0bff117 	ldw	r2,-60(fp)
 2030834:	100490fa 	slli	r2,r2,3
 2030838:	1885883a 	add	r2,r3,r2
 203083c:	10800117 	ldw	r2,4(r2)
 2030840:	1007883a 	mov	r3,r2
 2030844:	e0bff517 	ldw	r2,-44(fp)
 2030848:	10c0020d 	sth	r3,8(r2)
 203084c:	e0bff517 	ldw	r2,-44(fp)
 2030850:	10c0020b 	ldhu	r3,8(r2)
 2030854:	e0bff517 	ldw	r2,-44(fp)
 2030858:	10c0028d 	sth	r3,10(r2)
      /* netbuf empty, add new pbuf */
      if (chain_buf.p == NULL) {
 203085c:	e0bff717 	ldw	r2,-36(fp)
 2030860:	1000051e 	bne	r2,zero,2030878 <lwip_sendmsg+0x33c>
        chain_buf.p = chain_buf.ptr = p;
 2030864:	e0bff517 	ldw	r2,-44(fp)
 2030868:	e0bff815 	stw	r2,-32(fp)
 203086c:	e0bff817 	ldw	r2,-32(fp)
 2030870:	e0bff715 	stw	r2,-36(fp)
 2030874:	00001006 	br	20308b8 <lwip_sendmsg+0x37c>
        /* add pbuf to existing pbuf chain */
      } else {
        if (chain_buf.p->tot_len + p->len > 0xffff) {
 2030878:	e0bff717 	ldw	r2,-36(fp)
 203087c:	1080020b 	ldhu	r2,8(r2)
 2030880:	10ffffcc 	andi	r3,r2,65535
 2030884:	e0bff517 	ldw	r2,-44(fp)
 2030888:	1080028b 	ldhu	r2,10(r2)
 203088c:	10bfffcc 	andi	r2,r2,65535
 2030890:	1885883a 	add	r2,r3,r2
 2030894:	00ffffd4 	movui	r3,65535
 2030898:	1880030e 	bge	r3,r2,20308a8 <lwip_sendmsg+0x36c>
          /* overflow */
          pbuf_free(p);
 203089c:	e13ff517 	ldw	r4,-44(fp)
 20308a0:	201d2f40 	call	201d2f4 <pbuf_free>
          goto sendmsg_emsgsize;
 20308a4:	00002e06 	br	2030960 <lwip_sendmsg+0x424>
        }
        pbuf_cat(chain_buf.p, p);
 20308a8:	e0bff717 	ldw	r2,-36(fp)
 20308ac:	e17ff517 	ldw	r5,-44(fp)
 20308b0:	1009883a 	mov	r4,r2
 20308b4:	201d4d40 	call	201d4d4 <pbuf_cat>
      err = ERR_OK;
    }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
    /* create a chained netbuf from the IO vectors. NOTE: we assemble a pbuf chain
       manually to avoid having to allocate, chain, and delete a netbuf for each iov */
    for (i = 0; i < msg->msg_iovlen; i++) {
 20308b8:	e0bff117 	ldw	r2,-60(fp)
 20308bc:	10800044 	addi	r2,r2,1
 20308c0:	e0bff115 	stw	r2,-60(fp)
 20308c4:	e0bffd17 	ldw	r2,-12(fp)
 20308c8:	10800317 	ldw	r2,12(r2)
 20308cc:	e0fff117 	ldw	r3,-60(fp)
 20308d0:	18bfbb16 	blt	r3,r2,20307c0 <__alt_mem_mem_0+0xfd0107c0>
        }
        pbuf_cat(chain_buf.p, p);
      }
    }
    /* save size of total chain */
    if (err == ERR_OK) {
 20308d4:	e0bff007 	ldb	r2,-64(fp)
 20308d8:	1000041e 	bne	r2,zero,20308ec <lwip_sendmsg+0x3b0>
      size = netbuf_len(&chain_buf);
 20308dc:	e0bff717 	ldw	r2,-36(fp)
 20308e0:	1080020b 	ldhu	r2,8(r2)
 20308e4:	10bfffcc 	andi	r2,r2,65535
 20308e8:	e0bff215 	stw	r2,-56(fp)
    }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

    if (err == ERR_OK) {
 20308ec:	e0bff007 	ldb	r2,-64(fp)
 20308f0:	1000071e 	bne	r2,zero,2030910 <lwip_sendmsg+0x3d4>
        IP_SET_TYPE_VAL(chain_buf.addr, IPADDR_TYPE_V4);
      }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

      /* send the data */
      err = netconn_send(sock->conn, &chain_buf);
 20308f4:	e0bff317 	ldw	r2,-52(fp)
 20308f8:	10800017 	ldw	r2,0(r2)
 20308fc:	e0fff704 	addi	r3,fp,-36
 2030900:	180b883a 	mov	r5,r3
 2030904:	1009883a 	mov	r4,r2
 2030908:	203ef4c0 	call	203ef4c <netconn_send>
 203090c:	e0bff005 	stb	r2,-64(fp)
    }

    /* deallocated the buffer */
    netbuf_free(&chain_buf);
 2030910:	e0bff704 	addi	r2,fp,-36
 2030914:	1009883a 	mov	r4,r2
 2030918:	20420600 	call	2042060 <netbuf_free>

    set_errno(err_to_errno(err));
 203091c:	e0bff007 	ldb	r2,-64(fp)
 2030920:	1009883a 	mov	r4,r2
 2030924:	2041e900 	call	2041e90 <err_to_errno>
 2030928:	10000626 	beq	r2,zero,2030944 <lwip_sendmsg+0x408>
 203092c:	20423b80 	call	20423b8 <__errno>
 2030930:	1021883a 	mov	r16,r2
 2030934:	e0bff007 	ldb	r2,-64(fp)
 2030938:	1009883a 	mov	r4,r2
 203093c:	2041e900 	call	2041e90 <err_to_errno>
 2030940:	80800015 	stw	r2,0(r16)
    done_socket(sock);
    return (err == ERR_OK ? size : -1);
 2030944:	e0bff007 	ldb	r2,-64(fp)
 2030948:	1000021e 	bne	r2,zero,2030954 <lwip_sendmsg+0x418>
 203094c:	e0bff217 	ldw	r2,-56(fp)
 2030950:	00000b06 	br	2030980 <lwip_sendmsg+0x444>
 2030954:	00bfffc4 	movi	r2,-1
 2030958:	00000906 	br	2030980 <lwip_sendmsg+0x444>
       manually to avoid having to allocate, chain, and delete a netbuf for each iov */
    for (i = 0; i < msg->msg_iovlen; i++) {
      struct pbuf *p;
      if (msg->msg_iov[i].iov_len > 0xFFFF) {
        /* overflow */
        goto sendmsg_emsgsize;
 203095c:	0001883a 	nop

    set_errno(err_to_errno(err));
    done_socket(sock);
    return (err == ERR_OK ? size : -1);
sendmsg_emsgsize:
    set_errno(EMSGSIZE);
 2030960:	20423b80 	call	20423b8 <__errno>
 2030964:	1007883a 	mov	r3,r2
 2030968:	00801e84 	movi	r2,122
 203096c:	18800015 	stw	r2,0(r3)
    netbuf_free(&chain_buf);
 2030970:	e0bff704 	addi	r2,fp,-36
 2030974:	1009883a 	mov	r4,r2
 2030978:	20420600 	call	2042060 <netbuf_free>
    done_socket(sock);
    return -1;
 203097c:	00bfffc4 	movi	r2,-1
#else /* LWIP_UDP || LWIP_RAW */
  set_errno(err_to_errno(ERR_ARG));
  done_socket(sock);
  return -1;
#endif /* LWIP_UDP || LWIP_RAW */
}
 2030980:	e6ffff04 	addi	sp,fp,-4
 2030984:	dfc00217 	ldw	ra,8(sp)
 2030988:	df000117 	ldw	fp,4(sp)
 203098c:	dc000017 	ldw	r16,0(sp)
 2030990:	dec00304 	addi	sp,sp,12
 2030994:	f800283a 	ret

02030998 <lwip_sendto>:

ssize_t
lwip_sendto(int s, const void *data, size_t size, int flags,
            const struct sockaddr *to, socklen_t tolen)
{
 2030998:	defff104 	addi	sp,sp,-60
 203099c:	dfc00e15 	stw	ra,56(sp)
 20309a0:	df000d15 	stw	fp,52(sp)
 20309a4:	dc000c15 	stw	r16,48(sp)
 20309a8:	df000d04 	addi	fp,sp,52
 20309ac:	e13ffb15 	stw	r4,-20(fp)
 20309b0:	e17ffc15 	stw	r5,-16(fp)
 20309b4:	e1bffd15 	stw	r6,-12(fp)
 20309b8:	e1fffe15 	stw	r7,-8(fp)
  err_t err;
  u16_t short_size;
  u16_t remote_port;
  struct netbuf buf;

  sock = get_socket(s);
 20309bc:	e13ffb17 	ldw	r4,-20(fp)
 20309c0:	202ed4c0 	call	202ed4c <get_socket>
 20309c4:	e0bff415 	stw	r2,-48(fp)
  if (!sock) {
 20309c8:	e0bff417 	ldw	r2,-48(fp)
 20309cc:	1000021e 	bne	r2,zero,20309d8 <lwip_sendto+0x40>
    return -1;
 20309d0:	00bfffc4 	movi	r2,-1
 20309d4:	00006906 	br	2030b7c <lwip_sendto+0x1e4>
  }

  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 20309d8:	e0bff417 	ldw	r2,-48(fp)
 20309dc:	10800017 	ldw	r2,0(r2)
 20309e0:	10800017 	ldw	r2,0(r2)
 20309e4:	10803c0c 	andi	r2,r2,240
 20309e8:	10800418 	cmpnei	r2,r2,16
 20309ec:	1000061e 	bne	r2,zero,2030a08 <lwip_sendto+0x70>
#if LWIP_TCP
    done_socket(sock);
    return lwip_send(s, data, size, flags);
 20309f0:	e1fffe17 	ldw	r7,-8(fp)
 20309f4:	e1bffd17 	ldw	r6,-12(fp)
 20309f8:	e17ffc17 	ldw	r5,-16(fp)
 20309fc:	e13ffb17 	ldw	r4,-20(fp)
 2030a00:	20304040 	call	2030404 <lwip_send>
 2030a04:	00005d06 	br	2030b7c <lwip_sendto+0x1e4>
    done_socket(sock);
    return -1;
#endif /* LWIP_TCP */
  }

  if (size > LWIP_MIN(0xFFFF, SSIZE_MAX)) {
 2030a08:	e0bffd17 	ldw	r2,-12(fp)
 2030a0c:	00ffffd4 	movui	r3,65535
 2030a10:	1880062e 	bgeu	r3,r2,2030a2c <lwip_sendto+0x94>
    /* cannot fit into one datagram (at least for us) */
    set_errno(EMSGSIZE);
 2030a14:	20423b80 	call	20423b8 <__errno>
 2030a18:	1007883a 	mov	r3,r2
 2030a1c:	00801e84 	movi	r2,122
 2030a20:	18800015 	stw	r2,0(r3)
    done_socket(sock);
    return -1;
 2030a24:	00bfffc4 	movi	r2,-1
 2030a28:	00005406 	br	2030b7c <lwip_sendto+0x1e4>
  }
  short_size = (u16_t)size;
 2030a2c:	e0bffd17 	ldw	r2,-12(fp)
 2030a30:	e0bff50d 	sth	r2,-44(fp)
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
 2030a34:	e0800217 	ldw	r2,8(fp)
 2030a38:	1000021e 	bne	r2,zero,2030a44 <lwip_sendto+0xac>
 2030a3c:	e0800317 	ldw	r2,12(fp)
 2030a40:	10001726 	beq	r2,zero,2030aa0 <lwip_sendto+0x108>
 2030a44:	e0800317 	ldw	r2,12(fp)
 2030a48:	10800418 	cmpnei	r2,r2,16
 2030a4c:	10000a1e 	bne	r2,zero,2030a78 <lwip_sendto+0xe0>
 2030a50:	e0800217 	ldw	r2,8(fp)
 2030a54:	10000826 	beq	r2,zero,2030a78 <lwip_sendto+0xe0>
 2030a58:	e0800217 	ldw	r2,8(fp)
 2030a5c:	10800043 	ldbu	r2,1(r2)
 2030a60:	10803fcc 	andi	r2,r2,255
 2030a64:	10800098 	cmpnei	r2,r2,2
 2030a68:	1000031e 	bne	r2,zero,2030a78 <lwip_sendto+0xe0>
 2030a6c:	e0800217 	ldw	r2,8(fp)
 2030a70:	108000cc 	andi	r2,r2,3
 2030a74:	10000a26 	beq	r2,zero,2030aa0 <lwip_sendto+0x108>
 2030a78:	013ffc04 	movi	r4,-16
 2030a7c:	2041e900 	call	2041e90 <err_to_errno>
 2030a80:	10000526 	beq	r2,zero,2030a98 <lwip_sendto+0x100>
 2030a84:	20423b80 	call	20423b8 <__errno>
 2030a88:	1021883a 	mov	r16,r2
 2030a8c:	013ffc04 	movi	r4,-16
 2030a90:	2041e900 	call	2041e90 <err_to_errno>
 2030a94:	80800015 	stw	r2,0(r16)
 2030a98:	00bfffc4 	movi	r2,-1
 2030a9c:	00003706 	br	2030b7c <lwip_sendto+0x1e4>
              ((to != NULL) && (IS_SOCK_ADDR_TYPE_VALID(to) && IS_SOCK_ADDR_ALIGNED(to))))),
             set_errno(err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
  LWIP_UNUSED_ARG(tolen);

  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
 2030aa0:	e03ff715 	stw	zero,-36(fp)
 2030aa4:	e0bff717 	ldw	r2,-36(fp)
 2030aa8:	e0bff615 	stw	r2,-40(fp)
#if LWIP_CHECKSUM_ON_COPY
  buf.flags = 0;
 2030aac:	e03ff985 	stb	zero,-26(fp)
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
 2030ab0:	e0800217 	ldw	r2,8(fp)
 2030ab4:	10000a26 	beq	r2,zero,2030ae0 <lwip_sendto+0x148>
    SOCKADDR_TO_IPADDR_PORT(to, &buf.addr, remote_port);
 2030ab8:	e0800217 	ldw	r2,8(fp)
 2030abc:	10800117 	ldw	r2,4(r2)
 2030ac0:	e0bff815 	stw	r2,-32(fp)
 2030ac4:	e0800217 	ldw	r2,8(fp)
 2030ac8:	1080008b 	ldhu	r2,2(r2)
 2030acc:	10bfffcc 	andi	r2,r2,65535
 2030ad0:	1009883a 	mov	r4,r2
 2030ad4:	20394740 	call	2039474 <lwip_htons>
 2030ad8:	e0bff38d 	sth	r2,-50(fp)
 2030adc:	00000206 	br	2030ae8 <lwip_sendto+0x150>
  } else {
    remote_port = 0;
 2030ae0:	e03ff38d 	sth	zero,-50(fp)
    ip_addr_set_any(NETCONNTYPE_ISIPV6(netconn_type(sock->conn)), &buf.addr);
 2030ae4:	e03ff815 	stw	zero,-32(fp)
  }
  netbuf_fromport(&buf) = remote_port;
 2030ae8:	e0bff38b 	ldhu	r2,-50(fp)
 2030aec:	e0bff90d 	sth	r2,-28(fp)
      MEMCPY(buf.p->payload, data, short_size);
    }
    err = ERR_OK;
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
 2030af0:	e0fff50b 	ldhu	r3,-44(fp)
 2030af4:	e0bff604 	addi	r2,fp,-40
 2030af8:	180d883a 	mov	r6,r3
 2030afc:	e17ffc17 	ldw	r5,-16(fp)
 2030b00:	1009883a 	mov	r4,r2
 2030b04:	20420dc0 	call	20420dc <netbuf_ref>
 2030b08:	e0bff305 	stb	r2,-52(fp)
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (err == ERR_OK) {
 2030b0c:	e0bff307 	ldb	r2,-52(fp)
 2030b10:	1000071e 	bne	r2,zero,2030b30 <lwip_sendto+0x198>
      IP_SET_TYPE_VAL(buf.addr, IPADDR_TYPE_V4);
    }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

    /* send the data */
    err = netconn_send(sock->conn, &buf);
 2030b14:	e0bff417 	ldw	r2,-48(fp)
 2030b18:	10800017 	ldw	r2,0(r2)
 2030b1c:	e0fff604 	addi	r3,fp,-40
 2030b20:	180b883a 	mov	r5,r3
 2030b24:	1009883a 	mov	r4,r2
 2030b28:	203ef4c0 	call	203ef4c <netconn_send>
 2030b2c:	e0bff305 	stb	r2,-52(fp)
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
 2030b30:	e0bff604 	addi	r2,fp,-40
 2030b34:	1009883a 	mov	r4,r2
 2030b38:	20420600 	call	2042060 <netbuf_free>

  set_errno(err_to_errno(err));
 2030b3c:	e0bff307 	ldb	r2,-52(fp)
 2030b40:	1009883a 	mov	r4,r2
 2030b44:	2041e900 	call	2041e90 <err_to_errno>
 2030b48:	10000626 	beq	r2,zero,2030b64 <lwip_sendto+0x1cc>
 2030b4c:	20423b80 	call	20423b8 <__errno>
 2030b50:	1021883a 	mov	r16,r2
 2030b54:	e0bff307 	ldb	r2,-52(fp)
 2030b58:	1009883a 	mov	r4,r2
 2030b5c:	2041e900 	call	2041e90 <err_to_errno>
 2030b60:	80800015 	stw	r2,0(r16)
  done_socket(sock);
  return (err == ERR_OK ? short_size : -1);
 2030b64:	e0bff307 	ldb	r2,-52(fp)
 2030b68:	1000021e 	bne	r2,zero,2030b74 <lwip_sendto+0x1dc>
 2030b6c:	e0bff50b 	ldhu	r2,-44(fp)
 2030b70:	00000206 	br	2030b7c <lwip_sendto+0x1e4>
 2030b74:	00bfffc4 	movi	r2,-1
 2030b78:	0001883a 	nop
}
 2030b7c:	e6ffff04 	addi	sp,fp,-4
 2030b80:	dfc00217 	ldw	ra,8(sp)
 2030b84:	df000117 	ldw	fp,4(sp)
 2030b88:	dc000017 	ldw	r16,0(sp)
 2030b8c:	dec00304 	addi	sp,sp,12
 2030b90:	f800283a 	ret

02030b94 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
 2030b94:	defff904 	addi	sp,sp,-28
 2030b98:	dfc00615 	stw	ra,24(sp)
 2030b9c:	df000515 	stw	fp,20(sp)
 2030ba0:	df000504 	addi	fp,sp,20
 2030ba4:	e13ffd15 	stw	r4,-12(fp)
 2030ba8:	e17ffe15 	stw	r5,-8(fp)
 2030bac:	e1bfff15 	stw	r6,-4(fp)
  int i;

  LWIP_UNUSED_ARG(domain); /* @todo: check this */

  /* create a netconn */
  switch (type) {
 2030bb0:	e0bffe17 	ldw	r2,-8(fp)
 2030bb4:	10c000a0 	cmpeqi	r3,r2,2
 2030bb8:	18000e1e 	bne	r3,zero,2030bf4 <lwip_socket+0x60>
 2030bbc:	10c000e0 	cmpeqi	r3,r2,3
 2030bc0:	1800031e 	bne	r3,zero,2030bd0 <lwip_socket+0x3c>
 2030bc4:	10800060 	cmpeqi	r2,r2,1
 2030bc8:	1000171e 	bne	r2,zero,2030c28 <lwip_socket+0x94>
 2030bcc:	00001d06 	br	2030c44 <lwip_socket+0xb0>
    case SOCK_RAW:
      conn = netconn_new_with_proto_and_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_RAW),
 2030bd0:	e0bfff17 	ldw	r2,-4(fp)
 2030bd4:	10803fcc 	andi	r2,r2,255
 2030bd8:	018080f4 	movhi	r6,515
 2030bdc:	31877504 	addi	r6,r6,7636
 2030be0:	100b883a 	mov	r5,r2
 2030be4:	01001004 	movi	r4,64
 2030be8:	203e1680 	call	203e168 <netconn_new_with_proto_and_callback>
 2030bec:	e0bffb15 	stw	r2,-20(fp)
             (u8_t)protocol, DEFAULT_SOCKET_EVENTCB);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                  domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
      break;
 2030bf0:	00001a06 	br	2030c5c <lwip_socket+0xc8>
    case SOCK_DGRAM:
      conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain,
 2030bf4:	e0bfff17 	ldw	r2,-4(fp)
 2030bf8:	10802218 	cmpnei	r2,r2,136
 2030bfc:	1000021e 	bne	r2,zero,2030c08 <lwip_socket+0x74>
 2030c00:	00800844 	movi	r2,33
 2030c04:	00000106 	br	2030c0c <lwip_socket+0x78>
 2030c08:	00800804 	movi	r2,32
 2030c0c:	018080f4 	movhi	r6,515
 2030c10:	31877504 	addi	r6,r6,7636
 2030c14:	000b883a 	mov	r5,zero
 2030c18:	1009883a 	mov	r4,r2
 2030c1c:	203e1680 	call	203e168 <netconn_new_with_proto_and_callback>
 2030c20:	e0bffb15 	stw	r2,-20(fp)
      if (conn) {
        /* netconn layer enables pktinfo by default, sockets default to off */
        conn->flags &= ~NETCONN_FLAG_PKTINFO;
      }
#endif /* LWIP_NETBUF_RECVINFO */
      break;
 2030c24:	00000d06 	br	2030c5c <lwip_socket+0xc8>
    case SOCK_STREAM:
      conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_TCP), DEFAULT_SOCKET_EVENTCB);
 2030c28:	018080f4 	movhi	r6,515
 2030c2c:	31877504 	addi	r6,r6,7636
 2030c30:	000b883a 	mov	r5,zero
 2030c34:	01000404 	movi	r4,16
 2030c38:	203e1680 	call	203e168 <netconn_new_with_proto_and_callback>
 2030c3c:	e0bffb15 	stw	r2,-20(fp)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                  domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
      break;
 2030c40:	00000606 	br	2030c5c <lwip_socket+0xc8>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                  domain, type, protocol));
      set_errno(EINVAL);
 2030c44:	20423b80 	call	20423b8 <__errno>
 2030c48:	1007883a 	mov	r3,r2
 2030c4c:	00800584 	movi	r2,22
 2030c50:	18800015 	stw	r2,0(r3)
      return -1;
 2030c54:	00bfffc4 	movi	r2,-1
 2030c58:	00001b06 	br	2030cc8 <lwip_socket+0x134>
  }

  if (!conn) {
 2030c5c:	e0bffb17 	ldw	r2,-20(fp)
 2030c60:	1000061e 	bne	r2,zero,2030c7c <lwip_socket+0xe8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
 2030c64:	20423b80 	call	20423b8 <__errno>
 2030c68:	1007883a 	mov	r3,r2
 2030c6c:	00801a44 	movi	r2,105
 2030c70:	18800015 	stw	r2,0(r3)
    return -1;
 2030c74:	00bfffc4 	movi	r2,-1
 2030c78:	00001306 	br	2030cc8 <lwip_socket+0x134>
  }

  i = alloc_socket(conn, 0);
 2030c7c:	000b883a 	mov	r5,zero
 2030c80:	e13ffb17 	ldw	r4,-20(fp)
 2030c84:	202eda40 	call	202eda4 <alloc_socket>
 2030c88:	e0bffc15 	stw	r2,-16(fp)

  if (i == -1) {
 2030c8c:	e0bffc17 	ldw	r2,-16(fp)
 2030c90:	10bfffd8 	cmpnei	r2,r2,-1
 2030c94:	1000081e 	bne	r2,zero,2030cb8 <lwip_socket+0x124>
    netconn_delete(conn);
 2030c98:	e13ffb17 	ldw	r4,-20(fp)
 2030c9c:	203e2900 	call	203e290 <netconn_delete>
    set_errno(ENFILE);
 2030ca0:	20423b80 	call	20423b8 <__errno>
 2030ca4:	1007883a 	mov	r3,r2
 2030ca8:	008005c4 	movi	r2,23
 2030cac:	18800015 	stw	r2,0(r3)
    return -1;
 2030cb0:	00bfffc4 	movi	r2,-1
 2030cb4:	00000406 	br	2030cc8 <lwip_socket+0x134>
  }
  conn->callback_arg.socket = i;
 2030cb8:	e0bffb17 	ldw	r2,-20(fp)
 2030cbc:	e0fffc17 	ldw	r3,-16(fp)
 2030cc0:	10c00715 	stw	r3,28(r2)
  done_socket(&sockets[i - LWIP_SOCKET_OFFSET]);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
 2030cc4:	e0bffc17 	ldw	r2,-16(fp)
}
 2030cc8:	e037883a 	mov	sp,fp
 2030ccc:	dfc00117 	ldw	ra,4(sp)
 2030cd0:	df000017 	ldw	fp,0(sp)
 2030cd4:	dec00204 	addi	sp,sp,8
 2030cd8:	f800283a 	ret

02030cdc <lwip_write>:

ssize_t
lwip_write(int s, const void *data, size_t size)
{
 2030cdc:	defffb04 	addi	sp,sp,-20
 2030ce0:	dfc00415 	stw	ra,16(sp)
 2030ce4:	df000315 	stw	fp,12(sp)
 2030ce8:	df000304 	addi	fp,sp,12
 2030cec:	e13ffd15 	stw	r4,-12(fp)
 2030cf0:	e17ffe15 	stw	r5,-8(fp)
 2030cf4:	e1bfff15 	stw	r6,-4(fp)
  return lwip_send(s, data, size, 0);
 2030cf8:	000f883a 	mov	r7,zero
 2030cfc:	e1bfff17 	ldw	r6,-4(fp)
 2030d00:	e17ffe17 	ldw	r5,-8(fp)
 2030d04:	e13ffd17 	ldw	r4,-12(fp)
 2030d08:	20304040 	call	2030404 <lwip_send>
}
 2030d0c:	e037883a 	mov	sp,fp
 2030d10:	dfc00117 	ldw	ra,4(sp)
 2030d14:	df000017 	ldw	fp,0(sp)
 2030d18:	dec00204 	addi	sp,sp,8
 2030d1c:	f800283a 	ret

02030d20 <lwip_writev>:

ssize_t
lwip_writev(int s, const struct iovec *iov, int iovcnt)
{
 2030d20:	defff404 	addi	sp,sp,-48
 2030d24:	dfc00b15 	stw	ra,44(sp)
 2030d28:	df000a15 	stw	fp,40(sp)
 2030d2c:	df000a04 	addi	fp,sp,40
 2030d30:	e13ffd15 	stw	r4,-12(fp)
 2030d34:	e17ffe15 	stw	r5,-8(fp)
 2030d38:	e1bfff15 	stw	r6,-4(fp)
  struct msghdr msg;

  msg.msg_name = NULL;
 2030d3c:	e03ff615 	stw	zero,-40(fp)
  msg.msg_namelen = 0;
 2030d40:	e03ff715 	stw	zero,-36(fp)
  /* Hack: we have to cast via number to cast from 'const' pointer to non-const.
     Blame the opengroup standard for this inconsistency. */
  msg.msg_iov = LWIP_CONST_CAST(struct iovec *, iov);
 2030d44:	e0bffe17 	ldw	r2,-8(fp)
 2030d48:	e0bff815 	stw	r2,-32(fp)
  msg.msg_iovlen = iovcnt;
 2030d4c:	e0bfff17 	ldw	r2,-4(fp)
 2030d50:	e0bff915 	stw	r2,-28(fp)
  msg.msg_control = NULL;
 2030d54:	e03ffa15 	stw	zero,-24(fp)
  msg.msg_controllen = 0;
 2030d58:	e03ffb15 	stw	zero,-20(fp)
  msg.msg_flags = 0;
 2030d5c:	e03ffc15 	stw	zero,-16(fp)
  return lwip_sendmsg(s, &msg, 0);
 2030d60:	000d883a 	mov	r6,zero
 2030d64:	e17ff604 	addi	r5,fp,-40
 2030d68:	e13ffd17 	ldw	r4,-12(fp)
 2030d6c:	203053c0 	call	203053c <lwip_sendmsg>
}
 2030d70:	e037883a 	mov	sp,fp
 2030d74:	dfc00117 	ldw	ra,4(sp)
 2030d78:	df000017 	ldw	fp,0(sp)
 2030d7c:	dec00204 	addi	sp,sp,8
 2030d80:	f800283a 	ret

02030d84 <lwip_link_select_cb>:

#if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
/* Add select_cb to select_cb_list. */
static void
lwip_link_select_cb(struct lwip_select_cb *select_cb)
{
 2030d84:	defffc04 	addi	sp,sp,-16
 2030d88:	dfc00315 	stw	ra,12(sp)
 2030d8c:	df000215 	stw	fp,8(sp)
 2030d90:	df000204 	addi	fp,sp,8
 2030d94:	e13fff15 	stw	r4,-4(fp)
  LWIP_SOCKET_SELECT_DECL_PROTECT(lev);

  /* Protect the select_cb_list */
  LWIP_SOCKET_SELECT_PROTECT(lev);
 2030d98:	2014cec0 	call	2014cec <sys_arch_protect>
 2030d9c:	e0bffe15 	stw	r2,-8(fp)

  /* Put this select_cb on top of list */
  select_cb->next = select_cb_list;
 2030da0:	d0e7fc17 	ldw	r3,-24592(gp)
 2030da4:	e0bfff17 	ldw	r2,-4(fp)
 2030da8:	10c00015 	stw	r3,0(r2)
  if (select_cb_list != NULL) {
 2030dac:	d0a7fc17 	ldw	r2,-24592(gp)
 2030db0:	10000326 	beq	r2,zero,2030dc0 <lwip_link_select_cb+0x3c>
    select_cb_list->prev = select_cb;
 2030db4:	d0a7fc17 	ldw	r2,-24592(gp)
 2030db8:	e0ffff17 	ldw	r3,-4(fp)
 2030dbc:	10c00115 	stw	r3,4(r2)
  }
  select_cb_list = select_cb;
 2030dc0:	e0bfff17 	ldw	r2,-4(fp)
 2030dc4:	d0a7fc15 	stw	r2,-24592(gp)
#if !LWIP_TCPIP_CORE_LOCKING
  /* Increasing this counter tells select_check_waiters that the list has changed. */
  select_cb_ctr++;
 2030dc8:	d0a7fb17 	ldw	r2,-24596(gp)
 2030dcc:	10800044 	addi	r2,r2,1
 2030dd0:	d0a7fb15 	stw	r2,-24596(gp)
#endif

  /* Now we can safely unprotect */
  LWIP_SOCKET_SELECT_UNPROTECT(lev);
 2030dd4:	e13ffe17 	ldw	r4,-8(fp)
 2030dd8:	2014d200 	call	2014d20 <sys_arch_unprotect>
}
 2030ddc:	0001883a 	nop
 2030de0:	e037883a 	mov	sp,fp
 2030de4:	dfc00117 	ldw	ra,4(sp)
 2030de8:	df000017 	ldw	fp,0(sp)
 2030dec:	dec00204 	addi	sp,sp,8
 2030df0:	f800283a 	ret

02030df4 <lwip_unlink_select_cb>:

/* Remove select_cb from select_cb_list. */
static void
lwip_unlink_select_cb(struct lwip_select_cb *select_cb)
{
 2030df4:	defffc04 	addi	sp,sp,-16
 2030df8:	dfc00315 	stw	ra,12(sp)
 2030dfc:	df000215 	stw	fp,8(sp)
 2030e00:	df000204 	addi	fp,sp,8
 2030e04:	e13fff15 	stw	r4,-4(fp)
  LWIP_SOCKET_SELECT_DECL_PROTECT(lev);

  /* Take us off the list */
  LWIP_SOCKET_SELECT_PROTECT(lev);
 2030e08:	2014cec0 	call	2014cec <sys_arch_protect>
 2030e0c:	e0bffe15 	stw	r2,-8(fp)
  if (select_cb->next != NULL) {
 2030e10:	e0bfff17 	ldw	r2,-4(fp)
 2030e14:	10800017 	ldw	r2,0(r2)
 2030e18:	10000526 	beq	r2,zero,2030e30 <lwip_unlink_select_cb+0x3c>
    select_cb->next->prev = select_cb->prev;
 2030e1c:	e0bfff17 	ldw	r2,-4(fp)
 2030e20:	10800017 	ldw	r2,0(r2)
 2030e24:	e0ffff17 	ldw	r3,-4(fp)
 2030e28:	18c00117 	ldw	r3,4(r3)
 2030e2c:	10c00115 	stw	r3,4(r2)
  }
  if (select_cb_list == select_cb) {
 2030e30:	d0e7fc17 	ldw	r3,-24592(gp)
 2030e34:	e0bfff17 	ldw	r2,-4(fp)
 2030e38:	1880041e 	bne	r3,r2,2030e4c <lwip_unlink_select_cb+0x58>
    LWIP_ASSERT("select_cb->prev == NULL", select_cb->prev == NULL);
    select_cb_list = select_cb->next;
 2030e3c:	e0bfff17 	ldw	r2,-4(fp)
 2030e40:	10800017 	ldw	r2,0(r2)
 2030e44:	d0a7fc15 	stw	r2,-24592(gp)
 2030e48:	00000506 	br	2030e60 <lwip_unlink_select_cb+0x6c>
  } else {
    LWIP_ASSERT("select_cb->prev != NULL", select_cb->prev != NULL);
    select_cb->prev->next = select_cb->next;
 2030e4c:	e0bfff17 	ldw	r2,-4(fp)
 2030e50:	10800117 	ldw	r2,4(r2)
 2030e54:	e0ffff17 	ldw	r3,-4(fp)
 2030e58:	18c00017 	ldw	r3,0(r3)
 2030e5c:	10c00015 	stw	r3,0(r2)
  }
#if !LWIP_TCPIP_CORE_LOCKING
  /* Increasing this counter tells select_check_waiters that the list has changed. */
  select_cb_ctr++;
 2030e60:	d0a7fb17 	ldw	r2,-24596(gp)
 2030e64:	10800044 	addi	r2,r2,1
 2030e68:	d0a7fb15 	stw	r2,-24596(gp)
#endif
  LWIP_SOCKET_SELECT_UNPROTECT(lev);
 2030e6c:	e13ffe17 	ldw	r4,-8(fp)
 2030e70:	2014d200 	call	2014d20 <sys_arch_unprotect>
}
 2030e74:	0001883a 	nop
 2030e78:	e037883a 	mov	sp,fp
 2030e7c:	dfc00117 	ldw	ra,4(sp)
 2030e80:	df000017 	ldw	fp,0(sp)
 2030e84:	dec00204 	addi	sp,sp,8
 2030e88:	f800283a 	ret

02030e8c <lwip_selscan>:
 * @return number of sockets that had events (read/write/exception) (>= 0)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
{
 2030e8c:	deffe704 	addi	sp,sp,-100
 2030e90:	dfc01815 	stw	ra,96(sp)
 2030e94:	df001715 	stw	fp,92(sp)
 2030e98:	df001704 	addi	fp,sp,92
 2030e9c:	e13ffc15 	stw	r4,-16(fp)
 2030ea0:	e17ffd15 	stw	r5,-12(fp)
 2030ea4:	e1bffe15 	stw	r6,-8(fp)
 2030ea8:	e1ffff15 	stw	r7,-4(fp)
  int i, nready = 0;
 2030eac:	e03fea15 	stw	zero,-88(fp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  FD_ZERO(&lreadset);
 2030eb0:	e0bff604 	addi	r2,fp,-40
 2030eb4:	e0bfec15 	stw	r2,-80(fp)
 2030eb8:	e03feb15 	stw	zero,-84(fp)
 2030ebc:	00000706 	br	2030edc <lwip_selscan+0x50>
 2030ec0:	e0bfec17 	ldw	r2,-80(fp)
 2030ec4:	10c00044 	addi	r3,r2,1
 2030ec8:	e0ffec15 	stw	r3,-80(fp)
 2030ecc:	10000005 	stb	zero,0(r2)
 2030ed0:	e0bfeb17 	ldw	r2,-84(fp)
 2030ed4:	10800044 	addi	r2,r2,1
 2030ed8:	e0bfeb15 	stw	r2,-84(fp)
 2030edc:	e0bfeb17 	ldw	r2,-84(fp)
 2030ee0:	10800230 	cmpltui	r2,r2,8
 2030ee4:	103ff61e 	bne	r2,zero,2030ec0 <__alt_mem_mem_0+0xfd010ec0>
  FD_ZERO(&lwriteset);
 2030ee8:	e0bff804 	addi	r2,fp,-32
 2030eec:	e0bfee15 	stw	r2,-72(fp)
 2030ef0:	e03fed15 	stw	zero,-76(fp)
 2030ef4:	00000706 	br	2030f14 <lwip_selscan+0x88>
 2030ef8:	e0bfee17 	ldw	r2,-72(fp)
 2030efc:	10c00044 	addi	r3,r2,1
 2030f00:	e0ffee15 	stw	r3,-72(fp)
 2030f04:	10000005 	stb	zero,0(r2)
 2030f08:	e0bfed17 	ldw	r2,-76(fp)
 2030f0c:	10800044 	addi	r2,r2,1
 2030f10:	e0bfed15 	stw	r2,-76(fp)
 2030f14:	e0bfed17 	ldw	r2,-76(fp)
 2030f18:	10800230 	cmpltui	r2,r2,8
 2030f1c:	103ff61e 	bne	r2,zero,2030ef8 <__alt_mem_mem_0+0xfd010ef8>
  FD_ZERO(&lexceptset);
 2030f20:	e0bffa04 	addi	r2,fp,-24
 2030f24:	e0bff015 	stw	r2,-64(fp)
 2030f28:	e03fef15 	stw	zero,-68(fp)
 2030f2c:	00000706 	br	2030f4c <lwip_selscan+0xc0>
 2030f30:	e0bff017 	ldw	r2,-64(fp)
 2030f34:	10c00044 	addi	r3,r2,1
 2030f38:	e0fff015 	stw	r3,-64(fp)
 2030f3c:	10000005 	stb	zero,0(r2)
 2030f40:	e0bfef17 	ldw	r2,-68(fp)
 2030f44:	10800044 	addi	r2,r2,1
 2030f48:	e0bfef15 	stw	r2,-68(fp)
 2030f4c:	e0bfef17 	ldw	r2,-68(fp)
 2030f50:	10800230 	cmpltui	r2,r2,8
 2030f54:	103ff61e 	bne	r2,zero,2030f30 <__alt_mem_mem_0+0xfd010f30>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 2030f58:	00800404 	movi	r2,16
 2030f5c:	e0bfe915 	stw	r2,-92(fp)
 2030f60:	0000bc06 	br	2031254 <lwip_selscan+0x3c8>
    /* if this FD is not in the set, continue */
    if (!(readset_in && FD_ISSET(i, readset_in)) &&
 2030f64:	e0bffd17 	ldw	r2,-12(fp)
 2030f68:	10000c26 	beq	r2,zero,2030f9c <lwip_selscan+0x110>
 2030f6c:	e0bfe917 	ldw	r2,-92(fp)
 2030f70:	1004d17a 	srli	r2,r2,5
 2030f74:	e0fffd17 	ldw	r3,-12(fp)
 2030f78:	1085883a 	add	r2,r2,r2
 2030f7c:	1085883a 	add	r2,r2,r2
 2030f80:	1885883a 	add	r2,r3,r2
 2030f84:	10c00017 	ldw	r3,0(r2)
 2030f88:	e0bfe917 	ldw	r2,-92(fp)
 2030f8c:	108007cc 	andi	r2,r2,31
 2030f90:	1885d83a 	sra	r2,r3,r2
 2030f94:	1080004c 	andi	r2,r2,1
 2030f98:	10001c1e 	bne	r2,zero,203100c <lwip_selscan+0x180>
 2030f9c:	e0bffe17 	ldw	r2,-8(fp)
 2030fa0:	10000c26 	beq	r2,zero,2030fd4 <lwip_selscan+0x148>
        !(writeset_in && FD_ISSET(i, writeset_in)) &&
 2030fa4:	e0bfe917 	ldw	r2,-92(fp)
 2030fa8:	1004d17a 	srli	r2,r2,5
 2030fac:	e0fffe17 	ldw	r3,-8(fp)
 2030fb0:	1085883a 	add	r2,r2,r2
 2030fb4:	1085883a 	add	r2,r2,r2
 2030fb8:	1885883a 	add	r2,r3,r2
 2030fbc:	10c00017 	ldw	r3,0(r2)
 2030fc0:	e0bfe917 	ldw	r2,-92(fp)
 2030fc4:	108007cc 	andi	r2,r2,31
 2030fc8:	1885d83a 	sra	r2,r3,r2
 2030fcc:	1080004c 	andi	r2,r2,1
 2030fd0:	10000e1e 	bne	r2,zero,203100c <lwip_selscan+0x180>
 2030fd4:	e0bfff17 	ldw	r2,-4(fp)
 2030fd8:	10009a26 	beq	r2,zero,2031244 <lwip_selscan+0x3b8>
        !(exceptset_in && FD_ISSET(i, exceptset_in))) {
 2030fdc:	e0bfe917 	ldw	r2,-92(fp)
 2030fe0:	1004d17a 	srli	r2,r2,5
 2030fe4:	e0ffff17 	ldw	r3,-4(fp)
 2030fe8:	1085883a 	add	r2,r2,r2
 2030fec:	1085883a 	add	r2,r2,r2
 2030ff0:	1885883a 	add	r2,r3,r2
 2030ff4:	10c00017 	ldw	r3,0(r2)
 2030ff8:	e0bfe917 	ldw	r2,-92(fp)
 2030ffc:	108007cc 	andi	r2,r2,31
 2031000:	1885d83a 	sra	r2,r3,r2
 2031004:	1080004c 	andi	r2,r2,1
 2031008:	10008e26 	beq	r2,zero,2031244 <lwip_selscan+0x3b8>
      continue;
    }
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
 203100c:	2014cec0 	call	2014cec <sys_arch_protect>
 2031010:	e0bff115 	stw	r2,-60(fp)
    sock = tryget_socket_unconn_locked(i);
 2031014:	e13fe917 	ldw	r4,-92(fp)
 2031018:	202ecc00 	call	202ecc0 <tryget_socket_unconn_locked>
 203101c:	e0bff215 	stw	r2,-56(fp)
    if (sock != NULL) {
 2031020:	e0bff217 	ldw	r2,-56(fp)
 2031024:	10008326 	beq	r2,zero,2031234 <lwip_selscan+0x3a8>
      void *lastdata = sock->lastdata.pbuf;
 2031028:	e0bff217 	ldw	r2,-56(fp)
 203102c:	10800117 	ldw	r2,4(r2)
 2031030:	e0bff315 	stw	r2,-52(fp)
      s16_t rcvevent = sock->rcvevent;
 2031034:	e0bff217 	ldw	r2,-56(fp)
 2031038:	1080020b 	ldhu	r2,8(r2)
 203103c:	e0bff40d 	sth	r2,-48(fp)
      u16_t sendevent = sock->sendevent;
 2031040:	e0bff217 	ldw	r2,-56(fp)
 2031044:	1080028b 	ldhu	r2,10(r2)
 2031048:	e0bff48d 	sth	r2,-46(fp)
      u16_t errevent = sock->errevent;
 203104c:	e0bff217 	ldw	r2,-56(fp)
 2031050:	1080030b 	ldhu	r2,12(r2)
 2031054:	e0bff50d 	sth	r2,-44(fp)
      SYS_ARCH_UNPROTECT(lev);
 2031058:	e13ff117 	ldw	r4,-60(fp)
 203105c:	2014d200 	call	2014d20 <sys_arch_unprotect>

      /* ... then examine it: */
      /* See if netconn of this socket is ready for read */
      if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
 2031060:	e0bffd17 	ldw	r2,-12(fp)
 2031064:	10002626 	beq	r2,zero,2031100 <lwip_selscan+0x274>
 2031068:	e0bfe917 	ldw	r2,-92(fp)
 203106c:	1004d17a 	srli	r2,r2,5
 2031070:	e0fffd17 	ldw	r3,-12(fp)
 2031074:	1085883a 	add	r2,r2,r2
 2031078:	1085883a 	add	r2,r2,r2
 203107c:	1885883a 	add	r2,r3,r2
 2031080:	10c00017 	ldw	r3,0(r2)
 2031084:	e0bfe917 	ldw	r2,-92(fp)
 2031088:	108007cc 	andi	r2,r2,31
 203108c:	1885d83a 	sra	r2,r3,r2
 2031090:	1080004c 	andi	r2,r2,1
 2031094:	10001a26 	beq	r2,zero,2031100 <lwip_selscan+0x274>
 2031098:	e0bff317 	ldw	r2,-52(fp)
 203109c:	1000021e 	bne	r2,zero,20310a8 <lwip_selscan+0x21c>
 20310a0:	e0bff40f 	ldh	r2,-48(fp)
 20310a4:	0080160e 	bge	zero,r2,2031100 <lwip_selscan+0x274>
        FD_SET(i, &lreadset);
 20310a8:	e0bfe917 	ldw	r2,-92(fp)
 20310ac:	1004d17a 	srli	r2,r2,5
 20310b0:	1087883a 	add	r3,r2,r2
 20310b4:	18c7883a 	add	r3,r3,r3
 20310b8:	e13fe904 	addi	r4,fp,-92
 20310bc:	20c7883a 	add	r3,r4,r3
 20310c0:	18c00d04 	addi	r3,r3,52
 20310c4:	19000017 	ldw	r4,0(r3)
 20310c8:	e0ffe917 	ldw	r3,-92(fp)
 20310cc:	18c007cc 	andi	r3,r3,31
 20310d0:	01400044 	movi	r5,1
 20310d4:	28c6983a 	sll	r3,r5,r3
 20310d8:	20c6b03a 	or	r3,r4,r3
 20310dc:	1085883a 	add	r2,r2,r2
 20310e0:	1085883a 	add	r2,r2,r2
 20310e4:	e13fe904 	addi	r4,fp,-92
 20310e8:	2085883a 	add	r2,r4,r2
 20310ec:	10800d04 	addi	r2,r2,52
 20310f0:	10c00015 	stw	r3,0(r2)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
 20310f4:	e0bfea17 	ldw	r2,-88(fp)
 20310f8:	10800044 	addi	r2,r2,1
 20310fc:	e0bfea15 	stw	r2,-88(fp)
      }
      /* See if netconn of this socket is ready for write */
      if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
 2031100:	e0bffe17 	ldw	r2,-8(fp)
 2031104:	10002426 	beq	r2,zero,2031198 <lwip_selscan+0x30c>
 2031108:	e0bfe917 	ldw	r2,-92(fp)
 203110c:	1004d17a 	srli	r2,r2,5
 2031110:	e0fffe17 	ldw	r3,-8(fp)
 2031114:	1085883a 	add	r2,r2,r2
 2031118:	1085883a 	add	r2,r2,r2
 203111c:	1885883a 	add	r2,r3,r2
 2031120:	10c00017 	ldw	r3,0(r2)
 2031124:	e0bfe917 	ldw	r2,-92(fp)
 2031128:	108007cc 	andi	r2,r2,31
 203112c:	1885d83a 	sra	r2,r3,r2
 2031130:	1080004c 	andi	r2,r2,1
 2031134:	10001826 	beq	r2,zero,2031198 <lwip_selscan+0x30c>
 2031138:	e0bff48b 	ldhu	r2,-46(fp)
 203113c:	10001626 	beq	r2,zero,2031198 <lwip_selscan+0x30c>
        FD_SET(i, &lwriteset);
 2031140:	e0bfe917 	ldw	r2,-92(fp)
 2031144:	1004d17a 	srli	r2,r2,5
 2031148:	1087883a 	add	r3,r2,r2
 203114c:	18c7883a 	add	r3,r3,r3
 2031150:	e13fe904 	addi	r4,fp,-92
 2031154:	20c7883a 	add	r3,r4,r3
 2031158:	18c00f04 	addi	r3,r3,60
 203115c:	19000017 	ldw	r4,0(r3)
 2031160:	e0ffe917 	ldw	r3,-92(fp)
 2031164:	18c007cc 	andi	r3,r3,31
 2031168:	01400044 	movi	r5,1
 203116c:	28c6983a 	sll	r3,r5,r3
 2031170:	20c6b03a 	or	r3,r4,r3
 2031174:	1085883a 	add	r2,r2,r2
 2031178:	1085883a 	add	r2,r2,r2
 203117c:	e13fe904 	addi	r4,fp,-92
 2031180:	2085883a 	add	r2,r4,r2
 2031184:	10800f04 	addi	r2,r2,60
 2031188:	10c00015 	stw	r3,0(r2)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
 203118c:	e0bfea17 	ldw	r2,-88(fp)
 2031190:	10800044 	addi	r2,r2,1
 2031194:	e0bfea15 	stw	r2,-88(fp)
      }
      /* See if netconn of this socket had an error */
      if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
 2031198:	e0bfff17 	ldw	r2,-4(fp)
 203119c:	10002a26 	beq	r2,zero,2031248 <lwip_selscan+0x3bc>
 20311a0:	e0bfe917 	ldw	r2,-92(fp)
 20311a4:	1004d17a 	srli	r2,r2,5
 20311a8:	e0ffff17 	ldw	r3,-4(fp)
 20311ac:	1085883a 	add	r2,r2,r2
 20311b0:	1085883a 	add	r2,r2,r2
 20311b4:	1885883a 	add	r2,r3,r2
 20311b8:	10c00017 	ldw	r3,0(r2)
 20311bc:	e0bfe917 	ldw	r2,-92(fp)
 20311c0:	108007cc 	andi	r2,r2,31
 20311c4:	1885d83a 	sra	r2,r3,r2
 20311c8:	1080004c 	andi	r2,r2,1
 20311cc:	10001e26 	beq	r2,zero,2031248 <lwip_selscan+0x3bc>
 20311d0:	e0bff50b 	ldhu	r2,-44(fp)
 20311d4:	10001c26 	beq	r2,zero,2031248 <lwip_selscan+0x3bc>
        FD_SET(i, &lexceptset);
 20311d8:	e0bfe917 	ldw	r2,-92(fp)
 20311dc:	1004d17a 	srli	r2,r2,5
 20311e0:	1087883a 	add	r3,r2,r2
 20311e4:	18c7883a 	add	r3,r3,r3
 20311e8:	e13fe904 	addi	r4,fp,-92
 20311ec:	20c7883a 	add	r3,r4,r3
 20311f0:	18c01104 	addi	r3,r3,68
 20311f4:	19000017 	ldw	r4,0(r3)
 20311f8:	e0ffe917 	ldw	r3,-92(fp)
 20311fc:	18c007cc 	andi	r3,r3,31
 2031200:	01400044 	movi	r5,1
 2031204:	28c6983a 	sll	r3,r5,r3
 2031208:	20c6b03a 	or	r3,r4,r3
 203120c:	1085883a 	add	r2,r2,r2
 2031210:	1085883a 	add	r2,r2,r2
 2031214:	e13fe904 	addi	r4,fp,-92
 2031218:	2085883a 	add	r2,r4,r2
 203121c:	10801104 	addi	r2,r2,68
 2031220:	10c00015 	stw	r3,0(r2)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
        nready++;
 2031224:	e0bfea17 	ldw	r2,-88(fp)
 2031228:	10800044 	addi	r2,r2,1
 203122c:	e0bfea15 	stw	r2,-88(fp)
 2031230:	00000506 	br	2031248 <lwip_selscan+0x3bc>
      }
      done_socket(sock);
    } else {
      SYS_ARCH_UNPROTECT(lev);
 2031234:	e13ff117 	ldw	r4,-60(fp)
 2031238:	2014d200 	call	2014d20 <sys_arch_unprotect>
      /* no a valid open socket */
      return -1;
 203123c:	00bfffc4 	movi	r2,-1
 2031240:	00001706 	br	20312a0 <lwip_selscan+0x414>
  for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
    /* if this FD is not in the set, continue */
    if (!(readset_in && FD_ISSET(i, readset_in)) &&
        !(writeset_in && FD_ISSET(i, writeset_in)) &&
        !(exceptset_in && FD_ISSET(i, exceptset_in))) {
      continue;
 2031244:	0001883a 	nop
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 2031248:	e0bfe917 	ldw	r2,-92(fp)
 203124c:	10800044 	addi	r2,r2,1
 2031250:	e0bfe915 	stw	r2,-92(fp)
 2031254:	e0ffe917 	ldw	r3,-92(fp)
 2031258:	e0bffc17 	ldw	r2,-16(fp)
 203125c:	18bf4116 	blt	r3,r2,2030f64 <__alt_mem_mem_0+0xfd010f64>
      /* no a valid open socket */
      return -1;
    }
  }
  /* copy local sets to the ones provided as arguments */
  *readset_out = lreadset;
 2031260:	e0800217 	ldw	r2,8(fp)
 2031264:	e0fff617 	ldw	r3,-40(fp)
 2031268:	10c00015 	stw	r3,0(r2)
 203126c:	e0fff717 	ldw	r3,-36(fp)
 2031270:	10c00115 	stw	r3,4(r2)
  *writeset_out = lwriteset;
 2031274:	e0800317 	ldw	r2,12(fp)
 2031278:	e0fff817 	ldw	r3,-32(fp)
 203127c:	10c00015 	stw	r3,0(r2)
 2031280:	e0fff917 	ldw	r3,-28(fp)
 2031284:	10c00115 	stw	r3,4(r2)
  *exceptset_out = lexceptset;
 2031288:	e0800417 	ldw	r2,16(fp)
 203128c:	e0fffa17 	ldw	r3,-24(fp)
 2031290:	10c00015 	stw	r3,0(r2)
 2031294:	e0fffb17 	ldw	r3,-20(fp)
 2031298:	10c00115 	stw	r3,4(r2)

  LWIP_ASSERT("nready >= 0", nready >= 0);
  return nready;
 203129c:	e0bfea17 	ldw	r2,-88(fp)
}
 20312a0:	e037883a 	mov	sp,fp
 20312a4:	dfc00117 	ldw	ra,4(sp)
 20312a8:	df000017 	ldw	fp,0(sp)
 20312ac:	dec00204 	addi	sp,sp,8
 20312b0:	f800283a 	ret

020312b4 <lwip_select>:
#endif /* LWIP_NETCONN_FULLDUPLEX */

int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
 20312b4:	deffde04 	addi	sp,sp,-136
 20312b8:	dfc02115 	stw	ra,132(sp)
 20312bc:	df002015 	stw	fp,128(sp)
 20312c0:	dc001f15 	stw	r16,124(sp)
 20312c4:	df002004 	addi	fp,sp,128
 20312c8:	e13ffb15 	stw	r4,-20(fp)
 20312cc:	e17ffc15 	stw	r5,-16(fp)
 20312d0:	e1bffd15 	stw	r6,-12(fp)
 20312d4:	e1fffe15 	stw	r7,-8(fp)
  u32_t waitres = 0;
 20312d8:	e03fe315 	stw	zero,-116(fp)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%"S32_F" tvusec=%"S32_F")\n",
                              maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                              timeout ? (s32_t)timeout->tv_sec : (s32_t) - 1,
                              timeout ? (s32_t)timeout->tv_usec : (s32_t) - 1));

  if ((maxfdp1 < 0) || (maxfdp1 > LWIP_SELECT_MAXNFDS)) {
 20312dc:	e0bffb17 	ldw	r2,-20(fp)
 20312e0:	10000316 	blt	r2,zero,20312f0 <lwip_select+0x3c>
 20312e4:	e0bffb17 	ldw	r2,-20(fp)
 20312e8:	10801050 	cmplti	r2,r2,65
 20312ec:	1000061e 	bne	r2,zero,2031308 <lwip_select+0x54>
    set_errno(EINVAL);
 20312f0:	20423b80 	call	20423b8 <__errno>
 20312f4:	1007883a 	mov	r3,r2
 20312f8:	00800584 	movi	r2,22
 20312fc:	18800015 	stw	r2,0(r3)
    return -1;
 2031300:	00bfffc4 	movi	r2,-1
 2031304:	00014b06 	br	2031834 <lwip_select+0x580>

  lwip_select_inc_sockets_used(maxfdp1, readset, writeset, exceptset, &used_sockets);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 2031308:	e0bff004 	addi	r2,fp,-64
 203130c:	d8800215 	stw	r2,8(sp)
 2031310:	e0bfee04 	addi	r2,fp,-72
 2031314:	d8800115 	stw	r2,4(sp)
 2031318:	e0bfec04 	addi	r2,fp,-80
 203131c:	d8800015 	stw	r2,0(sp)
 2031320:	e1fffe17 	ldw	r7,-8(fp)
 2031324:	e1bffd17 	ldw	r6,-12(fp)
 2031328:	e17ffc17 	ldw	r5,-16(fp)
 203132c:	e13ffb17 	ldw	r4,-20(fp)
 2031330:	2030e8c0 	call	2030e8c <lwip_selscan>
 2031334:	e0bfe415 	stw	r2,-112(fp)

  if (nready < 0) {
 2031338:	e0bfe417 	ldw	r2,-112(fp)
 203133c:	1000060e 	bge	r2,zero,2031358 <lwip_select+0xa4>
    /* one of the sockets in one of the fd_sets was invalid */
    set_errno(EBADF);
 2031340:	20423b80 	call	20423b8 <__errno>
 2031344:	1007883a 	mov	r3,r2
 2031348:	00800244 	movi	r2,9
 203134c:	18800015 	stw	r2,0(r3)
    lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
    return -1;
 2031350:	00bfffc4 	movi	r2,-1
 2031354:	00013706 	br	2031834 <lwip_select+0x580>
  } else if (nready > 0) {
 2031358:	e0bfe417 	ldw	r2,-112(fp)
 203135c:	00811f16 	blt	zero,r2,20317dc <lwip_select+0x528>
    /* one or more sockets are set, no need to wait */
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  } else {
    /* If we don't have any current events, then suspend if we are supposed to */
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
 2031360:	e0800217 	ldw	r2,8(fp)
 2031364:	10000626 	beq	r2,zero,2031380 <lwip_select+0xcc>
 2031368:	e0800217 	ldw	r2,8(fp)
 203136c:	10800017 	ldw	r2,0(r2)
 2031370:	1000031e 	bne	r2,zero,2031380 <lwip_select+0xcc>
 2031374:	e0800217 	ldw	r2,8(fp)
 2031378:	10800117 	ldw	r2,4(r2)
 203137c:	10011726 	beq	r2,zero,20317dc <lwip_select+0x528>
         list is only valid while we are in this function, so it's ok
         to use local variables (unless we're running in MPU compatible
         mode). */
      API_SELECT_CB_VAR_DECLARE(select_cb);
      API_SELECT_CB_VAR_ALLOC(select_cb, set_errno(ENOMEM); lwip_select_dec_sockets_used(maxfdp1, &used_sockets); return -1);
      memset(&API_SELECT_CB_VAR_REF(select_cb), 0, sizeof(struct lwip_select_cb));
 2031380:	e0bff204 	addi	r2,fp,-56
 2031384:	01800904 	movi	r6,36
 2031388:	000b883a 	mov	r5,zero
 203138c:	1009883a 	mov	r4,r2
 2031390:	2005fa00 	call	2005fa0 <memset>

      API_SELECT_CB_VAR_REF(select_cb).readset = readset;
 2031394:	e0bffc17 	ldw	r2,-16(fp)
 2031398:	e0bff415 	stw	r2,-48(fp)
      API_SELECT_CB_VAR_REF(select_cb).writeset = writeset;
 203139c:	e0bffd17 	ldw	r2,-12(fp)
 20313a0:	e0bff515 	stw	r2,-44(fp)
      API_SELECT_CB_VAR_REF(select_cb).exceptset = exceptset;
 20313a4:	e0bffe17 	ldw	r2,-8(fp)
 20313a8:	e0bff615 	stw	r2,-40(fp)
#if LWIP_NETCONN_SEM_PER_THREAD
      API_SELECT_CB_VAR_REF(select_cb).sem = LWIP_NETCONN_THREAD_SEM_GET();
#else /* LWIP_NETCONN_SEM_PER_THREAD */
      if (sys_sem_new(&API_SELECT_CB_VAR_REF(select_cb).sem, 0) != ERR_OK) {
 20313ac:	e0bff204 	addi	r2,fp,-56
 20313b0:	10800804 	addi	r2,r2,32
 20313b4:	000b883a 	mov	r5,zero
 20313b8:	1009883a 	mov	r4,r2
 20313bc:	2014f380 	call	2014f38 <sys_sem_new>
 20313c0:	10803fcc 	andi	r2,r2,255
 20313c4:	1080201c 	xori	r2,r2,128
 20313c8:	10bfe004 	addi	r2,r2,-128
 20313cc:	10000626 	beq	r2,zero,20313e8 <lwip_select+0x134>
        /* failed to create semaphore */
        set_errno(ENOMEM);
 20313d0:	20423b80 	call	20423b8 <__errno>
 20313d4:	1007883a 	mov	r3,r2
 20313d8:	00800304 	movi	r2,12
 20313dc:	18800015 	stw	r2,0(r3)
        lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
        API_SELECT_CB_VAR_FREE(select_cb);
        return -1;
 20313e0:	00bfffc4 	movi	r2,-1
 20313e4:	00011306 	br	2031834 <lwip_select+0x580>
      }
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

      lwip_link_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
 20313e8:	e0bff204 	addi	r2,fp,-56
 20313ec:	1009883a 	mov	r4,r2
 20313f0:	2030d840 	call	2030d84 <lwip_link_select_cb>

      /* Increase select_waiting for each socket we are interested in */
      maxfdp2 = maxfdp1;
 20313f4:	e0bffb17 	ldw	r2,-20(fp)
 20313f8:	e0bfe715 	stw	r2,-100(fp)
      for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 20313fc:	00800404 	movi	r2,16
 2031400:	e0bfe615 	stw	r2,-104(fp)
 2031404:	00005d06 	br	203157c <lwip_select+0x2c8>
        if ((readset && FD_ISSET(i, readset)) ||
 2031408:	e0bffc17 	ldw	r2,-16(fp)
 203140c:	10000c26 	beq	r2,zero,2031440 <lwip_select+0x18c>
 2031410:	e0bfe617 	ldw	r2,-104(fp)
 2031414:	1004d17a 	srli	r2,r2,5
 2031418:	e0fffc17 	ldw	r3,-16(fp)
 203141c:	1085883a 	add	r2,r2,r2
 2031420:	1085883a 	add	r2,r2,r2
 2031424:	1885883a 	add	r2,r3,r2
 2031428:	10c00017 	ldw	r3,0(r2)
 203142c:	e0bfe617 	ldw	r2,-104(fp)
 2031430:	108007cc 	andi	r2,r2,31
 2031434:	1885d83a 	sra	r2,r3,r2
 2031438:	1080004c 	andi	r2,r2,1
 203143c:	10001c1e 	bne	r2,zero,20314b0 <lwip_select+0x1fc>
 2031440:	e0bffd17 	ldw	r2,-12(fp)
 2031444:	10000c26 	beq	r2,zero,2031478 <lwip_select+0x1c4>
            (writeset && FD_ISSET(i, writeset)) ||
 2031448:	e0bfe617 	ldw	r2,-104(fp)
 203144c:	1004d17a 	srli	r2,r2,5
 2031450:	e0fffd17 	ldw	r3,-12(fp)
 2031454:	1085883a 	add	r2,r2,r2
 2031458:	1085883a 	add	r2,r2,r2
 203145c:	1885883a 	add	r2,r3,r2
 2031460:	10c00017 	ldw	r3,0(r2)
 2031464:	e0bfe617 	ldw	r2,-104(fp)
 2031468:	108007cc 	andi	r2,r2,31
 203146c:	1885d83a 	sra	r2,r3,r2
 2031470:	1080004c 	andi	r2,r2,1
 2031474:	10000e1e 	bne	r2,zero,20314b0 <lwip_select+0x1fc>
 2031478:	e0bffe17 	ldw	r2,-8(fp)
 203147c:	10003c26 	beq	r2,zero,2031570 <lwip_select+0x2bc>
            (exceptset && FD_ISSET(i, exceptset))) {
 2031480:	e0bfe617 	ldw	r2,-104(fp)
 2031484:	1004d17a 	srli	r2,r2,5
 2031488:	e0fffe17 	ldw	r3,-8(fp)
 203148c:	1085883a 	add	r2,r2,r2
 2031490:	1085883a 	add	r2,r2,r2
 2031494:	1885883a 	add	r2,r3,r2
 2031498:	10c00017 	ldw	r3,0(r2)
 203149c:	e0bfe617 	ldw	r2,-104(fp)
 20314a0:	108007cc 	andi	r2,r2,31
 20314a4:	1885d83a 	sra	r2,r3,r2
 20314a8:	1080004c 	andi	r2,r2,1
 20314ac:	10003026 	beq	r2,zero,2031570 <lwip_select+0x2bc>
          struct lwip_sock *sock;
          SYS_ARCH_PROTECT(lev);
 20314b0:	2014cec0 	call	2014cec <sys_arch_protect>
 20314b4:	e0bfe815 	stw	r2,-96(fp)
          sock = tryget_socket_unconn_locked(i);
 20314b8:	e13fe617 	ldw	r4,-104(fp)
 20314bc:	202ecc00 	call	202ecc0 <tryget_socket_unconn_locked>
 20314c0:	e0bfe915 	stw	r2,-92(fp)
          if (sock != NULL) {
 20314c4:	e0bfe917 	ldw	r2,-92(fp)
 20314c8:	10001e26 	beq	r2,zero,2031544 <lwip_select+0x290>
            sock->select_waiting++;
 20314cc:	e0bfe917 	ldw	r2,-92(fp)
 20314d0:	10800383 	ldbu	r2,14(r2)
 20314d4:	10800044 	addi	r2,r2,1
 20314d8:	1007883a 	mov	r3,r2
 20314dc:	e0bfe917 	ldw	r2,-92(fp)
 20314e0:	10c00385 	stb	r3,14(r2)
            if (sock->select_waiting == 0) {
 20314e4:	e0bfe917 	ldw	r2,-92(fp)
 20314e8:	10800383 	ldbu	r2,14(r2)
 20314ec:	10803fcc 	andi	r2,r2,255
 20314f0:	1000111e 	bne	r2,zero,2031538 <lwip_select+0x284>
              /* overflow - too many threads waiting */
              sock->select_waiting--;
 20314f4:	e0bfe917 	ldw	r2,-92(fp)
 20314f8:	10800383 	ldbu	r2,14(r2)
 20314fc:	10bfffc4 	addi	r2,r2,-1
 2031500:	1007883a 	mov	r3,r2
 2031504:	e0bfe917 	ldw	r2,-92(fp)
 2031508:	10c00385 	stb	r3,14(r2)
              nready = -1;
 203150c:	00bfffc4 	movi	r2,-1
 2031510:	e0bfe415 	stw	r2,-112(fp)
              maxfdp2 = i;
 2031514:	e0bfe617 	ldw	r2,-104(fp)
 2031518:	e0bfe715 	stw	r2,-100(fp)
              SYS_ARCH_UNPROTECT(lev);
 203151c:	e13fe817 	ldw	r4,-96(fp)
 2031520:	2014d200 	call	2014d20 <sys_arch_unprotect>
              done_socket(sock);
              set_errno(EBUSY);
 2031524:	20423b80 	call	20423b8 <__errno>
 2031528:	1007883a 	mov	r3,r2
 203152c:	00800404 	movi	r2,16
 2031530:	18800015 	stw	r2,0(r3)
              break;
 2031534:	00001406 	br	2031588 <lwip_select+0x2d4>
            }
            SYS_ARCH_UNPROTECT(lev);
 2031538:	e13fe817 	ldw	r4,-96(fp)
 203153c:	2014d200 	call	2014d20 <sys_arch_unprotect>
 2031540:	00000b06 	br	2031570 <lwip_select+0x2bc>
            done_socket(sock);
          } else {
            /* Not a valid socket */
            nready = -1;
 2031544:	00bfffc4 	movi	r2,-1
 2031548:	e0bfe415 	stw	r2,-112(fp)
            maxfdp2 = i;
 203154c:	e0bfe617 	ldw	r2,-104(fp)
 2031550:	e0bfe715 	stw	r2,-100(fp)
            SYS_ARCH_UNPROTECT(lev);
 2031554:	e13fe817 	ldw	r4,-96(fp)
 2031558:	2014d200 	call	2014d20 <sys_arch_unprotect>
            set_errno(EBADF);
 203155c:	20423b80 	call	20423b8 <__errno>
 2031560:	1007883a 	mov	r3,r2
 2031564:	00800244 	movi	r2,9
 2031568:	18800015 	stw	r2,0(r3)
            break;
 203156c:	00000606 	br	2031588 <lwip_select+0x2d4>

      lwip_link_select_cb(&API_SELECT_CB_VAR_REF(select_cb));

      /* Increase select_waiting for each socket we are interested in */
      maxfdp2 = maxfdp1;
      for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 2031570:	e0bfe617 	ldw	r2,-104(fp)
 2031574:	10800044 	addi	r2,r2,1
 2031578:	e0bfe615 	stw	r2,-104(fp)
 203157c:	e0ffe617 	ldw	r3,-104(fp)
 2031580:	e0bffb17 	ldw	r2,-20(fp)
 2031584:	18bfa016 	blt	r3,r2,2031408 <__alt_mem_mem_0+0xfd011408>
            break;
          }
        }
      }

      if (nready >= 0) {
 2031588:	e0bfe417 	ldw	r2,-112(fp)
 203158c:	10002a16 	blt	r2,zero,2031638 <lwip_select+0x384>
        /* Call lwip_selscan again: there could have been events between
           the last scan (without us on the list) and putting us on the list! */
        nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 2031590:	e0bff004 	addi	r2,fp,-64
 2031594:	d8800215 	stw	r2,8(sp)
 2031598:	e0bfee04 	addi	r2,fp,-72
 203159c:	d8800115 	stw	r2,4(sp)
 20315a0:	e0bfec04 	addi	r2,fp,-80
 20315a4:	d8800015 	stw	r2,0(sp)
 20315a8:	e1fffe17 	ldw	r7,-8(fp)
 20315ac:	e1bffd17 	ldw	r6,-12(fp)
 20315b0:	e17ffc17 	ldw	r5,-16(fp)
 20315b4:	e13ffb17 	ldw	r4,-20(fp)
 20315b8:	2030e8c0 	call	2030e8c <lwip_selscan>
 20315bc:	e0bfe415 	stw	r2,-112(fp)
        if (!nready) {
 20315c0:	e0bfe417 	ldw	r2,-112(fp)
 20315c4:	10001c1e 	bne	r2,zero,2031638 <lwip_select+0x384>
          /* Still none ready, just wait to be woken */
          if (timeout == 0) {
 20315c8:	e0800217 	ldw	r2,8(fp)
 20315cc:	1000021e 	bne	r2,zero,20315d8 <lwip_select+0x324>
            /* Wait forever */
            msectimeout = 0;
 20315d0:	e03fe515 	stw	zero,-108(fp)
 20315d4:	00001206 	br	2031620 <lwip_select+0x36c>
          } else {
            long msecs_long = ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500) / 1000));
 20315d8:	e0800217 	ldw	r2,8(fp)
 20315dc:	10800017 	ldw	r2,0(r2)
 20315e0:	1400fa24 	muli	r16,r2,1000
 20315e4:	e0800217 	ldw	r2,8(fp)
 20315e8:	10800117 	ldw	r2,4(r2)
 20315ec:	10807d04 	addi	r2,r2,500
 20315f0:	0140fa04 	movi	r5,1000
 20315f4:	1009883a 	mov	r4,r2
 20315f8:	200a9e40 	call	200a9e4 <__divsi3>
 20315fc:	8085883a 	add	r2,r16,r2
 2031600:	e0bfea15 	stw	r2,-88(fp)
            if (msecs_long <= 0) {
 2031604:	e0bfea17 	ldw	r2,-88(fp)
 2031608:	00800316 	blt	zero,r2,2031618 <lwip_select+0x364>
              /* Wait 1ms at least (0 means wait forever) */
              msectimeout = 1;
 203160c:	00800044 	movi	r2,1
 2031610:	e0bfe515 	stw	r2,-108(fp)
 2031614:	00000206 	br	2031620 <lwip_select+0x36c>
            } else {
              msectimeout = (u32_t)msecs_long;
 2031618:	e0bfea17 	ldw	r2,-88(fp)
 203161c:	e0bfe515 	stw	r2,-108(fp)
            }
          }

          waitres = sys_arch_sem_wait(SELECT_SEM_PTR(API_SELECT_CB_VAR_REF(select_cb).sem), msectimeout);
 2031620:	e0bff204 	addi	r2,fp,-56
 2031624:	10800804 	addi	r2,r2,32
 2031628:	e17fe517 	ldw	r5,-108(fp)
 203162c:	1009883a 	mov	r4,r2
 2031630:	20150800 	call	2015080 <sys_arch_sem_wait>
 2031634:	e0bfe315 	stw	r2,-116(fp)
#endif
        }
      }

      /* Decrease select_waiting for each socket we are interested in */
      for (i = LWIP_SOCKET_OFFSET; i < maxfdp2; i++) {
 2031638:	00800404 	movi	r2,16
 203163c:	e0bfe615 	stw	r2,-104(fp)
 2031640:	00004906 	br	2031768 <lwip_select+0x4b4>
        if ((readset && FD_ISSET(i, readset)) ||
 2031644:	e0bffc17 	ldw	r2,-16(fp)
 2031648:	10000c26 	beq	r2,zero,203167c <lwip_select+0x3c8>
 203164c:	e0bfe617 	ldw	r2,-104(fp)
 2031650:	1004d17a 	srli	r2,r2,5
 2031654:	e0fffc17 	ldw	r3,-16(fp)
 2031658:	1085883a 	add	r2,r2,r2
 203165c:	1085883a 	add	r2,r2,r2
 2031660:	1885883a 	add	r2,r3,r2
 2031664:	10c00017 	ldw	r3,0(r2)
 2031668:	e0bfe617 	ldw	r2,-104(fp)
 203166c:	108007cc 	andi	r2,r2,31
 2031670:	1885d83a 	sra	r2,r3,r2
 2031674:	1080004c 	andi	r2,r2,1
 2031678:	10001c1e 	bne	r2,zero,20316ec <lwip_select+0x438>
 203167c:	e0bffd17 	ldw	r2,-12(fp)
 2031680:	10000c26 	beq	r2,zero,20316b4 <lwip_select+0x400>
            (writeset && FD_ISSET(i, writeset)) ||
 2031684:	e0bfe617 	ldw	r2,-104(fp)
 2031688:	1004d17a 	srli	r2,r2,5
 203168c:	e0fffd17 	ldw	r3,-12(fp)
 2031690:	1085883a 	add	r2,r2,r2
 2031694:	1085883a 	add	r2,r2,r2
 2031698:	1885883a 	add	r2,r3,r2
 203169c:	10c00017 	ldw	r3,0(r2)
 20316a0:	e0bfe617 	ldw	r2,-104(fp)
 20316a4:	108007cc 	andi	r2,r2,31
 20316a8:	1885d83a 	sra	r2,r3,r2
 20316ac:	1080004c 	andi	r2,r2,1
 20316b0:	10000e1e 	bne	r2,zero,20316ec <lwip_select+0x438>
 20316b4:	e0bffe17 	ldw	r2,-8(fp)
 20316b8:	10002826 	beq	r2,zero,203175c <lwip_select+0x4a8>
            (exceptset && FD_ISSET(i, exceptset))) {
 20316bc:	e0bfe617 	ldw	r2,-104(fp)
 20316c0:	1004d17a 	srli	r2,r2,5
 20316c4:	e0fffe17 	ldw	r3,-8(fp)
 20316c8:	1085883a 	add	r2,r2,r2
 20316cc:	1085883a 	add	r2,r2,r2
 20316d0:	1885883a 	add	r2,r3,r2
 20316d4:	10c00017 	ldw	r3,0(r2)
 20316d8:	e0bfe617 	ldw	r2,-104(fp)
 20316dc:	108007cc 	andi	r2,r2,31
 20316e0:	1885d83a 	sra	r2,r3,r2
 20316e4:	1080004c 	andi	r2,r2,1
 20316e8:	10001c26 	beq	r2,zero,203175c <lwip_select+0x4a8>
          struct lwip_sock *sock;
          SYS_ARCH_PROTECT(lev);
 20316ec:	2014cec0 	call	2014cec <sys_arch_protect>
 20316f0:	e0bfe815 	stw	r2,-96(fp)
          sock = tryget_socket_unconn_nouse(i);
 20316f4:	e13fe617 	ldw	r4,-104(fp)
 20316f8:	202ebfc0 	call	202ebfc <tryget_socket_unconn_nouse>
 20316fc:	e0bfeb15 	stw	r2,-84(fp)
          LWIP_ASSERT("socket gone at the end of select", sock != NULL);
          if (sock != NULL) {
 2031700:	e0bfeb17 	ldw	r2,-84(fp)
 2031704:	10000d26 	beq	r2,zero,203173c <lwip_select+0x488>
            /* for now, handle select_waiting==0... */
            LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
            if (sock->select_waiting > 0) {
 2031708:	e0bfeb17 	ldw	r2,-84(fp)
 203170c:	10800383 	ldbu	r2,14(r2)
 2031710:	10803fcc 	andi	r2,r2,255
 2031714:	10000626 	beq	r2,zero,2031730 <lwip_select+0x47c>
              sock->select_waiting--;
 2031718:	e0bfeb17 	ldw	r2,-84(fp)
 203171c:	10800383 	ldbu	r2,14(r2)
 2031720:	10bfffc4 	addi	r2,r2,-1
 2031724:	1007883a 	mov	r3,r2
 2031728:	e0bfeb17 	ldw	r2,-84(fp)
 203172c:	10c00385 	stb	r3,14(r2)
            }
            SYS_ARCH_UNPROTECT(lev);
 2031730:	e13fe817 	ldw	r4,-96(fp)
 2031734:	2014d200 	call	2014d20 <sys_arch_unprotect>
 2031738:	00000806 	br	203175c <lwip_select+0x4a8>
          } else {
            SYS_ARCH_UNPROTECT(lev);
 203173c:	e13fe817 	ldw	r4,-96(fp)
 2031740:	2014d200 	call	2014d20 <sys_arch_unprotect>
            /* Not a valid socket */
            nready = -1;
 2031744:	00bfffc4 	movi	r2,-1
 2031748:	e0bfe415 	stw	r2,-112(fp)
            set_errno(EBADF);
 203174c:	20423b80 	call	20423b8 <__errno>
 2031750:	1007883a 	mov	r3,r2
 2031754:	00800244 	movi	r2,9
 2031758:	18800015 	stw	r2,0(r3)
#endif
        }
      }

      /* Decrease select_waiting for each socket we are interested in */
      for (i = LWIP_SOCKET_OFFSET; i < maxfdp2; i++) {
 203175c:	e0bfe617 	ldw	r2,-104(fp)
 2031760:	10800044 	addi	r2,r2,1
 2031764:	e0bfe615 	stw	r2,-104(fp)
 2031768:	e0ffe617 	ldw	r3,-104(fp)
 203176c:	e0bfe717 	ldw	r2,-100(fp)
 2031770:	18bfb416 	blt	r3,r2,2031644 <__alt_mem_mem_0+0xfd011644>
            set_errno(EBADF);
          }
        }
      }

      lwip_unlink_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
 2031774:	e0bff204 	addi	r2,fp,-56
 2031778:	1009883a 	mov	r4,r2
 203177c:	2030df40 	call	2030df4 <lwip_unlink_select_cb>
      if (API_SELECT_CB_VAR_REF(select_cb).sem_signalled && (!waited || (waitres == SYS_ARCH_TIMEOUT))) {
        /* don't leave the thread-local semaphore signalled */
        sys_arch_sem_wait(API_SELECT_CB_VAR_REF(select_cb).sem, 1);
      }
#else /* LWIP_NETCONN_SEM_PER_THREAD */
      sys_sem_free(&API_SELECT_CB_VAR_REF(select_cb).sem);
 2031780:	e0bff204 	addi	r2,fp,-56
 2031784:	10800804 	addi	r2,r2,32
 2031788:	1009883a 	mov	r4,r2
 203178c:	20151040 	call	2015104 <sys_sem_free>
#endif /* LWIP_NETCONN_SEM_PER_THREAD */
      API_SELECT_CB_VAR_FREE(select_cb);

      if (nready < 0) {
 2031790:	e0bfe417 	ldw	r2,-112(fp)
 2031794:	1000020e 	bge	r2,zero,20317a0 <lwip_select+0x4ec>
        /* This happens when a socket got closed while waiting */
        lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
        return -1;
 2031798:	00bfffc4 	movi	r2,-1
 203179c:	00002506 	br	2031834 <lwip_select+0x580>
      }

      if (waitres == SYS_ARCH_TIMEOUT) {
 20317a0:	e0bfe317 	ldw	r2,-116(fp)
 20317a4:	10bfffe0 	cmpeqi	r2,r2,-1
 20317a8:	10000c1e 	bne	r2,zero,20317dc <lwip_select+0x528>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
        /* This is OK as the local fdsets are empty and nready is zero,
           or we would have returned earlier. */
      } else {
        /* See what's set now after waiting */
        nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 20317ac:	e0bff004 	addi	r2,fp,-64
 20317b0:	d8800215 	stw	r2,8(sp)
 20317b4:	e0bfee04 	addi	r2,fp,-72
 20317b8:	d8800115 	stw	r2,4(sp)
 20317bc:	e0bfec04 	addi	r2,fp,-80
 20317c0:	d8800015 	stw	r2,0(sp)
 20317c4:	e1fffe17 	ldw	r7,-8(fp)
 20317c8:	e1bffd17 	ldw	r6,-12(fp)
 20317cc:	e17ffc17 	ldw	r5,-16(fp)
 20317d0:	e13ffb17 	ldw	r4,-20(fp)
 20317d4:	2030e8c0 	call	2030e8c <lwip_selscan>
 20317d8:	e0bfe415 	stw	r2,-112(fp)
    }
  }

  lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
  set_errno(0);
  if (readset) {
 20317dc:	e0bffc17 	ldw	r2,-16(fp)
 20317e0:	10000526 	beq	r2,zero,20317f8 <lwip_select+0x544>
    *readset = lreadset;
 20317e4:	e0bffc17 	ldw	r2,-16(fp)
 20317e8:	e0ffec17 	ldw	r3,-80(fp)
 20317ec:	10c00015 	stw	r3,0(r2)
 20317f0:	e0ffed17 	ldw	r3,-76(fp)
 20317f4:	10c00115 	stw	r3,4(r2)
  }
  if (writeset) {
 20317f8:	e0bffd17 	ldw	r2,-12(fp)
 20317fc:	10000526 	beq	r2,zero,2031814 <lwip_select+0x560>
    *writeset = lwriteset;
 2031800:	e0bffd17 	ldw	r2,-12(fp)
 2031804:	e0ffee17 	ldw	r3,-72(fp)
 2031808:	10c00015 	stw	r3,0(r2)
 203180c:	e0ffef17 	ldw	r3,-68(fp)
 2031810:	10c00115 	stw	r3,4(r2)
  }
  if (exceptset) {
 2031814:	e0bffe17 	ldw	r2,-8(fp)
 2031818:	10000526 	beq	r2,zero,2031830 <lwip_select+0x57c>
    *exceptset = lexceptset;
 203181c:	e0bffe17 	ldw	r2,-8(fp)
 2031820:	e0fff017 	ldw	r3,-64(fp)
 2031824:	10c00015 	stw	r3,0(r2)
 2031828:	e0fff117 	ldw	r3,-60(fp)
 203182c:	10c00115 	stw	r3,4(r2)
  }
  return nready;
 2031830:	e0bfe417 	ldw	r2,-112(fp)
}
 2031834:	e6ffff04 	addi	sp,fp,-4
 2031838:	dfc00217 	ldw	ra,8(sp)
 203183c:	df000117 	ldw	fp,4(sp)
 2031840:	dc000017 	ldw	r16,0(sp)
 2031844:	dec00304 	addi	sp,sp,12
 2031848:	f800283a 	ret

0203184c <lwip_pollscan>:
 * @param opts         what to update and how
 * @return number of structures that have revents != 0
 */
static int
lwip_pollscan(struct pollfd *fds, nfds_t nfds, enum lwip_pollscan_opts opts)
{
 203184c:	defff404 	addi	sp,sp,-48
 2031850:	dfc00b15 	stw	ra,44(sp)
 2031854:	df000a15 	stw	fp,40(sp)
 2031858:	df000a04 	addi	fp,sp,40
 203185c:	e13ffd15 	stw	r4,-12(fp)
 2031860:	e17ffe15 	stw	r5,-8(fp)
 2031864:	e1bfff15 	stw	r6,-4(fp)
  int nready = 0;
 2031868:	e03ff615 	stw	zero,-40(fp)
  nfds_t fdi;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  /* Go through each struct pollfd in the array. */
  for (fdi = 0; fdi < nfds; fdi++) {
 203186c:	e03ff715 	stw	zero,-36(fp)
 2031870:	0000ad06 	br	2031b28 <lwip_pollscan+0x2dc>
    if ((opts & LWIP_POLLSCAN_CLEAR) != 0) {
 2031874:	e0bfff17 	ldw	r2,-4(fp)
 2031878:	1080004c 	andi	r2,r2,1
 203187c:	10000526 	beq	r2,zero,2031894 <lwip_pollscan+0x48>
      fds[fdi].revents = 0;
 2031880:	e0bff717 	ldw	r2,-36(fp)
 2031884:	100490fa 	slli	r2,r2,3
 2031888:	e0fffd17 	ldw	r3,-12(fp)
 203188c:	1885883a 	add	r2,r3,r2
 2031890:	1000018d 	sth	zero,6(r2)

    /* Negative fd means the caller wants us to ignore this struct.
       POLLNVAL means we already detected that the fd is invalid;
       if another thread has since opened a new socket with that fd,
       we must not use that socket. */
    if (fds[fdi].fd >= 0 && (fds[fdi].revents & POLLNVAL) == 0) {
 2031894:	e0bff717 	ldw	r2,-36(fp)
 2031898:	100490fa 	slli	r2,r2,3
 203189c:	e0fffd17 	ldw	r3,-12(fp)
 20318a0:	1885883a 	add	r2,r3,r2
 20318a4:	10800017 	ldw	r2,0(r2)
 20318a8:	10009016 	blt	r2,zero,2031aec <lwip_pollscan+0x2a0>
 20318ac:	e0bff717 	ldw	r2,-36(fp)
 20318b0:	100490fa 	slli	r2,r2,3
 20318b4:	e0fffd17 	ldw	r3,-12(fp)
 20318b8:	1885883a 	add	r2,r3,r2
 20318bc:	1080018b 	ldhu	r2,6(r2)
 20318c0:	10bfffcc 	andi	r2,r2,65535
 20318c4:	1080020c 	andi	r2,r2,8
 20318c8:	1000881e 	bne	r2,zero,2031aec <lwip_pollscan+0x2a0>
      /* First get the socket's status (protected)... */
      SYS_ARCH_PROTECT(lev);
 20318cc:	2014cec0 	call	2014cec <sys_arch_protect>
 20318d0:	e0bff815 	stw	r2,-32(fp)
      sock = tryget_socket_unconn_locked(fds[fdi].fd);
 20318d4:	e0bff717 	ldw	r2,-36(fp)
 20318d8:	100490fa 	slli	r2,r2,3
 20318dc:	e0fffd17 	ldw	r3,-12(fp)
 20318e0:	1885883a 	add	r2,r3,r2
 20318e4:	10800017 	ldw	r2,0(r2)
 20318e8:	1009883a 	mov	r4,r2
 20318ec:	202ecc00 	call	202ecc0 <tryget_socket_unconn_locked>
 20318f0:	e0bff915 	stw	r2,-28(fp)
      if (sock != NULL) {
 20318f4:	e0bff917 	ldw	r2,-28(fp)
 20318f8:	10006d26 	beq	r2,zero,2031ab0 <lwip_pollscan+0x264>
        void* lastdata = sock->lastdata.pbuf;
 20318fc:	e0bff917 	ldw	r2,-28(fp)
 2031900:	10800117 	ldw	r2,4(r2)
 2031904:	e0bffa15 	stw	r2,-24(fp)
        s16_t rcvevent = sock->rcvevent;
 2031908:	e0bff917 	ldw	r2,-28(fp)
 203190c:	1080020b 	ldhu	r2,8(r2)
 2031910:	e0bffb0d 	sth	r2,-20(fp)
        u16_t sendevent = sock->sendevent;
 2031914:	e0bff917 	ldw	r2,-28(fp)
 2031918:	1080028b 	ldhu	r2,10(r2)
 203191c:	e0bffb8d 	sth	r2,-18(fp)
        u16_t errevent = sock->errevent;
 2031920:	e0bff917 	ldw	r2,-28(fp)
 2031924:	1080030b 	ldhu	r2,12(r2)
 2031928:	e0bffc0d 	sth	r2,-16(fp)

        if ((opts & LWIP_POLLSCAN_INC_WAIT) != 0) {
 203192c:	e0bfff17 	ldw	r2,-4(fp)
 2031930:	1080008c 	andi	r2,r2,2
 2031934:	10001526 	beq	r2,zero,203198c <lwip_pollscan+0x140>
          sock->select_waiting++;
 2031938:	e0bff917 	ldw	r2,-28(fp)
 203193c:	10800383 	ldbu	r2,14(r2)
 2031940:	10800044 	addi	r2,r2,1
 2031944:	1007883a 	mov	r3,r2
 2031948:	e0bff917 	ldw	r2,-28(fp)
 203194c:	10c00385 	stb	r3,14(r2)
          if (sock->select_waiting == 0) {
 2031950:	e0bff917 	ldw	r2,-28(fp)
 2031954:	10800383 	ldbu	r2,14(r2)
 2031958:	10803fcc 	andi	r2,r2,255
 203195c:	1000181e 	bne	r2,zero,20319c0 <lwip_pollscan+0x174>
            /* overflow - too many threads waiting */
            sock->select_waiting--;
 2031960:	e0bff917 	ldw	r2,-28(fp)
 2031964:	10800383 	ldbu	r2,14(r2)
 2031968:	10bfffc4 	addi	r2,r2,-1
 203196c:	1007883a 	mov	r3,r2
 2031970:	e0bff917 	ldw	r2,-28(fp)
 2031974:	10c00385 	stb	r3,14(r2)
            nready = -1;
 2031978:	00bfffc4 	movi	r2,-1
 203197c:	e0bff615 	stw	r2,-40(fp)
            SYS_ARCH_UNPROTECT(lev);
 2031980:	e13ff817 	ldw	r4,-32(fp)
 2031984:	2014d200 	call	2014d20 <sys_arch_unprotect>
            done_socket(sock);
            break;
 2031988:	00006a06 	br	2031b34 <lwip_pollscan+0x2e8>
          }
        } else if ((opts & LWIP_POLLSCAN_DEC_WAIT) != 0) {
 203198c:	e0bfff17 	ldw	r2,-4(fp)
 2031990:	1080010c 	andi	r2,r2,4
 2031994:	10000a26 	beq	r2,zero,20319c0 <lwip_pollscan+0x174>
          /* for now, handle select_waiting==0... */
          LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
          if (sock->select_waiting > 0) {
 2031998:	e0bff917 	ldw	r2,-28(fp)
 203199c:	10800383 	ldbu	r2,14(r2)
 20319a0:	10803fcc 	andi	r2,r2,255
 20319a4:	10000626 	beq	r2,zero,20319c0 <lwip_pollscan+0x174>
            sock->select_waiting--;
 20319a8:	e0bff917 	ldw	r2,-28(fp)
 20319ac:	10800383 	ldbu	r2,14(r2)
 20319b0:	10bfffc4 	addi	r2,r2,-1
 20319b4:	1007883a 	mov	r3,r2
 20319b8:	e0bff917 	ldw	r2,-28(fp)
 20319bc:	10c00385 	stb	r3,14(r2)
          }
        }
        SYS_ARCH_UNPROTECT(lev);
 20319c0:	e13ff817 	ldw	r4,-32(fp)
 20319c4:	2014d200 	call	2014d20 <sys_arch_unprotect>
        done_socket(sock);

        /* ... then examine it: */
        /* See if netconn of this socket is ready for read */
        if ((fds[fdi].events & POLLIN) != 0 && ((lastdata != NULL) || (rcvevent > 0))) {
 20319c8:	e0bff717 	ldw	r2,-36(fp)
 20319cc:	100490fa 	slli	r2,r2,3
 20319d0:	e0fffd17 	ldw	r3,-12(fp)
 20319d4:	1885883a 	add	r2,r3,r2
 20319d8:	1080010b 	ldhu	r2,4(r2)
 20319dc:	10bfffcc 	andi	r2,r2,65535
 20319e0:	1080004c 	andi	r2,r2,1
 20319e4:	10000f26 	beq	r2,zero,2031a24 <lwip_pollscan+0x1d8>
 20319e8:	e0bffa17 	ldw	r2,-24(fp)
 20319ec:	1000021e 	bne	r2,zero,20319f8 <lwip_pollscan+0x1ac>
 20319f0:	e0bffb0f 	ldh	r2,-20(fp)
 20319f4:	00800b0e 	bge	zero,r2,2031a24 <lwip_pollscan+0x1d8>
          fds[fdi].revents |= POLLIN;
 20319f8:	e0bff717 	ldw	r2,-36(fp)
 20319fc:	100490fa 	slli	r2,r2,3
 2031a00:	e0fffd17 	ldw	r3,-12(fp)
 2031a04:	1885883a 	add	r2,r3,r2
 2031a08:	e0fff717 	ldw	r3,-36(fp)
 2031a0c:	180690fa 	slli	r3,r3,3
 2031a10:	e13ffd17 	ldw	r4,-12(fp)
 2031a14:	20c7883a 	add	r3,r4,r3
 2031a18:	18c0018b 	ldhu	r3,6(r3)
 2031a1c:	18c00054 	ori	r3,r3,1
 2031a20:	10c0018d 	sth	r3,6(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for reading\n", fds[fdi].fd));
        }
        /* See if netconn of this socket is ready for write */
        if ((fds[fdi].events & POLLOUT) != 0 && (sendevent != 0)) {
 2031a24:	e0bff717 	ldw	r2,-36(fp)
 2031a28:	100490fa 	slli	r2,r2,3
 2031a2c:	e0fffd17 	ldw	r3,-12(fp)
 2031a30:	1885883a 	add	r2,r3,r2
 2031a34:	1080010b 	ldhu	r2,4(r2)
 2031a38:	10bfffcc 	andi	r2,r2,65535
 2031a3c:	1080008c 	andi	r2,r2,2
 2031a40:	10000d26 	beq	r2,zero,2031a78 <lwip_pollscan+0x22c>
 2031a44:	e0bffb8b 	ldhu	r2,-18(fp)
 2031a48:	10000b26 	beq	r2,zero,2031a78 <lwip_pollscan+0x22c>
          fds[fdi].revents |= POLLOUT;
 2031a4c:	e0bff717 	ldw	r2,-36(fp)
 2031a50:	100490fa 	slli	r2,r2,3
 2031a54:	e0fffd17 	ldw	r3,-12(fp)
 2031a58:	1885883a 	add	r2,r3,r2
 2031a5c:	e0fff717 	ldw	r3,-36(fp)
 2031a60:	180690fa 	slli	r3,r3,3
 2031a64:	e13ffd17 	ldw	r4,-12(fp)
 2031a68:	20c7883a 	add	r3,r4,r3
 2031a6c:	18c0018b 	ldhu	r3,6(r3)
 2031a70:	18c00094 	ori	r3,r3,2
 2031a74:	10c0018d 	sth	r3,6(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for writing\n", fds[fdi].fd));
        }
        /* See if netconn of this socket had an error */
        if (errevent != 0) {
 2031a78:	e0bffc0b 	ldhu	r2,-16(fp)
 2031a7c:	10001b26 	beq	r2,zero,2031aec <lwip_pollscan+0x2a0>
          /* POLLERR is output only. */
          fds[fdi].revents |= POLLERR;
 2031a80:	e0bff717 	ldw	r2,-36(fp)
 2031a84:	100490fa 	slli	r2,r2,3
 2031a88:	e0fffd17 	ldw	r3,-12(fp)
 2031a8c:	1885883a 	add	r2,r3,r2
 2031a90:	e0fff717 	ldw	r3,-36(fp)
 2031a94:	180690fa 	slli	r3,r3,3
 2031a98:	e13ffd17 	ldw	r4,-12(fp)
 2031a9c:	20c7883a 	add	r3,r4,r3
 2031aa0:	18c0018b 	ldhu	r3,6(r3)
 2031aa4:	18c00114 	ori	r3,r3,4
 2031aa8:	10c0018d 	sth	r3,6(r2)
 2031aac:	00000f06 	br	2031aec <lwip_pollscan+0x2a0>
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for exception\n", fds[fdi].fd));
        }
      } else {
        /* Not a valid socket */
        SYS_ARCH_UNPROTECT(lev);
 2031ab0:	e13ff817 	ldw	r4,-32(fp)
 2031ab4:	2014d200 	call	2014d20 <sys_arch_unprotect>
        /* POLLNVAL is output only. */
        fds[fdi].revents |= POLLNVAL;
 2031ab8:	e0bff717 	ldw	r2,-36(fp)
 2031abc:	100490fa 	slli	r2,r2,3
 2031ac0:	e0fffd17 	ldw	r3,-12(fp)
 2031ac4:	1885883a 	add	r2,r3,r2
 2031ac8:	e0fff717 	ldw	r3,-36(fp)
 2031acc:	180690fa 	slli	r3,r3,3
 2031ad0:	e13ffd17 	ldw	r4,-12(fp)
 2031ad4:	20c7883a 	add	r3,r4,r3
 2031ad8:	18c0018b 	ldhu	r3,6(r3)
 2031adc:	18c00214 	ori	r3,r3,8
 2031ae0:	10c0018d 	sth	r3,6(r2)
        return -1;
 2031ae4:	00bfffc4 	movi	r2,-1
 2031ae8:	00001306 	br	2031b38 <lwip_pollscan+0x2ec>
      }
    }

    /* Will return the number of structures that have events,
       not the number of events. */
    if (fds[fdi].revents != 0) {
 2031aec:	e0bff717 	ldw	r2,-36(fp)
 2031af0:	100490fa 	slli	r2,r2,3
 2031af4:	e0fffd17 	ldw	r3,-12(fp)
 2031af8:	1885883a 	add	r2,r3,r2
 2031afc:	1080018b 	ldhu	r2,6(r2)
 2031b00:	10bfffcc 	andi	r2,r2,65535
 2031b04:	10a0001c 	xori	r2,r2,32768
 2031b08:	10a00004 	addi	r2,r2,-32768
 2031b0c:	10000326 	beq	r2,zero,2031b1c <lwip_pollscan+0x2d0>
      nready++;
 2031b10:	e0bff617 	ldw	r2,-40(fp)
 2031b14:	10800044 	addi	r2,r2,1
 2031b18:	e0bff615 	stw	r2,-40(fp)
  nfds_t fdi;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  /* Go through each struct pollfd in the array. */
  for (fdi = 0; fdi < nfds; fdi++) {
 2031b1c:	e0bff717 	ldw	r2,-36(fp)
 2031b20:	10800044 	addi	r2,r2,1
 2031b24:	e0bff715 	stw	r2,-36(fp)
 2031b28:	e0fff717 	ldw	r3,-36(fp)
 2031b2c:	e0bffe17 	ldw	r2,-8(fp)
 2031b30:	18bf5036 	bltu	r3,r2,2031874 <__alt_mem_mem_0+0xfd011874>
      nready++;
    }
  }

  LWIP_ASSERT("nready >= 0", nready >= 0);
  return nready;
 2031b34:	e0bff617 	ldw	r2,-40(fp)
}
 2031b38:	e037883a 	mov	sp,fp
 2031b3c:	dfc00117 	ldw	ra,4(sp)
 2031b40:	df000017 	ldw	fp,0(sp)
 2031b44:	dec00204 	addi	sp,sp,8
 2031b48:	f800283a 	ret

02031b4c <lwip_poll>:
#define lwip_poll_dec_sockets_used(fds, nfds)
#endif /* LWIP_NETCONN_FULLDUPLEX */

int
lwip_poll(struct pollfd *fds, nfds_t nfds, int timeout)
{
 2031b4c:	deffef04 	addi	sp,sp,-68
 2031b50:	dfc01015 	stw	ra,64(sp)
 2031b54:	df000f15 	stw	fp,60(sp)
 2031b58:	df000f04 	addi	fp,sp,60
 2031b5c:	e13ffd15 	stw	r4,-12(fp)
 2031b60:	e17ffe15 	stw	r5,-8(fp)
 2031b64:	e1bfff15 	stw	r6,-4(fp)
  u32_t waitres = 0;
 2031b68:	e03ff115 	stw	zero,-60(fp)
  int waited = 0;
#endif

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll(%p, %d, %d)\n",
                  (void*)fds, (int)nfds, timeout));
  LWIP_ERROR("lwip_poll: invalid fds", ((fds != NULL && nfds > 0) || (fds == NULL && nfds == 0)),
 2031b6c:	e0bffd17 	ldw	r2,-12(fp)
 2031b70:	10000226 	beq	r2,zero,2031b7c <lwip_poll+0x30>
 2031b74:	e0bffe17 	ldw	r2,-8(fp)
 2031b78:	10000a1e 	bne	r2,zero,2031ba4 <lwip_poll+0x58>
 2031b7c:	e0bffd17 	ldw	r2,-12(fp)
 2031b80:	1000021e 	bne	r2,zero,2031b8c <lwip_poll+0x40>
 2031b84:	e0bffe17 	ldw	r2,-8(fp)
 2031b88:	10000626 	beq	r2,zero,2031ba4 <lwip_poll+0x58>
 2031b8c:	20423b80 	call	20423b8 <__errno>
 2031b90:	1007883a 	mov	r3,r2
 2031b94:	00800584 	movi	r2,22
 2031b98:	18800015 	stw	r2,0(r3)
 2031b9c:	00bfffc4 	movi	r2,-1
 2031ba0:	00005206 	br	2031cec <lwip_poll+0x1a0>

  lwip_poll_inc_sockets_used(fds, nfds);

  /* Go through each struct pollfd to count number of structures
     which currently match */
  nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_CLEAR);
 2031ba4:	01800044 	movi	r6,1
 2031ba8:	e17ffe17 	ldw	r5,-8(fp)
 2031bac:	e13ffd17 	ldw	r4,-12(fp)
 2031bb0:	203184c0 	call	203184c <lwip_pollscan>
 2031bb4:	e0bff215 	stw	r2,-56(fp)

  if (nready < 0) {
 2031bb8:	e0bff217 	ldw	r2,-56(fp)
 2031bbc:	1000020e 	bge	r2,zero,2031bc8 <lwip_poll+0x7c>
    lwip_poll_dec_sockets_used(fds, nfds);
    return -1;
 2031bc0:	00bfffc4 	movi	r2,-1
 2031bc4:	00004906 	br	2031cec <lwip_poll+0x1a0>
  }

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
 2031bc8:	e0bff217 	ldw	r2,-56(fp)
 2031bcc:	1000461e 	bne	r2,zero,2031ce8 <lwip_poll+0x19c>
    API_SELECT_CB_VAR_DECLARE(select_cb);

    if (timeout == 0) {
 2031bd0:	e0bfff17 	ldw	r2,-4(fp)
 2031bd4:	10004326 	beq	r2,zero,2031ce4 <lwip_poll+0x198>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: no timeout, returning 0\n"));
      goto return_success;
    }
    API_SELECT_CB_VAR_ALLOC(select_cb, set_errno(EAGAIN); lwip_poll_dec_sockets_used(fds, nfds); return -1);
    memset(&API_SELECT_CB_VAR_REF(select_cb), 0, sizeof(struct lwip_select_cb));
 2031bd8:	e0bff404 	addi	r2,fp,-48
 2031bdc:	01800904 	movi	r6,36
 2031be0:	000b883a 	mov	r5,zero
 2031be4:	1009883a 	mov	r4,r2
 2031be8:	2005fa00 	call	2005fa0 <memset>
    /* None ready: add our semaphore to list:
       We don't actually need any dynamic memory. Our entry on the
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    API_SELECT_CB_VAR_REF(select_cb).poll_fds = fds;
 2031bec:	e0bffd17 	ldw	r2,-12(fp)
 2031bf0:	e0bff915 	stw	r2,-28(fp)
    API_SELECT_CB_VAR_REF(select_cb).poll_nfds = nfds;
 2031bf4:	e0bffe17 	ldw	r2,-8(fp)
 2031bf8:	e0bffa15 	stw	r2,-24(fp)
#if LWIP_NETCONN_SEM_PER_THREAD
    API_SELECT_CB_VAR_REF(select_cb).sem = LWIP_NETCONN_THREAD_SEM_GET();
#else /* LWIP_NETCONN_SEM_PER_THREAD */
    if (sys_sem_new(&API_SELECT_CB_VAR_REF(select_cb).sem, 0) != ERR_OK) {
 2031bfc:	e0bff404 	addi	r2,fp,-48
 2031c00:	10800804 	addi	r2,r2,32
 2031c04:	000b883a 	mov	r5,zero
 2031c08:	1009883a 	mov	r4,r2
 2031c0c:	2014f380 	call	2014f38 <sys_sem_new>
 2031c10:	10803fcc 	andi	r2,r2,255
 2031c14:	1080201c 	xori	r2,r2,128
 2031c18:	10bfe004 	addi	r2,r2,-128
 2031c1c:	10000626 	beq	r2,zero,2031c38 <lwip_poll+0xec>
      /* failed to create semaphore */
      set_errno(EAGAIN);
 2031c20:	20423b80 	call	20423b8 <__errno>
 2031c24:	1007883a 	mov	r3,r2
 2031c28:	008002c4 	movi	r2,11
 2031c2c:	18800015 	stw	r2,0(r3)
      lwip_poll_dec_sockets_used(fds, nfds);
      API_SELECT_CB_VAR_FREE(select_cb);
      return -1;
 2031c30:	00bfffc4 	movi	r2,-1
 2031c34:	00002d06 	br	2031cec <lwip_poll+0x1a0>
    }
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

    lwip_link_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
 2031c38:	e0bff404 	addi	r2,fp,-48
 2031c3c:	1009883a 	mov	r4,r2
 2031c40:	2030d840 	call	2030d84 <lwip_link_select_cb>

    /* Increase select_waiting for each socket we are interested in.
       Also, check for events again: there could have been events between
       the last scan (without us on the list) and putting us on the list! */
    nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_INC_WAIT);
 2031c44:	01800084 	movi	r6,2
 2031c48:	e17ffe17 	ldw	r5,-8(fp)
 2031c4c:	e13ffd17 	ldw	r4,-12(fp)
 2031c50:	203184c0 	call	203184c <lwip_pollscan>
 2031c54:	e0bff215 	stw	r2,-56(fp)

    if (!nready) {
 2031c58:	e0bff217 	ldw	r2,-56(fp)
 2031c5c:	10000c1e 	bne	r2,zero,2031c90 <lwip_poll+0x144>
      /* Still none ready, just wait to be woken */
      if (timeout < 0) {
 2031c60:	e0bfff17 	ldw	r2,-4(fp)
 2031c64:	1000020e 	bge	r2,zero,2031c70 <lwip_poll+0x124>
        /* Wait forever */
        msectimeout = 0;
 2031c68:	e03ff315 	stw	zero,-52(fp)
 2031c6c:	00000206 	br	2031c78 <lwip_poll+0x12c>
      } else {
        /* timeout == 0 would have been handled earlier. */
        LWIP_ASSERT("timeout > 0", timeout > 0);
        msectimeout = timeout;
 2031c70:	e0bfff17 	ldw	r2,-4(fp)
 2031c74:	e0bff315 	stw	r2,-52(fp)
      }
      waitres = sys_arch_sem_wait(SELECT_SEM_PTR(API_SELECT_CB_VAR_REF(select_cb).sem), msectimeout);
 2031c78:	e0bff404 	addi	r2,fp,-48
 2031c7c:	10800804 	addi	r2,r2,32
 2031c80:	e17ff317 	ldw	r5,-52(fp)
 2031c84:	1009883a 	mov	r4,r2
 2031c88:	20150800 	call	2015080 <sys_arch_sem_wait>
 2031c8c:	e0bff115 	stw	r2,-60(fp)
#endif
    }

    /* Decrease select_waiting for each socket we are interested in,
       and check which events occurred while we waited. */
    nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_DEC_WAIT);
 2031c90:	01800104 	movi	r6,4
 2031c94:	e17ffe17 	ldw	r5,-8(fp)
 2031c98:	e13ffd17 	ldw	r4,-12(fp)
 2031c9c:	203184c0 	call	203184c <lwip_pollscan>
 2031ca0:	e0bff215 	stw	r2,-56(fp)

    lwip_unlink_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
 2031ca4:	e0bff404 	addi	r2,fp,-48
 2031ca8:	1009883a 	mov	r4,r2
 2031cac:	2030df40 	call	2030df4 <lwip_unlink_select_cb>
    if (select_cb.sem_signalled && (!waited || (waitres == SYS_ARCH_TIMEOUT))) {
      /* don't leave the thread-local semaphore signalled */
      sys_arch_sem_wait(API_SELECT_CB_VAR_REF(select_cb).sem, 1);
    }
#else /* LWIP_NETCONN_SEM_PER_THREAD */
    sys_sem_free(&API_SELECT_CB_VAR_REF(select_cb).sem);
 2031cb0:	e0bff404 	addi	r2,fp,-48
 2031cb4:	10800804 	addi	r2,r2,32
 2031cb8:	1009883a 	mov	r4,r2
 2031cbc:	20151040 	call	2015104 <sys_sem_free>
#endif /* LWIP_NETCONN_SEM_PER_THREAD */
    API_SELECT_CB_VAR_FREE(select_cb);

    if (nready < 0) {
 2031cc0:	e0bff217 	ldw	r2,-56(fp)
 2031cc4:	1000020e 	bge	r2,zero,2031cd0 <lwip_poll+0x184>
      /* This happens when a socket got closed while waiting */
      lwip_poll_dec_sockets_used(fds, nfds);
      return -1;
 2031cc8:	00bfffc4 	movi	r2,-1
 2031ccc:	00000706 	br	2031cec <lwip_poll+0x1a0>
    }

    if (waitres == SYS_ARCH_TIMEOUT) {
 2031cd0:	e0bff117 	ldw	r2,-60(fp)
 2031cd4:	10bfffd8 	cmpnei	r2,r2,-1
 2031cd8:	1000031e 	bne	r2,zero,2031ce8 <lwip_poll+0x19c>
      /* Timeout */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: timeout expired\n"));
      goto return_success;
 2031cdc:	0001883a 	nop
 2031ce0:	00000106 	br	2031ce8 <lwip_poll+0x19c>
  if (!nready) {
    API_SELECT_CB_VAR_DECLARE(select_cb);

    if (timeout == 0) {
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: no timeout, returning 0\n"));
      goto return_success;
 2031ce4:	0001883a 	nop

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: nready=%d\n", nready));
return_success:
  lwip_poll_dec_sockets_used(fds, nfds);
  set_errno(0);
  return nready;
 2031ce8:	e0bff217 	ldw	r2,-56(fp)
}
 2031cec:	e037883a 	mov	sp,fp
 2031cf0:	dfc00117 	ldw	ra,4(sp)
 2031cf4:	df000017 	ldw	fp,0(sp)
 2031cf8:	dec00204 	addi	sp,sp,8
 2031cfc:	f800283a 	ret

02031d00 <lwip_poll_should_wake>:
 * Check whether event_callback should wake up a thread waiting in
 * lwip_poll.
 */
static int
lwip_poll_should_wake(const struct lwip_select_cb *scb, int fd, int has_recvevent, int has_sendevent, int has_errevent)
{
 2031d00:	defff904 	addi	sp,sp,-28
 2031d04:	df000615 	stw	fp,24(sp)
 2031d08:	df000604 	addi	fp,sp,24
 2031d0c:	e13ffc15 	stw	r4,-16(fp)
 2031d10:	e17ffd15 	stw	r5,-12(fp)
 2031d14:	e1bffe15 	stw	r6,-8(fp)
 2031d18:	e1ffff15 	stw	r7,-4(fp)
  nfds_t fdi;
  for (fdi = 0; fdi < scb->poll_nfds; fdi++) {
 2031d1c:	e03ffa15 	stw	zero,-24(fp)
 2031d20:	00002306 	br	2031db0 <lwip_poll_should_wake+0xb0>
    const struct pollfd *pollfd = &scb->poll_fds[fdi];
 2031d24:	e0bffc17 	ldw	r2,-16(fp)
 2031d28:	10c00517 	ldw	r3,20(r2)
 2031d2c:	e0bffa17 	ldw	r2,-24(fp)
 2031d30:	100490fa 	slli	r2,r2,3
 2031d34:	1885883a 	add	r2,r3,r2
 2031d38:	e0bffb15 	stw	r2,-20(fp)
    if (pollfd->fd == fd) {
 2031d3c:	e0bffb17 	ldw	r2,-20(fp)
 2031d40:	10c00017 	ldw	r3,0(r2)
 2031d44:	e0bffd17 	ldw	r2,-12(fp)
 2031d48:	1880161e 	bne	r3,r2,2031da4 <lwip_poll_should_wake+0xa4>
      /* Do not update pollfd->revents right here;
         that would be a data race because lwip_pollscan
         accesses revents without protecting. */
      if (has_recvevent && (pollfd->events & POLLIN) != 0) {
 2031d4c:	e0bffe17 	ldw	r2,-8(fp)
 2031d50:	10000726 	beq	r2,zero,2031d70 <lwip_poll_should_wake+0x70>
 2031d54:	e0bffb17 	ldw	r2,-20(fp)
 2031d58:	1080010b 	ldhu	r2,4(r2)
 2031d5c:	10bfffcc 	andi	r2,r2,65535
 2031d60:	1080004c 	andi	r2,r2,1
 2031d64:	10000226 	beq	r2,zero,2031d70 <lwip_poll_should_wake+0x70>
        return 1;
 2031d68:	00800044 	movi	r2,1
 2031d6c:	00001506 	br	2031dc4 <lwip_poll_should_wake+0xc4>
      }
      if (has_sendevent && (pollfd->events & POLLOUT) != 0) {
 2031d70:	e0bfff17 	ldw	r2,-4(fp)
 2031d74:	10000726 	beq	r2,zero,2031d94 <lwip_poll_should_wake+0x94>
 2031d78:	e0bffb17 	ldw	r2,-20(fp)
 2031d7c:	1080010b 	ldhu	r2,4(r2)
 2031d80:	10bfffcc 	andi	r2,r2,65535
 2031d84:	1080008c 	andi	r2,r2,2
 2031d88:	10000226 	beq	r2,zero,2031d94 <lwip_poll_should_wake+0x94>
        return 1;
 2031d8c:	00800044 	movi	r2,1
 2031d90:	00000c06 	br	2031dc4 <lwip_poll_should_wake+0xc4>
      }
      if (has_errevent) {
 2031d94:	e0800117 	ldw	r2,4(fp)
 2031d98:	10000226 	beq	r2,zero,2031da4 <lwip_poll_should_wake+0xa4>
        /* POLLERR is output only. */
        return 1;
 2031d9c:	00800044 	movi	r2,1
 2031da0:	00000806 	br	2031dc4 <lwip_poll_should_wake+0xc4>
 */
static int
lwip_poll_should_wake(const struct lwip_select_cb *scb, int fd, int has_recvevent, int has_sendevent, int has_errevent)
{
  nfds_t fdi;
  for (fdi = 0; fdi < scb->poll_nfds; fdi++) {
 2031da4:	e0bffa17 	ldw	r2,-24(fp)
 2031da8:	10800044 	addi	r2,r2,1
 2031dac:	e0bffa15 	stw	r2,-24(fp)
 2031db0:	e0bffc17 	ldw	r2,-16(fp)
 2031db4:	10800617 	ldw	r2,24(r2)
 2031db8:	e0fffa17 	ldw	r3,-24(fp)
 2031dbc:	18bfd936 	bltu	r3,r2,2031d24 <__alt_mem_mem_0+0xfd011d24>
        /* POLLERR is output only. */
        return 1;
      }
    }
  }
  return 0;
 2031dc0:	0005883a 	mov	r2,zero
}
 2031dc4:	e037883a 	mov	sp,fp
 2031dc8:	df000017 	ldw	fp,0(sp)
 2031dcc:	dec00104 	addi	sp,sp,4
 2031dd0:	f800283a 	ret

02031dd4 <event_callback>:
 *   NETCONN_EVT_ERROR
 * This requirement will be asserted in select_check_waiters()
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
 2031dd4:	defff404 	addi	sp,sp,-48
 2031dd8:	dfc00b15 	stw	ra,44(sp)
 2031ddc:	df000a15 	stw	fp,40(sp)
 2031de0:	df000a04 	addi	fp,sp,40
 2031de4:	e13ffd15 	stw	r4,-12(fp)
 2031de8:	e17ffe15 	stw	r5,-8(fp)
 2031dec:	3005883a 	mov	r2,r6
 2031df0:	e0bfff0d 	sth	r2,-4(fp)
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
 2031df4:	e0bffd17 	ldw	r2,-12(fp)
 2031df8:	10008126 	beq	r2,zero,2032000 <event_callback+0x22c>
    s = conn->callback_arg.socket;
 2031dfc:	e0bffd17 	ldw	r2,-12(fp)
 2031e00:	10800717 	ldw	r2,28(r2)
 2031e04:	e0bff615 	stw	r2,-40(fp)
    if (s < 0) {
 2031e08:	e0bff617 	ldw	r2,-40(fp)
 2031e0c:	1000140e 	bge	r2,zero,2031e60 <event_callback+0x8c>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
 2031e10:	2014cec0 	call	2014cec <sys_arch_protect>
 2031e14:	e0bff815 	stw	r2,-32(fp)
      if (conn->callback_arg.socket < 0) {
 2031e18:	e0bffd17 	ldw	r2,-12(fp)
 2031e1c:	10800717 	ldw	r2,28(r2)
 2031e20:	10000a0e 	bge	r2,zero,2031e4c <event_callback+0x78>
        if (evt == NETCONN_EVT_RCVPLUS) {
 2031e24:	e0bffe17 	ldw	r2,-8(fp)
 2031e28:	1000051e 	bne	r2,zero,2031e40 <event_callback+0x6c>
          /* conn->socket is -1 on initialization
             lwip_accept adjusts sock->recvevent if conn->socket < -1 */
          conn->callback_arg.socket--;
 2031e2c:	e0bffd17 	ldw	r2,-12(fp)
 2031e30:	10800717 	ldw	r2,28(r2)
 2031e34:	10ffffc4 	addi	r3,r2,-1
 2031e38:	e0bffd17 	ldw	r2,-12(fp)
 2031e3c:	10c00715 	stw	r3,28(r2)
        }
        SYS_ARCH_UNPROTECT(lev);
 2031e40:	e13ff817 	ldw	r4,-32(fp)
 2031e44:	2014d200 	call	2014d20 <sys_arch_unprotect>
        return;
 2031e48:	00007006 	br	203200c <event_callback+0x238>
      }
      s = conn->callback_arg.socket;
 2031e4c:	e0bffd17 	ldw	r2,-12(fp)
 2031e50:	10800717 	ldw	r2,28(r2)
 2031e54:	e0bff615 	stw	r2,-40(fp)
      SYS_ARCH_UNPROTECT(lev);
 2031e58:	e13ff817 	ldw	r4,-32(fp)
 2031e5c:	2014d200 	call	2014d20 <sys_arch_unprotect>
    }

    sock = get_socket(s);
 2031e60:	e13ff617 	ldw	r4,-40(fp)
 2031e64:	202ed4c0 	call	202ed4c <get_socket>
 2031e68:	e0bff915 	stw	r2,-28(fp)
    if (!sock) {
 2031e6c:	e0bff917 	ldw	r2,-28(fp)
 2031e70:	10006526 	beq	r2,zero,2032008 <event_callback+0x234>
    }
  } else {
    return;
  }

  check_waiters = 1;
 2031e74:	00800044 	movi	r2,1
 2031e78:	e0bff715 	stw	r2,-36(fp)
  SYS_ARCH_PROTECT(lev);
 2031e7c:	2014cec0 	call	2014cec <sys_arch_protect>
 2031e80:	e0bff815 	stw	r2,-32(fp)
  /* Set event as required */
  switch (evt) {
 2031e84:	e0bffe17 	ldw	r2,-8(fp)
 2031e88:	10800168 	cmpgeui	r2,r2,5
 2031e8c:	1000341e 	bne	r2,zero,2031f60 <event_callback+0x18c>
 2031e90:	e0bffe17 	ldw	r2,-8(fp)
 2031e94:	100690ba 	slli	r3,r2,2
 2031e98:	008080f4 	movhi	r2,515
 2031e9c:	1087ab04 	addi	r2,r2,7852
 2031ea0:	1885883a 	add	r2,r3,r2
 2031ea4:	10800017 	ldw	r2,0(r2)
 2031ea8:	1000683a 	jmp	r2
 2031eac:	02031ec0 	call	2031ec <__alt_mem_sdram_controller_0-0x1dfce14>
 2031eb0:	02031efc 	xorhi	r8,zero,3195
 2031eb4:	02031f1c 	xori	r8,zero,3196
 2031eb8:	02031f40 	call	2031f4 <__alt_mem_sdram_controller_0-0x1dfce0c>
 2031ebc:	02031f50 	cmplti	r8,zero,3197
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
 2031ec0:	e0bff917 	ldw	r2,-28(fp)
 2031ec4:	1080020b 	ldhu	r2,8(r2)
 2031ec8:	10800044 	addi	r2,r2,1
 2031ecc:	1007883a 	mov	r3,r2
 2031ed0:	e0bff917 	ldw	r2,-28(fp)
 2031ed4:	10c0020d 	sth	r3,8(r2)
      if (sock->rcvevent > 1) {
 2031ed8:	e0bff917 	ldw	r2,-28(fp)
 2031edc:	1080020b 	ldhu	r2,8(r2)
 2031ee0:	10bfffcc 	andi	r2,r2,65535
 2031ee4:	10a0001c 	xori	r2,r2,32768
 2031ee8:	10a00004 	addi	r2,r2,-32768
 2031eec:	10800090 	cmplti	r2,r2,2
 2031ef0:	10001d1e 	bne	r2,zero,2031f68 <event_callback+0x194>
        check_waiters = 0;
 2031ef4:	e03ff715 	stw	zero,-36(fp)
      }
      break;
 2031ef8:	00001b06 	br	2031f68 <event_callback+0x194>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
 2031efc:	e0bff917 	ldw	r2,-28(fp)
 2031f00:	1080020b 	ldhu	r2,8(r2)
 2031f04:	10bfffc4 	addi	r2,r2,-1
 2031f08:	1007883a 	mov	r3,r2
 2031f0c:	e0bff917 	ldw	r2,-28(fp)
 2031f10:	10c0020d 	sth	r3,8(r2)
      check_waiters = 0;
 2031f14:	e03ff715 	stw	zero,-36(fp)
      break;
 2031f18:	00001406 	br	2031f6c <event_callback+0x198>
    case NETCONN_EVT_SENDPLUS:
      if (sock->sendevent) {
 2031f1c:	e0bff917 	ldw	r2,-28(fp)
 2031f20:	1080028b 	ldhu	r2,10(r2)
 2031f24:	10bfffcc 	andi	r2,r2,65535
 2031f28:	10000126 	beq	r2,zero,2031f30 <event_callback+0x15c>
        check_waiters = 0;
 2031f2c:	e03ff715 	stw	zero,-36(fp)
      }
      sock->sendevent = 1;
 2031f30:	e0bff917 	ldw	r2,-28(fp)
 2031f34:	00c00044 	movi	r3,1
 2031f38:	10c0028d 	sth	r3,10(r2)
      break;
 2031f3c:	00000b06 	br	2031f6c <event_callback+0x198>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
 2031f40:	e0bff917 	ldw	r2,-28(fp)
 2031f44:	1000028d 	sth	zero,10(r2)
      check_waiters = 0;
 2031f48:	e03ff715 	stw	zero,-36(fp)
      break;
 2031f4c:	00000706 	br	2031f6c <event_callback+0x198>
    case NETCONN_EVT_ERROR:
      sock->errevent = 1;
 2031f50:	e0bff917 	ldw	r2,-28(fp)
 2031f54:	00c00044 	movi	r3,1
 2031f58:	10c0030d 	sth	r3,12(r2)
      break;
 2031f5c:	00000306 	br	2031f6c <event_callback+0x198>
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
 2031f60:	0001883a 	nop
 2031f64:	00000106 	br	2031f6c <event_callback+0x198>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
      if (sock->rcvevent > 1) {
        check_waiters = 0;
      }
      break;
 2031f68:	0001883a 	nop
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
  }

  if (sock->select_waiting && check_waiters) {
 2031f6c:	e0bff917 	ldw	r2,-28(fp)
 2031f70:	10800383 	ldbu	r2,14(r2)
 2031f74:	10803fcc 	andi	r2,r2,255
 2031f78:	10001e26 	beq	r2,zero,2031ff4 <event_callback+0x220>
 2031f7c:	e0bff717 	ldw	r2,-36(fp)
 2031f80:	10001c26 	beq	r2,zero,2031ff4 <event_callback+0x220>
    /* Save which events are active */
    int has_recvevent, has_sendevent, has_errevent;
    has_recvevent = sock->rcvevent > 0;
 2031f84:	e0bff917 	ldw	r2,-28(fp)
 2031f88:	1080020b 	ldhu	r2,8(r2)
 2031f8c:	10bfffcc 	andi	r2,r2,65535
 2031f90:	10a0001c 	xori	r2,r2,32768
 2031f94:	10a00004 	addi	r2,r2,-32768
 2031f98:	0084803a 	cmplt	r2,zero,r2
 2031f9c:	10803fcc 	andi	r2,r2,255
 2031fa0:	e0bffa15 	stw	r2,-24(fp)
    has_sendevent = sock->sendevent != 0;
 2031fa4:	e0bff917 	ldw	r2,-28(fp)
 2031fa8:	1080028b 	ldhu	r2,10(r2)
 2031fac:	10bfffcc 	andi	r2,r2,65535
 2031fb0:	1004c03a 	cmpne	r2,r2,zero
 2031fb4:	10803fcc 	andi	r2,r2,255
 2031fb8:	e0bffb15 	stw	r2,-20(fp)
    has_errevent = sock->errevent != 0;
 2031fbc:	e0bff917 	ldw	r2,-28(fp)
 2031fc0:	1080030b 	ldhu	r2,12(r2)
 2031fc4:	10bfffcc 	andi	r2,r2,65535
 2031fc8:	1004c03a 	cmpne	r2,r2,zero
 2031fcc:	10803fcc 	andi	r2,r2,255
 2031fd0:	e0bffc15 	stw	r2,-16(fp)
    SYS_ARCH_UNPROTECT(lev);
 2031fd4:	e13ff817 	ldw	r4,-32(fp)
 2031fd8:	2014d200 	call	2014d20 <sys_arch_unprotect>
    /* Check any select calls waiting on this socket */
    select_check_waiters(s, has_recvevent, has_sendevent, has_errevent);
 2031fdc:	e1fffc17 	ldw	r7,-16(fp)
 2031fe0:	e1bffb17 	ldw	r6,-20(fp)
 2031fe4:	e17ffa17 	ldw	r5,-24(fp)
 2031fe8:	e13ff617 	ldw	r4,-40(fp)
 2031fec:	20320200 	call	2032020 <select_check_waiters>
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
  }

  if (sock->select_waiting && check_waiters) {
 2031ff0:	00000606 	br	203200c <event_callback+0x238>
    has_errevent = sock->errevent != 0;
    SYS_ARCH_UNPROTECT(lev);
    /* Check any select calls waiting on this socket */
    select_check_waiters(s, has_recvevent, has_sendevent, has_errevent);
  } else {
    SYS_ARCH_UNPROTECT(lev);
 2031ff4:	e13ff817 	ldw	r4,-32(fp)
 2031ff8:	2014d200 	call	2014d20 <sys_arch_unprotect>
 2031ffc:	00000306 	br	203200c <event_callback+0x238>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
 2032000:	0001883a 	nop
 2032004:	00000106 	br	203200c <event_callback+0x238>
      SYS_ARCH_UNPROTECT(lev);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
 2032008:	0001883a 	nop
    select_check_waiters(s, has_recvevent, has_sendevent, has_errevent);
  } else {
    SYS_ARCH_UNPROTECT(lev);
  }
  done_socket(sock);
}
 203200c:	e037883a 	mov	sp,fp
 2032010:	dfc00117 	ldw	ra,4(sp)
 2032014:	df000017 	ldw	fp,0(sp)
 2032018:	dec00204 	addi	sp,sp,8
 203201c:	f800283a 	ret

02032020 <select_check_waiters>:
 * of the loop, thus creating a possibility where a thread could modify the
 * select_cb_list during our UNPROTECT/PROTECT. We use a generational counter to
 * detect this change and restart the list walk. The list is expected to be small
 */
static void select_check_waiters(int s, int has_recvevent, int has_sendevent, int has_errevent)
{
 2032020:	defff504 	addi	sp,sp,-44
 2032024:	dfc00a15 	stw	ra,40(sp)
 2032028:	df000915 	stw	fp,36(sp)
 203202c:	df000904 	addi	fp,sp,36
 2032030:	e13ffc15 	stw	r4,-16(fp)
 2032034:	e17ffd15 	stw	r5,-12(fp)
 2032038:	e1bffe15 	stw	r6,-8(fp)
 203203c:	e1ffff15 	stw	r7,-4(fp)
#endif /* !LWIP_TCPIP_CORE_LOCKING */

  LWIP_ASSERT_CORE_LOCKED();

#if !LWIP_TCPIP_CORE_LOCKING
  SYS_ARCH_PROTECT(lev);
 2032040:	2014cec0 	call	2014cec <sys_arch_protect>
 2032044:	e0bffa15 	stw	r2,-24(fp)
again:
  /* remember the state of select_cb_list to detect changes */
  last_select_cb_ctr = select_cb_ctr;
 2032048:	d0a7fb17 	ldw	r2,-24596(gp)
 203204c:	e0bff915 	stw	r2,-28(fp)
#endif /* !LWIP_TCPIP_CORE_LOCKING */
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 2032050:	d0a7fc17 	ldw	r2,-24592(gp)
 2032054:	e0bff815 	stw	r2,-32(fp)
 2032058:	00006606 	br	20321f4 <select_check_waiters+0x1d4>
    if (scb->sem_signalled == 0) {
 203205c:	e0bff817 	ldw	r2,-32(fp)
 2032060:	10800717 	ldw	r2,28(r2)
 2032064:	1000561e 	bne	r2,zero,20321c0 <select_check_waiters+0x1a0>
      /* semaphore not signalled yet */
      int do_signal = 0;
 2032068:	e03ffb15 	stw	zero,-20(fp)
#if LWIP_SOCKET_POLL
      if (scb->poll_fds != NULL) {
 203206c:	e0bff817 	ldw	r2,-32(fp)
 2032070:	10800517 	ldw	r2,20(r2)
 2032074:	10000926 	beq	r2,zero,203209c <select_check_waiters+0x7c>
        do_signal = lwip_poll_should_wake(scb, s, has_recvevent, has_sendevent, has_errevent);
 2032078:	e0bfff17 	ldw	r2,-4(fp)
 203207c:	d8800015 	stw	r2,0(sp)
 2032080:	e1fffe17 	ldw	r7,-8(fp)
 2032084:	e1bffd17 	ldw	r6,-12(fp)
 2032088:	e17ffc17 	ldw	r5,-16(fp)
 203208c:	e13ff817 	ldw	r4,-32(fp)
 2032090:	2031d000 	call	2031d00 <lwip_poll_should_wake>
 2032094:	e0bffb15 	stw	r2,-20(fp)
 2032098:	00004006 	br	203219c <select_check_waiters+0x17c>
      else
#endif /* LWIP_SOCKET_SELECT && LWIP_SOCKET_POLL */
#if LWIP_SOCKET_SELECT
      {
        /* Test this select call for our socket */
        if (has_recvevent) {
 203209c:	e0bffd17 	ldw	r2,-12(fp)
 20320a0:	10001226 	beq	r2,zero,20320ec <select_check_waiters+0xcc>
          if (scb->readset && FD_ISSET(s, scb->readset)) {
 20320a4:	e0bff817 	ldw	r2,-32(fp)
 20320a8:	10800217 	ldw	r2,8(r2)
 20320ac:	10000f26 	beq	r2,zero,20320ec <select_check_waiters+0xcc>
 20320b0:	e0bff817 	ldw	r2,-32(fp)
 20320b4:	10c00217 	ldw	r3,8(r2)
 20320b8:	e0bffc17 	ldw	r2,-16(fp)
 20320bc:	1004d17a 	srli	r2,r2,5
 20320c0:	1085883a 	add	r2,r2,r2
 20320c4:	1085883a 	add	r2,r2,r2
 20320c8:	1885883a 	add	r2,r3,r2
 20320cc:	10c00017 	ldw	r3,0(r2)
 20320d0:	e0bffc17 	ldw	r2,-16(fp)
 20320d4:	108007cc 	andi	r2,r2,31
 20320d8:	1885d83a 	sra	r2,r3,r2
 20320dc:	1080004c 	andi	r2,r2,1
 20320e0:	10000226 	beq	r2,zero,20320ec <select_check_waiters+0xcc>
            do_signal = 1;
 20320e4:	00800044 	movi	r2,1
 20320e8:	e0bffb15 	stw	r2,-20(fp)
          }
        }
        if (has_sendevent) {
 20320ec:	e0bffe17 	ldw	r2,-8(fp)
 20320f0:	10001426 	beq	r2,zero,2032144 <select_check_waiters+0x124>
          if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
 20320f4:	e0bffb17 	ldw	r2,-20(fp)
 20320f8:	1000121e 	bne	r2,zero,2032144 <select_check_waiters+0x124>
 20320fc:	e0bff817 	ldw	r2,-32(fp)
 2032100:	10800317 	ldw	r2,12(r2)
 2032104:	10000f26 	beq	r2,zero,2032144 <select_check_waiters+0x124>
 2032108:	e0bff817 	ldw	r2,-32(fp)
 203210c:	10c00317 	ldw	r3,12(r2)
 2032110:	e0bffc17 	ldw	r2,-16(fp)
 2032114:	1004d17a 	srli	r2,r2,5
 2032118:	1085883a 	add	r2,r2,r2
 203211c:	1085883a 	add	r2,r2,r2
 2032120:	1885883a 	add	r2,r3,r2
 2032124:	10c00017 	ldw	r3,0(r2)
 2032128:	e0bffc17 	ldw	r2,-16(fp)
 203212c:	108007cc 	andi	r2,r2,31
 2032130:	1885d83a 	sra	r2,r3,r2
 2032134:	1080004c 	andi	r2,r2,1
 2032138:	10000226 	beq	r2,zero,2032144 <select_check_waiters+0x124>
            do_signal = 1;
 203213c:	00800044 	movi	r2,1
 2032140:	e0bffb15 	stw	r2,-20(fp)
          }
        }
        if (has_errevent) {
 2032144:	e0bfff17 	ldw	r2,-4(fp)
 2032148:	10001426 	beq	r2,zero,203219c <select_check_waiters+0x17c>
          if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
 203214c:	e0bffb17 	ldw	r2,-20(fp)
 2032150:	1000121e 	bne	r2,zero,203219c <select_check_waiters+0x17c>
 2032154:	e0bff817 	ldw	r2,-32(fp)
 2032158:	10800417 	ldw	r2,16(r2)
 203215c:	10000f26 	beq	r2,zero,203219c <select_check_waiters+0x17c>
 2032160:	e0bff817 	ldw	r2,-32(fp)
 2032164:	10c00417 	ldw	r3,16(r2)
 2032168:	e0bffc17 	ldw	r2,-16(fp)
 203216c:	1004d17a 	srli	r2,r2,5
 2032170:	1085883a 	add	r2,r2,r2
 2032174:	1085883a 	add	r2,r2,r2
 2032178:	1885883a 	add	r2,r3,r2
 203217c:	10c00017 	ldw	r3,0(r2)
 2032180:	e0bffc17 	ldw	r2,-16(fp)
 2032184:	108007cc 	andi	r2,r2,31
 2032188:	1885d83a 	sra	r2,r3,r2
 203218c:	1080004c 	andi	r2,r2,1
 2032190:	10000226 	beq	r2,zero,203219c <select_check_waiters+0x17c>
            do_signal = 1;
 2032194:	00800044 	movi	r2,1
 2032198:	e0bffb15 	stw	r2,-20(fp)
          }
        }
      }
#endif /* LWIP_SOCKET_SELECT */
      if (do_signal) {
 203219c:	e0bffb17 	ldw	r2,-20(fp)
 20321a0:	10000726 	beq	r2,zero,20321c0 <select_check_waiters+0x1a0>
        scb->sem_signalled = 1;
 20321a4:	e0bff817 	ldw	r2,-32(fp)
 20321a8:	00c00044 	movi	r3,1
 20321ac:	10c00715 	stw	r3,28(r2)
        /* For !LWIP_TCPIP_CORE_LOCKING, we don't call SYS_ARCH_UNPROTECT() before signaling
           the semaphore, as this might lead to the select thread taking itself off the list,
           invalidating the semaphore. */
        sys_sem_signal(SELECT_SEM_PTR(scb->sem));
 20321b0:	e0bff817 	ldw	r2,-32(fp)
 20321b4:	10800804 	addi	r2,r2,32
 20321b8:	1009883a 	mov	r4,r2
 20321bc:	20150340 	call	2015034 <sys_sem_signal>
    }
#if LWIP_TCPIP_CORE_LOCKING
  }
#else
    /* unlock interrupts with each step */
    SYS_ARCH_UNPROTECT(lev);
 20321c0:	e13ffa17 	ldw	r4,-24(fp)
 20321c4:	2014d200 	call	2014d20 <sys_arch_unprotect>
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
 20321c8:	2014cec0 	call	2014cec <sys_arch_protect>
 20321cc:	e0bffa15 	stw	r2,-24(fp)
    if (last_select_cb_ctr != select_cb_ctr) {
 20321d0:	d0a7fb17 	ldw	r2,-24596(gp)
 20321d4:	e0fff917 	ldw	r3,-28(fp)
 20321d8:	18800126 	beq	r3,r2,20321e0 <select_check_waiters+0x1c0>
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
 20321dc:	003f9a06 	br	2032048 <__alt_mem_mem_0+0xfd012048>
    }
    /* remember the state of select_cb_list to detect changes */
    last_select_cb_ctr = select_cb_ctr;
 20321e0:	d0a7fb17 	ldw	r2,-24596(gp)
 20321e4:	e0bff915 	stw	r2,-28(fp)
  SYS_ARCH_PROTECT(lev);
again:
  /* remember the state of select_cb_list to detect changes */
  last_select_cb_ctr = select_cb_ctr;
#endif /* !LWIP_TCPIP_CORE_LOCKING */
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 20321e8:	e0bff817 	ldw	r2,-32(fp)
 20321ec:	10800017 	ldw	r2,0(r2)
 20321f0:	e0bff815 	stw	r2,-32(fp)
 20321f4:	e0bff817 	ldw	r2,-32(fp)
 20321f8:	103f981e 	bne	r2,zero,203205c <__alt_mem_mem_0+0xfd01205c>
      goto again;
    }
    /* remember the state of select_cb_list to detect changes */
    last_select_cb_ctr = select_cb_ctr;
  }
  SYS_ARCH_UNPROTECT(lev);
 20321fc:	e13ffa17 	ldw	r4,-24(fp)
 2032200:	2014d200 	call	2014d20 <sys_arch_unprotect>
#endif
}
 2032204:	0001883a 	nop
 2032208:	e037883a 	mov	sp,fp
 203220c:	dfc00117 	ldw	ra,4(sp)
 2032210:	df000017 	ldw	fp,0(sp)
 2032214:	dec00204 	addi	sp,sp,8
 2032218:	f800283a 	ret

0203221c <lwip_shutdown>:
/**
 * Close one end of a full-duplex connection.
 */
int
lwip_shutdown(int s, int how)
{
 203221c:	defff804 	addi	sp,sp,-32
 2032220:	dfc00715 	stw	ra,28(sp)
 2032224:	df000615 	stw	fp,24(sp)
 2032228:	dc000515 	stw	r16,20(sp)
 203222c:	df000604 	addi	fp,sp,24
 2032230:	e13ffd15 	stw	r4,-12(fp)
 2032234:	e17ffe15 	stw	r5,-8(fp)
  struct lwip_sock *sock;
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;
 2032238:	e03ffa05 	stb	zero,-24(fp)
 203223c:	e03ffa45 	stb	zero,-23(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
 2032240:	e13ffd17 	ldw	r4,-12(fp)
 2032244:	202ed4c0 	call	202ed4c <get_socket>
 2032248:	e0bffb15 	stw	r2,-20(fp)
  if (!sock) {
 203224c:	e0bffb17 	ldw	r2,-20(fp)
 2032250:	1000021e 	bne	r2,zero,203225c <lwip_shutdown+0x40>
    return -1;
 2032254:	00bfffc4 	movi	r2,-1
 2032258:	00004706 	br	2032378 <lwip_shutdown+0x15c>
  }

  if (sock->conn != NULL) {
 203225c:	e0bffb17 	ldw	r2,-20(fp)
 2032260:	10800017 	ldw	r2,0(r2)
 2032264:	10000c26 	beq	r2,zero,2032298 <lwip_shutdown+0x7c>
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
 2032268:	e0bffb17 	ldw	r2,-20(fp)
 203226c:	10800017 	ldw	r2,0(r2)
 2032270:	10800017 	ldw	r2,0(r2)
 2032274:	10803c0c 	andi	r2,r2,240
 2032278:	10800420 	cmpeqi	r2,r2,16
 203227c:	10000c1e 	bne	r2,zero,20322b0 <lwip_shutdown+0x94>
      set_errno(EOPNOTSUPP);
 2032280:	20423b80 	call	20423b8 <__errno>
 2032284:	1007883a 	mov	r3,r2
 2032288:	008017c4 	movi	r2,95
 203228c:	18800015 	stw	r2,0(r3)
      done_socket(sock);
      return -1;
 2032290:	00bfffc4 	movi	r2,-1
 2032294:	00003806 	br	2032378 <lwip_shutdown+0x15c>
    }
  } else {
    set_errno(ENOTCONN);
 2032298:	20423b80 	call	20423b8 <__errno>
 203229c:	1007883a 	mov	r3,r2
 20322a0:	00802004 	movi	r2,128
 20322a4:	18800015 	stw	r2,0(r3)
    done_socket(sock);
    return -1;
 20322a8:	00bfffc4 	movi	r2,-1
 20322ac:	00003206 	br	2032378 <lwip_shutdown+0x15c>
  }

  if (how == SHUT_RD) {
 20322b0:	e0bffe17 	ldw	r2,-8(fp)
 20322b4:	1000031e 	bne	r2,zero,20322c4 <lwip_shutdown+0xa8>
    shut_rx = 1;
 20322b8:	00800044 	movi	r2,1
 20322bc:	e0bffa05 	stb	r2,-24(fp)
 20322c0:	00001406 	br	2032314 <lwip_shutdown+0xf8>
  } else if (how == SHUT_WR) {
 20322c4:	e0bffe17 	ldw	r2,-8(fp)
 20322c8:	10800058 	cmpnei	r2,r2,1
 20322cc:	1000031e 	bne	r2,zero,20322dc <lwip_shutdown+0xc0>
    shut_tx = 1;
 20322d0:	00800044 	movi	r2,1
 20322d4:	e0bffa45 	stb	r2,-23(fp)
 20322d8:	00000e06 	br	2032314 <lwip_shutdown+0xf8>
  } else if (how == SHUT_RDWR) {
 20322dc:	e0bffe17 	ldw	r2,-8(fp)
 20322e0:	10800098 	cmpnei	r2,r2,2
 20322e4:	1000051e 	bne	r2,zero,20322fc <lwip_shutdown+0xe0>
    shut_rx = 1;
 20322e8:	00800044 	movi	r2,1
 20322ec:	e0bffa05 	stb	r2,-24(fp)
    shut_tx = 1;
 20322f0:	00800044 	movi	r2,1
 20322f4:	e0bffa45 	stb	r2,-23(fp)
 20322f8:	00000606 	br	2032314 <lwip_shutdown+0xf8>
  } else {
    set_errno(EINVAL);
 20322fc:	20423b80 	call	20423b8 <__errno>
 2032300:	1007883a 	mov	r3,r2
 2032304:	00800584 	movi	r2,22
 2032308:	18800015 	stw	r2,0(r3)
    done_socket(sock);
    return -1;
 203230c:	00bfffc4 	movi	r2,-1
 2032310:	00001906 	br	2032378 <lwip_shutdown+0x15c>
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
 2032314:	e0bffb17 	ldw	r2,-20(fp)
 2032318:	10800017 	ldw	r2,0(r2)
 203231c:	e0fffa03 	ldbu	r3,-24(fp)
 2032320:	e13ffa43 	ldbu	r4,-23(fp)
 2032324:	200d883a 	mov	r6,r4
 2032328:	180b883a 	mov	r5,r3
 203232c:	1009883a 	mov	r4,r2
 2032330:	203f2e00 	call	203f2e0 <netconn_shutdown>
 2032334:	e0bffc05 	stb	r2,-16(fp)

  set_errno(err_to_errno(err));
 2032338:	e0bffc07 	ldb	r2,-16(fp)
 203233c:	1009883a 	mov	r4,r2
 2032340:	2041e900 	call	2041e90 <err_to_errno>
 2032344:	10000626 	beq	r2,zero,2032360 <lwip_shutdown+0x144>
 2032348:	20423b80 	call	20423b8 <__errno>
 203234c:	1021883a 	mov	r16,r2
 2032350:	e0bffc07 	ldb	r2,-16(fp)
 2032354:	1009883a 	mov	r4,r2
 2032358:	2041e900 	call	2041e90 <err_to_errno>
 203235c:	80800015 	stw	r2,0(r16)
  done_socket(sock);
  return (err == ERR_OK ? 0 : -1);
 2032360:	e0bffc07 	ldb	r2,-16(fp)
 2032364:	1000021e 	bne	r2,zero,2032370 <lwip_shutdown+0x154>
 2032368:	0005883a 	mov	r2,zero
 203236c:	00000106 	br	2032374 <lwip_shutdown+0x158>
 2032370:	00bfffc4 	movi	r2,-1
 2032374:	0001883a 	nop
}
 2032378:	e6ffff04 	addi	sp,fp,-4
 203237c:	dfc00217 	ldw	ra,8(sp)
 2032380:	df000117 	ldw	fp,4(sp)
 2032384:	dc000017 	ldw	r16,0(sp)
 2032388:	dec00304 	addi	sp,sp,12
 203238c:	f800283a 	ret

02032390 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
 2032390:	defff104 	addi	sp,sp,-60
 2032394:	dfc00e15 	stw	ra,56(sp)
 2032398:	df000d15 	stw	fp,52(sp)
 203239c:	dc000c15 	stw	r16,48(sp)
 20323a0:	df000d04 	addi	fp,sp,52
 20323a4:	e13ffb15 	stw	r4,-20(fp)
 20323a8:	e17ffc15 	stw	r5,-16(fp)
 20323ac:	e1bffd15 	stw	r6,-12(fp)
 20323b0:	3805883a 	mov	r2,r7
 20323b4:	e0bffe05 	stb	r2,-8(fp)
  union sockaddr_aligned saddr;
  ip_addr_t naddr;
  u16_t port;
  err_t err;

  sock = get_socket(s);
 20323b8:	e13ffb17 	ldw	r4,-20(fp)
 20323bc:	202ed4c0 	call	202ed4c <get_socket>
 20323c0:	e0bff315 	stw	r2,-52(fp)
  if (!sock) {
 20323c4:	e0bff317 	ldw	r2,-52(fp)
 20323c8:	1000021e 	bne	r2,zero,20323d4 <lwip_getaddrname+0x44>
    return -1;
 20323cc:	00bfffc4 	movi	r2,-1
 20323d0:	00003f06 	br	20324d0 <lwip_getaddrname+0x140>
  }

  /* get the IP address and port */
  err = netconn_getaddr(sock->conn, &naddr, &port, local);
 20323d4:	e0bff317 	ldw	r2,-52(fp)
 20323d8:	10800017 	ldw	r2,0(r2)
 20323dc:	e17ffe03 	ldbu	r5,-8(fp)
 20323e0:	e13ffa04 	addi	r4,fp,-24
 20323e4:	e0fff904 	addi	r3,fp,-28
 20323e8:	280f883a 	mov	r7,r5
 20323ec:	200d883a 	mov	r6,r4
 20323f0:	180b883a 	mov	r5,r3
 20323f4:	1009883a 	mov	r4,r2
 20323f8:	203e2e80 	call	203e2e8 <netconn_getaddr>
 20323fc:	e0bff405 	stb	r2,-48(fp)
  if (err != ERR_OK) {
 2032400:	e0bff407 	ldb	r2,-48(fp)
 2032404:	10000c26 	beq	r2,zero,2032438 <lwip_getaddrname+0xa8>
    set_errno(err_to_errno(err));
 2032408:	e0bff407 	ldb	r2,-48(fp)
 203240c:	1009883a 	mov	r4,r2
 2032410:	2041e900 	call	2041e90 <err_to_errno>
 2032414:	10000626 	beq	r2,zero,2032430 <lwip_getaddrname+0xa0>
 2032418:	20423b80 	call	20423b8 <__errno>
 203241c:	1021883a 	mov	r16,r2
 2032420:	e0bff407 	ldb	r2,-48(fp)
 2032424:	1009883a 	mov	r4,r2
 2032428:	2041e900 	call	2041e90 <err_to_errno>
 203242c:	80800015 	stw	r2,0(r16)
    done_socket(sock);
    return -1;
 2032430:	00bfffc4 	movi	r2,-1
 2032434:	00002606 	br	20324d0 <lwip_getaddrname+0x140>
    ip4_2_ipv4_mapped_ipv6(ip_2_ip6(&naddr), ip_2_ip4(&naddr));
    IP_SET_TYPE_VAL(naddr, IPADDR_TYPE_V6);
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

  IPADDR_PORT_TO_SOCKADDR(&saddr, &naddr, port);
 2032438:	e0bff504 	addi	r2,fp,-44
 203243c:	00c00404 	movi	r3,16
 2032440:	10c00005 	stb	r3,0(r2)
 2032444:	e0bff504 	addi	r2,fp,-44
 2032448:	00c00084 	movi	r3,2
 203244c:	10c00045 	stb	r3,1(r2)
 2032450:	e43ff504 	addi	r16,fp,-44
 2032454:	e0bffa0b 	ldhu	r2,-24(fp)
 2032458:	10bfffcc 	andi	r2,r2,65535
 203245c:	1009883a 	mov	r4,r2
 2032460:	20394740 	call	2039474 <lwip_htons>
 2032464:	8080008d 	sth	r2,2(r16)
 2032468:	e0bff504 	addi	r2,fp,-44
 203246c:	e0fff917 	ldw	r3,-28(fp)
 2032470:	10c00115 	stw	r3,4(r2)
 2032474:	e0bff504 	addi	r2,fp,-44
 2032478:	10800204 	addi	r2,r2,8
 203247c:	01800204 	movi	r6,8
 2032480:	000b883a 	mov	r5,zero
 2032484:	1009883a 	mov	r4,r2
 2032488:	2005fa00 	call	2005fa0 <memset>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print_val(SOCKETS_DEBUG, naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", port));

  if (*namelen > IPADDR_SOCKADDR_GET_LEN(&saddr)) {
 203248c:	e0bffd17 	ldw	r2,-12(fp)
 2032490:	10800017 	ldw	r2,0(r2)
 2032494:	e0fff503 	ldbu	r3,-44(fp)
 2032498:	18c03fcc 	andi	r3,r3,255
 203249c:	1880042e 	bgeu	r3,r2,20324b0 <lwip_getaddrname+0x120>
    *namelen = IPADDR_SOCKADDR_GET_LEN(&saddr);
 20324a0:	e0bff503 	ldbu	r2,-44(fp)
 20324a4:	10c03fcc 	andi	r3,r2,255
 20324a8:	e0bffd17 	ldw	r2,-12(fp)
 20324ac:	10c00015 	stw	r3,0(r2)
  }
  MEMCPY(name, &saddr, *namelen);
 20324b0:	e0bffd17 	ldw	r2,-12(fp)
 20324b4:	10c00017 	ldw	r3,0(r2)
 20324b8:	e0bff504 	addi	r2,fp,-44
 20324bc:	180d883a 	mov	r6,r3
 20324c0:	100b883a 	mov	r5,r2
 20324c4:	e13ffc17 	ldw	r4,-16(fp)
 20324c8:	2005e580 	call	2005e58 <memcpy>

  set_errno(0);
  done_socket(sock);
  return 0;
 20324cc:	0005883a 	mov	r2,zero
}
 20324d0:	e6ffff04 	addi	sp,fp,-4
 20324d4:	dfc00217 	ldw	ra,8(sp)
 20324d8:	df000117 	ldw	fp,4(sp)
 20324dc:	dc000017 	ldw	r16,0(sp)
 20324e0:	dec00304 	addi	sp,sp,12
 20324e4:	f800283a 	ret

020324e8 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
 20324e8:	defffb04 	addi	sp,sp,-20
 20324ec:	dfc00415 	stw	ra,16(sp)
 20324f0:	df000315 	stw	fp,12(sp)
 20324f4:	df000304 	addi	fp,sp,12
 20324f8:	e13ffd15 	stw	r4,-12(fp)
 20324fc:	e17ffe15 	stw	r5,-8(fp)
 2032500:	e1bfff15 	stw	r6,-4(fp)
  return lwip_getaddrname(s, name, namelen, 0);
 2032504:	000f883a 	mov	r7,zero
 2032508:	e1bfff17 	ldw	r6,-4(fp)
 203250c:	e17ffe17 	ldw	r5,-8(fp)
 2032510:	e13ffd17 	ldw	r4,-12(fp)
 2032514:	20323900 	call	2032390 <lwip_getaddrname>
}
 2032518:	e037883a 	mov	sp,fp
 203251c:	dfc00117 	ldw	ra,4(sp)
 2032520:	df000017 	ldw	fp,0(sp)
 2032524:	dec00204 	addi	sp,sp,8
 2032528:	f800283a 	ret

0203252c <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
 203252c:	defffb04 	addi	sp,sp,-20
 2032530:	dfc00415 	stw	ra,16(sp)
 2032534:	df000315 	stw	fp,12(sp)
 2032538:	df000304 	addi	fp,sp,12
 203253c:	e13ffd15 	stw	r4,-12(fp)
 2032540:	e17ffe15 	stw	r5,-8(fp)
 2032544:	e1bfff15 	stw	r6,-4(fp)
  return lwip_getaddrname(s, name, namelen, 1);
 2032548:	01c00044 	movi	r7,1
 203254c:	e1bfff17 	ldw	r6,-4(fp)
 2032550:	e17ffe17 	ldw	r5,-8(fp)
 2032554:	e13ffd17 	ldw	r4,-12(fp)
 2032558:	20323900 	call	2032390 <lwip_getaddrname>
}
 203255c:	e037883a 	mov	sp,fp
 2032560:	dfc00117 	ldw	ra,4(sp)
 2032564:	df000017 	ldw	fp,0(sp)
 2032568:	dec00204 	addi	sp,sp,8
 203256c:	f800283a 	ret

02032570 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
 2032570:	deffef04 	addi	sp,sp,-68
 2032574:	dfc01015 	stw	ra,64(sp)
 2032578:	df000f15 	stw	fp,60(sp)
 203257c:	dc000e15 	stw	r16,56(sp)
 2032580:	df000f04 	addi	fp,sp,60
 2032584:	e13ffb15 	stw	r4,-20(fp)
 2032588:	e17ffc15 	stw	r5,-16(fp)
 203258c:	e1bffd15 	stw	r6,-12(fp)
 2032590:	e1fffe15 	stw	r7,-8(fp)
  int err;
  struct lwip_sock *sock = get_socket(s);
 2032594:	e13ffb17 	ldw	r4,-20(fp)
 2032598:	202ed4c0 	call	202ed4c <get_socket>
 203259c:	e0bff115 	stw	r2,-60(fp)
#if !LWIP_TCPIP_CORE_LOCKING
  err_t cberr;
  LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
#endif /* !LWIP_TCPIP_CORE_LOCKING */

  if (!sock) {
 20325a0:	e0bff117 	ldw	r2,-60(fp)
 20325a4:	1000021e 	bne	r2,zero,20325b0 <lwip_getsockopt+0x40>
    return -1;
 20325a8:	00bfffc4 	movi	r2,-1
 20325ac:	00004306 	br	20326bc <lwip_getsockopt+0x14c>
  }

  if ((NULL == optval) || (NULL == optlen)) {
 20325b0:	e0bffe17 	ldw	r2,-8(fp)
 20325b4:	10000226 	beq	r2,zero,20325c0 <lwip_getsockopt+0x50>
 20325b8:	e0800217 	ldw	r2,8(fp)
 20325bc:	1000061e 	bne	r2,zero,20325d8 <lwip_getsockopt+0x68>
    set_errno(EFAULT);
 20325c0:	20423b80 	call	20423b8 <__errno>
 20325c4:	1007883a 	mov	r3,r2
 20325c8:	00800384 	movi	r2,14
 20325cc:	18800015 	stw	r2,0(r3)
    done_socket(sock);
    return -1;
 20325d0:	00bfffc4 	movi	r2,-1
 20325d4:	00003906 	br	20326bc <lwip_getsockopt+0x14c>
    return -1;
  }
#endif /* LWIP_MPU_COMPATIBLE */

  LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(data, sock);
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).s = s;
 20325d8:	e0bffb17 	ldw	r2,-20(fp)
 20325dc:	e0bff415 	stw	r2,-48(fp)
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).level = level;
 20325e0:	e0bffc17 	ldw	r2,-16(fp)
 20325e4:	e0bff515 	stw	r2,-44(fp)
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optname = optname;
 20325e8:	e0bffd17 	ldw	r2,-12(fp)
 20325ec:	e0bff615 	stw	r2,-40(fp)
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen = *optlen;
 20325f0:	e0800217 	ldw	r2,8(fp)
 20325f4:	10800017 	ldw	r2,0(r2)
 20325f8:	e0bff815 	stw	r2,-32(fp)
#if !LWIP_MPU_COMPATIBLE
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval.p = optval;
 20325fc:	e0bffe17 	ldw	r2,-8(fp)
 2032600:	e0bff715 	stw	r2,-36(fp)
#endif /* !LWIP_MPU_COMPATIBLE */
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err = 0;
 2032604:	e03ff915 	stw	zero,-28(fp)
#if LWIP_NETCONN_SEM_PER_THREAD
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
#else
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = &sock->conn->op_completed;
 2032608:	e0bff117 	ldw	r2,-60(fp)
 203260c:	10800017 	ldw	r2,0(r2)
 2032610:	10800404 	addi	r2,r2,16
 2032614:	e0bffa15 	stw	r2,-24(fp)
#endif
  cberr = tcpip_callback(lwip_getsockopt_callback, &LWIP_SETGETSOCKOPT_DATA_VAR_REF(data));
 2032618:	e0bff404 	addi	r2,fp,-48
 203261c:	100b883a 	mov	r5,r2
 2032620:	010080f4 	movhi	r4,515
 2032624:	2109b504 	addi	r4,r4,9940
 2032628:	2033e940 	call	2033e94 <tcpip_callback>
 203262c:	e0bff205 	stb	r2,-56(fp)
  if (cberr != ERR_OK) {
 2032630:	e0bff207 	ldb	r2,-56(fp)
 2032634:	10000c26 	beq	r2,zero,2032668 <lwip_getsockopt+0xf8>
    LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
    set_errno(err_to_errno(cberr));
 2032638:	e0bff207 	ldb	r2,-56(fp)
 203263c:	1009883a 	mov	r4,r2
 2032640:	2041e900 	call	2041e90 <err_to_errno>
 2032644:	10000626 	beq	r2,zero,2032660 <lwip_getsockopt+0xf0>
 2032648:	20423b80 	call	20423b8 <__errno>
 203264c:	1021883a 	mov	r16,r2
 2032650:	e0bff207 	ldb	r2,-56(fp)
 2032654:	1009883a 	mov	r4,r2
 2032658:	2041e900 	call	2041e90 <err_to_errno>
 203265c:	80800015 	stw	r2,0(r16)
    done_socket(sock);
    return -1;
 2032660:	00bfffc4 	movi	r2,-1
 2032664:	00001506 	br	20326bc <lwip_getsockopt+0x14c>
  }
  sys_arch_sem_wait((sys_sem_t *)(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem), 0);
 2032668:	e0bffa17 	ldw	r2,-24(fp)
 203266c:	000b883a 	mov	r5,zero
 2032670:	1009883a 	mov	r4,r2
 2032674:	20150800 	call	2015080 <sys_arch_sem_wait>

  /* write back optlen and optval */
  *optlen = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen;
 2032678:	e0fff817 	ldw	r3,-32(fp)
 203267c:	e0800217 	ldw	r2,8(fp)
 2032680:	10c00015 	stw	r3,0(r2)
  MEMCPY(optval, LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval,
         LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen);
#endif /* LWIP_MPU_COMPATIBLE */

  /* maybe lwip_getsockopt_impl has changed err */
  err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
 2032684:	e0bff917 	ldw	r2,-28(fp)
 2032688:	e0bff315 	stw	r2,-52(fp)
  LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  set_errno(err);
 203268c:	e0bff317 	ldw	r2,-52(fp)
 2032690:	10000426 	beq	r2,zero,20326a4 <lwip_getsockopt+0x134>
 2032694:	20423b80 	call	20423b8 <__errno>
 2032698:	1007883a 	mov	r3,r2
 203269c:	e0bff317 	ldw	r2,-52(fp)
 20326a0:	18800015 	stw	r2,0(r3)
  done_socket(sock);
  return err ? -1 : 0;
 20326a4:	e0bff317 	ldw	r2,-52(fp)
 20326a8:	10000226 	beq	r2,zero,20326b4 <lwip_getsockopt+0x144>
 20326ac:	00bfffc4 	movi	r2,-1
 20326b0:	00000206 	br	20326bc <lwip_getsockopt+0x14c>
 20326b4:	0005883a 	mov	r2,zero
 20326b8:	0001883a 	nop
}
 20326bc:	e6ffff04 	addi	sp,fp,-4
 20326c0:	dfc00217 	ldw	ra,8(sp)
 20326c4:	df000117 	ldw	fp,4(sp)
 20326c8:	dc000017 	ldw	r16,0(sp)
 20326cc:	dec00304 	addi	sp,sp,12
 20326d0:	f800283a 	ret

020326d4 <lwip_getsockopt_callback>:
/** lwip_getsockopt_callback: only used without CORE_LOCKING
 * to get into the tcpip_thread
 */
static void
lwip_getsockopt_callback(void *arg)
{
 20326d4:	defffb04 	addi	sp,sp,-20
 20326d8:	dfc00415 	stw	ra,16(sp)
 20326dc:	df000315 	stw	fp,12(sp)
 20326e0:	df000304 	addi	fp,sp,12
 20326e4:	e13fff15 	stw	r4,-4(fp)
  struct lwip_setgetsockopt_data *data;
  LWIP_ASSERT("arg != NULL", arg != NULL);
  data = (struct lwip_setgetsockopt_data *)arg;
 20326e8:	e0bfff17 	ldw	r2,-4(fp)
 20326ec:	e0bffe15 	stw	r2,-8(fp)

  data->err = lwip_getsockopt_impl(data->s, data->level, data->optname,
 20326f0:	e0bffe17 	ldw	r2,-8(fp)
 20326f4:	10c00017 	ldw	r3,0(r2)
 20326f8:	e0bffe17 	ldw	r2,-8(fp)
 20326fc:	11000117 	ldw	r4,4(r2)
 2032700:	e0bffe17 	ldw	r2,-8(fp)
 2032704:	11400217 	ldw	r5,8(r2)
 2032708:	e0bffe17 	ldw	r2,-8(fp)
 203270c:	11800317 	ldw	r6,12(r2)
 2032710:	e0bffe17 	ldw	r2,-8(fp)
 2032714:	10800404 	addi	r2,r2,16
 2032718:	d8800015 	stw	r2,0(sp)
 203271c:	300f883a 	mov	r7,r6
 2032720:	280d883a 	mov	r6,r5
 2032724:	200b883a 	mov	r5,r4
 2032728:	1809883a 	mov	r4,r3
 203272c:	20327c00 	call	20327c0 <lwip_getsockopt_impl>
 2032730:	1007883a 	mov	r3,r2
 2032734:	e0bffe17 	ldw	r2,-8(fp)
 2032738:	10c00515 	stw	r3,20(r2)
#else /* LWIP_MPU_COMPATIBLE */
                                   data->optval.p,
#endif /* LWIP_MPU_COMPATIBLE */
                                   &data->optlen);

  sys_sem_signal((sys_sem_t *)(data->completed_sem));
 203273c:	e0bffe17 	ldw	r2,-8(fp)
 2032740:	10800617 	ldw	r2,24(r2)
 2032744:	1009883a 	mov	r4,r2
 2032748:	20150340 	call	2015034 <sys_sem_signal>
}
 203274c:	0001883a 	nop
 2032750:	e037883a 	mov	sp,fp
 2032754:	dfc00117 	ldw	ra,4(sp)
 2032758:	df000017 	ldw	fp,0(sp)
 203275c:	dec00204 	addi	sp,sp,8
 2032760:	f800283a 	ret

02032764 <lwip_sockopt_to_ipopt>:
#endif  /* LWIP_TCPIP_CORE_LOCKING */

static int
lwip_sockopt_to_ipopt(int optname)
{
 2032764:	defffe04 	addi	sp,sp,-8
 2032768:	df000115 	stw	fp,4(sp)
 203276c:	df000104 	addi	fp,sp,4
 2032770:	e13fff15 	stw	r4,-4(fp)
  /* Map SO_* values to our internal SOF_* values
   * We should not rely on #defines in socket.h
   * being in sync with ip.h.
   */
  switch (optname) {
 2032774:	e0bfff17 	ldw	r2,-4(fp)
 2032778:	10c00220 	cmpeqi	r3,r2,8
 203277c:	1800071e 	bne	r3,zero,203279c <lwip_sockopt_to_ipopt+0x38>
 2032780:	10c00820 	cmpeqi	r3,r2,32
 2032784:	1800031e 	bne	r3,zero,2032794 <lwip_sockopt_to_ipopt+0x30>
 2032788:	10800120 	cmpeqi	r2,r2,4
 203278c:	1000051e 	bne	r2,zero,20327a4 <lwip_sockopt_to_ipopt+0x40>
 2032790:	00000606 	br	20327ac <lwip_sockopt_to_ipopt+0x48>
  case SO_BROADCAST:
    return SOF_BROADCAST;
 2032794:	00800804 	movi	r2,32
 2032798:	00000506 	br	20327b0 <lwip_sockopt_to_ipopt+0x4c>
  case SO_KEEPALIVE:
    return SOF_KEEPALIVE;
 203279c:	00800204 	movi	r2,8
 20327a0:	00000306 	br	20327b0 <lwip_sockopt_to_ipopt+0x4c>
  case SO_REUSEADDR:
    return SOF_REUSEADDR;
 20327a4:	00800104 	movi	r2,4
 20327a8:	00000106 	br	20327b0 <lwip_sockopt_to_ipopt+0x4c>
  default:
    LWIP_ASSERT("Unknown socket option", 0);
    return 0;
 20327ac:	0005883a 	mov	r2,zero
  }
}
 20327b0:	e037883a 	mov	sp,fp
 20327b4:	df000017 	ldw	fp,0(sp)
 20327b8:	dec00104 	addi	sp,sp,4
 20327bc:	f800283a 	ret

020327c0 <lwip_getsockopt_impl>:
/** lwip_getsockopt_impl: the actual implementation of getsockopt:
 * same argument as lwip_getsockopt, either called directly or through callback
 */
static int
lwip_getsockopt_impl(int s, int level, int optname, void *optval, socklen_t *optlen)
{
 20327c0:	defff704 	addi	sp,sp,-36
 20327c4:	dfc00815 	stw	ra,32(sp)
 20327c8:	df000715 	stw	fp,28(sp)
 20327cc:	df000704 	addi	fp,sp,28
 20327d0:	e13ffc15 	stw	r4,-16(fp)
 20327d4:	e17ffd15 	stw	r5,-12(fp)
 20327d8:	e1bffe15 	stw	r6,-8(fp)
 20327dc:	e1ffff15 	stw	r7,-4(fp)
  int err = 0;
 20327e0:	e03ff915 	stw	zero,-28(fp)
  struct lwip_sock *sock = tryget_socket(s);
 20327e4:	e13ffc17 	ldw	r4,-16(fp)
 20327e8:	202ecf80 	call	202ecf8 <tryget_socket>
 20327ec:	e0bffa15 	stw	r2,-24(fp)
  if (!sock) {
 20327f0:	e0bffa17 	ldw	r2,-24(fp)
 20327f4:	1000021e 	bne	r2,zero,2032800 <lwip_getsockopt_impl+0x40>
    return EBADF;
 20327f8:	00800244 	movi	r2,9
 20327fc:	00019706 	br	2032e5c <lwip_getsockopt_impl+0x69c>
  if (LWIP_HOOK_SOCKETS_GETSOCKOPT(s, sock, level, optname, optval, optlen, &err)) {
    return err;
  }
#endif

  switch (level) {
 2032800:	e0bffd17 	ldw	r2,-12(fp)
 2032804:	10c001a0 	cmpeqi	r3,r2,6
 2032808:	1801281e 	bne	r3,zero,2032cac <lwip_getsockopt_impl+0x4ec>
 203280c:	10c001c8 	cmpgei	r3,r2,7
 2032810:	1800021e 	bne	r3,zero,203281c <lwip_getsockopt_impl+0x5c>
 2032814:	1000ee26 	beq	r2,zero,2032bd0 <lwip_getsockopt_impl+0x410>
 2032818:	00018c06 	br	2032e4c <lwip_getsockopt_impl+0x68c>
 203281c:	10c03fe0 	cmpeqi	r3,r2,255
 2032820:	1801861e 	bne	r3,zero,2032e3c <lwip_getsockopt_impl+0x67c>
 2032824:	1083ffe0 	cmpeqi	r2,r2,4095
 2032828:	10018826 	beq	r2,zero,2032e4c <lwip_getsockopt_impl+0x68c>

    /* Level: SOL_SOCKET */
    case SOL_SOCKET:
      switch (optname) {
 203282c:	e0bffe17 	ldw	r2,-8(fp)
 2032830:	10c00820 	cmpeqi	r3,r2,32
 2032834:	18003d1e 	bne	r3,zero,203292c <lwip_getsockopt_impl+0x16c>
 2032838:	10c00848 	cmpgei	r3,r2,33
 203283c:	1800071e 	bne	r3,zero,203285c <lwip_getsockopt_impl+0x9c>
 2032840:	10c00120 	cmpeqi	r3,r2,4
 2032844:	1800391e 	bne	r3,zero,203292c <lwip_getsockopt_impl+0x16c>
 2032848:	10c00220 	cmpeqi	r3,r2,8
 203284c:	1800371e 	bne	r3,zero,203292c <lwip_getsockopt_impl+0x16c>
 2032850:	108000a0 	cmpeqi	r2,r2,2
 2032854:	10000d1e 	bne	r2,zero,203288c <lwip_getsockopt_impl+0xcc>
 2032858:	0000d906 	br	2032bc0 <lwip_getsockopt_impl+0x400>
 203285c:	10c401e0 	cmpeqi	r3,r2,4103
 2032860:	1800831e 	bne	r3,zero,2032a70 <lwip_getsockopt_impl+0x2b0>
 2032864:	10c40208 	cmpgei	r3,r2,4104
 2032868:	1800031e 	bne	r3,zero,2032878 <lwip_getsockopt_impl+0xb8>
 203286c:	108401a0 	cmpeqi	r2,r2,4102
 2032870:	1000921e 	bne	r2,zero,2032abc <lwip_getsockopt_impl+0x2fc>
 2032874:	0000d206 	br	2032bc0 <lwip_getsockopt_impl+0x400>
 2032878:	10c40220 	cmpeqi	r3,r2,4104
 203287c:	1800521e 	bne	r3,zero,20329c8 <lwip_getsockopt_impl+0x208>
 2032880:	108402a0 	cmpeqi	r2,r2,4106
 2032884:	1000ac1e 	bne	r2,zero,2032b38 <lwip_getsockopt_impl+0x378>
 2032888:	0000cd06 	br	2032bc0 <lwip_getsockopt_impl+0x400>

#if LWIP_TCP
        case SO_ACCEPTCONN:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
 203288c:	e0800217 	ldw	r2,8(fp)
 2032890:	10800017 	ldw	r2,0(r2)
 2032894:	10800128 	cmpgeui	r2,r2,4
 2032898:	1000021e 	bne	r2,zero,20328a4 <lwip_getsockopt_impl+0xe4>
 203289c:	00800584 	movi	r2,22
 20328a0:	00016e06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 20328a4:	e0bffa17 	ldw	r2,-24(fp)
 20328a8:	10800017 	ldw	r2,0(r2)
 20328ac:	10000426 	beq	r2,zero,20328c0 <lwip_getsockopt_impl+0x100>
 20328b0:	e0bffa17 	ldw	r2,-24(fp)
 20328b4:	10800017 	ldw	r2,0(r2)
 20328b8:	10800217 	ldw	r2,8(r2)
 20328bc:	1000021e 	bne	r2,zero,20328c8 <lwip_getsockopt_impl+0x108>
 20328c0:	00800584 	movi	r2,22
 20328c4:	00016506 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_TCP) {
 20328c8:	e0bffa17 	ldw	r2,-24(fp)
 20328cc:	10800017 	ldw	r2,0(r2)
 20328d0:	10800017 	ldw	r2,0(r2)
 20328d4:	10803c0c 	andi	r2,r2,240
 20328d8:	10800420 	cmpeqi	r2,r2,16
 20328dc:	1000021e 	bne	r2,zero,20328e8 <lwip_getsockopt_impl+0x128>
            done_socket(sock);
            return ENOPROTOOPT;
 20328e0:	00801b44 	movi	r2,109
 20328e4:	00015d06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          }
          if ((sock->conn->pcb.tcp != NULL) && (sock->conn->pcb.tcp->state == LISTEN)) {
 20328e8:	e0bffa17 	ldw	r2,-24(fp)
 20328ec:	10800017 	ldw	r2,0(r2)
 20328f0:	10800217 	ldw	r2,8(r2)
 20328f4:	10000a26 	beq	r2,zero,2032920 <lwip_getsockopt_impl+0x160>
 20328f8:	e0bffa17 	ldw	r2,-24(fp)
 20328fc:	10800017 	ldw	r2,0(r2)
 2032900:	10800217 	ldw	r2,8(r2)
 2032904:	10800617 	ldw	r2,24(r2)
 2032908:	10800058 	cmpnei	r2,r2,1
 203290c:	1000041e 	bne	r2,zero,2032920 <lwip_getsockopt_impl+0x160>
            *(int *)optval = 1;
 2032910:	e0bfff17 	ldw	r2,-4(fp)
 2032914:	00c00044 	movi	r3,1
 2032918:	10c00015 	stw	r3,0(r2)
          } else {
            *(int *)optval = 0;
          }
          break;
 203291c:	0000ab06 	br	2032bcc <lwip_getsockopt_impl+0x40c>
            return ENOPROTOOPT;
          }
          if ((sock->conn->pcb.tcp != NULL) && (sock->conn->pcb.tcp->state == LISTEN)) {
            *(int *)optval = 1;
          } else {
            *(int *)optval = 0;
 2032920:	e0bfff17 	ldw	r2,-4(fp)
 2032924:	10000015 	stw	zero,0(r2)
          }
          break;
 2032928:	0000a806 	br	2032bcc <lwip_getsockopt_impl+0x40c>
        case SO_BROADCAST:
        case SO_KEEPALIVE:
#if SO_REUSE
        case SO_REUSEADDR:
#endif /* SO_REUSE */
          if ((optname == SO_BROADCAST) &&
 203292c:	e0bffe17 	ldw	r2,-8(fp)
 2032930:	10800818 	cmpnei	r2,r2,32
 2032934:	1000081e 	bne	r2,zero,2032958 <lwip_getsockopt_impl+0x198>
              (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP)) {
 2032938:	e0bffa17 	ldw	r2,-24(fp)
 203293c:	10800017 	ldw	r2,0(r2)
 2032940:	10800017 	ldw	r2,0(r2)
 2032944:	10803c0c 	andi	r2,r2,240
        case SO_BROADCAST:
        case SO_KEEPALIVE:
#if SO_REUSE
        case SO_REUSEADDR:
#endif /* SO_REUSE */
          if ((optname == SO_BROADCAST) &&
 2032948:	10800820 	cmpeqi	r2,r2,32
 203294c:	1000021e 	bne	r2,zero,2032958 <lwip_getsockopt_impl+0x198>
              (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP)) {
            done_socket(sock);
            return ENOPROTOOPT;
 2032950:	00801b44 	movi	r2,109
 2032954:	00014106 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          }

          optname = lwip_sockopt_to_ipopt(optname);
 2032958:	e13ffe17 	ldw	r4,-8(fp)
 203295c:	20327640 	call	2032764 <lwip_sockopt_to_ipopt>
 2032960:	e0bffe15 	stw	r2,-8(fp)

          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
 2032964:	e0800217 	ldw	r2,8(fp)
 2032968:	10800017 	ldw	r2,0(r2)
 203296c:	10800128 	cmpgeui	r2,r2,4
 2032970:	1000021e 	bne	r2,zero,203297c <lwip_getsockopt_impl+0x1bc>
 2032974:	00800584 	movi	r2,22
 2032978:	00013806 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 203297c:	e0bffa17 	ldw	r2,-24(fp)
 2032980:	10800017 	ldw	r2,0(r2)
 2032984:	10000426 	beq	r2,zero,2032998 <lwip_getsockopt_impl+0x1d8>
 2032988:	e0bffa17 	ldw	r2,-24(fp)
 203298c:	10800017 	ldw	r2,0(r2)
 2032990:	10800217 	ldw	r2,8(r2)
 2032994:	1000021e 	bne	r2,zero,20329a0 <lwip_getsockopt_impl+0x1e0>
 2032998:	00800584 	movi	r2,22
 203299c:	00012f06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          *(int *)optval = ip_get_option(sock->conn->pcb.ip, optname);
 20329a0:	e0bffa17 	ldw	r2,-24(fp)
 20329a4:	10800017 	ldw	r2,0(r2)
 20329a8:	10800217 	ldw	r2,8(r2)
 20329ac:	10800243 	ldbu	r2,9(r2)
 20329b0:	10c03fcc 	andi	r3,r2,255
 20329b4:	e0bffe17 	ldw	r2,-8(fp)
 20329b8:	1886703a 	and	r3,r3,r2
 20329bc:	e0bfff17 	ldw	r2,-4(fp)
 20329c0:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                      s, optname, (*(int *)optval ? "on" : "off")));
          break;
 20329c4:	00008106 	br	2032bcc <lwip_getsockopt_impl+0x40c>

        case SO_TYPE:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
 20329c8:	e0800217 	ldw	r2,8(fp)
 20329cc:	10800017 	ldw	r2,0(r2)
 20329d0:	10800128 	cmpgeui	r2,r2,4
 20329d4:	1000021e 	bne	r2,zero,20329e0 <lwip_getsockopt_impl+0x220>
 20329d8:	00800584 	movi	r2,22
 20329dc:	00011f06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 20329e0:	e0bffa17 	ldw	r2,-24(fp)
 20329e4:	10800017 	ldw	r2,0(r2)
 20329e8:	1000021e 	bne	r2,zero,20329f4 <lwip_getsockopt_impl+0x234>
 20329ec:	00800584 	movi	r2,22
 20329f0:	00011a06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          switch (NETCONNTYPE_GROUP(netconn_type(sock->conn))) {
 20329f4:	e0bffa17 	ldw	r2,-24(fp)
 20329f8:	10800017 	ldw	r2,0(r2)
 20329fc:	10800017 	ldw	r2,0(r2)
 2032a00:	10803c0c 	andi	r2,r2,240
 2032a04:	10c00820 	cmpeqi	r3,r2,32
 2032a08:	18000d1e 	bne	r3,zero,2032a40 <lwip_getsockopt_impl+0x280>
 2032a0c:	10c01020 	cmpeqi	r3,r2,64
 2032a10:	1800031e 	bne	r3,zero,2032a20 <lwip_getsockopt_impl+0x260>
 2032a14:	10800420 	cmpeqi	r2,r2,16
 2032a18:	1000051e 	bne	r2,zero,2032a30 <lwip_getsockopt_impl+0x270>
 2032a1c:	00000c06 	br	2032a50 <lwip_getsockopt_impl+0x290>
            case NETCONN_RAW:
              *(int *)optval = SOCK_RAW;
 2032a20:	e0bfff17 	ldw	r2,-4(fp)
 2032a24:	00c000c4 	movi	r3,3
 2032a28:	10c00015 	stw	r3,0(r2)
              break;
 2032a2c:	00000f06 	br	2032a6c <lwip_getsockopt_impl+0x2ac>
            case NETCONN_TCP:
              *(int *)optval = SOCK_STREAM;
 2032a30:	e0bfff17 	ldw	r2,-4(fp)
 2032a34:	00c00044 	movi	r3,1
 2032a38:	10c00015 	stw	r3,0(r2)
              break;
 2032a3c:	00000b06 	br	2032a6c <lwip_getsockopt_impl+0x2ac>
            case NETCONN_UDP:
              *(int *)optval = SOCK_DGRAM;
 2032a40:	e0bfff17 	ldw	r2,-4(fp)
 2032a44:	00c00084 	movi	r3,2
 2032a48:	10c00015 	stw	r3,0(r2)
              break;
 2032a4c:	00000706 	br	2032a6c <lwip_getsockopt_impl+0x2ac>
            default: /* unrecognized socket type */
              *(int *)optval = netconn_type(sock->conn);
 2032a50:	e0bffa17 	ldw	r2,-24(fp)
 2032a54:	10800017 	ldw	r2,0(r2)
 2032a58:	10800017 	ldw	r2,0(r2)
 2032a5c:	1007883a 	mov	r3,r2
 2032a60:	e0bfff17 	ldw	r2,-4(fp)
 2032a64:	10c00015 	stw	r3,0(r2)
                          ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                           s, *(int *)optval));
          }  /* switch (netconn_type(sock->conn)) */
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                                      s, *(int *)optval));
          break;
 2032a68:	00005806 	br	2032bcc <lwip_getsockopt_impl+0x40c>
 2032a6c:	00005706 	br	2032bcc <lwip_getsockopt_impl+0x40c>

        case SO_ERROR:
          LWIP_SOCKOPT_CHECK_OPTLEN(sock, *optlen, int);
 2032a70:	e0800217 	ldw	r2,8(fp)
 2032a74:	10800017 	ldw	r2,0(r2)
 2032a78:	10800128 	cmpgeui	r2,r2,4
 2032a7c:	1000021e 	bne	r2,zero,2032a88 <lwip_getsockopt_impl+0x2c8>
 2032a80:	00800584 	movi	r2,22
 2032a84:	0000f506 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          *(int *)optval = err_to_errno(netconn_err(sock->conn));
 2032a88:	e0bffa17 	ldw	r2,-24(fp)
 2032a8c:	10800017 	ldw	r2,0(r2)
 2032a90:	1009883a 	mov	r4,r2
 2032a94:	203f2800 	call	203f280 <netconn_err>
 2032a98:	10803fcc 	andi	r2,r2,255
 2032a9c:	1080201c 	xori	r2,r2,128
 2032aa0:	10bfe004 	addi	r2,r2,-128
 2032aa4:	1009883a 	mov	r4,r2
 2032aa8:	2041e900 	call	2041e90 <err_to_errno>
 2032aac:	1007883a 	mov	r3,r2
 2032ab0:	e0bfff17 	ldw	r2,-4(fp)
 2032ab4:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                                      s, *(int *)optval));
          break;
 2032ab8:	00004406 	br	2032bcc <lwip_getsockopt_impl+0x40c>
          LWIP_SO_SNDRCVTIMEO_SET(optval, netconn_get_sendtimeout(sock->conn));
          break;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
        case SO_RCVTIMEO:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
 2032abc:	e0800217 	ldw	r2,8(fp)
 2032ac0:	10800017 	ldw	r2,0(r2)
 2032ac4:	10800228 	cmpgeui	r2,r2,8
 2032ac8:	1000021e 	bne	r2,zero,2032ad4 <lwip_getsockopt_impl+0x314>
 2032acc:	00800584 	movi	r2,22
 2032ad0:	0000e206 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 2032ad4:	e0bffa17 	ldw	r2,-24(fp)
 2032ad8:	10800017 	ldw	r2,0(r2)
 2032adc:	1000021e 	bne	r2,zero,2032ae8 <lwip_getsockopt_impl+0x328>
 2032ae0:	00800584 	movi	r2,22
 2032ae4:	0000dd06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          LWIP_SO_SNDRCVTIMEO_SET(optval, netconn_get_recvtimeout(sock->conn));
 2032ae8:	e0bffa17 	ldw	r2,-24(fp)
 2032aec:	10800017 	ldw	r2,0(r2)
 2032af0:	10800817 	ldw	r2,32(r2)
 2032af4:	e0bffb15 	stw	r2,-20(fp)
 2032af8:	e0bffb17 	ldw	r2,-20(fp)
 2032afc:	0140fa04 	movi	r5,1000
 2032b00:	1009883a 	mov	r4,r2
 2032b04:	200aadc0 	call	200aadc <__udivsi3>
 2032b08:	1007883a 	mov	r3,r2
 2032b0c:	e0bfff17 	ldw	r2,-4(fp)
 2032b10:	10c00015 	stw	r3,0(r2)
 2032b14:	e0bffb17 	ldw	r2,-20(fp)
 2032b18:	0140fa04 	movi	r5,1000
 2032b1c:	1009883a 	mov	r4,r2
 2032b20:	200ab400 	call	200ab40 <__umodsi3>
 2032b24:	1080fa24 	muli	r2,r2,1000
 2032b28:	1007883a 	mov	r3,r2
 2032b2c:	e0bfff17 	ldw	r2,-4(fp)
 2032b30:	10c00115 	stw	r3,4(r2)
          break;
 2032b34:	00002506 	br	2032bcc <lwip_getsockopt_impl+0x40c>
        }
        break;
#endif /* LWIP_SO_LINGER */
#if LWIP_UDP
        case SO_NO_CHECK:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_UDP);
 2032b38:	e0800217 	ldw	r2,8(fp)
 2032b3c:	10800017 	ldw	r2,0(r2)
 2032b40:	10800128 	cmpgeui	r2,r2,4
 2032b44:	1000021e 	bne	r2,zero,2032b50 <lwip_getsockopt_impl+0x390>
 2032b48:	00800584 	movi	r2,22
 2032b4c:	0000c306 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 2032b50:	e0bffa17 	ldw	r2,-24(fp)
 2032b54:	10800017 	ldw	r2,0(r2)
 2032b58:	10000426 	beq	r2,zero,2032b6c <lwip_getsockopt_impl+0x3ac>
 2032b5c:	e0bffa17 	ldw	r2,-24(fp)
 2032b60:	10800017 	ldw	r2,0(r2)
 2032b64:	10800217 	ldw	r2,8(r2)
 2032b68:	1000021e 	bne	r2,zero,2032b74 <lwip_getsockopt_impl+0x3b4>
 2032b6c:	00800584 	movi	r2,22
 2032b70:	0000ba06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 2032b74:	e0bffa17 	ldw	r2,-24(fp)
 2032b78:	10800017 	ldw	r2,0(r2)
 2032b7c:	10800017 	ldw	r2,0(r2)
 2032b80:	10803c0c 	andi	r2,r2,240
 2032b84:	10800820 	cmpeqi	r2,r2,32
 2032b88:	1000021e 	bne	r2,zero,2032b94 <lwip_getsockopt_impl+0x3d4>
 2032b8c:	00801b44 	movi	r2,109
 2032b90:	0000b206 	br	2032e5c <lwip_getsockopt_impl+0x69c>
            /* this flag is only available for UDP, not for UDP lite */
            done_socket(sock);
            return EAFNOSUPPORT;
          }
#endif /* LWIP_UDPLITE */
          *(int *)optval = udp_is_flag_set(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM) ? 1 : 0;
 2032b94:	e0bffa17 	ldw	r2,-24(fp)
 2032b98:	10800017 	ldw	r2,0(r2)
 2032b9c:	10800217 	ldw	r2,8(r2)
 2032ba0:	10800503 	ldbu	r2,20(r2)
 2032ba4:	10803fcc 	andi	r2,r2,255
 2032ba8:	1080004c 	andi	r2,r2,1
 2032bac:	1004c03a 	cmpne	r2,r2,zero
 2032bb0:	10c03fcc 	andi	r3,r2,255
 2032bb4:	e0bfff17 	ldw	r2,-4(fp)
 2032bb8:	10c00015 	stw	r3,0(r2)
          break;
 2032bbc:	00000306 	br	2032bcc <lwip_getsockopt_impl+0x40c>
#endif /* LWIP_UDP*/
        default:
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                      s, optname));
          err = ENOPROTOOPT;
 2032bc0:	00801b44 	movi	r2,109
 2032bc4:	e0bff915 	stw	r2,-28(fp)
          break;
 2032bc8:	0001883a 	nop
      }  /* switch (optname) */
      break;
 2032bcc:	0000a206 	br	2032e58 <lwip_getsockopt_impl+0x698>

    /* Level: IPPROTO_IP */
    case IPPROTO_IP:
      switch (optname) {
 2032bd0:	e0bffe17 	ldw	r2,-8(fp)
 2032bd4:	10c00060 	cmpeqi	r3,r2,1
 2032bd8:	1800191e 	bne	r3,zero,2032c40 <lwip_getsockopt_impl+0x480>
 2032bdc:	108000a0 	cmpeqi	r2,r2,2
 2032be0:	10002e26 	beq	r2,zero,2032c9c <lwip_getsockopt_impl+0x4dc>
        case IP_TTL:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
 2032be4:	e0800217 	ldw	r2,8(fp)
 2032be8:	10800017 	ldw	r2,0(r2)
 2032bec:	10800128 	cmpgeui	r2,r2,4
 2032bf0:	1000021e 	bne	r2,zero,2032bfc <lwip_getsockopt_impl+0x43c>
 2032bf4:	00800584 	movi	r2,22
 2032bf8:	00009806 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 2032bfc:	e0bffa17 	ldw	r2,-24(fp)
 2032c00:	10800017 	ldw	r2,0(r2)
 2032c04:	10000426 	beq	r2,zero,2032c18 <lwip_getsockopt_impl+0x458>
 2032c08:	e0bffa17 	ldw	r2,-24(fp)
 2032c0c:	10800017 	ldw	r2,0(r2)
 2032c10:	10800217 	ldw	r2,8(r2)
 2032c14:	1000021e 	bne	r2,zero,2032c20 <lwip_getsockopt_impl+0x460>
 2032c18:	00800584 	movi	r2,22
 2032c1c:	00008f06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          *(int *)optval = sock->conn->pcb.ip->ttl;
 2032c20:	e0bffa17 	ldw	r2,-24(fp)
 2032c24:	10800017 	ldw	r2,0(r2)
 2032c28:	10800217 	ldw	r2,8(r2)
 2032c2c:	108002c3 	ldbu	r2,11(r2)
 2032c30:	10c03fcc 	andi	r3,r2,255
 2032c34:	e0bfff17 	ldw	r2,-4(fp)
 2032c38:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                                      s, *(int *)optval));
          break;
 2032c3c:	00001a06 	br	2032ca8 <lwip_getsockopt_impl+0x4e8>
        case IP_TOS:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
 2032c40:	e0800217 	ldw	r2,8(fp)
 2032c44:	10800017 	ldw	r2,0(r2)
 2032c48:	10800128 	cmpgeui	r2,r2,4
 2032c4c:	1000021e 	bne	r2,zero,2032c58 <lwip_getsockopt_impl+0x498>
 2032c50:	00800584 	movi	r2,22
 2032c54:	00008106 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 2032c58:	e0bffa17 	ldw	r2,-24(fp)
 2032c5c:	10800017 	ldw	r2,0(r2)
 2032c60:	10000426 	beq	r2,zero,2032c74 <lwip_getsockopt_impl+0x4b4>
 2032c64:	e0bffa17 	ldw	r2,-24(fp)
 2032c68:	10800017 	ldw	r2,0(r2)
 2032c6c:	10800217 	ldw	r2,8(r2)
 2032c70:	1000021e 	bne	r2,zero,2032c7c <lwip_getsockopt_impl+0x4bc>
 2032c74:	00800584 	movi	r2,22
 2032c78:	00007806 	br	2032e5c <lwip_getsockopt_impl+0x69c>
          *(int *)optval = sock->conn->pcb.ip->tos;
 2032c7c:	e0bffa17 	ldw	r2,-24(fp)
 2032c80:	10800017 	ldw	r2,0(r2)
 2032c84:	10800217 	ldw	r2,8(r2)
 2032c88:	10800283 	ldbu	r2,10(r2)
 2032c8c:	10c03fcc 	andi	r3,r2,255
 2032c90:	e0bfff17 	ldw	r2,-4(fp)
 2032c94:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                                      s, *(int *)optval));
          break;
 2032c98:	00000306 	br	2032ca8 <lwip_getsockopt_impl+0x4e8>
          break;
#endif /* LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS && LWIP_UDP */
        default:
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                      s, optname));
          err = ENOPROTOOPT;
 2032c9c:	00801b44 	movi	r2,109
 2032ca0:	e0bff915 	stw	r2,-28(fp)
          break;
 2032ca4:	0001883a 	nop
      }  /* switch (optname) */
      break;
 2032ca8:	00006b06 	br	2032e58 <lwip_getsockopt_impl+0x698>

#if LWIP_TCP
    /* Level: IPPROTO_TCP */
    case IPPROTO_TCP:
      /* Special case: all IPPROTO_TCP option take an int */
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_TCP);
 2032cac:	e0800217 	ldw	r2,8(fp)
 2032cb0:	10800017 	ldw	r2,0(r2)
 2032cb4:	10800128 	cmpgeui	r2,r2,4
 2032cb8:	1000021e 	bne	r2,zero,2032cc4 <lwip_getsockopt_impl+0x504>
 2032cbc:	00800584 	movi	r2,22
 2032cc0:	00006606 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 2032cc4:	e0bffa17 	ldw	r2,-24(fp)
 2032cc8:	10800017 	ldw	r2,0(r2)
 2032ccc:	10000426 	beq	r2,zero,2032ce0 <lwip_getsockopt_impl+0x520>
 2032cd0:	e0bffa17 	ldw	r2,-24(fp)
 2032cd4:	10800017 	ldw	r2,0(r2)
 2032cd8:	10800217 	ldw	r2,8(r2)
 2032cdc:	1000021e 	bne	r2,zero,2032ce8 <lwip_getsockopt_impl+0x528>
 2032ce0:	00800584 	movi	r2,22
 2032ce4:	00005d06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
 2032ce8:	e0bffa17 	ldw	r2,-24(fp)
 2032cec:	10800017 	ldw	r2,0(r2)
 2032cf0:	10800017 	ldw	r2,0(r2)
 2032cf4:	10803c0c 	andi	r2,r2,240
 2032cf8:	10800420 	cmpeqi	r2,r2,16
 2032cfc:	1000021e 	bne	r2,zero,2032d08 <lwip_getsockopt_impl+0x548>
 2032d00:	00801b44 	movi	r2,109
 2032d04:	00005506 	br	2032e5c <lwip_getsockopt_impl+0x69c>
      if (sock->conn->pcb.tcp->state == LISTEN) {
 2032d08:	e0bffa17 	ldw	r2,-24(fp)
 2032d0c:	10800017 	ldw	r2,0(r2)
 2032d10:	10800217 	ldw	r2,8(r2)
 2032d14:	10800617 	ldw	r2,24(r2)
 2032d18:	10800058 	cmpnei	r2,r2,1
 2032d1c:	1000021e 	bne	r2,zero,2032d28 <lwip_getsockopt_impl+0x568>
        done_socket(sock);
        return EINVAL;
 2032d20:	00800584 	movi	r2,22
 2032d24:	00004d06 	br	2032e5c <lwip_getsockopt_impl+0x69c>
      }
      switch (optname) {
 2032d28:	e0bffe17 	ldw	r2,-8(fp)
 2032d2c:	108001a8 	cmpgeui	r2,r2,6
 2032d30:	10003e1e 	bne	r2,zero,2032e2c <lwip_getsockopt_impl+0x66c>
 2032d34:	e0bffe17 	ldw	r2,-8(fp)
 2032d38:	100690ba 	slli	r3,r2,2
 2032d3c:	008080f4 	movhi	r2,515
 2032d40:	108b5404 	addi	r2,r2,11600
 2032d44:	1885883a 	add	r2,r3,r2
 2032d48:	10800017 	ldw	r2,0(r2)
 2032d4c:	1000683a 	jmp	r2
 2032d50:	02032e2c 	andhi	r8,zero,3256
 2032d54:	02032d68 	cmpgeui	r8,zero,3253
 2032d58:	02032d94 	movui	r8,3254
 2032d5c:	02032db4 	movhi	r8,3254
 2032d60:	02032de0 	cmpeqi	r8,zero,3255
 2032d64:	02032e0c 	andi	r8,zero,3256
        case TCP_NODELAY:
          *(int *)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
 2032d68:	e0bffa17 	ldw	r2,-24(fp)
 2032d6c:	10800017 	ldw	r2,0(r2)
 2032d70:	10800217 	ldw	r2,8(r2)
 2032d74:	1080088b 	ldhu	r2,34(r2)
 2032d78:	10bfffcc 	andi	r2,r2,65535
 2032d7c:	1080100c 	andi	r2,r2,64
 2032d80:	1004c03a 	cmpne	r2,r2,zero
 2032d84:	10c03fcc 	andi	r3,r2,255
 2032d88:	e0bfff17 	ldw	r2,-4(fp)
 2032d8c:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                                      s, (*(int *)optval) ? "on" : "off") );
          break;
 2032d90:	00002906 	br	2032e38 <lwip_getsockopt_impl+0x678>
        case TCP_KEEPALIVE:
          *(int *)optval = (int)sock->conn->pcb.tcp->keep_idle;
 2032d94:	e0bffa17 	ldw	r2,-24(fp)
 2032d98:	10800017 	ldw	r2,0(r2)
 2032d9c:	10800217 	ldw	r2,8(r2)
 2032da0:	10802717 	ldw	r2,156(r2)
 2032da4:	1007883a 	mov	r3,r2
 2032da8:	e0bfff17 	ldw	r2,-4(fp)
 2032dac:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) = %d\n",
                                      s, *(int *)optval));
          break;
 2032db0:	00002106 	br	2032e38 <lwip_getsockopt_impl+0x678>

#if LWIP_TCP_KEEPALIVE
        case TCP_KEEPIDLE:
          *(int *)optval = (int)(sock->conn->pcb.tcp->keep_idle / 1000);
 2032db4:	e0bffa17 	ldw	r2,-24(fp)
 2032db8:	10800017 	ldw	r2,0(r2)
 2032dbc:	10800217 	ldw	r2,8(r2)
 2032dc0:	10802717 	ldw	r2,156(r2)
 2032dc4:	0140fa04 	movi	r5,1000
 2032dc8:	1009883a 	mov	r4,r2
 2032dcc:	200aadc0 	call	200aadc <__udivsi3>
 2032dd0:	1007883a 	mov	r3,r2
 2032dd4:	e0bfff17 	ldw	r2,-4(fp)
 2032dd8:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) = %d\n",
                                      s, *(int *)optval));
          break;
 2032ddc:	00001606 	br	2032e38 <lwip_getsockopt_impl+0x678>
        case TCP_KEEPINTVL:
          *(int *)optval = (int)(sock->conn->pcb.tcp->keep_intvl / 1000);
 2032de0:	e0bffa17 	ldw	r2,-24(fp)
 2032de4:	10800017 	ldw	r2,0(r2)
 2032de8:	10800217 	ldw	r2,8(r2)
 2032dec:	10802817 	ldw	r2,160(r2)
 2032df0:	0140fa04 	movi	r5,1000
 2032df4:	1009883a 	mov	r4,r2
 2032df8:	200aadc0 	call	200aadc <__udivsi3>
 2032dfc:	1007883a 	mov	r3,r2
 2032e00:	e0bfff17 	ldw	r2,-4(fp)
 2032e04:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) = %d\n",
                                      s, *(int *)optval));
          break;
 2032e08:	00000b06 	br	2032e38 <lwip_getsockopt_impl+0x678>
        case TCP_KEEPCNT:
          *(int *)optval = (int)sock->conn->pcb.tcp->keep_cnt;
 2032e0c:	e0bffa17 	ldw	r2,-24(fp)
 2032e10:	10800017 	ldw	r2,0(r2)
 2032e14:	10800217 	ldw	r2,8(r2)
 2032e18:	10802917 	ldw	r2,164(r2)
 2032e1c:	1007883a 	mov	r3,r2
 2032e20:	e0bfff17 	ldw	r2,-4(fp)
 2032e24:	10c00015 	stw	r3,0(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) = %d\n",
                                      s, *(int *)optval));
          break;
 2032e28:	00000306 	br	2032e38 <lwip_getsockopt_impl+0x678>
#endif /* LWIP_TCP_KEEPALIVE */
        default:
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                      s, optname));
          err = ENOPROTOOPT;
 2032e2c:	00801b44 	movi	r2,109
 2032e30:	e0bff915 	stw	r2,-28(fp)
          break;
 2032e34:	0001883a 	nop
      }  /* switch (optname) */
      break;
 2032e38:	00000706 	br	2032e58 <lwip_getsockopt_impl+0x698>
          break;
#endif /* LWIP_IPV6 && LWIP_RAW */
        default:
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_RAW, UNIMPL: optname=0x%x, ..)\n",
                                      s, optname));
          err = ENOPROTOOPT;
 2032e3c:	00801b44 	movi	r2,109
 2032e40:	e0bff915 	stw	r2,-28(fp)
          break;
 2032e44:	0001883a 	nop
      }  /* switch (optname) */
      break;
 2032e48:	00000306 	br	2032e58 <lwip_getsockopt_impl+0x698>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
 2032e4c:	00801b44 	movi	r2,109
 2032e50:	e0bff915 	stw	r2,-28(fp)
      break;
 2032e54:	0001883a 	nop
  } /* switch (level) */

  done_socket(sock);
  return err;
 2032e58:	e0bff917 	ldw	r2,-28(fp)
}
 2032e5c:	e037883a 	mov	sp,fp
 2032e60:	dfc00117 	ldw	ra,4(sp)
 2032e64:	df000017 	ldw	fp,0(sp)
 2032e68:	dec00204 	addi	sp,sp,8
 2032e6c:	f800283a 	ret

02032e70 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
 2032e70:	deffef04 	addi	sp,sp,-68
 2032e74:	dfc01015 	stw	ra,64(sp)
 2032e78:	df000f15 	stw	fp,60(sp)
 2032e7c:	dc000e15 	stw	r16,56(sp)
 2032e80:	df000f04 	addi	fp,sp,60
 2032e84:	e13ffb15 	stw	r4,-20(fp)
 2032e88:	e17ffc15 	stw	r5,-16(fp)
 2032e8c:	e1bffd15 	stw	r6,-12(fp)
 2032e90:	e1fffe15 	stw	r7,-8(fp)
  int err = 0;
 2032e94:	e03ff115 	stw	zero,-60(fp)
  struct lwip_sock *sock = get_socket(s);
 2032e98:	e13ffb17 	ldw	r4,-20(fp)
 2032e9c:	202ed4c0 	call	202ed4c <get_socket>
 2032ea0:	e0bff215 	stw	r2,-56(fp)
#if !LWIP_TCPIP_CORE_LOCKING
  err_t cberr;
  LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
#endif /* !LWIP_TCPIP_CORE_LOCKING */

  if (!sock) {
 2032ea4:	e0bff217 	ldw	r2,-56(fp)
 2032ea8:	1000021e 	bne	r2,zero,2032eb4 <lwip_setsockopt+0x44>
    return -1;
 2032eac:	00bfffc4 	movi	r2,-1
 2032eb0:	00003d06 	br	2032fa8 <lwip_setsockopt+0x138>
  }

  if (NULL == optval) {
 2032eb4:	e0bffe17 	ldw	r2,-8(fp)
 2032eb8:	1000061e 	bne	r2,zero,2032ed4 <lwip_setsockopt+0x64>
    set_errno(EFAULT);
 2032ebc:	20423b80 	call	20423b8 <__errno>
 2032ec0:	1007883a 	mov	r3,r2
 2032ec4:	00800384 	movi	r2,14
 2032ec8:	18800015 	stw	r2,0(r3)
    done_socket(sock);
    return -1;
 2032ecc:	00bfffc4 	movi	r2,-1
 2032ed0:	00003506 	br	2032fa8 <lwip_setsockopt+0x138>
    return -1;
  }
#endif /* LWIP_MPU_COMPATIBLE */

  LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(data, sock);
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).s = s;
 2032ed4:	e0bffb17 	ldw	r2,-20(fp)
 2032ed8:	e0bff415 	stw	r2,-48(fp)
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).level = level;
 2032edc:	e0bffc17 	ldw	r2,-16(fp)
 2032ee0:	e0bff515 	stw	r2,-44(fp)
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optname = optname;
 2032ee4:	e0bffd17 	ldw	r2,-12(fp)
 2032ee8:	e0bff615 	stw	r2,-40(fp)
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen = optlen;
 2032eec:	e0800217 	ldw	r2,8(fp)
 2032ef0:	e0bff815 	stw	r2,-32(fp)
#if LWIP_MPU_COMPATIBLE
  MEMCPY(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval, optval, optlen);
#else /* LWIP_MPU_COMPATIBLE */
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval.pc = (const void *)optval;
 2032ef4:	e0bffe17 	ldw	r2,-8(fp)
 2032ef8:	e0bff715 	stw	r2,-36(fp)
#endif /* LWIP_MPU_COMPATIBLE */
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err = 0;
 2032efc:	e03ff915 	stw	zero,-28(fp)
#if LWIP_NETCONN_SEM_PER_THREAD
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
#else
  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = &sock->conn->op_completed;
 2032f00:	e0bff217 	ldw	r2,-56(fp)
 2032f04:	10800017 	ldw	r2,0(r2)
 2032f08:	10800404 	addi	r2,r2,16
 2032f0c:	e0bffa15 	stw	r2,-24(fp)
#endif
  cberr = tcpip_callback(lwip_setsockopt_callback, &LWIP_SETGETSOCKOPT_DATA_VAR_REF(data));
 2032f10:	e0bff404 	addi	r2,fp,-48
 2032f14:	100b883a 	mov	r5,r2
 2032f18:	010080f4 	movhi	r4,515
 2032f1c:	210bf004 	addi	r4,r4,12224
 2032f20:	2033e940 	call	2033e94 <tcpip_callback>
 2032f24:	e0bff305 	stb	r2,-52(fp)
  if (cberr != ERR_OK) {
 2032f28:	e0bff307 	ldb	r2,-52(fp)
 2032f2c:	10000c26 	beq	r2,zero,2032f60 <lwip_setsockopt+0xf0>
    LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
    set_errno(err_to_errno(cberr));
 2032f30:	e0bff307 	ldb	r2,-52(fp)
 2032f34:	1009883a 	mov	r4,r2
 2032f38:	2041e900 	call	2041e90 <err_to_errno>
 2032f3c:	10000626 	beq	r2,zero,2032f58 <lwip_setsockopt+0xe8>
 2032f40:	20423b80 	call	20423b8 <__errno>
 2032f44:	1021883a 	mov	r16,r2
 2032f48:	e0bff307 	ldb	r2,-52(fp)
 2032f4c:	1009883a 	mov	r4,r2
 2032f50:	2041e900 	call	2041e90 <err_to_errno>
 2032f54:	80800015 	stw	r2,0(r16)
    done_socket(sock);
    return -1;
 2032f58:	00bfffc4 	movi	r2,-1
 2032f5c:	00001206 	br	2032fa8 <lwip_setsockopt+0x138>
  }
  sys_arch_sem_wait((sys_sem_t *)(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem), 0);
 2032f60:	e0bffa17 	ldw	r2,-24(fp)
 2032f64:	000b883a 	mov	r5,zero
 2032f68:	1009883a 	mov	r4,r2
 2032f6c:	20150800 	call	2015080 <sys_arch_sem_wait>

  /* maybe lwip_setsockopt_impl has changed err */
  err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
 2032f70:	e0bff917 	ldw	r2,-28(fp)
 2032f74:	e0bff115 	stw	r2,-60(fp)
  LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
#endif  /* LWIP_TCPIP_CORE_LOCKING */

  set_errno(err);
 2032f78:	e0bff117 	ldw	r2,-60(fp)
 2032f7c:	10000426 	beq	r2,zero,2032f90 <lwip_setsockopt+0x120>
 2032f80:	20423b80 	call	20423b8 <__errno>
 2032f84:	1007883a 	mov	r3,r2
 2032f88:	e0bff117 	ldw	r2,-60(fp)
 2032f8c:	18800015 	stw	r2,0(r3)
  done_socket(sock);
  return err ? -1 : 0;
 2032f90:	e0bff117 	ldw	r2,-60(fp)
 2032f94:	10000226 	beq	r2,zero,2032fa0 <lwip_setsockopt+0x130>
 2032f98:	00bfffc4 	movi	r2,-1
 2032f9c:	00000206 	br	2032fa8 <lwip_setsockopt+0x138>
 2032fa0:	0005883a 	mov	r2,zero
 2032fa4:	0001883a 	nop
}
 2032fa8:	e6ffff04 	addi	sp,fp,-4
 2032fac:	dfc00217 	ldw	ra,8(sp)
 2032fb0:	df000117 	ldw	fp,4(sp)
 2032fb4:	dc000017 	ldw	r16,0(sp)
 2032fb8:	dec00304 	addi	sp,sp,12
 2032fbc:	f800283a 	ret

02032fc0 <lwip_setsockopt_callback>:
/** lwip_setsockopt_callback: only used without CORE_LOCKING
 * to get into the tcpip_thread
 */
static void
lwip_setsockopt_callback(void *arg)
{
 2032fc0:	defffb04 	addi	sp,sp,-20
 2032fc4:	dfc00415 	stw	ra,16(sp)
 2032fc8:	df000315 	stw	fp,12(sp)
 2032fcc:	df000304 	addi	fp,sp,12
 2032fd0:	e13fff15 	stw	r4,-4(fp)
  struct lwip_setgetsockopt_data *data;
  LWIP_ASSERT("arg != NULL", arg != NULL);
  data = (struct lwip_setgetsockopt_data *)arg;
 2032fd4:	e0bfff17 	ldw	r2,-4(fp)
 2032fd8:	e0bffe15 	stw	r2,-8(fp)

  data->err = lwip_setsockopt_impl(data->s, data->level, data->optname,
 2032fdc:	e0bffe17 	ldw	r2,-8(fp)
 2032fe0:	10c00017 	ldw	r3,0(r2)
 2032fe4:	e0bffe17 	ldw	r2,-8(fp)
 2032fe8:	11000117 	ldw	r4,4(r2)
 2032fec:	e0bffe17 	ldw	r2,-8(fp)
 2032ff0:	11400217 	ldw	r5,8(r2)
 2032ff4:	e0bffe17 	ldw	r2,-8(fp)
 2032ff8:	11800317 	ldw	r6,12(r2)
 2032ffc:	e0bffe17 	ldw	r2,-8(fp)
 2033000:	10800417 	ldw	r2,16(r2)
 2033004:	d8800015 	stw	r2,0(sp)
 2033008:	300f883a 	mov	r7,r6
 203300c:	280d883a 	mov	r6,r5
 2033010:	200b883a 	mov	r5,r4
 2033014:	1809883a 	mov	r4,r3
 2033018:	20330500 	call	2033050 <lwip_setsockopt_impl>
 203301c:	1007883a 	mov	r3,r2
 2033020:	e0bffe17 	ldw	r2,-8(fp)
 2033024:	10c00515 	stw	r3,20(r2)
#else /* LWIP_MPU_COMPATIBLE */
                                   data->optval.pc,
#endif /* LWIP_MPU_COMPATIBLE */
                                   data->optlen);

  sys_sem_signal((sys_sem_t *)(data->completed_sem));
 2033028:	e0bffe17 	ldw	r2,-8(fp)
 203302c:	10800617 	ldw	r2,24(r2)
 2033030:	1009883a 	mov	r4,r2
 2033034:	20150340 	call	2015034 <sys_sem_signal>
}
 2033038:	0001883a 	nop
 203303c:	e037883a 	mov	sp,fp
 2033040:	dfc00117 	ldw	ra,4(sp)
 2033044:	df000017 	ldw	fp,0(sp)
 2033048:	dec00204 	addi	sp,sp,8
 203304c:	f800283a 	ret

02033050 <lwip_setsockopt_impl>:
/** lwip_setsockopt_impl: the actual implementation of setsockopt:
 * same argument as lwip_setsockopt, either called directly or through callback
 */
static int
lwip_setsockopt_impl(int s, int level, int optname, const void *optval, socklen_t optlen)
{
 2033050:	defff404 	addi	sp,sp,-48
 2033054:	dfc00b15 	stw	ra,44(sp)
 2033058:	df000a15 	stw	fp,40(sp)
 203305c:	dc000915 	stw	r16,36(sp)
 2033060:	df000a04 	addi	fp,sp,40
 2033064:	e13ffb15 	stw	r4,-20(fp)
 2033068:	e17ffc15 	stw	r5,-16(fp)
 203306c:	e1bffd15 	stw	r6,-12(fp)
 2033070:	e1fffe15 	stw	r7,-8(fp)
  int err = 0;
 2033074:	e03ff615 	stw	zero,-40(fp)
  struct lwip_sock *sock = tryget_socket(s);
 2033078:	e13ffb17 	ldw	r4,-20(fp)
 203307c:	202ecf80 	call	202ecf8 <tryget_socket>
 2033080:	e0bff815 	stw	r2,-32(fp)
  if (!sock) {
 2033084:	e0bff817 	ldw	r2,-32(fp)
 2033088:	1000021e 	bne	r2,zero,2033094 <lwip_setsockopt_impl+0x44>
    return EBADF;
 203308c:	00800244 	movi	r2,9
 2033090:	00018206 	br	203369c <lwip_setsockopt_impl+0x64c>
  if (LWIP_HOOK_SOCKETS_SETSOCKOPT(s, sock, level, optname, optval, optlen, &err)) {
    return err;
  }
#endif

  switch (level) {
 2033094:	e0bffc17 	ldw	r2,-16(fp)
 2033098:	10c001a0 	cmpeqi	r3,r2,6
 203309c:	18010f1e 	bne	r3,zero,20334dc <lwip_setsockopt_impl+0x48c>
 20330a0:	10c001c8 	cmpgei	r3,r2,7
 20330a4:	1800021e 	bne	r3,zero,20330b0 <lwip_setsockopt_impl+0x60>
 20330a8:	1000d926 	beq	r2,zero,2033410 <lwip_setsockopt_impl+0x3c0>
 20330ac:	00017706 	br	203368c <lwip_setsockopt_impl+0x63c>
 20330b0:	10c03fe0 	cmpeqi	r3,r2,255
 20330b4:	1801711e 	bne	r3,zero,203367c <lwip_setsockopt_impl+0x62c>
 20330b8:	1083ffe0 	cmpeqi	r2,r2,4095
 20330bc:	10017326 	beq	r2,zero,203368c <lwip_setsockopt_impl+0x63c>

    /* Level: SOL_SOCKET */
    case SOL_SOCKET:
      switch (optname) {
 20330c0:	e0bffd17 	ldw	r2,-12(fp)
 20330c4:	10c00820 	cmpeqi	r3,r2,32
 20330c8:	18000e1e 	bne	r3,zero,2033104 <lwip_setsockopt_impl+0xb4>
 20330cc:	10c00848 	cmpgei	r3,r2,33
 20330d0:	1800051e 	bne	r3,zero,20330e8 <lwip_setsockopt_impl+0x98>
 20330d4:	10c00120 	cmpeqi	r3,r2,4
 20330d8:	18000a1e 	bne	r3,zero,2033104 <lwip_setsockopt_impl+0xb4>
 20330dc:	10800220 	cmpeqi	r2,r2,8
 20330e0:	1000081e 	bne	r2,zero,2033104 <lwip_setsockopt_impl+0xb4>
 20330e4:	0000c606 	br	2033400 <lwip_setsockopt_impl+0x3b0>
 20330e8:	10c402a0 	cmpeqi	r3,r2,4106
 20330ec:	18005a1e 	bne	r3,zero,2033258 <lwip_setsockopt_impl+0x208>
 20330f0:	10c402e0 	cmpeqi	r3,r2,4107
 20330f4:	1800861e 	bne	r3,zero,2033310 <lwip_setsockopt_impl+0x2c0>
 20330f8:	108401a0 	cmpeqi	r2,r2,4102
 20330fc:	1000391e 	bne	r2,zero,20331e4 <lwip_setsockopt_impl+0x194>
 2033100:	0000bf06 	br	2033400 <lwip_setsockopt_impl+0x3b0>
        case SO_BROADCAST:
        case SO_KEEPALIVE:
#if SO_REUSE
        case SO_REUSEADDR:
#endif /* SO_REUSE */
          if ((optname == SO_BROADCAST) &&
 2033104:	e0bffd17 	ldw	r2,-12(fp)
 2033108:	10800818 	cmpnei	r2,r2,32
 203310c:	1000081e 	bne	r2,zero,2033130 <lwip_setsockopt_impl+0xe0>
              (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP)) {
 2033110:	e0bff817 	ldw	r2,-32(fp)
 2033114:	10800017 	ldw	r2,0(r2)
 2033118:	10800017 	ldw	r2,0(r2)
 203311c:	10803c0c 	andi	r2,r2,240
        case SO_BROADCAST:
        case SO_KEEPALIVE:
#if SO_REUSE
        case SO_REUSEADDR:
#endif /* SO_REUSE */
          if ((optname == SO_BROADCAST) &&
 2033120:	10800820 	cmpeqi	r2,r2,32
 2033124:	1000021e 	bne	r2,zero,2033130 <lwip_setsockopt_impl+0xe0>
              (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP)) {
            done_socket(sock);
            return ENOPROTOOPT;
 2033128:	00801b44 	movi	r2,109
 203312c:	00015b06 	br	203369c <lwip_setsockopt_impl+0x64c>
          }

          optname = lwip_sockopt_to_ipopt(optname);
 2033130:	e13ffd17 	ldw	r4,-12(fp)
 2033134:	20327640 	call	2032764 <lwip_sockopt_to_ipopt>
 2033138:	e0bffd15 	stw	r2,-12(fp)

          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
 203313c:	e0800217 	ldw	r2,8(fp)
 2033140:	10800128 	cmpgeui	r2,r2,4
 2033144:	1000021e 	bne	r2,zero,2033150 <lwip_setsockopt_impl+0x100>
 2033148:	00800584 	movi	r2,22
 203314c:	00015306 	br	203369c <lwip_setsockopt_impl+0x64c>
 2033150:	e0bff817 	ldw	r2,-32(fp)
 2033154:	10800017 	ldw	r2,0(r2)
 2033158:	10000426 	beq	r2,zero,203316c <lwip_setsockopt_impl+0x11c>
 203315c:	e0bff817 	ldw	r2,-32(fp)
 2033160:	10800017 	ldw	r2,0(r2)
 2033164:	10800217 	ldw	r2,8(r2)
 2033168:	1000021e 	bne	r2,zero,2033174 <lwip_setsockopt_impl+0x124>
 203316c:	00800584 	movi	r2,22
 2033170:	00014a06 	br	203369c <lwip_setsockopt_impl+0x64c>
          if (*(const int *)optval) {
 2033174:	e0bffe17 	ldw	r2,-8(fp)
 2033178:	10800017 	ldw	r2,0(r2)
 203317c:	10000c26 	beq	r2,zero,20331b0 <lwip_setsockopt_impl+0x160>
            ip_set_option(sock->conn->pcb.ip, optname);
 2033180:	e0bff817 	ldw	r2,-32(fp)
 2033184:	10800017 	ldw	r2,0(r2)
 2033188:	10800217 	ldw	r2,8(r2)
 203318c:	e0fff817 	ldw	r3,-32(fp)
 2033190:	18c00017 	ldw	r3,0(r3)
 2033194:	18c00217 	ldw	r3,8(r3)
 2033198:	18c00243 	ldbu	r3,9(r3)
 203319c:	1809883a 	mov	r4,r3
 20331a0:	e0fffd17 	ldw	r3,-12(fp)
 20331a4:	20c6b03a 	or	r3,r4,r3
 20331a8:	10c00245 	stb	r3,9(r2)
          } else {
            ip_reset_option(sock->conn->pcb.ip, optname);
          }
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                                      s, optname, (*(const int *)optval ? "on" : "off")));
          break;
 20331ac:	00009706 	br	203340c <lwip_setsockopt_impl+0x3bc>

          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
          if (*(const int *)optval) {
            ip_set_option(sock->conn->pcb.ip, optname);
          } else {
            ip_reset_option(sock->conn->pcb.ip, optname);
 20331b0:	e0bff817 	ldw	r2,-32(fp)
 20331b4:	10800017 	ldw	r2,0(r2)
 20331b8:	10800217 	ldw	r2,8(r2)
 20331bc:	e0fff817 	ldw	r3,-32(fp)
 20331c0:	18c00017 	ldw	r3,0(r3)
 20331c4:	18c00217 	ldw	r3,8(r3)
 20331c8:	18c00243 	ldbu	r3,9(r3)
 20331cc:	1809883a 	mov	r4,r3
 20331d0:	e0fffd17 	ldw	r3,-12(fp)
 20331d4:	00c6303a 	nor	r3,zero,r3
 20331d8:	20c6703a 	and	r3,r4,r3
 20331dc:	10c00245 	stb	r3,9(r2)
          }
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                                      s, optname, (*(const int *)optval ? "on" : "off")));
          break;
 20331e0:	00008a06 	br	203340c <lwip_setsockopt_impl+0x3bc>
        }
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
        case SO_RCVTIMEO: {
          long ms_long;
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
 20331e4:	e0800217 	ldw	r2,8(fp)
 20331e8:	10800228 	cmpgeui	r2,r2,8
 20331ec:	1000021e 	bne	r2,zero,20331f8 <lwip_setsockopt_impl+0x1a8>
 20331f0:	00800584 	movi	r2,22
 20331f4:	00012906 	br	203369c <lwip_setsockopt_impl+0x64c>
 20331f8:	e0bff817 	ldw	r2,-32(fp)
 20331fc:	10800017 	ldw	r2,0(r2)
 2033200:	1000021e 	bne	r2,zero,203320c <lwip_setsockopt_impl+0x1bc>
 2033204:	00800584 	movi	r2,22
 2033208:	00012406 	br	203369c <lwip_setsockopt_impl+0x64c>
          ms_long = LWIP_SO_SNDRCVTIMEO_GET_MS(optval);
 203320c:	e0bffe17 	ldw	r2,-8(fp)
 2033210:	10800017 	ldw	r2,0(r2)
 2033214:	1400fa24 	muli	r16,r2,1000
 2033218:	e0bffe17 	ldw	r2,-8(fp)
 203321c:	10800117 	ldw	r2,4(r2)
 2033220:	0140fa04 	movi	r5,1000
 2033224:	1009883a 	mov	r4,r2
 2033228:	200a9e40 	call	200a9e4 <__divsi3>
 203322c:	8085883a 	add	r2,r16,r2
 2033230:	e0bff915 	stw	r2,-28(fp)
          if (ms_long < 0) {
 2033234:	e0bff917 	ldw	r2,-28(fp)
 2033238:	1000020e 	bge	r2,zero,2033244 <lwip_setsockopt_impl+0x1f4>
            done_socket(sock);
            return EINVAL;
 203323c:	00800584 	movi	r2,22
 2033240:	00011606 	br	203369c <lwip_setsockopt_impl+0x64c>
          }
          netconn_set_recvtimeout(sock->conn, (u32_t)ms_long);
 2033244:	e0bff817 	ldw	r2,-32(fp)
 2033248:	10800017 	ldw	r2,0(r2)
 203324c:	e0fff917 	ldw	r3,-28(fp)
 2033250:	10c00815 	stw	r3,32(r2)
          break;
 2033254:	00006d06 	br	203340c <lwip_setsockopt_impl+0x3bc>
        }
        break;
#endif /* LWIP_SO_LINGER */
#if LWIP_UDP
        case SO_NO_CHECK:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_UDP);
 2033258:	e0800217 	ldw	r2,8(fp)
 203325c:	10800128 	cmpgeui	r2,r2,4
 2033260:	1000021e 	bne	r2,zero,203326c <lwip_setsockopt_impl+0x21c>
 2033264:	00800584 	movi	r2,22
 2033268:	00010c06 	br	203369c <lwip_setsockopt_impl+0x64c>
 203326c:	e0bff817 	ldw	r2,-32(fp)
 2033270:	10800017 	ldw	r2,0(r2)
 2033274:	10000426 	beq	r2,zero,2033288 <lwip_setsockopt_impl+0x238>
 2033278:	e0bff817 	ldw	r2,-32(fp)
 203327c:	10800017 	ldw	r2,0(r2)
 2033280:	10800217 	ldw	r2,8(r2)
 2033284:	1000021e 	bne	r2,zero,2033290 <lwip_setsockopt_impl+0x240>
 2033288:	00800584 	movi	r2,22
 203328c:	00010306 	br	203369c <lwip_setsockopt_impl+0x64c>
 2033290:	e0bff817 	ldw	r2,-32(fp)
 2033294:	10800017 	ldw	r2,0(r2)
 2033298:	10800017 	ldw	r2,0(r2)
 203329c:	10803c0c 	andi	r2,r2,240
 20332a0:	10800820 	cmpeqi	r2,r2,32
 20332a4:	1000021e 	bne	r2,zero,20332b0 <lwip_setsockopt_impl+0x260>
 20332a8:	00801b44 	movi	r2,109
 20332ac:	0000fb06 	br	203369c <lwip_setsockopt_impl+0x64c>
            /* this flag is only available for UDP, not for UDP lite */
            done_socket(sock);
            return EAFNOSUPPORT;
          }
#endif /* LWIP_UDPLITE */
          if (*(const int *)optval) {
 20332b0:	e0bffe17 	ldw	r2,-8(fp)
 20332b4:	10800017 	ldw	r2,0(r2)
 20332b8:	10000a26 	beq	r2,zero,20332e4 <lwip_setsockopt_impl+0x294>
            udp_set_flags(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 20332bc:	e0bff817 	ldw	r2,-32(fp)
 20332c0:	10800017 	ldw	r2,0(r2)
 20332c4:	10800217 	ldw	r2,8(r2)
 20332c8:	e0fff817 	ldw	r3,-32(fp)
 20332cc:	18c00017 	ldw	r3,0(r3)
 20332d0:	18c00217 	ldw	r3,8(r3)
 20332d4:	18c00503 	ldbu	r3,20(r3)
 20332d8:	18c00054 	ori	r3,r3,1
 20332dc:	10c00505 	stb	r3,20(r2)
          } else {
            udp_clear_flags(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
          }
          break;
 20332e0:	00004a06 	br	203340c <lwip_setsockopt_impl+0x3bc>
          }
#endif /* LWIP_UDPLITE */
          if (*(const int *)optval) {
            udp_set_flags(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
          } else {
            udp_clear_flags(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 20332e4:	e0bff817 	ldw	r2,-32(fp)
 20332e8:	10800017 	ldw	r2,0(r2)
 20332ec:	10800217 	ldw	r2,8(r2)
 20332f0:	e0fff817 	ldw	r3,-32(fp)
 20332f4:	18c00017 	ldw	r3,0(r3)
 20332f8:	18c00217 	ldw	r3,8(r3)
 20332fc:	19000503 	ldbu	r4,20(r3)
 2033300:	00ffff84 	movi	r3,-2
 2033304:	20c6703a 	and	r3,r4,r3
 2033308:	10c00505 	stb	r3,20(r2)
          }
          break;
 203330c:	00003f06 	br	203340c <lwip_setsockopt_impl+0x3bc>
#endif /* LWIP_UDP */
        case SO_BINDTODEVICE: {
          const struct ifreq *iface;
          struct netif *n = NULL;
 2033310:	e03ff715 	stw	zero,-36(fp)

          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, struct ifreq);
 2033314:	e0800217 	ldw	r2,8(fp)
 2033318:	108001a8 	cmpgeui	r2,r2,6
 203331c:	1000021e 	bne	r2,zero,2033328 <lwip_setsockopt_impl+0x2d8>
 2033320:	00800584 	movi	r2,22
 2033324:	0000dd06 	br	203369c <lwip_setsockopt_impl+0x64c>
 2033328:	e0bff817 	ldw	r2,-32(fp)
 203332c:	10800017 	ldw	r2,0(r2)
 2033330:	1000021e 	bne	r2,zero,203333c <lwip_setsockopt_impl+0x2ec>
 2033334:	00800584 	movi	r2,22
 2033338:	0000d806 	br	203369c <lwip_setsockopt_impl+0x64c>

          iface = (const struct ifreq *)optval;
 203333c:	e0bffe17 	ldw	r2,-8(fp)
 2033340:	e0bffa15 	stw	r2,-24(fp)
          if (iface->ifr_name[0] != 0) {
 2033344:	e0bffa17 	ldw	r2,-24(fp)
 2033348:	10800003 	ldbu	r2,0(r2)
 203334c:	10803fcc 	andi	r2,r2,255
 2033350:	1080201c 	xori	r2,r2,128
 2033354:	10bfe004 	addi	r2,r2,-128
 2033358:	10000826 	beq	r2,zero,203337c <lwip_setsockopt_impl+0x32c>
            n = netif_find(iface->ifr_name);
 203335c:	e0bffa17 	ldw	r2,-24(fp)
 2033360:	1009883a 	mov	r4,r2
 2033364:	201c69c0 	call	201c69c <netif_find>
 2033368:	e0bff715 	stw	r2,-36(fp)
            if (n == NULL) {
 203336c:	e0bff717 	ldw	r2,-36(fp)
 2033370:	1000021e 	bne	r2,zero,203337c <lwip_setsockopt_impl+0x32c>
              done_socket(sock);
              return ENODEV;
 2033374:	008004c4 	movi	r2,19
 2033378:	0000c806 	br	203369c <lwip_setsockopt_impl+0x64c>
            }
          }

          switch (NETCONNTYPE_GROUP(netconn_type(sock->conn))) {
 203337c:	e0bff817 	ldw	r2,-32(fp)
 2033380:	10800017 	ldw	r2,0(r2)
 2033384:	10800017 	ldw	r2,0(r2)
 2033388:	10803c0c 	andi	r2,r2,240
 203338c:	10c00820 	cmpeqi	r3,r2,32
 2033390:	18000c1e 	bne	r3,zero,20333c4 <lwip_setsockopt_impl+0x374>
 2033394:	10c01020 	cmpeqi	r3,r2,64
 2033398:	1800111e 	bne	r3,zero,20333e0 <lwip_setsockopt_impl+0x390>
 203339c:	10800420 	cmpeqi	r2,r2,16
 20333a0:	1000011e 	bne	r2,zero,20333a8 <lwip_setsockopt_impl+0x358>
              raw_bind_netif(sock->conn->pcb.raw, n);
              break;
#endif
            default:
              LWIP_ASSERT("Unhandled netconn type in SO_BINDTODEVICE", 0);
              break;
 20333a4:	00001506 	br	20333fc <lwip_setsockopt_impl+0x3ac>
          }

          switch (NETCONNTYPE_GROUP(netconn_type(sock->conn))) {
#if LWIP_TCP
            case NETCONN_TCP:
              tcp_bind_netif(sock->conn->pcb.tcp, n);
 20333a8:	e0bff817 	ldw	r2,-32(fp)
 20333ac:	10800017 	ldw	r2,0(r2)
 20333b0:	10800217 	ldw	r2,8(r2)
 20333b4:	e17ff717 	ldw	r5,-36(fp)
 20333b8:	1009883a 	mov	r4,r2
 20333bc:	201f9280 	call	201f928 <tcp_bind_netif>
              break;
 20333c0:	00000e06 	br	20333fc <lwip_setsockopt_impl+0x3ac>
#endif
#if LWIP_UDP
            case NETCONN_UDP:
              udp_bind_netif(sock->conn->pcb.udp, n);
 20333c4:	e0bff817 	ldw	r2,-32(fp)
 20333c8:	10800017 	ldw	r2,0(r2)
 20333cc:	10800217 	ldw	r2,8(r2)
 20333d0:	e17ff717 	ldw	r5,-36(fp)
 20333d4:	1009883a 	mov	r4,r2
 20333d8:	202a9040 	call	202a904 <udp_bind_netif>
              break;
 20333dc:	00000706 	br	20333fc <lwip_setsockopt_impl+0x3ac>
#endif
#if LWIP_RAW
            case NETCONN_RAW:
              raw_bind_netif(sock->conn->pcb.raw, n);
 20333e0:	e0bff817 	ldw	r2,-32(fp)
 20333e4:	10800017 	ldw	r2,0(r2)
 20333e8:	10800217 	ldw	r2,8(r2)
 20333ec:	e17ff717 	ldw	r5,-36(fp)
 20333f0:	1009883a 	mov	r4,r2
 20333f4:	201e6b00 	call	201e6b0 <raw_bind_netif>
              break;
 20333f8:	0001883a 	nop
            default:
              LWIP_ASSERT("Unhandled netconn type in SO_BINDTODEVICE", 0);
              break;
          }
        }
        break;
 20333fc:	00000306 	br	203340c <lwip_setsockopt_impl+0x3bc>
        default:
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                      s, optname));
          err = ENOPROTOOPT;
 2033400:	00801b44 	movi	r2,109
 2033404:	e0bff615 	stw	r2,-40(fp)
          break;
 2033408:	0001883a 	nop
      }  /* switch (optname) */
      break;
 203340c:	0000a206 	br	2033698 <lwip_setsockopt_impl+0x648>

    /* Level: IPPROTO_IP */
    case IPPROTO_IP:
      switch (optname) {
 2033410:	e0bffd17 	ldw	r2,-12(fp)
 2033414:	10c00060 	cmpeqi	r3,r2,1
 2033418:	1800171e 	bne	r3,zero,2033478 <lwip_setsockopt_impl+0x428>
 203341c:	108000a0 	cmpeqi	r2,r2,2
 2033420:	10002a26 	beq	r2,zero,20334cc <lwip_setsockopt_impl+0x47c>
        case IP_TTL:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
 2033424:	e0800217 	ldw	r2,8(fp)
 2033428:	10800128 	cmpgeui	r2,r2,4
 203342c:	1000021e 	bne	r2,zero,2033438 <lwip_setsockopt_impl+0x3e8>
 2033430:	00800584 	movi	r2,22
 2033434:	00009906 	br	203369c <lwip_setsockopt_impl+0x64c>
 2033438:	e0bff817 	ldw	r2,-32(fp)
 203343c:	10800017 	ldw	r2,0(r2)
 2033440:	10000426 	beq	r2,zero,2033454 <lwip_setsockopt_impl+0x404>
 2033444:	e0bff817 	ldw	r2,-32(fp)
 2033448:	10800017 	ldw	r2,0(r2)
 203344c:	10800217 	ldw	r2,8(r2)
 2033450:	1000021e 	bne	r2,zero,203345c <lwip_setsockopt_impl+0x40c>
 2033454:	00800584 	movi	r2,22
 2033458:	00009006 	br	203369c <lwip_setsockopt_impl+0x64c>
          sock->conn->pcb.ip->ttl = (u8_t)(*(const int *)optval);
 203345c:	e0bff817 	ldw	r2,-32(fp)
 2033460:	10800017 	ldw	r2,0(r2)
 2033464:	10800217 	ldw	r2,8(r2)
 2033468:	e0fffe17 	ldw	r3,-8(fp)
 203346c:	18c00017 	ldw	r3,0(r3)
 2033470:	10c002c5 	stb	r3,11(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
                                      s, sock->conn->pcb.ip->ttl));
          break;
 2033474:	00001806 	br	20334d8 <lwip_setsockopt_impl+0x488>
        case IP_TOS:
          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
 2033478:	e0800217 	ldw	r2,8(fp)
 203347c:	10800128 	cmpgeui	r2,r2,4
 2033480:	1000021e 	bne	r2,zero,203348c <lwip_setsockopt_impl+0x43c>
 2033484:	00800584 	movi	r2,22
 2033488:	00008406 	br	203369c <lwip_setsockopt_impl+0x64c>
 203348c:	e0bff817 	ldw	r2,-32(fp)
 2033490:	10800017 	ldw	r2,0(r2)
 2033494:	10000426 	beq	r2,zero,20334a8 <lwip_setsockopt_impl+0x458>
 2033498:	e0bff817 	ldw	r2,-32(fp)
 203349c:	10800017 	ldw	r2,0(r2)
 20334a0:	10800217 	ldw	r2,8(r2)
 20334a4:	1000021e 	bne	r2,zero,20334b0 <lwip_setsockopt_impl+0x460>
 20334a8:	00800584 	movi	r2,22
 20334ac:	00007b06 	br	203369c <lwip_setsockopt_impl+0x64c>
          sock->conn->pcb.ip->tos = (u8_t)(*(const int *)optval);
 20334b0:	e0bff817 	ldw	r2,-32(fp)
 20334b4:	10800017 	ldw	r2,0(r2)
 20334b8:	10800217 	ldw	r2,8(r2)
 20334bc:	e0fffe17 	ldw	r3,-8(fp)
 20334c0:	18c00017 	ldw	r3,0(r3)
 20334c4:	10c00285 	stb	r3,10(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
                                      s, sock->conn->pcb.ip->tos));
          break;
 20334c8:	00000306 	br	20334d8 <lwip_setsockopt_impl+0x488>
        break;
#endif /* LWIP_IGMP */
        default:
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                      s, optname));
          err = ENOPROTOOPT;
 20334cc:	00801b44 	movi	r2,109
 20334d0:	e0bff615 	stw	r2,-40(fp)
          break;
 20334d4:	0001883a 	nop
      }  /* switch (optname) */
      break;
 20334d8:	00006f06 	br	2033698 <lwip_setsockopt_impl+0x648>

#if LWIP_TCP
    /* Level: IPPROTO_TCP */
    case IPPROTO_TCP:
      /* Special case: all IPPROTO_TCP option take an int */
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_TCP);
 20334dc:	e0800217 	ldw	r2,8(fp)
 20334e0:	10800128 	cmpgeui	r2,r2,4
 20334e4:	1000021e 	bne	r2,zero,20334f0 <lwip_setsockopt_impl+0x4a0>
 20334e8:	00800584 	movi	r2,22
 20334ec:	00006b06 	br	203369c <lwip_setsockopt_impl+0x64c>
 20334f0:	e0bff817 	ldw	r2,-32(fp)
 20334f4:	10800017 	ldw	r2,0(r2)
 20334f8:	10000426 	beq	r2,zero,203350c <lwip_setsockopt_impl+0x4bc>
 20334fc:	e0bff817 	ldw	r2,-32(fp)
 2033500:	10800017 	ldw	r2,0(r2)
 2033504:	10800217 	ldw	r2,8(r2)
 2033508:	1000021e 	bne	r2,zero,2033514 <lwip_setsockopt_impl+0x4c4>
 203350c:	00800584 	movi	r2,22
 2033510:	00006206 	br	203369c <lwip_setsockopt_impl+0x64c>
 2033514:	e0bff817 	ldw	r2,-32(fp)
 2033518:	10800017 	ldw	r2,0(r2)
 203351c:	10800017 	ldw	r2,0(r2)
 2033520:	10803c0c 	andi	r2,r2,240
 2033524:	10800420 	cmpeqi	r2,r2,16
 2033528:	1000021e 	bne	r2,zero,2033534 <lwip_setsockopt_impl+0x4e4>
 203352c:	00801b44 	movi	r2,109
 2033530:	00005a06 	br	203369c <lwip_setsockopt_impl+0x64c>
      if (sock->conn->pcb.tcp->state == LISTEN) {
 2033534:	e0bff817 	ldw	r2,-32(fp)
 2033538:	10800017 	ldw	r2,0(r2)
 203353c:	10800217 	ldw	r2,8(r2)
 2033540:	10800617 	ldw	r2,24(r2)
 2033544:	10800058 	cmpnei	r2,r2,1
 2033548:	1000021e 	bne	r2,zero,2033554 <lwip_setsockopt_impl+0x504>
        done_socket(sock);
        return EINVAL;
 203354c:	00800584 	movi	r2,22
 2033550:	00005206 	br	203369c <lwip_setsockopt_impl+0x64c>
      }
      switch (optname) {
 2033554:	e0bffd17 	ldw	r2,-12(fp)
 2033558:	108001a8 	cmpgeui	r2,r2,6
 203355c:	1000431e 	bne	r2,zero,203366c <lwip_setsockopt_impl+0x61c>
 2033560:	e0bffd17 	ldw	r2,-12(fp)
 2033564:	100690ba 	slli	r3,r2,2
 2033568:	008080f4 	movhi	r2,515
 203356c:	108d5f04 	addi	r2,r2,13692
 2033570:	1885883a 	add	r2,r3,r2
 2033574:	10800017 	ldw	r2,0(r2)
 2033578:	1000683a 	jmp	r2
 203357c:	0203366c 	andhi	r8,zero,3289
 2033580:	02033594 	movui	r8,3286
 2033584:	020335f4 	movhi	r8,3287
 2033588:	02033610 	cmplti	r8,zero,3288
 203358c:	02033630 	cmpltui	r8,zero,3288
 2033590:	02033650 	cmplti	r8,zero,3289
        case TCP_NODELAY:
          if (*(const int *)optval) {
 2033594:	e0bffe17 	ldw	r2,-8(fp)
 2033598:	10800017 	ldw	r2,0(r2)
 203359c:	10000a26 	beq	r2,zero,20335c8 <lwip_setsockopt_impl+0x578>
            tcp_nagle_disable(sock->conn->pcb.tcp);
 20335a0:	e0bff817 	ldw	r2,-32(fp)
 20335a4:	10800017 	ldw	r2,0(r2)
 20335a8:	10800217 	ldw	r2,8(r2)
 20335ac:	e0fff817 	ldw	r3,-32(fp)
 20335b0:	18c00017 	ldw	r3,0(r3)
 20335b4:	18c00217 	ldw	r3,8(r3)
 20335b8:	18c0088b 	ldhu	r3,34(r3)
 20335bc:	18c01014 	ori	r3,r3,64
 20335c0:	10c0088d 	sth	r3,34(r2)
          } else {
            tcp_nagle_enable(sock->conn->pcb.tcp);
          }
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                                      s, (*(const int *)optval) ? "on" : "off") );
          break;
 20335c4:	00002c06 	br	2033678 <lwip_setsockopt_impl+0x628>
      switch (optname) {
        case TCP_NODELAY:
          if (*(const int *)optval) {
            tcp_nagle_disable(sock->conn->pcb.tcp);
          } else {
            tcp_nagle_enable(sock->conn->pcb.tcp);
 20335c8:	e0bff817 	ldw	r2,-32(fp)
 20335cc:	10800017 	ldw	r2,0(r2)
 20335d0:	10800217 	ldw	r2,8(r2)
 20335d4:	e0fff817 	ldw	r3,-32(fp)
 20335d8:	18c00017 	ldw	r3,0(r3)
 20335dc:	18c00217 	ldw	r3,8(r3)
 20335e0:	1900088b 	ldhu	r4,34(r3)
 20335e4:	00ffefc4 	movi	r3,-65
 20335e8:	20c6703a 	and	r3,r4,r3
 20335ec:	10c0088d 	sth	r3,34(r2)
          }
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                                      s, (*(const int *)optval) ? "on" : "off") );
          break;
 20335f0:	00002106 	br	2033678 <lwip_setsockopt_impl+0x628>
        case TCP_KEEPALIVE:
          sock->conn->pcb.tcp->keep_idle = (u32_t)(*(const int *)optval);
 20335f4:	e0bff817 	ldw	r2,-32(fp)
 20335f8:	10800017 	ldw	r2,0(r2)
 20335fc:	10800217 	ldw	r2,8(r2)
 2033600:	e0fffe17 	ldw	r3,-8(fp)
 2033604:	18c00017 	ldw	r3,0(r3)
 2033608:	10c02715 	stw	r3,156(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
                                      s, sock->conn->pcb.tcp->keep_idle));
          break;
 203360c:	00001a06 	br	2033678 <lwip_setsockopt_impl+0x628>

#if LWIP_TCP_KEEPALIVE
        case TCP_KEEPIDLE:
          sock->conn->pcb.tcp->keep_idle = 1000 * (u32_t)(*(const int *)optval);
 2033610:	e0bff817 	ldw	r2,-32(fp)
 2033614:	10800017 	ldw	r2,0(r2)
 2033618:	10800217 	ldw	r2,8(r2)
 203361c:	e0fffe17 	ldw	r3,-8(fp)
 2033620:	18c00017 	ldw	r3,0(r3)
 2033624:	18c0fa24 	muli	r3,r3,1000
 2033628:	10c02715 	stw	r3,156(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
                                      s, sock->conn->pcb.tcp->keep_idle));
          break;
 203362c:	00001206 	br	2033678 <lwip_setsockopt_impl+0x628>
        case TCP_KEEPINTVL:
          sock->conn->pcb.tcp->keep_intvl = 1000 * (u32_t)(*(const int *)optval);
 2033630:	e0bff817 	ldw	r2,-32(fp)
 2033634:	10800017 	ldw	r2,0(r2)
 2033638:	10800217 	ldw	r2,8(r2)
 203363c:	e0fffe17 	ldw	r3,-8(fp)
 2033640:	18c00017 	ldw	r3,0(r3)
 2033644:	18c0fa24 	muli	r3,r3,1000
 2033648:	10c02815 	stw	r3,160(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
                                      s, sock->conn->pcb.tcp->keep_intvl));
          break;
 203364c:	00000a06 	br	2033678 <lwip_setsockopt_impl+0x628>
        case TCP_KEEPCNT:
          sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(const int *)optval);
 2033650:	e0bff817 	ldw	r2,-32(fp)
 2033654:	10800017 	ldw	r2,0(r2)
 2033658:	10800217 	ldw	r2,8(r2)
 203365c:	e0fffe17 	ldw	r3,-8(fp)
 2033660:	18c00017 	ldw	r3,0(r3)
 2033664:	10c02915 	stw	r3,164(r2)
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
                                      s, sock->conn->pcb.tcp->keep_cnt));
          break;
 2033668:	00000306 	br	2033678 <lwip_setsockopt_impl+0x628>
#endif /* LWIP_TCP_KEEPALIVE */
        default:
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                      s, optname));
          err = ENOPROTOOPT;
 203366c:	00801b44 	movi	r2,109
 2033670:	e0bff615 	stw	r2,-40(fp)
          break;
 2033674:	0001883a 	nop
      }  /* switch (optname) */
      break;
 2033678:	00000706 	br	2033698 <lwip_setsockopt_impl+0x648>
          break;
#endif /* LWIP_IPV6 && LWIP_RAW */
        default:
          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_RAW, UNIMPL: optname=0x%x, ..)\n",
                                      s, optname));
          err = ENOPROTOOPT;
 203367c:	00801b44 	movi	r2,109
 2033680:	e0bff615 	stw	r2,-40(fp)
          break;
 2033684:	0001883a 	nop
      }  /* switch (optname) */
      break;
 2033688:	00000306 	br	2033698 <lwip_setsockopt_impl+0x648>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
 203368c:	00801b44 	movi	r2,109
 2033690:	e0bff615 	stw	r2,-40(fp)
      break;
 2033694:	0001883a 	nop
  }  /* switch (level) */

  done_socket(sock);
  return err;
 2033698:	e0bff617 	ldw	r2,-40(fp)
}
 203369c:	e6ffff04 	addi	sp,fp,-4
 20336a0:	dfc00217 	ldw	ra,8(sp)
 20336a4:	df000117 	ldw	fp,4(sp)
 20336a8:	dc000017 	ldw	r16,0(sp)
 20336ac:	dec00304 	addi	sp,sp,12
 20336b0:	f800283a 	ret

020336b4 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
 20336b4:	defff904 	addi	sp,sp,-28
 20336b8:	dfc00615 	stw	ra,24(sp)
 20336bc:	df000515 	stw	fp,20(sp)
 20336c0:	df000504 	addi	fp,sp,20
 20336c4:	e13ffd15 	stw	r4,-12(fp)
 20336c8:	e17ffe15 	stw	r5,-8(fp)
 20336cc:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock = get_socket(s);
 20336d0:	e13ffd17 	ldw	r4,-12(fp)
 20336d4:	202ed4c0 	call	202ed4c <get_socket>
 20336d8:	e0bffc15 	stw	r2,-16(fp)
  u8_t val;
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  if (!sock) {
 20336dc:	e0bffc17 	ldw	r2,-16(fp)
 20336e0:	1000021e 	bne	r2,zero,20336ec <lwip_ioctl+0x38>
    return -1;
 20336e4:	00bfffc4 	movi	r2,-1
 20336e8:	00002606 	br	2033784 <lwip_ioctl+0xd0>
  }

  switch (cmd) {
 20336ec:	e0fffe17 	ldw	r3,-8(fp)
 20336f0:	00a00134 	movhi	r2,32772
 20336f4:	10999f84 	addi	r2,r2,26238
 20336f8:	18800726 	beq	r3,r2,2033718 <lwip_ioctl+0x64>
      set_errno(0);
      done_socket(sock);
      return 0;

    default:
      break;
 20336fc:	0001883a 	nop
  } /* switch (cmd) */
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
  set_errno(ENOSYS); /* not yet implemented */
 2033700:	20423b80 	call	20423b8 <__errno>
 2033704:	1007883a 	mov	r3,r2
 2033708:	00801604 	movi	r2,88
 203370c:	18800015 	stw	r2,0(r3)
  done_socket(sock);
  return -1;
 2033710:	00bfffc4 	movi	r2,-1
 2033714:	00001b06 	br	2033784 <lwip_ioctl+0xd0>
      break;
#endif /* LWIP_SO_RCVBUF */
#endif /* LWIP_SO_RCVBUF || LWIP_FIONREAD_LINUXMODE */

    case (long)FIONBIO:
      val = 0;
 2033718:	e03ffb05 	stb	zero,-20(fp)
      if (argp && *(int *)argp) {
 203371c:	e0bfff17 	ldw	r2,-4(fp)
 2033720:	10000526 	beq	r2,zero,2033738 <lwip_ioctl+0x84>
 2033724:	e0bfff17 	ldw	r2,-4(fp)
 2033728:	10800017 	ldw	r2,0(r2)
 203372c:	10000226 	beq	r2,zero,2033738 <lwip_ioctl+0x84>
        val = 1;
 2033730:	00800044 	movi	r2,1
 2033734:	e0bffb05 	stb	r2,-20(fp)
      }
      netconn_set_nonblocking(sock->conn, val);
 2033738:	e0bffb03 	ldbu	r2,-20(fp)
 203373c:	10000826 	beq	r2,zero,2033760 <lwip_ioctl+0xac>
 2033740:	e0bffc17 	ldw	r2,-16(fp)
 2033744:	10800017 	ldw	r2,0(r2)
 2033748:	e0fffc17 	ldw	r3,-16(fp)
 203374c:	18c00017 	ldw	r3,0(r3)
 2033750:	18c00903 	ldbu	r3,36(r3)
 2033754:	18c00094 	ori	r3,r3,2
 2033758:	10c00905 	stb	r3,36(r2)
 203375c:	00000806 	br	2033780 <lwip_ioctl+0xcc>
 2033760:	e0bffc17 	ldw	r2,-16(fp)
 2033764:	10800017 	ldw	r2,0(r2)
 2033768:	e0fffc17 	ldw	r3,-16(fp)
 203376c:	18c00017 	ldw	r3,0(r3)
 2033770:	19000903 	ldbu	r4,36(r3)
 2033774:	00ffff44 	movi	r3,-3
 2033778:	20c6703a 	and	r3,r4,r3
 203377c:	10c00905 	stb	r3,36(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
      set_errno(0);
      done_socket(sock);
      return 0;
 2033780:	0005883a 	mov	r2,zero
  } /* switch (cmd) */
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
  set_errno(ENOSYS); /* not yet implemented */
  done_socket(sock);
  return -1;
}
 2033784:	e037883a 	mov	sp,fp
 2033788:	dfc00117 	ldw	ra,4(sp)
 203378c:	df000017 	ldw	fp,0(sp)
 2033790:	dec00204 	addi	sp,sp,8
 2033794:	f800283a 	ret

02033798 <lwip_fcntl>:
 * The flag O_NONBLOCK and access modes are supported for F_GETFL, only
 * the flag O_NONBLOCK is implemented for F_SETFL.
 */
int
lwip_fcntl(int s, int cmd, int val)
{
 2033798:	defff704 	addi	sp,sp,-36
 203379c:	dfc00815 	stw	ra,32(sp)
 20337a0:	df000715 	stw	fp,28(sp)
 20337a4:	df000704 	addi	fp,sp,28
 20337a8:	e13ffd15 	stw	r4,-12(fp)
 20337ac:	e17ffe15 	stw	r5,-8(fp)
 20337b0:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock = get_socket(s);
 20337b4:	e13ffd17 	ldw	r4,-12(fp)
 20337b8:	202ed4c0 	call	202ed4c <get_socket>
 20337bc:	e0bffb15 	stw	r2,-20(fp)
  int ret = -1;
 20337c0:	00bfffc4 	movi	r2,-1
 20337c4:	e0bff915 	stw	r2,-28(fp)
  int op_mode = 0;
 20337c8:	e03ffa15 	stw	zero,-24(fp)

  if (!sock) {
 20337cc:	e0bffb17 	ldw	r2,-20(fp)
 20337d0:	1000021e 	bne	r2,zero,20337dc <lwip_fcntl+0x44>
    return -1;
 20337d4:	00bfffc4 	movi	r2,-1
 20337d8:	00006106 	br	2033960 <lwip_fcntl+0x1c8>
  }

  switch (cmd) {
 20337dc:	e0bffe17 	ldw	r2,-8(fp)
 20337e0:	10c000e0 	cmpeqi	r3,r2,3
 20337e4:	1800031e 	bne	r3,zero,20337f4 <lwip_fcntl+0x5c>
 20337e8:	10800120 	cmpeqi	r2,r2,4
 20337ec:	1000341e 	bne	r2,zero,20338c0 <lwip_fcntl+0x128>
 20337f0:	00005506 	br	2033948 <lwip_fcntl+0x1b0>
    case F_GETFL:
      ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
 20337f4:	e0bffb17 	ldw	r2,-20(fp)
 20337f8:	10800017 	ldw	r2,0(r2)
 20337fc:	10800903 	ldbu	r2,36(r2)
 2033800:	10803fcc 	andi	r2,r2,255
 2033804:	1080008c 	andi	r2,r2,2
 2033808:	1004c03a 	cmpne	r2,r2,zero
 203380c:	10803fcc 	andi	r2,r2,255
 2033810:	e0bff915 	stw	r2,-28(fp)
      set_errno(0);

      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
 2033814:	e0bffb17 	ldw	r2,-20(fp)
 2033818:	10800017 	ldw	r2,0(r2)
 203381c:	10800017 	ldw	r2,0(r2)
 2033820:	10803c0c 	andi	r2,r2,240
 2033824:	10800418 	cmpnei	r2,r2,16
 2033828:	10001d1e 	bne	r2,zero,20338a0 <lwip_fcntl+0x108>
        LOCK_TCPIP_CORE();
#else
        SYS_ARCH_DECL_PROTECT(lev);
        /* the proper thing to do here would be to get into the tcpip_thread,
           but locking should be OK as well since we only *read* some flags */
        SYS_ARCH_PROTECT(lev);
 203382c:	2014cec0 	call	2014cec <sys_arch_protect>
 2033830:	e0bffc15 	stw	r2,-16(fp)
#endif
#if LWIP_TCP
        if (sock->conn->pcb.tcp) {
 2033834:	e0bffb17 	ldw	r2,-20(fp)
 2033838:	10800017 	ldw	r2,0(r2)
 203383c:	10800217 	ldw	r2,8(r2)
 2033840:	10001426 	beq	r2,zero,2033894 <lwip_fcntl+0xfc>
          if (!(sock->conn->pcb.tcp->flags & TF_RXCLOSED)) {
 2033844:	e0bffb17 	ldw	r2,-20(fp)
 2033848:	10800017 	ldw	r2,0(r2)
 203384c:	10800217 	ldw	r2,8(r2)
 2033850:	1080088b 	ldhu	r2,34(r2)
 2033854:	10bfffcc 	andi	r2,r2,65535
 2033858:	1080040c 	andi	r2,r2,16
 203385c:	1000031e 	bne	r2,zero,203386c <lwip_fcntl+0xd4>
            op_mode |= O_RDONLY;
 2033860:	e0bffa17 	ldw	r2,-24(fp)
 2033864:	10800094 	ori	r2,r2,2
 2033868:	e0bffa15 	stw	r2,-24(fp)
          }
          if (!(sock->conn->pcb.tcp->flags & TF_FIN)) {
 203386c:	e0bffb17 	ldw	r2,-20(fp)
 2033870:	10800017 	ldw	r2,0(r2)
 2033874:	10800217 	ldw	r2,8(r2)
 2033878:	1080088b 	ldhu	r2,34(r2)
 203387c:	10bfffcc 	andi	r2,r2,65535
 2033880:	1080080c 	andi	r2,r2,32
 2033884:	1000031e 	bne	r2,zero,2033894 <lwip_fcntl+0xfc>
            op_mode |= O_WRONLY;
 2033888:	e0bffa17 	ldw	r2,-24(fp)
 203388c:	10800114 	ori	r2,r2,4
 2033890:	e0bffa15 	stw	r2,-24(fp)
        }
#endif
#if LWIP_TCPIP_CORE_LOCKING
        UNLOCK_TCPIP_CORE();
#else
        SYS_ARCH_UNPROTECT(lev);
 2033894:	e13ffc17 	ldw	r4,-16(fp)
 2033898:	2014d200 	call	2014d20 <sys_arch_unprotect>
 203389c:	00000306 	br	20338ac <lwip_fcntl+0x114>
#endif
      } else {
        op_mode |= O_RDWR;
 20338a0:	e0bffa17 	ldw	r2,-24(fp)
 20338a4:	10800194 	ori	r2,r2,6
 20338a8:	e0bffa15 	stw	r2,-24(fp)
      }

      /* ensure O_RDWR for (O_RDONLY|O_WRONLY) != O_RDWR cases */
      ret |= (op_mode == (O_RDONLY | O_WRONLY)) ? O_RDWR : op_mode;
 20338ac:	e0fff917 	ldw	r3,-28(fp)
 20338b0:	e0bffa17 	ldw	r2,-24(fp)
 20338b4:	1884b03a 	or	r2,r3,r2
 20338b8:	e0bff915 	stw	r2,-28(fp)

      break;
 20338bc:	00002706 	br	203395c <lwip_fcntl+0x1c4>
    case F_SETFL:
      /* Bits corresponding to the file access mode and the file creation flags [..] that are set in arg shall be ignored */
      val &= ~(O_RDONLY | O_WRONLY | O_RDWR);
 20338c0:	e0ffff17 	ldw	r3,-4(fp)
 20338c4:	00bffe44 	movi	r2,-7
 20338c8:	1884703a 	and	r2,r3,r2
 20338cc:	e0bfff15 	stw	r2,-4(fp)
      if ((val & ~O_NONBLOCK) == 0) {
 20338d0:	e0ffff17 	ldw	r3,-4(fp)
 20338d4:	00bfff84 	movi	r2,-2
 20338d8:	1884703a 	and	r2,r3,r2
 20338dc:	1000151e 	bne	r2,zero,2033934 <lwip_fcntl+0x19c>
        /* only O_NONBLOCK, all other bits are zero */
        netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
 20338e0:	e0bfff17 	ldw	r2,-4(fp)
 20338e4:	1080004c 	andi	r2,r2,1
 20338e8:	10000826 	beq	r2,zero,203390c <lwip_fcntl+0x174>
 20338ec:	e0bffb17 	ldw	r2,-20(fp)
 20338f0:	10800017 	ldw	r2,0(r2)
 20338f4:	e0fffb17 	ldw	r3,-20(fp)
 20338f8:	18c00017 	ldw	r3,0(r3)
 20338fc:	18c00903 	ldbu	r3,36(r3)
 2033900:	18c00094 	ori	r3,r3,2
 2033904:	10c00905 	stb	r3,36(r2)
 2033908:	00000806 	br	203392c <lwip_fcntl+0x194>
 203390c:	e0bffb17 	ldw	r2,-20(fp)
 2033910:	10800017 	ldw	r2,0(r2)
 2033914:	e0fffb17 	ldw	r3,-20(fp)
 2033918:	18c00017 	ldw	r3,0(r3)
 203391c:	19000903 	ldbu	r4,36(r3)
 2033920:	00ffff44 	movi	r3,-3
 2033924:	20c6703a 	and	r3,r4,r3
 2033928:	10c00905 	stb	r3,36(r2)
        ret = 0;
 203392c:	e03ff915 	stw	zero,-28(fp)
        set_errno(0);
      } else {
        set_errno(ENOSYS); /* not yet implemented */
      }
      break;
 2033930:	00000a06 	br	203395c <lwip_fcntl+0x1c4>
        /* only O_NONBLOCK, all other bits are zero */
        netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
        ret = 0;
        set_errno(0);
      } else {
        set_errno(ENOSYS); /* not yet implemented */
 2033934:	20423b80 	call	20423b8 <__errno>
 2033938:	1007883a 	mov	r3,r2
 203393c:	00801604 	movi	r2,88
 2033940:	18800015 	stw	r2,0(r3)
      }
      break;
 2033944:	00000506 	br	203395c <lwip_fcntl+0x1c4>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
      set_errno(ENOSYS); /* not yet implemented */
 2033948:	20423b80 	call	20423b8 <__errno>
 203394c:	1007883a 	mov	r3,r2
 2033950:	00801604 	movi	r2,88
 2033954:	18800015 	stw	r2,0(r3)
      break;
 2033958:	0001883a 	nop
  }
  done_socket(sock);
  return ret;
 203395c:	e0bff917 	ldw	r2,-28(fp)
}
 2033960:	e037883a 	mov	sp,fp
 2033964:	dfc00117 	ldw	ra,4(sp)
 2033968:	df000017 	ldw	fp,0(sp)
 203396c:	dec00204 	addi	sp,sp,8
 2033970:	f800283a 	ret

02033974 <lwip_inet_ntop>:
}
#endif

const char *
lwip_inet_ntop(int af, const void *src, char *dst, socklen_t size)
{
 2033974:	defff804 	addi	sp,sp,-32
 2033978:	dfc00715 	stw	ra,28(sp)
 203397c:	df000615 	stw	fp,24(sp)
 2033980:	df000604 	addi	fp,sp,24
 2033984:	e13ffc15 	stw	r4,-16(fp)
 2033988:	e17ffd15 	stw	r5,-12(fp)
 203398c:	e1bffe15 	stw	r6,-8(fp)
 2033990:	e1ffff15 	stw	r7,-4(fp)
  const char *ret = NULL;
 2033994:	e03ffa15 	stw	zero,-24(fp)
  int size_int = (int)size;
 2033998:	e0bfff17 	ldw	r2,-4(fp)
 203399c:	e0bffb15 	stw	r2,-20(fp)
  if (size_int < 0) {
 20339a0:	e0bffb17 	ldw	r2,-20(fp)
 20339a4:	1000060e 	bge	r2,zero,20339c0 <lwip_inet_ntop+0x4c>
    set_errno(ENOSPC);
 20339a8:	20423b80 	call	20423b8 <__errno>
 20339ac:	1007883a 	mov	r3,r2
 20339b0:	00800704 	movi	r2,28
 20339b4:	18800015 	stw	r2,0(r3)
    return NULL;
 20339b8:	0005883a 	mov	r2,zero
 20339bc:	00001606 	br	2033a18 <lwip_inet_ntop+0xa4>
  }
  switch (af) {
 20339c0:	e0bffc17 	ldw	r2,-16(fp)
 20339c4:	108000a0 	cmpeqi	r2,r2,2
 20339c8:	10000c26 	beq	r2,zero,20339fc <lwip_inet_ntop+0x88>
#if LWIP_IPV4
    case AF_INET:
      ret = ip4addr_ntoa_r((const ip4_addr_t *)src, dst, size_int);
 20339cc:	e1bffb17 	ldw	r6,-20(fp)
 20339d0:	e17ffe17 	ldw	r5,-8(fp)
 20339d4:	e13ffd17 	ldw	r4,-12(fp)
 20339d8:	201a8180 	call	201a818 <ip4addr_ntoa_r>
 20339dc:	e0bffa15 	stw	r2,-24(fp)
      if (ret == NULL) {
 20339e0:	e0bffa17 	ldw	r2,-24(fp)
 20339e4:	10000a1e 	bne	r2,zero,2033a10 <lwip_inet_ntop+0x9c>
        set_errno(ENOSPC);
 20339e8:	20423b80 	call	20423b8 <__errno>
 20339ec:	1007883a 	mov	r3,r2
 20339f0:	00800704 	movi	r2,28
 20339f4:	18800015 	stw	r2,0(r3)
      }
      break;
 20339f8:	00000506 	br	2033a10 <lwip_inet_ntop+0x9c>
        set_errno(ENOSPC);
      }
      break;
#endif
    default:
      set_errno(EAFNOSUPPORT);
 20339fc:	20423b80 	call	20423b8 <__errno>
 2033a00:	1007883a 	mov	r3,r2
 2033a04:	00801a84 	movi	r2,106
 2033a08:	18800015 	stw	r2,0(r3)
      break;
 2033a0c:	00000106 	br	2033a14 <lwip_inet_ntop+0xa0>
    case AF_INET:
      ret = ip4addr_ntoa_r((const ip4_addr_t *)src, dst, size_int);
      if (ret == NULL) {
        set_errno(ENOSPC);
      }
      break;
 2033a10:	0001883a 	nop
#endif
    default:
      set_errno(EAFNOSUPPORT);
      break;
  }
  return ret;
 2033a14:	e0bffa17 	ldw	r2,-24(fp)
}
 2033a18:	e037883a 	mov	sp,fp
 2033a1c:	dfc00117 	ldw	ra,4(sp)
 2033a20:	df000017 	ldw	fp,0(sp)
 2033a24:	dec00204 	addi	sp,sp,8
 2033a28:	f800283a 	ret

02033a2c <lwip_inet_pton>:

int
lwip_inet_pton(int af, const char *src, void *dst)
{
 2033a2c:	defffa04 	addi	sp,sp,-24
 2033a30:	dfc00515 	stw	ra,20(sp)
 2033a34:	df000415 	stw	fp,16(sp)
 2033a38:	df000404 	addi	fp,sp,16
 2033a3c:	e13ffd15 	stw	r4,-12(fp)
 2033a40:	e17ffe15 	stw	r5,-8(fp)
 2033a44:	e1bfff15 	stw	r6,-4(fp)
  int err;
  switch (af) {
 2033a48:	e0bffd17 	ldw	r2,-12(fp)
 2033a4c:	108000a0 	cmpeqi	r2,r2,2
 2033a50:	10000526 	beq	r2,zero,2033a68 <lwip_inet_pton+0x3c>
#if LWIP_IPV4
    case AF_INET:
      err = ip4addr_aton(src, (ip4_addr_t *)dst);
 2033a54:	e17fff17 	ldw	r5,-4(fp)
 2033a58:	e13ffe17 	ldw	r4,-8(fp)
 2033a5c:	201a3d40 	call	201a3d4 <ip4addr_aton>
 2033a60:	e0bffc15 	stw	r2,-16(fp)
      break;
 2033a64:	00000706 	br	2033a84 <lwip_inet_pton+0x58>
      }
      break;
    }
#endif
    default:
      err = -1;
 2033a68:	00bfffc4 	movi	r2,-1
 2033a6c:	e0bffc15 	stw	r2,-16(fp)
      set_errno(EAFNOSUPPORT);
 2033a70:	20423b80 	call	20423b8 <__errno>
 2033a74:	1007883a 	mov	r3,r2
 2033a78:	00801a84 	movi	r2,106
 2033a7c:	18800015 	stw	r2,0(r3)
      break;
 2033a80:	0001883a 	nop
  }
  return err;
 2033a84:	e0bffc17 	ldw	r2,-16(fp)
}
 2033a88:	e037883a 	mov	sp,fp
 2033a8c:	dfc00117 	ldw	ra,4(sp)
 2033a90:	df000017 	ldw	fp,0(sp)
 2033a94:	dec00204 	addi	sp,sp,8
 2033a98:	f800283a 	ret

02033a9c <tcpip_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
static void
tcpip_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 2033a9c:	defffa04 	addi	sp,sp,-24
 2033aa0:	dfc00515 	stw	ra,20(sp)
 2033aa4:	df000415 	stw	fp,16(sp)
 2033aa8:	df000404 	addi	fp,sp,16
 2033aac:	e13ffe15 	stw	r4,-8(fp)
 2033ab0:	e17fff15 	stw	r5,-4(fp)
  u32_t sleeptime, res;

again:
  LWIP_ASSERT_CORE_LOCKED();

  sleeptime = sys_timeouts_sleeptime();
 2033ab4:	20297bc0 	call	20297bc <sys_timeouts_sleeptime>
 2033ab8:	e0bffc15 	stw	r2,-16(fp)
  if (sleeptime == SYS_TIMEOUTS_SLEEPTIME_INFINITE) {
 2033abc:	e0bffc17 	ldw	r2,-16(fp)
 2033ac0:	10bfffd8 	cmpnei	r2,r2,-1
 2033ac4:	1000051e 	bne	r2,zero,2033adc <tcpip_timeouts_mbox_fetch+0x40>
    UNLOCK_TCPIP_CORE();
    sys_arch_mbox_fetch(mbox, msg, 0);
 2033ac8:	000d883a 	mov	r6,zero
 2033acc:	e17fff17 	ldw	r5,-4(fp)
 2033ad0:	e13ffe17 	ldw	r4,-8(fp)
 2033ad4:	20153ac0 	call	20153ac <sys_arch_mbox_fetch>
    LOCK_TCPIP_CORE();
    return;
 2033ad8:	00000e06 	br	2033b14 <tcpip_timeouts_mbox_fetch+0x78>
  } else if (sleeptime == 0) {
 2033adc:	e0bffc17 	ldw	r2,-16(fp)
 2033ae0:	1000021e 	bne	r2,zero,2033aec <tcpip_timeouts_mbox_fetch+0x50>
    sys_check_timeouts();
 2033ae4:	20296840 	call	2029684 <sys_check_timeouts>
    /* We try again to fetch a message from the mbox. */
    goto again;
 2033ae8:	003ff206 	br	2033ab4 <__alt_mem_mem_0+0xfd013ab4>
  }

  UNLOCK_TCPIP_CORE();
  res = sys_arch_mbox_fetch(mbox, msg, sleeptime);
 2033aec:	e1bffc17 	ldw	r6,-16(fp)
 2033af0:	e17fff17 	ldw	r5,-4(fp)
 2033af4:	e13ffe17 	ldw	r4,-8(fp)
 2033af8:	20153ac0 	call	20153ac <sys_arch_mbox_fetch>
 2033afc:	e0bffd15 	stw	r2,-12(fp)
  LOCK_TCPIP_CORE();
  if (res == SYS_ARCH_TIMEOUT) {
 2033b00:	e0bffd17 	ldw	r2,-12(fp)
 2033b04:	10bfffd8 	cmpnei	r2,r2,-1
 2033b08:	1000021e 	bne	r2,zero,2033b14 <tcpip_timeouts_mbox_fetch+0x78>
    /* If a SYS_ARCH_TIMEOUT value is returned, a timeout occurred
       before a message could be fetched. */
    sys_check_timeouts();
 2033b0c:	20296840 	call	2029684 <sys_check_timeouts>
    /* We try again to fetch a message from the mbox. */
    goto again;
 2033b10:	003fe806 	br	2033ab4 <__alt_mem_mem_0+0xfd013ab4>
  }
}
 2033b14:	e037883a 	mov	sp,fp
 2033b18:	dfc00117 	ldw	ra,4(sp)
 2033b1c:	df000017 	ldw	fp,0(sp)
 2033b20:	dec00204 	addi	sp,sp,8
 2033b24:	f800283a 	ret

02033b28 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 2033b28:	defffc04 	addi	sp,sp,-16
 2033b2c:	dfc00315 	stw	ra,12(sp)
 2033b30:	df000215 	stw	fp,8(sp)
 2033b34:	df000204 	addi	fp,sp,8
 2033b38:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);

  LWIP_MARK_TCPIP_THREAD();

  LOCK_TCPIP_CORE();
  if (tcpip_init_done != NULL) {
 2033b3c:	d0a7fd17 	ldw	r2,-24588(gp)
 2033b40:	10000426 	beq	r2,zero,2033b54 <tcpip_thread+0x2c>
    tcpip_init_done(tcpip_init_done_arg);
 2033b44:	d0a7fd17 	ldw	r2,-24588(gp)
 2033b48:	d0e7fe17 	ldw	r3,-24584(gp)
 2033b4c:	1809883a 	mov	r4,r3
 2033b50:	103ee83a 	callr	r2
  }

  while (1) {                          /* MAIN Loop */
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    TCPIP_MBOX_FETCH(&tcpip_mbox, (void **)&msg);
 2033b54:	e17ffe04 	addi	r5,fp,-8
 2033b58:	d127ff04 	addi	r4,gp,-24580
 2033b5c:	2033a9c0 	call	2033a9c <tcpip_timeouts_mbox_fetch>
    if (msg == NULL) {
 2033b60:	e0bffe17 	ldw	r2,-8(fp)
 2033b64:	10000426 	beq	r2,zero,2033b78 <tcpip_thread+0x50>
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: NULL\n"));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      continue;
    }
    tcpip_thread_handle_msg(msg);
 2033b68:	e0bffe17 	ldw	r2,-8(fp)
 2033b6c:	1009883a 	mov	r4,r2
 2033b70:	2033b800 	call	2033b80 <tcpip_thread_handle_msg>
 2033b74:	003ff706 	br	2033b54 <__alt_mem_mem_0+0xfd013b54>
    /* wait for a message, timeouts are processed while waiting */
    TCPIP_MBOX_FETCH(&tcpip_mbox, (void **)&msg);
    if (msg == NULL) {
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: NULL\n"));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      continue;
 2033b78:	0001883a 	nop
    }
    tcpip_thread_handle_msg(msg);
  }
 2033b7c:	003ff506 	br	2033b54 <__alt_mem_mem_0+0xfd013b54>

02033b80 <tcpip_thread_handle_msg>:
/* Handle a single tcpip_msg
 * This is in its own function for access by tests only.
 */
static void
tcpip_thread_handle_msg(struct tcpip_msg *msg)
{
 2033b80:	defffc04 	addi	sp,sp,-16
 2033b84:	dfc00315 	stw	ra,12(sp)
 2033b88:	df000215 	stw	fp,8(sp)
 2033b8c:	dc000115 	stw	r16,4(sp)
 2033b90:	df000204 	addi	fp,sp,8
 2033b94:	e13ffe15 	stw	r4,-8(fp)
  switch (msg->type) {
 2033b98:	e0bffe17 	ldw	r2,-8(fp)
 2033b9c:	10800017 	ldw	r2,0(r2)
 2033ba0:	10c00228 	cmpgeui	r3,r2,8
 2033ba4:	18006c1e 	bne	r3,zero,2033d58 <tcpip_thread_handle_msg+0x1d8>
 2033ba8:	100690ba 	slli	r3,r2,2
 2033bac:	008080f4 	movhi	r2,515
 2033bb0:	108ef004 	addi	r2,r2,15296
 2033bb4:	1885883a 	add	r2,r3,r2
 2033bb8:	10800017 	ldw	r2,0(r2)
 2033bbc:	1000683a 	jmp	r2
 2033bc0:	02033be0 	cmpeqi	r8,zero,3311
 2033bc4:	02033bfc 	xorhi	r8,zero,3311
 2033bc8:	02033c60 	cmpeqi	r8,zero,3313
 2033bcc:	02033cb0 	cmpltui	r8,zero,3314
 2033bd0:	02033ce8 	cmpgeui	r8,zero,3315
 2033bd4:	02033d14 	movui	r8,3316
 2033bd8:	02033d3c 	xorhi	r8,zero,3316
 2033bdc:	02033c34 	movhi	r8,3312
#if !LWIP_TCPIP_CORE_LOCKING
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.api_msg.function(msg->msg.api_msg.msg);
 2033be0:	e0bffe17 	ldw	r2,-8(fp)
 2033be4:	10800117 	ldw	r2,4(r2)
 2033be8:	e0fffe17 	ldw	r3,-8(fp)
 2033bec:	18c00217 	ldw	r3,8(r3)
 2033bf0:	1809883a 	mov	r4,r3
 2033bf4:	103ee83a 	callr	r2
      break;
 2033bf8:	00005806 	br	2033d5c <tcpip_thread_handle_msg+0x1dc>
    case TCPIP_MSG_API_CALL:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API CALL message %p\n", (void *)msg));
      msg->msg.api_call.arg->err = msg->msg.api_call.function(msg->msg.api_call.arg);
 2033bfc:	e0bffe17 	ldw	r2,-8(fp)
 2033c00:	14000217 	ldw	r16,8(r2)
 2033c04:	e0bffe17 	ldw	r2,-8(fp)
 2033c08:	10800117 	ldw	r2,4(r2)
 2033c0c:	e0fffe17 	ldw	r3,-8(fp)
 2033c10:	18c00217 	ldw	r3,8(r3)
 2033c14:	1809883a 	mov	r4,r3
 2033c18:	103ee83a 	callr	r2
 2033c1c:	80800005 	stb	r2,0(r16)
      sys_sem_signal(msg->msg.api_call.sem);
 2033c20:	e0bffe17 	ldw	r2,-8(fp)
 2033c24:	10800317 	ldw	r2,12(r2)
 2033c28:	1009883a 	mov	r4,r2
 2033c2c:	20150340 	call	2015034 <sys_sem_signal>
      break;
 2033c30:	00004a06 	br	2033d5c <tcpip_thread_handle_msg+0x1dc>
    case TCPIP_MSG_CALLBACK_STATIC_WAIT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK WAIT message %p\n", (void *)msg));
      msg->msg.cb_wait.function(msg->msg.cb_wait.ctx);
 2033c34:	e0bffe17 	ldw	r2,-8(fp)
 2033c38:	10800117 	ldw	r2,4(r2)
 2033c3c:	e0fffe17 	ldw	r3,-8(fp)
 2033c40:	18c00217 	ldw	r3,8(r3)
 2033c44:	1809883a 	mov	r4,r3
 2033c48:	103ee83a 	callr	r2
      sys_sem_signal(msg->msg.cb_wait.sem);
 2033c4c:	e0bffe17 	ldw	r2,-8(fp)
 2033c50:	10800317 	ldw	r2,12(r2)
 2033c54:	1009883a 	mov	r4,r2
 2033c58:	20150340 	call	2015034 <sys_sem_signal>
      break;
 2033c5c:	00003f06 	br	2033d5c <tcpip_thread_handle_msg+0x1dc>
#endif /* !LWIP_TCPIP_CORE_LOCKING */

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
      if (msg->msg.inp.input_fn(msg->msg.inp.p, msg->msg.inp.netif) != ERR_OK) {
 2033c60:	e0bffe17 	ldw	r2,-8(fp)
 2033c64:	10800317 	ldw	r2,12(r2)
 2033c68:	e0fffe17 	ldw	r3,-8(fp)
 2033c6c:	19000117 	ldw	r4,4(r3)
 2033c70:	e0fffe17 	ldw	r3,-8(fp)
 2033c74:	18c00217 	ldw	r3,8(r3)
 2033c78:	180b883a 	mov	r5,r3
 2033c7c:	103ee83a 	callr	r2
 2033c80:	10803fcc 	andi	r2,r2,255
 2033c84:	1080201c 	xori	r2,r2,128
 2033c88:	10bfe004 	addi	r2,r2,-128
 2033c8c:	10000426 	beq	r2,zero,2033ca0 <tcpip_thread_handle_msg+0x120>
        pbuf_free(msg->msg.inp.p);
 2033c90:	e0bffe17 	ldw	r2,-8(fp)
 2033c94:	10800117 	ldw	r2,4(r2)
 2033c98:	1009883a 	mov	r4,r2
 2033c9c:	201d2f40 	call	201d2f4 <pbuf_free>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 2033ca0:	e17ffe17 	ldw	r5,-8(fp)
 2033ca4:	01000284 	movi	r4,10
 2033ca8:	201b9640 	call	201b964 <memp_free>
      break;
 2033cac:	00002b06 	br	2033d5c <tcpip_thread_handle_msg+0x1dc>
#endif /* !LWIP_TCPIP_CORE_LOCKING_INPUT */

#if LWIP_TCPIP_TIMEOUT && LWIP_TIMERS
    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
 2033cb0:	e0bffe17 	ldw	r2,-8(fp)
 2033cb4:	10c00117 	ldw	r3,4(r2)
 2033cb8:	e0bffe17 	ldw	r2,-8(fp)
 2033cbc:	11000217 	ldw	r4,8(r2)
 2033cc0:	e0bffe17 	ldw	r2,-8(fp)
 2033cc4:	10800317 	ldw	r2,12(r2)
 2033cc8:	100d883a 	mov	r6,r2
 2033ccc:	200b883a 	mov	r5,r4
 2033cd0:	1809883a 	mov	r4,r3
 2033cd4:	20295680 	call	2029568 <sys_timeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 2033cd8:	e17ffe17 	ldw	r5,-8(fp)
 2033cdc:	01000244 	movi	r4,9
 2033ce0:	201b9640 	call	201b964 <memp_free>
      break;
 2033ce4:	00001d06 	br	2033d5c <tcpip_thread_handle_msg+0x1dc>
    case TCPIP_MSG_UNTIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
      sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
 2033ce8:	e0bffe17 	ldw	r2,-8(fp)
 2033cec:	10c00217 	ldw	r3,8(r2)
 2033cf0:	e0bffe17 	ldw	r2,-8(fp)
 2033cf4:	10800317 	ldw	r2,12(r2)
 2033cf8:	100b883a 	mov	r5,r2
 2033cfc:	1809883a 	mov	r4,r3
 2033d00:	20295c00 	call	20295c0 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 2033d04:	e17ffe17 	ldw	r5,-8(fp)
 2033d08:	01000244 	movi	r4,9
 2033d0c:	201b9640 	call	201b964 <memp_free>
      break;
 2033d10:	00001206 	br	2033d5c <tcpip_thread_handle_msg+0x1dc>
#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 2033d14:	e0bffe17 	ldw	r2,-8(fp)
 2033d18:	10800117 	ldw	r2,4(r2)
 2033d1c:	e0fffe17 	ldw	r3,-8(fp)
 2033d20:	18c00217 	ldw	r3,8(r3)
 2033d24:	1809883a 	mov	r4,r3
 2033d28:	103ee83a 	callr	r2
      memp_free(MEMP_TCPIP_MSG_API, msg);
 2033d2c:	e17ffe17 	ldw	r5,-8(fp)
 2033d30:	01000244 	movi	r4,9
 2033d34:	201b9640 	call	201b964 <memp_free>
      break;
 2033d38:	00000806 	br	2033d5c <tcpip_thread_handle_msg+0x1dc>

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 2033d3c:	e0bffe17 	ldw	r2,-8(fp)
 2033d40:	10800117 	ldw	r2,4(r2)
 2033d44:	e0fffe17 	ldw	r3,-8(fp)
 2033d48:	18c00217 	ldw	r3,8(r3)
 2033d4c:	1809883a 	mov	r4,r3
 2033d50:	103ee83a 	callr	r2
      break;
 2033d54:	00000106 	br	2033d5c <tcpip_thread_handle_msg+0x1dc>

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      break;
 2033d58:	0001883a 	nop
  }
}
 2033d5c:	0001883a 	nop
 2033d60:	e6ffff04 	addi	sp,fp,-4
 2033d64:	dfc00217 	ldw	ra,8(sp)
 2033d68:	df000117 	ldw	fp,4(sp)
 2033d6c:	dc000017 	ldw	r16,0(sp)
 2033d70:	dec00304 	addi	sp,sp,12
 2033d74:	f800283a 	ret

02033d78 <tcpip_inpkt>:
 * @param inp the network interface on which the packet was received
 * @param input_fn input function to call
 */
err_t
tcpip_inpkt(struct pbuf *p, struct netif *inp, netif_input_fn input_fn)
{
 2033d78:	defffa04 	addi	sp,sp,-24
 2033d7c:	dfc00515 	stw	ra,20(sp)
 2033d80:	df000415 	stw	fp,16(sp)
 2033d84:	df000404 	addi	fp,sp,16
 2033d88:	e13ffd15 	stw	r4,-12(fp)
 2033d8c:	e17ffe15 	stw	r5,-8(fp)
 2033d90:	e1bfff15 	stw	r6,-4(fp)
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 2033d94:	01000284 	movi	r4,10
 2033d98:	201b82c0 	call	201b82c <memp_malloc>
 2033d9c:	e0bffc15 	stw	r2,-16(fp)
  if (msg == NULL) {
 2033da0:	e0bffc17 	ldw	r2,-16(fp)
 2033da4:	1000021e 	bne	r2,zero,2033db0 <tcpip_inpkt+0x38>
    return ERR_MEM;
 2033da8:	00bfffc4 	movi	r2,-1
 2033dac:	00001906 	br	2033e14 <tcpip_inpkt+0x9c>
  }

  msg->type = TCPIP_MSG_INPKT;
 2033db0:	e0bffc17 	ldw	r2,-16(fp)
 2033db4:	00c00084 	movi	r3,2
 2033db8:	10c00015 	stw	r3,0(r2)
  msg->msg.inp.p = p;
 2033dbc:	e0bffc17 	ldw	r2,-16(fp)
 2033dc0:	e0fffd17 	ldw	r3,-12(fp)
 2033dc4:	10c00115 	stw	r3,4(r2)
  msg->msg.inp.netif = inp;
 2033dc8:	e0bffc17 	ldw	r2,-16(fp)
 2033dcc:	e0fffe17 	ldw	r3,-8(fp)
 2033dd0:	10c00215 	stw	r3,8(r2)
  msg->msg.inp.input_fn = input_fn;
 2033dd4:	e0bffc17 	ldw	r2,-16(fp)
 2033dd8:	e0ffff17 	ldw	r3,-4(fp)
 2033ddc:	10c00315 	stw	r3,12(r2)
  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
 2033de0:	e17ffc17 	ldw	r5,-16(fp)
 2033de4:	d127ff04 	addi	r4,gp,-24580
 2033de8:	20152880 	call	2015288 <sys_mbox_trypost>
 2033dec:	10803fcc 	andi	r2,r2,255
 2033df0:	1080201c 	xori	r2,r2,128
 2033df4:	10bfe004 	addi	r2,r2,-128
 2033df8:	10000526 	beq	r2,zero,2033e10 <tcpip_inpkt+0x98>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 2033dfc:	e17ffc17 	ldw	r5,-16(fp)
 2033e00:	01000284 	movi	r4,10
 2033e04:	201b9640 	call	201b964 <memp_free>
    return ERR_MEM;
 2033e08:	00bfffc4 	movi	r2,-1
 2033e0c:	00000106 	br	2033e14 <tcpip_inpkt+0x9c>
  }
  return ERR_OK;
 2033e10:	0005883a 	mov	r2,zero
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 2033e14:	e037883a 	mov	sp,fp
 2033e18:	dfc00117 	ldw	ra,4(sp)
 2033e1c:	df000017 	ldw	fp,0(sp)
 2033e20:	dec00204 	addi	sp,sp,8
 2033e24:	f800283a 	ret

02033e28 <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 2033e28:	defffc04 	addi	sp,sp,-16
 2033e2c:	dfc00315 	stw	ra,12(sp)
 2033e30:	df000215 	stw	fp,8(sp)
 2033e34:	df000204 	addi	fp,sp,8
 2033e38:	e13ffe15 	stw	r4,-8(fp)
 2033e3c:	e17fff15 	stw	r5,-4(fp)
#if LWIP_ETHERNET
  if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 2033e40:	e0bfff17 	ldw	r2,-4(fp)
 2033e44:	10800f43 	ldbu	r2,61(r2)
 2033e48:	10803fcc 	andi	r2,r2,255
 2033e4c:	1080060c 	andi	r2,r2,24
 2033e50:	10000626 	beq	r2,zero,2033e6c <tcpip_input+0x44>
    return tcpip_inpkt(p, inp, ethernet_input);
 2033e54:	018080f4 	movhi	r6,515
 2033e58:	31ab4204 	addi	r6,r6,-21240
 2033e5c:	e17fff17 	ldw	r5,-4(fp)
 2033e60:	e13ffe17 	ldw	r4,-8(fp)
 2033e64:	2033d780 	call	2033d78 <tcpip_inpkt>
 2033e68:	00000506 	br	2033e80 <tcpip_input+0x58>
  } else
#endif /* LWIP_ETHERNET */
    return tcpip_inpkt(p, inp, ip_input);
 2033e6c:	01808134 	movhi	r6,516
 2033e70:	31aded04 	addi	r6,r6,-18508
 2033e74:	e17fff17 	ldw	r5,-4(fp)
 2033e78:	e13ffe17 	ldw	r4,-8(fp)
 2033e7c:	2033d780 	call	2033d78 <tcpip_inpkt>
}
 2033e80:	e037883a 	mov	sp,fp
 2033e84:	dfc00117 	ldw	ra,4(sp)
 2033e88:	df000017 	ldw	fp,0(sp)
 2033e8c:	dec00204 	addi	sp,sp,8
 2033e90:	f800283a 	ret

02033e94 <tcpip_callback>:
 *
 * @see tcpip_try_callback
 */
err_t
tcpip_callback(tcpip_callback_fn function, void *ctx)
{
 2033e94:	defffb04 	addi	sp,sp,-20
 2033e98:	dfc00415 	stw	ra,16(sp)
 2033e9c:	df000315 	stw	fp,12(sp)
 2033ea0:	df000304 	addi	fp,sp,12
 2033ea4:	e13ffe15 	stw	r4,-8(fp)
 2033ea8:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 2033eac:	01000244 	movi	r4,9
 2033eb0:	201b82c0 	call	201b82c <memp_malloc>
 2033eb4:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
 2033eb8:	e0bffd17 	ldw	r2,-12(fp)
 2033ebc:	1000021e 	bne	r2,zero,2033ec8 <tcpip_callback+0x34>
    return ERR_MEM;
 2033ec0:	00bfffc4 	movi	r2,-1
 2033ec4:	00000d06 	br	2033efc <tcpip_callback+0x68>
  }

  msg->type = TCPIP_MSG_CALLBACK;
 2033ec8:	e0bffd17 	ldw	r2,-12(fp)
 2033ecc:	00c00144 	movi	r3,5
 2033ed0:	10c00015 	stw	r3,0(r2)
  msg->msg.cb.function = function;
 2033ed4:	e0bffd17 	ldw	r2,-12(fp)
 2033ed8:	e0fffe17 	ldw	r3,-8(fp)
 2033edc:	10c00115 	stw	r3,4(r2)
  msg->msg.cb.ctx = ctx;
 2033ee0:	e0bffd17 	ldw	r2,-12(fp)
 2033ee4:	e0ffff17 	ldw	r3,-4(fp)
 2033ee8:	10c00215 	stw	r3,8(r2)

  sys_mbox_post(&tcpip_mbox, msg);
 2033eec:	e17ffd17 	ldw	r5,-12(fp)
 2033ef0:	d127ff04 	addi	r4,gp,-24580
 2033ef4:	20152340 	call	2015234 <sys_mbox_post>
  return ERR_OK;
 2033ef8:	0005883a 	mov	r2,zero
}
 2033efc:	e037883a 	mov	sp,fp
 2033f00:	dfc00117 	ldw	ra,4(sp)
 2033f04:	df000017 	ldw	fp,0(sp)
 2033f08:	dec00204 	addi	sp,sp,8
 2033f0c:	f800283a 	ret

02033f10 <tcpip_try_callback>:
 *
 * @see tcpip_callback
 */
err_t
tcpip_try_callback(tcpip_callback_fn function, void *ctx)
{
 2033f10:	defffb04 	addi	sp,sp,-20
 2033f14:	dfc00415 	stw	ra,16(sp)
 2033f18:	df000315 	stw	fp,12(sp)
 2033f1c:	df000304 	addi	fp,sp,12
 2033f20:	e13ffe15 	stw	r4,-8(fp)
 2033f24:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 2033f28:	01000244 	movi	r4,9
 2033f2c:	201b82c0 	call	201b82c <memp_malloc>
 2033f30:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
 2033f34:	e0bffd17 	ldw	r2,-12(fp)
 2033f38:	1000021e 	bne	r2,zero,2033f44 <tcpip_try_callback+0x34>
    return ERR_MEM;
 2033f3c:	00bfffc4 	movi	r2,-1
 2033f40:	00001606 	br	2033f9c <tcpip_try_callback+0x8c>
  }

  msg->type = TCPIP_MSG_CALLBACK;
 2033f44:	e0bffd17 	ldw	r2,-12(fp)
 2033f48:	00c00144 	movi	r3,5
 2033f4c:	10c00015 	stw	r3,0(r2)
  msg->msg.cb.function = function;
 2033f50:	e0bffd17 	ldw	r2,-12(fp)
 2033f54:	e0fffe17 	ldw	r3,-8(fp)
 2033f58:	10c00115 	stw	r3,4(r2)
  msg->msg.cb.ctx = ctx;
 2033f5c:	e0bffd17 	ldw	r2,-12(fp)
 2033f60:	e0ffff17 	ldw	r3,-4(fp)
 2033f64:	10c00215 	stw	r3,8(r2)

  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
 2033f68:	e17ffd17 	ldw	r5,-12(fp)
 2033f6c:	d127ff04 	addi	r4,gp,-24580
 2033f70:	20152880 	call	2015288 <sys_mbox_trypost>
 2033f74:	10803fcc 	andi	r2,r2,255
 2033f78:	1080201c 	xori	r2,r2,128
 2033f7c:	10bfe004 	addi	r2,r2,-128
 2033f80:	10000526 	beq	r2,zero,2033f98 <tcpip_try_callback+0x88>
    memp_free(MEMP_TCPIP_MSG_API, msg);
 2033f84:	e17ffd17 	ldw	r5,-12(fp)
 2033f88:	01000244 	movi	r4,9
 2033f8c:	201b9640 	call	201b964 <memp_free>
    return ERR_MEM;
 2033f90:	00bfffc4 	movi	r2,-1
 2033f94:	00000106 	br	2033f9c <tcpip_try_callback+0x8c>
  }
  return ERR_OK;
 2033f98:	0005883a 	mov	r2,zero
}
 2033f9c:	e037883a 	mov	sp,fp
 2033fa0:	dfc00117 	ldw	ra,4(sp)
 2033fa4:	df000017 	ldw	fp,0(sp)
 2033fa8:	dec00204 	addi	sp,sp,8
 2033fac:	f800283a 	ret

02033fb0 <tcpip_timeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
 2033fb0:	defffa04 	addi	sp,sp,-24
 2033fb4:	dfc00515 	stw	ra,20(sp)
 2033fb8:	df000415 	stw	fp,16(sp)
 2033fbc:	df000404 	addi	fp,sp,16
 2033fc0:	e13ffd15 	stw	r4,-12(fp)
 2033fc4:	e17ffe15 	stw	r5,-8(fp)
 2033fc8:	e1bfff15 	stw	r6,-4(fp)
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 2033fcc:	01000244 	movi	r4,9
 2033fd0:	201b82c0 	call	201b82c <memp_malloc>
 2033fd4:	e0bffc15 	stw	r2,-16(fp)
  if (msg == NULL) {
 2033fd8:	e0bffc17 	ldw	r2,-16(fp)
 2033fdc:	1000021e 	bne	r2,zero,2033fe8 <tcpip_timeout+0x38>
    return ERR_MEM;
 2033fe0:	00bfffc4 	movi	r2,-1
 2033fe4:	00001006 	br	2034028 <tcpip_timeout+0x78>
  }

  msg->type = TCPIP_MSG_TIMEOUT;
 2033fe8:	e0bffc17 	ldw	r2,-16(fp)
 2033fec:	00c000c4 	movi	r3,3
 2033ff0:	10c00015 	stw	r3,0(r2)
  msg->msg.tmo.msecs = msecs;
 2033ff4:	e0bffc17 	ldw	r2,-16(fp)
 2033ff8:	e0fffd17 	ldw	r3,-12(fp)
 2033ffc:	10c00115 	stw	r3,4(r2)
  msg->msg.tmo.h = h;
 2034000:	e0bffc17 	ldw	r2,-16(fp)
 2034004:	e0fffe17 	ldw	r3,-8(fp)
 2034008:	10c00215 	stw	r3,8(r2)
  msg->msg.tmo.arg = arg;
 203400c:	e0bffc17 	ldw	r2,-16(fp)
 2034010:	e0ffff17 	ldw	r3,-4(fp)
 2034014:	10c00315 	stw	r3,12(r2)
  sys_mbox_post(&tcpip_mbox, msg);
 2034018:	e17ffc17 	ldw	r5,-16(fp)
 203401c:	d127ff04 	addi	r4,gp,-24580
 2034020:	20152340 	call	2015234 <sys_mbox_post>
  return ERR_OK;
 2034024:	0005883a 	mov	r2,zero
}
 2034028:	e037883a 	mov	sp,fp
 203402c:	dfc00117 	ldw	ra,4(sp)
 2034030:	df000017 	ldw	fp,0(sp)
 2034034:	dec00204 	addi	sp,sp,8
 2034038:	f800283a 	ret

0203403c <tcpip_untimeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_untimeout(sys_timeout_handler h, void *arg)
{
 203403c:	defffb04 	addi	sp,sp,-20
 2034040:	dfc00415 	stw	ra,16(sp)
 2034044:	df000315 	stw	fp,12(sp)
 2034048:	df000304 	addi	fp,sp,12
 203404c:	e13ffe15 	stw	r4,-8(fp)
 2034050:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 2034054:	01000244 	movi	r4,9
 2034058:	201b82c0 	call	201b82c <memp_malloc>
 203405c:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
 2034060:	e0bffd17 	ldw	r2,-12(fp)
 2034064:	1000021e 	bne	r2,zero,2034070 <tcpip_untimeout+0x34>
    return ERR_MEM;
 2034068:	00bfffc4 	movi	r2,-1
 203406c:	00000d06 	br	20340a4 <tcpip_untimeout+0x68>
  }

  msg->type = TCPIP_MSG_UNTIMEOUT;
 2034070:	e0bffd17 	ldw	r2,-12(fp)
 2034074:	00c00104 	movi	r3,4
 2034078:	10c00015 	stw	r3,0(r2)
  msg->msg.tmo.h = h;
 203407c:	e0bffd17 	ldw	r2,-12(fp)
 2034080:	e0fffe17 	ldw	r3,-8(fp)
 2034084:	10c00215 	stw	r3,8(r2)
  msg->msg.tmo.arg = arg;
 2034088:	e0bffd17 	ldw	r2,-12(fp)
 203408c:	e0ffff17 	ldw	r3,-4(fp)
 2034090:	10c00315 	stw	r3,12(r2)
  sys_mbox_post(&tcpip_mbox, msg);
 2034094:	e17ffd17 	ldw	r5,-12(fp)
 2034098:	d127ff04 	addi	r4,gp,-24580
 203409c:	20152340 	call	2015234 <sys_mbox_post>
  return ERR_OK;
 20340a0:	0005883a 	mov	r2,zero
}
 20340a4:	e037883a 	mov	sp,fp
 20340a8:	dfc00117 	ldw	ra,4(sp)
 20340ac:	df000017 	ldw	fp,0(sp)
 20340b0:	dec00204 	addi	sp,sp,8
 20340b4:	f800283a 	ret

020340b8 <tcpip_send_msg_wait_sem>:
 * @param sem semaphore to wait on
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_send_msg_wait_sem(tcpip_callback_fn fn, void *apimsg, sys_sem_t *sem)
{
 20340b8:	defff704 	addi	sp,sp,-36
 20340bc:	dfc00815 	stw	ra,32(sp)
 20340c0:	df000715 	stw	fp,28(sp)
 20340c4:	df000704 	addi	fp,sp,28
 20340c8:	e13ffd15 	stw	r4,-12(fp)
 20340cc:	e17ffe15 	stw	r5,-8(fp)
 20340d0:	e1bfff15 	stw	r6,-4(fp)

  LWIP_ASSERT("semaphore not initialized", sys_sem_valid(sem));
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  TCPIP_MSG_VAR_ALLOC(msg);
  TCPIP_MSG_VAR_REF(msg).type = TCPIP_MSG_API;
 20340d4:	e03ff915 	stw	zero,-28(fp)
  TCPIP_MSG_VAR_REF(msg).msg.api_msg.function = fn;
 20340d8:	e0bffd17 	ldw	r2,-12(fp)
 20340dc:	e0bffa15 	stw	r2,-24(fp)
  TCPIP_MSG_VAR_REF(msg).msg.api_msg.msg = apimsg;
 20340e0:	e0bffe17 	ldw	r2,-8(fp)
 20340e4:	e0bffb15 	stw	r2,-20(fp)
  sys_mbox_post(&tcpip_mbox, &TCPIP_MSG_VAR_REF(msg));
 20340e8:	e17ff904 	addi	r5,fp,-28
 20340ec:	d127ff04 	addi	r4,gp,-24580
 20340f0:	20152340 	call	2015234 <sys_mbox_post>
  sys_arch_sem_wait(sem, 0);
 20340f4:	000b883a 	mov	r5,zero
 20340f8:	e13fff17 	ldw	r4,-4(fp)
 20340fc:	20150800 	call	2015080 <sys_arch_sem_wait>
  TCPIP_MSG_VAR_FREE(msg);
  return ERR_OK;
 2034100:	0005883a 	mov	r2,zero
#endif /* LWIP_TCPIP_CORE_LOCKING */
}
 2034104:	e037883a 	mov	sp,fp
 2034108:	dfc00117 	ldw	ra,4(sp)
 203410c:	df000017 	ldw	fp,0(sp)
 2034110:	dec00204 	addi	sp,sp,8
 2034114:	f800283a 	ret

02034118 <tcpip_api_call>:
 * @param call Call parameters
 * @return Return value from tcpip_api_call_fn
 */
err_t
tcpip_api_call(tcpip_api_call_fn fn, struct tcpip_api_call_data *call)
{
 2034118:	defff704 	addi	sp,sp,-36
 203411c:	dfc00815 	stw	ra,32(sp)
 2034120:	df000715 	stw	fp,28(sp)
 2034124:	df000704 	addi	fp,sp,28
 2034128:	e13ffe15 	stw	r4,-8(fp)
 203412c:	e17fff15 	stw	r5,-4(fp)
  return err;
#else /* LWIP_TCPIP_CORE_LOCKING */
  TCPIP_MSG_VAR_DECLARE(msg);

#if !LWIP_NETCONN_SEM_PER_THREAD
  err_t err = sys_sem_new(&call->sem, 0);
 2034130:	e0bfff17 	ldw	r2,-4(fp)
 2034134:	10800104 	addi	r2,r2,4
 2034138:	000b883a 	mov	r5,zero
 203413c:	1009883a 	mov	r4,r2
 2034140:	2014f380 	call	2014f38 <sys_sem_new>
 2034144:	e0bff905 	stb	r2,-28(fp)
  if (err != ERR_OK) {
 2034148:	e0bff907 	ldb	r2,-28(fp)
 203414c:	10000226 	beq	r2,zero,2034158 <tcpip_api_call+0x40>
    return err;
 2034150:	e0bff903 	ldbu	r2,-28(fp)
 2034154:	00001706 	br	20341b4 <tcpip_api_call+0x9c>
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  TCPIP_MSG_VAR_ALLOC(msg);
  TCPIP_MSG_VAR_REF(msg).type = TCPIP_MSG_API_CALL;
 2034158:	00800044 	movi	r2,1
 203415c:	e0bffa15 	stw	r2,-24(fp)
  TCPIP_MSG_VAR_REF(msg).msg.api_call.arg = call;
 2034160:	e0bfff17 	ldw	r2,-4(fp)
 2034164:	e0bffc15 	stw	r2,-16(fp)
  TCPIP_MSG_VAR_REF(msg).msg.api_call.function = fn;
 2034168:	e0bffe17 	ldw	r2,-8(fp)
 203416c:	e0bffb15 	stw	r2,-20(fp)
#if LWIP_NETCONN_SEM_PER_THREAD
  TCPIP_MSG_VAR_REF(msg).msg.api_call.sem = LWIP_NETCONN_THREAD_SEM_GET();
#else /* LWIP_NETCONN_SEM_PER_THREAD */
  TCPIP_MSG_VAR_REF(msg).msg.api_call.sem = &call->sem;
 2034170:	e0bfff17 	ldw	r2,-4(fp)
 2034174:	10800104 	addi	r2,r2,4
 2034178:	e0bffd15 	stw	r2,-12(fp)
#endif /* LWIP_NETCONN_SEM_PER_THREAD */
  sys_mbox_post(&tcpip_mbox, &TCPIP_MSG_VAR_REF(msg));
 203417c:	e0bffa04 	addi	r2,fp,-24
 2034180:	100b883a 	mov	r5,r2
 2034184:	d127ff04 	addi	r4,gp,-24580
 2034188:	20152340 	call	2015234 <sys_mbox_post>
  sys_arch_sem_wait(TCPIP_MSG_VAR_REF(msg).msg.api_call.sem, 0);
 203418c:	e0bffd17 	ldw	r2,-12(fp)
 2034190:	000b883a 	mov	r5,zero
 2034194:	1009883a 	mov	r4,r2
 2034198:	20150800 	call	2015080 <sys_arch_sem_wait>
  TCPIP_MSG_VAR_FREE(msg);

#if !LWIP_NETCONN_SEM_PER_THREAD
  sys_sem_free(&call->sem);
 203419c:	e0bfff17 	ldw	r2,-4(fp)
 20341a0:	10800104 	addi	r2,r2,4
 20341a4:	1009883a 	mov	r4,r2
 20341a8:	20151040 	call	2015104 <sys_sem_free>
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

  return call->err;
 20341ac:	e0bfff17 	ldw	r2,-4(fp)
 20341b0:	10800003 	ldbu	r2,0(r2)
#endif /* LWIP_TCPIP_CORE_LOCKING */
}
 20341b4:	e037883a 	mov	sp,fp
 20341b8:	dfc00117 	ldw	ra,4(sp)
 20341bc:	df000017 	ldw	fp,0(sp)
 20341c0:	dec00204 	addi	sp,sp,8
 20341c4:	f800283a 	ret

020341c8 <tcpip_callbackmsg_new>:
 * @see tcpip_callbackmsg_trycallback()
 * @see tcpip_callbackmsg_delete()
 */
struct tcpip_callback_msg *
tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
{
 20341c8:	defffb04 	addi	sp,sp,-20
 20341cc:	dfc00415 	stw	ra,16(sp)
 20341d0:	df000315 	stw	fp,12(sp)
 20341d4:	df000304 	addi	fp,sp,12
 20341d8:	e13ffe15 	stw	r4,-8(fp)
 20341dc:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 20341e0:	01000244 	movi	r4,9
 20341e4:	201b82c0 	call	201b82c <memp_malloc>
 20341e8:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
 20341ec:	e0bffd17 	ldw	r2,-12(fp)
 20341f0:	1000021e 	bne	r2,zero,20341fc <tcpip_callbackmsg_new+0x34>
    return NULL;
 20341f4:	0005883a 	mov	r2,zero
 20341f8:	00000a06 	br	2034224 <tcpip_callbackmsg_new+0x5c>
  }
  msg->type = TCPIP_MSG_CALLBACK_STATIC;
 20341fc:	e0bffd17 	ldw	r2,-12(fp)
 2034200:	00c00184 	movi	r3,6
 2034204:	10c00015 	stw	r3,0(r2)
  msg->msg.cb.function = function;
 2034208:	e0bffd17 	ldw	r2,-12(fp)
 203420c:	e0fffe17 	ldw	r3,-8(fp)
 2034210:	10c00115 	stw	r3,4(r2)
  msg->msg.cb.ctx = ctx;
 2034214:	e0bffd17 	ldw	r2,-12(fp)
 2034218:	e0ffff17 	ldw	r3,-4(fp)
 203421c:	10c00215 	stw	r3,8(r2)
  return (struct tcpip_callback_msg *)msg;
 2034220:	e0bffd17 	ldw	r2,-12(fp)
}
 2034224:	e037883a 	mov	sp,fp
 2034228:	dfc00117 	ldw	ra,4(sp)
 203422c:	df000017 	ldw	fp,0(sp)
 2034230:	dec00204 	addi	sp,sp,8
 2034234:	f800283a 	ret

02034238 <tcpip_callbackmsg_delete>:
 *
 * @see tcpip_callbackmsg_new()
 */
void
tcpip_callbackmsg_delete(struct tcpip_callback_msg *msg)
{
 2034238:	defffd04 	addi	sp,sp,-12
 203423c:	dfc00215 	stw	ra,8(sp)
 2034240:	df000115 	stw	fp,4(sp)
 2034244:	df000104 	addi	fp,sp,4
 2034248:	e13fff15 	stw	r4,-4(fp)
  memp_free(MEMP_TCPIP_MSG_API, msg);
 203424c:	e17fff17 	ldw	r5,-4(fp)
 2034250:	01000244 	movi	r4,9
 2034254:	201b9640 	call	201b964 <memp_free>
}
 2034258:	0001883a 	nop
 203425c:	e037883a 	mov	sp,fp
 2034260:	dfc00117 	ldw	ra,4(sp)
 2034264:	df000017 	ldw	fp,0(sp)
 2034268:	dec00204 	addi	sp,sp,8
 203426c:	f800283a 	ret

02034270 <tcpip_callbackmsg_trycallback>:
 *
 * @see tcpip_callbackmsg_new()
 */
err_t
tcpip_callbackmsg_trycallback(struct tcpip_callback_msg *msg)
{
 2034270:	defffd04 	addi	sp,sp,-12
 2034274:	dfc00215 	stw	ra,8(sp)
 2034278:	df000115 	stw	fp,4(sp)
 203427c:	df000104 	addi	fp,sp,4
 2034280:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
  return sys_mbox_trypost(&tcpip_mbox, msg);
 2034284:	e17fff17 	ldw	r5,-4(fp)
 2034288:	d127ff04 	addi	r4,gp,-24580
 203428c:	20152880 	call	2015288 <sys_mbox_trypost>
}
 2034290:	e037883a 	mov	sp,fp
 2034294:	dfc00117 	ldw	ra,4(sp)
 2034298:	df000017 	ldw	fp,0(sp)
 203429c:	dec00204 	addi	sp,sp,8
 20342a0:	f800283a 	ret

020342a4 <tcpip_callbackmsg_trycallback_fromisr>:
 *
 * @see tcpip_callbackmsg_new()
 */
err_t
tcpip_callbackmsg_trycallback_fromisr(struct tcpip_callback_msg *msg)
{
 20342a4:	defffd04 	addi	sp,sp,-12
 20342a8:	dfc00215 	stw	ra,8(sp)
 20342ac:	df000115 	stw	fp,4(sp)
 20342b0:	df000104 	addi	fp,sp,4
 20342b4:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
  return sys_mbox_trypost_fromisr(&tcpip_mbox, msg);
 20342b8:	e17fff17 	ldw	r5,-4(fp)
 20342bc:	d127ff04 	addi	r4,gp,-24580
 20342c0:	201530c0 	call	201530c <sys_mbox_trypost_fromisr>
}
 20342c4:	e037883a 	mov	sp,fp
 20342c8:	dfc00117 	ldw	ra,4(sp)
 20342cc:	df000017 	ldw	fp,0(sp)
 20342d0:	dec00204 	addi	sp,sp,8
 20342d4:	f800283a 	ret

020342d8 <tcpip_callback_wait>:
 * @param ctx parameter passed to f
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_wait(tcpip_callback_fn function, void *ctx)
{
 20342d8:	defff604 	addi	sp,sp,-40
 20342dc:	dfc00915 	stw	ra,36(sp)
 20342e0:	df000815 	stw	fp,32(sp)
 20342e4:	df000804 	addi	fp,sp,32
 20342e8:	e13ffe15 	stw	r4,-8(fp)
 20342ec:	e17fff15 	stw	r5,-4(fp)
  sys_sem_t sem;
  struct tcpip_msg msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  err = sys_sem_new(&sem, 0);
 20342f0:	e0bff904 	addi	r2,fp,-28
 20342f4:	000b883a 	mov	r5,zero
 20342f8:	1009883a 	mov	r4,r2
 20342fc:	2014f380 	call	2014f38 <sys_sem_new>
 2034300:	e0bff805 	stb	r2,-32(fp)
  if (err != ERR_OK) {
 2034304:	e0bff807 	ldb	r2,-32(fp)
 2034308:	10000226 	beq	r2,zero,2034314 <tcpip_callback_wait+0x3c>
    return err;
 203430c:	e0bff803 	ldbu	r2,-32(fp)
 2034310:	00001406 	br	2034364 <tcpip_callback_wait+0x8c>
  }

  msg.type = TCPIP_MSG_CALLBACK_STATIC_WAIT;
 2034314:	008001c4 	movi	r2,7
 2034318:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.cb_wait.function = function;
 203431c:	e0bffe17 	ldw	r2,-8(fp)
 2034320:	e0bffb15 	stw	r2,-20(fp)
  msg.msg.cb_wait.ctx = ctx;
 2034324:	e0bfff17 	ldw	r2,-4(fp)
 2034328:	e0bffc15 	stw	r2,-16(fp)
  msg.msg.cb_wait.sem = &sem;
 203432c:	e0bff904 	addi	r2,fp,-28
 2034330:	e0bffd15 	stw	r2,-12(fp)
  sys_mbox_post(&tcpip_mbox, &msg);
 2034334:	e0bffa04 	addi	r2,fp,-24
 2034338:	100b883a 	mov	r5,r2
 203433c:	d127ff04 	addi	r4,gp,-24580
 2034340:	20152340 	call	2015234 <sys_mbox_post>
  sys_arch_sem_wait(&sem, 0);
 2034344:	e0bff904 	addi	r2,fp,-28
 2034348:	000b883a 	mov	r5,zero
 203434c:	1009883a 	mov	r4,r2
 2034350:	20150800 	call	2015080 <sys_arch_sem_wait>
  sys_sem_free(&sem);
 2034354:	e0bff904 	addi	r2,fp,-28
 2034358:	1009883a 	mov	r4,r2
 203435c:	20151040 	call	2015104 <sys_sem_free>
  return ERR_OK;
 2034360:	0005883a 	mov	r2,zero
#endif /* LWIP_TCPIP_CORE_LOCKING */
}
 2034364:	e037883a 	mov	sp,fp
 2034368:	dfc00117 	ldw	ra,4(sp)
 203436c:	df000017 	ldw	fp,0(sp)
 2034370:	dec00204 	addi	sp,sp,8
 2034374:	f800283a 	ret

02034378 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 2034378:	defffb04 	addi	sp,sp,-20
 203437c:	dfc00415 	stw	ra,16(sp)
 2034380:	df000315 	stw	fp,12(sp)
 2034384:	df000304 	addi	fp,sp,12
 2034388:	e13ffe15 	stw	r4,-8(fp)
 203438c:	e17fff15 	stw	r5,-4(fp)
  lwip_init();
 2034390:	203a36c0 	call	203a36c <lwip_init>

  tcpip_init_done = initfunc;
 2034394:	e0bffe17 	ldw	r2,-8(fp)
 2034398:	d0a7fd15 	stw	r2,-24588(gp)
  tcpip_init_done_arg = arg;
 203439c:	e0bfff17 	ldw	r2,-4(fp)
 20343a0:	d0a7fe15 	stw	r2,-24584(gp)
  if (sys_mbox_new(&tcpip_mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 20343a4:	01440004 	movi	r5,4096
 20343a8:	d127ff04 	addi	r4,gp,-24580
 20343ac:	20151640 	call	2015164 <sys_mbox_new>
  if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 20343b0:	008000c4 	movi	r2,3
 20343b4:	d8800015 	stw	r2,0(sp)
 20343b8:	01c80004 	movi	r7,8192
 20343bc:	000d883a 	mov	r6,zero
 20343c0:	014080f4 	movhi	r5,515
 20343c4:	294eca04 	addi	r5,r5,15144
 20343c8:	01008134 	movhi	r4,516
 20343cc:	211c2704 	addi	r4,r4,28828
 20343d0:	20155200 	call	2015520 <sys_thread_new>
}
 20343d4:	0001883a 	nop
 20343d8:	e037883a 	mov	sp,fp
 20343dc:	dfc00117 	ldw	ra,4(sp)
 20343e0:	df000017 	ldw	fp,0(sp)
 20343e4:	dec00204 	addi	sp,sp,8
 20343e8:	f800283a 	ret

020343ec <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
 20343ec:	defffc04 	addi	sp,sp,-16
 20343f0:	dfc00315 	stw	ra,12(sp)
 20343f4:	df000215 	stw	fp,8(sp)
 20343f8:	df000204 	addi	fp,sp,8
 20343fc:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q = (struct pbuf *)p;
 2034400:	e0bfff17 	ldw	r2,-4(fp)
 2034404:	e0bffe15 	stw	r2,-8(fp)
  pbuf_free(q);
 2034408:	e13ffe17 	ldw	r4,-8(fp)
 203440c:	201d2f40 	call	201d2f4 <pbuf_free>
}
 2034410:	0001883a 	nop
 2034414:	e037883a 	mov	sp,fp
 2034418:	dfc00117 	ldw	ra,4(sp)
 203441c:	df000017 	ldw	fp,0(sp)
 2034420:	dec00204 	addi	sp,sp,8
 2034424:	f800283a 	ret

02034428 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
 2034428:	defffd04 	addi	sp,sp,-12
 203442c:	dfc00215 	stw	ra,8(sp)
 2034430:	df000115 	stw	fp,4(sp)
 2034434:	df000104 	addi	fp,sp,4
 2034438:	e13fff15 	stw	r4,-4(fp)
  return tcpip_try_callback(pbuf_free_int, p);
 203443c:	e17fff17 	ldw	r5,-4(fp)
 2034440:	010080f4 	movhi	r4,515
 2034444:	2110fb04 	addi	r4,r4,17388
 2034448:	2033f100 	call	2033f10 <tcpip_try_callback>
}
 203444c:	e037883a 	mov	sp,fp
 2034450:	dfc00117 	ldw	ra,4(sp)
 2034454:	df000017 	ldw	fp,0(sp)
 2034458:	dec00204 	addi	sp,sp,8
 203445c:	f800283a 	ret

02034460 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
 2034460:	defffd04 	addi	sp,sp,-12
 2034464:	dfc00215 	stw	ra,8(sp)
 2034468:	df000115 	stw	fp,4(sp)
 203446c:	df000104 	addi	fp,sp,4
 2034470:	e13fff15 	stw	r4,-4(fp)
  return tcpip_try_callback(mem_free, m);
 2034474:	e17fff17 	ldw	r5,-4(fp)
 2034478:	010080b4 	movhi	r4,514
 203447c:	212b3f04 	addi	r4,r4,-21252
 2034480:	2033f100 	call	2033f10 <tcpip_try_callback>
}
 2034484:	e037883a 	mov	sp,fp
 2034488:	dfc00117 	ldw	ra,4(sp)
 203448c:	df000017 	ldw	fp,0(sp)
 2034490:	dec00204 	addi	sp,sp,8
 2034494:	f800283a 	ret

02034498 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 2034498:	defffb04 	addi	sp,sp,-20
 203449c:	df000115 	stw	fp,4(sp)
 20344a0:	df000104 	addi	fp,sp,4
 20344a4:	e13fff15 	stw	r4,-4(fp)
 20344a8:	e1400115 	stw	r5,4(fp)
 20344ac:	e1800215 	stw	r6,8(fp)
 20344b0:	e1c00315 	stw	r7,12(fp)
 20344b4:	0001883a 	nop
 20344b8:	e037883a 	mov	sp,fp
 20344bc:	df000017 	ldw	fp,0(sp)
 20344c0:	dec00404 	addi	sp,sp,16
 20344c4:	f800283a 	ret

020344c8 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 20344c8:	defffb04 	addi	sp,sp,-20
 20344cc:	df000415 	stw	fp,16(sp)
 20344d0:	df000404 	addi	fp,sp,16
 20344d4:	e13ffc15 	stw	r4,-16(fp)
 20344d8:	e17ffd15 	stw	r5,-12(fp)
 20344dc:	e1bffe15 	stw	r6,-8(fp)
 20344e0:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 20344e4:	e0fffd17 	ldw	r3,-12(fp)
 20344e8:	e0bffc17 	ldw	r2,-16(fp)
 20344ec:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 20344f0:	e0fffe17 	ldw	r3,-8(fp)
 20344f4:	e0bffc17 	ldw	r2,-16(fp)
 20344f8:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 20344fc:	e0ffff17 	ldw	r3,-4(fp)
 2034500:	e0bffc17 	ldw	r2,-16(fp)
 2034504:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 2034508:	e0c00117 	ldw	r3,4(fp)
 203450c:	e0bffc17 	ldw	r2,-16(fp)
 2034510:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 2034514:	0005883a 	mov	r2,zero
}
 2034518:	e037883a 	mov	sp,fp
 203451c:	df000017 	ldw	fp,0(sp)
 2034520:	dec00104 	addi	sp,sp,4
 2034524:	f800283a 	ret

02034528 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 2034528:	defffa04 	addi	sp,sp,-24
 203452c:	dfc00515 	stw	ra,20(sp)
 2034530:	df000415 	stw	fp,16(sp)
 2034534:	df000404 	addi	fp,sp,16
 2034538:	e13ffe15 	stw	r4,-8(fp)
 203453c:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 2034540:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 2034544:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 2034548:	00000b06 	br	2034578 <tse_mac_sTxWrite+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 203454c:	e0fffc17 	ldw	r3,-16(fp)
 2034550:	18800044 	addi	r2,r3,1
 2034554:	e0bffc15 	stw	r2,-16(fp)
 2034558:	008003f4 	movhi	r2,15
 203455c:	10909004 	addi	r2,r2,16960
 2034560:	1880051e 	bne	r3,r2,2034578 <tse_mac_sTxWrite+0x50>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 2034564:	01008134 	movhi	r4,516
 2034568:	211c2b04 	addi	r4,r4,28844
 203456c:	20426cc0 	call	20426cc <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 2034570:	00bffa84 	movi	r2,-22
 2034574:	00002006 	br	20345f8 <tse_mac_sTxWrite+0xd0>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 2034578:	e0bffe17 	ldw	r2,-8(fp)
 203457c:	10800117 	ldw	r2,4(r2)
 2034580:	10800317 	ldw	r2,12(r2)
 2034584:	10800037 	ldwio	r2,0(r2)
 2034588:	1080040c 	andi	r2,r2,16
 203458c:	103fef1e 	bne	r2,zero,203454c <__alt_mem_mem_0+0xfd01454c>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 2034590:	e0bffe17 	ldw	r2,-8(fp)
 2034594:	10800117 	ldw	r2,4(r2)
 2034598:	10800317 	ldw	r2,12(r2)
 203459c:	10800404 	addi	r2,r2,16
 20345a0:	0007883a 	mov	r3,zero
 20345a4:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 20345a8:	e0bffe17 	ldw	r2,-8(fp)
 20345ac:	10800117 	ldw	r2,4(r2)
 20345b0:	10800317 	ldw	r2,12(r2)
 20345b4:	00c03fc4 	movi	r3,255
 20345b8:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 20345bc:	e0bffe17 	ldw	r2,-8(fp)
 20345c0:	10800117 	ldw	r2,4(r2)
 20345c4:	e17fff17 	ldw	r5,-4(fp)
 20345c8:	1009883a 	mov	r4,r2
 20345cc:	202bea40 	call	202bea4 <alt_avalon_sgdma_do_sync_transfer>
 20345d0:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  if (result != 0)
 20345d4:	e0bffd03 	ldbu	r2,-12(fp)
 20345d8:	10000226 	beq	r2,zero,20345e4 <tse_mac_sTxWrite+0xbc>
    return -1;
 20345dc:	00bfffc4 	movi	r2,-1
 20345e0:	00000506 	br	20345f8 <tse_mac_sTxWrite+0xd0>
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 20345e4:	e0bfff17 	ldw	r2,-4(fp)
 20345e8:	10800704 	addi	r2,r2,28
 20345ec:	10800037 	ldwio	r2,0(r2)
 20345f0:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 20345f4:	e0bffd8b 	ldhu	r2,-10(fp)
}
 20345f8:	e037883a 	mov	sp,fp
 20345fc:	dfc00117 	ldw	ra,4(sp)
 2034600:	df000017 	ldw	fp,0(sp)
 2034604:	dec00204 	addi	sp,sp,8
 2034608:	f800283a 	ret

0203460c <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 203460c:	defffa04 	addi	sp,sp,-24
 2034610:	dfc00515 	stw	ra,20(sp)
 2034614:	df000415 	stw	fp,16(sp)
 2034618:	df000404 	addi	fp,sp,16
 203461c:	e13ffe15 	stw	r4,-8(fp)
 2034620:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 2034624:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 2034628:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 203462c:	00000b06 	br	203465c <tse_mac_aRxRead+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 2034630:	e0fffc17 	ldw	r3,-16(fp)
 2034634:	18800044 	addi	r2,r3,1
 2034638:	e0bffc15 	stw	r2,-16(fp)
 203463c:	008003f4 	movhi	r2,15
 2034640:	10909004 	addi	r2,r2,16960
 2034644:	1880051e 	bne	r3,r2,203465c <tse_mac_aRxRead+0x50>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 2034648:	01008134 	movhi	r4,516
 203464c:	211c3204 	addi	r4,r4,28872
 2034650:	20426cc0 	call	20426cc <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 2034654:	00bffa84 	movi	r2,-22
 2034658:	00001106 	br	20346a0 <tse_mac_aRxRead+0x94>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 203465c:	e0bffe17 	ldw	r2,-8(fp)
 2034660:	10800217 	ldw	r2,8(r2)
 2034664:	10800317 	ldw	r2,12(r2)
 2034668:	10800037 	ldwio	r2,0(r2)
 203466c:	1080040c 	andi	r2,r2,16
 2034670:	103fef1e 	bne	r2,zero,2034630 <__alt_mem_mem_0+0xfd014630>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 2034674:	e0bffe17 	ldw	r2,-8(fp)
 2034678:	10800217 	ldw	r2,8(r2)
 203467c:	e17fff17 	ldw	r5,-4(fp)
 2034680:	1009883a 	mov	r4,r2
 2034684:	202bd800 	call	202bd80 <alt_avalon_sgdma_do_async_transfer>
 2034688:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);
  
  if (result != 0)
 203468c:	e0bffd03 	ldbu	r2,-12(fp)
 2034690:	10000226 	beq	r2,zero,203469c <tse_mac_aRxRead+0x90>
    return -1;
 2034694:	00bfffc4 	movi	r2,-1
 2034698:	00000106 	br	20346a0 <tse_mac_aRxRead+0x94>
 
  return SUCCESS;
 203469c:	0005883a 	mov	r2,zero
}
 20346a0:	e037883a 	mov	sp,fp
 20346a4:	dfc00117 	ldw	ra,4(sp)
 20346a8:	df000017 	ldw	fp,0(sp)
 20346ac:	dec00204 	addi	sp,sp,8
 20346b0:	f800283a 	ret

020346b4 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 20346b4:	defffc04 	addi	sp,sp,-16
 20346b8:	df000315 	stw	fp,12(sp)
 20346bc:	df000304 	addi	fp,sp,12
 20346c0:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 20346c4:	e0bfff17 	ldw	r2,-4(fp)
 20346c8:	10800204 	addi	r2,r2,8
 20346cc:	10800037 	ldwio	r2,0(r2)
 20346d0:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 20346d4:	e0bfff17 	ldw	r2,-4(fp)
 20346d8:	10800204 	addi	r2,r2,8
 20346dc:	00c80204 	movi	r3,8200
 20346e0:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 20346e4:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 20346e8:	00000306 	br	20346f8 <tse_mac_SwReset+0x44>
 20346ec:	e0bffd17 	ldw	r2,-12(fp)
 20346f0:	10800044 	addi	r2,r2,1
 20346f4:	e0bffd15 	stw	r2,-12(fp)
 20346f8:	e0bfff17 	ldw	r2,-4(fp)
 20346fc:	10800204 	addi	r2,r2,8
 2034700:	10800037 	ldwio	r2,0(r2)
 2034704:	1088000c 	andi	r2,r2,8192
 2034708:	10000326 	beq	r2,zero,2034718 <tse_mac_SwReset+0x64>
 203470c:	e0bffd17 	ldw	r2,-12(fp)
 2034710:	1089c410 	cmplti	r2,r2,10000
 2034714:	103ff51e 	bne	r2,zero,20346ec <__alt_mem_mem_0+0xfd0146ec>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 2034718:	e0bfff17 	ldw	r2,-4(fp)
 203471c:	10800204 	addi	r2,r2,8
 2034720:	e0fffe17 	ldw	r3,-8(fp)
 2034724:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 2034728:	0005883a 	mov	r2,zero
}
 203472c:	e037883a 	mov	sp,fp
 2034730:	df000017 	ldw	fp,0(sp)
 2034734:	dec00104 	addi	sp,sp,4
 2034738:	f800283a 	ret

0203473c <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 203473c:	defffd04 	addi	sp,sp,-12
 2034740:	df000215 	stw	fp,8(sp)
 2034744:	df000204 	addi	fp,sp,8
 2034748:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 203474c:	e0bfff17 	ldw	r2,-4(fp)
 2034750:	10800204 	addi	r2,r2,8
 2034754:	10800037 	ldwio	r2,0(r2)
 2034758:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 203475c:	e0fffe17 	ldw	r3,-8(fp)
 2034760:	00bffdc4 	movi	r2,-9
 2034764:	1884703a 	and	r2,r3,r2
 2034768:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 203476c:	e0bfff17 	ldw	r2,-4(fp)
 2034770:	10800204 	addi	r2,r2,8
 2034774:	e0fffe17 	ldw	r3,-8(fp)
 2034778:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 203477c:	0005883a 	mov	r2,zero
}
 2034780:	e037883a 	mov	sp,fp
 2034784:	df000017 	ldw	fp,0(sp)
 2034788:	dec00104 	addi	sp,sp,4
 203478c:	f800283a 	ret

02034790 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 2034790:	defffd04 	addi	sp,sp,-12
 2034794:	df000215 	stw	fp,8(sp)
 2034798:	df000204 	addi	fp,sp,8
 203479c:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 20347a0:	e0bfff17 	ldw	r2,-4(fp)
 20347a4:	10800204 	addi	r2,r2,8
 20347a8:	10800037 	ldwio	r2,0(r2)
 20347ac:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 20347b0:	e0bffe17 	ldw	r2,-8(fp)
 20347b4:	10800214 	ori	r2,r2,8
 20347b8:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 20347bc:	e0bfff17 	ldw	r2,-4(fp)
 20347c0:	10800204 	addi	r2,r2,8
 20347c4:	e0fffe17 	ldw	r3,-8(fp)
 20347c8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 20347cc:	0005883a 	mov	r2,zero
}
 20347d0:	e037883a 	mov	sp,fp
 20347d4:	df000017 	ldw	fp,0(sp)
 20347d8:	dec00104 	addi	sp,sp,4
 20347dc:	f800283a 	ret

020347e0 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 20347e0:	defffb04 	addi	sp,sp,-20
 20347e4:	dfc00415 	stw	ra,16(sp)
 20347e8:	df000315 	stw	fp,12(sp)
 20347ec:	dc000215 	stw	r16,8(sp)
 20347f0:	df000304 	addi	fp,sp,12
 20347f4:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 20347f8:	e03ffd15 	stw	zero,-12(fp)
 20347fc:	00002906 	br	20348a4 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 2034800:	008085f4 	movhi	r2,535
 2034804:	10be3a04 	addi	r2,r2,-1816
 2034808:	e0fffd17 	ldw	r3,-12(fp)
 203480c:	18c7883a 	add	r3,r3,r3
 2034810:	18c7883a 	add	r3,r3,r3
 2034814:	10c5883a 	add	r2,r2,r3
 2034818:	10800017 	ldw	r2,0(r2)
 203481c:	10c01417 	ldw	r3,80(r2)
 2034820:	e0bffe17 	ldw	r2,-8(fp)
 2034824:	10801417 	ldw	r2,80(r2)
 2034828:	18801b1e 	bne	r3,r2,2034898 <alt_tse_phy_add_profile+0xb8>
 203482c:	008085f4 	movhi	r2,535
 2034830:	10be3a04 	addi	r2,r2,-1816
 2034834:	e0fffd17 	ldw	r3,-12(fp)
 2034838:	18c7883a 	add	r3,r3,r3
 203483c:	18c7883a 	add	r3,r3,r3
 2034840:	10c5883a 	add	r2,r2,r3
 2034844:	10800017 	ldw	r2,0(r2)
 2034848:	10c01503 	ldbu	r3,84(r2)
 203484c:	e0bffe17 	ldw	r2,-8(fp)
 2034850:	10801503 	ldbu	r2,84(r2)
 2034854:	18c03fcc 	andi	r3,r3,255
 2034858:	10803fcc 	andi	r2,r2,255
 203485c:	18800e1e 	bne	r3,r2,2034898 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 2034860:	e0bffe17 	ldw	r2,-8(fp)
 2034864:	10801417 	ldw	r2,80(r2)
 2034868:	1007883a 	mov	r3,r2
 203486c:	e0bffe17 	ldw	r2,-8(fp)
 2034870:	10801503 	ldbu	r2,84(r2)
 2034874:	10803fcc 	andi	r2,r2,255
 2034878:	100d883a 	mov	r6,r2
 203487c:	180b883a 	mov	r5,r3
 2034880:	01008134 	movhi	r4,516
 2034884:	211c3904 	addi	r4,r4,28900
 2034888:	20009e40 	call	20009e4 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 203488c:	01008134 	movhi	r4,516
 2034890:	211c4d04 	addi	r4,r4,28980
 2034894:	20426cc0 	call	20426cc <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 2034898:	e0bffd17 	ldw	r2,-12(fp)
 203489c:	10800044 	addi	r2,r2,1
 20348a0:	e0bffd15 	stw	r2,-12(fp)
 20348a4:	d0a80003 	ldbu	r2,-24576(gp)
 20348a8:	10803fcc 	andi	r2,r2,255
 20348ac:	e0fffd17 	ldw	r3,-12(fp)
 20348b0:	18bfd316 	blt	r3,r2,2034800 <__alt_mem_mem_0+0xfd014800>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 20348b4:	d0a80003 	ldbu	r2,-24576(gp)
 20348b8:	14003fcc 	andi	r16,r2,255
 20348bc:	01001904 	movi	r4,100
 20348c0:	20424000 	call	2042400 <malloc>
 20348c4:	1009883a 	mov	r4,r2
 20348c8:	008085f4 	movhi	r2,535
 20348cc:	10be3a04 	addi	r2,r2,-1816
 20348d0:	8407883a 	add	r3,r16,r16
 20348d4:	18c7883a 	add	r3,r3,r3
 20348d8:	10c5883a 	add	r2,r2,r3
 20348dc:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 20348e0:	d0a80003 	ldbu	r2,-24576(gp)
 20348e4:	10c03fcc 	andi	r3,r2,255
 20348e8:	008085f4 	movhi	r2,535
 20348ec:	10be3a04 	addi	r2,r2,-1816
 20348f0:	18c7883a 	add	r3,r3,r3
 20348f4:	18c7883a 	add	r3,r3,r3
 20348f8:	10c5883a 	add	r2,r2,r3
 20348fc:	10800017 	ldw	r2,0(r2)
 2034900:	1000081e 	bne	r2,zero,2034924 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 2034904:	d0a80003 	ldbu	r2,-24576(gp)
 2034908:	10803fcc 	andi	r2,r2,255
 203490c:	100b883a 	mov	r5,r2
 2034910:	01008134 	movhi	r4,516
 2034914:	211c6504 	addi	r4,r4,29076
 2034918:	20009e40 	call	20009e4 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 203491c:	00bfffc4 	movi	r2,-1
 2034920:	00002206 	br	20349ac <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 2034924:	d0a80003 	ldbu	r2,-24576(gp)
 2034928:	10c03fcc 	andi	r3,r2,255
 203492c:	008085f4 	movhi	r2,535
 2034930:	10be3a04 	addi	r2,r2,-1816
 2034934:	18c7883a 	add	r3,r3,r3
 2034938:	18c7883a 	add	r3,r3,r3
 203493c:	10c5883a 	add	r2,r2,r3
 2034940:	10c00017 	ldw	r3,0(r2)
 2034944:	e0bffe17 	ldw	r2,-8(fp)
 2034948:	1009883a 	mov	r4,r2
 203494c:	00801904 	movi	r2,100
 2034950:	100d883a 	mov	r6,r2
 2034954:	200b883a 	mov	r5,r4
 2034958:	1809883a 	mov	r4,r3
 203495c:	2005e580 	call	2005e58 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 2034960:	d0a80003 	ldbu	r2,-24576(gp)
 2034964:	10c03fcc 	andi	r3,r2,255
 2034968:	008085f4 	movhi	r2,535
 203496c:	10be3a04 	addi	r2,r2,-1816
 2034970:	18c7883a 	add	r3,r3,r3
 2034974:	18c7883a 	add	r3,r3,r3
 2034978:	10c5883a 	add	r2,r2,r3
 203497c:	10800017 	ldw	r2,0(r2)
 2034980:	1007883a 	mov	r3,r2
 2034984:	e0bffe17 	ldw	r2,-8(fp)
 2034988:	100b883a 	mov	r5,r2
 203498c:	1809883a 	mov	r4,r3
 2034990:	204289c0 	call	204289c <strcpy>
    
    phy_profile_count++;
 2034994:	d0a80003 	ldbu	r2,-24576(gp)
 2034998:	10800044 	addi	r2,r2,1
 203499c:	d0a80005 	stb	r2,-24576(gp)
    
    return phy_profile_count - 1;
 20349a0:	d0a80003 	ldbu	r2,-24576(gp)
 20349a4:	10803fcc 	andi	r2,r2,255
 20349a8:	10bfffc4 	addi	r2,r2,-1
}
 20349ac:	e6ffff04 	addi	sp,fp,-4
 20349b0:	dfc00217 	ldw	ra,8(sp)
 20349b4:	df000117 	ldw	fp,4(sp)
 20349b8:	dc000017 	ldw	r16,0(sp)
 20349bc:	dec00304 	addi	sp,sp,12
 20349c0:	f800283a 	ret

020349c4 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 20349c4:	defff204 	addi	sp,sp,-56
 20349c8:	dfc00d15 	stw	ra,52(sp)
 20349cc:	df000c15 	stw	fp,48(sp)
 20349d0:	dc000b15 	stw	r16,44(sp)
 20349d4:	df000c04 	addi	fp,sp,48
 20349d8:	e13ffb15 	stw	r4,-20(fp)
 20349dc:	e17ffc15 	stw	r5,-16(fp)
 20349e0:	e1bffd15 	stw	r6,-12(fp)
 20349e4:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 20349e8:	e0bffb17 	ldw	r2,-20(fp)
 20349ec:	e0bffa15 	stw	r2,-24(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 20349f0:	e0bffc17 	ldw	r2,-16(fp)
 20349f4:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 20349f8:	e0bffd17 	ldw	r2,-12(fp)
 20349fc:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 2034a00:	e0bffe17 	ldw	r2,-8(fp)
 2034a04:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 2034a08:	e0800217 	ldw	r2,8(fp)
 2034a0c:	e0bff915 	stw	r2,-28(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 2034a10:	e0bffa17 	ldw	r2,-24(fp)
 2034a14:	10800303 	ldbu	r2,12(r2)
 2034a18:	10803fcc 	andi	r2,r2,255
 2034a1c:	1000031e 	bne	r2,zero,2034a2c <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 2034a20:	00800044 	movi	r2,1
 2034a24:	e0bff515 	stw	r2,-44(fp)
 2034a28:	00000e06 	br	2034a64 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 2034a2c:	e0bffa17 	ldw	r2,-24(fp)
 2034a30:	10800303 	ldbu	r2,12(r2)
 2034a34:	10803fcc 	andi	r2,r2,255
 2034a38:	10000526 	beq	r2,zero,2034a50 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 2034a3c:	e0bffa17 	ldw	r2,-24(fp)
 2034a40:	10800303 	ldbu	r2,12(r2)
 2034a44:	10803fcc 	andi	r2,r2,255
 2034a48:	e0bff515 	stw	r2,-44(fp)
 2034a4c:	00000506 	br	2034a64 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 2034a50:	01008134 	movhi	r4,516
 2034a54:	211c7404 	addi	r4,r4,29136
 2034a58:	20426cc0 	call	20426cc <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2034a5c:	00bfffc4 	movi	r2,-1
 2034a60:	00025106 	br	20353a8 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 2034a64:	e03ff415 	stw	zero,-48(fp)
 2034a68:	00024b06 	br	2035398 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 2034a6c:	d0a80083 	ldbu	r2,-24574(gp)
 2034a70:	10803fcc 	andi	r2,r2,255
 2034a74:	1080201c 	xori	r2,r2,128
 2034a78:	10bfe004 	addi	r2,r2,-128
 2034a7c:	10800210 	cmplti	r2,r2,8
 2034a80:	10000c1e 	bne	r2,zero,2034ab4 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 2034a84:	01008134 	movhi	r4,516
 2034a88:	211c8004 	addi	r4,r4,29184
 2034a8c:	20426cc0 	call	20426cc <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 2034a90:	d0a80083 	ldbu	r2,-24574(gp)
 2034a94:	10803fcc 	andi	r2,r2,255
 2034a98:	1080201c 	xori	r2,r2,128
 2034a9c:	10bfe004 	addi	r2,r2,-128
 2034aa0:	100d883a 	mov	r6,r2
 2034aa4:	01400204 	movi	r5,8
 2034aa8:	01008134 	movhi	r4,516
 2034aac:	211c9004 	addi	r4,r4,29248
 2034ab0:	20009e40 	call	20009e4 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 2034ab4:	e0bffa17 	ldw	r2,-24(fp)
 2034ab8:	1000081e 	bne	r2,zero,2034adc <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 2034abc:	01008134 	movhi	r4,516
 2034ac0:	211c9f04 	addi	r4,r4,29308
 2034ac4:	20426cc0 	call	20426cc <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 2034ac8:	01008134 	movhi	r4,516
 2034acc:	211ca904 	addi	r4,r4,29348
 2034ad0:	20426cc0 	call	20426cc <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2034ad4:	00bfffc4 	movi	r2,-1
 2034ad8:	00023306 	br	20353a8 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 2034adc:	d0a80083 	ldbu	r2,-24574(gp)
 2034ae0:	11003fcc 	andi	r4,r2,255
 2034ae4:	2100201c 	xori	r4,r4,128
 2034ae8:	213fe004 	addi	r4,r4,-128
 2034aec:	e0bffa17 	ldw	r2,-24(fp)
 2034af0:	10800017 	ldw	r2,0(r2)
 2034af4:	e0fff417 	ldw	r3,-48(fp)
 2034af8:	180692ba 	slli	r3,r3,10
 2034afc:	10c7883a 	add	r3,r2,r3
 2034b00:	00808174 	movhi	r2,517
 2034b04:	10aaaf04 	addi	r2,r2,-21828
 2034b08:	21001224 	muli	r4,r4,72
 2034b0c:	1105883a 	add	r2,r2,r4
 2034b10:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 2034b14:	d0a80083 	ldbu	r2,-24574(gp)
 2034b18:	11003fcc 	andi	r4,r2,255
 2034b1c:	2100201c 	xori	r4,r4,128
 2034b20:	213fe004 	addi	r4,r4,-128
 2034b24:	e0bffa17 	ldw	r2,-24(fp)
 2034b28:	10c0010b 	ldhu	r3,4(r2)
 2034b2c:	00808174 	movhi	r2,517
 2034b30:	10aaaf04 	addi	r2,r2,-21828
 2034b34:	21001224 	muli	r4,r4,72
 2034b38:	1105883a 	add	r2,r2,r4
 2034b3c:	10800104 	addi	r2,r2,4
 2034b40:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 2034b44:	d0a80083 	ldbu	r2,-24574(gp)
 2034b48:	11003fcc 	andi	r4,r2,255
 2034b4c:	2100201c 	xori	r4,r4,128
 2034b50:	213fe004 	addi	r4,r4,-128
 2034b54:	e0bffa17 	ldw	r2,-24(fp)
 2034b58:	10c0018b 	ldhu	r3,6(r2)
 2034b5c:	00808174 	movhi	r2,517
 2034b60:	10aaaf04 	addi	r2,r2,-21828
 2034b64:	21001224 	muli	r4,r4,72
 2034b68:	1105883a 	add	r2,r2,r4
 2034b6c:	10800184 	addi	r2,r2,6
 2034b70:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 2034b74:	d0a80083 	ldbu	r2,-24574(gp)
 2034b78:	11003fcc 	andi	r4,r2,255
 2034b7c:	2100201c 	xori	r4,r4,128
 2034b80:	213fe004 	addi	r4,r4,-128
 2034b84:	e0bffa17 	ldw	r2,-24(fp)
 2034b88:	10c00203 	ldbu	r3,8(r2)
 2034b8c:	00808174 	movhi	r2,517
 2034b90:	10aaaf04 	addi	r2,r2,-21828
 2034b94:	21001224 	muli	r4,r4,72
 2034b98:	1105883a 	add	r2,r2,r4
 2034b9c:	10800204 	addi	r2,r2,8
 2034ba0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 2034ba4:	d0a80083 	ldbu	r2,-24574(gp)
 2034ba8:	11003fcc 	andi	r4,r2,255
 2034bac:	2100201c 	xori	r4,r4,128
 2034bb0:	213fe004 	addi	r4,r4,-128
 2034bb4:	e0bffa17 	ldw	r2,-24(fp)
 2034bb8:	10c00243 	ldbu	r3,9(r2)
 2034bbc:	00808174 	movhi	r2,517
 2034bc0:	10aaaf04 	addi	r2,r2,-21828
 2034bc4:	21001224 	muli	r4,r4,72
 2034bc8:	1105883a 	add	r2,r2,r4
 2034bcc:	10800244 	addi	r2,r2,9
 2034bd0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 2034bd4:	d0a80083 	ldbu	r2,-24574(gp)
 2034bd8:	11003fcc 	andi	r4,r2,255
 2034bdc:	2100201c 	xori	r4,r4,128
 2034be0:	213fe004 	addi	r4,r4,-128
 2034be4:	e0bffa17 	ldw	r2,-24(fp)
 2034be8:	10c00283 	ldbu	r3,10(r2)
 2034bec:	00808174 	movhi	r2,517
 2034bf0:	10aaaf04 	addi	r2,r2,-21828
 2034bf4:	21001224 	muli	r4,r4,72
 2034bf8:	1105883a 	add	r2,r2,r4
 2034bfc:	10800284 	addi	r2,r2,10
 2034c00:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 2034c04:	d0a80083 	ldbu	r2,-24574(gp)
 2034c08:	11003fcc 	andi	r4,r2,255
 2034c0c:	2100201c 	xori	r4,r4,128
 2034c10:	213fe004 	addi	r4,r4,-128
 2034c14:	e0bffa17 	ldw	r2,-24(fp)
 2034c18:	10c002c3 	ldbu	r3,11(r2)
 2034c1c:	00808174 	movhi	r2,517
 2034c20:	10aaaf04 	addi	r2,r2,-21828
 2034c24:	21001224 	muli	r4,r4,72
 2034c28:	1105883a 	add	r2,r2,r4
 2034c2c:	108002c4 	addi	r2,r2,11
 2034c30:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 2034c34:	d0a80083 	ldbu	r2,-24574(gp)
 2034c38:	11003fcc 	andi	r4,r2,255
 2034c3c:	2100201c 	xori	r4,r4,128
 2034c40:	213fe004 	addi	r4,r4,-128
 2034c44:	e0bffa17 	ldw	r2,-24(fp)
 2034c48:	10c00303 	ldbu	r3,12(r2)
 2034c4c:	00808174 	movhi	r2,517
 2034c50:	10aaaf04 	addi	r2,r2,-21828
 2034c54:	21001224 	muli	r4,r4,72
 2034c58:	1105883a 	add	r2,r2,r4
 2034c5c:	10800304 	addi	r2,r2,12
 2034c60:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 2034c64:	d0a80083 	ldbu	r2,-24574(gp)
 2034c68:	11003fcc 	andi	r4,r2,255
 2034c6c:	2100201c 	xori	r4,r4,128
 2034c70:	213fe004 	addi	r4,r4,-128
 2034c74:	e0bffa17 	ldw	r2,-24(fp)
 2034c78:	10c00343 	ldbu	r3,13(r2)
 2034c7c:	00808174 	movhi	r2,517
 2034c80:	10aaaf04 	addi	r2,r2,-21828
 2034c84:	21001224 	muli	r4,r4,72
 2034c88:	1105883a 	add	r2,r2,r4
 2034c8c:	10800344 	addi	r2,r2,13
 2034c90:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 2034c94:	d0a80083 	ldbu	r2,-24574(gp)
 2034c98:	11003fcc 	andi	r4,r2,255
 2034c9c:	2100201c 	xori	r4,r4,128
 2034ca0:	213fe004 	addi	r4,r4,-128
 2034ca4:	e0bffa17 	ldw	r2,-24(fp)
 2034ca8:	10c00383 	ldbu	r3,14(r2)
 2034cac:	00808174 	movhi	r2,517
 2034cb0:	10aaaf04 	addi	r2,r2,-21828
 2034cb4:	21001224 	muli	r4,r4,72
 2034cb8:	1105883a 	add	r2,r2,r4
 2034cbc:	10800384 	addi	r2,r2,14
 2034cc0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 2034cc4:	d0a80083 	ldbu	r2,-24574(gp)
 2034cc8:	11003fcc 	andi	r4,r2,255
 2034ccc:	2100201c 	xori	r4,r4,128
 2034cd0:	213fe004 	addi	r4,r4,-128
 2034cd4:	e0bffa17 	ldw	r2,-24(fp)
 2034cd8:	10c003c3 	ldbu	r3,15(r2)
 2034cdc:	00808174 	movhi	r2,517
 2034ce0:	10aaaf04 	addi	r2,r2,-21828
 2034ce4:	21001224 	muli	r4,r4,72
 2034ce8:	1105883a 	add	r2,r2,r4
 2034cec:	108003c4 	addi	r2,r2,15
 2034cf0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 2034cf4:	d0a80083 	ldbu	r2,-24574(gp)
 2034cf8:	11003fcc 	andi	r4,r2,255
 2034cfc:	2100201c 	xori	r4,r4,128
 2034d00:	213fe004 	addi	r4,r4,-128
 2034d04:	e0bffa17 	ldw	r2,-24(fp)
 2034d08:	10c00403 	ldbu	r3,16(r2)
 2034d0c:	00808174 	movhi	r2,517
 2034d10:	10aaaf04 	addi	r2,r2,-21828
 2034d14:	21001224 	muli	r4,r4,72
 2034d18:	1105883a 	add	r2,r2,r4
 2034d1c:	10800404 	addi	r2,r2,16
 2034d20:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 2034d24:	e0bff617 	ldw	r2,-40(fp)
 2034d28:	10000d1e 	bne	r2,zero,2034d60 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 2034d2c:	01008134 	movhi	r4,516
 2034d30:	211cbb04 	addi	r4,r4,29420
 2034d34:	20426cc0 	call	20426cc <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 2034d38:	d0a80083 	ldbu	r2,-24574(gp)
 2034d3c:	10803fcc 	andi	r2,r2,255
 2034d40:	1080201c 	xori	r2,r2,128
 2034d44:	10bfe004 	addi	r2,r2,-128
 2034d48:	100b883a 	mov	r5,r2
 2034d4c:	01008134 	movhi	r4,516
 2034d50:	211cc604 	addi	r4,r4,29464
 2034d54:	20009e40 	call	20009e4 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2034d58:	00bfffc4 	movi	r2,-1
 2034d5c:	00019206 	br	20353a8 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 2034d60:	d0a80083 	ldbu	r2,-24574(gp)
 2034d64:	14003fcc 	andi	r16,r2,255
 2034d68:	8400201c 	xori	r16,r16,128
 2034d6c:	843fe004 	addi	r16,r16,-128
 2034d70:	e0bff617 	ldw	r2,-40(fp)
 2034d74:	10800017 	ldw	r2,0(r2)
 2034d78:	1009883a 	mov	r4,r2
 2034d7c:	20073a40 	call	20073a4 <strlen>
 2034d80:	10800044 	addi	r2,r2,1
 2034d84:	1009883a 	mov	r4,r2
 2034d88:	20424000 	call	2042400 <malloc>
 2034d8c:	1009883a 	mov	r4,r2
 2034d90:	00808174 	movhi	r2,517
 2034d94:	10aaaf04 	addi	r2,r2,-21828
 2034d98:	80c01224 	muli	r3,r16,72
 2034d9c:	10c5883a 	add	r2,r2,r3
 2034da0:	10800504 	addi	r2,r2,20
 2034da4:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 2034da8:	d0a80083 	ldbu	r2,-24574(gp)
 2034dac:	10c03fcc 	andi	r3,r2,255
 2034db0:	18c0201c 	xori	r3,r3,128
 2034db4:	18ffe004 	addi	r3,r3,-128
 2034db8:	00808174 	movhi	r2,517
 2034dbc:	10aaaf04 	addi	r2,r2,-21828
 2034dc0:	18c01224 	muli	r3,r3,72
 2034dc4:	10c5883a 	add	r2,r2,r3
 2034dc8:	10800504 	addi	r2,r2,20
 2034dcc:	10800017 	ldw	r2,0(r2)
 2034dd0:	10000a1e 	bne	r2,zero,2034dfc <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 2034dd4:	d0a80083 	ldbu	r2,-24574(gp)
 2034dd8:	10803fcc 	andi	r2,r2,255
 2034ddc:	1080201c 	xori	r2,r2,128
 2034de0:	10bfe004 	addi	r2,r2,-128
 2034de4:	100b883a 	mov	r5,r2
 2034de8:	01008134 	movhi	r4,516
 2034dec:	211cde04 	addi	r4,r4,29560
 2034df0:	20009e40 	call	20009e4 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 2034df4:	00bfffc4 	movi	r2,-1
 2034df8:	00016b06 	br	20353a8 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 2034dfc:	d0a80083 	ldbu	r2,-24574(gp)
 2034e00:	10c03fcc 	andi	r3,r2,255
 2034e04:	18c0201c 	xori	r3,r3,128
 2034e08:	18ffe004 	addi	r3,r3,-128
 2034e0c:	00808174 	movhi	r2,517
 2034e10:	10aaaf04 	addi	r2,r2,-21828
 2034e14:	18c01224 	muli	r3,r3,72
 2034e18:	10c5883a 	add	r2,r2,r3
 2034e1c:	10800504 	addi	r2,r2,20
 2034e20:	10c00017 	ldw	r3,0(r2)
 2034e24:	e0bff617 	ldw	r2,-40(fp)
 2034e28:	10800017 	ldw	r2,0(r2)
 2034e2c:	100b883a 	mov	r5,r2
 2034e30:	1809883a 	mov	r4,r3
 2034e34:	204289c0 	call	204289c <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 2034e38:	d0a80083 	ldbu	r2,-24574(gp)
 2034e3c:	14003fcc 	andi	r16,r2,255
 2034e40:	8400201c 	xori	r16,r16,128
 2034e44:	843fe004 	addi	r16,r16,-128
 2034e48:	e0bff617 	ldw	r2,-40(fp)
 2034e4c:	10800117 	ldw	r2,4(r2)
 2034e50:	1009883a 	mov	r4,r2
 2034e54:	20073a40 	call	20073a4 <strlen>
 2034e58:	10800044 	addi	r2,r2,1
 2034e5c:	1009883a 	mov	r4,r2
 2034e60:	20424000 	call	2042400 <malloc>
 2034e64:	1009883a 	mov	r4,r2
 2034e68:	00808174 	movhi	r2,517
 2034e6c:	10aaaf04 	addi	r2,r2,-21828
 2034e70:	80c01224 	muli	r3,r16,72
 2034e74:	10c5883a 	add	r2,r2,r3
 2034e78:	10800604 	addi	r2,r2,24
 2034e7c:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 2034e80:	d0a80083 	ldbu	r2,-24574(gp)
 2034e84:	10c03fcc 	andi	r3,r2,255
 2034e88:	18c0201c 	xori	r3,r3,128
 2034e8c:	18ffe004 	addi	r3,r3,-128
 2034e90:	00808174 	movhi	r2,517
 2034e94:	10aaaf04 	addi	r2,r2,-21828
 2034e98:	18c01224 	muli	r3,r3,72
 2034e9c:	10c5883a 	add	r2,r2,r3
 2034ea0:	10800604 	addi	r2,r2,24
 2034ea4:	10800017 	ldw	r2,0(r2)
 2034ea8:	10000a1e 	bne	r2,zero,2034ed4 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 2034eac:	d0a80083 	ldbu	r2,-24574(gp)
 2034eb0:	10803fcc 	andi	r2,r2,255
 2034eb4:	1080201c 	xori	r2,r2,128
 2034eb8:	10bfe004 	addi	r2,r2,-128
 2034ebc:	100b883a 	mov	r5,r2
 2034ec0:	01008134 	movhi	r4,516
 2034ec4:	211cf104 	addi	r4,r4,29636
 2034ec8:	20009e40 	call	20009e4 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 2034ecc:	00bfffc4 	movi	r2,-1
 2034ed0:	00013506 	br	20353a8 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 2034ed4:	d0a80083 	ldbu	r2,-24574(gp)
 2034ed8:	10c03fcc 	andi	r3,r2,255
 2034edc:	18c0201c 	xori	r3,r3,128
 2034ee0:	18ffe004 	addi	r3,r3,-128
 2034ee4:	00808174 	movhi	r2,517
 2034ee8:	10aaaf04 	addi	r2,r2,-21828
 2034eec:	18c01224 	muli	r3,r3,72
 2034ef0:	10c5883a 	add	r2,r2,r3
 2034ef4:	10800604 	addi	r2,r2,24
 2034ef8:	10c00017 	ldw	r3,0(r2)
 2034efc:	e0bff617 	ldw	r2,-40(fp)
 2034f00:	10800117 	ldw	r2,4(r2)
 2034f04:	100b883a 	mov	r5,r2
 2034f08:	1809883a 	mov	r4,r3
 2034f0c:	204289c0 	call	204289c <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 2034f10:	d0a80083 	ldbu	r2,-24574(gp)
 2034f14:	11003fcc 	andi	r4,r2,255
 2034f18:	2100201c 	xori	r4,r4,128
 2034f1c:	213fe004 	addi	r4,r4,-128
 2034f20:	e0bff617 	ldw	r2,-40(fp)
 2034f24:	10c0020b 	ldhu	r3,8(r2)
 2034f28:	00808174 	movhi	r2,517
 2034f2c:	10aaaf04 	addi	r2,r2,-21828
 2034f30:	21001224 	muli	r4,r4,72
 2034f34:	1105883a 	add	r2,r2,r4
 2034f38:	10800704 	addi	r2,r2,28
 2034f3c:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 2034f40:	e0bff717 	ldw	r2,-36(fp)
 2034f44:	1000151e 	bne	r2,zero,2034f9c <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 2034f48:	d0a80083 	ldbu	r2,-24574(gp)
 2034f4c:	10c03fcc 	andi	r3,r2,255
 2034f50:	18c0201c 	xori	r3,r3,128
 2034f54:	18ffe004 	addi	r3,r3,-128
 2034f58:	00808174 	movhi	r2,517
 2034f5c:	10aaaf04 	addi	r2,r2,-21828
 2034f60:	18c01224 	muli	r3,r3,72
 2034f64:	10c5883a 	add	r2,r2,r3
 2034f68:	10800784 	addi	r2,r2,30
 2034f6c:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 2034f70:	d0a80083 	ldbu	r2,-24574(gp)
 2034f74:	10c03fcc 	andi	r3,r2,255
 2034f78:	18c0201c 	xori	r3,r3,128
 2034f7c:	18ffe004 	addi	r3,r3,-128
 2034f80:	00808174 	movhi	r2,517
 2034f84:	10aaaf04 	addi	r2,r2,-21828
 2034f88:	18c01224 	muli	r3,r3,72
 2034f8c:	10c5883a 	add	r2,r2,r3
 2034f90:	10800804 	addi	r2,r2,32
 2034f94:	10000015 	stw	zero,0(r2)
 2034f98:	00001806 	br	2034ffc <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 2034f9c:	d0a80083 	ldbu	r2,-24574(gp)
 2034fa0:	11003fcc 	andi	r4,r2,255
 2034fa4:	2100201c 	xori	r4,r4,128
 2034fa8:	213fe004 	addi	r4,r4,-128
 2034fac:	e0bff717 	ldw	r2,-36(fp)
 2034fb0:	10c00003 	ldbu	r3,0(r2)
 2034fb4:	00808174 	movhi	r2,517
 2034fb8:	10aaaf04 	addi	r2,r2,-21828
 2034fbc:	21001224 	muli	r4,r4,72
 2034fc0:	1105883a 	add	r2,r2,r4
 2034fc4:	10800784 	addi	r2,r2,30
 2034fc8:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 2034fcc:	d0a80083 	ldbu	r2,-24574(gp)
 2034fd0:	11003fcc 	andi	r4,r2,255
 2034fd4:	2100201c 	xori	r4,r4,128
 2034fd8:	213fe004 	addi	r4,r4,-128
 2034fdc:	e0bff717 	ldw	r2,-36(fp)
 2034fe0:	10c00117 	ldw	r3,4(r2)
 2034fe4:	00808174 	movhi	r2,517
 2034fe8:	10aaaf04 	addi	r2,r2,-21828
 2034fec:	21001224 	muli	r4,r4,72
 2034ff0:	1105883a 	add	r2,r2,r4
 2034ff4:	10800804 	addi	r2,r2,32
 2034ff8:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 2034ffc:	e0bff817 	ldw	r2,-32(fp)
 2035000:	1000471e 	bne	r2,zero,2035120 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 2035004:	d0a80083 	ldbu	r2,-24574(gp)
 2035008:	10c03fcc 	andi	r3,r2,255
 203500c:	18c0201c 	xori	r3,r3,128
 2035010:	18ffe004 	addi	r3,r3,-128
 2035014:	00808174 	movhi	r2,517
 2035018:	10aaaf04 	addi	r2,r2,-21828
 203501c:	18c01224 	muli	r3,r3,72
 2035020:	10c5883a 	add	r2,r2,r3
 2035024:	10800904 	addi	r2,r2,36
 2035028:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 203502c:	d0a80083 	ldbu	r2,-24574(gp)
 2035030:	10c03fcc 	andi	r3,r2,255
 2035034:	18c0201c 	xori	r3,r3,128
 2035038:	18ffe004 	addi	r3,r3,-128
 203503c:	00808174 	movhi	r2,517
 2035040:	10aaaf04 	addi	r2,r2,-21828
 2035044:	18c01224 	muli	r3,r3,72
 2035048:	10c5883a 	add	r2,r2,r3
 203504c:	10800a04 	addi	r2,r2,40
 2035050:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 2035054:	d0a80083 	ldbu	r2,-24574(gp)
 2035058:	10c03fcc 	andi	r3,r2,255
 203505c:	18c0201c 	xori	r3,r3,128
 2035060:	18ffe004 	addi	r3,r3,-128
 2035064:	00808174 	movhi	r2,517
 2035068:	10aaaf04 	addi	r2,r2,-21828
 203506c:	18c01224 	muli	r3,r3,72
 2035070:	10c5883a 	add	r2,r2,r3
 2035074:	10800b04 	addi	r2,r2,44
 2035078:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 203507c:	d0a80083 	ldbu	r2,-24574(gp)
 2035080:	10c03fcc 	andi	r3,r2,255
 2035084:	18c0201c 	xori	r3,r3,128
 2035088:	18ffe004 	addi	r3,r3,-128
 203508c:	00808174 	movhi	r2,517
 2035090:	10aaaf04 	addi	r2,r2,-21828
 2035094:	18c01224 	muli	r3,r3,72
 2035098:	10c5883a 	add	r2,r2,r3
 203509c:	10800c04 	addi	r2,r2,48
 20350a0:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 20350a4:	d0a80083 	ldbu	r2,-24574(gp)
 20350a8:	10c03fcc 	andi	r3,r2,255
 20350ac:	18c0201c 	xori	r3,r3,128
 20350b0:	18ffe004 	addi	r3,r3,-128
 20350b4:	00808174 	movhi	r2,517
 20350b8:	10aaaf04 	addi	r2,r2,-21828
 20350bc:	18c01224 	muli	r3,r3,72
 20350c0:	10c5883a 	add	r2,r2,r3
 20350c4:	10800d04 	addi	r2,r2,52
 20350c8:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 20350cc:	d0a80083 	ldbu	r2,-24574(gp)
 20350d0:	10c03fcc 	andi	r3,r2,255
 20350d4:	18c0201c 	xori	r3,r3,128
 20350d8:	18ffe004 	addi	r3,r3,-128
 20350dc:	00808174 	movhi	r2,517
 20350e0:	10aaaf04 	addi	r2,r2,-21828
 20350e4:	18c01224 	muli	r3,r3,72
 20350e8:	10c5883a 	add	r2,r2,r3
 20350ec:	10800e04 	addi	r2,r2,56
 20350f0:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 20350f4:	d0a80083 	ldbu	r2,-24574(gp)
 20350f8:	10c03fcc 	andi	r3,r2,255
 20350fc:	18c0201c 	xori	r3,r3,128
 2035100:	18ffe004 	addi	r3,r3,-128
 2035104:	00808174 	movhi	r2,517
 2035108:	10aaaf04 	addi	r2,r2,-21828
 203510c:	18c01224 	muli	r3,r3,72
 2035110:	10c5883a 	add	r2,r2,r3
 2035114:	10800f04 	addi	r2,r2,60
 2035118:	10000015 	stw	zero,0(r2)
 203511c:	00005406 	br	2035270 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 2035120:	d0a80083 	ldbu	r2,-24574(gp)
 2035124:	11003fcc 	andi	r4,r2,255
 2035128:	2100201c 	xori	r4,r4,128
 203512c:	213fe004 	addi	r4,r4,-128
 2035130:	e0bff817 	ldw	r2,-32(fp)
 2035134:	10c00003 	ldbu	r3,0(r2)
 2035138:	00808174 	movhi	r2,517
 203513c:	10aaaf04 	addi	r2,r2,-21828
 2035140:	21001224 	muli	r4,r4,72
 2035144:	1105883a 	add	r2,r2,r4
 2035148:	10800904 	addi	r2,r2,36
 203514c:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 2035150:	d0a80083 	ldbu	r2,-24574(gp)
 2035154:	11003fcc 	andi	r4,r2,255
 2035158:	2100201c 	xori	r4,r4,128
 203515c:	213fe004 	addi	r4,r4,-128
 2035160:	e0bff817 	ldw	r2,-32(fp)
 2035164:	10c00117 	ldw	r3,4(r2)
 2035168:	00808174 	movhi	r2,517
 203516c:	10aaaf04 	addi	r2,r2,-21828
 2035170:	21001224 	muli	r4,r4,72
 2035174:	1105883a 	add	r2,r2,r4
 2035178:	10800a04 	addi	r2,r2,40
 203517c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 2035180:	d0a80083 	ldbu	r2,-24574(gp)
 2035184:	11003fcc 	andi	r4,r2,255
 2035188:	2100201c 	xori	r4,r4,128
 203518c:	213fe004 	addi	r4,r4,-128
 2035190:	e0bff817 	ldw	r2,-32(fp)
 2035194:	10c00217 	ldw	r3,8(r2)
 2035198:	00808174 	movhi	r2,517
 203519c:	10aaaf04 	addi	r2,r2,-21828
 20351a0:	21001224 	muli	r4,r4,72
 20351a4:	1105883a 	add	r2,r2,r4
 20351a8:	10800b04 	addi	r2,r2,44
 20351ac:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 20351b0:	d0a80083 	ldbu	r2,-24574(gp)
 20351b4:	11003fcc 	andi	r4,r2,255
 20351b8:	2100201c 	xori	r4,r4,128
 20351bc:	213fe004 	addi	r4,r4,-128
 20351c0:	e0bff817 	ldw	r2,-32(fp)
 20351c4:	10c00317 	ldw	r3,12(r2)
 20351c8:	00808174 	movhi	r2,517
 20351cc:	10aaaf04 	addi	r2,r2,-21828
 20351d0:	21001224 	muli	r4,r4,72
 20351d4:	1105883a 	add	r2,r2,r4
 20351d8:	10800c04 	addi	r2,r2,48
 20351dc:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 20351e0:	d0a80083 	ldbu	r2,-24574(gp)
 20351e4:	11003fcc 	andi	r4,r2,255
 20351e8:	2100201c 	xori	r4,r4,128
 20351ec:	213fe004 	addi	r4,r4,-128
 20351f0:	e0bff817 	ldw	r2,-32(fp)
 20351f4:	10c00417 	ldw	r3,16(r2)
 20351f8:	00808174 	movhi	r2,517
 20351fc:	10aaaf04 	addi	r2,r2,-21828
 2035200:	21001224 	muli	r4,r4,72
 2035204:	1105883a 	add	r2,r2,r4
 2035208:	10800d04 	addi	r2,r2,52
 203520c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 2035210:	d0a80083 	ldbu	r2,-24574(gp)
 2035214:	11003fcc 	andi	r4,r2,255
 2035218:	2100201c 	xori	r4,r4,128
 203521c:	213fe004 	addi	r4,r4,-128
 2035220:	e0bff817 	ldw	r2,-32(fp)
 2035224:	10c00517 	ldw	r3,20(r2)
 2035228:	00808174 	movhi	r2,517
 203522c:	10aaaf04 	addi	r2,r2,-21828
 2035230:	21001224 	muli	r4,r4,72
 2035234:	1105883a 	add	r2,r2,r4
 2035238:	10800e04 	addi	r2,r2,56
 203523c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 2035240:	d0a80083 	ldbu	r2,-24574(gp)
 2035244:	11003fcc 	andi	r4,r2,255
 2035248:	2100201c 	xori	r4,r4,128
 203524c:	213fe004 	addi	r4,r4,-128
 2035250:	e0bff817 	ldw	r2,-32(fp)
 2035254:	10c00617 	ldw	r3,24(r2)
 2035258:	00808174 	movhi	r2,517
 203525c:	10aaaf04 	addi	r2,r2,-21828
 2035260:	21001224 	muli	r4,r4,72
 2035264:	1105883a 	add	r2,r2,r4
 2035268:	10800f04 	addi	r2,r2,60
 203526c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 2035270:	e0bff917 	ldw	r2,-28(fp)
 2035274:	1000161e 	bne	r2,zero,20352d0 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 2035278:	d0a80083 	ldbu	r2,-24574(gp)
 203527c:	10c03fcc 	andi	r3,r2,255
 2035280:	18c0201c 	xori	r3,r3,128
 2035284:	18ffe004 	addi	r3,r3,-128
 2035288:	00808174 	movhi	r2,517
 203528c:	10aaaf04 	addi	r2,r2,-21828
 2035290:	18c01224 	muli	r3,r3,72
 2035294:	10c5883a 	add	r2,r2,r3
 2035298:	10801004 	addi	r2,r2,64
 203529c:	00ffffc4 	movi	r3,-1
 20352a0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 20352a4:	d0a80083 	ldbu	r2,-24574(gp)
 20352a8:	10c03fcc 	andi	r3,r2,255
 20352ac:	18c0201c 	xori	r3,r3,128
 20352b0:	18ffe004 	addi	r3,r3,-128
 20352b4:	00808174 	movhi	r2,517
 20352b8:	10aaaf04 	addi	r2,r2,-21828
 20352bc:	18c01224 	muli	r3,r3,72
 20352c0:	10c5883a 	add	r2,r2,r3
 20352c4:	10801104 	addi	r2,r2,68
 20352c8:	10000015 	stw	zero,0(r2)
 20352cc:	00001806 	br	2035330 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 20352d0:	d0a80083 	ldbu	r2,-24574(gp)
 20352d4:	11003fcc 	andi	r4,r2,255
 20352d8:	2100201c 	xori	r4,r4,128
 20352dc:	213fe004 	addi	r4,r4,-128
 20352e0:	e0bff917 	ldw	r2,-28(fp)
 20352e4:	10c00017 	ldw	r3,0(r2)
 20352e8:	00808174 	movhi	r2,517
 20352ec:	10aaaf04 	addi	r2,r2,-21828
 20352f0:	21001224 	muli	r4,r4,72
 20352f4:	1105883a 	add	r2,r2,r4
 20352f8:	10801004 	addi	r2,r2,64
 20352fc:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 2035300:	d0a80083 	ldbu	r2,-24574(gp)
 2035304:	11003fcc 	andi	r4,r2,255
 2035308:	2100201c 	xori	r4,r4,128
 203530c:	213fe004 	addi	r4,r4,-128
 2035310:	e0bff917 	ldw	r2,-28(fp)
 2035314:	10c00117 	ldw	r3,4(r2)
 2035318:	00808174 	movhi	r2,517
 203531c:	10aaaf04 	addi	r2,r2,-21828
 2035320:	21001224 	muli	r4,r4,72
 2035324:	1105883a 	add	r2,r2,r4
 2035328:	10801104 	addi	r2,r2,68
 203532c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 2035330:	e0bff617 	ldw	r2,-40(fp)
 2035334:	10800304 	addi	r2,r2,12
 2035338:	e0bff615 	stw	r2,-40(fp)
		if(pmem) pmem++;
 203533c:	e0bff717 	ldw	r2,-36(fp)
 2035340:	10000326 	beq	r2,zero,2035350 <alt_tse_system_add_sys+0x98c>
 2035344:	e0bff717 	ldw	r2,-36(fp)
 2035348:	10800204 	addi	r2,r2,8
 203534c:	e0bff715 	stw	r2,-36(fp)
		if(pfifo) pfifo++;
 2035350:	e0bff817 	ldw	r2,-32(fp)
 2035354:	10000326 	beq	r2,zero,2035364 <alt_tse_system_add_sys+0x9a0>
 2035358:	e0bff817 	ldw	r2,-32(fp)
 203535c:	10800704 	addi	r2,r2,28
 2035360:	e0bff815 	stw	r2,-32(fp)
		if(pphy) pphy++;
 2035364:	e0bff917 	ldw	r2,-28(fp)
 2035368:	10000326 	beq	r2,zero,2035378 <alt_tse_system_add_sys+0x9b4>
 203536c:	e0bff917 	ldw	r2,-28(fp)
 2035370:	10800204 	addi	r2,r2,8
 2035374:	e0bff915 	stw	r2,-28(fp)
		
		tse_system_count++;
 2035378:	d0a80083 	ldbu	r2,-24574(gp)
 203537c:	10800044 	addi	r2,r2,1
 2035380:	d0a80085 	stb	r2,-24574(gp)
		max_mac_system = tse_system_count;
 2035384:	d0a80083 	ldbu	r2,-24574(gp)
 2035388:	d0a01f05 	stb	r2,-32644(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 203538c:	e0bff417 	ldw	r2,-48(fp)
 2035390:	10800044 	addi	r2,r2,1
 2035394:	e0bff415 	stw	r2,-48(fp)
 2035398:	e0fff417 	ldw	r3,-48(fp)
 203539c:	e0bff517 	ldw	r2,-44(fp)
 20353a0:	18bdb216 	blt	r3,r2,2034a6c <__alt_mem_mem_0+0xfd014a6c>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 20353a4:	0005883a 	mov	r2,zero
	
}
 20353a8:	e6ffff04 	addi	sp,fp,-4
 20353ac:	dfc00217 	ldw	ra,8(sp)
 20353b0:	df000117 	ldw	fp,4(sp)
 20353b4:	dc000017 	ldw	r16,0(sp)
 20353b8:	dec00304 	addi	sp,sp,12
 20353bc:	f800283a 	ret

020353c0 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 20353c0:	defff904 	addi	sp,sp,-28
 20353c4:	dfc00615 	stw	ra,24(sp)
 20353c8:	df000515 	stw	fp,20(sp)
 20353cc:	df000504 	addi	fp,sp,20
 20353d0:	e13ffe15 	stw	r4,-8(fp)
 20353d4:	2805883a 	mov	r2,r5
 20353d8:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 20353dc:	e03ffb15 	stw	zero,-20(fp)
 20353e0:	00004806 	br	2035504 <alt_tse_sys_enable_mdio_sharing+0x144>
		psys_mac = psys_mac_list[i];
 20353e4:	e0bffb17 	ldw	r2,-20(fp)
 20353e8:	1085883a 	add	r2,r2,r2
 20353ec:	1085883a 	add	r2,r2,r2
 20353f0:	1007883a 	mov	r3,r2
 20353f4:	e0bffe17 	ldw	r2,-8(fp)
 20353f8:	10c5883a 	add	r2,r2,r3
 20353fc:	10800017 	ldw	r2,0(r2)
 2035400:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 2035404:	e0bffd17 	ldw	r2,-12(fp)
 2035408:	1000081e 	bne	r2,zero,203542c <alt_tse_sys_enable_mdio_sharing+0x6c>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 203540c:	01008134 	movhi	r4,516
 2035410:	211c9f04 	addi	r4,r4,29308
 2035414:	20426cc0 	call	20426cc <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 2035418:	01008134 	movhi	r4,516
 203541c:	211d0404 	addi	r4,r4,29712
 2035420:	20426cc0 	call	20426cc <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2035424:	00bfffc4 	movi	r2,-1
 2035428:	00003a06 	br	2035514 <alt_tse_sys_enable_mdio_sharing+0x154>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 203542c:	e03ffc15 	stw	zero,-16(fp)
 2035430:	00002d06 	br	20354e8 <alt_tse_sys_enable_mdio_sharing+0x128>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 2035434:	e0bffd17 	ldw	r2,-12(fp)
 2035438:	10c00017 	ldw	r3,0(r2)
 203543c:	00808174 	movhi	r2,517
 2035440:	10aaaf04 	addi	r2,r2,-21828
 2035444:	e13ffc17 	ldw	r4,-16(fp)
 2035448:	21001224 	muli	r4,r4,72
 203544c:	1105883a 	add	r2,r2,r4
 2035450:	10800017 	ldw	r2,0(r2)
 2035454:	1880211e 	bne	r3,r2,20354dc <alt_tse_sys_enable_mdio_sharing+0x11c>
				if(tse_mac_device[j].tse_multichannel_mac) {
 2035458:	00808174 	movhi	r2,517
 203545c:	10aaaf04 	addi	r2,r2,-21828
 2035460:	e0fffc17 	ldw	r3,-16(fp)
 2035464:	18c01224 	muli	r3,r3,72
 2035468:	10c5883a 	add	r2,r2,r3
 203546c:	108002c4 	addi	r2,r2,11
 2035470:	10800003 	ldbu	r2,0(r2)
 2035474:	10803fcc 	andi	r2,r2,255
 2035478:	10000826 	beq	r2,zero,203549c <alt_tse_sys_enable_mdio_sharing+0xdc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 203547c:	01008134 	movhi	r4,516
 2035480:	211d1804 	addi	r4,r4,29792
 2035484:	20426cc0 	call	20426cc <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 2035488:	01008134 	movhi	r4,516
 203548c:	211d2904 	addi	r4,r4,29860
 2035490:	20426cc0 	call	20426cc <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2035494:	00bfffc4 	movi	r2,-1
 2035498:	00001e06 	br	2035514 <alt_tse_sys_enable_mdio_sharing+0x154>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 203549c:	00808174 	movhi	r2,517
 20354a0:	10aaaf04 	addi	r2,r2,-21828
 20354a4:	e0fffc17 	ldw	r3,-16(fp)
 20354a8:	18c01224 	muli	r3,r3,72
 20354ac:	10c5883a 	add	r2,r2,r3
 20354b0:	10800344 	addi	r2,r2,13
 20354b4:	00c00044 	movi	r3,1
 20354b8:	10c00005 	stb	r3,0(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 20354bc:	00808174 	movhi	r2,517
 20354c0:	10aaaf04 	addi	r2,r2,-21828
 20354c4:	e0fffc17 	ldw	r3,-16(fp)
 20354c8:	18c01224 	muli	r3,r3,72
 20354cc:	10c5883a 	add	r2,r2,r3
 20354d0:	10800384 	addi	r2,r2,14
 20354d4:	e0ffff03 	ldbu	r3,-4(fp)
 20354d8:	10c00005 	stb	r3,0(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 20354dc:	e0bffc17 	ldw	r2,-16(fp)
 20354e0:	10800044 	addi	r2,r2,1
 20354e4:	e0bffc15 	stw	r2,-16(fp)
 20354e8:	d0a01f03 	ldbu	r2,-32644(gp)
 20354ec:	10803fcc 	andi	r2,r2,255
 20354f0:	e0fffc17 	ldw	r3,-16(fp)
 20354f4:	18bfcf16 	blt	r3,r2,2035434 <__alt_mem_mem_0+0xfd015434>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 20354f8:	e0bffb17 	ldw	r2,-20(fp)
 20354fc:	10800044 	addi	r2,r2,1
 2035500:	e0bffb15 	stw	r2,-20(fp)
 2035504:	e0bfff03 	ldbu	r2,-4(fp)
 2035508:	e0fffb17 	ldw	r3,-20(fp)
 203550c:	18bfb516 	blt	r3,r2,20353e4 <__alt_mem_mem_0+0xfd0153e4>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 2035510:	0005883a 	mov	r2,zero
}
 2035514:	e037883a 	mov	sp,fp
 2035518:	dfc00117 	ldw	ra,4(sp)
 203551c:	df000017 	ldw	fp,0(sp)
 2035520:	dec00204 	addi	sp,sp,8
 2035524:	f800283a 	ret

02035528 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 2035528:	defffc04 	addi	sp,sp,-16
 203552c:	dfc00315 	stw	ra,12(sp)
 2035530:	df000215 	stw	fp,8(sp)
 2035534:	df000204 	addi	fp,sp,8
 2035538:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 203553c:	e13fff17 	ldw	r4,-4(fp)
 2035540:	20357100 	call	2035710 <alt_tse_get_mac_info>
 2035544:	10800317 	ldw	r2,12(r2)
 2035548:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 203554c:	e13ffe17 	ldw	r4,-8(fp)
 2035550:	20388d00 	call	20388d0 <alt_tse_phy_get_common_speed>
}
 2035554:	e037883a 	mov	sp,fp
 2035558:	dfc00117 	ldw	ra,4(sp)
 203555c:	df000017 	ldw	fp,0(sp)
 2035560:	dec00204 	addi	sp,sp,8
 2035564:	f800283a 	ret

02035568 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 2035568:	defffb04 	addi	sp,sp,-20
 203556c:	dfc00415 	stw	ra,16(sp)
 2035570:	df000315 	stw	fp,12(sp)
 2035574:	df000304 	addi	fp,sp,12
 2035578:	e13ffe15 	stw	r4,-8(fp)
 203557c:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 2035580:	e13ffe17 	ldw	r4,-8(fp)
 2035584:	20357100 	call	2035710 <alt_tse_get_mac_info>
 2035588:	10800317 	ldw	r2,12(r2)
 203558c:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 2035590:	e17fff17 	ldw	r5,-4(fp)
 2035594:	e13ffd17 	ldw	r4,-12(fp)
 2035598:	2038bf80 	call	2038bf8 <alt_tse_phy_set_common_speed>
}
 203559c:	e037883a 	mov	sp,fp
 20355a0:	dfc00117 	ldw	ra,4(sp)
 20355a4:	df000017 	ldw	fp,0(sp)
 20355a8:	dec00204 	addi	sp,sp,8
 20355ac:	f800283a 	ret

020355b0 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 20355b0:	defffd04 	addi	sp,sp,-12
 20355b4:	df000215 	stw	fp,8(sp)
 20355b8:	df000204 	addi	fp,sp,8
 20355bc:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 20355c0:	e03ffe15 	stw	zero,-8(fp)
 20355c4:	00000c06 	br	20355f8 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 20355c8:	e0bffe17 	ldw	r2,-8(fp)
 20355cc:	10c01224 	muli	r3,r2,72
 20355d0:	00808174 	movhi	r2,517
 20355d4:	10aaaf04 	addi	r2,r2,-21828
 20355d8:	1887883a 	add	r3,r3,r2
 20355dc:	e0bfff17 	ldw	r2,-4(fp)
 20355e0:	1880021e 	bne	r3,r2,20355ec <alt_tse_get_system_index+0x3c>
            return i;
 20355e4:	e0bffe17 	ldw	r2,-8(fp)
 20355e8:	00000806 	br	203560c <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 20355ec:	e0bffe17 	ldw	r2,-8(fp)
 20355f0:	10800044 	addi	r2,r2,1
 20355f4:	e0bffe15 	stw	r2,-8(fp)
 20355f8:	d0a01f03 	ldbu	r2,-32644(gp)
 20355fc:	10803fcc 	andi	r2,r2,255
 2035600:	e0fffe17 	ldw	r3,-8(fp)
 2035604:	18bff016 	blt	r3,r2,20355c8 <__alt_mem_mem_0+0xfd0155c8>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 2035608:	00bfffc4 	movi	r2,-1
}
 203560c:	e037883a 	mov	sp,fp
 2035610:	df000017 	ldw	fp,0(sp)
 2035614:	dec00104 	addi	sp,sp,4
 2035618:	f800283a 	ret

0203561c <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 203561c:	defffd04 	addi	sp,sp,-12
 2035620:	df000215 	stw	fp,8(sp)
 2035624:	df000204 	addi	fp,sp,8
 2035628:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 203562c:	e03ffe15 	stw	zero,-8(fp)
 2035630:	00000e06 	br	203566c <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 2035634:	008085f4 	movhi	r2,535
 2035638:	10be3204 	addi	r2,r2,-1848
 203563c:	e0fffe17 	ldw	r3,-8(fp)
 2035640:	18c7883a 	add	r3,r3,r3
 2035644:	18c7883a 	add	r3,r3,r3
 2035648:	10c5883a 	add	r2,r2,r3
 203564c:	10c00017 	ldw	r3,0(r2)
 2035650:	e0bfff17 	ldw	r2,-4(fp)
 2035654:	1880021e 	bne	r3,r2,2035660 <alt_tse_get_mac_group_index+0x44>
            return i;
 2035658:	e0bffe17 	ldw	r2,-8(fp)
 203565c:	00000806 	br	2035680 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 2035660:	e0bffe17 	ldw	r2,-8(fp)
 2035664:	10800044 	addi	r2,r2,1
 2035668:	e0bffe15 	stw	r2,-8(fp)
 203566c:	d0a80043 	ldbu	r2,-24575(gp)
 2035670:	10803fcc 	andi	r2,r2,255
 2035674:	e0fffe17 	ldw	r3,-8(fp)
 2035678:	18bfee16 	blt	r3,r2,2035634 <__alt_mem_mem_0+0xfd015634>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 203567c:	00bfffc4 	movi	r2,-1
}
 2035680:	e037883a 	mov	sp,fp
 2035684:	df000017 	ldw	fp,0(sp)
 2035688:	dec00104 	addi	sp,sp,4
 203568c:	f800283a 	ret

02035690 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 2035690:	defffd04 	addi	sp,sp,-12
 2035694:	df000215 	stw	fp,8(sp)
 2035698:	df000204 	addi	fp,sp,8
 203569c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 20356a0:	e03ffe15 	stw	zero,-8(fp)
 20356a4:	00000f06 	br	20356e4 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 20356a8:	e0bfff17 	ldw	r2,-4(fp)
 20356ac:	10c00317 	ldw	r3,12(r2)
 20356b0:	e0bffe17 	ldw	r2,-8(fp)
 20356b4:	10800044 	addi	r2,r2,1
 20356b8:	1085883a 	add	r2,r2,r2
 20356bc:	1085883a 	add	r2,r2,r2
 20356c0:	1885883a 	add	r2,r3,r2
 20356c4:	10c00017 	ldw	r3,0(r2)
 20356c8:	e0bfff17 	ldw	r2,-4(fp)
 20356cc:	1880021e 	bne	r3,r2,20356d8 <alt_tse_get_mac_info_index+0x48>
            return i;
 20356d0:	e0bffe17 	ldw	r2,-8(fp)
 20356d4:	00000a06 	br	2035700 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 20356d8:	e0bffe17 	ldw	r2,-8(fp)
 20356dc:	10800044 	addi	r2,r2,1
 20356e0:	e0bffe15 	stw	r2,-8(fp)
 20356e4:	e0bfff17 	ldw	r2,-4(fp)
 20356e8:	10800317 	ldw	r2,12(r2)
 20356ec:	10800003 	ldbu	r2,0(r2)
 20356f0:	10803fcc 	andi	r2,r2,255
 20356f4:	e0fffe17 	ldw	r3,-8(fp)
 20356f8:	18bfeb16 	blt	r3,r2,20356a8 <__alt_mem_mem_0+0xfd0156a8>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 20356fc:	00bfffc4 	movi	r2,-1
}
 2035700:	e037883a 	mov	sp,fp
 2035704:	df000017 	ldw	fp,0(sp)
 2035708:	dec00104 	addi	sp,sp,4
 203570c:	f800283a 	ret

02035710 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 2035710:	defffa04 	addi	sp,sp,-24
 2035714:	df000515 	stw	fp,20(sp)
 2035718:	df000504 	addi	fp,sp,20
 203571c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 2035720:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 2035724:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 2035728:	e03ffb15 	stw	zero,-20(fp)
 203572c:	00002506 	br	20357c4 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 2035730:	008085f4 	movhi	r2,535
 2035734:	10be3204 	addi	r2,r2,-1848
 2035738:	e0fffb17 	ldw	r3,-20(fp)
 203573c:	18c7883a 	add	r3,r3,r3
 2035740:	18c7883a 	add	r3,r3,r3
 2035744:	10c5883a 	add	r2,r2,r3
 2035748:	10800017 	ldw	r2,0(r2)
 203574c:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 2035750:	e03ffc15 	stw	zero,-16(fp)
 2035754:	00001306 	br	20357a4 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 2035758:	e0fffd17 	ldw	r3,-12(fp)
 203575c:	e0bffc17 	ldw	r2,-16(fp)
 2035760:	10800044 	addi	r2,r2,1
 2035764:	1085883a 	add	r2,r2,r2
 2035768:	1085883a 	add	r2,r2,r2
 203576c:	1885883a 	add	r2,r3,r2
 2035770:	10800017 	ldw	r2,0(r2)
 2035774:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 2035778:	e0bffe17 	ldw	r2,-8(fp)
 203577c:	10800217 	ldw	r2,8(r2)
 2035780:	10800017 	ldw	r2,0(r2)
 2035784:	1007883a 	mov	r3,r2
 2035788:	e0bfff17 	ldw	r2,-4(fp)
 203578c:	1880021e 	bne	r3,r2,2035798 <alt_tse_get_mac_info+0x88>
                return pmac_info;
 2035790:	e0bffe17 	ldw	r2,-8(fp)
 2035794:	00001006 	br	20357d8 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 2035798:	e0bffc17 	ldw	r2,-16(fp)
 203579c:	10800044 	addi	r2,r2,1
 20357a0:	e0bffc15 	stw	r2,-16(fp)
 20357a4:	e0bffd17 	ldw	r2,-12(fp)
 20357a8:	10800003 	ldbu	r2,0(r2)
 20357ac:	10803fcc 	andi	r2,r2,255
 20357b0:	e0fffc17 	ldw	r3,-16(fp)
 20357b4:	18bfe816 	blt	r3,r2,2035758 <__alt_mem_mem_0+0xfd015758>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 20357b8:	e0bffb17 	ldw	r2,-20(fp)
 20357bc:	10800044 	addi	r2,r2,1
 20357c0:	e0bffb15 	stw	r2,-20(fp)
 20357c4:	d0a80043 	ldbu	r2,-24575(gp)
 20357c8:	10803fcc 	andi	r2,r2,255
 20357cc:	e0fffb17 	ldw	r3,-20(fp)
 20357d0:	18bfd716 	blt	r3,r2,2035730 <__alt_mem_mem_0+0xfd015730>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 20357d4:	0005883a 	mov	r2,zero
}
 20357d8:	e037883a 	mov	sp,fp
 20357dc:	df000017 	ldw	fp,0(sp)
 20357e0:	dec00104 	addi	sp,sp,4
 20357e4:	f800283a 	ret

020357e8 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 20357e8:	defffc04 	addi	sp,sp,-16
 20357ec:	df000315 	stw	fp,12(sp)
 20357f0:	df000304 	addi	fp,sp,12
 20357f4:	e13ffe15 	stw	r4,-8(fp)
 20357f8:	2805883a 	mov	r2,r5
 20357fc:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 2035800:	e0bffe17 	ldw	r2,-8(fp)
 2035804:	10800204 	addi	r2,r2,8
 2035808:	10800037 	ldwio	r2,0(r2)
 203580c:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 2035810:	e0bfff03 	ldbu	r2,-4(fp)
 2035814:	10800098 	cmpnei	r2,r2,2
 2035818:	1000091e 	bne	r2,zero,2035840 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 203581c:	e0bffd17 	ldw	r2,-12(fp)
 2035820:	10800214 	ori	r2,r2,8
 2035824:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2035828:	e0fffd17 	ldw	r3,-12(fp)
 203582c:	00bf8034 	movhi	r2,65024
 2035830:	10bfffc4 	addi	r2,r2,-1
 2035834:	1884703a 	and	r2,r3,r2
 2035838:	e0bffd15 	stw	r2,-12(fp)
 203583c:	00001906 	br	20358a4 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 2035840:	e0bfff03 	ldbu	r2,-4(fp)
 2035844:	10800058 	cmpnei	r2,r2,1
 2035848:	10000a1e 	bne	r2,zero,2035874 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 203584c:	e0fffd17 	ldw	r3,-12(fp)
 2035850:	00bffdc4 	movi	r2,-9
 2035854:	1884703a 	and	r2,r3,r2
 2035858:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 203585c:	e0fffd17 	ldw	r3,-12(fp)
 2035860:	00bf8034 	movhi	r2,65024
 2035864:	10bfffc4 	addi	r2,r2,-1
 2035868:	1884703a 	and	r2,r3,r2
 203586c:	e0bffd15 	stw	r2,-12(fp)
 2035870:	00000c06 	br	20358a4 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 2035874:	e0bfff03 	ldbu	r2,-4(fp)
 2035878:	1000081e 	bne	r2,zero,203589c <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 203587c:	e0fffd17 	ldw	r3,-12(fp)
 2035880:	00bffdc4 	movi	r2,-9
 2035884:	1884703a 	and	r2,r3,r2
 2035888:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 203588c:	e0bffd17 	ldw	r2,-12(fp)
 2035890:	10808034 	orhi	r2,r2,512
 2035894:	e0bffd15 	stw	r2,-12(fp)
 2035898:	00000206 	br	20358a4 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 203589c:	00bffd84 	movi	r2,-10
 20358a0:	00000506 	br	20358b8 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 20358a4:	e0bffe17 	ldw	r2,-8(fp)
 20358a8:	10800204 	addi	r2,r2,8
 20358ac:	e0fffd17 	ldw	r3,-12(fp)
 20358b0:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 20358b4:	0005883a 	mov	r2,zero
}
 20358b8:	e037883a 	mov	sp,fp
 20358bc:	df000017 	ldw	fp,0(sp)
 20358c0:	dec00104 	addi	sp,sp,4
 20358c4:	f800283a 	ret

020358c8 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 20358c8:	defffc04 	addi	sp,sp,-16
 20358cc:	df000315 	stw	fp,12(sp)
 20358d0:	df000304 	addi	fp,sp,12
 20358d4:	e13ffe15 	stw	r4,-8(fp)
 20358d8:	2805883a 	mov	r2,r5
 20358dc:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 20358e0:	e0bffe17 	ldw	r2,-8(fp)
 20358e4:	10800204 	addi	r2,r2,8
 20358e8:	10800037 	ldwio	r2,0(r2)
 20358ec:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 20358f0:	e0bfff03 	ldbu	r2,-4(fp)
 20358f4:	1000041e 	bne	r2,zero,2035908 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 20358f8:	e0bffd17 	ldw	r2,-12(fp)
 20358fc:	10810014 	ori	r2,r2,1024
 2035900:	e0bffd15 	stw	r2,-12(fp)
 2035904:	00000a06 	br	2035930 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 2035908:	e0bfff03 	ldbu	r2,-4(fp)
 203590c:	10800058 	cmpnei	r2,r2,1
 2035910:	1000051e 	bne	r2,zero,2035928 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 2035914:	e0fffd17 	ldw	r3,-12(fp)
 2035918:	00beffc4 	movi	r2,-1025
 203591c:	1884703a 	and	r2,r3,r2
 2035920:	e0bffd15 	stw	r2,-12(fp)
 2035924:	00000206 	br	2035930 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 2035928:	00bffd84 	movi	r2,-10
 203592c:	00000506 	br	2035944 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 2035930:	e0bffe17 	ldw	r2,-8(fp)
 2035934:	10800204 	addi	r2,r2,8
 2035938:	e0fffd17 	ldw	r3,-12(fp)
 203593c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 2035940:	0005883a 	mov	r2,zero

}
 2035944:	e037883a 	mov	sp,fp
 2035948:	df000017 	ldw	fp,0(sp)
 203594c:	dec00104 	addi	sp,sp,4
 2035950:	f800283a 	ret

02035954 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 2035954:	defff404 	addi	sp,sp,-48
 2035958:	dfc00b15 	stw	ra,44(sp)
 203595c:	df000a15 	stw	fp,40(sp)
 2035960:	df000a04 	addi	fp,sp,40
 2035964:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2035968:	00800044 	movi	r2,1
 203596c:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 2035970:	00800044 	movi	r2,1
 2035974:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 2035978:	e0bff743 	ldbu	r2,-35(fp)
 203597c:	10c0004c 	andi	r3,r2,1
 2035980:	e0bff703 	ldbu	r2,-36(fp)
 2035984:	10800098 	cmpnei	r2,r2,2
 2035988:	1000021e 	bne	r2,zero,2035994 <getPHYSpeed+0x40>
 203598c:	00800084 	movi	r2,2
 2035990:	00000106 	br	2035998 <getPHYSpeed+0x44>
 2035994:	0005883a 	mov	r2,zero
 2035998:	1886b03a 	or	r3,r3,r2
 203599c:	e0bff703 	ldbu	r2,-36(fp)
 20359a0:	10800058 	cmpnei	r2,r2,1
 20359a4:	1000021e 	bne	r2,zero,20359b0 <getPHYSpeed+0x5c>
 20359a8:	00800104 	movi	r2,4
 20359ac:	00000106 	br	20359b4 <getPHYSpeed+0x60>
 20359b0:	0005883a 	mov	r2,zero
 20359b4:	1886b03a 	or	r3,r3,r2
 20359b8:	e0bff703 	ldbu	r2,-36(fp)
 20359bc:	1000021e 	bne	r2,zero,20359c8 <getPHYSpeed+0x74>
 20359c0:	00800204 	movi	r2,8
 20359c4:	00000106 	br	20359cc <getPHYSpeed+0x78>
 20359c8:	0005883a 	mov	r2,zero
 20359cc:	1886b03a 	or	r3,r3,r2
 20359d0:	e0bff703 	ldbu	r2,-36(fp)
 20359d4:	108000d8 	cmpnei	r2,r2,3
 20359d8:	1000021e 	bne	r2,zero,20359e4 <getPHYSpeed+0x90>
 20359dc:	00800074 	movhi	r2,1
 20359e0:	00000106 	br	20359e8 <getPHYSpeed+0x94>
 20359e4:	0005883a 	mov	r2,zero
 20359e8:	1884b03a 	or	r2,r3,r2
 20359ec:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 20359f0:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 20359f4:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 20359f8:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 20359fc:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 2035a00:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 2035a04:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 2035a08:	d0a800c3 	ldbu	r2,-24573(gp)
 2035a0c:	10803fcc 	andi	r2,r2,255
 2035a10:	1000031e 	bne	r2,zero,2035a20 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 2035a14:	20379480 	call	2037948 <alt_tse_phy_init>
        is_init = 1;
 2035a18:	00800044 	movi	r2,1
 2035a1c:	d0a800c5 	stb	r2,-24573(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 2035a20:	e13fff17 	ldw	r4,-4(fp)
 2035a24:	20357100 	call	2035710 <alt_tse_get_mac_info>
 2035a28:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 2035a2c:	e0bffa17 	ldw	r2,-24(fp)
 2035a30:	1000481e 	bne	r2,zero,2035b54 <getPHYSpeed+0x200>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2035a34:	00800044 	movi	r2,1
 2035a38:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2035a3c:	00800044 	movi	r2,1
 2035a40:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 2035a44:	e0bff743 	ldbu	r2,-35(fp)
 2035a48:	10c0004c 	andi	r3,r2,1
 2035a4c:	e0bff703 	ldbu	r2,-36(fp)
 2035a50:	10800098 	cmpnei	r2,r2,2
 2035a54:	1000021e 	bne	r2,zero,2035a60 <getPHYSpeed+0x10c>
 2035a58:	00800084 	movi	r2,2
 2035a5c:	00000106 	br	2035a64 <getPHYSpeed+0x110>
 2035a60:	0005883a 	mov	r2,zero
 2035a64:	1886b03a 	or	r3,r3,r2
 2035a68:	e0bff703 	ldbu	r2,-36(fp)
 2035a6c:	10800058 	cmpnei	r2,r2,1
 2035a70:	1000021e 	bne	r2,zero,2035a7c <getPHYSpeed+0x128>
 2035a74:	00800104 	movi	r2,4
 2035a78:	00000106 	br	2035a80 <getPHYSpeed+0x12c>
 2035a7c:	0005883a 	mov	r2,zero
 2035a80:	1886b03a 	or	r3,r3,r2
 2035a84:	e0bff703 	ldbu	r2,-36(fp)
 2035a88:	1000021e 	bne	r2,zero,2035a94 <getPHYSpeed+0x140>
 2035a8c:	00800204 	movi	r2,8
 2035a90:	00000106 	br	2035a98 <getPHYSpeed+0x144>
 2035a94:	0005883a 	mov	r2,zero
 2035a98:	1886b03a 	or	r3,r3,r2
 2035a9c:	e0bff703 	ldbu	r2,-36(fp)
 2035aa0:	108000d8 	cmpnei	r2,r2,3
 2035aa4:	1000021e 	bne	r2,zero,2035ab0 <getPHYSpeed+0x15c>
 2035aa8:	00800074 	movhi	r2,1
 2035aac:	00000106 	br	2035ab4 <getPHYSpeed+0x160>
 2035ab0:	0005883a 	mov	r2,zero
 2035ab4:	1884b03a 	or	r2,r3,r2
 2035ab8:	10802034 	orhi	r2,r2,128
 2035abc:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 2035ac0:	e0bff703 	ldbu	r2,-36(fp)
 2035ac4:	108000a0 	cmpeqi	r2,r2,2
 2035ac8:	10000e1e 	bne	r2,zero,2035b04 <getPHYSpeed+0x1b0>
 2035acc:	e0bff703 	ldbu	r2,-36(fp)
 2035ad0:	10800060 	cmpeqi	r2,r2,1
 2035ad4:	1000081e 	bne	r2,zero,2035af8 <getPHYSpeed+0x1a4>
 2035ad8:	e0bff703 	ldbu	r2,-36(fp)
 2035adc:	1000031e 	bne	r2,zero,2035aec <getPHYSpeed+0x198>
 2035ae0:	00808134 	movhi	r2,516
 2035ae4:	109d3804 	addi	r2,r2,29920
 2035ae8:	00000806 	br	2035b0c <getPHYSpeed+0x1b8>
 2035aec:	00808134 	movhi	r2,516
 2035af0:	109d3904 	addi	r2,r2,29924
 2035af4:	00000506 	br	2035b0c <getPHYSpeed+0x1b8>
 2035af8:	00808134 	movhi	r2,516
 2035afc:	109d3b04 	addi	r2,r2,29932
 2035b00:	00000206 	br	2035b0c <getPHYSpeed+0x1b8>
 2035b04:	00808134 	movhi	r2,516
 2035b08:	109d3c04 	addi	r2,r2,29936
 2035b0c:	e0fff743 	ldbu	r3,-35(fp)
 2035b10:	18c00058 	cmpnei	r3,r3,1
 2035b14:	1800031e 	bne	r3,zero,2035b24 <getPHYSpeed+0x1d0>
 2035b18:	00c08134 	movhi	r3,516
 2035b1c:	18dd3e04 	addi	r3,r3,29944
 2035b20:	00000206 	br	2035b2c <getPHYSpeed+0x1d8>
 2035b24:	00c08134 	movhi	r3,516
 2035b28:	18dd4004 	addi	r3,r3,29952
 2035b2c:	180d883a 	mov	r6,r3
 2035b30:	100b883a 	mov	r5,r2
 2035b34:	01008134 	movhi	r4,516
 2035b38:	211d4204 	addi	r4,r4,29960
 2035b3c:	20009e40 	call	20009e4 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 2035b40:	01008134 	movhi	r4,516
 2035b44:	211d5a04 	addi	r4,r4,30056
 2035b48:	20426cc0 	call	20426cc <puts>
        return result;
 2035b4c:	e0bff817 	ldw	r2,-32(fp)
 2035b50:	00021a06 	br	20363bc <getPHYSpeed+0xa68>
    }
    
    pphy = pmac_info->pphy_info;
 2035b54:	e0bffa17 	ldw	r2,-24(fp)
 2035b58:	10800117 	ldw	r2,4(r2)
 2035b5c:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 2035b60:	e0bffa17 	ldw	r2,-24(fp)
 2035b64:	10800317 	ldw	r2,12(r2)
 2035b68:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 2035b6c:	e0bffa17 	ldw	r2,-24(fp)
 2035b70:	10800217 	ldw	r2,8(r2)
 2035b74:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2035b78:	e13ffa17 	ldw	r4,-24(fp)
 2035b7c:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2035b80:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2035b84:	e13ffb17 	ldw	r4,-20(fp)
 2035b88:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2035b8c:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 2035b90:	e0bffb17 	ldw	r2,-20(fp)
 2035b94:	10800117 	ldw	r2,4(r2)
 2035b98:	10800217 	ldw	r2,8(r2)
 2035b9c:	10800203 	ldbu	r2,8(r2)
 2035ba0:	10803fcc 	andi	r2,r2,255
 2035ba4:	10005a1e 	bne	r2,zero,2035d10 <getPHYSpeed+0x3bc>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2035ba8:	00800044 	movi	r2,1
 2035bac:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2035bb0:	00800044 	movi	r2,1
 2035bb4:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 2035bb8:	e0bff743 	ldbu	r2,-35(fp)
 2035bbc:	10c0004c 	andi	r3,r2,1
 2035bc0:	e0bff703 	ldbu	r2,-36(fp)
 2035bc4:	10800098 	cmpnei	r2,r2,2
 2035bc8:	1000021e 	bne	r2,zero,2035bd4 <getPHYSpeed+0x280>
 2035bcc:	00800084 	movi	r2,2
 2035bd0:	00000106 	br	2035bd8 <getPHYSpeed+0x284>
 2035bd4:	0005883a 	mov	r2,zero
 2035bd8:	1886b03a 	or	r3,r3,r2
 2035bdc:	e0bff703 	ldbu	r2,-36(fp)
 2035be0:	10800058 	cmpnei	r2,r2,1
 2035be4:	1000021e 	bne	r2,zero,2035bf0 <getPHYSpeed+0x29c>
 2035be8:	00800104 	movi	r2,4
 2035bec:	00000106 	br	2035bf4 <getPHYSpeed+0x2a0>
 2035bf0:	0005883a 	mov	r2,zero
 2035bf4:	1886b03a 	or	r3,r3,r2
 2035bf8:	e0bff703 	ldbu	r2,-36(fp)
 2035bfc:	1000021e 	bne	r2,zero,2035c08 <getPHYSpeed+0x2b4>
 2035c00:	00800204 	movi	r2,8
 2035c04:	00000106 	br	2035c0c <getPHYSpeed+0x2b8>
 2035c08:	0005883a 	mov	r2,zero
 2035c0c:	1886b03a 	or	r3,r3,r2
 2035c10:	e0bff703 	ldbu	r2,-36(fp)
 2035c14:	108000d8 	cmpnei	r2,r2,3
 2035c18:	1000021e 	bne	r2,zero,2035c24 <getPHYSpeed+0x2d0>
 2035c1c:	00800074 	movhi	r2,1
 2035c20:	00000106 	br	2035c28 <getPHYSpeed+0x2d4>
 2035c24:	0005883a 	mov	r2,zero
 2035c28:	1884b03a 	or	r2,r3,r2
 2035c2c:	10801034 	orhi	r2,r2,64
 2035c30:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 2035c34:	010003f4 	movhi	r4,15
 2035c38:	21109004 	addi	r4,r4,16960
 2035c3c:	202ea340 	call	202ea34 <usleep>
        if(psys->tse_phy_cfg) {
 2035c40:	e0bffc17 	ldw	r2,-16(fp)
 2035c44:	10801117 	ldw	r2,68(r2)
 2035c48:	10000d26 	beq	r2,zero,2035c80 <getPHYSpeed+0x32c>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 2035c4c:	e0bffd47 	ldb	r2,-11(fp)
 2035c50:	e0fffd07 	ldb	r3,-12(fp)
 2035c54:	180d883a 	mov	r6,r3
 2035c58:	100b883a 	mov	r5,r2
 2035c5c:	01008134 	movhi	r4,516
 2035c60:	211d6b04 	addi	r4,r4,30124
 2035c64:	20009e40 	call	20009e4 <printf>
        	result = psys->tse_phy_cfg(pmac);
 2035c68:	e0bffc17 	ldw	r2,-16(fp)
 2035c6c:	10801117 	ldw	r2,68(r2)
 2035c70:	e13fff17 	ldw	r4,-4(fp)
 2035c74:	103ee83a 	callr	r2
 2035c78:	e0bff815 	stw	r2,-32(fp)
 2035c7c:	00002206 	br	2035d08 <getPHYSpeed+0x3b4>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2035c80:	e13ffd47 	ldb	r4,-11(fp)
 2035c84:	e0bff703 	ldbu	r2,-36(fp)
 2035c88:	108000a0 	cmpeqi	r2,r2,2
 2035c8c:	10000e1e 	bne	r2,zero,2035cc8 <getPHYSpeed+0x374>
 2035c90:	e0bff703 	ldbu	r2,-36(fp)
 2035c94:	10800060 	cmpeqi	r2,r2,1
 2035c98:	1000081e 	bne	r2,zero,2035cbc <getPHYSpeed+0x368>
 2035c9c:	e0bff703 	ldbu	r2,-36(fp)
 2035ca0:	1000031e 	bne	r2,zero,2035cb0 <getPHYSpeed+0x35c>
 2035ca4:	00808134 	movhi	r2,516
 2035ca8:	109d3804 	addi	r2,r2,29920
 2035cac:	00000806 	br	2035cd0 <getPHYSpeed+0x37c>
 2035cb0:	00808134 	movhi	r2,516
 2035cb4:	109d3904 	addi	r2,r2,29924
 2035cb8:	00000506 	br	2035cd0 <getPHYSpeed+0x37c>
 2035cbc:	00808134 	movhi	r2,516
 2035cc0:	109d3b04 	addi	r2,r2,29932
 2035cc4:	00000206 	br	2035cd0 <getPHYSpeed+0x37c>
 2035cc8:	00808134 	movhi	r2,516
 2035ccc:	109d3c04 	addi	r2,r2,29936
 2035cd0:	e0fff743 	ldbu	r3,-35(fp)
 2035cd4:	18c00058 	cmpnei	r3,r3,1
 2035cd8:	1800031e 	bne	r3,zero,2035ce8 <getPHYSpeed+0x394>
 2035cdc:	00c08134 	movhi	r3,516
 2035ce0:	18dd3e04 	addi	r3,r3,29944
 2035ce4:	00000206 	br	2035cf0 <getPHYSpeed+0x39c>
 2035ce8:	00c08134 	movhi	r3,516
 2035cec:	18dd4004 	addi	r3,r3,29952
 2035cf0:	180f883a 	mov	r7,r3
 2035cf4:	100d883a 	mov	r6,r2
 2035cf8:	200b883a 	mov	r5,r4
 2035cfc:	01008134 	movhi	r4,516
 2035d00:	211d7d04 	addi	r4,r4,30196
 2035d04:	20009e40 	call	20009e4 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 2035d08:	e0bff817 	ldw	r2,-32(fp)
 2035d0c:	0001ab06 	br	20363bc <getPHYSpeed+0xa68>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2035d10:	e0bffb17 	ldw	r2,-20(fp)
 2035d14:	10800117 	ldw	r2,4(r2)
 2035d18:	10800217 	ldw	r2,8(r2)
 2035d1c:	10800017 	ldw	r2,0(r2)
 2035d20:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 2035d24:	e0bff917 	ldw	r2,-28(fp)
 2035d28:	1000491e 	bne	r2,zero,2035e50 <getPHYSpeed+0x4fc>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2035d2c:	00800044 	movi	r2,1
 2035d30:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2035d34:	00800044 	movi	r2,1
 2035d38:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 2035d3c:	e0bff743 	ldbu	r2,-35(fp)
 2035d40:	10c0004c 	andi	r3,r2,1
 2035d44:	e0bff703 	ldbu	r2,-36(fp)
 2035d48:	10800098 	cmpnei	r2,r2,2
 2035d4c:	1000021e 	bne	r2,zero,2035d58 <getPHYSpeed+0x404>
 2035d50:	00800084 	movi	r2,2
 2035d54:	00000106 	br	2035d5c <getPHYSpeed+0x408>
 2035d58:	0005883a 	mov	r2,zero
 2035d5c:	1886b03a 	or	r3,r3,r2
 2035d60:	e0bff703 	ldbu	r2,-36(fp)
 2035d64:	10800058 	cmpnei	r2,r2,1
 2035d68:	1000021e 	bne	r2,zero,2035d74 <getPHYSpeed+0x420>
 2035d6c:	00800104 	movi	r2,4
 2035d70:	00000106 	br	2035d78 <getPHYSpeed+0x424>
 2035d74:	0005883a 	mov	r2,zero
 2035d78:	1886b03a 	or	r3,r3,r2
 2035d7c:	e0bff703 	ldbu	r2,-36(fp)
 2035d80:	1000021e 	bne	r2,zero,2035d8c <getPHYSpeed+0x438>
 2035d84:	00800204 	movi	r2,8
 2035d88:	00000106 	br	2035d90 <getPHYSpeed+0x43c>
 2035d8c:	0005883a 	mov	r2,zero
 2035d90:	1886b03a 	or	r3,r3,r2
 2035d94:	e0bff703 	ldbu	r2,-36(fp)
 2035d98:	108000d8 	cmpnei	r2,r2,3
 2035d9c:	1000021e 	bne	r2,zero,2035da8 <getPHYSpeed+0x454>
 2035da0:	00800074 	movhi	r2,1
 2035da4:	00000106 	br	2035dac <getPHYSpeed+0x458>
 2035da8:	0005883a 	mov	r2,zero
 2035dac:	1884b03a 	or	r2,r3,r2
 2035db0:	10800834 	orhi	r2,r2,32
 2035db4:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2035db8:	e13ffd47 	ldb	r4,-11(fp)
 2035dbc:	e17ffd07 	ldb	r5,-12(fp)
 2035dc0:	e0bff703 	ldbu	r2,-36(fp)
 2035dc4:	108000a0 	cmpeqi	r2,r2,2
 2035dc8:	10000e1e 	bne	r2,zero,2035e04 <getPHYSpeed+0x4b0>
 2035dcc:	e0bff703 	ldbu	r2,-36(fp)
 2035dd0:	10800060 	cmpeqi	r2,r2,1
 2035dd4:	1000081e 	bne	r2,zero,2035df8 <getPHYSpeed+0x4a4>
 2035dd8:	e0bff703 	ldbu	r2,-36(fp)
 2035ddc:	1000031e 	bne	r2,zero,2035dec <getPHYSpeed+0x498>
 2035de0:	00808134 	movhi	r2,516
 2035de4:	109d3804 	addi	r2,r2,29920
 2035de8:	00000806 	br	2035e0c <getPHYSpeed+0x4b8>
 2035dec:	00808134 	movhi	r2,516
 2035df0:	109d3904 	addi	r2,r2,29924
 2035df4:	00000506 	br	2035e0c <getPHYSpeed+0x4b8>
 2035df8:	00808134 	movhi	r2,516
 2035dfc:	109d3b04 	addi	r2,r2,29932
 2035e00:	00000206 	br	2035e0c <getPHYSpeed+0x4b8>
 2035e04:	00808134 	movhi	r2,516
 2035e08:	109d3c04 	addi	r2,r2,29936
 2035e0c:	e0fff743 	ldbu	r3,-35(fp)
 2035e10:	18c00058 	cmpnei	r3,r3,1
 2035e14:	1800031e 	bne	r3,zero,2035e24 <getPHYSpeed+0x4d0>
 2035e18:	00c08134 	movhi	r3,516
 2035e1c:	18dd3e04 	addi	r3,r3,29944
 2035e20:	00000206 	br	2035e2c <getPHYSpeed+0x4d8>
 2035e24:	00c08134 	movhi	r3,516
 2035e28:	18dd4004 	addi	r3,r3,29952
 2035e2c:	d8c00015 	stw	r3,0(sp)
 2035e30:	100f883a 	mov	r7,r2
 2035e34:	280d883a 	mov	r6,r5
 2035e38:	200b883a 	mov	r5,r4
 2035e3c:	01008134 	movhi	r4,516
 2035e40:	211d8f04 	addi	r4,r4,30268
 2035e44:	20009e40 	call	20009e4 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 2035e48:	e0bff817 	ldw	r2,-32(fp)
 2035e4c:	00015b06 	br	20363bc <getPHYSpeed+0xa68>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 2035e50:	e0bffa17 	ldw	r2,-24(fp)
 2035e54:	10800003 	ldbu	r2,0(r2)
 2035e58:	10803fcc 	andi	r2,r2,255
 2035e5c:	10800058 	cmpnei	r2,r2,1
 2035e60:	1000071e 	bne	r2,zero,2035e80 <getPHYSpeed+0x52c>
			alt_tse_phy_set_adv_1000(pphy, 0);
 2035e64:	000b883a 	mov	r5,zero
 2035e68:	e13ff917 	ldw	r4,-28(fp)
 2035e6c:	20383100 	call	2038310 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2035e70:	017e0034 	movhi	r5,63488
 2035e74:	e13ff917 	ldw	r4,-28(fp)
 2035e78:	2037a600 	call	2037a60 <alt_tse_phy_restart_an>
 2035e7c:	00000e06 	br	2035eb8 <getPHYSpeed+0x564>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 2035e80:	e0bffa17 	ldw	r2,-24(fp)
 2035e84:	10800003 	ldbu	r2,0(r2)
 2035e88:	10803fcc 	andi	r2,r2,255
 2035e8c:	10800098 	cmpnei	r2,r2,2
 2035e90:	1000091e 	bne	r2,zero,2035eb8 <getPHYSpeed+0x564>
			alt_tse_phy_set_adv_100(pphy, 0);
 2035e94:	000b883a 	mov	r5,zero
 2035e98:	e13ff917 	ldw	r4,-28(fp)
 2035e9c:	20384d40 	call	20384d4 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 2035ea0:	000b883a 	mov	r5,zero
 2035ea4:	e13ff917 	ldw	r4,-28(fp)
 2035ea8:	20387280 	call	2038728 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2035eac:	017e0034 	movhi	r5,63488
 2035eb0:	e13ff917 	ldw	r4,-28(fp)
 2035eb4:	2037a600 	call	2037a60 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 2035eb8:	017e0034 	movhi	r5,63488
 2035ebc:	e13ff917 	ldw	r4,-28(fp)
 2035ec0:	2037c1c0 	call	2037c1c <alt_tse_phy_check_link>
 2035ec4:	10bfffd8 	cmpnei	r2,r2,-1
 2035ec8:	1000491e 	bne	r2,zero,2035ff0 <getPHYSpeed+0x69c>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2035ecc:	00800044 	movi	r2,1
 2035ed0:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2035ed4:	00800044 	movi	r2,1
 2035ed8:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 2035edc:	e0bff743 	ldbu	r2,-35(fp)
 2035ee0:	10c0004c 	andi	r3,r2,1
 2035ee4:	e0bff703 	ldbu	r2,-36(fp)
 2035ee8:	10800098 	cmpnei	r2,r2,2
 2035eec:	1000021e 	bne	r2,zero,2035ef8 <getPHYSpeed+0x5a4>
 2035ef0:	00800084 	movi	r2,2
 2035ef4:	00000106 	br	2035efc <getPHYSpeed+0x5a8>
 2035ef8:	0005883a 	mov	r2,zero
 2035efc:	1886b03a 	or	r3,r3,r2
 2035f00:	e0bff703 	ldbu	r2,-36(fp)
 2035f04:	10800058 	cmpnei	r2,r2,1
 2035f08:	1000021e 	bne	r2,zero,2035f14 <getPHYSpeed+0x5c0>
 2035f0c:	00800104 	movi	r2,4
 2035f10:	00000106 	br	2035f18 <getPHYSpeed+0x5c4>
 2035f14:	0005883a 	mov	r2,zero
 2035f18:	1886b03a 	or	r3,r3,r2
 2035f1c:	e0bff703 	ldbu	r2,-36(fp)
 2035f20:	1000021e 	bne	r2,zero,2035f2c <getPHYSpeed+0x5d8>
 2035f24:	00800204 	movi	r2,8
 2035f28:	00000106 	br	2035f30 <getPHYSpeed+0x5dc>
 2035f2c:	0005883a 	mov	r2,zero
 2035f30:	1886b03a 	or	r3,r3,r2
 2035f34:	e0bff703 	ldbu	r2,-36(fp)
 2035f38:	108000d8 	cmpnei	r2,r2,3
 2035f3c:	1000021e 	bne	r2,zero,2035f48 <getPHYSpeed+0x5f4>
 2035f40:	00800074 	movhi	r2,1
 2035f44:	00000106 	br	2035f4c <getPHYSpeed+0x5f8>
 2035f48:	0005883a 	mov	r2,zero
 2035f4c:	1884b03a 	or	r2,r3,r2
 2035f50:	10800234 	orhi	r2,r2,8
 2035f54:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2035f58:	e13ffd47 	ldb	r4,-11(fp)
 2035f5c:	e17ffd07 	ldb	r5,-12(fp)
 2035f60:	e0bff703 	ldbu	r2,-36(fp)
 2035f64:	108000a0 	cmpeqi	r2,r2,2
 2035f68:	10000e1e 	bne	r2,zero,2035fa4 <getPHYSpeed+0x650>
 2035f6c:	e0bff703 	ldbu	r2,-36(fp)
 2035f70:	10800060 	cmpeqi	r2,r2,1
 2035f74:	1000081e 	bne	r2,zero,2035f98 <getPHYSpeed+0x644>
 2035f78:	e0bff703 	ldbu	r2,-36(fp)
 2035f7c:	1000031e 	bne	r2,zero,2035f8c <getPHYSpeed+0x638>
 2035f80:	00808134 	movhi	r2,516
 2035f84:	109d3804 	addi	r2,r2,29920
 2035f88:	00000806 	br	2035fac <getPHYSpeed+0x658>
 2035f8c:	00808134 	movhi	r2,516
 2035f90:	109d3904 	addi	r2,r2,29924
 2035f94:	00000506 	br	2035fac <getPHYSpeed+0x658>
 2035f98:	00808134 	movhi	r2,516
 2035f9c:	109d3b04 	addi	r2,r2,29932
 2035fa0:	00000206 	br	2035fac <getPHYSpeed+0x658>
 2035fa4:	00808134 	movhi	r2,516
 2035fa8:	109d3c04 	addi	r2,r2,29936
 2035fac:	e0fff743 	ldbu	r3,-35(fp)
 2035fb0:	18c00058 	cmpnei	r3,r3,1
 2035fb4:	1800031e 	bne	r3,zero,2035fc4 <getPHYSpeed+0x670>
 2035fb8:	00c08134 	movhi	r3,516
 2035fbc:	18dd3e04 	addi	r3,r3,29944
 2035fc0:	00000206 	br	2035fcc <getPHYSpeed+0x678>
 2035fc4:	00c08134 	movhi	r3,516
 2035fc8:	18dd4004 	addi	r3,r3,29952
 2035fcc:	d8c00015 	stw	r3,0(sp)
 2035fd0:	100f883a 	mov	r7,r2
 2035fd4:	280d883a 	mov	r6,r5
 2035fd8:	200b883a 	mov	r5,r4
 2035fdc:	01008134 	movhi	r4,516
 2035fe0:	211da004 	addi	r4,r4,30336
 2035fe4:	20009e40 	call	20009e4 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 2035fe8:	e0bff817 	ldw	r2,-32(fp)
 2035fec:	0000f306 	br	20363bc <getPHYSpeed+0xa68>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 2035ff0:	e0bffe17 	ldw	r2,-8(fp)
 2035ff4:	10801004 	addi	r2,r2,64
 2035ff8:	e0fff917 	ldw	r3,-28(fp)
 2035ffc:	18c00003 	ldbu	r3,0(r3)
 2036000:	18c03fcc 	andi	r3,r3,255
 2036004:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 2036008:	d8000015 	stw	zero,0(sp)
 203600c:	01c00044 	movi	r7,1
 2036010:	01800384 	movi	r6,14
 2036014:	000b883a 	mov	r5,zero
 2036018:	e13ff917 	ldw	r4,-28(fp)
 203601c:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 2036020:	e0bff917 	ldw	r2,-28(fp)
 2036024:	10800517 	ldw	r2,20(r2)
 2036028:	10002b1e 	bne	r2,zero,20360d8 <getPHYSpeed+0x784>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 203602c:	e0bffd47 	ldb	r2,-11(fp)
 2036030:	e0fffd07 	ldb	r3,-12(fp)
 2036034:	180d883a 	mov	r6,r3
 2036038:	100b883a 	mov	r5,r2
 203603c:	01008134 	movhi	r4,516
 2036040:	211db404 	addi	r4,r4,30416
 2036044:	20009e40 	call	20009e4 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2036048:	00800044 	movi	r2,1
 203604c:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2036050:	00800044 	movi	r2,1
 2036054:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 2036058:	e0bff743 	ldbu	r2,-35(fp)
 203605c:	10c0004c 	andi	r3,r2,1
 2036060:	e0bff703 	ldbu	r2,-36(fp)
 2036064:	10800098 	cmpnei	r2,r2,2
 2036068:	1000021e 	bne	r2,zero,2036074 <getPHYSpeed+0x720>
 203606c:	00800084 	movi	r2,2
 2036070:	00000106 	br	2036078 <getPHYSpeed+0x724>
 2036074:	0005883a 	mov	r2,zero
 2036078:	1886b03a 	or	r3,r3,r2
 203607c:	e0bff703 	ldbu	r2,-36(fp)
 2036080:	10800058 	cmpnei	r2,r2,1
 2036084:	1000021e 	bne	r2,zero,2036090 <getPHYSpeed+0x73c>
 2036088:	00800104 	movi	r2,4
 203608c:	00000106 	br	2036094 <getPHYSpeed+0x740>
 2036090:	0005883a 	mov	r2,zero
 2036094:	1886b03a 	or	r3,r3,r2
 2036098:	e0bff703 	ldbu	r2,-36(fp)
 203609c:	1000021e 	bne	r2,zero,20360a8 <getPHYSpeed+0x754>
 20360a0:	00800204 	movi	r2,8
 20360a4:	00000106 	br	20360ac <getPHYSpeed+0x758>
 20360a8:	0005883a 	mov	r2,zero
 20360ac:	1886b03a 	or	r3,r3,r2
 20360b0:	e0bff703 	ldbu	r2,-36(fp)
 20360b4:	108000d8 	cmpnei	r2,r2,3
 20360b8:	1000021e 	bne	r2,zero,20360c4 <getPHYSpeed+0x770>
 20360bc:	00800074 	movhi	r2,1
 20360c0:	00000106 	br	20360c8 <getPHYSpeed+0x774>
 20360c4:	0005883a 	mov	r2,zero
 20360c8:	1884b03a 	or	r2,r3,r2
 20360cc:	10800134 	orhi	r2,r2,4
 20360d0:	e0bff815 	stw	r2,-32(fp)
 20360d4:	00009406 	br	2036328 <getPHYSpeed+0x9d4>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 20360d8:	e0bff917 	ldw	r2,-28(fp)
 20360dc:	10800517 	ldw	r2,20(r2)
 20360e0:	10801817 	ldw	r2,96(r2)
 20360e4:	10002626 	beq	r2,zero,2036180 <getPHYSpeed+0x82c>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 20360e8:	e0bff917 	ldw	r2,-28(fp)
 20360ec:	10800517 	ldw	r2,20(r2)
 20360f0:	10801817 	ldw	r2,96(r2)
 20360f4:	e13ffe17 	ldw	r4,-8(fp)
 20360f8:	103ee83a 	callr	r2
 20360fc:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2036100:	e0bff817 	ldw	r2,-32(fp)
 2036104:	1080008c 	andi	r2,r2,2
 2036108:	10000c1e 	bne	r2,zero,203613c <getPHYSpeed+0x7e8>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 203610c:	e0bff817 	ldw	r2,-32(fp)
 2036110:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2036114:	1000071e 	bne	r2,zero,2036134 <getPHYSpeed+0x7e0>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 2036118:	e0bff817 	ldw	r2,-32(fp)
 203611c:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2036120:	10000226 	beq	r2,zero,203612c <getPHYSpeed+0x7d8>
 2036124:	0005883a 	mov	r2,zero
 2036128:	00000506 	br	2036140 <getPHYSpeed+0x7ec>
 203612c:	008000c4 	movi	r2,3
 2036130:	00000306 	br	2036140 <getPHYSpeed+0x7ec>
 2036134:	00800044 	movi	r2,1
 2036138:	00000106 	br	2036140 <getPHYSpeed+0x7ec>
 203613c:	00800084 	movi	r2,2
 2036140:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 2036144:	e0bff817 	ldw	r2,-32(fp)
 2036148:	1080004c 	andi	r2,r2,1
 203614c:	1004c03a 	cmpne	r2,r2,zero
 2036150:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 2036154:	e0bff817 	ldw	r2,-32(fp)
 2036158:	1080006c 	andhi	r2,r2,1
 203615c:	10007226 	beq	r2,zero,2036328 <getPHYSpeed+0x9d4>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 2036160:	e0bffd47 	ldb	r2,-11(fp)
 2036164:	e0fffd07 	ldb	r3,-12(fp)
 2036168:	180d883a 	mov	r6,r3
 203616c:	100b883a 	mov	r5,r2
 2036170:	01008134 	movhi	r4,516
 2036174:	211dc204 	addi	r4,r4,30472
 2036178:	20009e40 	call	20009e4 <printf>
 203617c:	00006a06 	br	2036328 <getPHYSpeed+0x9d4>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 2036180:	e0bff917 	ldw	r2,-28(fp)
 2036184:	10800517 	ldw	r2,20(r2)
 2036188:	10801583 	ldbu	r2,86(r2)
 203618c:	10803fcc 	andi	r2,r2,255
 2036190:	10002b1e 	bne	r2,zero,2036240 <getPHYSpeed+0x8ec>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 2036194:	e0bffd47 	ldb	r2,-11(fp)
 2036198:	e0fffd07 	ldb	r3,-12(fp)
 203619c:	180d883a 	mov	r6,r3
 20361a0:	100b883a 	mov	r5,r2
 20361a4:	01008134 	movhi	r4,516
 20361a8:	211dcf04 	addi	r4,r4,30524
 20361ac:	20009e40 	call	20009e4 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 20361b0:	00800044 	movi	r2,1
 20361b4:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 20361b8:	00800044 	movi	r2,1
 20361bc:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 20361c0:	e0bff743 	ldbu	r2,-35(fp)
 20361c4:	10c0004c 	andi	r3,r2,1
 20361c8:	e0bff703 	ldbu	r2,-36(fp)
 20361cc:	10800098 	cmpnei	r2,r2,2
 20361d0:	1000021e 	bne	r2,zero,20361dc <getPHYSpeed+0x888>
 20361d4:	00800084 	movi	r2,2
 20361d8:	00000106 	br	20361e0 <getPHYSpeed+0x88c>
 20361dc:	0005883a 	mov	r2,zero
 20361e0:	1886b03a 	or	r3,r3,r2
 20361e4:	e0bff703 	ldbu	r2,-36(fp)
 20361e8:	10800058 	cmpnei	r2,r2,1
 20361ec:	1000021e 	bne	r2,zero,20361f8 <getPHYSpeed+0x8a4>
 20361f0:	00800104 	movi	r2,4
 20361f4:	00000106 	br	20361fc <getPHYSpeed+0x8a8>
 20361f8:	0005883a 	mov	r2,zero
 20361fc:	1886b03a 	or	r3,r3,r2
 2036200:	e0bff703 	ldbu	r2,-36(fp)
 2036204:	1000021e 	bne	r2,zero,2036210 <getPHYSpeed+0x8bc>
 2036208:	00800204 	movi	r2,8
 203620c:	00000106 	br	2036214 <getPHYSpeed+0x8c0>
 2036210:	0005883a 	mov	r2,zero
 2036214:	1886b03a 	or	r3,r3,r2
 2036218:	e0bff703 	ldbu	r2,-36(fp)
 203621c:	108000d8 	cmpnei	r2,r2,3
 2036220:	1000021e 	bne	r2,zero,203622c <getPHYSpeed+0x8d8>
 2036224:	00800074 	movhi	r2,1
 2036228:	00000106 	br	2036230 <getPHYSpeed+0x8dc>
 203622c:	0005883a 	mov	r2,zero
 2036230:	1884b03a 	or	r2,r3,r2
 2036234:	108000b4 	orhi	r2,r2,2
 2036238:	e0bff815 	stw	r2,-32(fp)
 203623c:	00003a06 	br	2036328 <getPHYSpeed+0x9d4>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 2036240:	e0bff917 	ldw	r2,-28(fp)
 2036244:	10800517 	ldw	r2,20(r2)
 2036248:	10801583 	ldbu	r2,86(r2)
 203624c:	10c03fcc 	andi	r3,r2,255
 2036250:	e0bff917 	ldw	r2,-28(fp)
 2036254:	10800517 	ldw	r2,20(r2)
 2036258:	108015c3 	ldbu	r2,87(r2)
 203625c:	10803fcc 	andi	r2,r2,255
 2036260:	01c00084 	movi	r7,2
 2036264:	100d883a 	mov	r6,r2
 2036268:	180b883a 	mov	r5,r3
 203626c:	e13ff917 	ldw	r4,-28(fp)
 2036270:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2036274:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 2036278:	e0bff917 	ldw	r2,-28(fp)
 203627c:	10800517 	ldw	r2,20(r2)
 2036280:	10801583 	ldbu	r2,86(r2)
 2036284:	10c03fcc 	andi	r3,r2,255
 2036288:	e0bff917 	ldw	r2,-28(fp)
 203628c:	10800517 	ldw	r2,20(r2)
 2036290:	10801603 	ldbu	r2,88(r2)
 2036294:	10803fcc 	andi	r2,r2,255
 2036298:	01c00044 	movi	r7,1
 203629c:	100d883a 	mov	r6,r2
 20362a0:	180b883a 	mov	r5,r3
 20362a4:	e13ff917 	ldw	r4,-28(fp)
 20362a8:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 20362ac:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 20362b0:	e0bff743 	ldbu	r2,-35(fp)
 20362b4:	10c0004c 	andi	r3,r2,1
 20362b8:	e0bff703 	ldbu	r2,-36(fp)
 20362bc:	10800098 	cmpnei	r2,r2,2
 20362c0:	1000021e 	bne	r2,zero,20362cc <getPHYSpeed+0x978>
 20362c4:	00800084 	movi	r2,2
 20362c8:	00000106 	br	20362d0 <getPHYSpeed+0x97c>
 20362cc:	0005883a 	mov	r2,zero
 20362d0:	1886b03a 	or	r3,r3,r2
 20362d4:	e0bff703 	ldbu	r2,-36(fp)
 20362d8:	10800058 	cmpnei	r2,r2,1
 20362dc:	1000021e 	bne	r2,zero,20362e8 <getPHYSpeed+0x994>
 20362e0:	00800104 	movi	r2,4
 20362e4:	00000106 	br	20362ec <getPHYSpeed+0x998>
 20362e8:	0005883a 	mov	r2,zero
 20362ec:	1886b03a 	or	r3,r3,r2
 20362f0:	e0bff703 	ldbu	r2,-36(fp)
 20362f4:	1000021e 	bne	r2,zero,2036300 <getPHYSpeed+0x9ac>
 20362f8:	00800204 	movi	r2,8
 20362fc:	00000106 	br	2036304 <getPHYSpeed+0x9b0>
 2036300:	0005883a 	mov	r2,zero
 2036304:	1886b03a 	or	r3,r3,r2
 2036308:	e0bff703 	ldbu	r2,-36(fp)
 203630c:	108000d8 	cmpnei	r2,r2,3
 2036310:	1000021e 	bne	r2,zero,203631c <getPHYSpeed+0x9c8>
 2036314:	00800074 	movhi	r2,1
 2036318:	00000106 	br	2036320 <getPHYSpeed+0x9cc>
 203631c:	0005883a 	mov	r2,zero
 2036320:	1884b03a 	or	r2,r3,r2
 2036324:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2036328:	e13ffd47 	ldb	r4,-11(fp)
 203632c:	e17ffd07 	ldb	r5,-12(fp)
 2036330:	e0bff703 	ldbu	r2,-36(fp)
 2036334:	108000a0 	cmpeqi	r2,r2,2
 2036338:	10000e1e 	bne	r2,zero,2036374 <getPHYSpeed+0xa20>
 203633c:	e0bff703 	ldbu	r2,-36(fp)
 2036340:	10800060 	cmpeqi	r2,r2,1
 2036344:	1000081e 	bne	r2,zero,2036368 <getPHYSpeed+0xa14>
 2036348:	e0bff703 	ldbu	r2,-36(fp)
 203634c:	1000031e 	bne	r2,zero,203635c <getPHYSpeed+0xa08>
 2036350:	00808134 	movhi	r2,516
 2036354:	109d3804 	addi	r2,r2,29920
 2036358:	00000806 	br	203637c <getPHYSpeed+0xa28>
 203635c:	00808134 	movhi	r2,516
 2036360:	109d3904 	addi	r2,r2,29924
 2036364:	00000506 	br	203637c <getPHYSpeed+0xa28>
 2036368:	00808134 	movhi	r2,516
 203636c:	109d3b04 	addi	r2,r2,29932
 2036370:	00000206 	br	203637c <getPHYSpeed+0xa28>
 2036374:	00808134 	movhi	r2,516
 2036378:	109d3c04 	addi	r2,r2,29936
 203637c:	e0fff743 	ldbu	r3,-35(fp)
 2036380:	18c00058 	cmpnei	r3,r3,1
 2036384:	1800031e 	bne	r3,zero,2036394 <getPHYSpeed+0xa40>
 2036388:	00c08134 	movhi	r3,516
 203638c:	18dd3e04 	addi	r3,r3,29944
 2036390:	00000206 	br	203639c <getPHYSpeed+0xa48>
 2036394:	00c08134 	movhi	r3,516
 2036398:	18dd4004 	addi	r3,r3,29952
 203639c:	d8c00015 	stw	r3,0(sp)
 20363a0:	100f883a 	mov	r7,r2
 20363a4:	280d883a 	mov	r6,r5
 20363a8:	200b883a 	mov	r5,r4
 20363ac:	01008134 	movhi	r4,516
 20363b0:	211de604 	addi	r4,r4,30616
 20363b4:	20009e40 	call	20009e4 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 20363b8:	e0bff817 	ldw	r2,-32(fp)
}
 20363bc:	e037883a 	mov	sp,fp
 20363c0:	dfc00117 	ldw	ra,4(sp)
 20363c4:	df000017 	ldw	fp,0(sp)
 20363c8:	dec00204 	addi	sp,sp,8
 20363cc:	f800283a 	ret

020363d0 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 20363d0:	defffd04 	addi	sp,sp,-12
 20363d4:	df000215 	stw	fp,8(sp)
 20363d8:	df000204 	addi	fp,sp,8
 20363dc:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 20363e0:	e0bfff17 	ldw	r2,-4(fp)
 20363e4:	10800617 	ldw	r2,24(r2)
 20363e8:	10800317 	ldw	r2,12(r2)
 20363ec:	10800117 	ldw	r2,4(r2)
 20363f0:	10800217 	ldw	r2,8(r2)
 20363f4:	10800017 	ldw	r2,0(r2)
 20363f8:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 20363fc:	e0bffe17 	ldw	r2,-8(fp)
 2036400:	10801004 	addi	r2,r2,64
 2036404:	10800037 	ldwio	r2,0(r2)
}
 2036408:	e037883a 	mov	sp,fp
 203640c:	df000017 	ldw	fp,0(sp)
 2036410:	dec00104 	addi	sp,sp,4
 2036414:	f800283a 	ret

02036418 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 2036418:	defffc04 	addi	sp,sp,-16
 203641c:	df000315 	stw	fp,12(sp)
 2036420:	df000304 	addi	fp,sp,12
 2036424:	e13ffe15 	stw	r4,-8(fp)
 2036428:	2805883a 	mov	r2,r5
 203642c:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2036430:	e0bffe17 	ldw	r2,-8(fp)
 2036434:	10800617 	ldw	r2,24(r2)
 2036438:	10800317 	ldw	r2,12(r2)
 203643c:	10800117 	ldw	r2,4(r2)
 2036440:	10800217 	ldw	r2,8(r2)
 2036444:	10800017 	ldw	r2,0(r2)
 2036448:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 203644c:	e0bffd17 	ldw	r2,-12(fp)
 2036450:	10801004 	addi	r2,r2,64
 2036454:	e0ffff03 	ldbu	r3,-4(fp)
 2036458:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 203645c:	0005883a 	mov	r2,zero
}
 2036460:	e037883a 	mov	sp,fp
 2036464:	df000017 	ldw	fp,0(sp)
 2036468:	dec00104 	addi	sp,sp,4
 203646c:	f800283a 	ret

02036470 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 2036470:	defff604 	addi	sp,sp,-40
 2036474:	df000915 	stw	fp,36(sp)
 2036478:	df000904 	addi	fp,sp,36
 203647c:	e13ffb15 	stw	r4,-20(fp)
 2036480:	3009883a 	mov	r4,r6
 2036484:	3807883a 	mov	r3,r7
 2036488:	e0800117 	ldw	r2,4(fp)
 203648c:	e17ffc05 	stb	r5,-16(fp)
 2036490:	e13ffd05 	stb	r4,-12(fp)
 2036494:	e0fffe05 	stb	r3,-8(fp)
 2036498:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 203649c:	e0bffb17 	ldw	r2,-20(fp)
 20364a0:	10800617 	ldw	r2,24(r2)
 20364a4:	10800317 	ldw	r2,12(r2)
 20364a8:	10800117 	ldw	r2,4(r2)
 20364ac:	10800217 	ldw	r2,8(r2)
 20364b0:	10800017 	ldw	r2,0(r2)
 20364b4:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 20364b8:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 20364bc:	e03ff815 	stw	zero,-32(fp)
 20364c0:	00000906 	br	20364e8 <alt_tse_phy_wr_mdio_reg+0x78>
    {
        bit_mask <<= 1;
 20364c4:	e0bff70b 	ldhu	r2,-36(fp)
 20364c8:	1085883a 	add	r2,r2,r2
 20364cc:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 20364d0:	e0bff70b 	ldhu	r2,-36(fp)
 20364d4:	10800054 	ori	r2,r2,1
 20364d8:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 20364dc:	e0bff817 	ldw	r2,-32(fp)
 20364e0:	10800044 	addi	r2,r2,1
 20364e4:	e0bff815 	stw	r2,-32(fp)
 20364e8:	e0bffe03 	ldbu	r2,-8(fp)
 20364ec:	e0fff817 	ldw	r3,-32(fp)
 20364f0:	18bff416 	blt	r3,r2,20364c4 <__alt_mem_mem_0+0xfd0164c4>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 20364f4:	e0fff70b 	ldhu	r3,-36(fp)
 20364f8:	e0bffd03 	ldbu	r2,-12(fp)
 20364fc:	1884983a 	sll	r2,r3,r2
 2036500:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 2036504:	e0bff917 	ldw	r2,-28(fp)
 2036508:	10c0a004 	addi	r3,r2,640
 203650c:	e0bffc03 	ldbu	r2,-16(fp)
 2036510:	1085883a 	add	r2,r2,r2
 2036514:	1085883a 	add	r2,r2,r2
 2036518:	1885883a 	add	r2,r3,r2
 203651c:	10800037 	ldwio	r2,0(r2)
 2036520:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 2036524:	e0bff70b 	ldhu	r2,-36(fp)
 2036528:	0084303a 	nor	r2,zero,r2
 203652c:	1007883a 	mov	r3,r2
 2036530:	e0bffa0b 	ldhu	r2,-24(fp)
 2036534:	1884703a 	and	r2,r3,r2
 2036538:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 203653c:	e0ffff0b 	ldhu	r3,-4(fp)
 2036540:	e0bffd03 	ldbu	r2,-12(fp)
 2036544:	1884983a 	sll	r2,r3,r2
 2036548:	1007883a 	mov	r3,r2
 203654c:	e0bff70b 	ldhu	r2,-36(fp)
 2036550:	1884703a 	and	r2,r3,r2
 2036554:	1007883a 	mov	r3,r2
 2036558:	e0bffa0b 	ldhu	r2,-24(fp)
 203655c:	1884b03a 	or	r2,r3,r2
 2036560:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 2036564:	e0bff917 	ldw	r2,-28(fp)
 2036568:	10c0a004 	addi	r3,r2,640
 203656c:	e0bffc03 	ldbu	r2,-16(fp)
 2036570:	1085883a 	add	r2,r2,r2
 2036574:	1085883a 	add	r2,r2,r2
 2036578:	1885883a 	add	r2,r3,r2
 203657c:	e0fffa0b 	ldhu	r3,-24(fp)
 2036580:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 2036584:	0005883a 	mov	r2,zero
    
}
 2036588:	e037883a 	mov	sp,fp
 203658c:	df000017 	ldw	fp,0(sp)
 2036590:	dec00104 	addi	sp,sp,4
 2036594:	f800283a 	ret

02036598 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 2036598:	defff704 	addi	sp,sp,-36
 203659c:	df000815 	stw	fp,32(sp)
 20365a0:	df000804 	addi	fp,sp,32
 20365a4:	e13ffc15 	stw	r4,-16(fp)
 20365a8:	2809883a 	mov	r4,r5
 20365ac:	3007883a 	mov	r3,r6
 20365b0:	3805883a 	mov	r2,r7
 20365b4:	e13ffd05 	stb	r4,-12(fp)
 20365b8:	e0fffe05 	stb	r3,-8(fp)
 20365bc:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 20365c0:	e0bffc17 	ldw	r2,-16(fp)
 20365c4:	10800617 	ldw	r2,24(r2)
 20365c8:	10800317 	ldw	r2,12(r2)
 20365cc:	10800117 	ldw	r2,4(r2)
 20365d0:	10800217 	ldw	r2,8(r2)
 20365d4:	10800017 	ldw	r2,0(r2)
 20365d8:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 20365dc:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 20365e0:	e03ff915 	stw	zero,-28(fp)
 20365e4:	00000906 	br	203660c <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 20365e8:	e0bff817 	ldw	r2,-32(fp)
 20365ec:	1085883a 	add	r2,r2,r2
 20365f0:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 20365f4:	e0bff817 	ldw	r2,-32(fp)
 20365f8:	10800054 	ori	r2,r2,1
 20365fc:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 2036600:	e0bff917 	ldw	r2,-28(fp)
 2036604:	10800044 	addi	r2,r2,1
 2036608:	e0bff915 	stw	r2,-28(fp)
 203660c:	e0bfff03 	ldbu	r2,-4(fp)
 2036610:	e0fff917 	ldw	r3,-28(fp)
 2036614:	18bff416 	blt	r3,r2,20365e8 <__alt_mem_mem_0+0xfd0165e8>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 2036618:	e0bffa17 	ldw	r2,-24(fp)
 203661c:	10c0a004 	addi	r3,r2,640
 2036620:	e0bffd03 	ldbu	r2,-12(fp)
 2036624:	1085883a 	add	r2,r2,r2
 2036628:	1085883a 	add	r2,r2,r2
 203662c:	1885883a 	add	r2,r3,r2
 2036630:	10800037 	ldwio	r2,0(r2)
 2036634:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 2036638:	e0fffb0b 	ldhu	r3,-20(fp)
 203663c:	e0bffe03 	ldbu	r2,-8(fp)
 2036640:	1885d83a 	sra	r2,r3,r2
 2036644:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 2036648:	e0fffb0b 	ldhu	r3,-20(fp)
 203664c:	e0bff817 	ldw	r2,-32(fp)
 2036650:	1884703a 	and	r2,r3,r2
}
 2036654:	e037883a 	mov	sp,fp
 2036658:	df000017 	ldw	fp,0(sp)
 203665c:	dec00104 	addi	sp,sp,4
 2036660:	f800283a 	ret

02036664 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 2036664:	deff9a04 	addi	sp,sp,-408
 2036668:	dfc06515 	stw	ra,404(sp)
 203666c:	df006415 	stw	fp,400(sp)
 2036670:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 2036674:	e0ff9c04 	addi	r3,fp,-400
 2036678:	00801904 	movi	r2,100
 203667c:	100d883a 	mov	r6,r2
 2036680:	000b883a 	mov	r5,zero
 2036684:	1809883a 	mov	r4,r3
 2036688:	2005fa00 	call	2005fa0 <memset>
 203668c:	009d9cb4 	movhi	r2,30322
 2036690:	10985344 	addi	r2,r2,24909
 2036694:	e0bf9c15 	stw	r2,-400(fp)
 2036698:	00881b34 	movhi	r2,8300
 203669c:	109b1944 	addi	r2,r2,27749
 20366a0:	e0bf9d15 	stw	r2,-396(fp)
 20366a4:	008c5174 	movhi	r2,12613
 20366a8:	108e0e04 	addi	r2,r2,14392
 20366ac:	e0bf9e15 	stw	r2,-392(fp)
 20366b0:	00800c74 	movhi	r2,49
 20366b4:	108c4c44 	addi	r2,r2,12593
 20366b8:	e0bf9f15 	stw	r2,-388(fp)
 20366bc:	e0bfa004 	addi	r2,fp,-384
 20366c0:	00c01004 	movi	r3,64
 20366c4:	180d883a 	mov	r6,r3
 20366c8:	000b883a 	mov	r5,zero
 20366cc:	1009883a 	mov	r4,r2
 20366d0:	2005fa00 	call	2005fa0 <memset>
 20366d4:	009410c4 	movi	r2,20547
 20366d8:	e0bfb015 	stw	r2,-320(fp)
 20366dc:	00800304 	movi	r2,12
 20366e0:	e0bfb105 	stb	r2,-316(fp)
 20366e4:	00800084 	movi	r2,2
 20366e8:	e0bfb145 	stb	r2,-315(fp)
 20366ec:	00800444 	movi	r2,17
 20366f0:	e0bfb185 	stb	r2,-314(fp)
 20366f4:	00800384 	movi	r2,14
 20366f8:	e0bfb1c5 	stb	r2,-313(fp)
 20366fc:	00800344 	movi	r2,13
 2036700:	e0bfb205 	stb	r2,-312(fp)
 2036704:	00800284 	movi	r2,10
 2036708:	e0bfb245 	stb	r2,-311(fp)
 203670c:	00808134 	movhi	r2,516
 2036710:	10a42b04 	addi	r2,r2,-28500
 2036714:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 2036718:	e0bfb504 	addi	r2,fp,-300
 203671c:	00c01904 	movi	r3,100
 2036720:	180d883a 	mov	r6,r3
 2036724:	000b883a 	mov	r5,zero
 2036728:	1009883a 	mov	r4,r2
 203672c:	2005fa00 	call	2005fa0 <memset>
 2036730:	009d9cb4 	movhi	r2,30322
 2036734:	10985344 	addi	r2,r2,24909
 2036738:	e0bfb515 	stw	r2,-300(fp)
 203673c:	00881b34 	movhi	r2,8300
 2036740:	109b1944 	addi	r2,r2,27749
 2036744:	e0bfb615 	stw	r2,-296(fp)
 2036748:	00991874 	movhi	r2,25697
 203674c:	109d5444 	addi	r2,r2,30033
 2036750:	e0bfb715 	stw	r2,-292(fp)
 2036754:	00965234 	movhi	r2,22856
 2036758:	10940804 	addi	r2,r2,20512
 203675c:	e0bfb815 	stw	r2,-288(fp)
 2036760:	00914e34 	movhi	r2,17720
 2036764:	108e0804 	addi	r2,r2,14368
 2036768:	e0bfb915 	stw	r2,-284(fp)
 203676c:	008d4d34 	movhi	r2,13620
 2036770:	108c4c44 	addi	r2,r2,12593
 2036774:	e0bfba15 	stw	r2,-280(fp)
 2036778:	e03fbb15 	stw	zero,-276(fp)
 203677c:	e03fbc15 	stw	zero,-272(fp)
 2036780:	e03fbd15 	stw	zero,-268(fp)
 2036784:	e03fbe15 	stw	zero,-264(fp)
 2036788:	e03fbf15 	stw	zero,-260(fp)
 203678c:	e03fc015 	stw	zero,-256(fp)
 2036790:	e03fc115 	stw	zero,-252(fp)
 2036794:	e03fc215 	stw	zero,-248(fp)
 2036798:	e03fc315 	stw	zero,-244(fp)
 203679c:	e03fc415 	stw	zero,-240(fp)
 20367a0:	e03fc515 	stw	zero,-236(fp)
 20367a4:	e03fc615 	stw	zero,-232(fp)
 20367a8:	e03fc715 	stw	zero,-228(fp)
 20367ac:	e03fc815 	stw	zero,-224(fp)
 20367b0:	009410c4 	movi	r2,20547
 20367b4:	e0bfc915 	stw	r2,-220(fp)
 20367b8:	00800344 	movi	r2,13
 20367bc:	e0bfca05 	stb	r2,-216(fp)
 20367c0:	00800084 	movi	r2,2
 20367c4:	e0bfca45 	stb	r2,-215(fp)
 20367c8:	00800444 	movi	r2,17
 20367cc:	e0bfca85 	stb	r2,-214(fp)
 20367d0:	00800384 	movi	r2,14
 20367d4:	e0bfcac5 	stb	r2,-213(fp)
 20367d8:	00800344 	movi	r2,13
 20367dc:	e0bfcb05 	stb	r2,-212(fp)
 20367e0:	00800284 	movi	r2,10
 20367e4:	e0bfcb45 	stb	r2,-211(fp)
 20367e8:	00808134 	movhi	r2,516
 20367ec:	10a42b04 	addi	r2,r2,-28500
 20367f0:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 20367f4:	e0bfce04 	addi	r2,fp,-200
 20367f8:	00c01904 	movi	r3,100
 20367fc:	180d883a 	mov	r6,r3
 2036800:	000b883a 	mov	r5,zero
 2036804:	1009883a 	mov	r4,r2
 2036808:	2005fa00 	call	2005fa0 <memset>
 203680c:	009a5d34 	movhi	r2,26996
 2036810:	10985384 	addi	r2,r2,24910
 2036814:	e0bfce15 	stw	r2,-200(fp)
 2036818:	009b1874 	movhi	r2,27745
 203681c:	109b9bc4 	addi	r2,r2,28271
 2036820:	e0bfcf15 	stw	r2,-196(fp)
 2036824:	008e1434 	movhi	r2,14416
 2036828:	10910804 	addi	r2,r2,17440
 203682c:	e0bfd015 	stw	r2,-192(fp)
 2036830:	008d4db4 	movhi	r2,13622
 2036834:	108e0cc4 	addi	r2,r2,14387
 2036838:	e0bfd115 	stw	r2,-188(fp)
 203683c:	e03fd215 	stw	zero,-184(fp)
 2036840:	e0bfd304 	addi	r2,fp,-180
 2036844:	00c00f04 	movi	r3,60
 2036848:	180d883a 	mov	r6,r3
 203684c:	000b883a 	mov	r5,zero
 2036850:	1009883a 	mov	r4,r2
 2036854:	2005fa00 	call	2005fa0 <memset>
 2036858:	00800234 	movhi	r2,8
 203685c:	108005c4 	addi	r2,r2,23
 2036860:	e0bfe215 	stw	r2,-120(fp)
 2036864:	008001c4 	movi	r2,7
 2036868:	e0bfe305 	stb	r2,-116(fp)
 203686c:	00800284 	movi	r2,10
 2036870:	e0bfe345 	stb	r2,-115(fp)
 2036874:	00800444 	movi	r2,17
 2036878:	e0bfe385 	stb	r2,-114(fp)
 203687c:	008000c4 	movi	r2,3
 2036880:	e0bfe3c5 	stb	r2,-113(fp)
 2036884:	00800044 	movi	r2,1
 2036888:	e0bfe405 	stb	r2,-112(fp)
 203688c:	00800084 	movi	r2,2
 2036890:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 2036894:	00808134 	movhi	r2,516
 2036898:	109df204 	addi	r2,r2,30664
 203689c:	e0ffe704 	addi	r3,fp,-100
 20368a0:	1009883a 	mov	r4,r2
 20368a4:	00801904 	movi	r2,100
 20368a8:	100d883a 	mov	r6,r2
 20368ac:	200b883a 	mov	r5,r4
 20368b0:	1809883a 	mov	r4,r3
 20368b4:	2005e580 	call	2005e58 <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 20368b8:	e13f9c04 	addi	r4,fp,-400
 20368bc:	20347e00 	call	20347e0 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 20368c0:	e0bfb504 	addi	r2,fp,-300
 20368c4:	1009883a 	mov	r4,r2
 20368c8:	20347e00 	call	20347e0 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 20368cc:	e0bfce04 	addi	r2,fp,-200
 20368d0:	1009883a 	mov	r4,r2
 20368d4:	20347e00 	call	20347e0 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 20368d8:	e0bfe704 	addi	r2,fp,-100
 20368dc:	1009883a 	mov	r4,r2
 20368e0:	20347e00 	call	20347e0 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 20368e4:	d0a80003 	ldbu	r2,-24576(gp)
 20368e8:	10803fcc 	andi	r2,r2,255
}
 20368ec:	e037883a 	mov	sp,fp
 20368f0:	dfc00117 	ldw	ra,4(sp)
 20368f4:	df000017 	ldw	fp,0(sp)
 20368f8:	dec00204 	addi	sp,sp,8
 20368fc:	f800283a 	ret

02036900 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 2036900:	defffd04 	addi	sp,sp,-12
 2036904:	dfc00215 	stw	ra,8(sp)
 2036908:	df000115 	stw	fp,4(sp)
 203690c:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 2036910:	d0a80003 	ldbu	r2,-24576(gp)
 2036914:	10803fcc 	andi	r2,r2,255
 2036918:	100b883a 	mov	r5,r2
 203691c:	01008134 	movhi	r4,516
 2036920:	211e0b04 	addi	r4,r4,30764
 2036924:	20344980 	call	2034498 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 2036928:	e03fff05 	stb	zero,-4(fp)
 203692c:	00006d06 	br	2036ae4 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 2036930:	e0bfff07 	ldb	r2,-4(fp)
 2036934:	100b883a 	mov	r5,r2
 2036938:	01008134 	movhi	r4,516
 203693c:	211e1a04 	addi	r4,r4,30824
 2036940:	20344980 	call	2034498 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 2036944:	e0ffff07 	ldb	r3,-4(fp)
 2036948:	008085f4 	movhi	r2,535
 203694c:	10be3a04 	addi	r2,r2,-1816
 2036950:	18c7883a 	add	r3,r3,r3
 2036954:	18c7883a 	add	r3,r3,r3
 2036958:	10c5883a 	add	r2,r2,r3
 203695c:	10800017 	ldw	r2,0(r2)
 2036960:	100b883a 	mov	r5,r2
 2036964:	01008134 	movhi	r4,516
 2036968:	211e1f04 	addi	r4,r4,30844
 203696c:	20344980 	call	2034498 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 2036970:	e0ffff07 	ldb	r3,-4(fp)
 2036974:	008085f4 	movhi	r2,535
 2036978:	10be3a04 	addi	r2,r2,-1816
 203697c:	18c7883a 	add	r3,r3,r3
 2036980:	18c7883a 	add	r3,r3,r3
 2036984:	10c5883a 	add	r2,r2,r3
 2036988:	10800017 	ldw	r2,0(r2)
 203698c:	10801417 	ldw	r2,80(r2)
 2036990:	100b883a 	mov	r5,r2
 2036994:	01008134 	movhi	r4,516
 2036998:	211e2504 	addi	r4,r4,30868
 203699c:	20344980 	call	2034498 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 20369a0:	e0ffff07 	ldb	r3,-4(fp)
 20369a4:	008085f4 	movhi	r2,535
 20369a8:	10be3a04 	addi	r2,r2,-1816
 20369ac:	18c7883a 	add	r3,r3,r3
 20369b0:	18c7883a 	add	r3,r3,r3
 20369b4:	10c5883a 	add	r2,r2,r3
 20369b8:	10800017 	ldw	r2,0(r2)
 20369bc:	10801503 	ldbu	r2,84(r2)
 20369c0:	10803fcc 	andi	r2,r2,255
 20369c4:	100b883a 	mov	r5,r2
 20369c8:	01008134 	movhi	r4,516
 20369cc:	211e2c04 	addi	r4,r4,30896
 20369d0:	20344980 	call	2034498 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 20369d4:	e0ffff07 	ldb	r3,-4(fp)
 20369d8:	008085f4 	movhi	r2,535
 20369dc:	10be3a04 	addi	r2,r2,-1816
 20369e0:	18c7883a 	add	r3,r3,r3
 20369e4:	18c7883a 	add	r3,r3,r3
 20369e8:	10c5883a 	add	r2,r2,r3
 20369ec:	10800017 	ldw	r2,0(r2)
 20369f0:	10801543 	ldbu	r2,85(r2)
 20369f4:	10803fcc 	andi	r2,r2,255
 20369f8:	100b883a 	mov	r5,r2
 20369fc:	01008134 	movhi	r4,516
 2036a00:	211e3304 	addi	r4,r4,30924
 2036a04:	20344980 	call	2034498 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 2036a08:	e0ffff07 	ldb	r3,-4(fp)
 2036a0c:	008085f4 	movhi	r2,535
 2036a10:	10be3a04 	addi	r2,r2,-1816
 2036a14:	18c7883a 	add	r3,r3,r3
 2036a18:	18c7883a 	add	r3,r3,r3
 2036a1c:	10c5883a 	add	r2,r2,r3
 2036a20:	10800017 	ldw	r2,0(r2)
 2036a24:	10801583 	ldbu	r2,86(r2)
 2036a28:	10803fcc 	andi	r2,r2,255
 2036a2c:	100b883a 	mov	r5,r2
 2036a30:	01008134 	movhi	r4,516
 2036a34:	211e3a04 	addi	r4,r4,30952
 2036a38:	20344980 	call	2034498 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 2036a3c:	e0ffff07 	ldb	r3,-4(fp)
 2036a40:	008085f4 	movhi	r2,535
 2036a44:	10be3a04 	addi	r2,r2,-1816
 2036a48:	18c7883a 	add	r3,r3,r3
 2036a4c:	18c7883a 	add	r3,r3,r3
 2036a50:	10c5883a 	add	r2,r2,r3
 2036a54:	10800017 	ldw	r2,0(r2)
 2036a58:	108015c3 	ldbu	r2,87(r2)
 2036a5c:	10803fcc 	andi	r2,r2,255
 2036a60:	100b883a 	mov	r5,r2
 2036a64:	01008134 	movhi	r4,516
 2036a68:	211e4104 	addi	r4,r4,30980
 2036a6c:	20344980 	call	2034498 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 2036a70:	e0ffff07 	ldb	r3,-4(fp)
 2036a74:	008085f4 	movhi	r2,535
 2036a78:	10be3a04 	addi	r2,r2,-1816
 2036a7c:	18c7883a 	add	r3,r3,r3
 2036a80:	18c7883a 	add	r3,r3,r3
 2036a84:	10c5883a 	add	r2,r2,r3
 2036a88:	10800017 	ldw	r2,0(r2)
 2036a8c:	10801603 	ldbu	r2,88(r2)
 2036a90:	10803fcc 	andi	r2,r2,255
 2036a94:	100b883a 	mov	r5,r2
 2036a98:	01008134 	movhi	r4,516
 2036a9c:	211e4704 	addi	r4,r4,31004
 2036aa0:	20344980 	call	2034498 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 2036aa4:	e0ffff07 	ldb	r3,-4(fp)
 2036aa8:	008085f4 	movhi	r2,535
 2036aac:	10be3a04 	addi	r2,r2,-1816
 2036ab0:	18c7883a 	add	r3,r3,r3
 2036ab4:	18c7883a 	add	r3,r3,r3
 2036ab8:	10c5883a 	add	r2,r2,r3
 2036abc:	10800017 	ldw	r2,0(r2)
 2036ac0:	10801643 	ldbu	r2,89(r2)
 2036ac4:	10803fcc 	andi	r2,r2,255
 2036ac8:	100b883a 	mov	r5,r2
 2036acc:	01008134 	movhi	r4,516
 2036ad0:	211e4d04 	addi	r4,r4,31028
 2036ad4:	20344980 	call	2034498 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 2036ad8:	e0bfff03 	ldbu	r2,-4(fp)
 2036adc:	10800044 	addi	r2,r2,1
 2036ae0:	e0bfff05 	stb	r2,-4(fp)
 2036ae4:	e0ffff07 	ldb	r3,-4(fp)
 2036ae8:	d0a80003 	ldbu	r2,-24576(gp)
 2036aec:	10803fcc 	andi	r2,r2,255
 2036af0:	18bf8f16 	blt	r3,r2,2036930 <__alt_mem_mem_0+0xfd016930>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 2036af4:	d0a80003 	ldbu	r2,-24576(gp)
 2036af8:	10803fcc 	andi	r2,r2,255
}
 2036afc:	e037883a 	mov	sp,fp
 2036b00:	dfc00117 	ldw	ra,4(sp)
 2036b04:	df000017 	ldw	fp,0(sp)
 2036b08:	dec00204 	addi	sp,sp,8
 2036b0c:	f800283a 	ret

02036b10 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 2036b10:	defffa04 	addi	sp,sp,-24
 2036b14:	dfc00515 	stw	ra,20(sp)
 2036b18:	df000415 	stw	fp,16(sp)
 2036b1c:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 2036b20:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 2036b24:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 2036b28:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 2036b2c:	d0280045 	stb	zero,-24575(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 2036b30:	e03ffc05 	stb	zero,-16(fp)
 2036b34:	00019506 	br	203718c <alt_tse_mac_group_init+0x67c>
        psys = &tse_mac_device[i];
 2036b38:	e0bffc07 	ldb	r2,-16(fp)
 2036b3c:	10c01224 	muli	r3,r2,72
 2036b40:	00808174 	movhi	r2,517
 2036b44:	10aaaf04 	addi	r2,r2,-21828
 2036b48:	1885883a 	add	r2,r3,r2
 2036b4c:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 2036b50:	e0bfff17 	ldw	r2,-4(fp)
 2036b54:	10800517 	ldw	r2,20(r2)
 2036b58:	10018926 	beq	r2,zero,2037180 <alt_tse_mac_group_init+0x670>
 2036b5c:	e0bfff17 	ldw	r2,-4(fp)
 2036b60:	10800617 	ldw	r2,24(r2)
 2036b64:	10018626 	beq	r2,zero,2037180 <alt_tse_mac_group_init+0x670>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 2036b68:	d0a80043 	ldbu	r2,-24575(gp)
 2036b6c:	10c03fcc 	andi	r3,r2,255
 2036b70:	e0bfff17 	ldw	r2,-4(fp)
 2036b74:	10800017 	ldw	r2,0(r2)
 2036b78:	100d883a 	mov	r6,r2
 2036b7c:	180b883a 	mov	r5,r3
 2036b80:	01008134 	movhi	r4,516
 2036b84:	211e5304 	addi	r4,r4,31052
 2036b88:	20009e40 	call	20009e4 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 2036b8c:	01000904 	movi	r4,36
 2036b90:	20424000 	call	2042400 <malloc>
 2036b94:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 2036b98:	e0bffd17 	ldw	r2,-12(fp)
 2036b9c:	1000081e 	bne	r2,zero,2036bc0 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 2036ba0:	d0a80043 	ldbu	r2,-24575(gp)
 2036ba4:	10803fcc 	andi	r2,r2,255
 2036ba8:	100b883a 	mov	r5,r2
 2036bac:	01008134 	movhi	r4,516
 2036bb0:	211e5f04 	addi	r4,r4,31100
 2036bb4:	20009e40 	call	20009e4 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 2036bb8:	00bfffc4 	movi	r2,-1
 2036bbc:	00017806 	br	20371a0 <alt_tse_mac_group_init+0x690>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 2036bc0:	e0bfff17 	ldw	r2,-4(fp)
 2036bc4:	108002c3 	ldbu	r2,11(r2)
 2036bc8:	10803fcc 	andi	r2,r2,255
 2036bcc:	10001226 	beq	r2,zero,2036c18 <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 2036bd0:	e0bfff17 	ldw	r2,-4(fp)
 2036bd4:	10c00303 	ldbu	r3,12(r2)
 2036bd8:	e0bffd17 	ldw	r2,-12(fp)
 2036bdc:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 2036be0:	01008134 	movhi	r4,516
 2036be4:	211e6d04 	addi	r4,r4,31156
 2036be8:	20344980 	call	2034498 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 2036bec:	e0bffd17 	ldw	r2,-12(fp)
 2036bf0:	10800003 	ldbu	r2,0(r2)
 2036bf4:	10803fcc 	andi	r2,r2,255
 2036bf8:	100b883a 	mov	r5,r2
 2036bfc:	01008134 	movhi	r4,516
 2036c00:	211e7804 	addi	r4,r4,31200
 2036c04:	20344980 	call	2034498 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 2036c08:	01008134 	movhi	r4,516
 2036c0c:	211e8304 	addi	r4,r4,31244
 2036c10:	20344980 	call	2034498 <no_printf>
 2036c14:	00001f06 	br	2036c94 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 2036c18:	e0bfff17 	ldw	r2,-4(fp)
 2036c1c:	10800343 	ldbu	r2,13(r2)
 2036c20:	10803fcc 	andi	r2,r2,255
 2036c24:	10001226 	beq	r2,zero,2036c70 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 2036c28:	e0bfff17 	ldw	r2,-4(fp)
 2036c2c:	10c00383 	ldbu	r3,14(r2)
 2036c30:	e0bffd17 	ldw	r2,-12(fp)
 2036c34:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 2036c38:	01008134 	movhi	r4,516
 2036c3c:	211e8e04 	addi	r4,r4,31288
 2036c40:	20344980 	call	2034498 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 2036c44:	01008134 	movhi	r4,516
 2036c48:	211e8304 	addi	r4,r4,31244
 2036c4c:	20344980 	call	2034498 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 2036c50:	e0bffd17 	ldw	r2,-12(fp)
 2036c54:	10800003 	ldbu	r2,0(r2)
 2036c58:	10803fcc 	andi	r2,r2,255
 2036c5c:	100b883a 	mov	r5,r2
 2036c60:	01008134 	movhi	r4,516
 2036c64:	211e9904 	addi	r4,r4,31332
 2036c68:	20344980 	call	2034498 <no_printf>
 2036c6c:	00000906 	br	2036c94 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 2036c70:	e0bffd17 	ldw	r2,-12(fp)
 2036c74:	00c00044 	movi	r3,1
 2036c78:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 2036c7c:	01008134 	movhi	r4,516
 2036c80:	211e8e04 	addi	r4,r4,31288
 2036c84:	20344980 	call	2034498 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 2036c88:	01008134 	movhi	r4,516
 2036c8c:	211ea404 	addi	r4,r4,31376
 2036c90:	20344980 	call	2034498 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 2036c94:	e03ffc45 	stb	zero,-15(fp)
 2036c98:	00012206 	br	2037124 <alt_tse_mac_group_init+0x614>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 2036c9c:	01000404 	movi	r4,16
 2036ca0:	20424000 	call	2042400 <malloc>
 2036ca4:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 2036ca8:	e0bffe17 	ldw	r2,-8(fp)
 2036cac:	10000a1e 	bne	r2,zero,2036cd8 <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 2036cb0:	d0a80043 	ldbu	r2,-24575(gp)
 2036cb4:	10803fcc 	andi	r2,r2,255
 2036cb8:	e0fffc47 	ldb	r3,-15(fp)
 2036cbc:	180d883a 	mov	r6,r3
 2036cc0:	100b883a 	mov	r5,r2
 2036cc4:	01008134 	movhi	r4,516
 2036cc8:	211eaf04 	addi	r4,r4,31420
 2036ccc:	20009e40 	call	20009e4 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 2036cd0:	00bfffc4 	movi	r2,-1
 2036cd4:	00013206 	br	20371a0 <alt_tse_mac_group_init+0x690>
                }
                
                pmac_info->pmac_group = pmac_group;
 2036cd8:	e0bffe17 	ldw	r2,-8(fp)
 2036cdc:	e0fffd17 	ldw	r3,-12(fp)
 2036ce0:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 2036ce4:	e0bffe17 	ldw	r2,-8(fp)
 2036ce8:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 2036cec:	e0fffc07 	ldb	r3,-16(fp)
 2036cf0:	e0bffc47 	ldb	r2,-15(fp)
 2036cf4:	1885883a 	add	r2,r3,r2
 2036cf8:	10c01224 	muli	r3,r2,72
 2036cfc:	00808174 	movhi	r2,517
 2036d00:	10aaaf04 	addi	r2,r2,-21828
 2036d04:	1887883a 	add	r3,r3,r2
 2036d08:	e0bffe17 	ldw	r2,-8(fp)
 2036d0c:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 2036d10:	e0bffe17 	ldw	r2,-8(fp)
 2036d14:	10800217 	ldw	r2,8(r2)
 2036d18:	10800517 	ldw	r2,20(r2)
 2036d1c:	10000426 	beq	r2,zero,2036d30 <alt_tse_mac_group_init+0x220>
 2036d20:	e0bffe17 	ldw	r2,-8(fp)
 2036d24:	10800217 	ldw	r2,8(r2)
 2036d28:	10800617 	ldw	r2,24(r2)
 2036d2c:	1000091e 	bne	r2,zero,2036d54 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 2036d30:	e0fffc07 	ldb	r3,-16(fp)
 2036d34:	e0bffc47 	ldb	r2,-15(fp)
 2036d38:	1885883a 	add	r2,r3,r2
 2036d3c:	100b883a 	mov	r5,r2
 2036d40:	01008134 	movhi	r4,516
 2036d44:	211ec104 	addi	r4,r4,31492
 2036d48:	20009e40 	call	20009e4 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2036d4c:	00bfffc4 	movi	r2,-1
 2036d50:	00011306 	br	20371a0 <alt_tse_mac_group_init+0x690>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 2036d54:	e0bffe17 	ldw	r2,-8(fp)
 2036d58:	10800217 	ldw	r2,8(r2)
 2036d5c:	10800243 	ldbu	r2,9(r2)
 2036d60:	10803fcc 	andi	r2,r2,255
 2036d64:	10000d26 	beq	r2,zero,2036d9c <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 2036d68:	e0bffe17 	ldw	r2,-8(fp)
 2036d6c:	10800217 	ldw	r2,8(r2)
 2036d70:	10800283 	ldbu	r2,10(r2)
 2036d74:	10803fcc 	andi	r2,r2,255
 2036d78:	10000426 	beq	r2,zero,2036d8c <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 2036d7c:	e0bffe17 	ldw	r2,-8(fp)
 2036d80:	00c00084 	movi	r3,2
 2036d84:	10c00005 	stb	r3,0(r2)
 2036d88:	00000606 	br	2036da4 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 2036d8c:	e0bffe17 	ldw	r2,-8(fp)
 2036d90:	00c00044 	movi	r3,1
 2036d94:	10c00005 	stb	r3,0(r2)
 2036d98:	00000206 	br	2036da4 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 2036d9c:	e0bffe17 	ldw	r2,-8(fp)
 2036da0:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 2036da4:	e0bffe17 	ldw	r2,-8(fp)
 2036da8:	10800217 	ldw	r2,8(r2)
 2036dac:	10800343 	ldbu	r2,13(r2)
 2036db0:	10803fcc 	andi	r2,r2,255
 2036db4:	10006626 	beq	r2,zero,2036f50 <alt_tse_mac_group_init+0x440>
 2036db8:	e0bffe17 	ldw	r2,-8(fp)
 2036dbc:	10800217 	ldw	r2,8(r2)
 2036dc0:	108002c3 	ldbu	r2,11(r2)
 2036dc4:	10803fcc 	andi	r2,r2,255
 2036dc8:	1000611e 	bne	r2,zero,2036f50 <alt_tse_mac_group_init+0x440>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 2036dcc:	e0fffc47 	ldb	r3,-15(fp)
 2036dd0:	e0bffe17 	ldw	r2,-8(fp)
 2036dd4:	10800217 	ldw	r2,8(r2)
 2036dd8:	10800017 	ldw	r2,0(r2)
 2036ddc:	100d883a 	mov	r6,r2
 2036de0:	180b883a 	mov	r5,r3
 2036de4:	01008134 	movhi	r4,516
 2036de8:	211ed004 	addi	r4,r4,31552
 2036dec:	20344980 	call	2034498 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 2036df0:	e13ffc47 	ldb	r4,-15(fp)
 2036df4:	e0fffc07 	ldb	r3,-16(fp)
 2036df8:	e0bffc47 	ldb	r2,-15(fp)
 2036dfc:	1885883a 	add	r2,r3,r2
 2036e00:	100d883a 	mov	r6,r2
 2036e04:	200b883a 	mov	r5,r4
 2036e08:	01008134 	movhi	r4,516
 2036e0c:	211edc04 	addi	r4,r4,31600
 2036e10:	20344980 	call	2034498 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 2036e14:	e0bffe17 	ldw	r2,-8(fp)
 2036e18:	10800003 	ldbu	r2,0(r2)
 2036e1c:	10803fcc 	andi	r2,r2,255
 2036e20:	10c00060 	cmpeqi	r3,r2,1
 2036e24:	18000c1e 	bne	r3,zero,2036e58 <alt_tse_mac_group_init+0x348>
 2036e28:	10c000a0 	cmpeqi	r3,r2,2
 2036e2c:	1800021e 	bne	r3,zero,2036e38 <alt_tse_mac_group_init+0x328>
 2036e30:	10001126 	beq	r2,zero,2036e78 <alt_tse_mac_group_init+0x368>
 2036e34:	00001806 	br	2036e98 <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 2036e38:	e0bffc47 	ldb	r2,-15(fp)
 2036e3c:	01808134 	movhi	r6,516
 2036e40:	319eeb04 	addi	r6,r6,31660
 2036e44:	100b883a 	mov	r5,r2
 2036e48:	01008134 	movhi	r4,516
 2036e4c:	211ef004 	addi	r4,r4,31680
 2036e50:	20344980 	call	2034498 <no_printf>
                            break;
 2036e54:	00001806 	br	2036eb8 <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 2036e58:	e0bffc47 	ldb	r2,-15(fp)
 2036e5c:	01808134 	movhi	r6,516
 2036e60:	319efb04 	addi	r6,r6,31724
 2036e64:	100b883a 	mov	r5,r2
 2036e68:	01008134 	movhi	r4,516
 2036e6c:	211ef004 	addi	r4,r4,31680
 2036e70:	20344980 	call	2034498 <no_printf>
                            break;
 2036e74:	00001006 	br	2036eb8 <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 2036e78:	e0bffc47 	ldb	r2,-15(fp)
 2036e7c:	01808134 	movhi	r6,516
 2036e80:	319f0104 	addi	r6,r6,31748
 2036e84:	100b883a 	mov	r5,r2
 2036e88:	01008134 	movhi	r4,516
 2036e8c:	211ef004 	addi	r4,r4,31680
 2036e90:	20344980 	call	2034498 <no_printf>
                            break;
 2036e94:	00000806 	br	2036eb8 <alt_tse_mac_group_init+0x3a8>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 2036e98:	e0bffc47 	ldb	r2,-15(fp)
 2036e9c:	01808134 	movhi	r6,516
 2036ea0:	319d3904 	addi	r6,r6,29924
 2036ea4:	100b883a 	mov	r5,r2
 2036ea8:	01008134 	movhi	r4,516
 2036eac:	211ef004 	addi	r4,r4,31680
 2036eb0:	20344980 	call	2034498 <no_printf>
                            break;
 2036eb4:	0001883a 	nop
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 2036eb8:	e0bffe17 	ldw	r2,-8(fp)
 2036ebc:	10800217 	ldw	r2,8(r2)
 2036ec0:	108003c3 	ldbu	r2,15(r2)
 2036ec4:	10803fcc 	andi	r2,r2,255
 2036ec8:	10008b26 	beq	r2,zero,20370f8 <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 2036ecc:	e0fffc47 	ldb	r3,-15(fp)
 2036ed0:	e0bffe17 	ldw	r2,-8(fp)
 2036ed4:	10800217 	ldw	r2,8(r2)
 2036ed8:	108003c3 	ldbu	r2,15(r2)
 2036edc:	10803fcc 	andi	r2,r2,255
 2036ee0:	10000326 	beq	r2,zero,2036ef0 <alt_tse_mac_group_init+0x3e0>
 2036ee4:	00808134 	movhi	r2,516
 2036ee8:	109f0804 	addi	r2,r2,31776
 2036eec:	00000206 	br	2036ef8 <alt_tse_mac_group_init+0x3e8>
 2036ef0:	00808134 	movhi	r2,516
 2036ef4:	109f0904 	addi	r2,r2,31780
 2036ef8:	100d883a 	mov	r6,r2
 2036efc:	180b883a 	mov	r5,r3
 2036f00:	01008134 	movhi	r4,516
 2036f04:	211f0a04 	addi	r4,r4,31784
 2036f08:	20344980 	call	2034498 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 2036f0c:	e0fffc47 	ldb	r3,-15(fp)
 2036f10:	e0bffe17 	ldw	r2,-8(fp)
 2036f14:	10800217 	ldw	r2,8(r2)
 2036f18:	10800403 	ldbu	r2,16(r2)
 2036f1c:	10803fcc 	andi	r2,r2,255
 2036f20:	10000326 	beq	r2,zero,2036f30 <alt_tse_mac_group_init+0x420>
 2036f24:	00808134 	movhi	r2,516
 2036f28:	109f0804 	addi	r2,r2,31776
 2036f2c:	00000206 	br	2036f38 <alt_tse_mac_group_init+0x428>
 2036f30:	00808134 	movhi	r2,516
 2036f34:	109f0904 	addi	r2,r2,31780
 2036f38:	100d883a 	mov	r6,r2
 2036f3c:	180b883a 	mov	r5,r3
 2036f40:	01008134 	movhi	r4,516
 2036f44:	211f1504 	addi	r4,r4,31828
 2036f48:	20344980 	call	2034498 <no_printf>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                            break;
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 2036f4c:	00006a06 	br	20370f8 <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 2036f50:	e0bffc47 	ldb	r2,-15(fp)
 2036f54:	1000421e 	bne	r2,zero,2037060 <alt_tse_mac_group_init+0x550>
	                    switch(pmac_info->mac_type) {
 2036f58:	e0bffe17 	ldw	r2,-8(fp)
 2036f5c:	10800003 	ldbu	r2,0(r2)
 2036f60:	10803fcc 	andi	r2,r2,255
 2036f64:	10c00060 	cmpeqi	r3,r2,1
 2036f68:	18000a1e 	bne	r3,zero,2036f94 <alt_tse_mac_group_init+0x484>
 2036f6c:	10c000a0 	cmpeqi	r3,r2,2
 2036f70:	1800021e 	bne	r3,zero,2036f7c <alt_tse_mac_group_init+0x46c>
 2036f74:	10000d26 	beq	r2,zero,2036fac <alt_tse_mac_group_init+0x49c>
 2036f78:	00001206 	br	2036fc4 <alt_tse_mac_group_init+0x4b4>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 2036f7c:	01408134 	movhi	r5,516
 2036f80:	295eeb04 	addi	r5,r5,31660
 2036f84:	01008134 	movhi	r4,516
 2036f88:	211f2004 	addi	r4,r4,31872
 2036f8c:	20344980 	call	2034498 <no_printf>
	                            break;
 2036f90:	00001206 	br	2036fdc <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 2036f94:	01408134 	movhi	r5,516
 2036f98:	295efb04 	addi	r5,r5,31724
 2036f9c:	01008134 	movhi	r4,516
 2036fa0:	211f2004 	addi	r4,r4,31872
 2036fa4:	20344980 	call	2034498 <no_printf>
	                            break;
 2036fa8:	00000c06 	br	2036fdc <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 2036fac:	01408134 	movhi	r5,516
 2036fb0:	295f0104 	addi	r5,r5,31748
 2036fb4:	01008134 	movhi	r4,516
 2036fb8:	211f2004 	addi	r4,r4,31872
 2036fbc:	20344980 	call	2034498 <no_printf>
	                            break;
 2036fc0:	00000606 	br	2036fdc <alt_tse_mac_group_init+0x4cc>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 2036fc4:	01408134 	movhi	r5,516
 2036fc8:	295d3904 	addi	r5,r5,29924
 2036fcc:	01008134 	movhi	r4,516
 2036fd0:	211f2004 	addi	r4,r4,31872
 2036fd4:	20344980 	call	2034498 <no_printf>
                                    break;
 2036fd8:	0001883a 	nop
			    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 2036fdc:	e0bffe17 	ldw	r2,-8(fp)
 2036fe0:	10800217 	ldw	r2,8(r2)
 2036fe4:	108003c3 	ldbu	r2,15(r2)
 2036fe8:	10803fcc 	andi	r2,r2,255
 2036fec:	10001c26 	beq	r2,zero,2037060 <alt_tse_mac_group_init+0x550>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 2036ff0:	e0bffe17 	ldw	r2,-8(fp)
 2036ff4:	10800217 	ldw	r2,8(r2)
 2036ff8:	108003c3 	ldbu	r2,15(r2)
 2036ffc:	10803fcc 	andi	r2,r2,255
 2037000:	10000326 	beq	r2,zero,2037010 <alt_tse_mac_group_init+0x500>
 2037004:	00808134 	movhi	r2,516
 2037008:	109f0804 	addi	r2,r2,31776
 203700c:	00000206 	br	2037018 <alt_tse_mac_group_init+0x508>
 2037010:	00808134 	movhi	r2,516
 2037014:	109f0904 	addi	r2,r2,31780
 2037018:	100b883a 	mov	r5,r2
 203701c:	01008134 	movhi	r4,516
 2037020:	211f2b04 	addi	r4,r4,31916
 2037024:	20344980 	call	2034498 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 2037028:	e0bffe17 	ldw	r2,-8(fp)
 203702c:	10800217 	ldw	r2,8(r2)
 2037030:	10800403 	ldbu	r2,16(r2)
 2037034:	10803fcc 	andi	r2,r2,255
 2037038:	10000326 	beq	r2,zero,2037048 <alt_tse_mac_group_init+0x538>
 203703c:	00808134 	movhi	r2,516
 2037040:	109f0804 	addi	r2,r2,31776
 2037044:	00000206 	br	2037050 <alt_tse_mac_group_init+0x540>
 2037048:	00808134 	movhi	r2,516
 203704c:	109f0904 	addi	r2,r2,31780
 2037050:	100b883a 	mov	r5,r2
 2037054:	01008134 	movhi	r4,516
 2037058:	211f3604 	addi	r4,r4,31960
 203705c:	20344980 	call	2034498 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 2037060:	e0bffe17 	ldw	r2,-8(fp)
 2037064:	10800217 	ldw	r2,8(r2)
 2037068:	108002c3 	ldbu	r2,11(r2)
 203706c:	10803fcc 	andi	r2,r2,255
 2037070:	10001326 	beq	r2,zero,20370c0 <alt_tse_mac_group_init+0x5b0>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 2037074:	e0fffc47 	ldb	r3,-15(fp)
 2037078:	e0bffe17 	ldw	r2,-8(fp)
 203707c:	10800217 	ldw	r2,8(r2)
 2037080:	10800017 	ldw	r2,0(r2)
 2037084:	100d883a 	mov	r6,r2
 2037088:	180b883a 	mov	r5,r3
 203708c:	01008134 	movhi	r4,516
 2037090:	211f4104 	addi	r4,r4,32004
 2037094:	20344980 	call	2034498 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 2037098:	e13ffc47 	ldb	r4,-15(fp)
 203709c:	e0fffc07 	ldb	r3,-16(fp)
 20370a0:	e0bffc47 	ldb	r2,-15(fp)
 20370a4:	1885883a 	add	r2,r3,r2
 20370a8:	100d883a 	mov	r6,r2
 20370ac:	200b883a 	mov	r5,r4
 20370b0:	01008134 	movhi	r4,516
 20370b4:	211f4d04 	addi	r4,r4,32052
 20370b8:	20344980 	call	2034498 <no_printf>
 20370bc:	00000e06 	br	20370f8 <alt_tse_mac_group_init+0x5e8>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 20370c0:	e0bffe17 	ldw	r2,-8(fp)
 20370c4:	10800217 	ldw	r2,8(r2)
 20370c8:	10800017 	ldw	r2,0(r2)
 20370cc:	100b883a 	mov	r5,r2
 20370d0:	01008134 	movhi	r4,516
 20370d4:	211f5c04 	addi	r4,r4,32112
 20370d8:	20344980 	call	2034498 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 20370dc:	e0fffc07 	ldb	r3,-16(fp)
 20370e0:	e0bffc47 	ldb	r2,-15(fp)
 20370e4:	1885883a 	add	r2,r3,r2
 20370e8:	100b883a 	mov	r5,r2
 20370ec:	01008134 	movhi	r4,516
 20370f0:	211f6804 	addi	r4,r4,32160
 20370f4:	20344980 	call	2034498 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 20370f8:	e0bffc47 	ldb	r2,-15(fp)
 20370fc:	e0fffd17 	ldw	r3,-12(fp)
 2037100:	10800044 	addi	r2,r2,1
 2037104:	1085883a 	add	r2,r2,r2
 2037108:	1085883a 	add	r2,r2,r2
 203710c:	1885883a 	add	r2,r3,r2
 2037110:	e0fffe17 	ldw	r3,-8(fp)
 2037114:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 2037118:	e0bffc43 	ldbu	r2,-15(fp)
 203711c:	10800044 	addi	r2,r2,1
 2037120:	e0bffc45 	stb	r2,-15(fp)
 2037124:	e0fffc47 	ldb	r3,-15(fp)
 2037128:	e0bffd17 	ldw	r2,-12(fp)
 203712c:	10800003 	ldbu	r2,0(r2)
 2037130:	10803fcc 	andi	r2,r2,255
 2037134:	18bed916 	blt	r3,r2,2036c9c <__alt_mem_mem_0+0xfd016c9c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 2037138:	d0a80043 	ldbu	r2,-24575(gp)
 203713c:	10c03fcc 	andi	r3,r2,255
 2037140:	008085f4 	movhi	r2,535
 2037144:	10be3204 	addi	r2,r2,-1848
 2037148:	18c7883a 	add	r3,r3,r3
 203714c:	18c7883a 	add	r3,r3,r3
 2037150:	10c5883a 	add	r2,r2,r3
 2037154:	e0fffd17 	ldw	r3,-12(fp)
 2037158:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 203715c:	d0a80043 	ldbu	r2,-24575(gp)
 2037160:	10800044 	addi	r2,r2,1
 2037164:	d0a80045 	stb	r2,-24575(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 2037168:	e0bffd17 	ldw	r2,-12(fp)
 203716c:	10c00003 	ldbu	r3,0(r2)
 2037170:	e0bffc03 	ldbu	r2,-16(fp)
 2037174:	1885883a 	add	r2,r3,r2
 2037178:	10bfffc4 	addi	r2,r2,-1
 203717c:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 2037180:	e0bffc03 	ldbu	r2,-16(fp)
 2037184:	10800044 	addi	r2,r2,1
 2037188:	e0bffc05 	stb	r2,-16(fp)
 203718c:	e0fffc07 	ldb	r3,-16(fp)
 2037190:	d0a01f03 	ldbu	r2,-32644(gp)
 2037194:	10803fcc 	andi	r2,r2,255
 2037198:	18be6716 	blt	r3,r2,2036b38 <__alt_mem_mem_0+0xfd016b38>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 203719c:	0005883a 	mov	r2,zero
}
 20371a0:	e037883a 	mov	sp,fp
 20371a4:	dfc00117 	ldw	ra,4(sp)
 20371a8:	df000017 	ldw	fp,0(sp)
 20371ac:	dec00204 	addi	sp,sp,8
 20371b0:	f800283a 	ret

020371b4 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 20371b4:	deffed04 	addi	sp,sp,-76
 20371b8:	dfc01215 	stw	ra,72(sp)
 20371bc:	df001115 	stw	fp,68(sp)
 20371c0:	df001104 	addi	fp,sp,68
 20371c4:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 20371c8:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 20371cc:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 20371d0:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 20371d4:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 20371d8:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 20371dc:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 20371e0:	e0bfff17 	ldw	r2,-4(fp)
 20371e4:	10800117 	ldw	r2,4(r2)
 20371e8:	10800217 	ldw	r2,8(r2)
 20371ec:	10800017 	ldw	r2,0(r2)
 20371f0:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 20371f4:	e0bff917 	ldw	r2,-28(fp)
 20371f8:	10801004 	addi	r2,r2,64
 20371fc:	10800037 	ldwio	r2,0(r2)
 2037200:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2037204:	e13fff17 	ldw	r4,-4(fp)
 2037208:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 203720c:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x01; phyadd < 0x20; phyadd++)
 2037210:	00800044 	movi	r2,1
 2037214:	e0bff005 	stb	r2,-64(fp)
 2037218:	0000ca06 	br	2037544 <alt_tse_mac_get_phy+0x390>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 203721c:	e0bff917 	ldw	r2,-28(fp)
 2037220:	10801004 	addi	r2,r2,64
 2037224:	e0fff003 	ldbu	r3,-64(fp)
 2037228:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 203722c:	e0bff917 	ldw	r2,-28(fp)
 2037230:	1080a204 	addi	r2,r2,648
 2037234:	10800037 	ldwio	r2,0(r2)
 2037238:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 203723c:	e0bff917 	ldw	r2,-28(fp)
 2037240:	1080a304 	addi	r2,r2,652
 2037244:	10800037 	ldwio	r2,0(r2)
 2037248:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 203724c:	e0fffc17 	ldw	r3,-16(fp)
 2037250:	e0bff517 	ldw	r2,-44(fp)
 2037254:	1880b826 	beq	r3,r2,2037538 <alt_tse_mac_get_phy+0x384>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 2037258:	01000704 	movi	r4,28
 203725c:	20424000 	call	2042400 <malloc>
 2037260:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 2037264:	e0bff617 	ldw	r2,-40(fp)
 2037268:	1000091e 	bne	r2,zero,2037290 <alt_tse_mac_get_phy+0xdc>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 203726c:	e0bffb07 	ldb	r2,-20(fp)
 2037270:	e0fff407 	ldb	r3,-48(fp)
 2037274:	180d883a 	mov	r6,r3
 2037278:	100b883a 	mov	r5,r2
 203727c:	01008134 	movhi	r4,516
 2037280:	211f7704 	addi	r4,r4,32220
 2037284:	20009e40 	call	20009e4 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 2037288:	00bfffc4 	movi	r2,-1
 203728c:	0000cd06 	br	20375c4 <alt_tse_mac_get_phy+0x410>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 2037290:	e0bff617 	ldw	r2,-40(fp)
 2037294:	e0fff003 	ldbu	r3,-64(fp)
 2037298:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 203729c:	e0bffc17 	ldw	r2,-16(fp)
 20372a0:	100691ba 	slli	r3,r2,6
 20372a4:	e0bff517 	ldw	r2,-44(fp)
 20372a8:	1005d2ba 	srai	r2,r2,10
 20372ac:	10800fcc 	andi	r2,r2,63
 20372b0:	1884b03a 	or	r2,r3,r2
 20372b4:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 20372b8:	e0bff517 	ldw	r2,-44(fp)
 20372bc:	1005d13a 	srai	r2,r2,4
 20372c0:	10800fcc 	andi	r2,r2,63
 20372c4:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 20372c8:	e0bff517 	ldw	r2,-44(fp)
 20372cc:	108003cc 	andi	r2,r2,15
 20372d0:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 20372d4:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 20372d8:	e03ff115 	stw	zero,-60(fp)
 20372dc:	00003406 	br	20373b0 <alt_tse_mac_get_phy+0x1fc>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 20372e0:	008085f4 	movhi	r2,535
 20372e4:	10be3a04 	addi	r2,r2,-1816
 20372e8:	e0fff117 	ldw	r3,-60(fp)
 20372ec:	18c7883a 	add	r3,r3,r3
 20372f0:	18c7883a 	add	r3,r3,r3
 20372f4:	10c5883a 	add	r2,r2,r3
 20372f8:	10800017 	ldw	r2,0(r2)
 20372fc:	10c01417 	ldw	r3,80(r2)
 2037300:	e0bffd17 	ldw	r2,-12(fp)
 2037304:	1880271e 	bne	r3,r2,20373a4 <alt_tse_mac_get_phy+0x1f0>
 2037308:	008085f4 	movhi	r2,535
 203730c:	10be3a04 	addi	r2,r2,-1816
 2037310:	e0fff117 	ldw	r3,-60(fp)
 2037314:	18c7883a 	add	r3,r3,r3
 2037318:	18c7883a 	add	r3,r3,r3
 203731c:	10c5883a 	add	r2,r2,r3
 2037320:	10800017 	ldw	r2,0(r2)
 2037324:	10801503 	ldbu	r2,84(r2)
 2037328:	10c03fcc 	andi	r3,r2,255
 203732c:	e0bffe03 	ldbu	r2,-8(fp)
 2037330:	18801c1e 	bne	r3,r2,20373a4 <alt_tse_mac_get_phy+0x1f0>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 2037334:	008085f4 	movhi	r2,535
 2037338:	10be3a04 	addi	r2,r2,-1816
 203733c:	e0fff117 	ldw	r3,-60(fp)
 2037340:	18c7883a 	add	r3,r3,r3
 2037344:	18c7883a 	add	r3,r3,r3
 2037348:	10c5883a 	add	r2,r2,r3
 203734c:	10c00017 	ldw	r3,0(r2)
 2037350:	e0bff617 	ldw	r2,-40(fp)
 2037354:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 2037358:	008085f4 	movhi	r2,535
 203735c:	10be3a04 	addi	r2,r2,-1816
 2037360:	e0fff117 	ldw	r3,-60(fp)
 2037364:	18c7883a 	add	r3,r3,r3
 2037368:	18c7883a 	add	r3,r3,r3
 203736c:	10c5883a 	add	r2,r2,r3
 2037370:	10800017 	ldw	r2,0(r2)
 2037374:	1009883a 	mov	r4,r2
 2037378:	e0bff003 	ldbu	r2,-64(fp)
 203737c:	e0fffb07 	ldb	r3,-20(fp)
 2037380:	180f883a 	mov	r7,r3
 2037384:	100d883a 	mov	r6,r2
 2037388:	200b883a 	mov	r5,r4
 203738c:	01008134 	movhi	r4,516
 2037390:	211f8604 	addi	r4,r4,32280
 2037394:	20009e40 	call	20009e4 <printf>
                    is_phy_in_profile = 1;
 2037398:	00800044 	movi	r2,1
 203739c:	e0bff205 	stb	r2,-56(fp)
                    break;
 20373a0:	00000706 	br	20373c0 <alt_tse_mac_get_phy+0x20c>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 20373a4:	e0bff117 	ldw	r2,-60(fp)
 20373a8:	10800044 	addi	r2,r2,1
 20373ac:	e0bff115 	stw	r2,-60(fp)
 20373b0:	d0a80003 	ldbu	r2,-24576(gp)
 20373b4:	10803fcc 	andi	r2,r2,255
 20373b8:	e0fff117 	ldw	r3,-60(fp)
 20373bc:	18bfc816 	blt	r3,r2,20372e0 <__alt_mem_mem_0+0xfd0172e0>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 20373c0:	e0bff203 	ldbu	r2,-56(fp)
 20373c4:	10000f1e 	bne	r2,zero,2037404 <alt_tse_mac_get_phy+0x250>
                pphy->pphy_profile = 0;
 20373c8:	e0bff617 	ldw	r2,-40(fp)
 20373cc:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 20373d0:	e0bff003 	ldbu	r2,-64(fp)
 20373d4:	e0fffb07 	ldb	r3,-20(fp)
 20373d8:	180d883a 	mov	r6,r3
 20373dc:	100b883a 	mov	r5,r2
 20373e0:	01008134 	movhi	r4,516
 20373e4:	211f9604 	addi	r4,r4,32344
 20373e8:	20009e40 	call	20009e4 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 20373ec:	01008134 	movhi	r4,516
 20373f0:	211fa704 	addi	r4,r4,32412
 20373f4:	20426cc0 	call	20426cc <puts>
                return_value++;
 20373f8:	e0bff317 	ldw	r2,-52(fp)
 20373fc:	10800044 	addi	r2,r2,1
 2037400:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 2037404:	e0bffd17 	ldw	r2,-12(fp)
 2037408:	100b883a 	mov	r5,r2
 203740c:	01008134 	movhi	r4,516
 2037410:	211fb404 	addi	r4,r4,32464
 2037414:	20344980 	call	2034498 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 2037418:	e0bffe03 	ldbu	r2,-8(fp)
 203741c:	100b883a 	mov	r5,r2
 2037420:	01008134 	movhi	r4,516
 2037424:	211fbf04 	addi	r4,r4,32508
 2037428:	20344980 	call	2034498 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 203742c:	e0bffe43 	ldbu	r2,-7(fp)
 2037430:	100b883a 	mov	r5,r2
 2037434:	01008134 	movhi	r4,516
 2037438:	211fca04 	addi	r4,r4,32552
 203743c:	20344980 	call	2034498 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 2037440:	e17ff617 	ldw	r5,-40(fp)
 2037444:	e13fff17 	ldw	r4,-4(fp)
 2037448:	20375d80 	call	20375d8 <alt_tse_mac_associate_phy>
 203744c:	1000341e 	bne	r2,zero,2037520 <alt_tse_mac_get_phy+0x36c>
            	
            	pmac_info = pphy->pmac_info;
 2037450:	e0bff617 	ldw	r2,-40(fp)
 2037454:	10800617 	ldw	r2,24(r2)
 2037458:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 203745c:	e0bff717 	ldw	r2,-36(fp)
 2037460:	10800217 	ldw	r2,8(r2)
 2037464:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 2037468:	d8000015 	stw	zero,0(sp)
 203746c:	01c00044 	movi	r7,1
 2037470:	01800384 	movi	r6,14
 2037474:	000b883a 	mov	r5,zero
 2037478:	e13ff617 	ldw	r4,-40(fp)
 203747c:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 2037480:	01400044 	movi	r5,1
 2037484:	e13ff617 	ldw	r4,-40(fp)
 2037488:	20383100 	call	2038310 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 203748c:	01400044 	movi	r5,1
 2037490:	e13ff617 	ldw	r4,-40(fp)
 2037494:	20384d40 	call	20384d4 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 2037498:	01400044 	movi	r5,1
 203749c:	e13ff617 	ldw	r4,-40(fp)
 20374a0:	20387280 	call	2038728 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 20374a4:	017e0034 	movhi	r5,63488
 20374a8:	e13ff617 	ldw	r4,-40(fp)
 20374ac:	2037a600 	call	2037a60 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 20374b0:	e0bff617 	ldw	r2,-40(fp)
 20374b4:	10800517 	ldw	r2,20(r2)
 20374b8:	10000f26 	beq	r2,zero,20374f8 <alt_tse_mac_get_phy+0x344>
		            if(pphy->pphy_profile->phy_cfg) {
 20374bc:	e0bff617 	ldw	r2,-40(fp)
 20374c0:	10800517 	ldw	r2,20(r2)
 20374c4:	10801717 	ldw	r2,92(r2)
 20374c8:	10000b26 	beq	r2,zero,20374f8 <alt_tse_mac_get_phy+0x344>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 20374cc:	e0bff617 	ldw	r2,-40(fp)
 20374d0:	10800517 	ldw	r2,20(r2)
 20374d4:	100b883a 	mov	r5,r2
 20374d8:	01008134 	movhi	r4,516
 20374dc:	211fd504 	addi	r4,r4,32596
 20374e0:	20344980 	call	2034498 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 20374e4:	e0bff617 	ldw	r2,-40(fp)
 20374e8:	10800517 	ldw	r2,20(r2)
 20374ec:	10801717 	ldw	r2,92(r2)
 20374f0:	e13ff917 	ldw	r4,-28(fp)
 20374f4:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 20374f8:	e0bff817 	ldw	r2,-32(fp)
 20374fc:	10801117 	ldw	r2,68(r2)
 2037500:	10000726 	beq	r2,zero,2037520 <alt_tse_mac_get_phy+0x36c>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 2037504:	01008134 	movhi	r4,516
 2037508:	211fe304 	addi	r4,r4,32652
 203750c:	20344980 	call	2034498 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 2037510:	e0bff817 	ldw	r2,-32(fp)
 2037514:	10801117 	ldw	r2,68(r2)
 2037518:	e13ff917 	ldw	r4,-28(fp)
 203751c:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 2037520:	01008134 	movhi	r4,516
 2037524:	211ff104 	addi	r4,r4,32708
 2037528:	20344980 	call	2034498 <no_printf>
	            
            phy_info_count++;
 203752c:	e0bff403 	ldbu	r2,-48(fp)
 2037530:	10800044 	addi	r2,r2,1
 2037534:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x01; phyadd < 0x20; phyadd++)
 2037538:	e0bff003 	ldbu	r2,-64(fp)
 203753c:	10800044 	addi	r2,r2,1
 2037540:	e0bff005 	stb	r2,-64(fp)
 2037544:	e0bff003 	ldbu	r2,-64(fp)
 2037548:	10800830 	cmpltui	r2,r2,32
 203754c:	103f331e 	bne	r2,zero,203721c <__alt_mem_mem_0+0xfd01721c>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 2037550:	e0bfff17 	ldw	r2,-4(fp)
 2037554:	10800003 	ldbu	r2,0(r2)
 2037558:	10c03fcc 	andi	r3,r2,255
 203755c:	e0bff407 	ldb	r2,-48(fp)
 2037560:	18801326 	beq	r3,r2,20375b0 <alt_tse_mac_get_phy+0x3fc>
        if(phy_info_count == 0) {
 2037564:	e0bff407 	ldb	r2,-48(fp)
 2037568:	1000061e 	bne	r2,zero,2037584 <alt_tse_mac_get_phy+0x3d0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 203756c:	e0bffb07 	ldb	r2,-20(fp)
 2037570:	100b883a 	mov	r5,r2
 2037574:	01008134 	movhi	r4,516
 2037578:	211ff204 	addi	r4,r4,32712
 203757c:	20009e40 	call	20009e4 <printf>
 2037580:	00000b06 	br	20375b0 <alt_tse_mac_get_phy+0x3fc>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 2037584:	e0fffb07 	ldb	r3,-20(fp)
 2037588:	e13ff407 	ldb	r4,-48(fp)
 203758c:	e0bfff17 	ldw	r2,-4(fp)
 2037590:	10800003 	ldbu	r2,0(r2)
 2037594:	10803fcc 	andi	r2,r2,255
 2037598:	100f883a 	mov	r7,r2
 203759c:	200d883a 	mov	r6,r4
 20375a0:	180b883a 	mov	r5,r3
 20375a4:	01008134 	movhi	r4,516
 20375a8:	211ffe04 	addi	r4,r4,32760
 20375ac:	20009e40 	call	20009e4 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 20375b0:	e0bff917 	ldw	r2,-28(fp)
 20375b4:	10801004 	addi	r2,r2,64
 20375b8:	e0fffa17 	ldw	r3,-24(fp)
 20375bc:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 20375c0:	e0bff317 	ldw	r2,-52(fp)
}
 20375c4:	e037883a 	mov	sp,fp
 20375c8:	dfc00117 	ldw	ra,4(sp)
 20375cc:	df000017 	ldw	fp,0(sp)
 20375d0:	dec00204 	addi	sp,sp,8
 20375d4:	f800283a 	ret

020375d8 <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 20375d8:	defff604 	addi	sp,sp,-40
 20375dc:	dfc00915 	stw	ra,36(sp)
 20375e0:	df000815 	stw	fp,32(sp)
 20375e4:	df000804 	addi	fp,sp,32
 20375e8:	e13ffe15 	stw	r4,-8(fp)
 20375ec:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 20375f0:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 20375f4:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 20375f8:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 20375fc:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2037600:	e13ffe17 	ldw	r4,-8(fp)
 2037604:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2037608:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 203760c:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 2037610:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 2037614:	e03ff815 	stw	zero,-32(fp)
 2037618:	00002c06 	br	20376cc <alt_tse_mac_associate_phy+0xf4>
        pmac_info = pmac_group->pmac_info[i];
 203761c:	e0fffe17 	ldw	r3,-8(fp)
 2037620:	e0bff817 	ldw	r2,-32(fp)
 2037624:	10800044 	addi	r2,r2,1
 2037628:	1085883a 	add	r2,r2,r2
 203762c:	1085883a 	add	r2,r2,r2
 2037630:	1885883a 	add	r2,r3,r2
 2037634:	10800017 	ldw	r2,0(r2)
 2037638:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 203763c:	e0bffc17 	ldw	r2,-16(fp)
 2037640:	10800217 	ldw	r2,8(r2)
 2037644:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 2037648:	e0bffb17 	ldw	r2,-20(fp)
 203764c:	10c01017 	ldw	r3,64(r2)
 2037650:	e0bfff17 	ldw	r2,-4(fp)
 2037654:	10800003 	ldbu	r2,0(r2)
 2037658:	10803fcc 	andi	r2,r2,255
 203765c:	1880181e 	bne	r3,r2,20376c0 <alt_tse_mac_associate_phy+0xe8>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2037660:	e13ffc17 	ldw	r4,-16(fp)
 2037664:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2037668:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 203766c:	e13ffb17 	ldw	r4,-20(fp)
 2037670:	20355b00 	call	20355b0 <alt_tse_get_system_index>
 2037674:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 2037678:	e0bffc17 	ldw	r2,-16(fp)
 203767c:	e0ffff17 	ldw	r3,-4(fp)
 2037680:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 2037684:	e0bfff17 	ldw	r2,-4(fp)
 2037688:	e0fffc17 	ldw	r3,-16(fp)
 203768c:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 2037690:	e0bffd47 	ldb	r2,-11(fp)
 2037694:	e0fffd07 	ldb	r3,-12(fp)
 2037698:	e13ffd87 	ldb	r4,-10(fp)
 203769c:	200f883a 	mov	r7,r4
 20376a0:	180d883a 	mov	r6,r3
 20376a4:	100b883a 	mov	r5,r2
 20376a8:	01008174 	movhi	r4,517
 20376ac:	21201d04 	addi	r4,r4,-32652
 20376b0:	20009e40 	call	20009e4 <printf>
            is_mapped = 1;
 20376b4:	00800044 	movi	r2,1
 20376b8:	e0bffa05 	stb	r2,-24(fp)
            break;
 20376bc:	00000806 	br	20376e0 <alt_tse_mac_associate_phy+0x108>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 20376c0:	e0bff817 	ldw	r2,-32(fp)
 20376c4:	10800044 	addi	r2,r2,1
 20376c8:	e0bff815 	stw	r2,-32(fp)
 20376cc:	e0bffe17 	ldw	r2,-8(fp)
 20376d0:	10800003 	ldbu	r2,0(r2)
 20376d4:	10803fcc 	andi	r2,r2,255
 20376d8:	e0fff817 	ldw	r3,-32(fp)
 20376dc:	18bfcf16 	blt	r3,r2,203761c <__alt_mem_mem_0+0xfd01761c>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 20376e0:	e0bffa03 	ldbu	r2,-24(fp)
 20376e4:	10003d1e 	bne	r2,zero,20377dc <alt_tse_mac_associate_phy+0x204>
        for(i = 0; i < pmac_group->channel; i++) {
 20376e8:	e03ff815 	stw	zero,-32(fp)
 20376ec:	00003606 	br	20377c8 <alt_tse_mac_associate_phy+0x1f0>
            pmac_info = pmac_group->pmac_info[i];
 20376f0:	e0fffe17 	ldw	r3,-8(fp)
 20376f4:	e0bff817 	ldw	r2,-32(fp)
 20376f8:	10800044 	addi	r2,r2,1
 20376fc:	1085883a 	add	r2,r2,r2
 2037700:	1085883a 	add	r2,r2,r2
 2037704:	1885883a 	add	r2,r3,r2
 2037708:	10800017 	ldw	r2,0(r2)
 203770c:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 2037710:	e0bffc17 	ldw	r2,-16(fp)
 2037714:	10800217 	ldw	r2,8(r2)
 2037718:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 203771c:	e0bffb17 	ldw	r2,-20(fp)
 2037720:	10800517 	ldw	r2,20(r2)
 2037724:	10002426 	beq	r2,zero,20377b8 <alt_tse_mac_associate_phy+0x1e0>
 2037728:	e0bffb17 	ldw	r2,-20(fp)
 203772c:	10800617 	ldw	r2,24(r2)
 2037730:	10002126 	beq	r2,zero,20377b8 <alt_tse_mac_associate_phy+0x1e0>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 2037734:	e0bffb17 	ldw	r2,-20(fp)
 2037738:	10801017 	ldw	r2,64(r2)
 203773c:	10bfffd8 	cmpnei	r2,r2,-1
 2037740:	10001e1e 	bne	r2,zero,20377bc <alt_tse_mac_associate_phy+0x1e4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2037744:	e13ffc17 	ldw	r4,-16(fp)
 2037748:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 203774c:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 2037750:	e13ffb17 	ldw	r4,-20(fp)
 2037754:	20355b00 	call	20355b0 <alt_tse_get_system_index>
 2037758:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 203775c:	e0bffc17 	ldw	r2,-16(fp)
 2037760:	e0ffff17 	ldw	r3,-4(fp)
 2037764:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 2037768:	e0bfff17 	ldw	r2,-4(fp)
 203776c:	e0fffc17 	ldw	r3,-16(fp)
 2037770:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 2037774:	e0bfff17 	ldw	r2,-4(fp)
 2037778:	10800003 	ldbu	r2,0(r2)
 203777c:	10c03fcc 	andi	r3,r2,255
 2037780:	e0bffb17 	ldw	r2,-20(fp)
 2037784:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 2037788:	e0bffd47 	ldb	r2,-11(fp)
 203778c:	e0fffd07 	ldb	r3,-12(fp)
 2037790:	e13ffd87 	ldb	r4,-10(fp)
 2037794:	200f883a 	mov	r7,r4
 2037798:	180d883a 	mov	r6,r3
 203779c:	100b883a 	mov	r5,r2
 20377a0:	01008174 	movhi	r4,517
 20377a4:	21202d04 	addi	r4,r4,-32588
 20377a8:	20009e40 	call	20009e4 <printf>
                is_mapped = 1;
 20377ac:	00800044 	movi	r2,1
 20377b0:	e0bffa05 	stb	r2,-24(fp)
                break;
 20377b4:	00000906 	br	20377dc <alt_tse_mac_associate_phy+0x204>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 20377b8:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 20377bc:	e0bff817 	ldw	r2,-32(fp)
 20377c0:	10800044 	addi	r2,r2,1
 20377c4:	e0bff815 	stw	r2,-32(fp)
 20377c8:	e0bffe17 	ldw	r2,-8(fp)
 20377cc:	10800003 	ldbu	r2,0(r2)
 20377d0:	10803fcc 	andi	r2,r2,255
 20377d4:	e0fff817 	ldw	r3,-32(fp)
 20377d8:	18bfc516 	blt	r3,r2,20376f0 <__alt_mem_mem_0+0xfd0176f0>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 20377dc:	e0bffa03 	ldbu	r2,-24(fp)
 20377e0:	1000091e 	bne	r2,zero,2037808 <alt_tse_mac_associate_phy+0x230>
    	pphy->pmac_info = 0;
 20377e4:	e0bfff17 	ldw	r2,-4(fp)
 20377e8:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 20377ec:	e0bffd47 	ldb	r2,-11(fp)
 20377f0:	100b883a 	mov	r5,r2
 20377f4:	01008174 	movhi	r4,517
 20377f8:	21203e04 	addi	r4,r4,-32520
 20377fc:	20009e40 	call	20009e4 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 2037800:	00bfffc4 	movi	r2,-1
 2037804:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 2037808:	e0bff917 	ldw	r2,-28(fp)
}
 203780c:	e037883a 	mov	sp,fp
 2037810:	dfc00117 	ldw	ra,4(sp)
 2037814:	df000017 	ldw	fp,0(sp)
 2037818:	dec00204 	addi	sp,sp,8
 203781c:	f800283a 	ret

02037820 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 2037820:	defff804 	addi	sp,sp,-32
 2037824:	dfc00715 	stw	ra,28(sp)
 2037828:	df000615 	stw	fp,24(sp)
 203782c:	df000604 	addi	fp,sp,24
 2037830:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 2037834:	e0bfff17 	ldw	r2,-4(fp)
 2037838:	10800217 	ldw	r2,8(r2)
 203783c:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 2037840:	e0bffa17 	ldw	r2,-24(fp)
 2037844:	10800017 	ldw	r2,0(r2)
 2037848:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 203784c:	e0bfff17 	ldw	r2,-4(fp)
 2037850:	10800317 	ldw	r2,12(r2)
 2037854:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2037858:	e13fff17 	ldw	r4,-4(fp)
 203785c:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2037860:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2037864:	e13ffc17 	ldw	r4,-16(fp)
 2037868:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 203786c:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 2037870:	e0bffa17 	ldw	r2,-24(fp)
 2037874:	108003c3 	ldbu	r2,15(r2)
 2037878:	10803fcc 	andi	r2,r2,255
 203787c:	10002c26 	beq	r2,zero,2037930 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 2037880:	e0bffd47 	ldb	r2,-11(fp)
 2037884:	e0fffd07 	ldb	r3,-12(fp)
 2037888:	180d883a 	mov	r6,r3
 203788c:	100b883a 	mov	r5,r2
 2037890:	01008174 	movhi	r4,517
 2037894:	21206f04 	addi	r4,r4,-32324
 2037898:	20009e40 	call	20009e4 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 203789c:	e0bffb17 	ldw	r2,-20(fp)
 20378a0:	10808004 	addi	r2,r2,512
 20378a4:	10801404 	addi	r2,r2,80
 20378a8:	10800037 	ldwio	r2,0(r2)
 20378ac:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 20378b0:	e0bffa17 	ldw	r2,-24(fp)
 20378b4:	10800403 	ldbu	r2,16(r2)
 20378b8:	10803fcc 	andi	r2,r2,255
 20378bc:	10000e26 	beq	r2,zero,20378f8 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 20378c0:	e0bffd47 	ldb	r2,-11(fp)
 20378c4:	e0fffd07 	ldb	r3,-12(fp)
 20378c8:	180d883a 	mov	r6,r3
 20378cc:	100b883a 	mov	r5,r2
 20378d0:	01008174 	movhi	r4,517
 20378d4:	21207d04 	addi	r4,r4,-32268
 20378d8:	20009e40 	call	20009e4 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 20378dc:	e0bffb17 	ldw	r2,-20(fp)
 20378e0:	10808004 	addi	r2,r2,512
 20378e4:	10801404 	addi	r2,r2,80
 20378e8:	e0fffe17 	ldw	r3,-8(fp)
 20378ec:	18c000d4 	ori	r3,r3,3
 20378f0:	10c00035 	stwio	r3,0(r2)
 20378f4:	00000e06 	br	2037930 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 20378f8:	e0bffd47 	ldb	r2,-11(fp)
 20378fc:	e0fffd07 	ldb	r3,-12(fp)
 2037900:	180d883a 	mov	r6,r3
 2037904:	100b883a 	mov	r5,r2
 2037908:	01008174 	movhi	r4,517
 203790c:	21208904 	addi	r4,r4,-32220
 2037910:	20009e40 	call	20009e4 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 2037914:	e0bffb17 	ldw	r2,-20(fp)
 2037918:	10808004 	addi	r2,r2,512
 203791c:	10801404 	addi	r2,r2,80
 2037920:	e13ffe17 	ldw	r4,-8(fp)
 2037924:	00ffff04 	movi	r3,-4
 2037928:	20c6703a 	and	r3,r4,r3
 203792c:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 2037930:	0005883a 	mov	r2,zero
}
 2037934:	e037883a 	mov	sp,fp
 2037938:	dfc00117 	ldw	ra,4(sp)
 203793c:	df000017 	ldw	fp,0(sp)
 2037940:	dec00204 	addi	sp,sp,8
 2037944:	f800283a 	ret

02037948 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 2037948:	defffb04 	addi	sp,sp,-20
 203794c:	dfc00415 	stw	ra,16(sp)
 2037950:	df000315 	stw	fp,12(sp)
 2037954:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 2037958:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 203795c:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 2037960:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 2037964:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 2037968:	20366640 	call	2036664 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 203796c:	20369000 	call	2036900 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 2037970:	2036b100 	call	2036b10 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 2037974:	e03ffd05 	stb	zero,-12(fp)
 2037978:	00002f06 	br	2037a38 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 203797c:	e0fffd07 	ldb	r3,-12(fp)
 2037980:	008085f4 	movhi	r2,535
 2037984:	10be3204 	addi	r2,r2,-1848
 2037988:	18c7883a 	add	r3,r3,r3
 203798c:	18c7883a 	add	r3,r3,r3
 2037990:	10c5883a 	add	r2,r2,r3
 2037994:	10800017 	ldw	r2,0(r2)
 2037998:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 203799c:	e0bffe17 	ldw	r2,-8(fp)
 20379a0:	10800117 	ldw	r2,4(r2)
 20379a4:	10800217 	ldw	r2,8(r2)
 20379a8:	10800203 	ldbu	r2,8(r2)
 20379ac:	10803fcc 	andi	r2,r2,255
 20379b0:	10000326 	beq	r2,zero,20379c0 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 20379b4:	e13ffe17 	ldw	r4,-8(fp)
 20379b8:	20371b40 	call	20371b4 <alt_tse_mac_get_phy>
 20379bc:	00000706 	br	20379dc <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 20379c0:	e0bffd07 	ldb	r2,-12(fp)
 20379c4:	e0fffd47 	ldb	r3,-11(fp)
 20379c8:	180d883a 	mov	r6,r3
 20379cc:	100b883a 	mov	r5,r2
 20379d0:	01008174 	movhi	r4,517
 20379d4:	21209504 	addi	r4,r4,-32172
 20379d8:	20009e40 	call	20009e4 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 20379dc:	e03ffd45 	stb	zero,-11(fp)
 20379e0:	00000d06 	br	2037a18 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 20379e4:	e0bffd47 	ldb	r2,-11(fp)
 20379e8:	e0fffe17 	ldw	r3,-8(fp)
 20379ec:	10800044 	addi	r2,r2,1
 20379f0:	1085883a 	add	r2,r2,r2
 20379f4:	1085883a 	add	r2,r2,r2
 20379f8:	1885883a 	add	r2,r3,r2
 20379fc:	10800017 	ldw	r2,0(r2)
 2037a00:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 2037a04:	e13fff17 	ldw	r4,-4(fp)
 2037a08:	20378200 	call	2037820 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 2037a0c:	e0bffd43 	ldbu	r2,-11(fp)
 2037a10:	10800044 	addi	r2,r2,1
 2037a14:	e0bffd45 	stb	r2,-11(fp)
 2037a18:	e0fffd47 	ldb	r3,-11(fp)
 2037a1c:	e0bffe17 	ldw	r2,-8(fp)
 2037a20:	10800003 	ldbu	r2,0(r2)
 2037a24:	10803fcc 	andi	r2,r2,255
 2037a28:	18bfee16 	blt	r3,r2,20379e4 <__alt_mem_mem_0+0xfd0179e4>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 2037a2c:	e0bffd03 	ldbu	r2,-12(fp)
 2037a30:	10800044 	addi	r2,r2,1
 2037a34:	e0bffd05 	stb	r2,-12(fp)
 2037a38:	e0fffd07 	ldb	r3,-12(fp)
 2037a3c:	d0a80043 	ldbu	r2,-24575(gp)
 2037a40:	10803fcc 	andi	r2,r2,255
 2037a44:	18bfcd16 	blt	r3,r2,203797c <__alt_mem_mem_0+0xfd01797c>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 2037a48:	0005883a 	mov	r2,zero
}
 2037a4c:	e037883a 	mov	sp,fp
 2037a50:	dfc00117 	ldw	ra,4(sp)
 2037a54:	df000017 	ldw	fp,0(sp)
 2037a58:	dec00204 	addi	sp,sp,8
 2037a5c:	f800283a 	ret

02037a60 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 2037a60:	defff704 	addi	sp,sp,-36
 2037a64:	dfc00815 	stw	ra,32(sp)
 2037a68:	df000715 	stw	fp,28(sp)
 2037a6c:	df000704 	addi	fp,sp,28
 2037a70:	e13ffe15 	stw	r4,-8(fp)
 2037a74:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 2037a78:	e0bffe17 	ldw	r2,-8(fp)
 2037a7c:	10800617 	ldw	r2,24(r2)
 2037a80:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 2037a84:	e0bffb17 	ldw	r2,-20(fp)
 2037a88:	10800317 	ldw	r2,12(r2)
 2037a8c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2037a90:	e13ffb17 	ldw	r4,-20(fp)
 2037a94:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2037a98:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2037a9c:	e13ffc17 	ldw	r4,-16(fp)
 2037aa0:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2037aa4:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 2037aa8:	e13ffe17 	ldw	r4,-8(fp)
 2037aac:	20363d00 	call	20363d0 <alt_tse_phy_rd_mdio_addr>
 2037ab0:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2037ab4:	e0bffe17 	ldw	r2,-8(fp)
 2037ab8:	10800003 	ldbu	r2,0(r2)
 2037abc:	10803fcc 	andi	r2,r2,255
 2037ac0:	100b883a 	mov	r5,r2
 2037ac4:	e13ffe17 	ldw	r4,-8(fp)
 2037ac8:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 2037acc:	01c00044 	movi	r7,1
 2037ad0:	018000c4 	movi	r6,3
 2037ad4:	01400044 	movi	r5,1
 2037ad8:	e13ffe17 	ldw	r4,-8(fp)
 2037adc:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037ae0:	10000d1e 	bne	r2,zero,2037b18 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 2037ae4:	e0bffd47 	ldb	r2,-11(fp)
 2037ae8:	e0fffd07 	ldb	r3,-12(fp)
 2037aec:	180d883a 	mov	r6,r3
 2037af0:	100b883a 	mov	r5,r2
 2037af4:	01008174 	movhi	r4,517
 2037af8:	2120ab04 	addi	r4,r4,-32084
 2037afc:	20009e40 	call	20009e4 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2037b00:	e0bffd83 	ldbu	r2,-10(fp)
 2037b04:	100b883a 	mov	r5,r2
 2037b08:	e13ffe17 	ldw	r4,-8(fp)
 2037b0c:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 2037b10:	00bfff84 	movi	r2,-2
 2037b14:	00003c06 	br	2037c08 <alt_tse_phy_restart_an+0x1a8>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 2037b18:	00800044 	movi	r2,1
 2037b1c:	d8800015 	stw	r2,0(sp)
 2037b20:	01c00044 	movi	r7,1
 2037b24:	01800304 	movi	r6,12
 2037b28:	000b883a 	mov	r5,zero
 2037b2c:	e13ffe17 	ldw	r4,-8(fp)
 2037b30:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 2037b34:	00800044 	movi	r2,1
 2037b38:	d8800015 	stw	r2,0(sp)
 2037b3c:	01c00044 	movi	r7,1
 2037b40:	01800244 	movi	r6,9
 2037b44:	000b883a 	mov	r5,zero
 2037b48:	e13ffe17 	ldw	r4,-8(fp)
 2037b4c:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 2037b50:	e0bffd47 	ldb	r2,-11(fp)
 2037b54:	e0fffd07 	ldb	r3,-12(fp)
 2037b58:	180d883a 	mov	r6,r3
 2037b5c:	100b883a 	mov	r5,r2
 2037b60:	01008174 	movhi	r4,517
 2037b64:	2120bb04 	addi	r4,r4,-32020
 2037b68:	20009e40 	call	20009e4 <printf>
    
    alt_32 timeout = 0;
 2037b6c:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 2037b70:	00001306 	br	2037bc0 <alt_tse_phy_restart_an+0x160>
        if(timeout++ > timeout_threshold) {
 2037b74:	e0bffa17 	ldw	r2,-24(fp)
 2037b78:	10c00044 	addi	r3,r2,1
 2037b7c:	e0fffa15 	stw	r3,-24(fp)
 2037b80:	1007883a 	mov	r3,r2
 2037b84:	e0bfff17 	ldw	r2,-4(fp)
 2037b88:	10c00d2e 	bgeu	r2,r3,2037bc0 <alt_tse_phy_restart_an+0x160>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 2037b8c:	e0bffd47 	ldb	r2,-11(fp)
 2037b90:	e0fffd07 	ldb	r3,-12(fp)
 2037b94:	180d883a 	mov	r6,r3
 2037b98:	100b883a 	mov	r5,r2
 2037b9c:	01008174 	movhi	r4,517
 2037ba0:	2120cd04 	addi	r4,r4,-31948
 2037ba4:	20009e40 	call	20009e4 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2037ba8:	e0bffd83 	ldbu	r2,-10(fp)
 2037bac:	100b883a 	mov	r5,r2
 2037bb0:	e13ffe17 	ldw	r4,-8(fp)
 2037bb4:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 2037bb8:	00bfffc4 	movi	r2,-1
 2037bbc:	00001206 	br	2037c08 <alt_tse_phy_restart_an+0x1a8>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 2037bc0:	01c00044 	movi	r7,1
 2037bc4:	01800144 	movi	r6,5
 2037bc8:	01400044 	movi	r5,1
 2037bcc:	e13ffe17 	ldw	r4,-8(fp)
 2037bd0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037bd4:	103fe726 	beq	r2,zero,2037b74 <__alt_mem_mem_0+0xfd017b74>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 2037bd8:	e0bffd47 	ldb	r2,-11(fp)
 2037bdc:	e0fffd07 	ldb	r3,-12(fp)
 2037be0:	180d883a 	mov	r6,r3
 2037be4:	100b883a 	mov	r5,r2
 2037be8:	01008174 	movhi	r4,517
 2037bec:	2120d904 	addi	r4,r4,-31900
 2037bf0:	20009e40 	call	20009e4 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2037bf4:	e0bffd83 	ldbu	r2,-10(fp)
 2037bf8:	100b883a 	mov	r5,r2
 2037bfc:	e13ffe17 	ldw	r4,-8(fp)
 2037c00:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 2037c04:	0005883a 	mov	r2,zero
}
 2037c08:	e037883a 	mov	sp,fp
 2037c0c:	dfc00117 	ldw	ra,4(sp)
 2037c10:	df000017 	ldw	fp,0(sp)
 2037c14:	dec00204 	addi	sp,sp,8
 2037c18:	f800283a 	ret

02037c1c <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 2037c1c:	defff904 	addi	sp,sp,-28
 2037c20:	dfc00615 	stw	ra,24(sp)
 2037c24:	df000515 	stw	fp,20(sp)
 2037c28:	df000504 	addi	fp,sp,20
 2037c2c:	e13ffe15 	stw	r4,-8(fp)
 2037c30:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 2037c34:	e0bffe17 	ldw	r2,-8(fp)
 2037c38:	10800617 	ldw	r2,24(r2)
 2037c3c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 2037c40:	e0bffb17 	ldw	r2,-20(fp)
 2037c44:	10800317 	ldw	r2,12(r2)
 2037c48:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2037c4c:	e13ffb17 	ldw	r4,-20(fp)
 2037c50:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2037c54:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 2037c58:	e13ffc17 	ldw	r4,-16(fp)
 2037c5c:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2037c60:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 2037c64:	e13ffe17 	ldw	r4,-8(fp)
 2037c68:	20363d00 	call	20363d0 <alt_tse_phy_rd_mdio_addr>
 2037c6c:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2037c70:	e0bffe17 	ldw	r2,-8(fp)
 2037c74:	10800003 	ldbu	r2,0(r2)
 2037c78:	10803fcc 	andi	r2,r2,255
 2037c7c:	100b883a 	mov	r5,r2
 2037c80:	e13ffe17 	ldw	r4,-8(fp)
 2037c84:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 2037c88:	e0bffd47 	ldb	r2,-11(fp)
 2037c8c:	e0fffd07 	ldb	r3,-12(fp)
 2037c90:	180d883a 	mov	r6,r3
 2037c94:	100b883a 	mov	r5,r2
 2037c98:	01008174 	movhi	r4,517
 2037c9c:	2120e504 	addi	r4,r4,-31852
 2037ca0:	20009e40 	call	20009e4 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 2037ca4:	01c00044 	movi	r7,1
 2037ca8:	01800384 	movi	r6,14
 2037cac:	000b883a 	mov	r5,zero
 2037cb0:	e13ffe17 	ldw	r4,-8(fp)
 2037cb4:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037cb8:	1000061e 	bne	r2,zero,2037cd4 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 2037cbc:	01c00044 	movi	r7,1
 2037cc0:	01800144 	movi	r6,5
 2037cc4:	01400044 	movi	r5,1
 2037cc8:	e13ffe17 	ldw	r4,-8(fp)
 2037ccc:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 2037cd0:	1000191e 	bne	r2,zero,2037d38 <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 2037cd4:	e0bffd47 	ldb	r2,-11(fp)
 2037cd8:	e0fffd07 	ldb	r3,-12(fp)
 2037cdc:	180d883a 	mov	r6,r3
 2037ce0:	100b883a 	mov	r5,r2
 2037ce4:	01008174 	movhi	r4,517
 2037ce8:	2120f004 	addi	r4,r4,-31808
 2037cec:	20009e40 	call	20009e4 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 2037cf0:	e17fff17 	ldw	r5,-4(fp)
 2037cf4:	e13ffe17 	ldw	r4,-8(fp)
 2037cf8:	2037a600 	call	2037a60 <alt_tse_phy_restart_an>
 2037cfc:	10bfffd8 	cmpnei	r2,r2,-1
 2037d00:	10000d1e 	bne	r2,zero,2037d38 <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 2037d04:	e0bffd47 	ldb	r2,-11(fp)
 2037d08:	e0fffd07 	ldb	r3,-12(fp)
 2037d0c:	180d883a 	mov	r6,r3
 2037d10:	100b883a 	mov	r5,r2
 2037d14:	01008174 	movhi	r4,517
 2037d18:	21210404 	addi	r4,r4,-31728
 2037d1c:	20009e40 	call	20009e4 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2037d20:	e0bffd83 	ldbu	r2,-10(fp)
 2037d24:	100b883a 	mov	r5,r2
 2037d28:	e13ffe17 	ldw	r4,-8(fp)
 2037d2c:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 2037d30:	00bfffc4 	movi	r2,-1
 2037d34:	00000c06 	br	2037d68 <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 2037d38:	e0bffd47 	ldb	r2,-11(fp)
 2037d3c:	e0fffd07 	ldb	r3,-12(fp)
 2037d40:	180d883a 	mov	r6,r3
 2037d44:	100b883a 	mov	r5,r2
 2037d48:	01008174 	movhi	r4,517
 2037d4c:	21211104 	addi	r4,r4,-31676
 2037d50:	20009e40 	call	20009e4 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2037d54:	e0bffd83 	ldbu	r2,-10(fp)
 2037d58:	100b883a 	mov	r5,r2
 2037d5c:	e13ffe17 	ldw	r4,-8(fp)
 2037d60:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 2037d64:	0005883a 	mov	r2,zero
}
 2037d68:	e037883a 	mov	sp,fp
 2037d6c:	dfc00117 	ldw	ra,4(sp)
 2037d70:	df000017 	ldw	fp,0(sp)
 2037d74:	dec00204 	addi	sp,sp,8
 2037d78:	f800283a 	ret

02037d7c <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 2037d7c:	defff904 	addi	sp,sp,-28
 2037d80:	dfc00615 	stw	ra,24(sp)
 2037d84:	df000515 	stw	fp,20(sp)
 2037d88:	df000504 	addi	fp,sp,20
 2037d8c:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 2037d90:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 2037d94:	e0bfff17 	ldw	r2,-4(fp)
 2037d98:	10800617 	ldw	r2,24(r2)
 2037d9c:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 2037da0:	e0bffc17 	ldw	r2,-16(fp)
 2037da4:	10800317 	ldw	r2,12(r2)
 2037da8:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2037dac:	e13ffc17 	ldw	r4,-16(fp)
 2037db0:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2037db4:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 2037db8:	e13ffd17 	ldw	r4,-12(fp)
 2037dbc:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2037dc0:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 2037dc4:	e13fff17 	ldw	r4,-4(fp)
 2037dc8:	20363d00 	call	20363d0 <alt_tse_phy_rd_mdio_addr>
 2037dcc:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2037dd0:	e0bfff17 	ldw	r2,-4(fp)
 2037dd4:	10800003 	ldbu	r2,0(r2)
 2037dd8:	10803fcc 	andi	r2,r2,255
 2037ddc:	100b883a 	mov	r5,r2
 2037de0:	e13fff17 	ldw	r4,-4(fp)
 2037de4:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 2037de8:	01c00044 	movi	r7,1
 2037dec:	018000c4 	movi	r6,3
 2037df0:	01400044 	movi	r5,1
 2037df4:	e13fff17 	ldw	r4,-4(fp)
 2037df8:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037dfc:	10000d1e 	bne	r2,zero,2037e34 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 2037e00:	e0bffe47 	ldb	r2,-7(fp)
 2037e04:	e0fffe07 	ldb	r3,-8(fp)
 2037e08:	180d883a 	mov	r6,r3
 2037e0c:	100b883a 	mov	r5,r2
 2037e10:	01008174 	movhi	r4,517
 2037e14:	2120ab04 	addi	r4,r4,-32084
 2037e18:	20009e40 	call	20009e4 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2037e1c:	e0bffe83 	ldbu	r2,-6(fp)
 2037e20:	100b883a 	mov	r5,r2
 2037e24:	e13fff17 	ldw	r4,-4(fp)
 2037e28:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 2037e2c:	00bfff84 	movi	r2,-2
 2037e30:	00013206 	br	20382fc <alt_tse_phy_get_cap+0x580>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2037e34:	017e0034 	movhi	r5,63488
 2037e38:	e13fff17 	ldw	r4,-4(fp)
 2037e3c:	2037a600 	call	2037a60 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 2037e40:	01c00044 	movi	r7,1
 2037e44:	01800144 	movi	r6,5
 2037e48:	01400044 	movi	r5,1
 2037e4c:	e13fff17 	ldw	r4,-4(fp)
 2037e50:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037e54:	1000021e 	bne	r2,zero,2037e60 <alt_tse_phy_get_cap+0xe4>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 2037e58:	00bfffc4 	movi	r2,-1
 2037e5c:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 2037e60:	01c00044 	movi	r7,1
 2037e64:	018003c4 	movi	r6,15
 2037e68:	014003c4 	movi	r5,15
 2037e6c:	e13fff17 	ldw	r4,-4(fp)
 2037e70:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037e74:	1007883a 	mov	r3,r2
 2037e78:	e0bfff17 	ldw	r2,-4(fp)
 2037e7c:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 2037e80:	01c00044 	movi	r7,1
 2037e84:	01800384 	movi	r6,14
 2037e88:	014003c4 	movi	r5,15
 2037e8c:	e13fff17 	ldw	r4,-4(fp)
 2037e90:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037e94:	1007883a 	mov	r3,r2
 2037e98:	e0bfff17 	ldw	r2,-4(fp)
 2037e9c:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 2037ea0:	01c00044 	movi	r7,1
 2037ea4:	01800344 	movi	r6,13
 2037ea8:	014003c4 	movi	r5,15
 2037eac:	e13fff17 	ldw	r4,-4(fp)
 2037eb0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037eb4:	1007883a 	mov	r3,r2
 2037eb8:	e0bfff17 	ldw	r2,-4(fp)
 2037ebc:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 2037ec0:	01c00044 	movi	r7,1
 2037ec4:	01800304 	movi	r6,12
 2037ec8:	014003c4 	movi	r5,15
 2037ecc:	e13fff17 	ldw	r4,-4(fp)
 2037ed0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037ed4:	1007883a 	mov	r3,r2
 2037ed8:	e0bfff17 	ldw	r2,-4(fp)
 2037edc:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 2037ee0:	01c00044 	movi	r7,1
 2037ee4:	018003c4 	movi	r6,15
 2037ee8:	01400044 	movi	r5,1
 2037eec:	e13fff17 	ldw	r4,-4(fp)
 2037ef0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037ef4:	1007883a 	mov	r3,r2
 2037ef8:	e0bfff17 	ldw	r2,-4(fp)
 2037efc:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 2037f00:	01c00044 	movi	r7,1
 2037f04:	01800384 	movi	r6,14
 2037f08:	01400044 	movi	r5,1
 2037f0c:	e13fff17 	ldw	r4,-4(fp)
 2037f10:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037f14:	1007883a 	mov	r3,r2
 2037f18:	e0bfff17 	ldw	r2,-4(fp)
 2037f1c:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 2037f20:	01c00044 	movi	r7,1
 2037f24:	01800344 	movi	r6,13
 2037f28:	01400044 	movi	r5,1
 2037f2c:	e13fff17 	ldw	r4,-4(fp)
 2037f30:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037f34:	1007883a 	mov	r3,r2
 2037f38:	e0bfff17 	ldw	r2,-4(fp)
 2037f3c:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 2037f40:	01c00044 	movi	r7,1
 2037f44:	01800284 	movi	r6,10
 2037f48:	01400044 	movi	r5,1
 2037f4c:	e13fff17 	ldw	r4,-4(fp)
 2037f50:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037f54:	1007883a 	mov	r3,r2
 2037f58:	e0bfff17 	ldw	r2,-4(fp)
 2037f5c:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 2037f60:	01c00044 	movi	r7,1
 2037f64:	01800244 	movi	r6,9
 2037f68:	01400044 	movi	r5,1
 2037f6c:	e13fff17 	ldw	r4,-4(fp)
 2037f70:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037f74:	1007883a 	mov	r3,r2
 2037f78:	e0bfff17 	ldw	r2,-4(fp)
 2037f7c:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 2037f80:	01c00044 	movi	r7,1
 2037f84:	01800304 	movi	r6,12
 2037f88:	01400044 	movi	r5,1
 2037f8c:	e13fff17 	ldw	r4,-4(fp)
 2037f90:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037f94:	1007883a 	mov	r3,r2
 2037f98:	e0bfff17 	ldw	r2,-4(fp)
 2037f9c:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 2037fa0:	01c00044 	movi	r7,1
 2037fa4:	018002c4 	movi	r6,11
 2037fa8:	01400044 	movi	r5,1
 2037fac:	e13fff17 	ldw	r4,-4(fp)
 2037fb0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037fb4:	1007883a 	mov	r3,r2
 2037fb8:	e0bfff17 	ldw	r2,-4(fp)
 2037fbc:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 2037fc0:	01c00044 	movi	r7,1
 2037fc4:	018002c4 	movi	r6,11
 2037fc8:	01400284 	movi	r5,10
 2037fcc:	e13fff17 	ldw	r4,-4(fp)
 2037fd0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037fd4:	1007883a 	mov	r3,r2
 2037fd8:	e0bfff17 	ldw	r2,-4(fp)
 2037fdc:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 2037fe0:	01c00044 	movi	r7,1
 2037fe4:	01800284 	movi	r6,10
 2037fe8:	01400284 	movi	r5,10
 2037fec:	e13fff17 	ldw	r4,-4(fp)
 2037ff0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2037ff4:	1007883a 	mov	r3,r2
 2037ff8:	e0bfff17 	ldw	r2,-4(fp)
 2037ffc:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 2038000:	01c00044 	movi	r7,1
 2038004:	01800244 	movi	r6,9
 2038008:	01400144 	movi	r5,5
 203800c:	e13fff17 	ldw	r4,-4(fp)
 2038010:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038014:	1007883a 	mov	r3,r2
 2038018:	e0bfff17 	ldw	r2,-4(fp)
 203801c:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 2038020:	01c00044 	movi	r7,1
 2038024:	01800204 	movi	r6,8
 2038028:	01400144 	movi	r5,5
 203802c:	e13fff17 	ldw	r4,-4(fp)
 2038030:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038034:	1007883a 	mov	r3,r2
 2038038:	e0bfff17 	ldw	r2,-4(fp)
 203803c:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 2038040:	01c00044 	movi	r7,1
 2038044:	018001c4 	movi	r6,7
 2038048:	01400144 	movi	r5,5
 203804c:	e13fff17 	ldw	r4,-4(fp)
 2038050:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038054:	1007883a 	mov	r3,r2
 2038058:	e0bfff17 	ldw	r2,-4(fp)
 203805c:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 2038060:	01c00044 	movi	r7,1
 2038064:	01800184 	movi	r6,6
 2038068:	01400144 	movi	r5,5
 203806c:	e13fff17 	ldw	r4,-4(fp)
 2038070:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038074:	1007883a 	mov	r3,r2
 2038078:	e0bfff17 	ldw	r2,-4(fp)
 203807c:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 2038080:	01c00044 	movi	r7,1
 2038084:	01800144 	movi	r6,5
 2038088:	01400144 	movi	r5,5
 203808c:	e13fff17 	ldw	r4,-4(fp)
 2038090:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038094:	1007883a 	mov	r3,r2
 2038098:	e0bfff17 	ldw	r2,-4(fp)
 203809c:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 20380a0:	e0bffe47 	ldb	r2,-7(fp)
 20380a4:	e0fffe07 	ldb	r3,-8(fp)
 20380a8:	180d883a 	mov	r6,r3
 20380ac:	100b883a 	mov	r5,r2
 20380b0:	01008174 	movhi	r4,517
 20380b4:	21211c04 	addi	r4,r4,-31632
 20380b8:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 20380bc:	e0bfff17 	ldw	r2,-4(fp)
 20380c0:	10800043 	ldbu	r2,1(r2)
 20380c4:	10803fcc 	andi	r2,r2,255
 20380c8:	100b883a 	mov	r5,r2
 20380cc:	01008174 	movhi	r4,517
 20380d0:	21212704 	addi	r4,r4,-31588
 20380d4:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 20380d8:	e0bfff17 	ldw	r2,-4(fp)
 20380dc:	10800083 	ldbu	r2,2(r2)
 20380e0:	10803fcc 	andi	r2,r2,255
 20380e4:	100b883a 	mov	r5,r2
 20380e8:	01008174 	movhi	r4,517
 20380ec:	21213104 	addi	r4,r4,-31548
 20380f0:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 20380f4:	e0bfff17 	ldw	r2,-4(fp)
 20380f8:	108000c3 	ldbu	r2,3(r2)
 20380fc:	10803fcc 	andi	r2,r2,255
 2038100:	100b883a 	mov	r5,r2
 2038104:	01008174 	movhi	r4,517
 2038108:	21213b04 	addi	r4,r4,-31508
 203810c:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 2038110:	e0bfff17 	ldw	r2,-4(fp)
 2038114:	10800103 	ldbu	r2,4(r2)
 2038118:	10803fcc 	andi	r2,r2,255
 203811c:	100b883a 	mov	r5,r2
 2038120:	01008174 	movhi	r4,517
 2038124:	21214504 	addi	r4,r4,-31468
 2038128:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 203812c:	e0bfff17 	ldw	r2,-4(fp)
 2038130:	10800143 	ldbu	r2,5(r2)
 2038134:	10803fcc 	andi	r2,r2,255
 2038138:	100b883a 	mov	r5,r2
 203813c:	01008174 	movhi	r4,517
 2038140:	21214f04 	addi	r4,r4,-31428
 2038144:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 2038148:	e0bfff17 	ldw	r2,-4(fp)
 203814c:	10800183 	ldbu	r2,6(r2)
 2038150:	10803fcc 	andi	r2,r2,255
 2038154:	100b883a 	mov	r5,r2
 2038158:	01008174 	movhi	r4,517
 203815c:	21215904 	addi	r4,r4,-31388
 2038160:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 2038164:	e0bfff17 	ldw	r2,-4(fp)
 2038168:	108001c3 	ldbu	r2,7(r2)
 203816c:	10803fcc 	andi	r2,r2,255
 2038170:	100b883a 	mov	r5,r2
 2038174:	01008174 	movhi	r4,517
 2038178:	21216304 	addi	r4,r4,-31348
 203817c:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 2038180:	e0bfff17 	ldw	r2,-4(fp)
 2038184:	10800203 	ldbu	r2,8(r2)
 2038188:	10803fcc 	andi	r2,r2,255
 203818c:	100b883a 	mov	r5,r2
 2038190:	01008174 	movhi	r4,517
 2038194:	21216d04 	addi	r4,r4,-31308
 2038198:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 203819c:	e0bfff17 	ldw	r2,-4(fp)
 20381a0:	10800243 	ldbu	r2,9(r2)
 20381a4:	10803fcc 	andi	r2,r2,255
 20381a8:	100b883a 	mov	r5,r2
 20381ac:	01008174 	movhi	r4,517
 20381b0:	21217704 	addi	r4,r4,-31268
 20381b4:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 20381b8:	e0bfff17 	ldw	r2,-4(fp)
 20381bc:	10800283 	ldbu	r2,10(r2)
 20381c0:	10803fcc 	andi	r2,r2,255
 20381c4:	100b883a 	mov	r5,r2
 20381c8:	01008174 	movhi	r4,517
 20381cc:	21218104 	addi	r4,r4,-31228
 20381d0:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 20381d4:	e0bfff17 	ldw	r2,-4(fp)
 20381d8:	108002c3 	ldbu	r2,11(r2)
 20381dc:	10803fcc 	andi	r2,r2,255
 20381e0:	100b883a 	mov	r5,r2
 20381e4:	01008174 	movhi	r4,517
 20381e8:	21218b04 	addi	r4,r4,-31188
 20381ec:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "\n");
 20381f0:	01008134 	movhi	r4,516
 20381f4:	211ff104 	addi	r4,r4,32708
 20381f8:	20344980 	call	2034498 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 20381fc:	e0bffe47 	ldb	r2,-7(fp)
 2038200:	e0fffe07 	ldb	r3,-8(fp)
 2038204:	180d883a 	mov	r6,r3
 2038208:	100b883a 	mov	r5,r2
 203820c:	01008174 	movhi	r4,517
 2038210:	21219504 	addi	r4,r4,-31148
 2038214:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 2038218:	e0bfff17 	ldw	r2,-4(fp)
 203821c:	10800303 	ldbu	r2,12(r2)
 2038220:	10803fcc 	andi	r2,r2,255
 2038224:	100b883a 	mov	r5,r2
 2038228:	01008174 	movhi	r4,517
 203822c:	21213b04 	addi	r4,r4,-31508
 2038230:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 2038234:	e0bfff17 	ldw	r2,-4(fp)
 2038238:	10800343 	ldbu	r2,13(r2)
 203823c:	10803fcc 	andi	r2,r2,255
 2038240:	100b883a 	mov	r5,r2
 2038244:	01008174 	movhi	r4,517
 2038248:	21214504 	addi	r4,r4,-31468
 203824c:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 2038250:	e0bfff17 	ldw	r2,-4(fp)
 2038254:	10800383 	ldbu	r2,14(r2)
 2038258:	10803fcc 	andi	r2,r2,255
 203825c:	100b883a 	mov	r5,r2
 2038260:	01008174 	movhi	r4,517
 2038264:	21214f04 	addi	r4,r4,-31428
 2038268:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 203826c:	e0bfff17 	ldw	r2,-4(fp)
 2038270:	108003c3 	ldbu	r2,15(r2)
 2038274:	10803fcc 	andi	r2,r2,255
 2038278:	100b883a 	mov	r5,r2
 203827c:	01008174 	movhi	r4,517
 2038280:	2121a204 	addi	r4,r4,-31096
 2038284:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 2038288:	e0bfff17 	ldw	r2,-4(fp)
 203828c:	10800403 	ldbu	r2,16(r2)
 2038290:	10803fcc 	andi	r2,r2,255
 2038294:	100b883a 	mov	r5,r2
 2038298:	01008174 	movhi	r4,517
 203829c:	2121ac04 	addi	r4,r4,-31056
 20382a0:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 20382a4:	e0bfff17 	ldw	r2,-4(fp)
 20382a8:	10800443 	ldbu	r2,17(r2)
 20382ac:	10803fcc 	andi	r2,r2,255
 20382b0:	100b883a 	mov	r5,r2
 20382b4:	01008174 	movhi	r4,517
 20382b8:	2121b604 	addi	r4,r4,-31016
 20382bc:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 20382c0:	e0bfff17 	ldw	r2,-4(fp)
 20382c4:	10800483 	ldbu	r2,18(r2)
 20382c8:	10803fcc 	andi	r2,r2,255
 20382cc:	100b883a 	mov	r5,r2
 20382d0:	01008174 	movhi	r4,517
 20382d4:	2121c004 	addi	r4,r4,-30976
 20382d8:	20344980 	call	2034498 <no_printf>
    tse_dprintf(6, "\n");
 20382dc:	01008134 	movhi	r4,516
 20382e0:	211ff104 	addi	r4,r4,32708
 20382e4:	20344980 	call	2034498 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 20382e8:	e0bffe83 	ldbu	r2,-6(fp)
 20382ec:	100b883a 	mov	r5,r2
 20382f0:	e13fff17 	ldw	r4,-4(fp)
 20382f4:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 20382f8:	e0bffb17 	ldw	r2,-20(fp)
    
}
 20382fc:	e037883a 	mov	sp,fp
 2038300:	dfc00117 	ldw	ra,4(sp)
 2038304:	df000017 	ldw	fp,0(sp)
 2038308:	dec00204 	addi	sp,sp,8
 203830c:	f800283a 	ret

02038310 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 2038310:	defff804 	addi	sp,sp,-32
 2038314:	dfc00715 	stw	ra,28(sp)
 2038318:	df000615 	stw	fp,24(sp)
 203831c:	df000604 	addi	fp,sp,24
 2038320:	e13ffe15 	stw	r4,-8(fp)
 2038324:	2805883a 	mov	r2,r5
 2038328:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 203832c:	e0bffe17 	ldw	r2,-8(fp)
 2038330:	10800617 	ldw	r2,24(r2)
 2038334:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 2038338:	e0bffb17 	ldw	r2,-20(fp)
 203833c:	10800317 	ldw	r2,12(r2)
 2038340:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2038344:	e13ffb17 	ldw	r4,-20(fp)
 2038348:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 203834c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2038350:	e13ffc17 	ldw	r4,-16(fp)
 2038354:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2038358:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 203835c:	e13ffe17 	ldw	r4,-8(fp)
 2038360:	20363d00 	call	20363d0 <alt_tse_phy_rd_mdio_addr>
 2038364:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2038368:	e0bffe17 	ldw	r2,-8(fp)
 203836c:	10800003 	ldbu	r2,0(r2)
 2038370:	10803fcc 	andi	r2,r2,255
 2038374:	100b883a 	mov	r5,r2
 2038378:	e13ffe17 	ldw	r4,-8(fp)
 203837c:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 2038380:	e0bfff03 	ldbu	r2,-4(fp)
 2038384:	10002d26 	beq	r2,zero,203843c <alt_tse_phy_set_adv_1000+0x12c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 2038388:	01c00044 	movi	r7,1
 203838c:	01800344 	movi	r6,13
 2038390:	014003c4 	movi	r5,15
 2038394:	e13ffe17 	ldw	r4,-8(fp)
 2038398:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 203839c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 20383a0:	e0bffdc3 	ldbu	r2,-9(fp)
 20383a4:	d8800015 	stw	r2,0(sp)
 20383a8:	01c00044 	movi	r7,1
 20383ac:	01800244 	movi	r6,9
 20383b0:	01400244 	movi	r5,9
 20383b4:	e13ffe17 	ldw	r4,-8(fp)
 20383b8:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 20383bc:	e0bffd47 	ldb	r2,-11(fp)
 20383c0:	e0fffd07 	ldb	r3,-12(fp)
 20383c4:	e13ffdc3 	ldbu	r4,-9(fp)
 20383c8:	200f883a 	mov	r7,r4
 20383cc:	180d883a 	mov	r6,r3
 20383d0:	100b883a 	mov	r5,r2
 20383d4:	01008174 	movhi	r4,517
 20383d8:	2121ca04 	addi	r4,r4,-30936
 20383dc:	20344980 	call	2034498 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 20383e0:	01c00044 	movi	r7,1
 20383e4:	01800304 	movi	r6,12
 20383e8:	014003c4 	movi	r5,15
 20383ec:	e13ffe17 	ldw	r4,-8(fp)
 20383f0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 20383f4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 20383f8:	e0bffdc3 	ldbu	r2,-9(fp)
 20383fc:	d8800015 	stw	r2,0(sp)
 2038400:	01c00044 	movi	r7,1
 2038404:	01800204 	movi	r6,8
 2038408:	01400244 	movi	r5,9
 203840c:	e13ffe17 	ldw	r4,-8(fp)
 2038410:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 2038414:	e0bffd47 	ldb	r2,-11(fp)
 2038418:	e0fffd07 	ldb	r3,-12(fp)
 203841c:	e13ffdc3 	ldbu	r4,-9(fp)
 2038420:	200f883a 	mov	r7,r4
 2038424:	180d883a 	mov	r6,r3
 2038428:	100b883a 	mov	r5,r2
 203842c:	01008174 	movhi	r4,517
 2038430:	2121dd04 	addi	r4,r4,-30860
 2038434:	20344980 	call	2034498 <no_printf>
 2038438:	00001c06 	br	20384ac <alt_tse_phy_set_adv_1000+0x19c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 203843c:	d8000015 	stw	zero,0(sp)
 2038440:	01c00044 	movi	r7,1
 2038444:	01800244 	movi	r6,9
 2038448:	01400244 	movi	r5,9
 203844c:	e13ffe17 	ldw	r4,-8(fp)
 2038450:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 2038454:	e0bffd47 	ldb	r2,-11(fp)
 2038458:	e0fffd07 	ldb	r3,-12(fp)
 203845c:	000f883a 	mov	r7,zero
 2038460:	180d883a 	mov	r6,r3
 2038464:	100b883a 	mov	r5,r2
 2038468:	01008174 	movhi	r4,517
 203846c:	2121ca04 	addi	r4,r4,-30936
 2038470:	20344980 	call	2034498 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 2038474:	d8000015 	stw	zero,0(sp)
 2038478:	01c00044 	movi	r7,1
 203847c:	01800204 	movi	r6,8
 2038480:	01400244 	movi	r5,9
 2038484:	e13ffe17 	ldw	r4,-8(fp)
 2038488:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203848c:	e0bffd47 	ldb	r2,-11(fp)
 2038490:	e0fffd07 	ldb	r3,-12(fp)
 2038494:	000f883a 	mov	r7,zero
 2038498:	180d883a 	mov	r6,r3
 203849c:	100b883a 	mov	r5,r2
 20384a0:	01008174 	movhi	r4,517
 20384a4:	2121f004 	addi	r4,r4,-30784
 20384a8:	20344980 	call	2034498 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 20384ac:	e0bffd83 	ldbu	r2,-10(fp)
 20384b0:	100b883a 	mov	r5,r2
 20384b4:	e13ffe17 	ldw	r4,-8(fp)
 20384b8:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 20384bc:	0005883a 	mov	r2,zero
}
 20384c0:	e037883a 	mov	sp,fp
 20384c4:	dfc00117 	ldw	ra,4(sp)
 20384c8:	df000017 	ldw	fp,0(sp)
 20384cc:	dec00204 	addi	sp,sp,8
 20384d0:	f800283a 	ret

020384d4 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 20384d4:	defff804 	addi	sp,sp,-32
 20384d8:	dfc00715 	stw	ra,28(sp)
 20384dc:	df000615 	stw	fp,24(sp)
 20384e0:	df000604 	addi	fp,sp,24
 20384e4:	e13ffe15 	stw	r4,-8(fp)
 20384e8:	2805883a 	mov	r2,r5
 20384ec:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 20384f0:	e0bffe17 	ldw	r2,-8(fp)
 20384f4:	10800617 	ldw	r2,24(r2)
 20384f8:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 20384fc:	e0bffb17 	ldw	r2,-20(fp)
 2038500:	10800317 	ldw	r2,12(r2)
 2038504:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2038508:	e13ffb17 	ldw	r4,-20(fp)
 203850c:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2038510:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2038514:	e13ffc17 	ldw	r4,-16(fp)
 2038518:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 203851c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 2038520:	e13ffe17 	ldw	r4,-8(fp)
 2038524:	20363d00 	call	20363d0 <alt_tse_phy_rd_mdio_addr>
 2038528:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 203852c:	e0bffe17 	ldw	r2,-8(fp)
 2038530:	10800003 	ldbu	r2,0(r2)
 2038534:	10803fcc 	andi	r2,r2,255
 2038538:	100b883a 	mov	r5,r2
 203853c:	e13ffe17 	ldw	r4,-8(fp)
 2038540:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 2038544:	e0bfff03 	ldbu	r2,-4(fp)
 2038548:	10004326 	beq	r2,zero,2038658 <alt_tse_phy_set_adv_100+0x184>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 203854c:	01c00044 	movi	r7,1
 2038550:	018003c4 	movi	r6,15
 2038554:	01400044 	movi	r5,1
 2038558:	e13ffe17 	ldw	r4,-8(fp)
 203855c:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038560:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 2038564:	e0bffdc3 	ldbu	r2,-9(fp)
 2038568:	d8800015 	stw	r2,0(sp)
 203856c:	01c00044 	movi	r7,1
 2038570:	01800244 	movi	r6,9
 2038574:	01400104 	movi	r5,4
 2038578:	e13ffe17 	ldw	r4,-8(fp)
 203857c:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 2038580:	e0bffd47 	ldb	r2,-11(fp)
 2038584:	e0fffd07 	ldb	r3,-12(fp)
 2038588:	e13ffdc3 	ldbu	r4,-9(fp)
 203858c:	200f883a 	mov	r7,r4
 2038590:	180d883a 	mov	r6,r3
 2038594:	100b883a 	mov	r5,r2
 2038598:	01008174 	movhi	r4,517
 203859c:	21220204 	addi	r4,r4,-30712
 20385a0:	20344980 	call	2034498 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 20385a4:	01c00044 	movi	r7,1
 20385a8:	01800384 	movi	r6,14
 20385ac:	01400044 	movi	r5,1
 20385b0:	e13ffe17 	ldw	r4,-8(fp)
 20385b4:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 20385b8:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 20385bc:	e0bffdc3 	ldbu	r2,-9(fp)
 20385c0:	d8800015 	stw	r2,0(sp)
 20385c4:	01c00044 	movi	r7,1
 20385c8:	01800204 	movi	r6,8
 20385cc:	01400104 	movi	r5,4
 20385d0:	e13ffe17 	ldw	r4,-8(fp)
 20385d4:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 20385d8:	e0bffd47 	ldb	r2,-11(fp)
 20385dc:	e0fffd07 	ldb	r3,-12(fp)
 20385e0:	e13ffdc3 	ldbu	r4,-9(fp)
 20385e4:	200f883a 	mov	r7,r4
 20385e8:	180d883a 	mov	r6,r3
 20385ec:	100b883a 	mov	r5,r2
 20385f0:	01008174 	movhi	r4,517
 20385f4:	21221204 	addi	r4,r4,-30648
 20385f8:	20344980 	call	2034498 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 20385fc:	01c00044 	movi	r7,1
 2038600:	01800344 	movi	r6,13
 2038604:	01400044 	movi	r5,1
 2038608:	e13ffe17 	ldw	r4,-8(fp)
 203860c:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038610:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 2038614:	e0bffdc3 	ldbu	r2,-9(fp)
 2038618:	d8800015 	stw	r2,0(sp)
 203861c:	01c00044 	movi	r7,1
 2038620:	018001c4 	movi	r6,7
 2038624:	01400104 	movi	r5,4
 2038628:	e13ffe17 	ldw	r4,-8(fp)
 203862c:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 2038630:	e0bffd47 	ldb	r2,-11(fp)
 2038634:	e0fffd07 	ldb	r3,-12(fp)
 2038638:	e13ffdc3 	ldbu	r4,-9(fp)
 203863c:	200f883a 	mov	r7,r4
 2038640:	180d883a 	mov	r6,r3
 2038644:	100b883a 	mov	r5,r2
 2038648:	01008174 	movhi	r4,517
 203864c:	21222504 	addi	r4,r4,-30572
 2038650:	20344980 	call	2034498 <no_printf>
 2038654:	00002a06 	br	2038700 <alt_tse_phy_set_adv_100+0x22c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 2038658:	d8000015 	stw	zero,0(sp)
 203865c:	01c00044 	movi	r7,1
 2038660:	01800244 	movi	r6,9
 2038664:	01400104 	movi	r5,4
 2038668:	e13ffe17 	ldw	r4,-8(fp)
 203866c:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 2038670:	e0bffd47 	ldb	r2,-11(fp)
 2038674:	e0fffd07 	ldb	r3,-12(fp)
 2038678:	000f883a 	mov	r7,zero
 203867c:	180d883a 	mov	r6,r3
 2038680:	100b883a 	mov	r5,r2
 2038684:	01008174 	movhi	r4,517
 2038688:	21220204 	addi	r4,r4,-30712
 203868c:	20344980 	call	2034498 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 2038690:	d8000015 	stw	zero,0(sp)
 2038694:	01c00044 	movi	r7,1
 2038698:	01800204 	movi	r6,8
 203869c:	01400104 	movi	r5,4
 20386a0:	e13ffe17 	ldw	r4,-8(fp)
 20386a4:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 20386a8:	e0bffd47 	ldb	r2,-11(fp)
 20386ac:	e0fffd07 	ldb	r3,-12(fp)
 20386b0:	000f883a 	mov	r7,zero
 20386b4:	180d883a 	mov	r6,r3
 20386b8:	100b883a 	mov	r5,r2
 20386bc:	01008174 	movhi	r4,517
 20386c0:	21221204 	addi	r4,r4,-30648
 20386c4:	20344980 	call	2034498 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 20386c8:	d8000015 	stw	zero,0(sp)
 20386cc:	01c00044 	movi	r7,1
 20386d0:	018001c4 	movi	r6,7
 20386d4:	01400104 	movi	r5,4
 20386d8:	e13ffe17 	ldw	r4,-8(fp)
 20386dc:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 20386e0:	e0bffd47 	ldb	r2,-11(fp)
 20386e4:	e0fffd07 	ldb	r3,-12(fp)
 20386e8:	000f883a 	mov	r7,zero
 20386ec:	180d883a 	mov	r6,r3
 20386f0:	100b883a 	mov	r5,r2
 20386f4:	01008174 	movhi	r4,517
 20386f8:	21222504 	addi	r4,r4,-30572
 20386fc:	20344980 	call	2034498 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 2038700:	e0bffd83 	ldbu	r2,-10(fp)
 2038704:	100b883a 	mov	r5,r2
 2038708:	e13ffe17 	ldw	r4,-8(fp)
 203870c:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 2038710:	0005883a 	mov	r2,zero
}
 2038714:	e037883a 	mov	sp,fp
 2038718:	dfc00117 	ldw	ra,4(sp)
 203871c:	df000017 	ldw	fp,0(sp)
 2038720:	dec00204 	addi	sp,sp,8
 2038724:	f800283a 	ret

02038728 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 2038728:	defff504 	addi	sp,sp,-44
 203872c:	dfc00a15 	stw	ra,40(sp)
 2038730:	df000915 	stw	fp,36(sp)
 2038734:	df000904 	addi	fp,sp,36
 2038738:	e13ffe15 	stw	r4,-8(fp)
 203873c:	2805883a 	mov	r2,r5
 2038740:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 2038744:	e0bffe17 	ldw	r2,-8(fp)
 2038748:	10800617 	ldw	r2,24(r2)
 203874c:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 2038750:	e0bff817 	ldw	r2,-32(fp)
 2038754:	10800317 	ldw	r2,12(r2)
 2038758:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203875c:	e13ff817 	ldw	r4,-32(fp)
 2038760:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2038764:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2038768:	e13ff917 	ldw	r4,-28(fp)
 203876c:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2038770:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 2038774:	e13ffe17 	ldw	r4,-8(fp)
 2038778:	20363d00 	call	20363d0 <alt_tse_phy_rd_mdio_addr>
 203877c:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2038780:	e0bffe17 	ldw	r2,-8(fp)
 2038784:	10800003 	ldbu	r2,0(r2)
 2038788:	10803fcc 	andi	r2,r2,255
 203878c:	100b883a 	mov	r5,r2
 2038790:	e13ffe17 	ldw	r4,-8(fp)
 2038794:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 2038798:	e0bfff03 	ldbu	r2,-4(fp)
 203879c:	10002926 	beq	r2,zero,2038844 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 20387a0:	01c00044 	movi	r7,1
 20387a4:	01800304 	movi	r6,12
 20387a8:	01400044 	movi	r5,1
 20387ac:	e13ffe17 	ldw	r4,-8(fp)
 20387b0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 20387b4:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 20387b8:	e0bffd03 	ldbu	r2,-12(fp)
 20387bc:	d8800015 	stw	r2,0(sp)
 20387c0:	01c00044 	movi	r7,1
 20387c4:	01800184 	movi	r6,6
 20387c8:	01400104 	movi	r5,4
 20387cc:	e13ffe17 	ldw	r4,-8(fp)
 20387d0:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 20387d4:	e0bffd03 	ldbu	r2,-12(fp)
 20387d8:	100f883a 	mov	r7,r2
 20387dc:	e1bffa17 	ldw	r6,-24(fp)
 20387e0:	e17ffb17 	ldw	r5,-20(fp)
 20387e4:	01008174 	movhi	r4,517
 20387e8:	21223804 	addi	r4,r4,-30496
 20387ec:	20344980 	call	2034498 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 20387f0:	01c00044 	movi	r7,1
 20387f4:	018002c4 	movi	r6,11
 20387f8:	01400044 	movi	r5,1
 20387fc:	e13ffe17 	ldw	r4,-8(fp)
 2038800:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038804:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 2038808:	e0bffd03 	ldbu	r2,-12(fp)
 203880c:	d8800015 	stw	r2,0(sp)
 2038810:	01c00044 	movi	r7,1
 2038814:	01800144 	movi	r6,5
 2038818:	01400104 	movi	r5,4
 203881c:	e13ffe17 	ldw	r4,-8(fp)
 2038820:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 2038824:	e0bffd03 	ldbu	r2,-12(fp)
 2038828:	100f883a 	mov	r7,r2
 203882c:	e1bffa17 	ldw	r6,-24(fp)
 2038830:	e17ffb17 	ldw	r5,-20(fp)
 2038834:	01008174 	movhi	r4,517
 2038838:	21224b04 	addi	r4,r4,-30420
 203883c:	20344980 	call	2034498 <no_printf>
 2038840:	00001806 	br	20388a4 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 2038844:	d8000015 	stw	zero,0(sp)
 2038848:	01c00044 	movi	r7,1
 203884c:	01800184 	movi	r6,6
 2038850:	01400104 	movi	r5,4
 2038854:	e13ffe17 	ldw	r4,-8(fp)
 2038858:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203885c:	000f883a 	mov	r7,zero
 2038860:	e1bffa17 	ldw	r6,-24(fp)
 2038864:	e17ffb17 	ldw	r5,-20(fp)
 2038868:	01008174 	movhi	r4,517
 203886c:	21223804 	addi	r4,r4,-30496
 2038870:	20344980 	call	2034498 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 2038874:	d8000015 	stw	zero,0(sp)
 2038878:	01c00044 	movi	r7,1
 203887c:	01800144 	movi	r6,5
 2038880:	01400104 	movi	r5,4
 2038884:	e13ffe17 	ldw	r4,-8(fp)
 2038888:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203888c:	000f883a 	mov	r7,zero
 2038890:	e1bffa17 	ldw	r6,-24(fp)
 2038894:	e17ffb17 	ldw	r5,-20(fp)
 2038898:	01008174 	movhi	r4,517
 203889c:	21224b04 	addi	r4,r4,-30420
 20388a0:	20344980 	call	2034498 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 20388a4:	e0bffc17 	ldw	r2,-16(fp)
 20388a8:	10803fcc 	andi	r2,r2,255
 20388ac:	100b883a 	mov	r5,r2
 20388b0:	e13ffe17 	ldw	r4,-8(fp)
 20388b4:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 20388b8:	0005883a 	mov	r2,zero
}
 20388bc:	e037883a 	mov	sp,fp
 20388c0:	dfc00117 	ldw	ra,4(sp)
 20388c4:	df000017 	ldw	fp,0(sp)
 20388c8:	dec00204 	addi	sp,sp,8
 20388cc:	f800283a 	ret

020388d0 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 20388d0:	defff604 	addi	sp,sp,-40
 20388d4:	dfc00915 	stw	ra,36(sp)
 20388d8:	df000815 	stw	fp,32(sp)
 20388dc:	df000804 	addi	fp,sp,32
 20388e0:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 20388e4:	00800044 	movi	r2,1
 20388e8:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 20388ec:	00800044 	movi	r2,1
 20388f0:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 20388f4:	00800044 	movi	r2,1
 20388f8:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 20388fc:	00800044 	movi	r2,1
 2038900:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 2038904:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 2038908:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203890c:	e13fff17 	ldw	r4,-4(fp)
 2038910:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2038914:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 2038918:	e03ff815 	stw	zero,-32(fp)
 203891c:	00001c06 	br	2038990 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 2038920:	e0ffff17 	ldw	r3,-4(fp)
 2038924:	e0bff817 	ldw	r2,-32(fp)
 2038928:	10800044 	addi	r2,r2,1
 203892c:	1085883a 	add	r2,r2,r2
 2038930:	1085883a 	add	r2,r2,r2
 2038934:	1885883a 	add	r2,r3,r2
 2038938:	10800017 	ldw	r2,0(r2)
 203893c:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 2038940:	e0bffc17 	ldw	r2,-16(fp)
 2038944:	10800117 	ldw	r2,4(r2)
 2038948:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 203894c:	e0bffd17 	ldw	r2,-12(fp)
 2038950:	10000926 	beq	r2,zero,2038978 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 2038954:	01400044 	movi	r5,1
 2038958:	e13ffd17 	ldw	r4,-12(fp)
 203895c:	20383100 	call	2038310 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 2038960:	01400044 	movi	r5,1
 2038964:	e13ffd17 	ldw	r4,-12(fp)
 2038968:	20384d40 	call	20384d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 203896c:	01400044 	movi	r5,1
 2038970:	e13ffd17 	ldw	r4,-12(fp)
 2038974:	20387280 	call	2038728 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 2038978:	01008134 	movhi	r4,516
 203897c:	211ff104 	addi	r4,r4,32708
 2038980:	20344980 	call	2034498 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 2038984:	e0bff817 	ldw	r2,-32(fp)
 2038988:	10800044 	addi	r2,r2,1
 203898c:	e0bff815 	stw	r2,-32(fp)
 2038990:	e0bfff17 	ldw	r2,-4(fp)
 2038994:	10800003 	ldbu	r2,0(r2)
 2038998:	10803fcc 	andi	r2,r2,255
 203899c:	e0fff817 	ldw	r3,-32(fp)
 20389a0:	18bfdf16 	blt	r3,r2,2038920 <__alt_mem_mem_0+0xfd018920>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 20389a4:	e03ff815 	stw	zero,-32(fp)
 20389a8:	00005606 	br	2038b04 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 20389ac:	e0ffff17 	ldw	r3,-4(fp)
 20389b0:	e0bff817 	ldw	r2,-32(fp)
 20389b4:	10800044 	addi	r2,r2,1
 20389b8:	1085883a 	add	r2,r2,r2
 20389bc:	1085883a 	add	r2,r2,r2
 20389c0:	1885883a 	add	r2,r3,r2
 20389c4:	10800017 	ldw	r2,0(r2)
 20389c8:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 20389cc:	e0bffc17 	ldw	r2,-16(fp)
 20389d0:	10800117 	ldw	r2,4(r2)
 20389d4:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 20389d8:	e0bffd17 	ldw	r2,-12(fp)
 20389dc:	10004326 	beq	r2,zero,2038aec <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 20389e0:	e13ffd17 	ldw	r4,-12(fp)
 20389e4:	2037d7c0 	call	2037d7c <alt_tse_phy_get_cap>
 20389e8:	1000421e 	bne	r2,zero,2038af4 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 20389ec:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 20389f0:	e0bffc17 	ldw	r2,-16(fp)
 20389f4:	10800003 	ldbu	r2,0(r2)
 20389f8:	10803fcc 	andi	r2,r2,255
 20389fc:	10800058 	cmpnei	r2,r2,1
 2038a00:	1000021e 	bne	r2,zero,2038a0c <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 2038a04:	e03ff905 	stb	zero,-28(fp)
 2038a08:	00000706 	br	2038a28 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 2038a0c:	e0bffc17 	ldw	r2,-16(fp)
 2038a10:	10800003 	ldbu	r2,0(r2)
 2038a14:	10803fcc 	andi	r2,r2,255
 2038a18:	10800098 	cmpnei	r2,r2,2
 2038a1c:	1000021e 	bne	r2,zero,2038a28 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 2038a20:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 2038a24:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 2038a28:	e0bffd17 	ldw	r2,-12(fp)
 2038a2c:	10c000c3 	ldbu	r3,3(r2)
 2038a30:	e0bffd17 	ldw	r2,-12(fp)
 2038a34:	10800303 	ldbu	r2,12(r2)
 2038a38:	1884703a 	and	r2,r3,r2
 2038a3c:	1007883a 	mov	r3,r2
 2038a40:	e0bff903 	ldbu	r2,-28(fp)
 2038a44:	1884703a 	and	r2,r3,r2
 2038a48:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 2038a4c:	e0bffd17 	ldw	r2,-12(fp)
 2038a50:	10c00183 	ldbu	r3,6(r2)
 2038a54:	e0bffd17 	ldw	r2,-12(fp)
 2038a58:	108003c3 	ldbu	r2,15(r2)
 2038a5c:	1884703a 	and	r2,r3,r2
 2038a60:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 2038a64:	e0bffd17 	ldw	r2,-12(fp)
 2038a68:	10c001c3 	ldbu	r3,7(r2)
 2038a6c:	e0bffd17 	ldw	r2,-12(fp)
 2038a70:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 2038a74:	1884703a 	and	r2,r3,r2
 2038a78:	2084b03a 	or	r2,r4,r2
 2038a7c:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 2038a80:	e0bffd17 	ldw	r2,-12(fp)
 2038a84:	10c00143 	ldbu	r3,5(r2)
 2038a88:	e0bffd17 	ldw	r2,-12(fp)
 2038a8c:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 2038a90:	1884703a 	and	r2,r3,r2
 2038a94:	2084b03a 	or	r2,r4,r2
 2038a98:	1007883a 	mov	r3,r2
 2038a9c:	e0bff943 	ldbu	r2,-27(fp)
 2038aa0:	1884703a 	and	r2,r3,r2
 2038aa4:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 2038aa8:	e0bffd17 	ldw	r2,-12(fp)
 2038aac:	10c00283 	ldbu	r3,10(r2)
 2038ab0:	e0bffd17 	ldw	r2,-12(fp)
 2038ab4:	10800443 	ldbu	r2,17(r2)
 2038ab8:	1884703a 	and	r2,r3,r2
 2038abc:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 2038ac0:	e0bffd17 	ldw	r2,-12(fp)
 2038ac4:	10c002c3 	ldbu	r3,11(r2)
 2038ac8:	e0bffd17 	ldw	r2,-12(fp)
 2038acc:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 2038ad0:	1884703a 	and	r2,r3,r2
 2038ad4:	2084b03a 	or	r2,r4,r2
 2038ad8:	1007883a 	mov	r3,r2
 2038adc:	e0bff983 	ldbu	r2,-26(fp)
 2038ae0:	1884703a 	and	r2,r3,r2
 2038ae4:	e0bff985 	stb	r2,-26(fp)
 2038ae8:	00000306 	br	2038af8 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 2038aec:	0001883a 	nop
 2038af0:	00000106 	br	2038af8 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 2038af4:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 2038af8:	e0bff817 	ldw	r2,-32(fp)
 2038afc:	10800044 	addi	r2,r2,1
 2038b00:	e0bff815 	stw	r2,-32(fp)
 2038b04:	e0bfff17 	ldw	r2,-4(fp)
 2038b08:	10800003 	ldbu	r2,0(r2)
 2038b0c:	10803fcc 	andi	r2,r2,255
 2038b10:	e0fff817 	ldw	r3,-32(fp)
 2038b14:	18bfa516 	blt	r3,r2,20389ac <__alt_mem_mem_0+0xfd0189ac>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 2038b18:	e0bffb03 	ldbu	r2,-20(fp)
 2038b1c:	10800058 	cmpnei	r2,r2,1
 2038b20:	1000081e 	bne	r2,zero,2038b44 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 2038b24:	00bfffc4 	movi	r2,-1
 2038b28:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 2038b2c:	e0bffe07 	ldb	r2,-8(fp)
 2038b30:	100b883a 	mov	r5,r2
 2038b34:	01008174 	movhi	r4,517
 2038b38:	21225e04 	addi	r4,r4,-30344
 2038b3c:	20009e40 	call	20009e4 <printf>
 2038b40:	00002706 	br	2038be0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 2038b44:	e0bff903 	ldbu	r2,-28(fp)
 2038b48:	10000926 	beq	r2,zero,2038b70 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 2038b4c:	00800084 	movi	r2,2
 2038b50:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 2038b54:	e0bffe07 	ldb	r2,-8(fp)
 2038b58:	0180fa04 	movi	r6,1000
 2038b5c:	100b883a 	mov	r5,r2
 2038b60:	01008174 	movhi	r4,517
 2038b64:	21227004 	addi	r4,r4,-30272
 2038b68:	20009e40 	call	20009e4 <printf>
 2038b6c:	00001c06 	br	2038be0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 2038b70:	e0bff943 	ldbu	r2,-27(fp)
 2038b74:	10000926 	beq	r2,zero,2038b9c <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 2038b78:	00800044 	movi	r2,1
 2038b7c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 2038b80:	e0bffe07 	ldb	r2,-8(fp)
 2038b84:	01801904 	movi	r6,100
 2038b88:	100b883a 	mov	r5,r2
 2038b8c:	01008174 	movhi	r4,517
 2038b90:	21227004 	addi	r4,r4,-30272
 2038b94:	20009e40 	call	20009e4 <printf>
 2038b98:	00001106 	br	2038be0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 2038b9c:	e0bff983 	ldbu	r2,-26(fp)
 2038ba0:	10000826 	beq	r2,zero,2038bc4 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 2038ba4:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 2038ba8:	e0bffe07 	ldb	r2,-8(fp)
 2038bac:	01800284 	movi	r6,10
 2038bb0:	100b883a 	mov	r5,r2
 2038bb4:	01008174 	movhi	r4,517
 2038bb8:	21227004 	addi	r4,r4,-30272
 2038bbc:	20009e40 	call	20009e4 <printf>
 2038bc0:	00000706 	br	2038be0 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 2038bc4:	00bfffc4 	movi	r2,-1
 2038bc8:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 2038bcc:	e0bffe07 	ldb	r2,-8(fp)
 2038bd0:	100b883a 	mov	r5,r2
 2038bd4:	01008174 	movhi	r4,517
 2038bd8:	21227d04 	addi	r4,r4,-30220
 2038bdc:	20009e40 	call	20009e4 <printf>

    return common_speed;
 2038be0:	e0bffa17 	ldw	r2,-24(fp)
}
 2038be4:	e037883a 	mov	sp,fp
 2038be8:	dfc00117 	ldw	ra,4(sp)
 2038bec:	df000017 	ldw	fp,0(sp)
 2038bf0:	dec00204 	addi	sp,sp,8
 2038bf4:	f800283a 	ret

02038bf8 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 2038bf8:	defff004 	addi	sp,sp,-64
 2038bfc:	dfc00f15 	stw	ra,60(sp)
 2038c00:	df000e15 	stw	fp,56(sp)
 2038c04:	dc400d15 	stw	r17,52(sp)
 2038c08:	dc000c15 	stw	r16,48(sp)
 2038c0c:	df000e04 	addi	fp,sp,56
 2038c10:	e13ffc15 	stw	r4,-16(fp)
 2038c14:	e17ffd15 	stw	r5,-12(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 2038c18:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 2038c1c:	e03ff615 	stw	zero,-40(fp)
    alt_tse_system_info *psys = 0;
 2038c20:	e03ff715 	stw	zero,-36(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 2038c24:	e03ff805 	stb	zero,-32(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2038c28:	e13ffc17 	ldw	r4,-16(fp)
 2038c2c:	203561c0 	call	203561c <alt_tse_get_mac_group_index>
 2038c30:	e0bff845 	stb	r2,-31(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2038c34:	e0bffc17 	ldw	r2,-16(fp)
 2038c38:	10800117 	ldw	r2,4(r2)
 2038c3c:	10800217 	ldw	r2,8(r2)
 2038c40:	10800017 	ldw	r2,0(r2)
 2038c44:	e0bff915 	stw	r2,-28(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 2038c48:	e0bff917 	ldw	r2,-28(fp)
 2038c4c:	10801004 	addi	r2,r2,64
 2038c50:	10800037 	ldwio	r2,0(r2)
 2038c54:	e0bffa15 	stw	r2,-24(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 2038c58:	e0bffd17 	ldw	r2,-12(fp)
 2038c5c:	10000316 	blt	r2,zero,2038c6c <alt_tse_phy_set_common_speed+0x74>
 2038c60:	e0bffd17 	ldw	r2,-12(fp)
 2038c64:	108000d0 	cmplti	r2,r2,3
 2038c68:	10000c1e 	bne	r2,zero,2038c9c <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 2038c6c:	e0bff847 	ldb	r2,-31(fp)
 2038c70:	e1bffd17 	ldw	r6,-12(fp)
 2038c74:	100b883a 	mov	r5,r2
 2038c78:	01008174 	movhi	r4,517
 2038c7c:	21228a04 	addi	r4,r4,-30168
 2038c80:	20009e40 	call	20009e4 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 2038c84:	e0bff917 	ldw	r2,-28(fp)
 2038c88:	10801004 	addi	r2,r2,64
 2038c8c:	e0fffa17 	ldw	r3,-24(fp)
 2038c90:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 2038c94:	00bfffc4 	movi	r2,-1
 2038c98:	0000fd06 	br	2039090 <alt_tse_phy_set_common_speed+0x498>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 2038c9c:	e03ff315 	stw	zero,-52(fp)
 2038ca0:	0000db06 	br	2039010 <alt_tse_phy_set_common_speed+0x418>
        pmac_info = pmac_group->pmac_info[i];
 2038ca4:	e0fffc17 	ldw	r3,-16(fp)
 2038ca8:	e0bff317 	ldw	r2,-52(fp)
 2038cac:	10800044 	addi	r2,r2,1
 2038cb0:	1085883a 	add	r2,r2,r2
 2038cb4:	1085883a 	add	r2,r2,r2
 2038cb8:	1885883a 	add	r2,r3,r2
 2038cbc:	10800017 	ldw	r2,0(r2)
 2038cc0:	e0bff615 	stw	r2,-40(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2038cc4:	e13ff617 	ldw	r4,-40(fp)
 2038cc8:	20356900 	call	2035690 <alt_tse_get_mac_info_index>
 2038ccc:	e0bff805 	stb	r2,-32(fp)

        pphy = pmac_info->pphy_info;
 2038cd0:	e0bff617 	ldw	r2,-40(fp)
 2038cd4:	10800117 	ldw	r2,4(r2)
 2038cd8:	e0bff515 	stw	r2,-44(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 2038cdc:	e0bff517 	ldw	r2,-44(fp)
 2038ce0:	1000c726 	beq	r2,zero,2039000 <alt_tse_phy_set_common_speed+0x408>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 2038ce4:	e0bff617 	ldw	r2,-40(fp)
 2038ce8:	10800217 	ldw	r2,8(r2)
 2038cec:	e0bff715 	stw	r2,-36(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2038cf0:	e0bff517 	ldw	r2,-44(fp)
 2038cf4:	10800003 	ldbu	r2,0(r2)
 2038cf8:	10803fcc 	andi	r2,r2,255
 2038cfc:	100b883a 	mov	r5,r2
 2038d00:	e13ff517 	ldw	r4,-44(fp)
 2038d04:	20364180 	call	2036418 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 2038d08:	e0bff517 	ldw	r2,-44(fp)
 2038d0c:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 2038d10:	10803fcc 	andi	r2,r2,255
 2038d14:	10000c1e 	bne	r2,zero,2038d48 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 2038d18:	e0bff517 	ldw	r2,-44(fp)
 2038d1c:	10800103 	ldbu	r2,4(r2)
 2038d20:	10803fcc 	andi	r2,r2,255
 2038d24:	1000081e 	bne	r2,zero,2038d48 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 2038d28:	e0bff517 	ldw	r2,-44(fp)
 2038d2c:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 2038d30:	10803fcc 	andi	r2,r2,255
 2038d34:	1000041e 	bne	r2,zero,2038d48 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 2038d38:	e0bff517 	ldw	r2,-44(fp)
 2038d3c:	10800083 	ldbu	r2,2(r2)
 2038d40:	10803fcc 	andi	r2,r2,255
 2038d44:	10000226 	beq	r2,zero,2038d50 <alt_tse_phy_set_common_speed+0x158>
 2038d48:	00800044 	movi	r2,1
 2038d4c:	00000106 	br	2038d54 <alt_tse_phy_set_common_speed+0x15c>
 2038d50:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 2038d54:	e0bffb05 	stb	r2,-20(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 2038d58:	e0bffb03 	ldbu	r2,-20(fp)
 2038d5c:	1000101e 	bne	r2,zero,2038da0 <alt_tse_phy_set_common_speed+0x1a8>
 2038d60:	e0bffd17 	ldw	r2,-12(fp)
 2038d64:	10800098 	cmpnei	r2,r2,2
 2038d68:	10000d1e 	bne	r2,zero,2038da0 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 2038d6c:	e0bff847 	ldb	r2,-31(fp)
 2038d70:	e0fff807 	ldb	r3,-32(fp)
 2038d74:	180d883a 	mov	r6,r3
 2038d78:	100b883a 	mov	r5,r2
 2038d7c:	01008174 	movhi	r4,517
 2038d80:	21229e04 	addi	r4,r4,-30088
 2038d84:	20009e40 	call	20009e4 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 2038d88:	e0bff917 	ldw	r2,-28(fp)
 2038d8c:	10801004 	addi	r2,r2,64
 2038d90:	e0fffa17 	ldw	r3,-24(fp)
 2038d94:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 2038d98:	00bfffc4 	movi	r2,-1
 2038d9c:	0000bc06 	br	2039090 <alt_tse_phy_set_common_speed+0x498>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 2038da0:	01c00044 	movi	r7,1
 2038da4:	018000c4 	movi	r6,3
 2038da8:	01400044 	movi	r5,1
 2038dac:	e13ff517 	ldw	r4,-44(fp)
 2038db0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038db4:	1000141e 	bne	r2,zero,2038e08 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 2038db8:	e0bffb03 	ldbu	r2,-20(fp)
 2038dbc:	10000926 	beq	r2,zero,2038de4 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 2038dc0:	e0bffd17 	ldw	r2,-12(fp)
 2038dc4:	1005d07a 	srai	r2,r2,1
 2038dc8:	10bfffcc 	andi	r2,r2,65535
 2038dcc:	d8800015 	stw	r2,0(sp)
 2038dd0:	01c00044 	movi	r7,1
 2038dd4:	01800184 	movi	r6,6
 2038dd8:	000b883a 	mov	r5,zero
 2038ddc:	e13ff517 	ldw	r4,-44(fp)
 2038de0:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 2038de4:	e0bffd17 	ldw	r2,-12(fp)
 2038de8:	10bfffcc 	andi	r2,r2,65535
 2038dec:	d8800015 	stw	r2,0(sp)
 2038df0:	01c00044 	movi	r7,1
 2038df4:	01800344 	movi	r6,13
 2038df8:	000b883a 	mov	r5,zero
 2038dfc:	e13ff517 	ldw	r4,-44(fp)
 2038e00:	20364700 	call	2036470 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 2038e04:	00007f06 	br	2039004 <alt_tse_phy_set_common_speed+0x40c>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 2038e08:	e0bffd17 	ldw	r2,-12(fp)
 2038e0c:	10800098 	cmpnei	r2,r2,2
 2038e10:	10000a1e 	bne	r2,zero,2038e3c <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 2038e14:	01400044 	movi	r5,1
 2038e18:	e13ff517 	ldw	r4,-44(fp)
 2038e1c:	20383100 	call	2038310 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 2038e20:	01400044 	movi	r5,1
 2038e24:	e13ff517 	ldw	r4,-44(fp)
 2038e28:	20384d40 	call	20384d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 2038e2c:	01400044 	movi	r5,1
 2038e30:	e13ff517 	ldw	r4,-44(fp)
 2038e34:	20387280 	call	2038728 <alt_tse_phy_set_adv_10>
 2038e38:	00002206 	br	2038ec4 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 2038e3c:	e0bffd17 	ldw	r2,-12(fp)
 2038e40:	10800058 	cmpnei	r2,r2,1
 2038e44:	10000a1e 	bne	r2,zero,2038e70 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 2038e48:	000b883a 	mov	r5,zero
 2038e4c:	e13ff517 	ldw	r4,-44(fp)
 2038e50:	20383100 	call	2038310 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 2038e54:	01400044 	movi	r5,1
 2038e58:	e13ff517 	ldw	r4,-44(fp)
 2038e5c:	20384d40 	call	20384d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 2038e60:	01400044 	movi	r5,1
 2038e64:	e13ff517 	ldw	r4,-44(fp)
 2038e68:	20387280 	call	2038728 <alt_tse_phy_set_adv_10>
 2038e6c:	00001506 	br	2038ec4 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 2038e70:	e0bffd17 	ldw	r2,-12(fp)
 2038e74:	10000a1e 	bne	r2,zero,2038ea0 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 2038e78:	000b883a 	mov	r5,zero
 2038e7c:	e13ff517 	ldw	r4,-44(fp)
 2038e80:	20383100 	call	2038310 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 2038e84:	000b883a 	mov	r5,zero
 2038e88:	e13ff517 	ldw	r4,-44(fp)
 2038e8c:	20384d40 	call	20384d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 2038e90:	01400044 	movi	r5,1
 2038e94:	e13ff517 	ldw	r4,-44(fp)
 2038e98:	20387280 	call	2038728 <alt_tse_phy_set_adv_10>
 2038e9c:	00000906 	br	2038ec4 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 2038ea0:	000b883a 	mov	r5,zero
 2038ea4:	e13ff517 	ldw	r4,-44(fp)
 2038ea8:	20383100 	call	2038310 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 2038eac:	000b883a 	mov	r5,zero
 2038eb0:	e13ff517 	ldw	r4,-44(fp)
 2038eb4:	20384d40 	call	20384d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 2038eb8:	000b883a 	mov	r5,zero
 2038ebc:	e13ff517 	ldw	r4,-44(fp)
 2038ec0:	20387280 	call	2038728 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 2038ec4:	01c00044 	movi	r7,1
 2038ec8:	01800144 	movi	r6,5
 2038ecc:	01400044 	movi	r5,1
 2038ed0:	e13ff517 	ldw	r4,-44(fp)
 2038ed4:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038ed8:	10800058 	cmpnei	r2,r2,1
 2038edc:	10003a1e 	bne	r2,zero,2038fc8 <alt_tse_phy_set_common_speed+0x3d0>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 2038ee0:	e0bffb03 	ldbu	r2,-20(fp)
 2038ee4:	10000f26 	beq	r2,zero,2038f24 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 2038ee8:	e0bff517 	ldw	r2,-44(fp)
 2038eec:	10800517 	ldw	r2,20(r2)
 2038ef0:	10801583 	ldbu	r2,86(r2)
 2038ef4:	10c03fcc 	andi	r3,r2,255
 2038ef8:	e0bff517 	ldw	r2,-44(fp)
 2038efc:	10800517 	ldw	r2,20(r2)
 2038f00:	108015c3 	ldbu	r2,87(r2)
 2038f04:	10803fcc 	andi	r2,r2,255
 2038f08:	01c00084 	movi	r7,2
 2038f0c:	100d883a 	mov	r6,r2
 2038f10:	180b883a 	mov	r5,r3
 2038f14:	e13ff517 	ldw	r4,-44(fp)
 2038f18:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038f1c:	e0bff405 	stb	r2,-48(fp)
 2038f20:	00000e06 	br	2038f5c <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 2038f24:	e0bff517 	ldw	r2,-44(fp)
 2038f28:	10800517 	ldw	r2,20(r2)
 2038f2c:	10801583 	ldbu	r2,86(r2)
 2038f30:	10c03fcc 	andi	r3,r2,255
 2038f34:	e0bff517 	ldw	r2,-44(fp)
 2038f38:	10800517 	ldw	r2,20(r2)
 2038f3c:	108015c3 	ldbu	r2,87(r2)
 2038f40:	10803fcc 	andi	r2,r2,255
 2038f44:	01c00044 	movi	r7,1
 2038f48:	100d883a 	mov	r6,r2
 2038f4c:	180b883a 	mov	r5,r3
 2038f50:	e13ff517 	ldw	r4,-44(fp)
 2038f54:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038f58:	e0bff405 	stb	r2,-48(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 2038f5c:	e0fff403 	ldbu	r3,-48(fp)
 2038f60:	e0bffd17 	ldw	r2,-12(fp)
 2038f64:	18800326 	beq	r3,r2,2038f74 <alt_tse_phy_set_common_speed+0x37c>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2038f68:	017e0034 	movhi	r5,63488
 2038f6c:	e13ff517 	ldw	r4,-44(fp)
 2038f70:	2037a600 	call	2037a60 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 2038f74:	e0bff517 	ldw	r2,-44(fp)
 2038f78:	10800517 	ldw	r2,20(r2)
 2038f7c:	10801583 	ldbu	r2,86(r2)
 2038f80:	10c03fcc 	andi	r3,r2,255
 2038f84:	e0bff517 	ldw	r2,-44(fp)
 2038f88:	10800517 	ldw	r2,20(r2)
 2038f8c:	10801603 	ldbu	r2,88(r2)
 2038f90:	10803fcc 	andi	r2,r2,255
 2038f94:	01c00044 	movi	r7,1
 2038f98:	100d883a 	mov	r6,r2
 2038f9c:	180b883a 	mov	r5,r3
 2038fa0:	e13ff517 	ldw	r4,-44(fp)
 2038fa4:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038fa8:	e0bffb45 	stb	r2,-19(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 2038fac:	e0bff717 	ldw	r2,-36(fp)
 2038fb0:	10800017 	ldw	r2,0(r2)
 2038fb4:	1007883a 	mov	r3,r2
 2038fb8:	e0bffb43 	ldbu	r2,-19(fp)
 2038fbc:	100b883a 	mov	r5,r2
 2038fc0:	1809883a 	mov	r4,r3
 2038fc4:	20358c80 	call	20358c8 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 2038fc8:	e43ff847 	ldb	r16,-31(fp)
 2038fcc:	e47ff807 	ldb	r17,-32(fp)
 2038fd0:	01c00404 	movi	r7,16
 2038fd4:	000d883a 	mov	r6,zero
 2038fd8:	01400044 	movi	r5,1
 2038fdc:	e13ff517 	ldw	r4,-44(fp)
 2038fe0:	20365980 	call	2036598 <alt_tse_phy_rd_mdio_reg>
 2038fe4:	100f883a 	mov	r7,r2
 2038fe8:	880d883a 	mov	r6,r17
 2038fec:	800b883a 	mov	r5,r16
 2038ff0:	01008174 	movhi	r4,517
 2038ff4:	2122b504 	addi	r4,r4,-29996
 2038ff8:	20009e40 	call	20009e4 <printf>
 2038ffc:	00000106 	br	2039004 <alt_tse_phy_set_common_speed+0x40c>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 2039000:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 2039004:	e0bff317 	ldw	r2,-52(fp)
 2039008:	10800044 	addi	r2,r2,1
 203900c:	e0bff315 	stw	r2,-52(fp)
 2039010:	e0bffc17 	ldw	r2,-16(fp)
 2039014:	10800003 	ldbu	r2,0(r2)
 2039018:	10803fcc 	andi	r2,r2,255
 203901c:	e0fff317 	ldw	r3,-52(fp)
 2039020:	18bf2016 	blt	r3,r2,2038ca4 <__alt_mem_mem_0+0xfd018ca4>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 2039024:	e0fff847 	ldb	r3,-31(fp)
 2039028:	e0bffd17 	ldw	r2,-12(fp)
 203902c:	108000a0 	cmpeqi	r2,r2,2
 2039030:	1000071e 	bne	r2,zero,2039050 <alt_tse_phy_set_common_speed+0x458>
 2039034:	e0bffd17 	ldw	r2,-12(fp)
 2039038:	10800058 	cmpnei	r2,r2,1
 203903c:	1000021e 	bne	r2,zero,2039048 <alt_tse_phy_set_common_speed+0x450>
 2039040:	00801904 	movi	r2,100
 2039044:	00000306 	br	2039054 <alt_tse_phy_set_common_speed+0x45c>
 2039048:	00800284 	movi	r2,10
 203904c:	00000106 	br	2039054 <alt_tse_phy_set_common_speed+0x45c>
 2039050:	0080fa04 	movi	r2,1000
 2039054:	100d883a 	mov	r6,r2
 2039058:	180b883a 	mov	r5,r3
 203905c:	01008174 	movhi	r4,517
 2039060:	2122c104 	addi	r4,r4,-29948
 2039064:	20009e40 	call	20009e4 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 2039068:	e0bffd17 	ldw	r2,-12(fp)
 203906c:	10803fcc 	andi	r2,r2,255
 2039070:	100b883a 	mov	r5,r2
 2039074:	e13ff917 	ldw	r4,-28(fp)
 2039078:	20357e80 	call	20357e8 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 203907c:	e0bff917 	ldw	r2,-28(fp)
 2039080:	10801004 	addi	r2,r2,64
 2039084:	e0fffa17 	ldw	r3,-24(fp)
 2039088:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 203908c:	e0bffd17 	ldw	r2,-12(fp)
}
 2039090:	e6fffe04 	addi	sp,fp,-8
 2039094:	dfc00317 	ldw	ra,12(sp)
 2039098:	df000217 	ldw	fp,8(sp)
 203909c:	dc400117 	ldw	r17,4(sp)
 20390a0:	dc000017 	ldw	r16,0(sp)
 20390a4:	dec00404 	addi	sp,sp,16
 20390a8:	f800283a 	ret

020390ac <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 20390ac:	defffc04 	addi	sp,sp,-16
 20390b0:	dfc00315 	stw	ra,12(sp)
 20390b4:	df000215 	stw	fp,8(sp)
 20390b8:	df000204 	addi	fp,sp,8
 20390bc:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & 1<<5) == 0) {
 20390c0:	e0bfff17 	ldw	r2,-4(fp)
 20390c4:	1080a104 	addi	r2,r2,644
 20390c8:	10800037 	ldwio	r2,0(r2)
 20390cc:	1080080c 	andi	r2,r2,32
 20390d0:	1000161e 	bne	r2,zero,203912c <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 20390d4:	01008174 	movhi	r4,517
 20390d8:	2122d204 	addi	r4,r4,-29880
 20390dc:	20426cc0 	call	20426cc <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 20390e0:	e0bfff17 	ldw	r2,-4(fp)
 20390e4:	1080a004 	addi	r2,r2,640
 20390e8:	10801004 	addi	r2,r2,64
 20390ec:	00c01e04 	movi	r3,120
 20390f0:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 20390f4:	01008174 	movhi	r4,517
 20390f8:	2122db04 	addi	r4,r4,-29844
 20390fc:	20426cc0 	call	20426cc <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 2039100:	e0bfff17 	ldw	r2,-4(fp)
 2039104:	1080a004 	addi	r2,r2,640
 2039108:	10800037 	ldwio	r2,0(r2)
 203910c:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);        
 2039110:	e0bfff17 	ldw	r2,-4(fp)
 2039114:	1080a004 	addi	r2,r2,640
 2039118:	e13ffe0b 	ldhu	r4,-8(fp)
 203911c:	00e00004 	movi	r3,-32768
 2039120:	20c6b03a 	or	r3,r4,r3
 2039124:	18ffffcc 	andi	r3,r3,65535
 2039128:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 203912c:	0005883a 	mov	r2,zero
}
 2039130:	e037883a 	mov	sp,fp
 2039134:	dfc00117 	ldw	ra,4(sp)
 2039138:	df000017 	ldw	fp,0(sp)
 203913c:	dec00204 	addi	sp,sp,8
 2039140:	f800283a 	ret

02039144 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 2039144:	defffc04 	addi	sp,sp,-16
 2039148:	dfc00315 	stw	ra,12(sp)
 203914c:	df000215 	stw	fp,8(sp)
 2039150:	df000204 	addi	fp,sp,8
 2039154:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 2039158:	e0bfff17 	ldw	r2,-4(fp)
 203915c:	1080bb04 	addi	r2,r2,748
 2039160:	10800037 	ldwio	r2,0(r2)
 2039164:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 2039168:	e0fffe0b 	ldhu	r3,-8(fp)
 203916c:	00bffc04 	movi	r2,-16
 2039170:	1884703a 	and	r2,r3,r2
 2039174:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 2039178:	01008174 	movhi	r4,517
 203917c:	2122e004 	addi	r4,r4,-29824
 2039180:	20426cc0 	call	20426cc <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 2039184:	e0bfff17 	ldw	r2,-4(fp)
 2039188:	1080bb04 	addi	r2,r2,748
 203918c:	e0fffe0b 	ldhu	r3,-8(fp)
 2039190:	18c003d4 	ori	r3,r3,15
 2039194:	18ffffcc 	andi	r3,r3,65535
 2039198:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 203919c:	01008174 	movhi	r4,517
 20391a0:	2122ec04 	addi	r4,r4,-29776
 20391a4:	20426cc0 	call	20426cc <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 20391a8:	e0bfff17 	ldw	r2,-4(fp)
 20391ac:	1080b404 	addi	r2,r2,720
 20391b0:	10800037 	ldwio	r2,0(r2)
 20391b4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 20391b8:	e0fffe0b 	ldhu	r3,-8(fp)
 20391bc:	00bfdf44 	movi	r2,-131
 20391c0:	1884703a 	and	r2,r3,r2
 20391c4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 20391c8:	e0bfff17 	ldw	r2,-4(fp)
 20391cc:	1080b404 	addi	r2,r2,720
 20391d0:	e0fffe0b 	ldhu	r3,-8(fp)
 20391d4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 20391d8:	01008174 	movhi	r4,517
 20391dc:	2122db04 	addi	r4,r4,-29844
 20391e0:	20426cc0 	call	20426cc <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 20391e4:	e0bfff17 	ldw	r2,-4(fp)
 20391e8:	1080a004 	addi	r2,r2,640
 20391ec:	10800037 	ldwio	r2,0(r2)
 20391f0:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 20391f4:	e0bfff17 	ldw	r2,-4(fp)
 20391f8:	1080a004 	addi	r2,r2,640
 20391fc:	e13ffe0b 	ldhu	r4,-8(fp)
 2039200:	00e00004 	movi	r3,-32768
 2039204:	20c6b03a 	or	r3,r4,r3
 2039208:	18ffffcc 	andi	r3,r3,65535
 203920c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 2039210:	00800044 	movi	r2,1
}
 2039214:	e037883a 	mov	sp,fp
 2039218:	dfc00117 	ldw	ra,4(sp)
 203921c:	df000017 	ldw	fp,0(sp)
 2039220:	dec00204 	addi	sp,sp,8
 2039224:	f800283a 	ret

02039228 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 2039228:	defffc04 	addi	sp,sp,-16
 203922c:	dfc00315 	stw	ra,12(sp)
 2039230:	df000215 	stw	fp,8(sp)
 2039234:	df000204 	addi	fp,sp,8
 2039238:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 203923c:	e0bfff17 	ldw	r2,-4(fp)
 2039240:	1080bb04 	addi	r2,r2,748
 2039244:	10800037 	ldwio	r2,0(r2)
 2039248:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 203924c:	e0fffe0b 	ldhu	r3,-8(fp)
 2039250:	00bffc04 	movi	r2,-16
 2039254:	1884703a 	and	r2,r3,r2
 2039258:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 203925c:	01008174 	movhi	r4,517
 2039260:	2122f604 	addi	r4,r4,-29736
 2039264:	20426cc0 	call	20426cc <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 2039268:	e0bfff17 	ldw	r2,-4(fp)
 203926c:	1080bb04 	addi	r2,r2,748
 2039270:	e0fffe0b 	ldhu	r3,-8(fp)
 2039274:	18c00114 	ori	r3,r3,4
 2039278:	18ffffcc 	andi	r3,r3,65535
 203927c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 2039280:	01008174 	movhi	r4,517
 2039284:	2122ec04 	addi	r4,r4,-29776
 2039288:	20426cc0 	call	20426cc <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 203928c:	e0bfff17 	ldw	r2,-4(fp)
 2039290:	1080b404 	addi	r2,r2,720
 2039294:	10800037 	ldwio	r2,0(r2)
 2039298:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 203929c:	e0fffe0b 	ldhu	r3,-8(fp)
 20392a0:	00bfdf44 	movi	r2,-131
 20392a4:	1884703a 	and	r2,r3,r2
 20392a8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 20392ac:	e0bfff17 	ldw	r2,-4(fp)
 20392b0:	1080b404 	addi	r2,r2,720
 20392b4:	e0fffe0b 	ldhu	r3,-8(fp)
 20392b8:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 20392bc:	01008174 	movhi	r4,517
 20392c0:	2122db04 	addi	r4,r4,-29844
 20392c4:	20426cc0 	call	20426cc <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 20392c8:	e0bfff17 	ldw	r2,-4(fp)
 20392cc:	1080a004 	addi	r2,r2,640
 20392d0:	10800037 	ldwio	r2,0(r2)
 20392d4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 20392d8:	e0bfff17 	ldw	r2,-4(fp)
 20392dc:	1080a004 	addi	r2,r2,640
 20392e0:	e13ffe0b 	ldhu	r4,-8(fp)
 20392e4:	00e00004 	movi	r3,-32768
 20392e8:	20c6b03a 	or	r3,r4,r3
 20392ec:	18ffffcc 	andi	r3,r3,65535
 20392f0:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 20392f4:	00800044 	movi	r2,1
}
 20392f8:	e037883a 	mov	sp,fp
 20392fc:	dfc00117 	ldw	ra,4(sp)
 2039300:	df000017 	ldw	fp,0(sp)
 2039304:	dec00204 	addi	sp,sp,8
 2039308:	f800283a 	ret

0203930c <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 203930c:	defffc04 	addi	sp,sp,-16
 2039310:	dfc00315 	stw	ra,12(sp)
 2039314:	df000215 	stw	fp,8(sp)
 2039318:	df000204 	addi	fp,sp,8
 203931c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 2039320:	e0bfff17 	ldw	r2,-4(fp)
 2039324:	1080bb04 	addi	r2,r2,748
 2039328:	10800037 	ldwio	r2,0(r2)
 203932c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 2039330:	e0fffe0b 	ldhu	r3,-8(fp)
 2039334:	00bffc04 	movi	r2,-16
 2039338:	1884703a 	and	r2,r3,r2
 203933c:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 2039340:	01008174 	movhi	r4,517
 2039344:	21230b04 	addi	r4,r4,-29652
 2039348:	20426cc0 	call	20426cc <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 203934c:	e0bfff17 	ldw	r2,-4(fp)
 2039350:	1080bb04 	addi	r2,r2,748
 2039354:	e0fffe0b 	ldhu	r3,-8(fp)
 2039358:	18c002d4 	ori	r3,r3,11
 203935c:	18ffffcc 	andi	r3,r3,65535
 2039360:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 2039364:	01008174 	movhi	r4,517
 2039368:	21231a04 	addi	r4,r4,-29592
 203936c:	20426cc0 	call	20426cc <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 2039370:	e0bfff17 	ldw	r2,-4(fp)
 2039374:	1080b404 	addi	r2,r2,720
 2039378:	10800037 	ldwio	r2,0(r2)
 203937c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 2039380:	e0fffe0b 	ldhu	r3,-8(fp)
 2039384:	00bfdf44 	movi	r2,-131
 2039388:	1884703a 	and	r2,r3,r2
 203938c:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 2039390:	e0bffe0b 	ldhu	r2,-8(fp)
 2039394:	10802094 	ori	r2,r2,130
 2039398:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 203939c:	e0bfff17 	ldw	r2,-4(fp)
 20393a0:	1080b404 	addi	r2,r2,720
 20393a4:	e0fffe0b 	ldhu	r3,-8(fp)
 20393a8:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 20393ac:	01008174 	movhi	r4,517
 20393b0:	2122db04 	addi	r4,r4,-29844
 20393b4:	20426cc0 	call	20426cc <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 20393b8:	e0bfff17 	ldw	r2,-4(fp)
 20393bc:	1080a004 	addi	r2,r2,640
 20393c0:	10800037 	ldwio	r2,0(r2)
 20393c4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 20393c8:	e0bfff17 	ldw	r2,-4(fp)
 20393cc:	1080a004 	addi	r2,r2,640
 20393d0:	e13ffe0b 	ldhu	r4,-8(fp)
 20393d4:	00e00004 	movi	r3,-32768
 20393d8:	20c6b03a 	or	r3,r4,r3
 20393dc:	18ffffcc 	andi	r3,r3,65535
 20393e0:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 20393e4:	00800044 	movi	r2,1
    
}
 20393e8:	e037883a 	mov	sp,fp
 20393ec:	dfc00117 	ldw	ra,4(sp)
 20393f0:	df000017 	ldw	fp,0(sp)
 20393f4:	dec00204 	addi	sp,sp,8
 20393f8:	f800283a 	ret

020393fc <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 20393fc:	defffc04 	addi	sp,sp,-16
 2039400:	df000315 	stw	fp,12(sp)
 2039404:	df000304 	addi	fp,sp,12
 2039408:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 203940c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 2039410:	e0bfff17 	ldw	r2,-4(fp)
 2039414:	1080b004 	addi	r2,r2,704
 2039418:	10800037 	ldwio	r2,0(r2)
 203941c:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 2039420:	e0bffe17 	ldw	r2,-8(fp)
 2039424:	1080008c 	andi	r2,r2,2
 2039428:	10000426 	beq	r2,zero,203943c <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 203942c:	e0bffd17 	ldw	r2,-12(fp)
 2039430:	10800214 	ori	r2,r2,8
 2039434:	e0bffd15 	stw	r2,-12(fp)
 2039438:	00000306 	br	2039448 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 203943c:	e0bffd17 	ldw	r2,-12(fp)
 2039440:	10800114 	ori	r2,r2,4
 2039444:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 2039448:	e0bffe17 	ldw	r2,-8(fp)
 203944c:	1080010c 	andi	r2,r2,4
 2039450:	10000326 	beq	r2,zero,2039460 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 2039454:	e0bffd17 	ldw	r2,-12(fp)
 2039458:	10800054 	ori	r2,r2,1
 203945c:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 2039460:	e0bffd17 	ldw	r2,-12(fp)
}
 2039464:	e037883a 	mov	sp,fp
 2039468:	df000017 	ldw	fp,0(sp)
 203946c:	dec00104 	addi	sp,sp,4
 2039470:	f800283a 	ret

02039474 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
 2039474:	defffe04 	addi	sp,sp,-8
 2039478:	df000115 	stw	fp,4(sp)
 203947c:	df000104 	addi	fp,sp,4
 2039480:	2005883a 	mov	r2,r4
 2039484:	e0bfff0d 	sth	r2,-4(fp)
  return PP_HTONS(n);
 2039488:	e0bfff0b 	ldhu	r2,-4(fp)
 203948c:	1004923a 	slli	r2,r2,8
 2039490:	1007883a 	mov	r3,r2
 2039494:	e0bfff0b 	ldhu	r2,-4(fp)
 2039498:	1004d23a 	srli	r2,r2,8
 203949c:	1884b03a 	or	r2,r3,r2
}
 20394a0:	e037883a 	mov	sp,fp
 20394a4:	df000017 	ldw	fp,0(sp)
 20394a8:	dec00104 	addi	sp,sp,4
 20394ac:	f800283a 	ret

020394b0 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
 20394b0:	defffe04 	addi	sp,sp,-8
 20394b4:	df000115 	stw	fp,4(sp)
 20394b8:	df000104 	addi	fp,sp,4
 20394bc:	e13fff15 	stw	r4,-4(fp)
  return PP_HTONL(n);
 20394c0:	e0bfff17 	ldw	r2,-4(fp)
 20394c4:	1006963a 	slli	r3,r2,24
 20394c8:	e0bfff17 	ldw	r2,-4(fp)
 20394cc:	10bfc00c 	andi	r2,r2,65280
 20394d0:	1004923a 	slli	r2,r2,8
 20394d4:	1886b03a 	or	r3,r3,r2
 20394d8:	e0bfff17 	ldw	r2,-4(fp)
 20394dc:	10803fec 	andhi	r2,r2,255
 20394e0:	1004d23a 	srli	r2,r2,8
 20394e4:	1886b03a 	or	r3,r3,r2
 20394e8:	e0bfff17 	ldw	r2,-4(fp)
 20394ec:	1004d63a 	srli	r2,r2,24
 20394f0:	1884b03a 	or	r2,r3,r2
}
 20394f4:	e037883a 	mov	sp,fp
 20394f8:	df000017 	ldw	fp,0(sp)
 20394fc:	dec00104 	addi	sp,sp,4
 2039500:	f800283a 	ret

02039504 <lwip_strnstr>:
 * lwIP default implementation for strnstr() non-standard function.
 * This can be \#defined to strnstr() depending on your platform port.
 */
char *
lwip_strnstr(const char *buffer, const char *token, size_t n)
{
 2039504:	defff904 	addi	sp,sp,-28
 2039508:	dfc00615 	stw	ra,24(sp)
 203950c:	df000515 	stw	fp,20(sp)
 2039510:	df000504 	addi	fp,sp,20
 2039514:	e13ffd15 	stw	r4,-12(fp)
 2039518:	e17ffe15 	stw	r5,-8(fp)
 203951c:	e1bfff15 	stw	r6,-4(fp)
  const char *p;
  size_t tokenlen = strlen(token);
 2039520:	e13ffe17 	ldw	r4,-8(fp)
 2039524:	20073a40 	call	20073a4 <strlen>
 2039528:	e0bffc15 	stw	r2,-16(fp)
  if (tokenlen == 0) {
 203952c:	e0bffc17 	ldw	r2,-16(fp)
 2039530:	1000021e 	bne	r2,zero,203953c <lwip_strnstr+0x38>
    return LWIP_CONST_CAST(char *, buffer);
 2039534:	e0bffd17 	ldw	r2,-12(fp)
 2039538:	00002606 	br	20395d4 <lwip_strnstr+0xd0>
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 203953c:	e0bffd17 	ldw	r2,-12(fp)
 2039540:	e0bffb15 	stw	r2,-20(fp)
 2039544:	00001506 	br	203959c <lwip_strnstr+0x98>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
 2039548:	e0bffb17 	ldw	r2,-20(fp)
 203954c:	10c00003 	ldbu	r3,0(r2)
 2039550:	e0bffe17 	ldw	r2,-8(fp)
 2039554:	10800003 	ldbu	r2,0(r2)
 2039558:	18c03fcc 	andi	r3,r3,255
 203955c:	18c0201c 	xori	r3,r3,128
 2039560:	18ffe004 	addi	r3,r3,-128
 2039564:	10803fcc 	andi	r2,r2,255
 2039568:	1080201c 	xori	r2,r2,128
 203956c:	10bfe004 	addi	r2,r2,-128
 2039570:	1880071e 	bne	r3,r2,2039590 <lwip_strnstr+0x8c>
 2039574:	e1bffc17 	ldw	r6,-16(fp)
 2039578:	e17ffe17 	ldw	r5,-8(fp)
 203957c:	e13ffb17 	ldw	r4,-20(fp)
 2039580:	204292c0 	call	204292c <strncmp>
 2039584:	1000021e 	bne	r2,zero,2039590 <lwip_strnstr+0x8c>
      return LWIP_CONST_CAST(char *, p);
 2039588:	e0bffb17 	ldw	r2,-20(fp)
 203958c:	00001106 	br	20395d4 <lwip_strnstr+0xd0>
  const char *p;
  size_t tokenlen = strlen(token);
  if (tokenlen == 0) {
    return LWIP_CONST_CAST(char *, buffer);
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 2039590:	e0bffb17 	ldw	r2,-20(fp)
 2039594:	10800044 	addi	r2,r2,1
 2039598:	e0bffb15 	stw	r2,-20(fp)
 203959c:	e0bffb17 	ldw	r2,-20(fp)
 20395a0:	10800003 	ldbu	r2,0(r2)
 20395a4:	10803fcc 	andi	r2,r2,255
 20395a8:	1080201c 	xori	r2,r2,128
 20395ac:	10bfe004 	addi	r2,r2,-128
 20395b0:	10000726 	beq	r2,zero,20395d0 <lwip_strnstr+0xcc>
 20395b4:	e0fffb17 	ldw	r3,-20(fp)
 20395b8:	e0bffc17 	ldw	r2,-16(fp)
 20395bc:	1885883a 	add	r2,r3,r2
 20395c0:	e13ffd17 	ldw	r4,-12(fp)
 20395c4:	e0ffff17 	ldw	r3,-4(fp)
 20395c8:	20c7883a 	add	r3,r4,r3
 20395cc:	18bfde2e 	bgeu	r3,r2,2039548 <__alt_mem_mem_0+0xfd019548>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
      return LWIP_CONST_CAST(char *, p);
    }
  }
  return NULL;
 20395d0:	0005883a 	mov	r2,zero
}
 20395d4:	e037883a 	mov	sp,fp
 20395d8:	dfc00117 	ldw	ra,4(sp)
 20395dc:	df000017 	ldw	fp,0(sp)
 20395e0:	dec00204 	addi	sp,sp,8
 20395e4:	f800283a 	ret

020395e8 <lwip_strnistr>:
 * lwIP default implementation for strnistr() non-standard function.
 * This can be \#defined to strnistr() depending on your platform port.
 */
char *
lwip_strnistr(const char *buffer, const char *token, size_t n)
{
 20395e8:	defff904 	addi	sp,sp,-28
 20395ec:	dfc00615 	stw	ra,24(sp)
 20395f0:	df000515 	stw	fp,20(sp)
 20395f4:	df000504 	addi	fp,sp,20
 20395f8:	e13ffd15 	stw	r4,-12(fp)
 20395fc:	e17ffe15 	stw	r5,-8(fp)
 2039600:	e1bfff15 	stw	r6,-4(fp)
  const char *p;
  size_t tokenlen = strlen(token);
 2039604:	e13ffe17 	ldw	r4,-8(fp)
 2039608:	20073a40 	call	20073a4 <strlen>
 203960c:	e0bffc15 	stw	r2,-16(fp)
  if (tokenlen == 0) {
 2039610:	e0bffc17 	ldw	r2,-16(fp)
 2039614:	1000021e 	bne	r2,zero,2039620 <lwip_strnistr+0x38>
    return LWIP_CONST_CAST(char *, buffer);
 2039618:	e0bffd17 	ldw	r2,-12(fp)
 203961c:	00001b06 	br	203968c <lwip_strnistr+0xa4>
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 2039620:	e0bffd17 	ldw	r2,-12(fp)
 2039624:	e0bffb15 	stw	r2,-20(fp)
 2039628:	00000a06 	br	2039654 <lwip_strnistr+0x6c>
    if (lwip_strnicmp(p, token, tokenlen) == 0) {
 203962c:	e1bffc17 	ldw	r6,-16(fp)
 2039630:	e17ffe17 	ldw	r5,-8(fp)
 2039634:	e13ffb17 	ldw	r4,-20(fp)
 2039638:	20397540 	call	2039754 <lwip_strnicmp>
 203963c:	1000021e 	bne	r2,zero,2039648 <lwip_strnistr+0x60>
      return LWIP_CONST_CAST(char *, p);
 2039640:	e0bffb17 	ldw	r2,-20(fp)
 2039644:	00001106 	br	203968c <lwip_strnistr+0xa4>
  const char *p;
  size_t tokenlen = strlen(token);
  if (tokenlen == 0) {
    return LWIP_CONST_CAST(char *, buffer);
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 2039648:	e0bffb17 	ldw	r2,-20(fp)
 203964c:	10800044 	addi	r2,r2,1
 2039650:	e0bffb15 	stw	r2,-20(fp)
 2039654:	e0bffb17 	ldw	r2,-20(fp)
 2039658:	10800003 	ldbu	r2,0(r2)
 203965c:	10803fcc 	andi	r2,r2,255
 2039660:	1080201c 	xori	r2,r2,128
 2039664:	10bfe004 	addi	r2,r2,-128
 2039668:	10000726 	beq	r2,zero,2039688 <lwip_strnistr+0xa0>
 203966c:	e0fffb17 	ldw	r3,-20(fp)
 2039670:	e0bffc17 	ldw	r2,-16(fp)
 2039674:	1885883a 	add	r2,r3,r2
 2039678:	e13ffd17 	ldw	r4,-12(fp)
 203967c:	e0ffff17 	ldw	r3,-4(fp)
 2039680:	20c7883a 	add	r3,r4,r3
 2039684:	18bfe92e 	bgeu	r3,r2,203962c <__alt_mem_mem_0+0xfd01962c>
    if (lwip_strnicmp(p, token, tokenlen) == 0) {
      return LWIP_CONST_CAST(char *, p);
    }
  }
  return NULL;
 2039688:	0005883a 	mov	r2,zero
}
 203968c:	e037883a 	mov	sp,fp
 2039690:	dfc00117 	ldw	ra,4(sp)
 2039694:	df000017 	ldw	fp,0(sp)
 2039698:	dec00204 	addi	sp,sp,8
 203969c:	f800283a 	ret

020396a0 <lwip_stricmp>:
 * lwIP default implementation for stricmp() non-standard function.
 * This can be \#defined to stricmp() depending on your platform port.
 */
int
lwip_stricmp(const char *str1, const char *str2)
{
 20396a0:	defffc04 	addi	sp,sp,-16
 20396a4:	df000315 	stw	fp,12(sp)
 20396a8:	df000304 	addi	fp,sp,12
 20396ac:	e13ffe15 	stw	r4,-8(fp)
 20396b0:	e17fff15 	stw	r5,-4(fp)
  char c1, c2;

  do {
    c1 = *str1++;
 20396b4:	e0bffe17 	ldw	r2,-8(fp)
 20396b8:	10c00044 	addi	r3,r2,1
 20396bc:	e0fffe15 	stw	r3,-8(fp)
 20396c0:	10800003 	ldbu	r2,0(r2)
 20396c4:	e0bffd05 	stb	r2,-12(fp)
    c2 = *str2++;
 20396c8:	e0bfff17 	ldw	r2,-4(fp)
 20396cc:	10c00044 	addi	r3,r2,1
 20396d0:	e0ffff15 	stw	r3,-4(fp)
 20396d4:	10800003 	ldbu	r2,0(r2)
 20396d8:	e0bffd45 	stb	r2,-11(fp)
    if (c1 != c2) {
 20396dc:	e0fffd07 	ldb	r3,-12(fp)
 20396e0:	e0bffd47 	ldb	r2,-11(fp)
 20396e4:	18801426 	beq	r3,r2,2039738 <lwip_stricmp+0x98>
      char c1_upc = c1 | 0x20;
 20396e8:	e0bffd03 	ldbu	r2,-12(fp)
 20396ec:	10800814 	ori	r2,r2,32
 20396f0:	e0bffd85 	stb	r2,-10(fp)
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 20396f4:	e0bffd87 	ldb	r2,-10(fp)
 20396f8:	10801850 	cmplti	r2,r2,97
 20396fc:	10000b1e 	bne	r2,zero,203972c <lwip_stricmp+0x8c>
 2039700:	e0bffd87 	ldb	r2,-10(fp)
 2039704:	10801ec8 	cmpgei	r2,r2,123
 2039708:	1000081e 	bne	r2,zero,203972c <lwip_stricmp+0x8c>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
 203970c:	e0bffd43 	ldbu	r2,-11(fp)
 2039710:	10800814 	ori	r2,r2,32
 2039714:	e0bffdc5 	stb	r2,-9(fp)
        if (c1_upc != c2_upc) {
 2039718:	e0fffd87 	ldb	r3,-10(fp)
 203971c:	e0bffdc7 	ldb	r2,-9(fp)
 2039720:	18800426 	beq	r3,r2,2039734 <lwip_stricmp+0x94>
          /* still not equal */
          /* don't care for < or > */
          return 1;
 2039724:	00800044 	movi	r2,1
 2039728:	00000606 	br	2039744 <lwip_stricmp+0xa4>
        }
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
 203972c:	00800044 	movi	r2,1
 2039730:	00000406 	br	2039744 <lwip_stricmp+0xa4>
  do {
    c1 = *str1++;
    c2 = *str2++;
    if (c1 != c2) {
      char c1_upc = c1 | 0x20;
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 2039734:	0001883a 	nop
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
      }
    }
  } while (c1 != 0);
 2039738:	e0bffd07 	ldb	r2,-12(fp)
 203973c:	103fdd1e 	bne	r2,zero,20396b4 <__alt_mem_mem_0+0xfd0196b4>
  return 0;
 2039740:	0005883a 	mov	r2,zero
}
 2039744:	e037883a 	mov	sp,fp
 2039748:	df000017 	ldw	fp,0(sp)
 203974c:	dec00104 	addi	sp,sp,4
 2039750:	f800283a 	ret

02039754 <lwip_strnicmp>:
 * lwIP default implementation for strnicmp() non-standard function.
 * This can be \#defined to strnicmp() depending on your platform port.
 */
int
lwip_strnicmp(const char *str1, const char *str2, size_t len)
{
 2039754:	defffb04 	addi	sp,sp,-20
 2039758:	df000415 	stw	fp,16(sp)
 203975c:	df000404 	addi	fp,sp,16
 2039760:	e13ffd15 	stw	r4,-12(fp)
 2039764:	e17ffe15 	stw	r5,-8(fp)
 2039768:	e1bfff15 	stw	r6,-4(fp)
  char c1, c2;

  do {
    c1 = *str1++;
 203976c:	e0bffd17 	ldw	r2,-12(fp)
 2039770:	10c00044 	addi	r3,r2,1
 2039774:	e0fffd15 	stw	r3,-12(fp)
 2039778:	10800003 	ldbu	r2,0(r2)
 203977c:	e0bffc05 	stb	r2,-16(fp)
    c2 = *str2++;
 2039780:	e0bffe17 	ldw	r2,-8(fp)
 2039784:	10c00044 	addi	r3,r2,1
 2039788:	e0fffe15 	stw	r3,-8(fp)
 203978c:	10800003 	ldbu	r2,0(r2)
 2039790:	e0bffc45 	stb	r2,-15(fp)
    if (c1 != c2) {
 2039794:	e0fffc07 	ldb	r3,-16(fp)
 2039798:	e0bffc47 	ldb	r2,-15(fp)
 203979c:	18801426 	beq	r3,r2,20397f0 <lwip_strnicmp+0x9c>
      char c1_upc = c1 | 0x20;
 20397a0:	e0bffc03 	ldbu	r2,-16(fp)
 20397a4:	10800814 	ori	r2,r2,32
 20397a8:	e0bffc85 	stb	r2,-14(fp)
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 20397ac:	e0bffc87 	ldb	r2,-14(fp)
 20397b0:	10801850 	cmplti	r2,r2,97
 20397b4:	10000b1e 	bne	r2,zero,20397e4 <lwip_strnicmp+0x90>
 20397b8:	e0bffc87 	ldb	r2,-14(fp)
 20397bc:	10801ec8 	cmpgei	r2,r2,123
 20397c0:	1000081e 	bne	r2,zero,20397e4 <lwip_strnicmp+0x90>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
 20397c4:	e0bffc43 	ldbu	r2,-15(fp)
 20397c8:	10800814 	ori	r2,r2,32
 20397cc:	e0bffcc5 	stb	r2,-13(fp)
        if (c1_upc != c2_upc) {
 20397d0:	e0fffc87 	ldb	r3,-14(fp)
 20397d4:	e0bffcc7 	ldb	r2,-13(fp)
 20397d8:	18800426 	beq	r3,r2,20397ec <lwip_strnicmp+0x98>
          /* still not equal */
          /* don't care for < or > */
          return 1;
 20397dc:	00800044 	movi	r2,1
 20397e0:	00000b06 	br	2039810 <lwip_strnicmp+0xbc>
        }
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
 20397e4:	00800044 	movi	r2,1
 20397e8:	00000906 	br	2039810 <lwip_strnicmp+0xbc>
  do {
    c1 = *str1++;
    c2 = *str2++;
    if (c1 != c2) {
      char c1_upc = c1 | 0x20;
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 20397ec:	0001883a 	nop
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
      }
    }
    len--;
 20397f0:	e0bfff17 	ldw	r2,-4(fp)
 20397f4:	10bfffc4 	addi	r2,r2,-1
 20397f8:	e0bfff15 	stw	r2,-4(fp)
  } while ((len != 0) && (c1 != 0));
 20397fc:	e0bfff17 	ldw	r2,-4(fp)
 2039800:	10000226 	beq	r2,zero,203980c <lwip_strnicmp+0xb8>
 2039804:	e0bffc07 	ldb	r2,-16(fp)
 2039808:	103fd81e 	bne	r2,zero,203976c <__alt_mem_mem_0+0xfd01976c>
  return 0;
 203980c:	0005883a 	mov	r2,zero
}
 2039810:	e037883a 	mov	sp,fp
 2039814:	df000017 	ldw	fp,0(sp)
 2039818:	dec00104 	addi	sp,sp,4
 203981c:	f800283a 	ret

02039820 <lwip_itoa>:
 * lwIP default implementation for itoa() non-standard function.
 * This can be \#defined to itoa() or snprintf(result, bufsize, "%d", number) depending on your platform port.
 */
void
lwip_itoa(char *result, size_t bufsize, int number)
{
 2039820:	defff704 	addi	sp,sp,-36
 2039824:	dfc00815 	stw	ra,32(sp)
 2039828:	df000715 	stw	fp,28(sp)
 203982c:	df000704 	addi	fp,sp,28
 2039830:	e13ffd15 	stw	r4,-12(fp)
 2039834:	e17ffe15 	stw	r5,-8(fp)
 2039838:	e1bfff15 	stw	r6,-4(fp)
  char *res = result;
 203983c:	e0bffd17 	ldw	r2,-12(fp)
 2039840:	e0bff915 	stw	r2,-28(fp)
  char *tmp = result + bufsize - 1;
 2039844:	e0bffe17 	ldw	r2,-8(fp)
 2039848:	10bfffc4 	addi	r2,r2,-1
 203984c:	e0fffd17 	ldw	r3,-12(fp)
 2039850:	1885883a 	add	r2,r3,r2
 2039854:	e0bffa15 	stw	r2,-24(fp)
  int n = (number >= 0) ? number : -number;
 2039858:	e0bfff17 	ldw	r2,-4(fp)
 203985c:	1000010e 	bge	r2,zero,2039864 <lwip_itoa+0x44>
 2039860:	0085c83a 	sub	r2,zero,r2
 2039864:	e0bffb15 	stw	r2,-20(fp)

  /* handle invalid bufsize */
  if (bufsize < 2) {
 2039868:	e0bffe17 	ldw	r2,-8(fp)
 203986c:	108000a8 	cmpgeui	r2,r2,2
 2039870:	1000061e 	bne	r2,zero,203988c <lwip_itoa+0x6c>
    if (bufsize == 1) {
 2039874:	e0bffe17 	ldw	r2,-8(fp)
 2039878:	10800058 	cmpnei	r2,r2,1
 203987c:	1000431e 	bne	r2,zero,203998c <lwip_itoa+0x16c>
      *result = 0;
 2039880:	e0bffd17 	ldw	r2,-12(fp)
 2039884:	10000005 	stb	zero,0(r2)
    }
    return;
 2039888:	00004006 	br	203998c <lwip_itoa+0x16c>
  }

  /* First, add sign */
  if (number < 0) {
 203988c:	e0bfff17 	ldw	r2,-4(fp)
 2039890:	1000050e 	bge	r2,zero,20398a8 <lwip_itoa+0x88>
    *res++ = '-';
 2039894:	e0bff917 	ldw	r2,-28(fp)
 2039898:	10c00044 	addi	r3,r2,1
 203989c:	e0fff915 	stw	r3,-28(fp)
 20398a0:	00c00b44 	movi	r3,45
 20398a4:	10c00005 	stb	r3,0(r2)
  }
  /* Then create the string from the end and stop if buffer full,
     and ensure output string is zero terminated */
  *tmp = 0;
 20398a8:	e0bffa17 	ldw	r2,-24(fp)
 20398ac:	10000005 	stb	zero,0(r2)
  while ((n != 0) && (tmp > res)) {
 20398b0:	00001106 	br	20398f8 <lwip_itoa+0xd8>
    char val = (char)('0' + (n % 10));
 20398b4:	e0bffb17 	ldw	r2,-20(fp)
 20398b8:	01400284 	movi	r5,10
 20398bc:	1009883a 	mov	r4,r2
 20398c0:	200aa680 	call	200aa68 <__modsi3>
 20398c4:	10800c04 	addi	r2,r2,48
 20398c8:	e0bffc05 	stb	r2,-16(fp)
    tmp--;
 20398cc:	e0bffa17 	ldw	r2,-24(fp)
 20398d0:	10bfffc4 	addi	r2,r2,-1
 20398d4:	e0bffa15 	stw	r2,-24(fp)
    *tmp = val;
 20398d8:	e0bffa17 	ldw	r2,-24(fp)
 20398dc:	e0fffc03 	ldbu	r3,-16(fp)
 20398e0:	10c00005 	stb	r3,0(r2)
    n = n / 10;
 20398e4:	e0bffb17 	ldw	r2,-20(fp)
 20398e8:	01400284 	movi	r5,10
 20398ec:	1009883a 	mov	r4,r2
 20398f0:	200a9e40 	call	200a9e4 <__divsi3>
 20398f4:	e0bffb15 	stw	r2,-20(fp)
    *res++ = '-';
  }
  /* Then create the string from the end and stop if buffer full,
     and ensure output string is zero terminated */
  *tmp = 0;
  while ((n != 0) && (tmp > res)) {
 20398f8:	e0bffb17 	ldw	r2,-20(fp)
 20398fc:	10000326 	beq	r2,zero,203990c <lwip_itoa+0xec>
 2039900:	e0bffa17 	ldw	r2,-24(fp)
 2039904:	e0fff917 	ldw	r3,-28(fp)
 2039908:	18bfea36 	bltu	r3,r2,20398b4 <__alt_mem_mem_0+0xfd0198b4>
    char val = (char)('0' + (n % 10));
    tmp--;
    *tmp = val;
    n = n / 10;
  }
  if (n) {
 203990c:	e0bffb17 	ldw	r2,-20(fp)
 2039910:	10000326 	beq	r2,zero,2039920 <lwip_itoa+0x100>
    /* buffer is too small */
    *result = 0;
 2039914:	e0bffd17 	ldw	r2,-12(fp)
 2039918:	10000005 	stb	zero,0(r2)
    return;
 203991c:	00001c06 	br	2039990 <lwip_itoa+0x170>
  }
  if (*tmp == 0) {
 2039920:	e0bffa17 	ldw	r2,-24(fp)
 2039924:	10800003 	ldbu	r2,0(r2)
 2039928:	10803fcc 	andi	r2,r2,255
 203992c:	1080201c 	xori	r2,r2,128
 2039930:	10bfe004 	addi	r2,r2,-128
 2039934:	10000a1e 	bne	r2,zero,2039960 <lwip_itoa+0x140>
    /* Nothing added? */
    *res++ = '0';
 2039938:	e0bff917 	ldw	r2,-28(fp)
 203993c:	10c00044 	addi	r3,r2,1
 2039940:	e0fff915 	stw	r3,-28(fp)
 2039944:	00c00c04 	movi	r3,48
 2039948:	10c00005 	stb	r3,0(r2)
    *res++ = 0;
 203994c:	e0bff917 	ldw	r2,-28(fp)
 2039950:	10c00044 	addi	r3,r2,1
 2039954:	e0fff915 	stw	r3,-28(fp)
 2039958:	10000005 	stb	zero,0(r2)
    return;
 203995c:	00000c06 	br	2039990 <lwip_itoa+0x170>
  }
  /* move from temporary buffer to output buffer (sign is not moved) */
  memmove(res, tmp, (size_t)((result + bufsize) - tmp));
 2039960:	e0fffd17 	ldw	r3,-12(fp)
 2039964:	e0bffe17 	ldw	r2,-8(fp)
 2039968:	1885883a 	add	r2,r3,r2
 203996c:	1007883a 	mov	r3,r2
 2039970:	e0bffa17 	ldw	r2,-24(fp)
 2039974:	1885c83a 	sub	r2,r3,r2
 2039978:	100d883a 	mov	r6,r2
 203997c:	e17ffa17 	ldw	r5,-24(fp)
 2039980:	e13ff917 	ldw	r4,-28(fp)
 2039984:	20094d40 	call	20094d4 <memmove>
 2039988:	00000106 	br	2039990 <lwip_itoa+0x170>
  /* handle invalid bufsize */
  if (bufsize < 2) {
    if (bufsize == 1) {
      *result = 0;
    }
    return;
 203998c:	0001883a 	nop
    *res++ = 0;
    return;
  }
  /* move from temporary buffer to output buffer (sign is not moved) */
  memmove(res, tmp, (size_t)((result + bufsize) - tmp));
}
 2039990:	e037883a 	mov	sp,fp
 2039994:	dfc00117 	ldw	ra,4(sp)
 2039998:	df000017 	ldw	fp,0(sp)
 203999c:	dec00204 	addi	sp,sp,8
 20399a0:	f800283a 	ret

020399a4 <lwip_standard_chksum>:
 *
 * by Curt McDowell, Broadcom Corp. December 8th, 2005
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 20399a4:	defff604 	addi	sp,sp,-40
 20399a8:	df000915 	stw	fp,36(sp)
 20399ac:	df000904 	addi	fp,sp,36
 20399b0:	e13ffe15 	stw	r4,-8(fp)
 20399b4:	e17fff15 	stw	r5,-4(fp)
  const u8_t *pb = (const u8_t *)dataptr;
 20399b8:	e0bffe17 	ldw	r2,-8(fp)
 20399bc:	e0bff715 	stw	r2,-36(fp)
  const u16_t *ps;
  u16_t t = 0;
 20399c0:	e03ffd0d 	sth	zero,-12(fp)
  const u32_t *pl;
  u32_t sum = 0, tmp;
 20399c4:	e03ffa15 	stw	zero,-24(fp)
  /* starts at odd byte address? */
  int odd = ((mem_ptr_t)pb & 1);
 20399c8:	e0bff717 	ldw	r2,-36(fp)
 20399cc:	1080004c 	andi	r2,r2,1
 20399d0:	e0bffc15 	stw	r2,-16(fp)

  if (odd && len > 0) {
 20399d4:	e0bffc17 	ldw	r2,-16(fp)
 20399d8:	10000c26 	beq	r2,zero,2039a0c <lwip_standard_chksum+0x68>
 20399dc:	e0bfff17 	ldw	r2,-4(fp)
 20399e0:	00800a0e 	bge	zero,r2,2039a0c <lwip_standard_chksum+0x68>
    ((u8_t *)&t)[1] = *pb++;
 20399e4:	e0bffd04 	addi	r2,fp,-12
 20399e8:	10800044 	addi	r2,r2,1
 20399ec:	e0fff717 	ldw	r3,-36(fp)
 20399f0:	19000044 	addi	r4,r3,1
 20399f4:	e13ff715 	stw	r4,-36(fp)
 20399f8:	18c00003 	ldbu	r3,0(r3)
 20399fc:	10c00005 	stb	r3,0(r2)
    len--;
 2039a00:	e0bfff17 	ldw	r2,-4(fp)
 2039a04:	10bfffc4 	addi	r2,r2,-1
 2039a08:	e0bfff15 	stw	r2,-4(fp)
  }

  ps = (const u16_t *)(const void *)pb;
 2039a0c:	e0bff717 	ldw	r2,-36(fp)
 2039a10:	e0bff815 	stw	r2,-32(fp)

  if (((mem_ptr_t)ps & 3) && len > 1) {
 2039a14:	e0bff817 	ldw	r2,-32(fp)
 2039a18:	108000cc 	andi	r2,r2,3
 2039a1c:	10000e26 	beq	r2,zero,2039a58 <lwip_standard_chksum+0xb4>
 2039a20:	e0bfff17 	ldw	r2,-4(fp)
 2039a24:	10800090 	cmplti	r2,r2,2
 2039a28:	10000b1e 	bne	r2,zero,2039a58 <lwip_standard_chksum+0xb4>
    sum += *ps++;
 2039a2c:	e0bff817 	ldw	r2,-32(fp)
 2039a30:	10c00084 	addi	r3,r2,2
 2039a34:	e0fff815 	stw	r3,-32(fp)
 2039a38:	1080000b 	ldhu	r2,0(r2)
 2039a3c:	10bfffcc 	andi	r2,r2,65535
 2039a40:	e0fffa17 	ldw	r3,-24(fp)
 2039a44:	1885883a 	add	r2,r3,r2
 2039a48:	e0bffa15 	stw	r2,-24(fp)
    len -= 2;
 2039a4c:	e0bfff17 	ldw	r2,-4(fp)
 2039a50:	10bfff84 	addi	r2,r2,-2
 2039a54:	e0bfff15 	stw	r2,-4(fp)
  }

  pl = (const u32_t *)(const void *)ps;
 2039a58:	e0bff817 	ldw	r2,-32(fp)
 2039a5c:	e0bff915 	stw	r2,-28(fp)

  while (len > 7)  {
 2039a60:	00001d06 	br	2039ad8 <lwip_standard_chksum+0x134>
    tmp = sum + *pl++;          /* ping */
 2039a64:	e0bff917 	ldw	r2,-28(fp)
 2039a68:	10c00104 	addi	r3,r2,4
 2039a6c:	e0fff915 	stw	r3,-28(fp)
 2039a70:	10c00017 	ldw	r3,0(r2)
 2039a74:	e0bffa17 	ldw	r2,-24(fp)
 2039a78:	1885883a 	add	r2,r3,r2
 2039a7c:	e0bffb15 	stw	r2,-20(fp)
    if (tmp < sum) {
 2039a80:	e0fffb17 	ldw	r3,-20(fp)
 2039a84:	e0bffa17 	ldw	r2,-24(fp)
 2039a88:	1880032e 	bgeu	r3,r2,2039a98 <lwip_standard_chksum+0xf4>
      tmp++;                    /* add back carry */
 2039a8c:	e0bffb17 	ldw	r2,-20(fp)
 2039a90:	10800044 	addi	r2,r2,1
 2039a94:	e0bffb15 	stw	r2,-20(fp)
    }

    sum = tmp + *pl++;          /* pong */
 2039a98:	e0bff917 	ldw	r2,-28(fp)
 2039a9c:	10c00104 	addi	r3,r2,4
 2039aa0:	e0fff915 	stw	r3,-28(fp)
 2039aa4:	10c00017 	ldw	r3,0(r2)
 2039aa8:	e0bffb17 	ldw	r2,-20(fp)
 2039aac:	1885883a 	add	r2,r3,r2
 2039ab0:	e0bffa15 	stw	r2,-24(fp)
    if (sum < tmp) {
 2039ab4:	e0fffa17 	ldw	r3,-24(fp)
 2039ab8:	e0bffb17 	ldw	r2,-20(fp)
 2039abc:	1880032e 	bgeu	r3,r2,2039acc <lwip_standard_chksum+0x128>
      sum++;                    /* add back carry */
 2039ac0:	e0bffa17 	ldw	r2,-24(fp)
 2039ac4:	10800044 	addi	r2,r2,1
 2039ac8:	e0bffa15 	stw	r2,-24(fp)
    }

    len -= 8;
 2039acc:	e0bfff17 	ldw	r2,-4(fp)
 2039ad0:	10bffe04 	addi	r2,r2,-8
 2039ad4:	e0bfff15 	stw	r2,-4(fp)
    len -= 2;
  }

  pl = (const u32_t *)(const void *)ps;

  while (len > 7)  {
 2039ad8:	e0bfff17 	ldw	r2,-4(fp)
 2039adc:	10800208 	cmpgei	r2,r2,8
 2039ae0:	103fe01e 	bne	r2,zero,2039a64 <__alt_mem_mem_0+0xfd019a64>

    len -= 8;
  }

  /* make room in upper bits */
  sum = FOLD_U32T(sum);
 2039ae4:	e0bffa17 	ldw	r2,-24(fp)
 2039ae8:	1006d43a 	srli	r3,r2,16
 2039aec:	e0bffa17 	ldw	r2,-24(fp)
 2039af0:	10bfffcc 	andi	r2,r2,65535
 2039af4:	1885883a 	add	r2,r3,r2
 2039af8:	e0bffa15 	stw	r2,-24(fp)

  ps = (const u16_t *)pl;
 2039afc:	e0bff917 	ldw	r2,-28(fp)
 2039b00:	e0bff815 	stw	r2,-32(fp)

  /* 16-bit aligned word remaining? */
  while (len > 1) {
 2039b04:	00000b06 	br	2039b34 <lwip_standard_chksum+0x190>
    sum += *ps++;
 2039b08:	e0bff817 	ldw	r2,-32(fp)
 2039b0c:	10c00084 	addi	r3,r2,2
 2039b10:	e0fff815 	stw	r3,-32(fp)
 2039b14:	1080000b 	ldhu	r2,0(r2)
 2039b18:	10bfffcc 	andi	r2,r2,65535
 2039b1c:	e0fffa17 	ldw	r3,-24(fp)
 2039b20:	1885883a 	add	r2,r3,r2
 2039b24:	e0bffa15 	stw	r2,-24(fp)
    len -= 2;
 2039b28:	e0bfff17 	ldw	r2,-4(fp)
 2039b2c:	10bfff84 	addi	r2,r2,-2
 2039b30:	e0bfff15 	stw	r2,-4(fp)
  sum = FOLD_U32T(sum);

  ps = (const u16_t *)pl;

  /* 16-bit aligned word remaining? */
  while (len > 1) {
 2039b34:	e0bfff17 	ldw	r2,-4(fp)
 2039b38:	10800088 	cmpgei	r2,r2,2
 2039b3c:	103ff21e 	bne	r2,zero,2039b08 <__alt_mem_mem_0+0xfd019b08>
    sum += *ps++;
    len -= 2;
  }

  /* dangling tail byte remaining? */
  if (len > 0) {                /* include odd byte */
 2039b40:	e0bfff17 	ldw	r2,-4(fp)
 2039b44:	0080040e 	bge	zero,r2,2039b58 <lwip_standard_chksum+0x1b4>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 2039b48:	e0bffd04 	addi	r2,fp,-12
 2039b4c:	e0fff817 	ldw	r3,-32(fp)
 2039b50:	18c00003 	ldbu	r3,0(r3)
 2039b54:	10c00005 	stb	r3,0(r2)
  }

  sum += t;                     /* add end bytes */
 2039b58:	e0bffd0b 	ldhu	r2,-12(fp)
 2039b5c:	10bfffcc 	andi	r2,r2,65535
 2039b60:	e0fffa17 	ldw	r3,-24(fp)
 2039b64:	1885883a 	add	r2,r3,r2
 2039b68:	e0bffa15 	stw	r2,-24(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 2039b6c:	e0bffa17 	ldw	r2,-24(fp)
 2039b70:	1006d43a 	srli	r3,r2,16
 2039b74:	e0bffa17 	ldw	r2,-24(fp)
 2039b78:	10bfffcc 	andi	r2,r2,65535
 2039b7c:	1885883a 	add	r2,r3,r2
 2039b80:	e0bffa15 	stw	r2,-24(fp)
  sum = FOLD_U32T(sum);
 2039b84:	e0bffa17 	ldw	r2,-24(fp)
 2039b88:	1006d43a 	srli	r3,r2,16
 2039b8c:	e0bffa17 	ldw	r2,-24(fp)
 2039b90:	10bfffcc 	andi	r2,r2,65535
 2039b94:	1885883a 	add	r2,r3,r2
 2039b98:	e0bffa15 	stw	r2,-24(fp)

  if (odd) {
 2039b9c:	e0bffc17 	ldw	r2,-16(fp)
 2039ba0:	10000826 	beq	r2,zero,2039bc4 <lwip_standard_chksum+0x220>
    sum = SWAP_BYTES_IN_WORD(sum);
 2039ba4:	e0bffa17 	ldw	r2,-24(fp)
 2039ba8:	1004923a 	slli	r2,r2,8
 2039bac:	10ffffcc 	andi	r3,r2,65535
 2039bb0:	e0bffa17 	ldw	r2,-24(fp)
 2039bb4:	10bfc00c 	andi	r2,r2,65280
 2039bb8:	1004d23a 	srli	r2,r2,8
 2039bbc:	1884b03a 	or	r2,r3,r2
 2039bc0:	e0bffa15 	stw	r2,-24(fp)
  }

  return (u16_t)sum;
 2039bc4:	e0bffa17 	ldw	r2,-24(fp)
}
 2039bc8:	e037883a 	mov	sp,fp
 2039bcc:	df000017 	ldw	fp,0(sp)
 2039bd0:	dec00104 	addi	sp,sp,4
 2039bd4:	f800283a 	ret

02039bd8 <inet_cksum_pseudo_base>:
#endif

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_base(struct pbuf *p, u8_t proto, u16_t proto_len, u32_t acc)
{
 2039bd8:	defff804 	addi	sp,sp,-32
 2039bdc:	dfc00715 	stw	ra,28(sp)
 2039be0:	df000615 	stw	fp,24(sp)
 2039be4:	df000604 	addi	fp,sp,24
 2039be8:	e13ffc15 	stw	r4,-16(fp)
 2039bec:	2807883a 	mov	r3,r5
 2039bf0:	3005883a 	mov	r2,r6
 2039bf4:	e1ffff15 	stw	r7,-4(fp)
 2039bf8:	e0fffd05 	stb	r3,-12(fp)
 2039bfc:	e0bffe0d 	sth	r2,-8(fp)
  struct pbuf *q;
  int swapped = 0;
 2039c00:	e03ffb15 	stw	zero,-20(fp)

  /* iterate through all pbuf in chain */
  for (q = p; q != NULL; q = q->next) {
 2039c04:	e0bffc17 	ldw	r2,-16(fp)
 2039c08:	e0bffa15 	stw	r2,-24(fp)
 2039c0c:	00002606 	br	2039ca8 <inet_cksum_pseudo_base+0xd0>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 2039c10:	e0bffa17 	ldw	r2,-24(fp)
 2039c14:	10c00117 	ldw	r3,4(r2)
 2039c18:	e0bffa17 	ldw	r2,-24(fp)
 2039c1c:	1080028b 	ldhu	r2,10(r2)
 2039c20:	10bfffcc 	andi	r2,r2,65535
 2039c24:	100b883a 	mov	r5,r2
 2039c28:	1809883a 	mov	r4,r3
 2039c2c:	20399a40 	call	20399a4 <lwip_standard_chksum>
 2039c30:	10bfffcc 	andi	r2,r2,65535
 2039c34:	e0ffff17 	ldw	r3,-4(fp)
 2039c38:	1885883a 	add	r2,r3,r2
 2039c3c:	e0bfff15 	stw	r2,-4(fp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 2039c40:	e0bfff17 	ldw	r2,-4(fp)
 2039c44:	1006d43a 	srli	r3,r2,16
 2039c48:	e0bfff17 	ldw	r2,-4(fp)
 2039c4c:	10bfffcc 	andi	r2,r2,65535
 2039c50:	1885883a 	add	r2,r3,r2
 2039c54:	e0bfff15 	stw	r2,-4(fp)
    if (q->len % 2 != 0) {
 2039c58:	e0bffa17 	ldw	r2,-24(fp)
 2039c5c:	1080028b 	ldhu	r2,10(r2)
 2039c60:	1080004c 	andi	r2,r2,1
 2039c64:	10bfffcc 	andi	r2,r2,65535
 2039c68:	10000c26 	beq	r2,zero,2039c9c <inet_cksum_pseudo_base+0xc4>
      swapped = !swapped;
 2039c6c:	e0bffb17 	ldw	r2,-20(fp)
 2039c70:	1005003a 	cmpeq	r2,r2,zero
 2039c74:	10803fcc 	andi	r2,r2,255
 2039c78:	e0bffb15 	stw	r2,-20(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 2039c7c:	e0bfff17 	ldw	r2,-4(fp)
 2039c80:	1004923a 	slli	r2,r2,8
 2039c84:	10ffffcc 	andi	r3,r2,65535
 2039c88:	e0bfff17 	ldw	r2,-4(fp)
 2039c8c:	10bfc00c 	andi	r2,r2,65280
 2039c90:	1004d23a 	srli	r2,r2,8
 2039c94:	1884b03a 	or	r2,r3,r2
 2039c98:	e0bfff15 	stw	r2,-4(fp)
{
  struct pbuf *q;
  int swapped = 0;

  /* iterate through all pbuf in chain */
  for (q = p; q != NULL; q = q->next) {
 2039c9c:	e0bffa17 	ldw	r2,-24(fp)
 2039ca0:	10800017 	ldw	r2,0(r2)
 2039ca4:	e0bffa15 	stw	r2,-24(fp)
 2039ca8:	e0bffa17 	ldw	r2,-24(fp)
 2039cac:	103fd81e 	bne	r2,zero,2039c10 <__alt_mem_mem_0+0xfd019c10>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 2039cb0:	e0bffb17 	ldw	r2,-20(fp)
 2039cb4:	10000826 	beq	r2,zero,2039cd8 <inet_cksum_pseudo_base+0x100>
    acc = SWAP_BYTES_IN_WORD(acc);
 2039cb8:	e0bfff17 	ldw	r2,-4(fp)
 2039cbc:	1004923a 	slli	r2,r2,8
 2039cc0:	10ffffcc 	andi	r3,r2,65535
 2039cc4:	e0bfff17 	ldw	r2,-4(fp)
 2039cc8:	10bfc00c 	andi	r2,r2,65280
 2039ccc:	1004d23a 	srli	r2,r2,8
 2039cd0:	1884b03a 	or	r2,r3,r2
 2039cd4:	e0bfff15 	stw	r2,-4(fp)
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 2039cd8:	e0bffd03 	ldbu	r2,-12(fp)
 2039cdc:	1009883a 	mov	r4,r2
 2039ce0:	20394740 	call	2039474 <lwip_htons>
 2039ce4:	10bfffcc 	andi	r2,r2,65535
 2039ce8:	e0ffff17 	ldw	r3,-4(fp)
 2039cec:	1885883a 	add	r2,r3,r2
 2039cf0:	e0bfff15 	stw	r2,-4(fp)
  acc += (u32_t)lwip_htons(proto_len);
 2039cf4:	e0bffe0b 	ldhu	r2,-8(fp)
 2039cf8:	1009883a 	mov	r4,r2
 2039cfc:	20394740 	call	2039474 <lwip_htons>
 2039d00:	10bfffcc 	andi	r2,r2,65535
 2039d04:	e0ffff17 	ldw	r3,-4(fp)
 2039d08:	1885883a 	add	r2,r3,r2
 2039d0c:	e0bfff15 	stw	r2,-4(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 2039d10:	e0bfff17 	ldw	r2,-4(fp)
 2039d14:	1006d43a 	srli	r3,r2,16
 2039d18:	e0bfff17 	ldw	r2,-4(fp)
 2039d1c:	10bfffcc 	andi	r2,r2,65535
 2039d20:	1885883a 	add	r2,r3,r2
 2039d24:	e0bfff15 	stw	r2,-4(fp)
  acc = FOLD_U32T(acc);
 2039d28:	e0bfff17 	ldw	r2,-4(fp)
 2039d2c:	1006d43a 	srli	r3,r2,16
 2039d30:	e0bfff17 	ldw	r2,-4(fp)
 2039d34:	10bfffcc 	andi	r2,r2,65535
 2039d38:	1885883a 	add	r2,r3,r2
 2039d3c:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 2039d40:	e0bfff17 	ldw	r2,-4(fp)
 2039d44:	0084303a 	nor	r2,zero,r2
}
 2039d48:	e037883a 	mov	sp,fp
 2039d4c:	dfc00117 	ldw	ra,4(sp)
 2039d50:	df000017 	ldw	fp,0(sp)
 2039d54:	dec00204 	addi	sp,sp,8
 2039d58:	f800283a 	ret

02039d5c <inet_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                   const ip4_addr_t *src, const ip4_addr_t *dest)
{
 2039d5c:	defff804 	addi	sp,sp,-32
 2039d60:	dfc00715 	stw	ra,28(sp)
 2039d64:	df000615 	stw	fp,24(sp)
 2039d68:	df000604 	addi	fp,sp,24
 2039d6c:	e13ffc15 	stw	r4,-16(fp)
 2039d70:	2807883a 	mov	r3,r5
 2039d74:	3005883a 	mov	r2,r6
 2039d78:	e1ffff15 	stw	r7,-4(fp)
 2039d7c:	e0fffd05 	stb	r3,-12(fp)
 2039d80:	e0bffe0d 	sth	r2,-8(fp)
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 2039d84:	e0bfff17 	ldw	r2,-4(fp)
 2039d88:	10800017 	ldw	r2,0(r2)
 2039d8c:	e0bffa15 	stw	r2,-24(fp)
  acc = (addr & 0xffffUL);
 2039d90:	e0bffa17 	ldw	r2,-24(fp)
 2039d94:	10bfffcc 	andi	r2,r2,65535
 2039d98:	e0bffb15 	stw	r2,-20(fp)
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 2039d9c:	e0bffa17 	ldw	r2,-24(fp)
 2039da0:	1004d43a 	srli	r2,r2,16
 2039da4:	e0fffb17 	ldw	r3,-20(fp)
 2039da8:	1885883a 	add	r2,r3,r2
 2039dac:	e0bffb15 	stw	r2,-20(fp)
  addr = ip4_addr_get_u32(dest);
 2039db0:	e0800217 	ldw	r2,8(fp)
 2039db4:	10800017 	ldw	r2,0(r2)
 2039db8:	e0bffa15 	stw	r2,-24(fp)
  acc = (u32_t)(acc + (addr & 0xffffUL));
 2039dbc:	e0bffa17 	ldw	r2,-24(fp)
 2039dc0:	10bfffcc 	andi	r2,r2,65535
 2039dc4:	e0fffb17 	ldw	r3,-20(fp)
 2039dc8:	1885883a 	add	r2,r3,r2
 2039dcc:	e0bffb15 	stw	r2,-20(fp)
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 2039dd0:	e0bffa17 	ldw	r2,-24(fp)
 2039dd4:	1004d43a 	srli	r2,r2,16
 2039dd8:	e0fffb17 	ldw	r3,-20(fp)
 2039ddc:	1885883a 	add	r2,r3,r2
 2039de0:	e0bffb15 	stw	r2,-20(fp)
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 2039de4:	e0bffb17 	ldw	r2,-20(fp)
 2039de8:	1006d43a 	srli	r3,r2,16
 2039dec:	e0bffb17 	ldw	r2,-20(fp)
 2039df0:	10bfffcc 	andi	r2,r2,65535
 2039df4:	1885883a 	add	r2,r3,r2
 2039df8:	e0bffb15 	stw	r2,-20(fp)
  acc = FOLD_U32T(acc);
 2039dfc:	e0bffb17 	ldw	r2,-20(fp)
 2039e00:	1006d43a 	srli	r3,r2,16
 2039e04:	e0bffb17 	ldw	r2,-20(fp)
 2039e08:	10bfffcc 	andi	r2,r2,65535
 2039e0c:	1885883a 	add	r2,r3,r2
 2039e10:	e0bffb15 	stw	r2,-20(fp)

  return inet_cksum_pseudo_base(p, proto, proto_len, acc);
 2039e14:	e0bffd03 	ldbu	r2,-12(fp)
 2039e18:	e0fffe0b 	ldhu	r3,-8(fp)
 2039e1c:	e1fffb17 	ldw	r7,-20(fp)
 2039e20:	180d883a 	mov	r6,r3
 2039e24:	100b883a 	mov	r5,r2
 2039e28:	e13ffc17 	ldw	r4,-16(fp)
 2039e2c:	2039bd80 	call	2039bd8 <inet_cksum_pseudo_base>
}
 2039e30:	e037883a 	mov	sp,fp
 2039e34:	dfc00117 	ldw	ra,4(sp)
 2039e38:	df000017 	ldw	fp,0(sp)
 2039e3c:	dec00204 	addi	sp,sp,8
 2039e40:	f800283a 	ret

02039e44 <ip_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                 const ip_addr_t *src, const ip_addr_t *dest)
{
 2039e44:	defff904 	addi	sp,sp,-28
 2039e48:	dfc00615 	stw	ra,24(sp)
 2039e4c:	df000515 	stw	fp,20(sp)
 2039e50:	df000504 	addi	fp,sp,20
 2039e54:	e13ffc15 	stw	r4,-16(fp)
 2039e58:	2807883a 	mov	r3,r5
 2039e5c:	3005883a 	mov	r2,r6
 2039e60:	e1ffff15 	stw	r7,-4(fp)
 2039e64:	e0fffd05 	stb	r3,-12(fp)
 2039e68:	e0bffe0d 	sth	r2,-8(fp)
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo(p, proto, proto_len, ip_2_ip4(src), ip_2_ip4(dest));
 2039e6c:	e0fffd03 	ldbu	r3,-12(fp)
 2039e70:	e13ffe0b 	ldhu	r4,-8(fp)
 2039e74:	e0800217 	ldw	r2,8(fp)
 2039e78:	d8800015 	stw	r2,0(sp)
 2039e7c:	e1ffff17 	ldw	r7,-4(fp)
 2039e80:	200d883a 	mov	r6,r4
 2039e84:	180b883a 	mov	r5,r3
 2039e88:	e13ffc17 	ldw	r4,-16(fp)
 2039e8c:	2039d5c0 	call	2039d5c <inet_chksum_pseudo>
  }
#endif /* LWIP_IPV4 */
}
 2039e90:	e037883a 	mov	sp,fp
 2039e94:	dfc00117 	ldw	ra,4(sp)
 2039e98:	df000017 	ldw	fp,0(sp)
 2039e9c:	dec00204 	addi	sp,sp,8
 2039ea0:	f800283a 	ret

02039ea4 <inet_cksum_pseudo_partial_base>:

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_partial_base(struct pbuf *p, u8_t proto, u16_t proto_len,
                               u16_t chksum_len, u32_t acc)
{
 2039ea4:	defff704 	addi	sp,sp,-36
 2039ea8:	dfc00815 	stw	ra,32(sp)
 2039eac:	df000715 	stw	fp,28(sp)
 2039eb0:	df000704 	addi	fp,sp,28
 2039eb4:	e13ffc15 	stw	r4,-16(fp)
 2039eb8:	2809883a 	mov	r4,r5
 2039ebc:	3007883a 	mov	r3,r6
 2039ec0:	3805883a 	mov	r2,r7
 2039ec4:	e13ffd05 	stb	r4,-12(fp)
 2039ec8:	e0fffe0d 	sth	r3,-8(fp)
 2039ecc:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *q;
  int swapped = 0;
 2039ed0:	e03ffa15 	stw	zero,-24(fp)
  u16_t chklen;

  /* iterate through all pbuf in chain */
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 2039ed4:	e0bffc17 	ldw	r2,-16(fp)
 2039ed8:	e0bff915 	stw	r2,-28(fp)
 2039edc:	00003006 	br	2039fa0 <inet_cksum_pseudo_partial_base+0xfc>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    chklen = q->len;
 2039ee0:	e0bff917 	ldw	r2,-28(fp)
 2039ee4:	1080028b 	ldhu	r2,10(r2)
 2039ee8:	e0bffb0d 	sth	r2,-20(fp)
    if (chklen > chksum_len) {
 2039eec:	e0bffb0b 	ldhu	r2,-20(fp)
 2039ef0:	e0ffff0b 	ldhu	r3,-4(fp)
 2039ef4:	1880022e 	bgeu	r3,r2,2039f00 <inet_cksum_pseudo_partial_base+0x5c>
      chklen = chksum_len;
 2039ef8:	e0bfff0b 	ldhu	r2,-4(fp)
 2039efc:	e0bffb0d 	sth	r2,-20(fp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 2039f00:	e0bff917 	ldw	r2,-28(fp)
 2039f04:	10800117 	ldw	r2,4(r2)
 2039f08:	e0fffb0b 	ldhu	r3,-20(fp)
 2039f0c:	180b883a 	mov	r5,r3
 2039f10:	1009883a 	mov	r4,r2
 2039f14:	20399a40 	call	20399a4 <lwip_standard_chksum>
 2039f18:	10bfffcc 	andi	r2,r2,65535
 2039f1c:	e0c00217 	ldw	r3,8(fp)
 2039f20:	1885883a 	add	r2,r3,r2
 2039f24:	e0800215 	stw	r2,8(fp)
    chksum_len = (u16_t)(chksum_len - chklen);
 2039f28:	e0ffff0b 	ldhu	r3,-4(fp)
 2039f2c:	e0bffb0b 	ldhu	r2,-20(fp)
 2039f30:	1885c83a 	sub	r2,r3,r2
 2039f34:	e0bfff0d 	sth	r2,-4(fp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 2039f38:	e0800217 	ldw	r2,8(fp)
 2039f3c:	1006d43a 	srli	r3,r2,16
 2039f40:	e0800217 	ldw	r2,8(fp)
 2039f44:	10bfffcc 	andi	r2,r2,65535
 2039f48:	1885883a 	add	r2,r3,r2
 2039f4c:	e0800215 	stw	r2,8(fp)
    if (q->len % 2 != 0) {
 2039f50:	e0bff917 	ldw	r2,-28(fp)
 2039f54:	1080028b 	ldhu	r2,10(r2)
 2039f58:	1080004c 	andi	r2,r2,1
 2039f5c:	10bfffcc 	andi	r2,r2,65535
 2039f60:	10000c26 	beq	r2,zero,2039f94 <inet_cksum_pseudo_partial_base+0xf0>
      swapped = !swapped;
 2039f64:	e0bffa17 	ldw	r2,-24(fp)
 2039f68:	1005003a 	cmpeq	r2,r2,zero
 2039f6c:	10803fcc 	andi	r2,r2,255
 2039f70:	e0bffa15 	stw	r2,-24(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 2039f74:	e0800217 	ldw	r2,8(fp)
 2039f78:	1004923a 	slli	r2,r2,8
 2039f7c:	10ffffcc 	andi	r3,r2,65535
 2039f80:	e0800217 	ldw	r2,8(fp)
 2039f84:	10bfc00c 	andi	r2,r2,65280
 2039f88:	1004d23a 	srli	r2,r2,8
 2039f8c:	1884b03a 	or	r2,r3,r2
 2039f90:	e0800215 	stw	r2,8(fp)
  struct pbuf *q;
  int swapped = 0;
  u16_t chklen;

  /* iterate through all pbuf in chain */
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 2039f94:	e0bff917 	ldw	r2,-28(fp)
 2039f98:	10800017 	ldw	r2,0(r2)
 2039f9c:	e0bff915 	stw	r2,-28(fp)
 2039fa0:	e0bff917 	ldw	r2,-28(fp)
 2039fa4:	10000226 	beq	r2,zero,2039fb0 <inet_cksum_pseudo_partial_base+0x10c>
 2039fa8:	e0bfff0b 	ldhu	r2,-4(fp)
 2039fac:	103fcc1e 	bne	r2,zero,2039ee0 <__alt_mem_mem_0+0xfd019ee0>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 2039fb0:	e0bffa17 	ldw	r2,-24(fp)
 2039fb4:	10000826 	beq	r2,zero,2039fd8 <inet_cksum_pseudo_partial_base+0x134>
    acc = SWAP_BYTES_IN_WORD(acc);
 2039fb8:	e0800217 	ldw	r2,8(fp)
 2039fbc:	1004923a 	slli	r2,r2,8
 2039fc0:	10ffffcc 	andi	r3,r2,65535
 2039fc4:	e0800217 	ldw	r2,8(fp)
 2039fc8:	10bfc00c 	andi	r2,r2,65280
 2039fcc:	1004d23a 	srli	r2,r2,8
 2039fd0:	1884b03a 	or	r2,r3,r2
 2039fd4:	e0800215 	stw	r2,8(fp)
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 2039fd8:	e0bffd03 	ldbu	r2,-12(fp)
 2039fdc:	1009883a 	mov	r4,r2
 2039fe0:	20394740 	call	2039474 <lwip_htons>
 2039fe4:	10bfffcc 	andi	r2,r2,65535
 2039fe8:	e0c00217 	ldw	r3,8(fp)
 2039fec:	1885883a 	add	r2,r3,r2
 2039ff0:	e0800215 	stw	r2,8(fp)
  acc += (u32_t)lwip_htons(proto_len);
 2039ff4:	e0bffe0b 	ldhu	r2,-8(fp)
 2039ff8:	1009883a 	mov	r4,r2
 2039ffc:	20394740 	call	2039474 <lwip_htons>
 203a000:	10bfffcc 	andi	r2,r2,65535
 203a004:	e0c00217 	ldw	r3,8(fp)
 203a008:	1885883a 	add	r2,r3,r2
 203a00c:	e0800215 	stw	r2,8(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 203a010:	e0800217 	ldw	r2,8(fp)
 203a014:	1006d43a 	srli	r3,r2,16
 203a018:	e0800217 	ldw	r2,8(fp)
 203a01c:	10bfffcc 	andi	r2,r2,65535
 203a020:	1885883a 	add	r2,r3,r2
 203a024:	e0800215 	stw	r2,8(fp)
  acc = FOLD_U32T(acc);
 203a028:	e0800217 	ldw	r2,8(fp)
 203a02c:	1006d43a 	srli	r3,r2,16
 203a030:	e0800217 	ldw	r2,8(fp)
 203a034:	10bfffcc 	andi	r2,r2,65535
 203a038:	1885883a 	add	r2,r3,r2
 203a03c:	e0800215 	stw	r2,8(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 203a040:	e0800217 	ldw	r2,8(fp)
 203a044:	0084303a 	nor	r2,zero,r2
}
 203a048:	e037883a 	mov	sp,fp
 203a04c:	dfc00117 	ldw	ra,4(sp)
 203a050:	df000017 	ldw	fp,0(sp)
 203a054:	dec00204 	addi	sp,sp,8
 203a058:	f800283a 	ret

0203a05c <inet_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                           u16_t chksum_len, const ip4_addr_t *src, const ip4_addr_t *dest)
{
 203a05c:	defff704 	addi	sp,sp,-36
 203a060:	dfc00815 	stw	ra,32(sp)
 203a064:	df000715 	stw	fp,28(sp)
 203a068:	df000704 	addi	fp,sp,28
 203a06c:	e13ffc15 	stw	r4,-16(fp)
 203a070:	2809883a 	mov	r4,r5
 203a074:	3007883a 	mov	r3,r6
 203a078:	3805883a 	mov	r2,r7
 203a07c:	e13ffd05 	stb	r4,-12(fp)
 203a080:	e0fffe0d 	sth	r3,-8(fp)
 203a084:	e0bfff0d 	sth	r2,-4(fp)
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 203a088:	e0800217 	ldw	r2,8(fp)
 203a08c:	10800017 	ldw	r2,0(r2)
 203a090:	e0bffa15 	stw	r2,-24(fp)
  acc = (addr & 0xffffUL);
 203a094:	e0bffa17 	ldw	r2,-24(fp)
 203a098:	10bfffcc 	andi	r2,r2,65535
 203a09c:	e0bffb15 	stw	r2,-20(fp)
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 203a0a0:	e0bffa17 	ldw	r2,-24(fp)
 203a0a4:	1004d43a 	srli	r2,r2,16
 203a0a8:	e0fffb17 	ldw	r3,-20(fp)
 203a0ac:	1885883a 	add	r2,r3,r2
 203a0b0:	e0bffb15 	stw	r2,-20(fp)
  addr = ip4_addr_get_u32(dest);
 203a0b4:	e0800317 	ldw	r2,12(fp)
 203a0b8:	10800017 	ldw	r2,0(r2)
 203a0bc:	e0bffa15 	stw	r2,-24(fp)
  acc = (u32_t)(acc + (addr & 0xffffUL));
 203a0c0:	e0bffa17 	ldw	r2,-24(fp)
 203a0c4:	10bfffcc 	andi	r2,r2,65535
 203a0c8:	e0fffb17 	ldw	r3,-20(fp)
 203a0cc:	1885883a 	add	r2,r3,r2
 203a0d0:	e0bffb15 	stw	r2,-20(fp)
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 203a0d4:	e0bffa17 	ldw	r2,-24(fp)
 203a0d8:	1004d43a 	srli	r2,r2,16
 203a0dc:	e0fffb17 	ldw	r3,-20(fp)
 203a0e0:	1885883a 	add	r2,r3,r2
 203a0e4:	e0bffb15 	stw	r2,-20(fp)
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 203a0e8:	e0bffb17 	ldw	r2,-20(fp)
 203a0ec:	1006d43a 	srli	r3,r2,16
 203a0f0:	e0bffb17 	ldw	r2,-20(fp)
 203a0f4:	10bfffcc 	andi	r2,r2,65535
 203a0f8:	1885883a 	add	r2,r3,r2
 203a0fc:	e0bffb15 	stw	r2,-20(fp)
  acc = FOLD_U32T(acc);
 203a100:	e0bffb17 	ldw	r2,-20(fp)
 203a104:	1006d43a 	srli	r3,r2,16
 203a108:	e0bffb17 	ldw	r2,-20(fp)
 203a10c:	10bfffcc 	andi	r2,r2,65535
 203a110:	1885883a 	add	r2,r3,r2
 203a114:	e0bffb15 	stw	r2,-20(fp)

  return inet_cksum_pseudo_partial_base(p, proto, proto_len, chksum_len, acc);
 203a118:	e0fffd03 	ldbu	r3,-12(fp)
 203a11c:	e13ffe0b 	ldhu	r4,-8(fp)
 203a120:	e17fff0b 	ldhu	r5,-4(fp)
 203a124:	e0bffb17 	ldw	r2,-20(fp)
 203a128:	d8800015 	stw	r2,0(sp)
 203a12c:	280f883a 	mov	r7,r5
 203a130:	200d883a 	mov	r6,r4
 203a134:	180b883a 	mov	r5,r3
 203a138:	e13ffc17 	ldw	r4,-16(fp)
 203a13c:	2039ea40 	call	2039ea4 <inet_cksum_pseudo_partial_base>
}
 203a140:	e037883a 	mov	sp,fp
 203a144:	dfc00117 	ldw	ra,4(sp)
 203a148:	df000017 	ldw	fp,0(sp)
 203a14c:	dec00204 	addi	sp,sp,8
 203a150:	f800283a 	ret

0203a154 <ip_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                         u16_t chksum_len, const ip_addr_t *src, const ip_addr_t *dest)
{
 203a154:	defff804 	addi	sp,sp,-32
 203a158:	dfc00715 	stw	ra,28(sp)
 203a15c:	df000615 	stw	fp,24(sp)
 203a160:	df000604 	addi	fp,sp,24
 203a164:	e13ffc15 	stw	r4,-16(fp)
 203a168:	2809883a 	mov	r4,r5
 203a16c:	3007883a 	mov	r3,r6
 203a170:	3805883a 	mov	r2,r7
 203a174:	e13ffd05 	stb	r4,-12(fp)
 203a178:	e0fffe0d 	sth	r3,-8(fp)
 203a17c:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo_partial(p, proto, proto_len, chksum_len, ip_2_ip4(src), ip_2_ip4(dest));
 203a180:	e0fffd03 	ldbu	r3,-12(fp)
 203a184:	e13ffe0b 	ldhu	r4,-8(fp)
 203a188:	e17fff0b 	ldhu	r5,-4(fp)
 203a18c:	e0800317 	ldw	r2,12(fp)
 203a190:	d8800115 	stw	r2,4(sp)
 203a194:	e0800217 	ldw	r2,8(fp)
 203a198:	d8800015 	stw	r2,0(sp)
 203a19c:	280f883a 	mov	r7,r5
 203a1a0:	200d883a 	mov	r6,r4
 203a1a4:	180b883a 	mov	r5,r3
 203a1a8:	e13ffc17 	ldw	r4,-16(fp)
 203a1ac:	203a05c0 	call	203a05c <inet_chksum_pseudo_partial>
  }
#endif /* LWIP_IPV4 */
}
 203a1b0:	e037883a 	mov	sp,fp
 203a1b4:	dfc00117 	ldw	ra,4(sp)
 203a1b8:	df000017 	ldw	fp,0(sp)
 203a1bc:	dec00204 	addi	sp,sp,8
 203a1c0:	f800283a 	ret

0203a1c4 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
 203a1c4:	defffc04 	addi	sp,sp,-16
 203a1c8:	dfc00315 	stw	ra,12(sp)
 203a1cc:	df000215 	stw	fp,8(sp)
 203a1d0:	df000204 	addi	fp,sp,8
 203a1d4:	e13ffe15 	stw	r4,-8(fp)
 203a1d8:	2805883a 	mov	r2,r5
 203a1dc:	e0bfff0d 	sth	r2,-4(fp)
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 203a1e0:	e0bfff0b 	ldhu	r2,-4(fp)
 203a1e4:	100b883a 	mov	r5,r2
 203a1e8:	e13ffe17 	ldw	r4,-8(fp)
 203a1ec:	20399a40 	call	20399a4 <lwip_standard_chksum>
 203a1f0:	0084303a 	nor	r2,zero,r2
}
 203a1f4:	e037883a 	mov	sp,fp
 203a1f8:	dfc00117 	ldw	ra,4(sp)
 203a1fc:	df000017 	ldw	fp,0(sp)
 203a200:	dec00204 	addi	sp,sp,8
 203a204:	f800283a 	ret

0203a208 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 203a208:	defffa04 	addi	sp,sp,-24
 203a20c:	dfc00515 	stw	ra,20(sp)
 203a210:	df000415 	stw	fp,16(sp)
 203a214:	df000404 	addi	fp,sp,16
 203a218:	e13fff15 	stw	r4,-4(fp)
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;
 203a21c:	e03ffe15 	stw	zero,-8(fp)

  acc = 0;
 203a220:	e03ffc15 	stw	zero,-16(fp)
  for (q = p; q != NULL; q = q->next) {
 203a224:	e0bfff17 	ldw	r2,-4(fp)
 203a228:	e0bffd15 	stw	r2,-12(fp)
 203a22c:	00002606 	br	203a2c8 <inet_chksum_pbuf+0xc0>
    acc += LWIP_CHKSUM(q->payload, q->len);
 203a230:	e0bffd17 	ldw	r2,-12(fp)
 203a234:	10c00117 	ldw	r3,4(r2)
 203a238:	e0bffd17 	ldw	r2,-12(fp)
 203a23c:	1080028b 	ldhu	r2,10(r2)
 203a240:	10bfffcc 	andi	r2,r2,65535
 203a244:	100b883a 	mov	r5,r2
 203a248:	1809883a 	mov	r4,r3
 203a24c:	20399a40 	call	20399a4 <lwip_standard_chksum>
 203a250:	10bfffcc 	andi	r2,r2,65535
 203a254:	e0fffc17 	ldw	r3,-16(fp)
 203a258:	1885883a 	add	r2,r3,r2
 203a25c:	e0bffc15 	stw	r2,-16(fp)
    acc = FOLD_U32T(acc);
 203a260:	e0bffc17 	ldw	r2,-16(fp)
 203a264:	1006d43a 	srli	r3,r2,16
 203a268:	e0bffc17 	ldw	r2,-16(fp)
 203a26c:	10bfffcc 	andi	r2,r2,65535
 203a270:	1885883a 	add	r2,r3,r2
 203a274:	e0bffc15 	stw	r2,-16(fp)
    if (q->len % 2 != 0) {
 203a278:	e0bffd17 	ldw	r2,-12(fp)
 203a27c:	1080028b 	ldhu	r2,10(r2)
 203a280:	1080004c 	andi	r2,r2,1
 203a284:	10bfffcc 	andi	r2,r2,65535
 203a288:	10000c26 	beq	r2,zero,203a2bc <inet_chksum_pbuf+0xb4>
      swapped = !swapped;
 203a28c:	e0bffe17 	ldw	r2,-8(fp)
 203a290:	1005003a 	cmpeq	r2,r2,zero
 203a294:	10803fcc 	andi	r2,r2,255
 203a298:	e0bffe15 	stw	r2,-8(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 203a29c:	e0bffc17 	ldw	r2,-16(fp)
 203a2a0:	1004923a 	slli	r2,r2,8
 203a2a4:	10ffffcc 	andi	r3,r2,65535
 203a2a8:	e0bffc17 	ldw	r2,-16(fp)
 203a2ac:	10bfc00c 	andi	r2,r2,65280
 203a2b0:	1004d23a 	srli	r2,r2,8
 203a2b4:	1884b03a 	or	r2,r3,r2
 203a2b8:	e0bffc15 	stw	r2,-16(fp)
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;

  acc = 0;
  for (q = p; q != NULL; q = q->next) {
 203a2bc:	e0bffd17 	ldw	r2,-12(fp)
 203a2c0:	10800017 	ldw	r2,0(r2)
 203a2c4:	e0bffd15 	stw	r2,-12(fp)
 203a2c8:	e0bffd17 	ldw	r2,-12(fp)
 203a2cc:	103fd81e 	bne	r2,zero,203a230 <__alt_mem_mem_0+0xfd01a230>
      swapped = !swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 203a2d0:	e0bffe17 	ldw	r2,-8(fp)
 203a2d4:	10000826 	beq	r2,zero,203a2f8 <inet_chksum_pbuf+0xf0>
    acc = SWAP_BYTES_IN_WORD(acc);
 203a2d8:	e0bffc17 	ldw	r2,-16(fp)
 203a2dc:	1004923a 	slli	r2,r2,8
 203a2e0:	10ffffcc 	andi	r3,r2,65535
 203a2e4:	e0bffc17 	ldw	r2,-16(fp)
 203a2e8:	10bfc00c 	andi	r2,r2,65280
 203a2ec:	1004d23a 	srli	r2,r2,8
 203a2f0:	1884b03a 	or	r2,r3,r2
 203a2f4:	e0bffc15 	stw	r2,-16(fp)
  }
  return (u16_t)~(acc & 0xffffUL);
 203a2f8:	e0bffc17 	ldw	r2,-16(fp)
 203a2fc:	0084303a 	nor	r2,zero,r2
}
 203a300:	e037883a 	mov	sp,fp
 203a304:	dfc00117 	ldw	ra,4(sp)
 203a308:	df000017 	ldw	fp,0(sp)
 203a30c:	dec00204 	addi	sp,sp,8
 203a310:	f800283a 	ret

0203a314 <lwip_chksum_copy>:
 * For architectures with big caches, data might still be in cache when
 * generating the checksum after copying.
 */
u16_t
lwip_chksum_copy(void *dst, const void *src, u16_t len)
{
 203a314:	defffb04 	addi	sp,sp,-20
 203a318:	dfc00415 	stw	ra,16(sp)
 203a31c:	df000315 	stw	fp,12(sp)
 203a320:	df000304 	addi	fp,sp,12
 203a324:	e13ffd15 	stw	r4,-12(fp)
 203a328:	e17ffe15 	stw	r5,-8(fp)
 203a32c:	3005883a 	mov	r2,r6
 203a330:	e0bfff0d 	sth	r2,-4(fp)
  MEMCPY(dst, src, len);
 203a334:	e0bfff0b 	ldhu	r2,-4(fp)
 203a338:	100d883a 	mov	r6,r2
 203a33c:	e17ffe17 	ldw	r5,-8(fp)
 203a340:	e13ffd17 	ldw	r4,-12(fp)
 203a344:	2005e580 	call	2005e58 <memcpy>
  return LWIP_CHKSUM(dst, len);
 203a348:	e0bfff0b 	ldhu	r2,-4(fp)
 203a34c:	100b883a 	mov	r5,r2
 203a350:	e13ffd17 	ldw	r4,-12(fp)
 203a354:	20399a40 	call	20399a4 <lwip_standard_chksum>
}
 203a358:	e037883a 	mov	sp,fp
 203a35c:	dfc00117 	ldw	ra,4(sp)
 203a360:	df000017 	ldw	fp,0(sp)
 203a364:	dec00204 	addi	sp,sp,8
 203a368:	f800283a 	ret

0203a36c <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 203a36c:	defffd04 	addi	sp,sp,-12
 203a370:	dfc00215 	stw	ra,8(sp)
 203a374:	df000115 	stw	fp,4(sp)
 203a378:	df000104 	addi	fp,sp,4
#ifndef LWIP_SKIP_CONST_CHECK
  int a = 0;
 203a37c:	e03fff15 	stw	zero,-4(fp)
#ifndef LWIP_SKIP_PACKING_CHECK
  LWIP_ASSERT("Struct packing not implemented correctly. Check your lwIP port.", sizeof(struct packed_struct_test) == PACKED_STRUCT_TEST_EXPECTED_SIZE);
#endif

  /* Modules initialization */
  stats_init();
 203a380:	201ed600 	call	201ed60 <stats_init>
#if !NO_SYS
  sys_init();
 203a384:	2014c7c0 	call	2014c7c <sys_init>
#endif /* !NO_SYS */
  mem_init();
 203a388:	201ab680 	call	201ab68 <mem_init>
  memp_init();
 203a38c:	201b6640 	call	201b664 <memp_init>
  pbuf_init();
  netif_init();
 203a390:	201b9dc0 	call	201b9dc <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 203a394:	202982c0 	call	202982c <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 203a398:	201ed800 	call	201ed80 <tcp_init>
#if PPP_SUPPORT
  ppp_init();
#endif

#if LWIP_TIMERS
  sys_timeouts_init();
 203a39c:	20294e00 	call	20294e0 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 203a3a0:	0001883a 	nop
 203a3a4:	e037883a 	mov	sp,fp
 203a3a8:	dfc00117 	ldw	ra,4(sp)
 203a3ac:	df000017 	ldw	fp,0(sp)
 203a3b0:	dec00204 	addi	sp,sp,8
 203a3b4:	f800283a 	ret

0203a3b8 <acd_add>:
 *                              is available
 */
err_t
acd_add(struct netif *netif, struct acd *acd,
         acd_conflict_callback_t acd_conflict_callback)
{
 203a3b8:	defffb04 	addi	sp,sp,-20
 203a3bc:	df000415 	stw	fp,16(sp)
 203a3c0:	df000404 	addi	fp,sp,16
 203a3c4:	e13ffd15 	stw	r4,-12(fp)
 203a3c8:	e17ffe15 	stw	r5,-8(fp)
 203a3cc:	e1bfff15 	stw	r6,-4(fp)
  struct acd *acd2;

  /* Set callback */
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("acd_conflict_callback != NULL", acd_conflict_callback != NULL);
  acd->acd_conflict_callback = acd_conflict_callback;
 203a3d0:	e0bffe17 	ldw	r2,-8(fp)
 203a3d4:	e0ffff17 	ldw	r3,-4(fp)
 203a3d8:	10c00515 	stw	r3,20(r2)

  /* Check if the acd struct is already added */
  for (acd2 = netif->acd_list; acd2 != NULL; acd2 = acd2->next) {
 203a3dc:	e0bffd17 	ldw	r2,-12(fp)
 203a3e0:	10801117 	ldw	r2,68(r2)
 203a3e4:	e0bffc15 	stw	r2,-16(fp)
 203a3e8:	00000806 	br	203a40c <acd_add+0x54>
    if (acd2 == acd) {
 203a3ec:	e0fffc17 	ldw	r3,-16(fp)
 203a3f0:	e0bffe17 	ldw	r2,-8(fp)
 203a3f4:	1880021e 	bne	r3,r2,203a400 <acd_add+0x48>
      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                  ("acd_add(): acd already added to list\n"));
      return ERR_OK;
 203a3f8:	0005883a 	mov	r2,zero
 203a3fc:	00000d06 	br	203a434 <acd_add+0x7c>
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("acd_conflict_callback != NULL", acd_conflict_callback != NULL);
  acd->acd_conflict_callback = acd_conflict_callback;

  /* Check if the acd struct is already added */
  for (acd2 = netif->acd_list; acd2 != NULL; acd2 = acd2->next) {
 203a400:	e0bffc17 	ldw	r2,-16(fp)
 203a404:	10800017 	ldw	r2,0(r2)
 203a408:	e0bffc15 	stw	r2,-16(fp)
 203a40c:	e0bffc17 	ldw	r2,-16(fp)
 203a410:	103ff61e 	bne	r2,zero,203a3ec <__alt_mem_mem_0+0xfd01a3ec>
      return ERR_OK;
    }
  }

  /* add acd struct to the list */
  acd->next = netif->acd_list;
 203a414:	e0bffd17 	ldw	r2,-12(fp)
 203a418:	10c01117 	ldw	r3,68(r2)
 203a41c:	e0bffe17 	ldw	r2,-8(fp)
 203a420:	10c00015 	stw	r3,0(r2)
  netif->acd_list = acd;
 203a424:	e0bffd17 	ldw	r2,-12(fp)
 203a428:	e0fffe17 	ldw	r3,-8(fp)
 203a42c:	10c01115 	stw	r3,68(r2)

  return ERR_OK;
 203a430:	0005883a 	mov	r2,zero
}
 203a434:	e037883a 	mov	sp,fp
 203a438:	df000017 	ldw	fp,0(sp)
 203a43c:	dec00104 	addi	sp,sp,4
 203a440:	f800283a 	ret

0203a444 <acd_start>:
 * @param acd     acd module to start
 * @param ipaddr  ip address to perform acd on
 */
err_t
acd_start(struct netif *netif, struct acd *acd, ip4_addr_t ipaddr)
{
 203a444:	defffa04 	addi	sp,sp,-24
 203a448:	dfc00515 	stw	ra,20(sp)
 203a44c:	df000415 	stw	fp,16(sp)
 203a450:	df000404 	addi	fp,sp,16
 203a454:	e13ffd15 	stw	r4,-12(fp)
 203a458:	e17ffe15 	stw	r5,-8(fp)
 203a45c:	e1bfff15 	stw	r6,-4(fp)
  err_t result = ERR_OK;
 203a460:	e03ffc05 	stb	zero,-16(fp)
              ("acd_start(netif=%p) %c%c%"U16_F"\n",
              (void *)netif, netif->name[0],
               netif->name[1], (u16_t)netif->num));

  /* init probing state */
  acd->sent_num = 0;
 203a464:	e0bffe17 	ldw	r2,-8(fp)
 203a468:	10000305 	stb	zero,12(r2)
  acd->lastconflict = 0;
 203a46c:	e0bffe17 	ldw	r2,-8(fp)
 203a470:	10000405 	stb	zero,16(r2)
  ip4_addr_copy(acd->ipaddr, ipaddr);
 203a474:	e0ffff17 	ldw	r3,-4(fp)
 203a478:	e0bffe17 	ldw	r2,-8(fp)
 203a47c:	10c00115 	stw	r3,4(r2)
  acd->state = ACD_STATE_PROBE_WAIT;
 203a480:	e0bffe17 	ldw	r2,-8(fp)
 203a484:	00c00044 	movi	r3,1
 203a488:	10c00215 	stw	r3,8(r2)

  acd->ttw = (u16_t)(ACD_RANDOM_PROBE_WAIT(netif, acd));
 203a48c:	e0bffd17 	ldw	r2,-12(fp)
 203a490:	10800ec3 	ldbu	r2,59(r2)
 203a494:	10803fcc 	andi	r2,r2,255
 203a498:	1006963a 	slli	r3,r2,24
 203a49c:	e0bffd17 	ldw	r2,-12(fp)
 203a4a0:	10800e43 	ldbu	r2,57(r2)
 203a4a4:	10803fcc 	andi	r2,r2,255
 203a4a8:	1004943a 	slli	r2,r2,16
 203a4ac:	1886b03a 	or	r3,r3,r2
 203a4b0:	e0bffd17 	ldw	r2,-12(fp)
 203a4b4:	10800e03 	ldbu	r2,56(r2)
 203a4b8:	10803fcc 	andi	r2,r2,255
 203a4bc:	1004923a 	slli	r2,r2,8
 203a4c0:	1886b03a 	or	r3,r3,r2
 203a4c4:	e0bffd17 	ldw	r2,-12(fp)
 203a4c8:	10800e83 	ldbu	r2,58(r2)
 203a4cc:	10803fcc 	andi	r2,r2,255
 203a4d0:	1886b03a 	or	r3,r3,r2
 203a4d4:	e0bffe17 	ldw	r2,-8(fp)
 203a4d8:	10800303 	ldbu	r2,12(r2)
 203a4dc:	10803fcc 	andi	r2,r2,255
 203a4e0:	1885883a 	add	r2,r3,r2
 203a4e4:	01400284 	movi	r5,10
 203a4e8:	1009883a 	mov	r4,r2
 203a4ec:	200ab400 	call	200ab40 <__umodsi3>
 203a4f0:	1007883a 	mov	r3,r2
 203a4f4:	e0bffe17 	ldw	r2,-8(fp)
 203a4f8:	10c0038d 	sth	r3,14(r2)

  return result;
 203a4fc:	e0bffc03 	ldbu	r2,-16(fp)
}
 203a500:	e037883a 	mov	sp,fp
 203a504:	dfc00117 	ldw	ra,4(sp)
 203a508:	df000017 	ldw	fp,0(sp)
 203a50c:	dec00204 	addi	sp,sp,8
 203a510:	f800283a 	ret

0203a514 <acd_stop>:
 *
 * @param acd   acd module to stop
 */
err_t
acd_stop(struct acd *acd)
{
 203a514:	defffe04 	addi	sp,sp,-8
 203a518:	df000115 	stw	fp,4(sp)
 203a51c:	df000104 	addi	fp,sp,4
 203a520:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("acd_stop\n"));

  if (acd != NULL) {
 203a524:	e0bfff17 	ldw	r2,-4(fp)
 203a528:	10000226 	beq	r2,zero,203a534 <acd_stop+0x20>
    acd->state = ACD_STATE_OFF;
 203a52c:	e0bfff17 	ldw	r2,-4(fp)
 203a530:	10000215 	stw	zero,8(r2)
  }
  return ERR_OK;
 203a534:	0005883a 	mov	r2,zero
}
 203a538:	e037883a 	mov	sp,fp
 203a53c:	df000017 	ldw	fp,0(sp)
 203a540:	dec00104 	addi	sp,sp,4
 203a544:	f800283a 	ret

0203a548 <acd_network_changed_link_down>:
 *
 * @param netif network interface on which to inform the ACD clients
 */
void
acd_network_changed_link_down(struct netif *netif)
{
 203a548:	defffc04 	addi	sp,sp,-16
 203a54c:	dfc00315 	stw	ra,12(sp)
 203a550:	df000215 	stw	fp,8(sp)
 203a554:	df000204 	addi	fp,sp,8
 203a558:	e13fff15 	stw	r4,-4(fp)
  struct acd *acd;
  /* loop over the acd's*/
  ACD_FOREACH(acd, netif->acd_list) {
 203a55c:	e0bfff17 	ldw	r2,-4(fp)
 203a560:	10801117 	ldw	r2,68(r2)
 203a564:	e0bffe15 	stw	r2,-8(fp)
 203a568:	00000506 	br	203a580 <acd_network_changed_link_down+0x38>
    acd_stop(acd);
 203a56c:	e13ffe17 	ldw	r4,-8(fp)
 203a570:	203a5140 	call	203a514 <acd_stop>
void
acd_network_changed_link_down(struct netif *netif)
{
  struct acd *acd;
  /* loop over the acd's*/
  ACD_FOREACH(acd, netif->acd_list) {
 203a574:	e0bffe17 	ldw	r2,-8(fp)
 203a578:	10800017 	ldw	r2,0(r2)
 203a57c:	e0bffe15 	stw	r2,-8(fp)
 203a580:	e0bffe17 	ldw	r2,-8(fp)
 203a584:	103ff91e 	bne	r2,zero,203a56c <__alt_mem_mem_0+0xfd01a56c>
    acd_stop(acd);
  }
}
 203a588:	0001883a 	nop
 203a58c:	e037883a 	mov	sp,fp
 203a590:	dfc00117 	ldw	ra,4(sp)
 203a594:	df000017 	ldw	fp,0(sp)
 203a598:	dec00204 	addi	sp,sp,8
 203a59c:	f800283a 	ret

0203a5a0 <acd_tmr>:
/**
 * Has to be called in loop every ACD_TMR_INTERVAL milliseconds
 */
void
acd_tmr(void)
{
 203a5a0:	defffc04 	addi	sp,sp,-16
 203a5a4:	dfc00315 	stw	ra,12(sp)
 203a5a8:	df000215 	stw	fp,8(sp)
 203a5ac:	df000204 	addi	fp,sp,8
  struct netif *netif;
  struct acd *acd;
  /* loop through netif's */
  NETIF_FOREACH(netif) {
 203a5b0:	d0a7dc17 	ldw	r2,-24720(gp)
 203a5b4:	e0bffe15 	stw	r2,-8(fp)
 203a5b8:	0000b006 	br	203a87c <acd_tmr+0x2dc>
    ACD_FOREACH(acd, netif->acd_list) {
 203a5bc:	e0bffe17 	ldw	r2,-8(fp)
 203a5c0:	10801117 	ldw	r2,68(r2)
 203a5c4:	e0bfff15 	stw	r2,-4(fp)
 203a5c8:	0000a706 	br	203a868 <acd_tmr+0x2c8>
      if (acd->lastconflict > 0) {
 203a5cc:	e0bfff17 	ldw	r2,-4(fp)
 203a5d0:	10800403 	ldbu	r2,16(r2)
 203a5d4:	10803fcc 	andi	r2,r2,255
 203a5d8:	10000626 	beq	r2,zero,203a5f4 <acd_tmr+0x54>
        acd->lastconflict--;
 203a5dc:	e0bfff17 	ldw	r2,-4(fp)
 203a5e0:	10800403 	ldbu	r2,16(r2)
 203a5e4:	10bfffc4 	addi	r2,r2,-1
 203a5e8:	1007883a 	mov	r3,r2
 203a5ec:	e0bfff17 	ldw	r2,-4(fp)
 203a5f0:	10c00405 	stb	r3,16(r2)

      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE,
                  ("acd_tmr() ACD-State: %"U16_F", ttw=%"U16_F"\n",
                   (u16_t)(acd->state), acd->ttw));

      if (acd->ttw > 0) {
 203a5f4:	e0bfff17 	ldw	r2,-4(fp)
 203a5f8:	1080038b 	ldhu	r2,14(r2)
 203a5fc:	10bfffcc 	andi	r2,r2,65535
 203a600:	10000626 	beq	r2,zero,203a61c <acd_tmr+0x7c>
        acd->ttw--;
 203a604:	e0bfff17 	ldw	r2,-4(fp)
 203a608:	1080038b 	ldhu	r2,14(r2)
 203a60c:	10bfffc4 	addi	r2,r2,-1
 203a610:	1007883a 	mov	r3,r2
 203a614:	e0bfff17 	ldw	r2,-4(fp)
 203a618:	10c0038d 	sth	r3,14(r2)
      }

      switch (acd->state) {
 203a61c:	e0bfff17 	ldw	r2,-4(fp)
 203a620:	10800217 	ldw	r2,8(r2)
 203a624:	10c00228 	cmpgeui	r3,r2,8
 203a628:	1800851e 	bne	r3,zero,203a840 <acd_tmr+0x2a0>
 203a62c:	100690ba 	slli	r3,r2,2
 203a630:	00808134 	movhi	r2,516
 203a634:	10a99104 	addi	r2,r2,-22972
 203a638:	1885883a 	add	r2,r3,r2
 203a63c:	10800017 	ldw	r2,0(r2)
 203a640:	1000683a 	jmp	r2
 203a644:	0203a840 	call	203a84 <__alt_mem_sdram_controller_0-0x1dfc57c>
 203a648:	0203a664 	muli	r8,zero,3737
 203a64c:	0203a664 	muli	r8,zero,3737
 203a650:	0203a75c 	xori	r8,zero,3741
 203a654:	0203a75c 	xori	r8,zero,3741
 203a658:	0203a840 	call	203a84 <__alt_mem_sdram_controller_0-0x1dfc57c>
 203a65c:	0203a840 	call	203a84 <__alt_mem_sdram_controller_0-0x1dfc57c>
 203a660:	0203a810 	cmplti	r8,zero,3744
        case ACD_STATE_PROBE_WAIT:
        case ACD_STATE_PROBING:
          if (acd->ttw == 0) {
 203a664:	e0bfff17 	ldw	r2,-4(fp)
 203a668:	1080038b 	ldhu	r2,14(r2)
 203a66c:	10bfffcc 	andi	r2,r2,65535
 203a670:	1000751e 	bne	r2,zero,203a848 <acd_tmr+0x2a8>
            acd->state = ACD_STATE_PROBING;
 203a674:	e0bfff17 	ldw	r2,-4(fp)
 203a678:	00c00084 	movi	r3,2
 203a67c:	10c00215 	stw	r3,8(r2)
            etharp_acd_probe(netif, &acd->ipaddr);
 203a680:	e0bfff17 	ldw	r2,-4(fp)
 203a684:	10800104 	addi	r2,r2,4
 203a688:	100b883a 	mov	r5,r2
 203a68c:	e13ffe17 	ldw	r4,-8(fp)
 203a690:	201a1300 	call	201a130 <etharp_acd_probe>
            LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE,
                        ("acd_tmr() PROBING Sent Probe\n"));
            acd->sent_num++;
 203a694:	e0bfff17 	ldw	r2,-4(fp)
 203a698:	10800303 	ldbu	r2,12(r2)
 203a69c:	10800044 	addi	r2,r2,1
 203a6a0:	1007883a 	mov	r3,r2
 203a6a4:	e0bfff17 	ldw	r2,-4(fp)
 203a6a8:	10c00305 	stb	r3,12(r2)
            if (acd->sent_num >= PROBE_NUM) {
 203a6ac:	e0bfff17 	ldw	r2,-4(fp)
 203a6b0:	10800303 	ldbu	r2,12(r2)
 203a6b4:	10803fcc 	andi	r2,r2,255
 203a6b8:	108000f0 	cmpltui	r2,r2,3
 203a6bc:	1000091e 	bne	r2,zero,203a6e4 <acd_tmr+0x144>
              /* Switch to ANNOUNCE_WAIT: last probe is sent*/
              acd->state = ACD_STATE_ANNOUNCE_WAIT;
 203a6c0:	e0bfff17 	ldw	r2,-4(fp)
 203a6c4:	00c000c4 	movi	r3,3
 203a6c8:	10c00215 	stw	r3,8(r2)

              acd->sent_num = 0;
 203a6cc:	e0bfff17 	ldw	r2,-4(fp)
 203a6d0:	10000305 	stb	zero,12(r2)

              /* calculate time to wait before announcing */
              acd->ttw = (u16_t)(ANNOUNCE_WAIT * ACD_TICKS_PER_SECOND);
 203a6d4:	e0bfff17 	ldw	r2,-4(fp)
 203a6d8:	00c00504 	movi	r3,20
 203a6dc:	10c0038d 	sth	r3,14(r2)
            } else {
              /* calculate time to wait to next probe */
              acd->ttw = (u16_t)(ACD_RANDOM_PROBE_INTERVAL(netif, acd));
            }
          }
          break;
 203a6e0:	00005906 	br	203a848 <acd_tmr+0x2a8>

              /* calculate time to wait before announcing */
              acd->ttw = (u16_t)(ANNOUNCE_WAIT * ACD_TICKS_PER_SECOND);
            } else {
              /* calculate time to wait to next probe */
              acd->ttw = (u16_t)(ACD_RANDOM_PROBE_INTERVAL(netif, acd));
 203a6e4:	e0bffe17 	ldw	r2,-8(fp)
 203a6e8:	10800ec3 	ldbu	r2,59(r2)
 203a6ec:	10803fcc 	andi	r2,r2,255
 203a6f0:	1006963a 	slli	r3,r2,24
 203a6f4:	e0bffe17 	ldw	r2,-8(fp)
 203a6f8:	10800e43 	ldbu	r2,57(r2)
 203a6fc:	10803fcc 	andi	r2,r2,255
 203a700:	1004943a 	slli	r2,r2,16
 203a704:	1886b03a 	or	r3,r3,r2
 203a708:	e0bffe17 	ldw	r2,-8(fp)
 203a70c:	10800e03 	ldbu	r2,56(r2)
 203a710:	10803fcc 	andi	r2,r2,255
 203a714:	1004923a 	slli	r2,r2,8
 203a718:	1886b03a 	or	r3,r3,r2
 203a71c:	e0bffe17 	ldw	r2,-8(fp)
 203a720:	10800e83 	ldbu	r2,58(r2)
 203a724:	10803fcc 	andi	r2,r2,255
 203a728:	1886b03a 	or	r3,r3,r2
 203a72c:	e0bfff17 	ldw	r2,-4(fp)
 203a730:	10800303 	ldbu	r2,12(r2)
 203a734:	10803fcc 	andi	r2,r2,255
 203a738:	1885883a 	add	r2,r3,r2
 203a73c:	01400284 	movi	r5,10
 203a740:	1009883a 	mov	r4,r2
 203a744:	200ab400 	call	200ab40 <__umodsi3>
 203a748:	10800284 	addi	r2,r2,10
 203a74c:	1007883a 	mov	r3,r2
 203a750:	e0bfff17 	ldw	r2,-4(fp)
 203a754:	10c0038d 	sth	r3,14(r2)
            }
          }
          break;
 203a758:	00003b06 	br	203a848 <acd_tmr+0x2a8>

        case ACD_STATE_ANNOUNCE_WAIT:
        case ACD_STATE_ANNOUNCING:
          if (acd->ttw == 0) {
 203a75c:	e0bfff17 	ldw	r2,-4(fp)
 203a760:	1080038b 	ldhu	r2,14(r2)
 203a764:	10bfffcc 	andi	r2,r2,65535
 203a768:	1000391e 	bne	r2,zero,203a850 <acd_tmr+0x2b0>
            if (acd->sent_num == 0) {
 203a76c:	e0bfff17 	ldw	r2,-4(fp)
 203a770:	10800303 	ldbu	r2,12(r2)
 203a774:	10803fcc 	andi	r2,r2,255
 203a778:	1000051e 	bne	r2,zero,203a790 <acd_tmr+0x1f0>
              acd->state = ACD_STATE_ANNOUNCING;
 203a77c:	e0bfff17 	ldw	r2,-4(fp)
 203a780:	00c00104 	movi	r3,4
 203a784:	10c00215 	stw	r3,8(r2)

              /* reset conflict count to ensure fast re-probing after announcing */
              acd->num_conflicts = 0;
 203a788:	e0bfff17 	ldw	r2,-4(fp)
 203a78c:	10000445 	stb	zero,17(r2)
                    ("acd_tmr(): changing state to ANNOUNCING: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                     ip4_addr1_16(&acd->ipaddr), ip4_addr2_16(&acd->ipaddr),
                     ip4_addr3_16(&acd->ipaddr), ip4_addr4_16(&acd->ipaddr)));
            }

            etharp_acd_announce(netif, &acd->ipaddr);
 203a790:	e0bfff17 	ldw	r2,-4(fp)
 203a794:	10800104 	addi	r2,r2,4
 203a798:	100b883a 	mov	r5,r2
 203a79c:	e13ffe17 	ldw	r4,-8(fp)
 203a7a0:	201a1a00 	call	201a1a0 <etharp_acd_announce>
            LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE,
                        ("acd_tmr() ANNOUNCING Sent Announce\n"));
            acd->ttw = ANNOUNCE_INTERVAL * ACD_TICKS_PER_SECOND;
 203a7a4:	e0bfff17 	ldw	r2,-4(fp)
 203a7a8:	00c00504 	movi	r3,20
 203a7ac:	10c0038d 	sth	r3,14(r2)
            acd->sent_num++;
 203a7b0:	e0bfff17 	ldw	r2,-4(fp)
 203a7b4:	10800303 	ldbu	r2,12(r2)
 203a7b8:	10800044 	addi	r2,r2,1
 203a7bc:	1007883a 	mov	r3,r2
 203a7c0:	e0bfff17 	ldw	r2,-4(fp)
 203a7c4:	10c00305 	stb	r3,12(r2)

            if (acd->sent_num >= ANNOUNCE_NUM) {
 203a7c8:	e0bfff17 	ldw	r2,-4(fp)
 203a7cc:	10800303 	ldbu	r2,12(r2)
 203a7d0:	10803fcc 	andi	r2,r2,255
 203a7d4:	108000b0 	cmpltui	r2,r2,2
 203a7d8:	10001d1e 	bne	r2,zero,203a850 <acd_tmr+0x2b0>
              acd->state = ACD_STATE_ONGOING;
 203a7dc:	e0bfff17 	ldw	r2,-4(fp)
 203a7e0:	00c00144 	movi	r3,5
 203a7e4:	10c00215 	stw	r3,8(r2)
              acd->sent_num = 0;
 203a7e8:	e0bfff17 	ldw	r2,-4(fp)
 203a7ec:	10000305 	stb	zero,12(r2)
              acd->ttw = 0;
 203a7f0:	e0bfff17 	ldw	r2,-4(fp)
 203a7f4:	1000038d 	sth	zero,14(r2)
                    ("acd_tmr(): changing state to ONGOING: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                     ip4_addr1_16(&acd->ipaddr), ip4_addr2_16(&acd->ipaddr),
                     ip4_addr3_16(&acd->ipaddr), ip4_addr4_16(&acd->ipaddr)));

              /* finally, let acd user know that the address is good and can be used */
              acd->acd_conflict_callback(netif, ACD_IP_OK);
 203a7f8:	e0bfff17 	ldw	r2,-4(fp)
 203a7fc:	10800517 	ldw	r2,20(r2)
 203a800:	000b883a 	mov	r5,zero
 203a804:	e13ffe17 	ldw	r4,-8(fp)
 203a808:	103ee83a 	callr	r2
            }
          }
          break;
 203a80c:	00001006 	br	203a850 <acd_tmr+0x2b0>

        case ACD_STATE_RATE_LIMIT:
          if (acd->ttw == 0) {
 203a810:	e0bfff17 	ldw	r2,-4(fp)
 203a814:	1080038b 	ldhu	r2,14(r2)
 203a818:	10bfffcc 	andi	r2,r2,65535
 203a81c:	10000e1e 	bne	r2,zero,203a858 <acd_tmr+0x2b8>
            /* acd should be stopped because ipaddr isn't valid any more */
            acd_stop(acd);
 203a820:	e13fff17 	ldw	r4,-4(fp)
 203a824:	203a5140 	call	203a514 <acd_stop>
            /* let the acd user (after rate limit interval) know that their is
             * a conflict detected. So it can restart the address acquiring
             * process.*/
            acd->acd_conflict_callback(netif, ACD_RESTART_CLIENT);
 203a828:	e0bfff17 	ldw	r2,-4(fp)
 203a82c:	10800517 	ldw	r2,20(r2)
 203a830:	01400044 	movi	r5,1
 203a834:	e13ffe17 	ldw	r4,-8(fp)
 203a838:	103ee83a 	callr	r2
          }
          break;
 203a83c:	00000606 	br	203a858 <acd_tmr+0x2b8>

        default:
          /* nothing to do in other states */
          break;
 203a840:	0001883a 	nop
 203a844:	00000506 	br	203a85c <acd_tmr+0x2bc>
            } else {
              /* calculate time to wait to next probe */
              acd->ttw = (u16_t)(ACD_RANDOM_PROBE_INTERVAL(netif, acd));
            }
          }
          break;
 203a848:	0001883a 	nop
 203a84c:	00000306 	br	203a85c <acd_tmr+0x2bc>

              /* finally, let acd user know that the address is good and can be used */
              acd->acd_conflict_callback(netif, ACD_IP_OK);
            }
          }
          break;
 203a850:	0001883a 	nop
 203a854:	00000106 	br	203a85c <acd_tmr+0x2bc>
            /* let the acd user (after rate limit interval) know that their is
             * a conflict detected. So it can restart the address acquiring
             * process.*/
            acd->acd_conflict_callback(netif, ACD_RESTART_CLIENT);
          }
          break;
 203a858:	0001883a 	nop
{
  struct netif *netif;
  struct acd *acd;
  /* loop through netif's */
  NETIF_FOREACH(netif) {
    ACD_FOREACH(acd, netif->acd_list) {
 203a85c:	e0bfff17 	ldw	r2,-4(fp)
 203a860:	10800017 	ldw	r2,0(r2)
 203a864:	e0bfff15 	stw	r2,-4(fp)
 203a868:	e0bfff17 	ldw	r2,-4(fp)
 203a86c:	103f571e 	bne	r2,zero,203a5cc <__alt_mem_mem_0+0xfd01a5cc>
acd_tmr(void)
{
  struct netif *netif;
  struct acd *acd;
  /* loop through netif's */
  NETIF_FOREACH(netif) {
 203a870:	e0bffe17 	ldw	r2,-8(fp)
 203a874:	10800017 	ldw	r2,0(r2)
 203a878:	e0bffe15 	stw	r2,-8(fp)
 203a87c:	e0bffe17 	ldw	r2,-8(fp)
 203a880:	103f4e1e 	bne	r2,zero,203a5bc <__alt_mem_mem_0+0xfd01a5bc>
          /* nothing to do in other states */
          break;
      }
    }
  }
}
 203a884:	0001883a 	nop
 203a888:	e037883a 	mov	sp,fp
 203a88c:	dfc00117 	ldw	ra,4(sp)
 203a890:	df000017 	ldw	fp,0(sp)
 203a894:	dec00204 	addi	sp,sp,8
 203a898:	f800283a 	ret

0203a89c <acd_restart>:
 *
 * The number of conflicts is increased and the upper layer is informed.
 */
static void
acd_restart(struct netif *netif, struct acd *acd)
{
 203a89c:	defffc04 	addi	sp,sp,-16
 203a8a0:	dfc00315 	stw	ra,12(sp)
 203a8a4:	df000215 	stw	fp,8(sp)
 203a8a8:	df000204 	addi	fp,sp,8
 203a8ac:	e13ffe15 	stw	r4,-8(fp)
 203a8b0:	e17fff15 	stw	r5,-4(fp)
  /* increase conflict counter. */
  acd->num_conflicts++;
 203a8b4:	e0bfff17 	ldw	r2,-4(fp)
 203a8b8:	10800443 	ldbu	r2,17(r2)
 203a8bc:	10800044 	addi	r2,r2,1
 203a8c0:	1007883a 	mov	r3,r2
 203a8c4:	e0bfff17 	ldw	r2,-4(fp)
 203a8c8:	10c00445 	stb	r3,17(r2)

  /* Decline the address */
  acd->acd_conflict_callback(netif, ACD_DECLINE);
 203a8cc:	e0bfff17 	ldw	r2,-4(fp)
 203a8d0:	10800517 	ldw	r2,20(r2)
 203a8d4:	01400084 	movi	r5,2
 203a8d8:	e13ffe17 	ldw	r4,-8(fp)
 203a8dc:	103ee83a 	callr	r2

  /* if we tried more then MAX_CONFLICTS we must limit our rate for
   * acquiring and probing addresses. compliant to RFC 5227 Section 2.1.1 */
  if (acd->num_conflicts >= MAX_CONFLICTS) {
 203a8e0:	e0bfff17 	ldw	r2,-4(fp)
 203a8e4:	10800443 	ldbu	r2,17(r2)
 203a8e8:	10803fcc 	andi	r2,r2,255
 203a8ec:	108002b0 	cmpltui	r2,r2,10
 203a8f0:	1000071e 	bne	r2,zero,203a910 <acd_restart+0x74>
    acd->state = ACD_STATE_RATE_LIMIT;
 203a8f4:	e0bfff17 	ldw	r2,-4(fp)
 203a8f8:	00c001c4 	movi	r3,7
 203a8fc:	10c00215 	stw	r3,8(r2)
    acd->ttw = (u16_t)(RATE_LIMIT_INTERVAL * ACD_TICKS_PER_SECOND);
 203a900:	e0bfff17 	ldw	r2,-4(fp)
 203a904:	00c09604 	movi	r3,600
 203a908:	10c0038d 	sth	r3,14(r2)
    acd_stop(acd);
    /* let the acd user know right away that their is a conflict detected.
     * So it can restart the address acquiring process. */
    acd->acd_conflict_callback(netif, ACD_RESTART_CLIENT);
  }
}
 203a90c:	00000706 	br	203a92c <acd_restart+0x90>
    LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
                ("acd_restart(): rate limiting initiated. too many conflicts\n"));
  }
  else {
    /* acd should be stopped because ipaddr isn't valid any more */
    acd_stop(acd);
 203a910:	e13fff17 	ldw	r4,-4(fp)
 203a914:	203a5140 	call	203a514 <acd_stop>
    /* let the acd user know right away that their is a conflict detected.
     * So it can restart the address acquiring process. */
    acd->acd_conflict_callback(netif, ACD_RESTART_CLIENT);
 203a918:	e0bfff17 	ldw	r2,-4(fp)
 203a91c:	10800517 	ldw	r2,20(r2)
 203a920:	01400044 	movi	r5,1
 203a924:	e13ffe17 	ldw	r4,-8(fp)
 203a928:	103ee83a 	callr	r2
  }
}
 203a92c:	0001883a 	nop
 203a930:	e037883a 	mov	sp,fp
 203a934:	dfc00117 	ldw	ra,4(sp)
 203a938:	df000017 	ldw	fp,0(sp)
 203a93c:	dec00204 	addi	sp,sp,8
 203a940:	f800283a 	ret

0203a944 <acd_arp_reply>:
 * @param netif network interface to use for acd processing
 * @param hdr   Incoming ARP packet
 */
void
acd_arp_reply(struct netif *netif, struct etharp_hdr *hdr)
{
 203a944:	defff704 	addi	sp,sp,-36
 203a948:	dfc00815 	stw	ra,32(sp)
 203a94c:	df000715 	stw	fp,28(sp)
 203a950:	df000704 	addi	fp,sp,28
 203a954:	e13ffe15 	stw	r4,-8(fp)
 203a958:	e17fff15 	stw	r5,-4(fp)
  struct acd *acd;
  ip4_addr_t sipaddr, dipaddr;
  struct eth_addr netifaddr;
  SMEMCPY(netifaddr.addr, netif->hwaddr, ETH_HWADDR_LEN);
 203a95c:	e0bffe17 	ldw	r2,-8(fp)
 203a960:	10800d84 	addi	r2,r2,54
 203a964:	10c00003 	ldbu	r3,0(r2)
 203a968:	e0fffc05 	stb	r3,-16(fp)
 203a96c:	10c00043 	ldbu	r3,1(r2)
 203a970:	e0fffc45 	stb	r3,-15(fp)
 203a974:	10c00083 	ldbu	r3,2(r2)
 203a978:	e0fffc85 	stb	r3,-14(fp)
 203a97c:	10c000c3 	ldbu	r3,3(r2)
 203a980:	e0fffcc5 	stb	r3,-13(fp)
 203a984:	10c00103 	ldbu	r3,4(r2)
 203a988:	e0fffd05 	stb	r3,-12(fp)
 203a98c:	10800143 	ldbu	r2,5(r2)
 203a990:	e0bffd45 	stb	r2,-11(fp)

  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support
   * compilers without structure packing (not using structure copy which
   * breaks strict-aliasing rules).
   */
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
 203a994:	e0bfff17 	ldw	r2,-4(fp)
 203a998:	10c00384 	addi	r3,r2,14
 203a99c:	e0bffa04 	addi	r2,fp,-24
 203a9a0:	01800104 	movi	r6,4
 203a9a4:	180b883a 	mov	r5,r3
 203a9a8:	1009883a 	mov	r4,r2
 203a9ac:	2005e580 	call	2005e58 <memcpy>
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
 203a9b0:	e0bfff17 	ldw	r2,-4(fp)
 203a9b4:	10c00604 	addi	r3,r2,24
 203a9b8:	e0bffb04 	addi	r2,fp,-20
 203a9bc:	01800104 	movi	r6,4
 203a9c0:	180b883a 	mov	r5,r3
 203a9c4:	1009883a 	mov	r4,r2
 203a9c8:	2005e580 	call	2005e58 <memcpy>

  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE, ("acd_arp_reply()\n"));

  /* loop over the acd's*/
  ACD_FOREACH(acd, netif->acd_list) {
 203a9cc:	e0bffe17 	ldw	r2,-8(fp)
 203a9d0:	10801117 	ldw	r2,68(r2)
 203a9d4:	e0bff915 	stw	r2,-28(fp)
 203a9d8:	00003606 	br	203aab4 <acd_arp_reply+0x170>
    switch(acd->state) {
 203a9dc:	e0bff917 	ldw	r2,-28(fp)
 203a9e0:	10800217 	ldw	r2,8(r2)
 203a9e4:	00802b2e 	bgeu	zero,r2,203aa94 <acd_arp_reply+0x150>
 203a9e8:	10c00130 	cmpltui	r3,r2,4
 203a9ec:	1800031e 	bne	r3,zero,203a9fc <acd_arp_reply+0xb8>
 203a9f0:	108001e8 	cmpgeui	r2,r2,7
 203a9f4:	1000271e 	bne	r2,zero,203aa94 <acd_arp_reply+0x150>
 203a9f8:	00001606 	br	203aa54 <acd_arp_reply+0x110>
         * from beginning to after ANNOUNCE_WAIT seconds we have a conflict if
         * ip.src == ipaddr (someone is already using the address)
         * OR
         * ip.dst == ipaddr && hw.src != own hwaddr (someone else is probing it)
         */
        if ((ip4_addr_cmp(&sipaddr, &acd->ipaddr)) ||
 203a9fc:	e0fffa17 	ldw	r3,-24(fp)
 203aa00:	e0bff917 	ldw	r2,-28(fp)
 203aa04:	10800117 	ldw	r2,4(r2)
 203aa08:	18800e26 	beq	r3,r2,203aa44 <acd_arp_reply+0x100>
            (ip4_addr_isany_val(sipaddr) &&
 203aa0c:	e0bffa17 	ldw	r2,-24(fp)
         * from beginning to after ANNOUNCE_WAIT seconds we have a conflict if
         * ip.src == ipaddr (someone is already using the address)
         * OR
         * ip.dst == ipaddr && hw.src != own hwaddr (someone else is probing it)
         */
        if ((ip4_addr_cmp(&sipaddr, &acd->ipaddr)) ||
 203aa10:	1000221e 	bne	r2,zero,203aa9c <acd_arp_reply+0x158>
            (ip4_addr_isany_val(sipaddr) &&
             ip4_addr_cmp(&dipaddr, &acd->ipaddr) &&
 203aa14:	e0fffb17 	ldw	r3,-20(fp)
 203aa18:	e0bff917 	ldw	r2,-28(fp)
 203aa1c:	10800117 	ldw	r2,4(r2)
         * ip.src == ipaddr (someone is already using the address)
         * OR
         * ip.dst == ipaddr && hw.src != own hwaddr (someone else is probing it)
         */
        if ((ip4_addr_cmp(&sipaddr, &acd->ipaddr)) ||
            (ip4_addr_isany_val(sipaddr) &&
 203aa20:	18801e1e 	bne	r3,r2,203aa9c <acd_arp_reply+0x158>
             ip4_addr_cmp(&dipaddr, &acd->ipaddr) &&
             !eth_addr_cmp(&netifaddr, &hdr->shwaddr))) {
 203aa24:	e0bfff17 	ldw	r2,-4(fp)
 203aa28:	10c00204 	addi	r3,r2,8
 203aa2c:	e0bffc04 	addi	r2,fp,-16
 203aa30:	01800184 	movi	r6,6
 203aa34:	180b883a 	mov	r5,r3
 203aa38:	1009883a 	mov	r4,r2
 203aa3c:	20424280 	call	2042428 <memcmp>
         * OR
         * ip.dst == ipaddr && hw.src != own hwaddr (someone else is probing it)
         */
        if ((ip4_addr_cmp(&sipaddr, &acd->ipaddr)) ||
            (ip4_addr_isany_val(sipaddr) &&
             ip4_addr_cmp(&dipaddr, &acd->ipaddr) &&
 203aa40:	10001626 	beq	r2,zero,203aa9c <acd_arp_reply+0x158>
             !eth_addr_cmp(&netifaddr, &hdr->shwaddr))) {
          LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
                      ("acd_arp_reply(): Probe Conflict detected\n"));
          acd_restart(netif, acd);
 203aa44:	e17ff917 	ldw	r5,-28(fp)
 203aa48:	e13ffe17 	ldw	r4,-8(fp)
 203aa4c:	203a89c0 	call	203a89c <acd_restart>
        }
        break;
 203aa50:	00001206 	br	203aa9c <acd_arp_reply+0x158>
      case ACD_STATE_PASSIVE_ONGOING:
        /* RFC 5227 Section 2.4:
         * in any state we have a conflict if
         * ip.src == ipaddr && hw.src != own hwaddr (someone is using our address)
         */
        if (ip4_addr_cmp(&sipaddr, &acd->ipaddr) &&
 203aa54:	e0fffa17 	ldw	r3,-24(fp)
 203aa58:	e0bff917 	ldw	r2,-28(fp)
 203aa5c:	10800117 	ldw	r2,4(r2)
 203aa60:	1880101e 	bne	r3,r2,203aaa4 <acd_arp_reply+0x160>
            !eth_addr_cmp(&netifaddr, &hdr->shwaddr)) {
 203aa64:	e0bfff17 	ldw	r2,-4(fp)
 203aa68:	10c00204 	addi	r3,r2,8
 203aa6c:	e0bffc04 	addi	r2,fp,-16
 203aa70:	01800184 	movi	r6,6
 203aa74:	180b883a 	mov	r5,r3
 203aa78:	1009883a 	mov	r4,r2
 203aa7c:	20424280 	call	2042428 <memcmp>
      case ACD_STATE_PASSIVE_ONGOING:
        /* RFC 5227 Section 2.4:
         * in any state we have a conflict if
         * ip.src == ipaddr && hw.src != own hwaddr (someone is using our address)
         */
        if (ip4_addr_cmp(&sipaddr, &acd->ipaddr) &&
 203aa80:	10000826 	beq	r2,zero,203aaa4 <acd_arp_reply+0x160>
            !eth_addr_cmp(&netifaddr, &hdr->shwaddr)) {
          LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
                      ("acd_arp_reply(): Conflicting ARP-Packet detected\n"));
          acd_handle_arp_conflict(netif, acd);
 203aa84:	e17ff917 	ldw	r5,-28(fp)
 203aa88:	e13ffe17 	ldw	r4,-8(fp)
 203aa8c:	203aad40 	call	203aad4 <acd_handle_arp_conflict>
        }
        break;
 203aa90:	00000406 	br	203aaa4 <acd_arp_reply+0x160>
    switch(acd->state) {
      case ACD_STATE_OFF:
      case ACD_STATE_RATE_LIMIT:
      default:
        /* do nothing */
        break;
 203aa94:	0001883a 	nop
 203aa98:	00000306 	br	203aaa8 <acd_arp_reply+0x164>
             !eth_addr_cmp(&netifaddr, &hdr->shwaddr))) {
          LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
                      ("acd_arp_reply(): Probe Conflict detected\n"));
          acd_restart(netif, acd);
        }
        break;
 203aa9c:	0001883a 	nop
 203aaa0:	00000106 	br	203aaa8 <acd_arp_reply+0x164>
            !eth_addr_cmp(&netifaddr, &hdr->shwaddr)) {
          LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
                      ("acd_arp_reply(): Conflicting ARP-Packet detected\n"));
          acd_handle_arp_conflict(netif, acd);
        }
        break;
 203aaa4:	0001883a 	nop
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);

  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE, ("acd_arp_reply()\n"));

  /* loop over the acd's*/
  ACD_FOREACH(acd, netif->acd_list) {
 203aaa8:	e0bff917 	ldw	r2,-28(fp)
 203aaac:	10800017 	ldw	r2,0(r2)
 203aab0:	e0bff915 	stw	r2,-28(fp)
 203aab4:	e0bff917 	ldw	r2,-28(fp)
 203aab8:	103fc81e 	bne	r2,zero,203a9dc <__alt_mem_mem_0+0xfd01a9dc>
          acd_handle_arp_conflict(netif, acd);
        }
        break;
    }
  }
}
 203aabc:	0001883a 	nop
 203aac0:	e037883a 	mov	sp,fp
 203aac4:	dfc00117 	ldw	ra,4(sp)
 203aac8:	df000017 	ldw	fp,0(sp)
 203aacc:	dec00204 	addi	sp,sp,8
 203aad0:	f800283a 	ret

0203aad4 <acd_handle_arp_conflict>:
/**
 * Handle a IP address conflict after an ARP conflict detection
 */
static void
acd_handle_arp_conflict(struct netif *netif, struct acd *acd)
{
 203aad4:	defffc04 	addi	sp,sp,-16
 203aad8:	dfc00315 	stw	ra,12(sp)
 203aadc:	df000215 	stw	fp,8(sp)
 203aae0:	df000204 	addi	fp,sp,8
 203aae4:	e13ffe15 	stw	r4,-8(fp)
 203aae8:	e17fff15 	stw	r5,-4(fp)
     We use option a) when the acd module does not represent the netif address,
     since we cannot have the acd module announcing or restarting. This
     situation occurs for the LL acd module when a routable address is used on
     the netif but the LL address is still open in the background. */

  if (acd->state == ACD_STATE_PASSIVE_ONGOING) {
 203aaec:	e0bfff17 	ldw	r2,-4(fp)
 203aaf0:	10800217 	ldw	r2,8(r2)
 203aaf4:	10800198 	cmpnei	r2,r2,6
 203aaf8:	1000081e 	bne	r2,zero,203ab1c <acd_handle_arp_conflict+0x48>
    /* Immediately back off on a conflict. */
    LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
      ("acd_handle_arp_conflict(): conflict when we are in passive mode -> back off\n"));
    acd_stop(acd);
 203aafc:	e13fff17 	ldw	r4,-4(fp)
 203ab00:	203a5140 	call	203a514 <acd_stop>
    acd->acd_conflict_callback(netif, ACD_DECLINE);
 203ab04:	e0bfff17 	ldw	r2,-4(fp)
 203ab08:	10800517 	ldw	r2,20(r2)
 203ab0c:	01400084 	movi	r5,2
 203ab10:	e13ffe17 	ldw	r4,-8(fp)
 203ab14:	103ee83a 	callr	r2
          ("acd_handle_arp_conflict(): we are defending, send ARP Announce\n"));
      etharp_acd_announce(netif, &acd->ipaddr);
      acd->lastconflict = DEFEND_INTERVAL * ACD_TICKS_PER_SECOND;
    }
  }
}
 203ab18:	00001006 	br	203ab5c <acd_handle_arp_conflict+0x88>
      ("acd_handle_arp_conflict(): conflict when we are in passive mode -> back off\n"));
    acd_stop(acd);
    acd->acd_conflict_callback(netif, ACD_DECLINE);
  }
  else {
    if (acd->lastconflict > 0) {
 203ab1c:	e0bfff17 	ldw	r2,-4(fp)
 203ab20:	10800403 	ldbu	r2,16(r2)
 203ab24:	10803fcc 	andi	r2,r2,255
 203ab28:	10000426 	beq	r2,zero,203ab3c <acd_handle_arp_conflict+0x68>
      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
        ("acd_handle_arp_conflict(): conflict within DEFEND_INTERVAL -> retreating\n"));

      /* Active TCP sessions are aborted when removing the ip address but a bad
       * connection was inevitable anyway with conflicting hosts */
       acd_restart(netif, acd);
 203ab2c:	e17fff17 	ldw	r5,-4(fp)
 203ab30:	e13ffe17 	ldw	r4,-8(fp)
 203ab34:	203a89c0 	call	203a89c <acd_restart>
          ("acd_handle_arp_conflict(): we are defending, send ARP Announce\n"));
      etharp_acd_announce(netif, &acd->ipaddr);
      acd->lastconflict = DEFEND_INTERVAL * ACD_TICKS_PER_SECOND;
    }
  }
}
 203ab38:	00000806 	br	203ab5c <acd_handle_arp_conflict+0x88>
       * connection was inevitable anyway with conflicting hosts */
       acd_restart(netif, acd);
    } else {
      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
          ("acd_handle_arp_conflict(): we are defending, send ARP Announce\n"));
      etharp_acd_announce(netif, &acd->ipaddr);
 203ab3c:	e0bfff17 	ldw	r2,-4(fp)
 203ab40:	10800104 	addi	r2,r2,4
 203ab44:	100b883a 	mov	r5,r2
 203ab48:	e13ffe17 	ldw	r4,-8(fp)
 203ab4c:	201a1a00 	call	201a1a0 <etharp_acd_announce>
      acd->lastconflict = DEFEND_INTERVAL * ACD_TICKS_PER_SECOND;
 203ab50:	e0bfff17 	ldw	r2,-4(fp)
 203ab54:	00c01904 	movi	r3,100
 203ab58:	10c00405 	stb	r3,16(r2)
    }
  }
}
 203ab5c:	0001883a 	nop
 203ab60:	e037883a 	mov	sp,fp
 203ab64:	dfc00117 	ldw	ra,4(sp)
 203ab68:	df000017 	ldw	fp,0(sp)
 203ab6c:	dec00204 	addi	sp,sp,8
 203ab70:	f800283a 	ret

0203ab74 <acd_put_in_passive_mode>:
/**
 * Put the acd module in passive ongoing conflict detection.
 */
static void
acd_put_in_passive_mode(struct netif *netif, struct acd *acd)
{
 203ab74:	defffc04 	addi	sp,sp,-16
 203ab78:	dfc00315 	stw	ra,12(sp)
 203ab7c:	df000215 	stw	fp,8(sp)
 203ab80:	df000204 	addi	fp,sp,8
 203ab84:	e13ffe15 	stw	r4,-8(fp)
 203ab88:	e17fff15 	stw	r5,-4(fp)
  switch(acd->state) {
 203ab8c:	e0bfff17 	ldw	r2,-4(fp)
 203ab90:	10800217 	ldw	r2,8(r2)
 203ab94:	10c00228 	cmpgeui	r3,r2,8
 203ab98:	18001a1e 	bne	r3,zero,203ac04 <acd_put_in_passive_mode+0x90>
 203ab9c:	100690ba 	slli	r3,r2,2
 203aba0:	00808134 	movhi	r2,516
 203aba4:	10aaed04 	addi	r2,r2,-21580
 203aba8:	1885883a 	add	r2,r3,r2
 203abac:	10800017 	ldw	r2,0(r2)
 203abb0:	1000683a 	jmp	r2
 203abb4:	0203ac04 	movi	r8,3760
 203abb8:	0203abd4 	movui	r8,3759
 203abbc:	0203abd4 	movui	r8,3759
 203abc0:	0203abd4 	movui	r8,3759
 203abc4:	0203abf4 	movhi	r8,3759
 203abc8:	0203abf4 	movhi	r8,3759
 203abcc:	0203ac04 	movi	r8,3760
 203abd0:	0203abd4 	movui	r8,3759

    case ACD_STATE_PROBE_WAIT:
    case ACD_STATE_PROBING:
    case ACD_STATE_ANNOUNCE_WAIT:
    case ACD_STATE_RATE_LIMIT:
      acd_stop(acd);
 203abd4:	e13fff17 	ldw	r4,-4(fp)
 203abd8:	203a5140 	call	203a514 <acd_stop>
      acd->acd_conflict_callback(netif, ACD_DECLINE);
 203abdc:	e0bfff17 	ldw	r2,-4(fp)
 203abe0:	10800517 	ldw	r2,20(r2)
 203abe4:	01400084 	movi	r5,2
 203abe8:	e13ffe17 	ldw	r4,-8(fp)
 203abec:	103ee83a 	callr	r2
      break;
 203abf0:	00000506 	br	203ac08 <acd_put_in_passive_mode+0x94>

    case ACD_STATE_ANNOUNCING:
    case ACD_STATE_ONGOING:
      acd->state = ACD_STATE_PASSIVE_ONGOING;
 203abf4:	e0bfff17 	ldw	r2,-4(fp)
 203abf8:	00c00184 	movi	r3,6
 203abfc:	10c00215 	stw	r3,8(r2)
      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
        ("acd_put_in_passive_mode()\n"));
      break;
 203ac00:	00000106 	br	203ac08 <acd_put_in_passive_mode+0x94>
  switch(acd->state) {
    case ACD_STATE_OFF:
    case ACD_STATE_PASSIVE_ONGOING:
    default:
      /* do nothing */
      break;
 203ac04:	0001883a 	nop
      acd->state = ACD_STATE_PASSIVE_ONGOING;
      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
        ("acd_put_in_passive_mode()\n"));
      break;
  }
}
 203ac08:	0001883a 	nop
 203ac0c:	e037883a 	mov	sp,fp
 203ac10:	dfc00117 	ldw	ra,4(sp)
 203ac14:	df000017 	ldw	fp,0(sp)
 203ac18:	dec00204 	addi	sp,sp,8
 203ac1c:	f800283a 	ret

0203ac20 <acd_netif_ip_addr_changed>:
 * @param new_addr  new ip address
 */
void
acd_netif_ip_addr_changed(struct netif *netif, const ip_addr_t *old_addr,
                          const ip_addr_t *new_addr)
{
 203ac20:	defffa04 	addi	sp,sp,-24
 203ac24:	dfc00515 	stw	ra,20(sp)
 203ac28:	df000415 	stw	fp,16(sp)
 203ac2c:	df000404 	addi	fp,sp,16
 203ac30:	e13ffd15 	stw	r4,-12(fp)
 203ac34:	e17ffe15 	stw	r5,-8(fp)
 203ac38:	e1bfff15 	stw	r6,-4(fp)
    ("acd_netif_ip_addr_changed(): old address = %s\n", ipaddr_ntoa(old_addr)));
  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    ("acd_netif_ip_addr_changed(): new address = %s\n", ipaddr_ntoa(new_addr)));

  /* If we change from ANY to an IP or from an IP to ANY we do nothing */
  if (ip_addr_isany(old_addr) || ip_addr_isany(new_addr)) {
 203ac3c:	e0bffe17 	ldw	r2,-8(fp)
 203ac40:	10002426 	beq	r2,zero,203acd4 <acd_netif_ip_addr_changed+0xb4>
 203ac44:	e0bffe17 	ldw	r2,-8(fp)
 203ac48:	10800017 	ldw	r2,0(r2)
 203ac4c:	10002126 	beq	r2,zero,203acd4 <acd_netif_ip_addr_changed+0xb4>
 203ac50:	e0bfff17 	ldw	r2,-4(fp)
 203ac54:	10001f26 	beq	r2,zero,203acd4 <acd_netif_ip_addr_changed+0xb4>
 203ac58:	e0bfff17 	ldw	r2,-4(fp)
 203ac5c:	10800017 	ldw	r2,0(r2)
 203ac60:	10001c26 	beq	r2,zero,203acd4 <acd_netif_ip_addr_changed+0xb4>
    return;
  }

  ACD_FOREACH(acd, netif->acd_list) {
 203ac64:	e0bffd17 	ldw	r2,-12(fp)
 203ac68:	10801117 	ldw	r2,68(r2)
 203ac6c:	e0bffc15 	stw	r2,-16(fp)
 203ac70:	00001506 	br	203acc8 <acd_netif_ip_addr_changed+0xa8>
    /* Find ACD module of old address */
    if(ip4_addr_cmp(&acd->ipaddr, ip_2_ip4(old_addr))) {
 203ac74:	e0bffc17 	ldw	r2,-16(fp)
 203ac78:	10c00117 	ldw	r3,4(r2)
 203ac7c:	e0bffe17 	ldw	r2,-8(fp)
 203ac80:	10800017 	ldw	r2,0(r2)
 203ac84:	18800d1e 	bne	r3,r2,203acbc <acd_netif_ip_addr_changed+0x9c>
      /* Did we change from a LL address to a routable address? */
      if (ip_addr_islinklocal(old_addr) && !ip_addr_islinklocal(new_addr)) {
 203ac88:	e0bffe17 	ldw	r2,-8(fp)
 203ac8c:	10800017 	ldw	r2,0(r2)
 203ac90:	10ffffcc 	andi	r3,r2,65535
 203ac94:	00bfaa54 	movui	r2,65193
 203ac98:	1880081e 	bne	r3,r2,203acbc <acd_netif_ip_addr_changed+0x9c>
 203ac9c:	e0bfff17 	ldw	r2,-4(fp)
 203aca0:	10800017 	ldw	r2,0(r2)
 203aca4:	10ffffcc 	andi	r3,r2,65535
 203aca8:	00bfaa54 	movui	r2,65193
 203acac:	18800326 	beq	r3,r2,203acbc <acd_netif_ip_addr_changed+0x9c>
        LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
          ("acd_netif_ip_addr_changed(): changed from LL to routable address\n"));
        /* Put the module in passive conflict detection mode */
        acd_put_in_passive_mode(netif, acd);
 203acb0:	e17ffc17 	ldw	r5,-16(fp)
 203acb4:	e13ffd17 	ldw	r4,-12(fp)
 203acb8:	203ab740 	call	203ab74 <acd_put_in_passive_mode>
  /* If we change from ANY to an IP or from an IP to ANY we do nothing */
  if (ip_addr_isany(old_addr) || ip_addr_isany(new_addr)) {
    return;
  }

  ACD_FOREACH(acd, netif->acd_list) {
 203acbc:	e0bffc17 	ldw	r2,-16(fp)
 203acc0:	10800017 	ldw	r2,0(r2)
 203acc4:	e0bffc15 	stw	r2,-16(fp)
 203acc8:	e0bffc17 	ldw	r2,-16(fp)
 203accc:	103fe91e 	bne	r2,zero,203ac74 <__alt_mem_mem_0+0xfd01ac74>
 203acd0:	00000106 	br	203acd8 <acd_netif_ip_addr_changed+0xb8>
  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    ("acd_netif_ip_addr_changed(): new address = %s\n", ipaddr_ntoa(new_addr)));

  /* If we change from ANY to an IP or from an IP to ANY we do nothing */
  if (ip_addr_isany(old_addr) || ip_addr_isany(new_addr)) {
    return;
 203acd4:	0001883a 	nop
        /* Put the module in passive conflict detection mode */
        acd_put_in_passive_mode(netif, acd);
      }
    }
  }
}
 203acd8:	e037883a 	mov	sp,fp
 203acdc:	dfc00117 	ldw	ra,4(sp)
 203ace0:	df000017 	ldw	fp,0(sp)
 203ace4:	dec00204 	addi	sp,sp,8
 203ace8:	f800283a 	ret

0203acec <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the icmp header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 203acec:	defff104 	addi	sp,sp,-60
 203acf0:	dfc00e15 	stw	ra,56(sp)
 203acf4:	df000d15 	stw	fp,52(sp)
 203acf8:	df000d04 	addi	fp,sp,52
 203acfc:	e13ffe15 	stw	r4,-8(fp)
 203ad00:	e17fff15 	stw	r5,-4(fp)
  struct icmp_echo_hdr *iecho;
  const struct ip_hdr *iphdr_in;
  u16_t hlen;
  const ip4_addr_t *src;

  ICMP_STATS_INC(icmp.recv);
 203ad04:	008085f4 	movhi	r2,535
 203ad08:	10bd8204 	addi	r2,r2,-2552
 203ad0c:	10803117 	ldw	r2,196(r2)
 203ad10:	10c00044 	addi	r3,r2,1
 203ad14:	008085f4 	movhi	r2,535
 203ad18:	10bd8204 	addi	r2,r2,-2552
 203ad1c:	10c03115 	stw	r3,196(r2)
  MIB2_STATS_INC(mib2.icmpinmsgs);

  iphdr_in = ip4_current_header();
 203ad20:	008085f4 	movhi	r2,535
 203ad24:	10be4204 	addi	r2,r2,-1784
 203ad28:	10800217 	ldw	r2,8(r2)
 203ad2c:	e0bff615 	stw	r2,-40(fp)
  hlen = IPH_HL_BYTES(iphdr_in);
 203ad30:	e0bff617 	ldw	r2,-40(fp)
 203ad34:	10800003 	ldbu	r2,0(r2)
 203ad38:	108003cc 	andi	r2,r2,15
 203ad3c:	1085883a 	add	r2,r2,r2
 203ad40:	1085883a 	add	r2,r2,r2
 203ad44:	10803fcc 	andi	r2,r2,255
 203ad48:	e0bff70d 	sth	r2,-36(fp)
  if (hlen < IP_HLEN) {
 203ad4c:	e0bff70b 	ldhu	r2,-36(fp)
 203ad50:	10800528 	cmpgeui	r2,r2,20
 203ad54:	10015126 	beq	r2,zero,203b29c <icmp_input+0x5b0>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
  }
  if (p->len < sizeof(u16_t) * 2) {
 203ad58:	e0bffe17 	ldw	r2,-8(fp)
 203ad5c:	1080028b 	ldhu	r2,10(r2)
 203ad60:	10bfffcc 	andi	r2,r2,65535
 203ad64:	10800128 	cmpgeui	r2,r2,4
 203ad68:	10014e26 	beq	r2,zero,203b2a4 <icmp_input+0x5b8>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 203ad6c:	e0bffe17 	ldw	r2,-8(fp)
 203ad70:	10800117 	ldw	r2,4(r2)
 203ad74:	10800003 	ldbu	r2,0(r2)
 203ad78:	e0bff785 	stb	r2,-34(fp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload) + 1);
  /* if debug is enabled but debug statement below is somehow disabled: */
  LWIP_UNUSED_ARG(code);
#endif /* LWIP_DEBUG */
  switch (type) {
 203ad7c:	e0bff783 	ldbu	r2,-34(fp)
 203ad80:	10014026 	beq	r2,zero,203b284 <icmp_input+0x598>
 203ad84:	10800220 	cmpeqi	r2,r2,8
 203ad88:	10012f26 	beq	r2,zero,203b248 <icmp_input+0x55c>
         (as obviously, an echo request has been sent, too). */
      MIB2_STATS_INC(mib2.icmpinechoreps);
      break;
    case ICMP_ECHO:
      MIB2_STATS_INC(mib2.icmpinechos);
      src = ip4_current_dest_addr();
 203ad8c:	008085f4 	movhi	r2,535
 203ad90:	10be4704 	addi	r2,r2,-1764
 203ad94:	e0bff815 	stw	r2,-32(fp)
      /* multicast destination address? */
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 203ad98:	008085f4 	movhi	r2,535
 203ad9c:	10be4204 	addi	r2,r2,-1784
 203ada0:	10800517 	ldw	r2,20(r2)
 203ada4:	10803c0c 	andi	r2,r2,240
 203ada8:	10803818 	cmpnei	r2,r2,224
 203adac:	10014a26 	beq	r2,zero,203b2d8 <icmp_input+0x5ec>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
        goto icmperr;
#endif /* LWIP_MULTICAST_PING */
      }
      /* broadcast destination address? */
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 203adb0:	008085f4 	movhi	r2,535
 203adb4:	10be4204 	addi	r2,r2,-1784
 203adb8:	10c00517 	ldw	r3,20(r2)
 203adbc:	008085f4 	movhi	r2,535
 203adc0:	10be4204 	addi	r2,r2,-1784
 203adc4:	10800017 	ldw	r2,0(r2)
 203adc8:	100b883a 	mov	r5,r2
 203adcc:	1809883a 	mov	r4,r3
 203add0:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
 203add4:	10803fcc 	andi	r2,r2,255
 203add8:	1001411e 	bne	r2,zero,203b2e0 <icmp_input+0x5f4>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
        goto icmperr;
#endif /* LWIP_BROADCAST_PING */
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 203addc:	e0bffe17 	ldw	r2,-8(fp)
 203ade0:	1080020b 	ldhu	r2,8(r2)
 203ade4:	10bfffcc 	andi	r2,r2,65535
 203ade8:	10800228 	cmpgeui	r2,r2,8
 203adec:	10012f26 	beq	r2,zero,203b2ac <icmp_input+0x5c0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
        goto lenerr;
      }
#if CHECKSUM_CHECK_ICMP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
        if (inet_chksum_pbuf(p) != 0) {
 203adf0:	e13ffe17 	ldw	r4,-8(fp)
 203adf4:	203a2080 	call	203a208 <inet_chksum_pbuf>
 203adf8:	10bfffcc 	andi	r2,r2,65535
 203adfc:	10000a26 	beq	r2,zero,203ae28 <icmp_input+0x13c>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
          pbuf_free(p);
 203ae00:	e13ffe17 	ldw	r4,-8(fp)
 203ae04:	201d2f40 	call	201d2f4 <pbuf_free>
          ICMP_STATS_INC(icmp.chkerr);
 203ae08:	008085f4 	movhi	r2,535
 203ae0c:	10bd8204 	addi	r2,r2,-2552
 203ae10:	10803417 	ldw	r2,208(r2)
 203ae14:	10c00044 	addi	r3,r2,1
 203ae18:	008085f4 	movhi	r2,535
 203ae1c:	10bd8204 	addi	r2,r2,-2552
 203ae20:	10c03415 	stw	r3,208(r2)
          MIB2_STATS_INC(mib2.icmpinerrors);
          return;
 203ae24:	00013f06 	br	203b324 <icmp_input+0x638>
        }
      }
#endif
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 203ae28:	e0bff70b 	ldhu	r2,-36(fp)
 203ae2c:	10800404 	addi	r2,r2,16
 203ae30:	100b883a 	mov	r5,r2
 203ae34:	e13ffe17 	ldw	r4,-8(fp)
 203ae38:	201cff40 	call	201cff4 <pbuf_add_header>
 203ae3c:	10803fcc 	andi	r2,r2,255
 203ae40:	10003a26 	beq	r2,zero,203af2c <icmp_input+0x240>
        /* p is not big enough to contain link headers
         * allocate a new one and copy p into it
         */
        struct pbuf *r;
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
 203ae44:	e0bffe17 	ldw	r2,-8(fp)
 203ae48:	10c0020b 	ldhu	r3,8(r2)
 203ae4c:	e0bff70b 	ldhu	r2,-36(fp)
 203ae50:	1885883a 	add	r2,r3,r2
 203ae54:	e0bff90d 	sth	r2,-28(fp)
        if (alloc_len < p->tot_len) {
 203ae58:	e0bffe17 	ldw	r2,-8(fp)
 203ae5c:	1080020b 	ldhu	r2,8(r2)
 203ae60:	10bfffcc 	andi	r2,r2,65535
 203ae64:	e0fff90b 	ldhu	r3,-28(fp)
 203ae68:	18811f36 	bltu	r3,r2,203b2e8 <icmp_input+0x5fc>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
          goto icmperr;
        }
        /* allocate new packet buffer with space for link headers */
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
 203ae6c:	e0bff90b 	ldhu	r2,-28(fp)
 203ae70:	0180a004 	movi	r6,640
 203ae74:	100b883a 	mov	r5,r2
 203ae78:	01000404 	movi	r4,16
 203ae7c:	201c9740 	call	201c974 <pbuf_alloc>
 203ae80:	e0bffa15 	stw	r2,-24(fp)
        if (r == NULL) {
 203ae84:	e0bffa17 	ldw	r2,-24(fp)
 203ae88:	10011926 	beq	r2,zero,203b2f0 <icmp_input+0x604>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
          goto icmperr;
        }
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 203ae8c:	e0bffa17 	ldw	r2,-24(fp)
 203ae90:	1080028b 	ldhu	r2,10(r2)
 203ae94:	10ffffcc 	andi	r3,r2,65535
 203ae98:	e0bff70b 	ldhu	r2,-36(fp)
 203ae9c:	10800204 	addi	r2,r2,8
 203aea0:	1880032e 	bgeu	r3,r2,203aeb0 <icmp_input+0x1c4>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
          pbuf_free(r);
 203aea4:	e13ffa17 	ldw	r4,-24(fp)
 203aea8:	201d2f40 	call	201d2f4 <pbuf_free>
          goto icmperr;
 203aeac:	00011306 	br	203b2fc <icmp_input+0x610>
        }
        /* copy the ip header */
        MEMCPY(r->payload, iphdr_in, hlen);
 203aeb0:	e0bffa17 	ldw	r2,-24(fp)
 203aeb4:	10800117 	ldw	r2,4(r2)
 203aeb8:	e0fff70b 	ldhu	r3,-36(fp)
 203aebc:	180d883a 	mov	r6,r3
 203aec0:	e17ff617 	ldw	r5,-40(fp)
 203aec4:	1009883a 	mov	r4,r2
 203aec8:	2005e580 	call	2005e58 <memcpy>
        /* switch r->payload back to icmp header (cannot fail) */
        if (pbuf_remove_header(r, hlen)) {
 203aecc:	e0bff70b 	ldhu	r2,-36(fp)
 203aed0:	100b883a 	mov	r5,r2
 203aed4:	e13ffa17 	ldw	r4,-24(fp)
 203aed8:	201d06c0 	call	201d06c <pbuf_remove_header>
 203aedc:	10803fcc 	andi	r2,r2,255
 203aee0:	10000326 	beq	r2,zero,203aef0 <icmp_input+0x204>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
          pbuf_free(r);
 203aee4:	e13ffa17 	ldw	r4,-24(fp)
 203aee8:	201d2f40 	call	201d2f4 <pbuf_free>
          goto icmperr;
 203aeec:	00010306 	br	203b2fc <icmp_input+0x610>
        }
        /* copy the rest of the packet without ip header */
        if (pbuf_copy(r, p) != ERR_OK) {
 203aef0:	e17ffe17 	ldw	r5,-8(fp)
 203aef4:	e13ffa17 	ldw	r4,-24(fp)
 203aef8:	201d6600 	call	201d660 <pbuf_copy>
 203aefc:	10803fcc 	andi	r2,r2,255
 203af00:	1080201c 	xori	r2,r2,128
 203af04:	10bfe004 	addi	r2,r2,-128
 203af08:	10000326 	beq	r2,zero,203af18 <icmp_input+0x22c>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
          pbuf_free(r);
 203af0c:	e13ffa17 	ldw	r4,-24(fp)
 203af10:	201d2f40 	call	201d2f4 <pbuf_free>
          goto icmperr;
 203af14:	0000f906 	br	203b2fc <icmp_input+0x610>
        }
        /* free the original p */
        pbuf_free(p);
 203af18:	e13ffe17 	ldw	r4,-8(fp)
 203af1c:	201d2f40 	call	201d2f4 <pbuf_free>
        /* we now have an identical copy of p that has room for link headers */
        p = r;
 203af20:	e0bffa17 	ldw	r2,-24(fp)
 203af24:	e0bffe15 	stw	r2,-8(fp)
 203af28:	00000706 	br	203af48 <icmp_input+0x25c>
      } else {
        /* restore p->payload to point to icmp header (cannot fail) */
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 203af2c:	e0bff70b 	ldhu	r2,-36(fp)
 203af30:	10800404 	addi	r2,r2,16
 203af34:	100b883a 	mov	r5,r2
 203af38:	e13ffe17 	ldw	r4,-8(fp)
 203af3c:	201d06c0 	call	201d06c <pbuf_remove_header>
 203af40:	10803fcc 	andi	r2,r2,255
 203af44:	1000ec1e 	bne	r2,zero,203b2f8 <icmp_input+0x60c>
      }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
      /* At this point, all checks are OK. */
      /* We generate an answer by switching the dest and src ip addresses,
       * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
      iecho = (struct icmp_echo_hdr *)p->payload;
 203af48:	e0bffe17 	ldw	r2,-8(fp)
 203af4c:	10800117 	ldw	r2,4(r2)
 203af50:	e0bffb15 	stw	r2,-20(fp)
      if (pbuf_add_header(p, hlen)) {
 203af54:	e0bff70b 	ldhu	r2,-36(fp)
 203af58:	100b883a 	mov	r5,r2
 203af5c:	e13ffe17 	ldw	r4,-8(fp)
 203af60:	201cff40 	call	201cff4 <pbuf_add_header>
 203af64:	10803fcc 	andi	r2,r2,255
 203af68:	1000c81e 	bne	r2,zero,203b28c <icmp_input+0x5a0>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
      } else {
        err_t ret;
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
 203af6c:	e0bffe17 	ldw	r2,-8(fp)
 203af70:	10800117 	ldw	r2,4(r2)
 203af74:	e0bffc15 	stw	r2,-16(fp)
        ip4_addr_copy(iphdr->src, *src);
 203af78:	e0bff817 	ldw	r2,-32(fp)
 203af7c:	10c00017 	ldw	r3,0(r2)
 203af80:	e0bffc17 	ldw	r2,-16(fp)
 203af84:	19803fcc 	andi	r6,r3,255
 203af88:	11000303 	ldbu	r4,12(r2)
 203af8c:	2008703a 	and	r4,r4,zero
 203af90:	200b883a 	mov	r5,r4
 203af94:	3009883a 	mov	r4,r6
 203af98:	2908b03a 	or	r4,r5,r4
 203af9c:	11000305 	stb	r4,12(r2)
 203afa0:	1808d23a 	srli	r4,r3,8
 203afa4:	21803fcc 	andi	r6,r4,255
 203afa8:	11000343 	ldbu	r4,13(r2)
 203afac:	2008703a 	and	r4,r4,zero
 203afb0:	200b883a 	mov	r5,r4
 203afb4:	3009883a 	mov	r4,r6
 203afb8:	2908b03a 	or	r4,r5,r4
 203afbc:	11000345 	stb	r4,13(r2)
 203afc0:	1808d43a 	srli	r4,r3,16
 203afc4:	21803fcc 	andi	r6,r4,255
 203afc8:	11000383 	ldbu	r4,14(r2)
 203afcc:	2008703a 	and	r4,r4,zero
 203afd0:	200b883a 	mov	r5,r4
 203afd4:	3009883a 	mov	r4,r6
 203afd8:	2908b03a 	or	r4,r5,r4
 203afdc:	11000385 	stb	r4,14(r2)
 203afe0:	180ad63a 	srli	r5,r3,24
 203afe4:	10c003c3 	ldbu	r3,15(r2)
 203afe8:	1806703a 	and	r3,r3,zero
 203afec:	1809883a 	mov	r4,r3
 203aff0:	2807883a 	mov	r3,r5
 203aff4:	20c6b03a 	or	r3,r4,r3
 203aff8:	10c003c5 	stb	r3,15(r2)
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 203affc:	008085f4 	movhi	r2,535
 203b000:	10be4204 	addi	r2,r2,-1784
 203b004:	10c00417 	ldw	r3,16(r2)
 203b008:	e0bffc17 	ldw	r2,-16(fp)
 203b00c:	19803fcc 	andi	r6,r3,255
 203b010:	11000403 	ldbu	r4,16(r2)
 203b014:	2008703a 	and	r4,r4,zero
 203b018:	200b883a 	mov	r5,r4
 203b01c:	3009883a 	mov	r4,r6
 203b020:	2908b03a 	or	r4,r5,r4
 203b024:	11000405 	stb	r4,16(r2)
 203b028:	1808d23a 	srli	r4,r3,8
 203b02c:	21803fcc 	andi	r6,r4,255
 203b030:	11000443 	ldbu	r4,17(r2)
 203b034:	2008703a 	and	r4,r4,zero
 203b038:	200b883a 	mov	r5,r4
 203b03c:	3009883a 	mov	r4,r6
 203b040:	2908b03a 	or	r4,r5,r4
 203b044:	11000445 	stb	r4,17(r2)
 203b048:	1808d43a 	srli	r4,r3,16
 203b04c:	21803fcc 	andi	r6,r4,255
 203b050:	11000483 	ldbu	r4,18(r2)
 203b054:	2008703a 	and	r4,r4,zero
 203b058:	200b883a 	mov	r5,r4
 203b05c:	3009883a 	mov	r4,r6
 203b060:	2908b03a 	or	r4,r5,r4
 203b064:	11000485 	stb	r4,18(r2)
 203b068:	180ad63a 	srli	r5,r3,24
 203b06c:	10c004c3 	ldbu	r3,19(r2)
 203b070:	1806703a 	and	r3,r3,zero
 203b074:	1809883a 	mov	r4,r3
 203b078:	2807883a 	mov	r3,r5
 203b07c:	20c6b03a 	or	r3,r4,r3
 203b080:	10c004c5 	stb	r3,19(r2)
        ICMPH_TYPE_SET(iecho, ICMP_ER);
 203b084:	e0bffb17 	ldw	r2,-20(fp)
 203b088:	10000005 	stb	zero,0(r2)
#if CHECKSUM_GEN_ICMP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
          /* adjust the checksum */
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 203b08c:	e0bffb17 	ldw	r2,-20(fp)
 203b090:	10c00083 	ldbu	r3,2(r2)
 203b094:	108000c3 	ldbu	r2,3(r2)
 203b098:	1004923a 	slli	r2,r2,8
 203b09c:	10c4b03a 	or	r2,r2,r3
 203b0a0:	10bfffcc 	andi	r2,r2,65535
 203b0a4:	10bffe30 	cmpltui	r2,r2,65528
 203b0a8:	10001a1e 	bne	r2,zero,203b114 <icmp_input+0x428>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
 203b0ac:	e0bffb17 	ldw	r2,-20(fp)
 203b0b0:	10c00083 	ldbu	r3,2(r2)
 203b0b4:	108000c3 	ldbu	r2,3(r2)
 203b0b8:	1004923a 	slli	r2,r2,8
 203b0bc:	10c4b03a 	or	r2,r2,r3
 203b0c0:	10800244 	addi	r2,r2,9
 203b0c4:	100d883a 	mov	r6,r2
 203b0c8:	e0bffb17 	ldw	r2,-20(fp)
 203b0cc:	30ffffcc 	andi	r3,r6,65535
 203b0d0:	19403fcc 	andi	r5,r3,255
 203b0d4:	10c00083 	ldbu	r3,2(r2)
 203b0d8:	1806703a 	and	r3,r3,zero
 203b0dc:	1809883a 	mov	r4,r3
 203b0e0:	2807883a 	mov	r3,r5
 203b0e4:	20c6b03a 	or	r3,r4,r3
 203b0e8:	10c00085 	stb	r3,2(r2)
 203b0ec:	30ffffcc 	andi	r3,r6,65535
 203b0f0:	1806d23a 	srli	r3,r3,8
 203b0f4:	197fffcc 	andi	r5,r3,65535
 203b0f8:	10c000c3 	ldbu	r3,3(r2)
 203b0fc:	1806703a 	and	r3,r3,zero
 203b100:	1809883a 	mov	r4,r3
 203b104:	2807883a 	mov	r3,r5
 203b108:	20c6b03a 	or	r3,r4,r3
 203b10c:	10c000c5 	stb	r3,3(r2)
 203b110:	00001906 	br	203b178 <icmp_input+0x48c>
          } else {
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
 203b114:	e0bffb17 	ldw	r2,-20(fp)
 203b118:	10c00083 	ldbu	r3,2(r2)
 203b11c:	108000c3 	ldbu	r2,3(r2)
 203b120:	1004923a 	slli	r2,r2,8
 203b124:	10c4b03a 	or	r2,r2,r3
 203b128:	10800204 	addi	r2,r2,8
 203b12c:	100d883a 	mov	r6,r2
 203b130:	e0bffb17 	ldw	r2,-20(fp)
 203b134:	30ffffcc 	andi	r3,r6,65535
 203b138:	19403fcc 	andi	r5,r3,255
 203b13c:	10c00083 	ldbu	r3,2(r2)
 203b140:	1806703a 	and	r3,r3,zero
 203b144:	1809883a 	mov	r4,r3
 203b148:	2807883a 	mov	r3,r5
 203b14c:	20c6b03a 	or	r3,r4,r3
 203b150:	10c00085 	stb	r3,2(r2)
 203b154:	30ffffcc 	andi	r3,r6,65535
 203b158:	1806d23a 	srli	r3,r3,8
 203b15c:	197fffcc 	andi	r5,r3,65535
 203b160:	10c000c3 	ldbu	r3,3(r2)
 203b164:	1806703a 	and	r3,r3,zero
 203b168:	1809883a 	mov	r4,r3
 203b16c:	2807883a 	mov	r3,r5
 203b170:	20c6b03a 	or	r3,r4,r3
 203b174:	10c000c5 	stb	r3,3(r2)
#else /* CHECKSUM_GEN_ICMP */
        iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

        /* Set the correct TTL and recalculate the header checksum. */
        IPH_TTL_SET(iphdr, ICMP_TTL);
 203b178:	e0bffc17 	ldw	r2,-16(fp)
 203b17c:	00c01004 	movi	r3,64
 203b180:	10c00205 	stb	r3,8(r2)
        IPH_CHKSUM_SET(iphdr, 0);
 203b184:	e0bffc17 	ldw	r2,-16(fp)
 203b188:	10c00283 	ldbu	r3,10(r2)
 203b18c:	1806703a 	and	r3,r3,zero
 203b190:	10c00285 	stb	r3,10(r2)
 203b194:	10c002c3 	ldbu	r3,11(r2)
 203b198:	1806703a 	and	r3,r3,zero
 203b19c:	10c002c5 	stb	r3,11(r2)
#if CHECKSUM_GEN_IP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
 203b1a0:	e0bff70b 	ldhu	r2,-36(fp)
 203b1a4:	100b883a 	mov	r5,r2
 203b1a8:	e13ffc17 	ldw	r4,-16(fp)
 203b1ac:	203a1c40 	call	203a1c4 <inet_chksum>
 203b1b0:	100d883a 	mov	r6,r2
 203b1b4:	e0bffc17 	ldw	r2,-16(fp)
 203b1b8:	30ffffcc 	andi	r3,r6,65535
 203b1bc:	19403fcc 	andi	r5,r3,255
 203b1c0:	10c00283 	ldbu	r3,10(r2)
 203b1c4:	1806703a 	and	r3,r3,zero
 203b1c8:	1809883a 	mov	r4,r3
 203b1cc:	2807883a 	mov	r3,r5
 203b1d0:	20c6b03a 	or	r3,r4,r3
 203b1d4:	10c00285 	stb	r3,10(r2)
 203b1d8:	30ffffcc 	andi	r3,r6,65535
 203b1dc:	1806d23a 	srli	r3,r3,8
 203b1e0:	197fffcc 	andi	r5,r3,65535
 203b1e4:	10c002c3 	ldbu	r3,11(r2)
 203b1e8:	1806703a 	and	r3,r3,zero
 203b1ec:	1809883a 	mov	r4,r3
 203b1f0:	2807883a 	mov	r3,r5
 203b1f4:	20c6b03a 	or	r3,r4,r3
 203b1f8:	10c002c5 	stb	r3,11(r2)
        }
#endif /* CHECKSUM_GEN_IP */

        ICMP_STATS_INC(icmp.xmit);
 203b1fc:	008085f4 	movhi	r2,535
 203b200:	10bd8204 	addi	r2,r2,-2552
 203b204:	10803017 	ldw	r2,192(r2)
 203b208:	10c00044 	addi	r3,r2,1
 203b20c:	008085f4 	movhi	r2,535
 203b210:	10bd8204 	addi	r2,r2,-2552
 203b214:	10c03015 	stw	r3,192(r2)
        MIB2_STATS_INC(mib2.icmpoutmsgs);
        /* increase number of echo replies attempted to send */
        MIB2_STATS_INC(mib2.icmpoutechoreps);

        /* send an ICMP packet */
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 203b218:	e0bfff17 	ldw	r2,-4(fp)
 203b21c:	d8800215 	stw	r2,8(sp)
 203b220:	00800044 	movi	r2,1
 203b224:	d8800115 	stw	r2,4(sp)
 203b228:	d8000015 	stw	zero,0(sp)
 203b22c:	01c01004 	movi	r7,64
 203b230:	000d883a 	mov	r6,zero
 203b234:	e17ff817 	ldw	r5,-32(fp)
 203b238:	e13ffe17 	ldw	r4,-8(fp)
 203b23c:	203be1c0 	call	203be1c <ip4_output_if>
 203b240:	e0bffd05 	stb	r2,-12(fp)
                            ICMP_TTL, 0, IP_PROTO_ICMP, inp);
        if (ret != ERR_OK) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
        }
      }
      break;
 203b244:	00001106 	br	203b28c <icmp_input+0x5a0>
      } else if (type == ICMP_AMR) {
        MIB2_STATS_INC(mib2.icmpinaddrmaskreps);
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                               (s16_t)type, (s16_t)code));
      ICMP_STATS_INC(icmp.proterr);
 203b248:	008085f4 	movhi	r2,535
 203b24c:	10bd8204 	addi	r2,r2,-2552
 203b250:	10803817 	ldw	r2,224(r2)
 203b254:	10c00044 	addi	r3,r2,1
 203b258:	008085f4 	movhi	r2,535
 203b25c:	10bd8204 	addi	r2,r2,-2552
 203b260:	10c03815 	stw	r3,224(r2)
      ICMP_STATS_INC(icmp.drop);
 203b264:	008085f4 	movhi	r2,535
 203b268:	10bd8204 	addi	r2,r2,-2552
 203b26c:	10803317 	ldw	r2,204(r2)
 203b270:	10c00044 	addi	r3,r2,1
 203b274:	008085f4 	movhi	r2,535
 203b278:	10bd8204 	addi	r2,r2,-2552
 203b27c:	10c03315 	stw	r3,204(r2)
 203b280:	00000306 	br	203b290 <icmp_input+0x5a4>
  switch (type) {
    case ICMP_ER:
      /* This is OK, echo reply might have been parsed by a raw PCB
         (as obviously, an echo request has been sent, too). */
      MIB2_STATS_INC(mib2.icmpinechoreps);
      break;
 203b284:	0001883a 	nop
 203b288:	00000106 	br	203b290 <icmp_input+0x5a4>
                            ICMP_TTL, 0, IP_PROTO_ICMP, inp);
        if (ret != ERR_OK) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
        }
      }
      break;
 203b28c:	0001883a 	nop
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                               (s16_t)type, (s16_t)code));
      ICMP_STATS_INC(icmp.proterr);
      ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 203b290:	e13ffe17 	ldw	r4,-8(fp)
 203b294:	201d2f40 	call	201d2f4 <pbuf_free>
  return;
 203b298:	00002206 	br	203b324 <icmp_input+0x638>

  iphdr_in = ip4_current_header();
  hlen = IPH_HL_BYTES(iphdr_in);
  if (hlen < IP_HLEN) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
 203b29c:	0001883a 	nop
 203b2a0:	00000306 	br	203b2b0 <icmp_input+0x5c4>
  }
  if (p->len < sizeof(u16_t) * 2) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
 203b2a4:	0001883a 	nop
 203b2a8:	00000106 	br	203b2b0 <icmp_input+0x5c4>
#endif /* LWIP_BROADCAST_PING */
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
        goto lenerr;
 203b2ac:	0001883a 	nop
      ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
 203b2b0:	e13ffe17 	ldw	r4,-8(fp)
 203b2b4:	201d2f40 	call	201d2f4 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
 203b2b8:	008085f4 	movhi	r2,535
 203b2bc:	10bd8204 	addi	r2,r2,-2552
 203b2c0:	10803517 	ldw	r2,212(r2)
 203b2c4:	10c00044 	addi	r3,r2,1
 203b2c8:	008085f4 	movhi	r2,535
 203b2cc:	10bd8204 	addi	r2,r2,-2552
 203b2d0:	10c03515 	stw	r3,212(r2)
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 203b2d4:	00001306 	br	203b324 <icmp_input+0x638>
#if LWIP_MULTICAST_PING
        /* For multicast, use address of receiving interface as source address */
        src = netif_ip4_addr(inp);
#else /* LWIP_MULTICAST_PING */
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
        goto icmperr;
 203b2d8:	0001883a 	nop
 203b2dc:	00000706 	br	203b2fc <icmp_input+0x610>
#if LWIP_BROADCAST_PING
        /* For broadcast, use address of receiving interface as source address */
        src = netif_ip4_addr(inp);
#else /* LWIP_BROADCAST_PING */
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
        goto icmperr;
 203b2e0:	0001883a 	nop
 203b2e4:	00000506 	br	203b2fc <icmp_input+0x610>
         */
        struct pbuf *r;
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
        if (alloc_len < p->tot_len) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
          goto icmperr;
 203b2e8:	0001883a 	nop
 203b2ec:	00000306 	br	203b2fc <icmp_input+0x610>
        }
        /* allocate new packet buffer with space for link headers */
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
        if (r == NULL) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
          goto icmperr;
 203b2f0:	0001883a 	nop
 203b2f4:	00000106 	br	203b2fc <icmp_input+0x610>
        p = r;
      } else {
        /* restore p->payload to point to icmp header (cannot fail) */
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
          goto icmperr;
 203b2f8:	0001883a 	nop
  ICMP_STATS_INC(icmp.lenerr);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
icmperr:
  pbuf_free(p);
 203b2fc:	e13ffe17 	ldw	r4,-8(fp)
 203b300:	201d2f40 	call	201d2f4 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
 203b304:	008085f4 	movhi	r2,535
 203b308:	10bd8204 	addi	r2,r2,-2552
 203b30c:	10803a17 	ldw	r2,232(r2)
 203b310:	10c00044 	addi	r3,r2,1
 203b314:	008085f4 	movhi	r2,535
 203b318:	10bd8204 	addi	r2,r2,-2552
 203b31c:	10c03a15 	stw	r3,232(r2)
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 203b320:	0001883a 	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
}
 203b324:	e037883a 	mov	sp,fp
 203b328:	dfc00117 	ldw	ra,4(sp)
 203b32c:	df000017 	ldw	fp,0(sp)
 203b330:	dec00204 	addi	sp,sp,8
 203b334:	f800283a 	ret

0203b338 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 203b338:	defffc04 	addi	sp,sp,-16
 203b33c:	dfc00315 	stw	ra,12(sp)
 203b340:	df000215 	stw	fp,8(sp)
 203b344:	df000204 	addi	fp,sp,8
 203b348:	e13ffe15 	stw	r4,-8(fp)
 203b34c:	e17fff15 	stw	r5,-4(fp)
  MIB2_STATS_INC(mib2.icmpoutdestunreachs);
  icmp_send_response(p, ICMP_DUR, t);
 203b350:	e0bfff17 	ldw	r2,-4(fp)
 203b354:	10803fcc 	andi	r2,r2,255
 203b358:	100d883a 	mov	r6,r2
 203b35c:	014000c4 	movi	r5,3
 203b360:	e13ffe17 	ldw	r4,-8(fp)
 203b364:	203b3c80 	call	203b3c8 <icmp_send_response>
}
 203b368:	0001883a 	nop
 203b36c:	e037883a 	mov	sp,fp
 203b370:	dfc00117 	ldw	ra,4(sp)
 203b374:	df000017 	ldw	fp,0(sp)
 203b378:	dec00204 	addi	sp,sp,8
 203b37c:	f800283a 	ret

0203b380 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 203b380:	defffc04 	addi	sp,sp,-16
 203b384:	dfc00315 	stw	ra,12(sp)
 203b388:	df000215 	stw	fp,8(sp)
 203b38c:	df000204 	addi	fp,sp,8
 203b390:	e13ffe15 	stw	r4,-8(fp)
 203b394:	e17fff15 	stw	r5,-4(fp)
  MIB2_STATS_INC(mib2.icmpouttimeexcds);
  icmp_send_response(p, ICMP_TE, t);
 203b398:	e0bfff17 	ldw	r2,-4(fp)
 203b39c:	10803fcc 	andi	r2,r2,255
 203b3a0:	100d883a 	mov	r6,r2
 203b3a4:	014002c4 	movi	r5,11
 203b3a8:	e13ffe17 	ldw	r4,-8(fp)
 203b3ac:	203b3c80 	call	203b3c8 <icmp_send_response>
}
 203b3b0:	0001883a 	nop
 203b3b4:	e037883a 	mov	sp,fp
 203b3b8:	dfc00117 	ldw	ra,4(sp)
 203b3bc:	df000017 	ldw	fp,0(sp)
 203b3c0:	dec00204 	addi	sp,sp,8
 203b3c4:	f800283a 	ret

0203b3c8 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 203b3c8:	defff304 	addi	sp,sp,-52
 203b3cc:	dfc00c15 	stw	ra,48(sp)
 203b3d0:	df000b15 	stw	fp,44(sp)
 203b3d4:	df000b04 	addi	fp,sp,44
 203b3d8:	e13ffd15 	stw	r4,-12(fp)
 203b3dc:	2807883a 	mov	r3,r5
 203b3e0:	3005883a 	mov	r2,r6
 203b3e4:	e0fffe05 	stb	r3,-8(fp)
 203b3e8:	e0bfff05 	stb	r2,-4(fp)

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 203b3ec:	0180a004 	movi	r6,640
 203b3f0:	01400904 	movi	r5,36
 203b3f4:	01000904 	movi	r4,36
 203b3f8:	201c9740 	call	201c974 <pbuf_alloc>
 203b3fc:	e0bff815 	stw	r2,-32(fp)
                 PBUF_RAM);
  if (q == NULL) {
 203b400:	e0bff817 	ldw	r2,-32(fp)
 203b404:	10006926 	beq	r2,zero,203b5ac <icmp_send_response+0x1e4>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
              (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 203b408:	e0bffd17 	ldw	r2,-12(fp)
 203b40c:	10800117 	ldw	r2,4(r2)
 203b410:	e0bff915 	stw	r2,-28(fp)
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_hdr *)q->payload;
 203b414:	e0bff817 	ldw	r2,-32(fp)
 203b418:	10800117 	ldw	r2,4(r2)
 203b41c:	e0bffa15 	stw	r2,-24(fp)
  icmphdr->type = type;
 203b420:	e0bffa17 	ldw	r2,-24(fp)
 203b424:	e0fffe03 	ldbu	r3,-8(fp)
 203b428:	10c00005 	stb	r3,0(r2)
  icmphdr->code = code;
 203b42c:	e0bffa17 	ldw	r2,-24(fp)
 203b430:	e0ffff03 	ldbu	r3,-4(fp)
 203b434:	10c00045 	stb	r3,1(r2)
  icmphdr->data = 0;
 203b438:	e0bffa17 	ldw	r2,-24(fp)
 203b43c:	10c00103 	ldbu	r3,4(r2)
 203b440:	1806703a 	and	r3,r3,zero
 203b444:	10c00105 	stb	r3,4(r2)
 203b448:	10c00143 	ldbu	r3,5(r2)
 203b44c:	1806703a 	and	r3,r3,zero
 203b450:	10c00145 	stb	r3,5(r2)
 203b454:	10c00183 	ldbu	r3,6(r2)
 203b458:	1806703a 	and	r3,r3,zero
 203b45c:	10c00185 	stb	r3,6(r2)
 203b460:	10c001c3 	ldbu	r3,7(r2)
 203b464:	1806703a 	and	r3,r3,zero
 203b468:	10c001c5 	stb	r3,7(r2)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 203b46c:	e0bff817 	ldw	r2,-32(fp)
 203b470:	10800117 	ldw	r2,4(r2)
 203b474:	10c00204 	addi	r3,r2,8
 203b478:	e0bffd17 	ldw	r2,-12(fp)
 203b47c:	10800117 	ldw	r2,4(r2)
 203b480:	01800704 	movi	r6,28
 203b484:	100b883a 	mov	r5,r2
 203b488:	1809883a 	mov	r4,r3
 203b48c:	2005e580 	call	2005e58 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
 203b490:	e0bff917 	ldw	r2,-28(fp)
 203b494:	10c00303 	ldbu	r3,12(r2)
 203b498:	11000343 	ldbu	r4,13(r2)
 203b49c:	2008923a 	slli	r4,r4,8
 203b4a0:	20c6b03a 	or	r3,r4,r3
 203b4a4:	11000383 	ldbu	r4,14(r2)
 203b4a8:	2008943a 	slli	r4,r4,16
 203b4ac:	20c6b03a 	or	r3,r4,r3
 203b4b0:	108003c3 	ldbu	r2,15(r2)
 203b4b4:	1004963a 	slli	r2,r2,24
 203b4b8:	10c4b03a 	or	r2,r2,r3
 203b4bc:	e0bffc15 	stw	r2,-16(fp)
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
 203b4c0:	e0bffc04 	addi	r2,fp,-16
 203b4c4:	1009883a 	mov	r4,r2
 203b4c8:	203b5c40 	call	203b5c4 <ip4_route>
 203b4cc:	e0bffb15 	stw	r2,-20(fp)
#endif
  if (netif != NULL) {
 203b4d0:	e0bffb17 	ldw	r2,-20(fp)
 203b4d4:	10003226 	beq	r2,zero,203b5a0 <icmp_send_response+0x1d8>
    /* calculate checksum */
    icmphdr->chksum = 0;
 203b4d8:	e0bffa17 	ldw	r2,-24(fp)
 203b4dc:	10c00083 	ldbu	r3,2(r2)
 203b4e0:	1806703a 	and	r3,r3,zero
 203b4e4:	10c00085 	stb	r3,2(r2)
 203b4e8:	10c000c3 	ldbu	r3,3(r2)
 203b4ec:	1806703a 	and	r3,r3,zero
 203b4f0:	10c000c5 	stb	r3,3(r2)
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
 203b4f4:	e0bff817 	ldw	r2,-32(fp)
 203b4f8:	1080028b 	ldhu	r2,10(r2)
 203b4fc:	10bfffcc 	andi	r2,r2,65535
 203b500:	100b883a 	mov	r5,r2
 203b504:	e13ffa17 	ldw	r4,-24(fp)
 203b508:	203a1c40 	call	203a1c4 <inet_chksum>
 203b50c:	100d883a 	mov	r6,r2
 203b510:	e0bffa17 	ldw	r2,-24(fp)
 203b514:	30ffffcc 	andi	r3,r6,65535
 203b518:	19403fcc 	andi	r5,r3,255
 203b51c:	10c00083 	ldbu	r3,2(r2)
 203b520:	1806703a 	and	r3,r3,zero
 203b524:	1809883a 	mov	r4,r3
 203b528:	2807883a 	mov	r3,r5
 203b52c:	20c6b03a 	or	r3,r4,r3
 203b530:	10c00085 	stb	r3,2(r2)
 203b534:	30ffffcc 	andi	r3,r6,65535
 203b538:	1806d23a 	srli	r3,r3,8
 203b53c:	197fffcc 	andi	r5,r3,65535
 203b540:	10c000c3 	ldbu	r3,3(r2)
 203b544:	1806703a 	and	r3,r3,zero
 203b548:	1809883a 	mov	r4,r3
 203b54c:	2807883a 	mov	r3,r5
 203b550:	20c6b03a 	or	r3,r4,r3
 203b554:	10c000c5 	stb	r3,3(r2)
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
 203b558:	008085f4 	movhi	r2,535
 203b55c:	10bd8204 	addi	r2,r2,-2552
 203b560:	10803017 	ldw	r2,192(r2)
 203b564:	10c00044 	addi	r3,r2,1
 203b568:	008085f4 	movhi	r2,535
 203b56c:	10bd8204 	addi	r2,r2,-2552
 203b570:	10c03015 	stw	r3,192(r2)
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 203b574:	e0fffc04 	addi	r3,fp,-16
 203b578:	e0bffb17 	ldw	r2,-20(fp)
 203b57c:	d8800215 	stw	r2,8(sp)
 203b580:	00800044 	movi	r2,1
 203b584:	d8800115 	stw	r2,4(sp)
 203b588:	d8000015 	stw	zero,0(sp)
 203b58c:	01c01004 	movi	r7,64
 203b590:	180d883a 	mov	r6,r3
 203b594:	000b883a 	mov	r5,zero
 203b598:	e13ff817 	ldw	r4,-32(fp)
 203b59c:	203be1c0 	call	203be1c <ip4_output_if>
  }
  pbuf_free(q);
 203b5a0:	e13ff817 	ldw	r4,-32(fp)
 203b5a4:	201d2f40 	call	201d2f4 <pbuf_free>
 203b5a8:	00000106 	br	203b5b0 <icmp_send_response+0x1e8>
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
 203b5ac:	0001883a 	nop
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
  }
  pbuf_free(q);
}
 203b5b0:	e037883a 	mov	sp,fp
 203b5b4:	dfc00117 	ldw	ra,4(sp)
 203b5b8:	df000017 	ldw	fp,0(sp)
 203b5bc:	dec00204 	addi	sp,sp,8
 203b5c0:	f800283a 	ret

0203b5c4 <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 203b5c4:	defffd04 	addi	sp,sp,-12
 203b5c8:	df000215 	stw	fp,8(sp)
 203b5cc:	df000204 	addi	fp,sp,8
 203b5d0:	e13fff15 	stw	r4,-4(fp)

  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
  LWIP_UNUSED_ARG(dest);

  /* iterate through netifs */
  NETIF_FOREACH(netif) {
 203b5d4:	d0a7dc17 	ldw	r2,-24720(gp)
 203b5d8:	e0bffe15 	stw	r2,-8(fp)
 203b5dc:	00002b06 	br	203b68c <ip4_route+0xc8>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 203b5e0:	e0bffe17 	ldw	r2,-8(fp)
 203b5e4:	10800f43 	ldbu	r2,61(r2)
 203b5e8:	10803fcc 	andi	r2,r2,255
 203b5ec:	1080004c 	andi	r2,r2,1
 203b5f0:	10002326 	beq	r2,zero,203b680 <ip4_route+0xbc>
 203b5f4:	e0bffe17 	ldw	r2,-8(fp)
 203b5f8:	10800f43 	ldbu	r2,61(r2)
 203b5fc:	10803fcc 	andi	r2,r2,255
 203b600:	1080010c 	andi	r2,r2,4
 203b604:	10001e26 	beq	r2,zero,203b680 <ip4_route+0xbc>
 203b608:	e0bffe17 	ldw	r2,-8(fp)
 203b60c:	10800104 	addi	r2,r2,4
 203b610:	10800017 	ldw	r2,0(r2)
 203b614:	10001a26 	beq	r2,zero,203b680 <ip4_route+0xbc>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 203b618:	e0bfff17 	ldw	r2,-4(fp)
 203b61c:	10c00017 	ldw	r3,0(r2)
 203b620:	e0bffe17 	ldw	r2,-8(fp)
 203b624:	10800104 	addi	r2,r2,4
 203b628:	10800017 	ldw	r2,0(r2)
 203b62c:	1886f03a 	xor	r3,r3,r2
 203b630:	e0bffe17 	ldw	r2,-8(fp)
 203b634:	10800204 	addi	r2,r2,8
 203b638:	10800017 	ldw	r2,0(r2)
 203b63c:	1884703a 	and	r2,r3,r2
 203b640:	1000021e 	bne	r2,zero,203b64c <ip4_route+0x88>
        /* return netif on which to forward IP packet */
        return netif;
 203b644:	e0bffe17 	ldw	r2,-8(fp)
 203b648:	00003106 	br	203b710 <ip4_route+0x14c>
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 203b64c:	e0bffe17 	ldw	r2,-8(fp)
 203b650:	10800f43 	ldbu	r2,61(r2)
 203b654:	10803fcc 	andi	r2,r2,255
 203b658:	1080008c 	andi	r2,r2,2
 203b65c:	1000081e 	bne	r2,zero,203b680 <ip4_route+0xbc>
 203b660:	e0bfff17 	ldw	r2,-4(fp)
 203b664:	10c00017 	ldw	r3,0(r2)
 203b668:	e0bffe17 	ldw	r2,-8(fp)
 203b66c:	10800304 	addi	r2,r2,12
 203b670:	10800017 	ldw	r2,0(r2)
 203b674:	1880021e 	bne	r3,r2,203b680 <ip4_route+0xbc>
        /* return netif on which to forward IP packet */
        return netif;
 203b678:	e0bffe17 	ldw	r2,-8(fp)
 203b67c:	00002406 	br	203b710 <ip4_route+0x14c>

  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
  LWIP_UNUSED_ARG(dest);

  /* iterate through netifs */
  NETIF_FOREACH(netif) {
 203b680:	e0bffe17 	ldw	r2,-8(fp)
 203b684:	10800017 	ldw	r2,0(r2)
 203b688:	e0bffe15 	stw	r2,-8(fp)
 203b68c:	e0bffe17 	ldw	r2,-8(fp)
 203b690:	103fd31e 	bne	r2,zero,203b5e0 <__alt_mem_mem_0+0xfd01b5e0>
    return netif;
  }
#endif
#endif /* !LWIP_SINGLE_NETIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 203b694:	d0a7dd17 	ldw	r2,-24716(gp)
 203b698:	10001326 	beq	r2,zero,203b6e8 <ip4_route+0x124>
 203b69c:	d0a7dd17 	ldw	r2,-24716(gp)
 203b6a0:	10800f43 	ldbu	r2,61(r2)
 203b6a4:	10803fcc 	andi	r2,r2,255
 203b6a8:	1080004c 	andi	r2,r2,1
 203b6ac:	10000e26 	beq	r2,zero,203b6e8 <ip4_route+0x124>
 203b6b0:	d0a7dd17 	ldw	r2,-24716(gp)
 203b6b4:	10800f43 	ldbu	r2,61(r2)
 203b6b8:	10803fcc 	andi	r2,r2,255
 203b6bc:	1080010c 	andi	r2,r2,4
 203b6c0:	10000926 	beq	r2,zero,203b6e8 <ip4_route+0x124>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 203b6c4:	d0a7dd17 	ldw	r2,-24716(gp)
 203b6c8:	10800104 	addi	r2,r2,4
 203b6cc:	10800017 	ldw	r2,0(r2)
    return netif;
  }
#endif
#endif /* !LWIP_SINGLE_NETIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 203b6d0:	10000526 	beq	r2,zero,203b6e8 <ip4_route+0x124>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 203b6d4:	e0bfff17 	ldw	r2,-4(fp)
 203b6d8:	10800017 	ldw	r2,0(r2)
 203b6dc:	10803fcc 	andi	r2,r2,255
 203b6e0:	10801fd8 	cmpnei	r2,r2,127
 203b6e4:	1000091e 	bne	r2,zero,203b70c <ip4_route+0x148>
    /* No matching netif found and default netif is not usable.
       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 203b6e8:	008085f4 	movhi	r2,535
 203b6ec:	10bd8204 	addi	r2,r2,-2552
 203b6f0:	10802b17 	ldw	r2,172(r2)
 203b6f4:	10c00044 	addi	r3,r2,1
 203b6f8:	008085f4 	movhi	r2,535
 203b6fc:	10bd8204 	addi	r2,r2,-2552
 203b700:	10c02b15 	stw	r3,172(r2)
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
 203b704:	0005883a 	mov	r2,zero
 203b708:	00000106 	br	203b710 <ip4_route+0x14c>
  }

  return netif_default;
 203b70c:	d0a7dd17 	ldw	r2,-24716(gp)
}
 203b710:	e037883a 	mov	sp,fp
 203b714:	df000017 	ldw	fp,0(sp)
 203b718:	dec00104 	addi	sp,sp,4
 203b71c:	f800283a 	ret

0203b720 <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
 203b720:	defffd04 	addi	sp,sp,-12
 203b724:	dfc00215 	stw	ra,8(sp)
 203b728:	df000115 	stw	fp,4(sp)
 203b72c:	df000104 	addi	fp,sp,4
 203b730:	e13fff15 	stw	r4,-4(fp)
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 203b734:	e0bfff17 	ldw	r2,-4(fp)
 203b738:	10800f43 	ldbu	r2,61(r2)
 203b73c:	10803fcc 	andi	r2,r2,255
 203b740:	1080004c 	andi	r2,r2,1
 203b744:	10001526 	beq	r2,zero,203b79c <ip4_input_accept+0x7c>
 203b748:	e0bfff17 	ldw	r2,-4(fp)
 203b74c:	10800104 	addi	r2,r2,4
 203b750:	10800017 	ldw	r2,0(r2)
 203b754:	10001126 	beq	r2,zero,203b79c <ip4_input_accept+0x7c>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 203b758:	008085f4 	movhi	r2,535
 203b75c:	10be4204 	addi	r2,r2,-1784
 203b760:	10c00517 	ldw	r3,20(r2)
 203b764:	e0bfff17 	ldw	r2,-4(fp)
 203b768:	10800104 	addi	r2,r2,4
 203b76c:	10800017 	ldw	r2,0(r2)
 203b770:	18800826 	beq	r3,r2,203b794 <ip4_input_accept+0x74>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 203b774:	008085f4 	movhi	r2,535
 203b778:	10be4204 	addi	r2,r2,-1784
 203b77c:	10800517 	ldw	r2,20(r2)
 203b780:	e17fff17 	ldw	r5,-4(fp)
 203b784:	1009883a 	mov	r4,r2
 203b788:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 203b78c:	10803fcc 	andi	r2,r2,255
 203b790:	10000226 	beq	r2,zero,203b79c <ip4_input_accept+0x7c>
#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
       ) {
      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
                             netif->name[0], netif->name[1]));
      /* accept on this netif */
      return 1;
 203b794:	00800044 	movi	r2,1
 203b798:	00000106 	br	203b7a0 <ip4_input_accept+0x80>
      /* accept on this netif */
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
 203b79c:	0005883a 	mov	r2,zero
}
 203b7a0:	e037883a 	mov	sp,fp
 203b7a4:	dfc00117 	ldw	ra,4(sp)
 203b7a8:	df000017 	ldw	fp,0(sp)
 203b7ac:	dec00204 	addi	sp,sp,8
 203b7b0:	f800283a 	ret

0203b7b4 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 203b7b4:	defff604 	addi	sp,sp,-40
 203b7b8:	dfc00915 	stw	ra,36(sp)
 203b7bc:	df000815 	stw	fp,32(sp)
 203b7c0:	df000804 	addi	fp,sp,32
 203b7c4:	e13ffe15 	stw	r4,-8(fp)
 203b7c8:	e17fff15 	stw	r5,-4(fp)
  const struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP
  int check_ip_src = 1;
 203b7cc:	00800044 	movi	r2,1
 203b7d0:	e0bffa15 	stw	r2,-24(fp)
  raw_input_state_t raw_status;
#endif /* LWIP_RAW */

  LWIP_ASSERT_CORE_LOCKED();

  IP_STATS_INC(ip.recv);
 203b7d4:	008085f4 	movhi	r2,535
 203b7d8:	10bd8204 	addi	r2,r2,-2552
 203b7dc:	10802517 	ldw	r2,148(r2)
 203b7e0:	10c00044 	addi	r3,r2,1
 203b7e4:	008085f4 	movhi	r2,535
 203b7e8:	10bd8204 	addi	r2,r2,-2552
 203b7ec:	10c02515 	stw	r3,148(r2)
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 203b7f0:	e0bffe17 	ldw	r2,-8(fp)
 203b7f4:	10800117 	ldw	r2,4(r2)
 203b7f8:	e0bff815 	stw	r2,-32(fp)
  if (IPH_V(iphdr) != 4) {
 203b7fc:	e0bff817 	ldw	r2,-32(fp)
 203b800:	10800003 	ldbu	r2,0(r2)
 203b804:	10803fcc 	andi	r2,r2,255
 203b808:	1004d13a 	srli	r2,r2,4
 203b80c:	10803fcc 	andi	r2,r2,255
 203b810:	10800120 	cmpeqi	r2,r2,4
 203b814:	1000121e 	bne	r2,zero,203b860 <ip4_input+0xac>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 203b818:	e13ffe17 	ldw	r4,-8(fp)
 203b81c:	201d2f40 	call	201d2f4 <pbuf_free>
    IP_STATS_INC(ip.err);
 203b820:	008085f4 	movhi	r2,535
 203b824:	10bd8204 	addi	r2,r2,-2552
 203b828:	10802e17 	ldw	r2,184(r2)
 203b82c:	10c00044 	addi	r3,r2,1
 203b830:	008085f4 	movhi	r2,535
 203b834:	10bd8204 	addi	r2,r2,-2552
 203b838:	10c02e15 	stw	r3,184(r2)
    IP_STATS_INC(ip.drop);
 203b83c:	008085f4 	movhi	r2,535
 203b840:	10bd8204 	addi	r2,r2,-2552
 203b844:	10802717 	ldw	r2,156(r2)
 203b848:	10c00044 	addi	r3,r2,1
 203b84c:	008085f4 	movhi	r2,535
 203b850:	10bd8204 	addi	r2,r2,-2552
 203b854:	10c02715 	stw	r3,156(r2)
    MIB2_STATS_INC(mib2.ipinhdrerrors);
    return ERR_OK;
 203b858:	0005883a 	mov	r2,zero
 203b85c:	00016a06 	br	203be08 <ip4_input+0x654>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in bytes */
  iphdr_hlen = IPH_HL_BYTES(iphdr);
 203b860:	e0bff817 	ldw	r2,-32(fp)
 203b864:	10800003 	ldbu	r2,0(r2)
 203b868:	108003cc 	andi	r2,r2,15
 203b86c:	1085883a 	add	r2,r2,r2
 203b870:	1085883a 	add	r2,r2,r2
 203b874:	10803fcc 	andi	r2,r2,255
 203b878:	e0bffb0d 	sth	r2,-20(fp)
  /* obtain ip length in bytes */
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 203b87c:	e0bff817 	ldw	r2,-32(fp)
 203b880:	10c00083 	ldbu	r3,2(r2)
 203b884:	108000c3 	ldbu	r2,3(r2)
 203b888:	1004923a 	slli	r2,r2,8
 203b88c:	10c4b03a 	or	r2,r2,r3
 203b890:	10bfffcc 	andi	r2,r2,65535
 203b894:	1009883a 	mov	r4,r2
 203b898:	20394740 	call	2039474 <lwip_htons>
 203b89c:	e0bffb8d 	sth	r2,-18(fp)

  /* Trim pbuf. This is especially required for packets < 60 bytes. */
  if (iphdr_len < p->tot_len) {
 203b8a0:	e0bffe17 	ldw	r2,-8(fp)
 203b8a4:	1080020b 	ldhu	r2,8(r2)
 203b8a8:	10bfffcc 	andi	r2,r2,65535
 203b8ac:	e0fffb8b 	ldhu	r3,-18(fp)
 203b8b0:	1880042e 	bgeu	r3,r2,203b8c4 <ip4_input+0x110>
    pbuf_realloc(p, iphdr_len);
 203b8b4:	e0bffb8b 	ldhu	r2,-18(fp)
 203b8b8:	100b883a 	mov	r5,r2
 203b8bc:	e13ffe17 	ldw	r4,-8(fp)
 203b8c0:	201cd3c0 	call	201cd3c <pbuf_realloc>
  }

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 203b8c4:	e0bffe17 	ldw	r2,-8(fp)
 203b8c8:	1080028b 	ldhu	r2,10(r2)
 203b8cc:	10ffffcc 	andi	r3,r2,65535
 203b8d0:	e0bffb0b 	ldhu	r2,-20(fp)
 203b8d4:	18800836 	bltu	r3,r2,203b8f8 <ip4_input+0x144>
 203b8d8:	e0bffe17 	ldw	r2,-8(fp)
 203b8dc:	1080020b 	ldhu	r2,8(r2)
 203b8e0:	10ffffcc 	andi	r3,r2,65535
 203b8e4:	e0bffb8b 	ldhu	r2,-18(fp)
 203b8e8:	18800336 	bltu	r3,r2,203b8f8 <ip4_input+0x144>
 203b8ec:	e0bffb0b 	ldhu	r2,-20(fp)
 203b8f0:	10800528 	cmpgeui	r2,r2,20
 203b8f4:	1000121e 	bne	r2,zero,203b940 <ip4_input+0x18c>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
                   iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 203b8f8:	e13ffe17 	ldw	r4,-8(fp)
 203b8fc:	201d2f40 	call	201d2f4 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
 203b900:	008085f4 	movhi	r2,535
 203b904:	10bd8204 	addi	r2,r2,-2552
 203b908:	10802917 	ldw	r2,164(r2)
 203b90c:	10c00044 	addi	r3,r2,1
 203b910:	008085f4 	movhi	r2,535
 203b914:	10bd8204 	addi	r2,r2,-2552
 203b918:	10c02915 	stw	r3,164(r2)
    IP_STATS_INC(ip.drop);
 203b91c:	008085f4 	movhi	r2,535
 203b920:	10bd8204 	addi	r2,r2,-2552
 203b924:	10802717 	ldw	r2,156(r2)
 203b928:	10c00044 	addi	r3,r2,1
 203b92c:	008085f4 	movhi	r2,535
 203b930:	10bd8204 	addi	r2,r2,-2552
 203b934:	10c02715 	stw	r3,156(r2)
    MIB2_STATS_INC(mib2.ipindiscards);
    return ERR_OK;
 203b938:	0005883a 	mov	r2,zero
 203b93c:	00013206 	br	203be08 <ip4_input+0x654>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
    if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 203b940:	e0bffb0b 	ldhu	r2,-20(fp)
 203b944:	100b883a 	mov	r5,r2
 203b948:	e13ff817 	ldw	r4,-32(fp)
 203b94c:	203a1c40 	call	203a1c4 <inet_chksum>
 203b950:	10bfffcc 	andi	r2,r2,65535
 203b954:	10001226 	beq	r2,zero,203b9a0 <ip4_input+0x1ec>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
      ip4_debug_print(p);
      pbuf_free(p);
 203b958:	e13ffe17 	ldw	r4,-8(fp)
 203b95c:	201d2f40 	call	201d2f4 <pbuf_free>
      IP_STATS_INC(ip.chkerr);
 203b960:	008085f4 	movhi	r2,535
 203b964:	10bd8204 	addi	r2,r2,-2552
 203b968:	10802817 	ldw	r2,160(r2)
 203b96c:	10c00044 	addi	r3,r2,1
 203b970:	008085f4 	movhi	r2,535
 203b974:	10bd8204 	addi	r2,r2,-2552
 203b978:	10c02815 	stw	r3,160(r2)
      IP_STATS_INC(ip.drop);
 203b97c:	008085f4 	movhi	r2,535
 203b980:	10bd8204 	addi	r2,r2,-2552
 203b984:	10802717 	ldw	r2,156(r2)
 203b988:	10c00044 	addi	r3,r2,1
 203b98c:	008085f4 	movhi	r2,535
 203b990:	10bd8204 	addi	r2,r2,-2552
 203b994:	10c02715 	stw	r3,156(r2)
      MIB2_STATS_INC(mib2.ipinhdrerrors);
      return ERR_OK;
 203b998:	0005883a 	mov	r2,zero
 203b99c:	00011a06 	br	203be08 <ip4_input+0x654>
    }
  }
#endif

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 203b9a0:	e0bff817 	ldw	r2,-32(fp)
 203b9a4:	10c00403 	ldbu	r3,16(r2)
 203b9a8:	11000443 	ldbu	r4,17(r2)
 203b9ac:	2008923a 	slli	r4,r4,8
 203b9b0:	20c6b03a 	or	r3,r4,r3
 203b9b4:	11000483 	ldbu	r4,18(r2)
 203b9b8:	2008943a 	slli	r4,r4,16
 203b9bc:	20c6b03a 	or	r3,r4,r3
 203b9c0:	108004c3 	ldbu	r2,19(r2)
 203b9c4:	1004963a 	slli	r2,r2,24
 203b9c8:	10c4b03a 	or	r2,r2,r3
 203b9cc:	1007883a 	mov	r3,r2
 203b9d0:	008085f4 	movhi	r2,535
 203b9d4:	10be4204 	addi	r2,r2,-1784
 203b9d8:	10c00515 	stw	r3,20(r2)
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 203b9dc:	e0bff817 	ldw	r2,-32(fp)
 203b9e0:	10c00303 	ldbu	r3,12(r2)
 203b9e4:	11000343 	ldbu	r4,13(r2)
 203b9e8:	2008923a 	slli	r4,r4,8
 203b9ec:	20c6b03a 	or	r3,r4,r3
 203b9f0:	11000383 	ldbu	r4,14(r2)
 203b9f4:	2008943a 	slli	r4,r4,16
 203b9f8:	20c6b03a 	or	r3,r4,r3
 203b9fc:	108003c3 	ldbu	r2,15(r2)
 203ba00:	1004963a 	slli	r2,r2,24
 203ba04:	10c4b03a 	or	r2,r2,r3
 203ba08:	1007883a 	mov	r3,r2
 203ba0c:	008085f4 	movhi	r2,535
 203ba10:	10be4204 	addi	r2,r2,-1784
 203ba14:	10c00415 	stw	r3,16(r2)

  /* match packet against an interface, i.e. is this packet for us? */
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 203ba18:	008085f4 	movhi	r2,535
 203ba1c:	10be4204 	addi	r2,r2,-1784
 203ba20:	10800517 	ldw	r2,20(r2)
 203ba24:	10803c0c 	andi	r2,r2,240
 203ba28:	10803818 	cmpnei	r2,r2,224
 203ba2c:	10000e1e 	bne	r2,zero,203ba68 <ip4_input+0x2b4>
      netif = inp;
    } else {
      netif = NULL;
    }
#else /* LWIP_IGMP */
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 203ba30:	e0bfff17 	ldw	r2,-4(fp)
 203ba34:	10800f43 	ldbu	r2,61(r2)
 203ba38:	10803fcc 	andi	r2,r2,255
 203ba3c:	1080004c 	andi	r2,r2,1
 203ba40:	10000726 	beq	r2,zero,203ba60 <ip4_input+0x2ac>
 203ba44:	e0bfff17 	ldw	r2,-4(fp)
 203ba48:	10800104 	addi	r2,r2,4
 203ba4c:	10800017 	ldw	r2,0(r2)
 203ba50:	10000326 	beq	r2,zero,203ba60 <ip4_input+0x2ac>
      netif = inp;
 203ba54:	e0bfff17 	ldw	r2,-4(fp)
 203ba58:	e0bff915 	stw	r2,-28(fp)
 203ba5c:	00002106 	br	203bae4 <ip4_input+0x330>
    } else {
      netif = NULL;
 203ba60:	e03ff915 	stw	zero,-28(fp)
 203ba64:	00001f06 	br	203bae4 <ip4_input+0x330>
    }
#endif /* LWIP_IGMP */
  } else {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs. */
    if (ip4_input_accept(inp)) {
 203ba68:	e13fff17 	ldw	r4,-4(fp)
 203ba6c:	203b7200 	call	203b720 <ip4_input_accept>
 203ba70:	10000326 	beq	r2,zero,203ba80 <ip4_input+0x2cc>
      netif = inp;
 203ba74:	e0bfff17 	ldw	r2,-4(fp)
 203ba78:	e0bff915 	stw	r2,-28(fp)
 203ba7c:	00001906 	br	203bae4 <ip4_input+0x330>
    } else {
      netif = NULL;
 203ba80:	e03ff915 	stw	zero,-28(fp)
#if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
      /* Packets sent to the loopback address must not be accepted on an
       * interface that does not have the loopback address assigned to it,
       * unless a non-loopback interface is used for loopback traffic. */
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
 203ba84:	008085f4 	movhi	r2,535
 203ba88:	10be4204 	addi	r2,r2,-1784
 203ba8c:	10800517 	ldw	r2,20(r2)
 203ba90:	10803fcc 	andi	r2,r2,255
 203ba94:	10801fe0 	cmpeqi	r2,r2,127
 203ba98:	1000121e 	bne	r2,zero,203bae4 <ip4_input+0x330>
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
 203ba9c:	d0a7dc17 	ldw	r2,-24720(gp)
 203baa0:	e0bff915 	stw	r2,-28(fp)
 203baa4:	00000b06 	br	203bad4 <ip4_input+0x320>
          if (netif == inp) {
 203baa8:	e0fff917 	ldw	r3,-28(fp)
 203baac:	e0bfff17 	ldw	r2,-4(fp)
 203bab0:	18800426 	beq	r3,r2,203bac4 <ip4_input+0x310>
            /* we checked that before already */
            continue;
          }
          if (ip4_input_accept(netif)) {
 203bab4:	e13ff917 	ldw	r4,-28(fp)
 203bab8:	203b7200 	call	203b720 <ip4_input_accept>
 203babc:	1000081e 	bne	r2,zero,203bae0 <ip4_input+0x32c>
 203bac0:	00000106 	br	203bac8 <ip4_input+0x314>
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
          if (netif == inp) {
            /* we checked that before already */
            continue;
 203bac4:	0001883a 	nop
       * unless a non-loopback interface is used for loopback traffic. */
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
 203bac8:	e0bff917 	ldw	r2,-28(fp)
 203bacc:	10800017 	ldw	r2,0(r2)
 203bad0:	e0bff915 	stw	r2,-28(fp)
 203bad4:	e0bff917 	ldw	r2,-28(fp)
 203bad8:	103ff31e 	bne	r2,zero,203baa8 <__alt_mem_mem_0+0xfd01baa8>
 203badc:	00000106 	br	203bae4 <ip4_input+0x330>
          if (netif == inp) {
            /* we checked that before already */
            continue;
          }
          if (ip4_input_accept(netif)) {
            break;
 203bae0:	0001883a 	nop
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
 203bae4:	e0bff917 	ldw	r2,-28(fp)
 203bae8:	1000141e 	bne	r2,zero,203bb3c <ip4_input+0x388>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 203baec:	e0bff817 	ldw	r2,-32(fp)
 203baf0:	10800243 	ldbu	r2,9(r2)
 203baf4:	10803fcc 	andi	r2,r2,255
 203baf8:	10800458 	cmpnei	r2,r2,17
 203bafc:	10000f1e 	bne	r2,zero,203bb3c <ip4_input+0x388>
      const struct udp_hdr *udphdr = (const struct udp_hdr *)((const u8_t *)iphdr + iphdr_hlen);
 203bb00:	e0bffb0b 	ldhu	r2,-20(fp)
 203bb04:	e0fff817 	ldw	r3,-32(fp)
 203bb08:	1885883a 	add	r2,r3,r2
 203bb0c:	e0bffc15 	stw	r2,-16(fp)
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: UDP packet to DHCP client port %"U16_F"\n",
                                              lwip_ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 203bb10:	e0bffc17 	ldw	r2,-16(fp)
 203bb14:	10c00083 	ldbu	r3,2(r2)
 203bb18:	108000c3 	ldbu	r2,3(r2)
 203bb1c:	1004923a 	slli	r2,r2,8
 203bb20:	10c4b03a 	or	r2,r2,r3
 203bb24:	10bfffcc 	andi	r2,r2,65535
 203bb28:	10910018 	cmpnei	r2,r2,17408
 203bb2c:	1000031e 	bne	r2,zero,203bb3c <ip4_input+0x388>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: DHCP packet accepted.\n"));
        netif = inp;
 203bb30:	e0bfff17 	ldw	r2,-4(fp)
 203bb34:	e0bff915 	stw	r2,-28(fp)
        check_ip_src = 0;
 203bb38:	e03ffa15 	stw	zero,-24(fp)
  }
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING
  if (check_ip_src
 203bb3c:	e0bffa17 	ldw	r2,-24(fp)
 203bb40:	10001d26 	beq	r2,zero,203bbb8 <ip4_input+0x404>
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
      /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
      && !ip4_addr_isany_val(*ip4_current_src_addr())
 203bb44:	008085f4 	movhi	r2,535
 203bb48:	10be4204 	addi	r2,r2,-1784
 203bb4c:	10800417 	ldw	r2,16(r2)
 203bb50:	10001926 	beq	r2,zero,203bbb8 <ip4_input+0x404>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 203bb54:	008085f4 	movhi	r2,535
 203bb58:	10be4204 	addi	r2,r2,-1784
 203bb5c:	10800417 	ldw	r2,16(r2)
 203bb60:	e17fff17 	ldw	r5,-4(fp)
 203bb64:	1009883a 	mov	r4,r2
 203bb68:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
 203bb6c:	10803fcc 	andi	r2,r2,255
 203bb70:	1000061e 	bne	r2,zero,203bb8c <ip4_input+0x3d8>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 203bb74:	008085f4 	movhi	r2,535
 203bb78:	10be4204 	addi	r2,r2,-1784
 203bb7c:	10800417 	ldw	r2,16(r2)
 203bb80:	10803c0c 	andi	r2,r2,240
      && !ip4_addr_isany_val(*ip4_current_src_addr())
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 203bb84:	10803818 	cmpnei	r2,r2,224
 203bb88:	10000b1e 	bne	r2,zero,203bbb8 <ip4_input+0x404>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 203bb8c:	e13ffe17 	ldw	r4,-8(fp)
 203bb90:	201d2f40 	call	201d2f4 <pbuf_free>
      IP_STATS_INC(ip.drop);
 203bb94:	008085f4 	movhi	r2,535
 203bb98:	10bd8204 	addi	r2,r2,-2552
 203bb9c:	10802717 	ldw	r2,156(r2)
 203bba0:	10c00044 	addi	r3,r2,1
 203bba4:	008085f4 	movhi	r2,535
 203bba8:	10bd8204 	addi	r2,r2,-2552
 203bbac:	10c02715 	stw	r3,156(r2)
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
      return ERR_OK;
 203bbb0:	0005883a 	mov	r2,zero
 203bbb4:	00009406 	br	203be08 <ip4_input+0x654>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 203bbb8:	e0bff917 	ldw	r2,-28(fp)
 203bbbc:	10000b1e 	bne	r2,zero,203bbec <ip4_input+0x438>
      /* try to forward IP packet on (other) interfaces */
      ip4_forward(p, (struct ip_hdr *)p->payload, inp);
    } else
#endif /* IP_FORWARD */
    {
      IP_STATS_INC(ip.drop);
 203bbc0:	008085f4 	movhi	r2,535
 203bbc4:	10bd8204 	addi	r2,r2,-2552
 203bbc8:	10802717 	ldw	r2,156(r2)
 203bbcc:	10c00044 	addi	r3,r2,1
 203bbd0:	008085f4 	movhi	r2,535
 203bbd4:	10bd8204 	addi	r2,r2,-2552
 203bbd8:	10c02715 	stw	r3,156(r2)
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
    }
    pbuf_free(p);
 203bbdc:	e13ffe17 	ldw	r4,-8(fp)
 203bbe0:	201d2f40 	call	201d2f4 <pbuf_free>
    return ERR_OK;
 203bbe4:	0005883a 	mov	r2,zero
 203bbe8:	00008706 	br	203be08 <ip4_input+0x654>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 203bbec:	e0bff817 	ldw	r2,-32(fp)
 203bbf0:	10c00183 	ldbu	r3,6(r2)
 203bbf4:	108001c3 	ldbu	r2,7(r2)
 203bbf8:	1004923a 	slli	r2,r2,8
 203bbfc:	10c4b03a 	or	r2,r2,r3
 203bc00:	10bfffcc 	andi	r2,r2,65535
 203bc04:	10bfcfcc 	andi	r2,r2,65343
 203bc08:	10000a26 	beq	r2,zero,203bc34 <ip4_input+0x480>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip4_reass()\n",
                           lwip_ntohs(IPH_ID(iphdr)), p->tot_len, lwip_ntohs(IPH_LEN(iphdr)), (u16_t)!!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (u16_t)((lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK) * 8)));
    /* reassemble the packet*/
    p = ip4_reass(p);
 203bc0c:	e13ffe17 	ldw	r4,-8(fp)
 203bc10:	203d3880 	call	203d388 <ip4_reass>
 203bc14:	e0bffe15 	stw	r2,-8(fp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 203bc18:	e0bffe17 	ldw	r2,-8(fp)
 203bc1c:	1000021e 	bne	r2,zero,203bc28 <ip4_input+0x474>
      return ERR_OK;
 203bc20:	0005883a 	mov	r2,zero
 203bc24:	00007806 	br	203be08 <ip4_input+0x654>
    }
    iphdr = (const struct ip_hdr *)p->payload;
 203bc28:	e0bffe17 	ldw	r2,-8(fp)
 203bc2c:	10800117 	ldw	r2,4(r2)
 203bc30:	e0bff815 	stw	r2,-32(fp)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
  ip4_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  ip_data.current_netif = netif;
 203bc34:	008085f4 	movhi	r2,535
 203bc38:	10be4204 	addi	r2,r2,-1784
 203bc3c:	e0fff917 	ldw	r3,-28(fp)
 203bc40:	10c00015 	stw	r3,0(r2)
  ip_data.current_input_netif = inp;
 203bc44:	008085f4 	movhi	r2,535
 203bc48:	10be4204 	addi	r2,r2,-1784
 203bc4c:	e0ffff17 	ldw	r3,-4(fp)
 203bc50:	10c00115 	stw	r3,4(r2)
  ip_data.current_ip4_header = iphdr;
 203bc54:	008085f4 	movhi	r2,535
 203bc58:	10be4204 	addi	r2,r2,-1784
 203bc5c:	e0fff817 	ldw	r3,-32(fp)
 203bc60:	10c00215 	stw	r3,8(r2)
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
 203bc64:	e0bff817 	ldw	r2,-32(fp)
 203bc68:	10800003 	ldbu	r2,0(r2)
 203bc6c:	108003cc 	andi	r2,r2,15
 203bc70:	1085883a 	add	r2,r2,r2
 203bc74:	1085883a 	add	r2,r2,r2
 203bc78:	10c03fcc 	andi	r3,r2,255
 203bc7c:	008085f4 	movhi	r2,535
 203bc80:	10be4204 	addi	r2,r2,-1784
 203bc84:	10c0030d 	sth	r3,12(r2)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  raw_status = raw_input(p, inp);
 203bc88:	e17fff17 	ldw	r5,-4(fp)
 203bc8c:	e13ffe17 	ldw	r4,-8(fp)
 203bc90:	201e4dc0 	call	201e4dc <raw_input>
 203bc94:	e0bffd15 	stw	r2,-12(fp)
  if (raw_status != RAW_INPUT_EATEN)
 203bc98:	e0bffd17 	ldw	r2,-12(fp)
 203bc9c:	10800060 	cmpeqi	r2,r2,1
 203bca0:	1000461e 	bne	r2,zero,203bdbc <ip4_input+0x608>
#endif /* LWIP_RAW */
  {
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
 203bca4:	e0bffb0b 	ldhu	r2,-20(fp)
 203bca8:	100b883a 	mov	r5,r2
 203bcac:	e13ffe17 	ldw	r4,-8(fp)
 203bcb0:	201d06c0 	call	201d06c <pbuf_remove_header>

    switch (IPH_PROTO(iphdr)) {
 203bcb4:	e0bff817 	ldw	r2,-32(fp)
 203bcb8:	10800243 	ldbu	r2,9(r2)
 203bcbc:	10803fcc 	andi	r2,r2,255
 203bcc0:	10c001a0 	cmpeqi	r3,r2,6
 203bcc4:	1800091e 	bne	r3,zero,203bcec <ip4_input+0x538>
 203bcc8:	10c00460 	cmpeqi	r3,r2,17
 203bccc:	1800031e 	bne	r3,zero,203bcdc <ip4_input+0x528>
 203bcd0:	10800060 	cmpeqi	r2,r2,1
 203bcd4:	1000091e 	bne	r2,zero,203bcfc <ip4_input+0x548>
 203bcd8:	00000c06 	br	203bd0c <ip4_input+0x558>
      case IP_PROTO_UDP:
#if LWIP_UDPLITE
      case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
        MIB2_STATS_INC(mib2.ipindelivers);
        udp_input(p, inp);
 203bcdc:	e17fff17 	ldw	r5,-4(fp)
 203bce0:	e13ffe17 	ldw	r4,-8(fp)
 203bce4:	20299f00 	call	20299f0 <udp_input>
        break;
 203bce8:	00003406 	br	203bdbc <ip4_input+0x608>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case IP_PROTO_TCP:
        MIB2_STATS_INC(mib2.ipindelivers);
        tcp_input(p, inp);
 203bcec:	e17fff17 	ldw	r5,-4(fp)
 203bcf0:	e13ffe17 	ldw	r4,-8(fp)
 203bcf4:	2021cb80 	call	2021cb8 <tcp_input>
        break;
 203bcf8:	00003006 	br	203bdbc <ip4_input+0x608>
#endif /* LWIP_TCP */
#if LWIP_ICMP
      case IP_PROTO_ICMP:
        MIB2_STATS_INC(mib2.ipindelivers);
        icmp_input(p, inp);
 203bcfc:	e17fff17 	ldw	r5,-4(fp)
 203bd00:	e13ffe17 	ldw	r4,-8(fp)
 203bd04:	203acec0 	call	203acec <icmp_input>
        break;
 203bd08:	00002c06 	br	203bdbc <ip4_input+0x608>
        igmp_input(p, inp, ip4_current_dest_addr());
        break;
#endif /* LWIP_IGMP */
      default:
#if LWIP_RAW
        if (raw_status == RAW_INPUT_DELIVERED) {
 203bd0c:	e0bffd17 	ldw	r2,-12(fp)
 203bd10:	108000a0 	cmpeqi	r2,r2,2
 203bd14:	1000261e 	bne	r2,zero,203bdb0 <ip4_input+0x5fc>
        } else
#endif /* LWIP_RAW */
        {
#if LWIP_ICMP
          /* send ICMP destination protocol unreachable unless is was a broadcast */
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 203bd18:	008085f4 	movhi	r2,535
 203bd1c:	10be4204 	addi	r2,r2,-1784
 203bd20:	10800517 	ldw	r2,20(r2)
 203bd24:	e17ff917 	ldw	r5,-28(fp)
 203bd28:	1009883a 	mov	r4,r2
 203bd2c:	201a2100 	call	201a210 <ip4_addr_isbroadcast_u32>
 203bd30:	10803fcc 	andi	r2,r2,255
 203bd34:	1000101e 	bne	r2,zero,203bd78 <ip4_input+0x5c4>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 203bd38:	008085f4 	movhi	r2,535
 203bd3c:	10be4204 	addi	r2,r2,-1784
 203bd40:	10800517 	ldw	r2,20(r2)
 203bd44:	10803c0c 	andi	r2,r2,240
        } else
#endif /* LWIP_RAW */
        {
#if LWIP_ICMP
          /* send ICMP destination protocol unreachable unless is was a broadcast */
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 203bd48:	10803820 	cmpeqi	r2,r2,224
 203bd4c:	10000a1e 	bne	r2,zero,203bd78 <ip4_input+0x5c4>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
 203bd50:	e0bffb0b 	ldhu	r2,-20(fp)
 203bd54:	10bfffcc 	andi	r2,r2,65535
 203bd58:	10a0001c 	xori	r2,r2,32768
 203bd5c:	10a00004 	addi	r2,r2,-32768
 203bd60:	100b883a 	mov	r5,r2
 203bd64:	e13ffe17 	ldw	r4,-8(fp)
 203bd68:	201d1f40 	call	201d1f4 <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
 203bd6c:	01400084 	movi	r5,2
 203bd70:	e13ffe17 	ldw	r4,-8(fp)
 203bd74:	203b3380 	call	203b338 <icmp_dest_unreach>
          }
#endif /* LWIP_ICMP */

          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", (u16_t)IPH_PROTO(iphdr)));

          IP_STATS_INC(ip.proterr);
 203bd78:	008085f4 	movhi	r2,535
 203bd7c:	10bd8204 	addi	r2,r2,-2552
 203bd80:	10802c17 	ldw	r2,176(r2)
 203bd84:	10c00044 	addi	r3,r2,1
 203bd88:	008085f4 	movhi	r2,535
 203bd8c:	10bd8204 	addi	r2,r2,-2552
 203bd90:	10c02c15 	stw	r3,176(r2)
          IP_STATS_INC(ip.drop);
 203bd94:	008085f4 	movhi	r2,535
 203bd98:	10bd8204 	addi	r2,r2,-2552
 203bd9c:	10802717 	ldw	r2,156(r2)
 203bda0:	10c00044 	addi	r3,r2,1
 203bda4:	008085f4 	movhi	r2,535
 203bda8:	10bd8204 	addi	r2,r2,-2552
 203bdac:	10c02715 	stw	r3,156(r2)
          MIB2_STATS_INC(mib2.ipinunknownprotos);
        }
        pbuf_free(p);
 203bdb0:	e13ffe17 	ldw	r4,-8(fp)
 203bdb4:	201d2f40 	call	201d2f4 <pbuf_free>
        break;
 203bdb8:	0001883a 	nop
    }
  }

  /* @todo: this is not really necessary... */
  ip_data.current_netif = NULL;
 203bdbc:	008085f4 	movhi	r2,535
 203bdc0:	10be4204 	addi	r2,r2,-1784
 203bdc4:	10000015 	stw	zero,0(r2)
  ip_data.current_input_netif = NULL;
 203bdc8:	008085f4 	movhi	r2,535
 203bdcc:	10be4204 	addi	r2,r2,-1784
 203bdd0:	10000115 	stw	zero,4(r2)
  ip_data.current_ip4_header = NULL;
 203bdd4:	008085f4 	movhi	r2,535
 203bdd8:	10be4204 	addi	r2,r2,-1784
 203bddc:	10000215 	stw	zero,8(r2)
  ip_data.current_ip_header_tot_len = 0;
 203bde0:	008085f4 	movhi	r2,535
 203bde4:	10be4204 	addi	r2,r2,-1784
 203bde8:	1000030d 	sth	zero,12(r2)
  ip4_addr_set_any(ip4_current_src_addr());
 203bdec:	008085f4 	movhi	r2,535
 203bdf0:	10be4204 	addi	r2,r2,-1784
 203bdf4:	10000415 	stw	zero,16(r2)
  ip4_addr_set_any(ip4_current_dest_addr());
 203bdf8:	008085f4 	movhi	r2,535
 203bdfc:	10be4204 	addi	r2,r2,-1784
 203be00:	10000515 	stw	zero,20(r2)

  return ERR_OK;
 203be04:	0005883a 	mov	r2,zero
}
 203be08:	e037883a 	mov	sp,fp
 203be0c:	dfc00117 	ldw	ra,4(sp)
 203be10:	df000017 	ldw	fp,0(sp)
 203be14:	dec00204 	addi	sp,sp,8
 203be18:	f800283a 	ret

0203be1c <ip4_output_if>:
 */
err_t
ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
              u8_t ttl, u8_t tos,
              u8_t proto, struct netif *netif)
{
 203be1c:	defff404 	addi	sp,sp,-48
 203be20:	dfc00b15 	stw	ra,44(sp)
 203be24:	df000a15 	stw	fp,40(sp)
 203be28:	df000a04 	addi	fp,sp,40
 203be2c:	e13ffa15 	stw	r4,-24(fp)
 203be30:	e17ffb15 	stw	r5,-20(fp)
 203be34:	e1bffc15 	stw	r6,-16(fp)
 203be38:	3809883a 	mov	r4,r7
 203be3c:	e0c00217 	ldw	r3,8(fp)
 203be40:	e0800317 	ldw	r2,12(fp)
 203be44:	e13ffd05 	stb	r4,-12(fp)
 203be48:	e0fffe05 	stb	r3,-8(fp)
 203be4c:	e0bfff05 	stb	r2,-4(fp)
ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
                  u16_t optlen)
{
#endif /* IP_OPTIONS_SEND */
  const ip4_addr_t *src_used = src;
 203be50:	e0bffb17 	ldw	r2,-20(fp)
 203be54:	e0bff915 	stw	r2,-28(fp)
  if (dest != LWIP_IP_HDRINCL) {
 203be58:	e0bffc17 	ldw	r2,-16(fp)
 203be5c:	10000826 	beq	r2,zero,203be80 <ip4_output_if+0x64>
    if (ip4_addr_isany(src)) {
 203be60:	e0bffb17 	ldw	r2,-20(fp)
 203be64:	10000326 	beq	r2,zero,203be74 <ip4_output_if+0x58>
 203be68:	e0bffb17 	ldw	r2,-20(fp)
 203be6c:	10800017 	ldw	r2,0(r2)
 203be70:	1000031e 	bne	r2,zero,203be80 <ip4_output_if+0x64>
      src_used = netif_ip4_addr(netif);
 203be74:	e0800417 	ldw	r2,16(fp)
 203be78:	10800104 	addi	r2,r2,4
 203be7c:	e0bff915 	stw	r2,-28(fp)

#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
                               ip_options, optlen);
#else /* IP_OPTIONS_SEND */
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 203be80:	e17ffd03 	ldbu	r5,-12(fp)
 203be84:	e0bffe03 	ldbu	r2,-8(fp)
 203be88:	e0ffff03 	ldbu	r3,-4(fp)
 203be8c:	e1000417 	ldw	r4,16(fp)
 203be90:	d9000215 	stw	r4,8(sp)
 203be94:	d8c00115 	stw	r3,4(sp)
 203be98:	d8800015 	stw	r2,0(sp)
 203be9c:	280f883a 	mov	r7,r5
 203bea0:	e1bffc17 	ldw	r6,-16(fp)
 203bea4:	e17ff917 	ldw	r5,-28(fp)
 203bea8:	e13ffa17 	ldw	r4,-24(fp)
 203beac:	203bec40 	call	203bec4 <ip4_output_if_src>
#endif /* IP_OPTIONS_SEND */
}
 203beb0:	e037883a 	mov	sp,fp
 203beb4:	dfc00117 	ldw	ra,4(sp)
 203beb8:	df000017 	ldw	fp,0(sp)
 203bebc:	dec00204 	addi	sp,sp,8
 203bec0:	f800283a 	ret

0203bec4 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos,
                  u8_t proto, struct netif *netif)
{
 203bec4:	defff404 	addi	sp,sp,-48
 203bec8:	dfc00b15 	stw	ra,44(sp)
 203becc:	df000a15 	stw	fp,40(sp)
 203bed0:	df000a04 	addi	fp,sp,40
 203bed4:	e13ffa15 	stw	r4,-24(fp)
 203bed8:	e17ffb15 	stw	r5,-20(fp)
 203bedc:	e1bffc15 	stw	r6,-16(fp)
 203bee0:	3809883a 	mov	r4,r7
 203bee4:	e0c00217 	ldw	r3,8(fp)
 203bee8:	e0800317 	ldw	r2,12(fp)
 203beec:	e13ffd05 	stb	r4,-12(fp)
 203bef0:	e0fffe05 	stb	r3,-8(fp)
 203bef4:	e0bfff05 	stb	r2,-4(fp)
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
 203bef8:	e03ff615 	stw	zero,-40(fp)
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 203befc:	e0bffc17 	ldw	r2,-16(fp)
 203bf00:	10015726 	beq	r2,zero,203c460 <ip4_output_if_src+0x59c>
    u16_t ip_hlen = IP_HLEN;
 203bf04:	00800504 	movi	r2,20
 203bf08:	e0bff70d 	sth	r2,-36(fp)
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
 203bf0c:	01400504 	movi	r5,20
 203bf10:	e13ffa17 	ldw	r4,-24(fp)
 203bf14:	201cff40 	call	201cff4 <pbuf_add_header>
 203bf18:	10803fcc 	andi	r2,r2,255
 203bf1c:	10000926 	beq	r2,zero,203bf44 <ip4_output_if_src+0x80>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
 203bf20:	008085f4 	movhi	r2,535
 203bf24:	10bd8204 	addi	r2,r2,-2552
 203bf28:	10802e17 	ldw	r2,184(r2)
 203bf2c:	10c00044 	addi	r3,r2,1
 203bf30:	008085f4 	movhi	r2,535
 203bf34:	10bd8204 	addi	r2,r2,-2552
 203bf38:	10c02e15 	stw	r3,184(r2)
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 203bf3c:	00bfff84 	movi	r2,-2
 203bf40:	00018306 	br	203c550 <ip4_output_if_src+0x68c>
    }

    iphdr = (struct ip_hdr *)p->payload;
 203bf44:	e0bffa17 	ldw	r2,-24(fp)
 203bf48:	10800117 	ldw	r2,4(r2)
 203bf4c:	e0bff815 	stw	r2,-32(fp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
                (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 203bf50:	e0bff817 	ldw	r2,-32(fp)
 203bf54:	e0fffd03 	ldbu	r3,-12(fp)
 203bf58:	10c00205 	stb	r3,8(r2)
    IPH_PROTO_SET(iphdr, proto);
 203bf5c:	e0bff817 	ldw	r2,-32(fp)
 203bf60:	e0ffff03 	ldbu	r3,-4(fp)
 203bf64:	10c00245 	stb	r3,9(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
 203bf68:	e0ffff03 	ldbu	r3,-4(fp)
 203bf6c:	e0bffd03 	ldbu	r2,-12(fp)
 203bf70:	1004923a 	slli	r2,r2,8
 203bf74:	1884b03a 	or	r2,r3,r2
 203bf78:	1004923a 	slli	r2,r2,8
 203bf7c:	1009883a 	mov	r4,r2
 203bf80:	e0ffff03 	ldbu	r3,-4(fp)
 203bf84:	e0bffd03 	ldbu	r2,-12(fp)
 203bf88:	1004923a 	slli	r2,r2,8
 203bf8c:	1884b03a 	or	r2,r3,r2
 203bf90:	10bfc00c 	andi	r2,r2,65280
 203bf94:	1005d23a 	srai	r2,r2,8
 203bf98:	2084b03a 	or	r2,r4,r2
 203bf9c:	10bfffcc 	andi	r2,r2,65535
 203bfa0:	e0fff617 	ldw	r3,-40(fp)
 203bfa4:	1885883a 	add	r2,r3,r2
 203bfa8:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 203bfac:	e0bffc17 	ldw	r2,-16(fp)
 203bfb0:	10c00017 	ldw	r3,0(r2)
 203bfb4:	e0bff817 	ldw	r2,-32(fp)
 203bfb8:	19803fcc 	andi	r6,r3,255
 203bfbc:	11000403 	ldbu	r4,16(r2)
 203bfc0:	2008703a 	and	r4,r4,zero
 203bfc4:	200b883a 	mov	r5,r4
 203bfc8:	3009883a 	mov	r4,r6
 203bfcc:	2908b03a 	or	r4,r5,r4
 203bfd0:	11000405 	stb	r4,16(r2)
 203bfd4:	1808d23a 	srli	r4,r3,8
 203bfd8:	21803fcc 	andi	r6,r4,255
 203bfdc:	11000443 	ldbu	r4,17(r2)
 203bfe0:	2008703a 	and	r4,r4,zero
 203bfe4:	200b883a 	mov	r5,r4
 203bfe8:	3009883a 	mov	r4,r6
 203bfec:	2908b03a 	or	r4,r5,r4
 203bff0:	11000445 	stb	r4,17(r2)
 203bff4:	1808d43a 	srli	r4,r3,16
 203bff8:	21803fcc 	andi	r6,r4,255
 203bffc:	11000483 	ldbu	r4,18(r2)
 203c000:	2008703a 	and	r4,r4,zero
 203c004:	200b883a 	mov	r5,r4
 203c008:	3009883a 	mov	r4,r6
 203c00c:	2908b03a 	or	r4,r5,r4
 203c010:	11000485 	stb	r4,18(r2)
 203c014:	180ad63a 	srli	r5,r3,24
 203c018:	10c004c3 	ldbu	r3,19(r2)
 203c01c:	1806703a 	and	r3,r3,zero
 203c020:	1809883a 	mov	r4,r3
 203c024:	2807883a 	mov	r3,r5
 203c028:	20c6b03a 	or	r3,r4,r3
 203c02c:	10c004c5 	stb	r3,19(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 203c030:	e0bff817 	ldw	r2,-32(fp)
 203c034:	10c00403 	ldbu	r3,16(r2)
 203c038:	11000443 	ldbu	r4,17(r2)
 203c03c:	2008923a 	slli	r4,r4,8
 203c040:	20c6b03a 	or	r3,r4,r3
 203c044:	11000483 	ldbu	r4,18(r2)
 203c048:	2008943a 	slli	r4,r4,16
 203c04c:	20c6b03a 	or	r3,r4,r3
 203c050:	108004c3 	ldbu	r2,19(r2)
 203c054:	1004963a 	slli	r2,r2,24
 203c058:	10c4b03a 	or	r2,r2,r3
 203c05c:	10bfffcc 	andi	r2,r2,65535
 203c060:	e0fff617 	ldw	r3,-40(fp)
 203c064:	1885883a 	add	r2,r3,r2
 203c068:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
 203c06c:	e0bff817 	ldw	r2,-32(fp)
 203c070:	10c00403 	ldbu	r3,16(r2)
 203c074:	11000443 	ldbu	r4,17(r2)
 203c078:	2008923a 	slli	r4,r4,8
 203c07c:	20c6b03a 	or	r3,r4,r3
 203c080:	11000483 	ldbu	r4,18(r2)
 203c084:	2008943a 	slli	r4,r4,16
 203c088:	20c6b03a 	or	r3,r4,r3
 203c08c:	108004c3 	ldbu	r2,19(r2)
 203c090:	1004963a 	slli	r2,r2,24
 203c094:	10c4b03a 	or	r2,r2,r3
 203c098:	1004d43a 	srli	r2,r2,16
 203c09c:	e0fff617 	ldw	r3,-40(fp)
 203c0a0:	1885883a 	add	r2,r3,r2
 203c0a4:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 203c0a8:	e0bff70b 	ldhu	r2,-36(fp)
 203c0ac:	1004d0ba 	srli	r2,r2,2
 203c0b0:	10801014 	ori	r2,r2,64
 203c0b4:	1007883a 	mov	r3,r2
 203c0b8:	e0bff817 	ldw	r2,-32(fp)
 203c0bc:	10c00005 	stb	r3,0(r2)
    IPH_TOS_SET(iphdr, tos);
 203c0c0:	e0bff817 	ldw	r2,-32(fp)
 203c0c4:	e0fffe03 	ldbu	r3,-8(fp)
 203c0c8:	10c00045 	stb	r3,1(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
 203c0cc:	e0fffe03 	ldbu	r3,-8(fp)
 203c0d0:	e0bff817 	ldw	r2,-32(fp)
 203c0d4:	10800003 	ldbu	r2,0(r2)
 203c0d8:	10803fcc 	andi	r2,r2,255
 203c0dc:	1004923a 	slli	r2,r2,8
 203c0e0:	1884b03a 	or	r2,r3,r2
 203c0e4:	1004923a 	slli	r2,r2,8
 203c0e8:	1009883a 	mov	r4,r2
 203c0ec:	e0fffe03 	ldbu	r3,-8(fp)
 203c0f0:	e0bff817 	ldw	r2,-32(fp)
 203c0f4:	10800003 	ldbu	r2,0(r2)
 203c0f8:	10803fcc 	andi	r2,r2,255
 203c0fc:	1004923a 	slli	r2,r2,8
 203c100:	1884b03a 	or	r2,r3,r2
 203c104:	10bfc00c 	andi	r2,r2,65280
 203c108:	1005d23a 	srai	r2,r2,8
 203c10c:	2084b03a 	or	r2,r4,r2
 203c110:	10bfffcc 	andi	r2,r2,65535
 203c114:	e0fff617 	ldw	r3,-40(fp)
 203c118:	1885883a 	add	r2,r3,r2
 203c11c:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 203c120:	e0bffa17 	ldw	r2,-24(fp)
 203c124:	1080020b 	ldhu	r2,8(r2)
 203c128:	10bfffcc 	andi	r2,r2,65535
 203c12c:	1009883a 	mov	r4,r2
 203c130:	20394740 	call	2039474 <lwip_htons>
 203c134:	100d883a 	mov	r6,r2
 203c138:	e0bff817 	ldw	r2,-32(fp)
 203c13c:	30ffffcc 	andi	r3,r6,65535
 203c140:	19403fcc 	andi	r5,r3,255
 203c144:	10c00083 	ldbu	r3,2(r2)
 203c148:	1806703a 	and	r3,r3,zero
 203c14c:	1809883a 	mov	r4,r3
 203c150:	2807883a 	mov	r3,r5
 203c154:	20c6b03a 	or	r3,r4,r3
 203c158:	10c00085 	stb	r3,2(r2)
 203c15c:	30ffffcc 	andi	r3,r6,65535
 203c160:	1806d23a 	srli	r3,r3,8
 203c164:	197fffcc 	andi	r5,r3,65535
 203c168:	10c000c3 	ldbu	r3,3(r2)
 203c16c:	1806703a 	and	r3,r3,zero
 203c170:	1809883a 	mov	r4,r3
 203c174:	2807883a 	mov	r3,r5
 203c178:	20c6b03a 	or	r3,r4,r3
 203c17c:	10c000c5 	stb	r3,3(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
 203c180:	e0bff817 	ldw	r2,-32(fp)
 203c184:	10c00083 	ldbu	r3,2(r2)
 203c188:	108000c3 	ldbu	r2,3(r2)
 203c18c:	1004923a 	slli	r2,r2,8
 203c190:	10c4b03a 	or	r2,r2,r3
 203c194:	10bfffcc 	andi	r2,r2,65535
 203c198:	e0fff617 	ldw	r3,-40(fp)
 203c19c:	1885883a 	add	r2,r3,r2
 203c1a0:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 203c1a4:	e0bff817 	ldw	r2,-32(fp)
 203c1a8:	10c00183 	ldbu	r3,6(r2)
 203c1ac:	1806703a 	and	r3,r3,zero
 203c1b0:	10c00185 	stb	r3,6(r2)
 203c1b4:	10c001c3 	ldbu	r3,7(r2)
 203c1b8:	1806703a 	and	r3,r3,zero
 203c1bc:	10c001c5 	stb	r3,7(r2)
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 203c1c0:	d0a8010b 	ldhu	r2,-24572(gp)
 203c1c4:	10bfffcc 	andi	r2,r2,65535
 203c1c8:	1009883a 	mov	r4,r2
 203c1cc:	20394740 	call	2039474 <lwip_htons>
 203c1d0:	100d883a 	mov	r6,r2
 203c1d4:	e0bff817 	ldw	r2,-32(fp)
 203c1d8:	30ffffcc 	andi	r3,r6,65535
 203c1dc:	19403fcc 	andi	r5,r3,255
 203c1e0:	10c00103 	ldbu	r3,4(r2)
 203c1e4:	1806703a 	and	r3,r3,zero
 203c1e8:	1809883a 	mov	r4,r3
 203c1ec:	2807883a 	mov	r3,r5
 203c1f0:	20c6b03a 	or	r3,r4,r3
 203c1f4:	10c00105 	stb	r3,4(r2)
 203c1f8:	30ffffcc 	andi	r3,r6,65535
 203c1fc:	1806d23a 	srli	r3,r3,8
 203c200:	197fffcc 	andi	r5,r3,65535
 203c204:	10c00143 	ldbu	r3,5(r2)
 203c208:	1806703a 	and	r3,r3,zero
 203c20c:	1809883a 	mov	r4,r3
 203c210:	2807883a 	mov	r3,r5
 203c214:	20c6b03a 	or	r3,r4,r3
 203c218:	10c00145 	stb	r3,5(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
 203c21c:	e0bff817 	ldw	r2,-32(fp)
 203c220:	10c00103 	ldbu	r3,4(r2)
 203c224:	10800143 	ldbu	r2,5(r2)
 203c228:	1004923a 	slli	r2,r2,8
 203c22c:	10c4b03a 	or	r2,r2,r3
 203c230:	10bfffcc 	andi	r2,r2,65535
 203c234:	e0fff617 	ldw	r3,-40(fp)
 203c238:	1885883a 	add	r2,r3,r2
 203c23c:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 203c240:	d0a8010b 	ldhu	r2,-24572(gp)
 203c244:	10800044 	addi	r2,r2,1
 203c248:	d0a8010d 	sth	r2,-24572(gp)

    if (src == NULL) {
 203c24c:	e0bffb17 	ldw	r2,-20(fp)
 203c250:	1000211e 	bne	r2,zero,203c2d8 <ip4_output_if_src+0x414>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 203c254:	d0e00e17 	ldw	r3,-32712(gp)
 203c258:	e0bff817 	ldw	r2,-32(fp)
 203c25c:	19803fcc 	andi	r6,r3,255
 203c260:	11000303 	ldbu	r4,12(r2)
 203c264:	2008703a 	and	r4,r4,zero
 203c268:	200b883a 	mov	r5,r4
 203c26c:	3009883a 	mov	r4,r6
 203c270:	2908b03a 	or	r4,r5,r4
 203c274:	11000305 	stb	r4,12(r2)
 203c278:	1808d23a 	srli	r4,r3,8
 203c27c:	21803fcc 	andi	r6,r4,255
 203c280:	11000343 	ldbu	r4,13(r2)
 203c284:	2008703a 	and	r4,r4,zero
 203c288:	200b883a 	mov	r5,r4
 203c28c:	3009883a 	mov	r4,r6
 203c290:	2908b03a 	or	r4,r5,r4
 203c294:	11000345 	stb	r4,13(r2)
 203c298:	1808d43a 	srli	r4,r3,16
 203c29c:	21803fcc 	andi	r6,r4,255
 203c2a0:	11000383 	ldbu	r4,14(r2)
 203c2a4:	2008703a 	and	r4,r4,zero
 203c2a8:	200b883a 	mov	r5,r4
 203c2ac:	3009883a 	mov	r4,r6
 203c2b0:	2908b03a 	or	r4,r5,r4
 203c2b4:	11000385 	stb	r4,14(r2)
 203c2b8:	180ad63a 	srli	r5,r3,24
 203c2bc:	10c003c3 	ldbu	r3,15(r2)
 203c2c0:	1806703a 	and	r3,r3,zero
 203c2c4:	1809883a 	mov	r4,r3
 203c2c8:	2807883a 	mov	r3,r5
 203c2cc:	20c6b03a 	or	r3,r4,r3
 203c2d0:	10c003c5 	stb	r3,15(r2)
 203c2d4:	00002106 	br	203c35c <ip4_output_if_src+0x498>
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 203c2d8:	e0bffb17 	ldw	r2,-20(fp)
 203c2dc:	10c00017 	ldw	r3,0(r2)
 203c2e0:	e0bff817 	ldw	r2,-32(fp)
 203c2e4:	19803fcc 	andi	r6,r3,255
 203c2e8:	11000303 	ldbu	r4,12(r2)
 203c2ec:	2008703a 	and	r4,r4,zero
 203c2f0:	200b883a 	mov	r5,r4
 203c2f4:	3009883a 	mov	r4,r6
 203c2f8:	2908b03a 	or	r4,r5,r4
 203c2fc:	11000305 	stb	r4,12(r2)
 203c300:	1808d23a 	srli	r4,r3,8
 203c304:	21803fcc 	andi	r6,r4,255
 203c308:	11000343 	ldbu	r4,13(r2)
 203c30c:	2008703a 	and	r4,r4,zero
 203c310:	200b883a 	mov	r5,r4
 203c314:	3009883a 	mov	r4,r6
 203c318:	2908b03a 	or	r4,r5,r4
 203c31c:	11000345 	stb	r4,13(r2)
 203c320:	1808d43a 	srli	r4,r3,16
 203c324:	21803fcc 	andi	r6,r4,255
 203c328:	11000383 	ldbu	r4,14(r2)
 203c32c:	2008703a 	and	r4,r4,zero
 203c330:	200b883a 	mov	r5,r4
 203c334:	3009883a 	mov	r4,r6
 203c338:	2908b03a 	or	r4,r5,r4
 203c33c:	11000385 	stb	r4,14(r2)
 203c340:	180ad63a 	srli	r5,r3,24
 203c344:	10c003c3 	ldbu	r3,15(r2)
 203c348:	1806703a 	and	r3,r3,zero
 203c34c:	1809883a 	mov	r4,r3
 203c350:	2807883a 	mov	r3,r5
 203c354:	20c6b03a 	or	r3,r4,r3
 203c358:	10c003c5 	stb	r3,15(r2)
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 203c35c:	e0bff817 	ldw	r2,-32(fp)
 203c360:	10c00303 	ldbu	r3,12(r2)
 203c364:	11000343 	ldbu	r4,13(r2)
 203c368:	2008923a 	slli	r4,r4,8
 203c36c:	20c6b03a 	or	r3,r4,r3
 203c370:	11000383 	ldbu	r4,14(r2)
 203c374:	2008943a 	slli	r4,r4,16
 203c378:	20c6b03a 	or	r3,r4,r3
 203c37c:	108003c3 	ldbu	r2,15(r2)
 203c380:	1004963a 	slli	r2,r2,24
 203c384:	10c4b03a 	or	r2,r2,r3
 203c388:	10bfffcc 	andi	r2,r2,65535
 203c38c:	e0fff617 	ldw	r3,-40(fp)
 203c390:	1885883a 	add	r2,r3,r2
 203c394:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 203c398:	e0bff817 	ldw	r2,-32(fp)
 203c39c:	10c00303 	ldbu	r3,12(r2)
 203c3a0:	11000343 	ldbu	r4,13(r2)
 203c3a4:	2008923a 	slli	r4,r4,8
 203c3a8:	20c6b03a 	or	r3,r4,r3
 203c3ac:	11000383 	ldbu	r4,14(r2)
 203c3b0:	2008943a 	slli	r4,r4,16
 203c3b4:	20c6b03a 	or	r3,r4,r3
 203c3b8:	108003c3 	ldbu	r2,15(r2)
 203c3bc:	1004963a 	slli	r2,r2,24
 203c3c0:	10c4b03a 	or	r2,r2,r3
 203c3c4:	1004d43a 	srli	r2,r2,16
 203c3c8:	e0fff617 	ldw	r3,-40(fp)
 203c3cc:	1885883a 	add	r2,r3,r2
 203c3d0:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 203c3d4:	e0bff617 	ldw	r2,-40(fp)
 203c3d8:	1006d43a 	srli	r3,r2,16
 203c3dc:	e0bff617 	ldw	r2,-40(fp)
 203c3e0:	10bfffcc 	andi	r2,r2,65535
 203c3e4:	1885883a 	add	r2,r3,r2
 203c3e8:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + chk_sum;
 203c3ec:	e0bff617 	ldw	r2,-40(fp)
 203c3f0:	1004d43a 	srli	r2,r2,16
 203c3f4:	e0fff617 	ldw	r3,-40(fp)
 203c3f8:	1885883a 	add	r2,r3,r2
 203c3fc:	e0bff615 	stw	r2,-40(fp)
    chk_sum = ~chk_sum;
 203c400:	e0bff617 	ldw	r2,-40(fp)
 203c404:	0084303a 	nor	r2,zero,r2
 203c408:	e0bff615 	stw	r2,-40(fp)
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      iphdr->_chksum = (u16_t)chk_sum; /* network order */
 203c40c:	e0bff617 	ldw	r2,-40(fp)
 203c410:	100d883a 	mov	r6,r2
 203c414:	e0bff817 	ldw	r2,-32(fp)
 203c418:	30ffffcc 	andi	r3,r6,65535
 203c41c:	19403fcc 	andi	r5,r3,255
 203c420:	10c00283 	ldbu	r3,10(r2)
 203c424:	1806703a 	and	r3,r3,zero
 203c428:	1809883a 	mov	r4,r3
 203c42c:	2807883a 	mov	r3,r5
 203c430:	20c6b03a 	or	r3,r4,r3
 203c434:	10c00285 	stb	r3,10(r2)
 203c438:	30ffffcc 	andi	r3,r6,65535
 203c43c:	1806d23a 	srli	r3,r3,8
 203c440:	197fffcc 	andi	r5,r3,65535
 203c444:	10c002c3 	ldbu	r3,11(r2)
 203c448:	1806703a 	and	r3,r3,zero
 203c44c:	1809883a 	mov	r4,r3
 203c450:	2807883a 	mov	r3,r5
 203c454:	20c6b03a 	or	r3,r4,r3
 203c458:	10c002c5 	stb	r3,11(r2)
 203c45c:	00001f06 	br	203c4dc <ip4_output_if_src+0x618>
    }
#endif /* CHECKSUM_GEN_IP */
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    if (p->len < IP_HLEN) {
 203c460:	e0bffa17 	ldw	r2,-24(fp)
 203c464:	1080028b 	ldhu	r2,10(r2)
 203c468:	10bfffcc 	andi	r2,r2,65535
 203c46c:	10800528 	cmpgeui	r2,r2,20
 203c470:	1000091e 	bne	r2,zero,203c498 <ip4_output_if_src+0x5d4>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
      IP_STATS_INC(ip.err);
 203c474:	008085f4 	movhi	r2,535
 203c478:	10bd8204 	addi	r2,r2,-2552
 203c47c:	10802e17 	ldw	r2,184(r2)
 203c480:	10c00044 	addi	r3,r2,1
 203c484:	008085f4 	movhi	r2,535
 203c488:	10bd8204 	addi	r2,r2,-2552
 203c48c:	10c02e15 	stw	r3,184(r2)
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 203c490:	00bfff84 	movi	r2,-2
 203c494:	00002e06 	br	203c550 <ip4_output_if_src+0x68c>
    }
    iphdr = (struct ip_hdr *)p->payload;
 203c498:	e0bffa17 	ldw	r2,-24(fp)
 203c49c:	10800117 	ldw	r2,4(r2)
 203c4a0:	e0bff815 	stw	r2,-32(fp)
    ip4_addr_copy(dest_addr, iphdr->dest);
 203c4a4:	e0bff817 	ldw	r2,-32(fp)
 203c4a8:	10c00403 	ldbu	r3,16(r2)
 203c4ac:	11000443 	ldbu	r4,17(r2)
 203c4b0:	2008923a 	slli	r4,r4,8
 203c4b4:	20c6b03a 	or	r3,r4,r3
 203c4b8:	11000483 	ldbu	r4,18(r2)
 203c4bc:	2008943a 	slli	r4,r4,16
 203c4c0:	20c6b03a 	or	r3,r4,r3
 203c4c4:	108004c3 	ldbu	r2,19(r2)
 203c4c8:	1004963a 	slli	r2,r2,24
 203c4cc:	10c4b03a 	or	r2,r2,r3
 203c4d0:	e0bff915 	stw	r2,-28(fp)
    dest = &dest_addr;
 203c4d4:	e0bff904 	addi	r2,fp,-28
 203c4d8:	e0bffc15 	stw	r2,-16(fp)
  }

  IP_STATS_INC(ip.xmit);
 203c4dc:	008085f4 	movhi	r2,535
 203c4e0:	10bd8204 	addi	r2,r2,-2552
 203c4e4:	10802417 	ldw	r2,144(r2)
 203c4e8:	10c00044 	addi	r3,r2,1
 203c4ec:	008085f4 	movhi	r2,535
 203c4f0:	10bd8204 	addi	r2,r2,-2552
 203c4f4:	10c02415 	stw	r3,144(r2)
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 203c4f8:	e0800417 	ldw	r2,16(fp)
 203c4fc:	10800d0b 	ldhu	r2,52(r2)
 203c500:	10bfffcc 	andi	r2,r2,65535
 203c504:	10000c26 	beq	r2,zero,203c538 <ip4_output_if_src+0x674>
 203c508:	e0bffa17 	ldw	r2,-24(fp)
 203c50c:	1100020b 	ldhu	r4,8(r2)
 203c510:	e0800417 	ldw	r2,16(fp)
 203c514:	10c00d0b 	ldhu	r3,52(r2)
 203c518:	20bfffcc 	andi	r2,r4,65535
 203c51c:	18ffffcc 	andi	r3,r3,65535
 203c520:	1880052e 	bgeu	r3,r2,203c538 <ip4_output_if_src+0x674>
    return ip4_frag(p, netif, dest);
 203c524:	e1bffc17 	ldw	r6,-16(fp)
 203c528:	e1400417 	ldw	r5,16(fp)
 203c52c:	e13ffa17 	ldw	r4,-24(fp)
 203c530:	203da940 	call	203da94 <ip4_frag>
 203c534:	00000606 	br	203c550 <ip4_output_if_src+0x68c>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 203c538:	e0800417 	ldw	r2,16(fp)
 203c53c:	10800517 	ldw	r2,20(r2)
 203c540:	e1bffc17 	ldw	r6,-16(fp)
 203c544:	e17ffa17 	ldw	r5,-24(fp)
 203c548:	e1000417 	ldw	r4,16(fp)
 203c54c:	103ee83a 	callr	r2
}
 203c550:	e037883a 	mov	sp,fp
 203c554:	dfc00117 	ldw	ra,4(sp)
 203c558:	df000017 	ldw	fp,0(sp)
 203c55c:	dec00204 	addi	sp,sp,8
 203c560:	f800283a 	ret

0203c564 <ip4_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
           u8_t ttl, u8_t tos, u8_t proto)
{
 203c564:	defff404 	addi	sp,sp,-48
 203c568:	dfc00b15 	stw	ra,44(sp)
 203c56c:	df000a15 	stw	fp,40(sp)
 203c570:	df000a04 	addi	fp,sp,40
 203c574:	e13ffa15 	stw	r4,-24(fp)
 203c578:	e17ffb15 	stw	r5,-20(fp)
 203c57c:	e1bffc15 	stw	r6,-16(fp)
 203c580:	3809883a 	mov	r4,r7
 203c584:	e0c00217 	ldw	r3,8(fp)
 203c588:	e0800317 	ldw	r2,12(fp)
 203c58c:	e13ffd05 	stb	r4,-12(fp)
 203c590:	e0fffe05 	stb	r3,-8(fp)
 203c594:	e0bfff05 	stb	r2,-4(fp)
  struct netif *netif;

  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);

  if ((netif = ip4_route_src(src, dest)) == NULL) {
 203c598:	e13ffc17 	ldw	r4,-16(fp)
 203c59c:	203b5c40 	call	203b5c4 <ip4_route>
 203c5a0:	e0bff915 	stw	r2,-28(fp)
 203c5a4:	e0bff917 	ldw	r2,-28(fp)
 203c5a8:	1000091e 	bne	r2,zero,203c5d0 <ip4_output+0x6c>
    LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                           ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 203c5ac:	008085f4 	movhi	r2,535
 203c5b0:	10bd8204 	addi	r2,r2,-2552
 203c5b4:	10802b17 	ldw	r2,172(r2)
 203c5b8:	10c00044 	addi	r3,r2,1
 203c5bc:	008085f4 	movhi	r2,535
 203c5c0:	10bd8204 	addi	r2,r2,-2552
 203c5c4:	10c02b15 	stw	r3,172(r2)
    return ERR_RTE;
 203c5c8:	00bfff04 	movi	r2,-4
 203c5cc:	00000c06 	br	203c600 <ip4_output+0x9c>
  }

  return ip4_output_if(p, src, dest, ttl, tos, proto, netif);
 203c5d0:	e17ffd03 	ldbu	r5,-12(fp)
 203c5d4:	e0bffe03 	ldbu	r2,-8(fp)
 203c5d8:	e0ffff03 	ldbu	r3,-4(fp)
 203c5dc:	e13ff917 	ldw	r4,-28(fp)
 203c5e0:	d9000215 	stw	r4,8(sp)
 203c5e4:	d8c00115 	stw	r3,4(sp)
 203c5e8:	d8800015 	stw	r2,0(sp)
 203c5ec:	280f883a 	mov	r7,r5
 203c5f0:	e1bffc17 	ldw	r6,-16(fp)
 203c5f4:	e17ffb17 	ldw	r5,-20(fp)
 203c5f8:	e13ffa17 	ldw	r4,-24(fp)
 203c5fc:	203be1c0 	call	203be1c <ip4_output_if>
}
 203c600:	e037883a 	mov	sp,fp
 203c604:	dfc00117 	ldw	ra,4(sp)
 203c608:	df000017 	ldw	fp,0(sp)
 203c60c:	dec00204 	addi	sp,sp,8
 203c610:	f800283a 	ret

0203c614 <ip4_output_hinted>:
 *         see ip_output_if() for more return values
 */
err_t
ip4_output_hinted(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos, u8_t proto, struct netif_hint *netif_hint)
{
 203c614:	defff304 	addi	sp,sp,-52
 203c618:	dfc00c15 	stw	ra,48(sp)
 203c61c:	df000b15 	stw	fp,44(sp)
 203c620:	df000b04 	addi	fp,sp,44
 203c624:	e13ffa15 	stw	r4,-24(fp)
 203c628:	e17ffb15 	stw	r5,-20(fp)
 203c62c:	e1bffc15 	stw	r6,-16(fp)
 203c630:	3809883a 	mov	r4,r7
 203c634:	e0c00217 	ldw	r3,8(fp)
 203c638:	e0800317 	ldw	r2,12(fp)
 203c63c:	e13ffd05 	stb	r4,-12(fp)
 203c640:	e0fffe05 	stb	r3,-8(fp)
 203c644:	e0bfff05 	stb	r2,-4(fp)
  struct netif *netif;
  err_t err;

  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);

  if ((netif = ip4_route_src(src, dest)) == NULL) {
 203c648:	e13ffc17 	ldw	r4,-16(fp)
 203c64c:	203b5c40 	call	203b5c4 <ip4_route>
 203c650:	e0bff815 	stw	r2,-32(fp)
 203c654:	e0bff817 	ldw	r2,-32(fp)
 203c658:	1000091e 	bne	r2,zero,203c680 <ip4_output_hinted+0x6c>
    LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                           ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 203c65c:	008085f4 	movhi	r2,535
 203c660:	10bd8204 	addi	r2,r2,-2552
 203c664:	10802b17 	ldw	r2,172(r2)
 203c668:	10c00044 	addi	r3,r2,1
 203c66c:	008085f4 	movhi	r2,535
 203c670:	10bd8204 	addi	r2,r2,-2552
 203c674:	10c02b15 	stw	r3,172(r2)
    return ERR_RTE;
 203c678:	00bfff04 	movi	r2,-4
 203c67c:	00001306 	br	203c6cc <ip4_output_hinted+0xb8>
  }

  NETIF_SET_HINTS(netif, netif_hint);
 203c680:	e0bff817 	ldw	r2,-32(fp)
 203c684:	e0c00417 	ldw	r3,16(fp)
 203c688:	10c01215 	stw	r3,72(r2)
  err = ip4_output_if(p, src, dest, ttl, tos, proto, netif);
 203c68c:	e17ffd03 	ldbu	r5,-12(fp)
 203c690:	e0bffe03 	ldbu	r2,-8(fp)
 203c694:	e0ffff03 	ldbu	r3,-4(fp)
 203c698:	e13ff817 	ldw	r4,-32(fp)
 203c69c:	d9000215 	stw	r4,8(sp)
 203c6a0:	d8c00115 	stw	r3,4(sp)
 203c6a4:	d8800015 	stw	r2,0(sp)
 203c6a8:	280f883a 	mov	r7,r5
 203c6ac:	e1bffc17 	ldw	r6,-16(fp)
 203c6b0:	e17ffb17 	ldw	r5,-20(fp)
 203c6b4:	e13ffa17 	ldw	r4,-24(fp)
 203c6b8:	203be1c0 	call	203be1c <ip4_output_if>
 203c6bc:	e0bff905 	stb	r2,-28(fp)
  NETIF_RESET_HINTS(netif);
 203c6c0:	e0bff817 	ldw	r2,-32(fp)
 203c6c4:	10001215 	stw	zero,72(r2)

  return err;
 203c6c8:	e0bff903 	ldbu	r2,-28(fp)
}
 203c6cc:	e037883a 	mov	sp,fp
 203c6d0:	dfc00117 	ldw	ra,4(sp)
 203c6d4:	df000017 	ldw	fp,0(sp)
 203c6d8:	dec00204 	addi	sp,sp,8
 203c6dc:	f800283a 	ret

0203c6e0 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
 203c6e0:	defffb04 	addi	sp,sp,-20
 203c6e4:	dfc00415 	stw	ra,16(sp)
 203c6e8:	df000315 	stw	fp,12(sp)
 203c6ec:	df000304 	addi	fp,sp,12
  struct ip_reassdata *r, *prev = NULL;
 203c6f0:	e03ffe15 	stw	zero,-8(fp)

  r = reassdatagrams;
 203c6f4:	d0a80217 	ldw	r2,-24568(gp)
 203c6f8:	e0bffd15 	stw	r2,-12(fp)
  while (r != NULL) {
 203c6fc:	00001806 	br	203c760 <ip_reass_tmr+0x80>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 203c700:	e0bffd17 	ldw	r2,-12(fp)
 203c704:	108007c3 	ldbu	r2,31(r2)
 203c708:	10803fcc 	andi	r2,r2,255
 203c70c:	10000c26 	beq	r2,zero,203c740 <ip_reass_tmr+0x60>
      r->timer--;
 203c710:	e0bffd17 	ldw	r2,-12(fp)
 203c714:	108007c3 	ldbu	r2,31(r2)
 203c718:	10bfffc4 	addi	r2,r2,-1
 203c71c:	1007883a 	mov	r3,r2
 203c720:	e0bffd17 	ldw	r2,-12(fp)
 203c724:	10c007c5 	stb	r3,31(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n", (u16_t)r->timer));
      prev = r;
 203c728:	e0bffd17 	ldw	r2,-12(fp)
 203c72c:	e0bffe15 	stw	r2,-8(fp)
      r = r->next;
 203c730:	e0bffd17 	ldw	r2,-12(fp)
 203c734:	10800017 	ldw	r2,0(r2)
 203c738:	e0bffd15 	stw	r2,-12(fp)
 203c73c:	00000806 	br	203c760 <ip_reass_tmr+0x80>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
 203c740:	e0bffd17 	ldw	r2,-12(fp)
 203c744:	e0bfff15 	stw	r2,-4(fp)
      /* get the next pointer before freeing */
      r = r->next;
 203c748:	e0bffd17 	ldw	r2,-12(fp)
 203c74c:	10800017 	ldw	r2,0(r2)
 203c750:	e0bffd15 	stw	r2,-12(fp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
 203c754:	e17ffe17 	ldw	r5,-8(fp)
 203c758:	e13fff17 	ldw	r4,-4(fp)
 203c75c:	203c7800 	call	203c780 <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
 203c760:	e0bffd17 	ldw	r2,-12(fp)
 203c764:	103fe61e 	bne	r2,zero,203c700 <__alt_mem_mem_0+0xfd01c700>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
    }
  }
}
 203c768:	0001883a 	nop
 203c76c:	e037883a 	mov	sp,fp
 203c770:	dfc00117 	ldw	ra,4(sp)
 203c774:	df000017 	ldw	fp,0(sp)
 203c778:	dec00204 	addi	sp,sp,8
 203c77c:	f800283a 	ret

0203c780 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 203c780:	defff704 	addi	sp,sp,-36
 203c784:	dfc00815 	stw	ra,32(sp)
 203c788:	df000715 	stw	fp,28(sp)
 203c78c:	df000704 	addi	fp,sp,28
 203c790:	e13ffe15 	stw	r4,-8(fp)
 203c794:	e17fff15 	stw	r5,-4(fp)
  u16_t pbufs_freed = 0;
 203c798:	e03ff90d 	sth	zero,-28(fp)
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  MIB2_STATS_INC(mib2.ipreasmfails);
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 203c79c:	e0bffe17 	ldw	r2,-8(fp)
 203c7a0:	10800117 	ldw	r2,4(r2)
 203c7a4:	10800117 	ldw	r2,4(r2)
 203c7a8:	e0bffb15 	stw	r2,-20(fp)
  if (iprh->start == 0) {
 203c7ac:	e0bffb17 	ldw	r2,-20(fp)
 203c7b0:	10c00103 	ldbu	r3,4(r2)
 203c7b4:	10800143 	ldbu	r2,5(r2)
 203c7b8:	1004923a 	slli	r2,r2,8
 203c7bc:	10c4b03a 	or	r2,r2,r3
 203c7c0:	10bfffcc 	andi	r2,r2,65535
 203c7c4:	1000251e 	bne	r2,zero,203c85c <ip_reass_free_complete_datagram+0xdc>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
 203c7c8:	e0bffe17 	ldw	r2,-8(fp)
 203c7cc:	10800117 	ldw	r2,4(r2)
 203c7d0:	e0bffa15 	stw	r2,-24(fp)
    ipr->p = iprh->next_pbuf;
 203c7d4:	e0bffb17 	ldw	r2,-20(fp)
 203c7d8:	10c00003 	ldbu	r3,0(r2)
 203c7dc:	11000043 	ldbu	r4,1(r2)
 203c7e0:	2008923a 	slli	r4,r4,8
 203c7e4:	20c6b03a 	or	r3,r4,r3
 203c7e8:	11000083 	ldbu	r4,2(r2)
 203c7ec:	2008943a 	slli	r4,r4,16
 203c7f0:	20c6b03a 	or	r3,r4,r3
 203c7f4:	108000c3 	ldbu	r2,3(r2)
 203c7f8:	1004963a 	slli	r2,r2,24
 203c7fc:	10c4b03a 	or	r2,r2,r3
 203c800:	1007883a 	mov	r3,r2
 203c804:	e0bffe17 	ldw	r2,-8(fp)
 203c808:	10c00115 	stw	r3,4(r2)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 203c80c:	e0bffa17 	ldw	r2,-24(fp)
 203c810:	10c00117 	ldw	r3,4(r2)
 203c814:	e0bffe17 	ldw	r2,-8(fp)
 203c818:	10800204 	addi	r2,r2,8
 203c81c:	01800504 	movi	r6,20
 203c820:	100b883a 	mov	r5,r2
 203c824:	1809883a 	mov	r4,r3
 203c828:	2005e580 	call	2005e58 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 203c82c:	01400044 	movi	r5,1
 203c830:	e13ffa17 	ldw	r4,-24(fp)
 203c834:	203b3800 	call	203b380 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 203c838:	e13ffa17 	ldw	r4,-24(fp)
 203c83c:	201d42c0 	call	201d42c <pbuf_clen>
 203c840:	e0bffc0d 	sth	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed = (u16_t)(pbufs_freed + clen);
 203c844:	e0fff90b 	ldhu	r3,-28(fp)
 203c848:	e0bffc0b 	ldhu	r2,-16(fp)
 203c84c:	1885883a 	add	r2,r3,r2
 203c850:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(p);
 203c854:	e13ffa17 	ldw	r4,-24(fp)
 203c858:	201d2f40 	call	201d2f4 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released
     separately as they have not yet been chained */
  p = ipr->p;
 203c85c:	e0bffe17 	ldw	r2,-8(fp)
 203c860:	10800117 	ldw	r2,4(r2)
 203c864:	e0bffa15 	stw	r2,-24(fp)
  while (p != NULL) {
 203c868:	00001a06 	br	203c8d4 <ip_reass_free_complete_datagram+0x154>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 203c86c:	e0bffa17 	ldw	r2,-24(fp)
 203c870:	10800117 	ldw	r2,4(r2)
 203c874:	e0bffb15 	stw	r2,-20(fp)
    pcur = p;
 203c878:	e0bffa17 	ldw	r2,-24(fp)
 203c87c:	e0bffd15 	stw	r2,-12(fp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 203c880:	e0bffb17 	ldw	r2,-20(fp)
 203c884:	10c00003 	ldbu	r3,0(r2)
 203c888:	11000043 	ldbu	r4,1(r2)
 203c88c:	2008923a 	slli	r4,r4,8
 203c890:	20c6b03a 	or	r3,r4,r3
 203c894:	11000083 	ldbu	r4,2(r2)
 203c898:	2008943a 	slli	r4,r4,16
 203c89c:	20c6b03a 	or	r3,r4,r3
 203c8a0:	108000c3 	ldbu	r2,3(r2)
 203c8a4:	1004963a 	slli	r2,r2,24
 203c8a8:	10c4b03a 	or	r2,r2,r3
 203c8ac:	e0bffa15 	stw	r2,-24(fp)
    clen = pbuf_clen(pcur);
 203c8b0:	e13ffd17 	ldw	r4,-12(fp)
 203c8b4:	201d42c0 	call	201d42c <pbuf_clen>
 203c8b8:	e0bffc0d 	sth	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed = (u16_t)(pbufs_freed + clen);
 203c8bc:	e0fff90b 	ldhu	r3,-28(fp)
 203c8c0:	e0bffc0b 	ldhu	r2,-16(fp)
 203c8c4:	1885883a 	add	r2,r3,r2
 203c8c8:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(pcur);
 203c8cc:	e13ffd17 	ldw	r4,-12(fp)
 203c8d0:	201d2f40 	call	201d2f4 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 203c8d4:	e0bffa17 	ldw	r2,-24(fp)
 203c8d8:	103fe41e 	bne	r2,zero,203c86c <__alt_mem_mem_0+0xfd01c86c>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed = (u16_t)(pbufs_freed + clen);
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 203c8dc:	e17fff17 	ldw	r5,-4(fp)
 203c8e0:	e13ffe17 	ldw	r4,-8(fp)
 203c8e4:	203cb900 	call	203cb90 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 203c8e8:	d0e8030b 	ldhu	r3,-24564(gp)
 203c8ec:	e0bff90b 	ldhu	r2,-28(fp)
 203c8f0:	1885c83a 	sub	r2,r3,r2
 203c8f4:	d0a8030d 	sth	r2,-24564(gp)

  return pbufs_freed;
 203c8f8:	e0bff90b 	ldhu	r2,-28(fp)
}
 203c8fc:	e037883a 	mov	sp,fp
 203c900:	dfc00117 	ldw	ra,4(sp)
 203c904:	df000017 	ldw	fp,0(sp)
 203c908:	dec00204 	addi	sp,sp,8
 203c90c:	f800283a 	ret

0203c910 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 203c910:	defff504 	addi	sp,sp,-44
 203c914:	dfc00a15 	stw	ra,40(sp)
 203c918:	df000915 	stw	fp,36(sp)
 203c91c:	df000904 	addi	fp,sp,36
 203c920:	e13ffe15 	stw	r4,-8(fp)
 203c924:	e17fff15 	stw	r5,-4(fp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev, *oldest_prev;
  int pbufs_freed = 0, pbufs_freed_current;
 203c928:	e03ffb15 	stw	zero,-20(fp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
 203c92c:	e03ff815 	stw	zero,-32(fp)
    prev = NULL;
 203c930:	e03ff915 	stw	zero,-28(fp)
    oldest_prev = NULL;
 203c934:	e03ffa15 	stw	zero,-24(fp)
    other_datagrams = 0;
 203c938:	e03ffc15 	stw	zero,-16(fp)
    r = reassdatagrams;
 203c93c:	d0a80217 	ldw	r2,-24568(gp)
 203c940:	e0bff715 	stw	r2,-36(fp)
    while (r != NULL) {
 203c944:	00004306 	br	203ca54 <ip_reass_remove_oldest_datagram+0x144>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 203c948:	e0bff717 	ldw	r2,-36(fp)
 203c94c:	10c00517 	ldw	r3,20(r2)
 203c950:	e0bffe17 	ldw	r2,-8(fp)
 203c954:	11000303 	ldbu	r4,12(r2)
 203c958:	11400343 	ldbu	r5,13(r2)
 203c95c:	280a923a 	slli	r5,r5,8
 203c960:	2908b03a 	or	r4,r5,r4
 203c964:	11400383 	ldbu	r5,14(r2)
 203c968:	280a943a 	slli	r5,r5,16
 203c96c:	2908b03a 	or	r4,r5,r4
 203c970:	108003c3 	ldbu	r2,15(r2)
 203c974:	1004963a 	slli	r2,r2,24
 203c978:	1104b03a 	or	r2,r2,r4
 203c97c:	1880181e 	bne	r3,r2,203c9e0 <ip_reass_remove_oldest_datagram+0xd0>
 203c980:	e0bff717 	ldw	r2,-36(fp)
 203c984:	10c00617 	ldw	r3,24(r2)
 203c988:	e0bffe17 	ldw	r2,-8(fp)
 203c98c:	11000403 	ldbu	r4,16(r2)
 203c990:	11400443 	ldbu	r5,17(r2)
 203c994:	280a923a 	slli	r5,r5,8
 203c998:	2908b03a 	or	r4,r5,r4
 203c99c:	11400483 	ldbu	r5,18(r2)
 203c9a0:	280a943a 	slli	r5,r5,16
 203c9a4:	2908b03a 	or	r4,r5,r4
 203c9a8:	108004c3 	ldbu	r2,19(r2)
 203c9ac:	1004963a 	slli	r2,r2,24
 203c9b0:	1104b03a 	or	r2,r2,r4
 203c9b4:	18800a1e 	bne	r3,r2,203c9e0 <ip_reass_remove_oldest_datagram+0xd0>
 203c9b8:	e0bff717 	ldw	r2,-36(fp)
 203c9bc:	1100030b 	ldhu	r4,12(r2)
 203c9c0:	e0bffe17 	ldw	r2,-8(fp)
 203c9c4:	10c00103 	ldbu	r3,4(r2)
 203c9c8:	10800143 	ldbu	r2,5(r2)
 203c9cc:	1004923a 	slli	r2,r2,8
 203c9d0:	10c4b03a 	or	r2,r2,r3
 203c9d4:	20ffffcc 	andi	r3,r4,65535
 203c9d8:	10bfffcc 	andi	r2,r2,65535
 203c9dc:	18801526 	beq	r3,r2,203ca34 <ip_reass_remove_oldest_datagram+0x124>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 203c9e0:	e0bffc17 	ldw	r2,-16(fp)
 203c9e4:	10800044 	addi	r2,r2,1
 203c9e8:	e0bffc15 	stw	r2,-16(fp)
        if (oldest == NULL) {
 203c9ec:	e0bff817 	ldw	r2,-32(fp)
 203c9f0:	1000051e 	bne	r2,zero,203ca08 <ip_reass_remove_oldest_datagram+0xf8>
          oldest = r;
 203c9f4:	e0bff717 	ldw	r2,-36(fp)
 203c9f8:	e0bff815 	stw	r2,-32(fp)
          oldest_prev = prev;
 203c9fc:	e0bff917 	ldw	r2,-28(fp)
 203ca00:	e0bffa15 	stw	r2,-24(fp)
 203ca04:	00000b06 	br	203ca34 <ip_reass_remove_oldest_datagram+0x124>
        } else if (r->timer <= oldest->timer) {
 203ca08:	e0bff717 	ldw	r2,-36(fp)
 203ca0c:	110007c3 	ldbu	r4,31(r2)
 203ca10:	e0bff817 	ldw	r2,-32(fp)
 203ca14:	10c007c3 	ldbu	r3,31(r2)
 203ca18:	20803fcc 	andi	r2,r4,255
 203ca1c:	18c03fcc 	andi	r3,r3,255
 203ca20:	18800436 	bltu	r3,r2,203ca34 <ip_reass_remove_oldest_datagram+0x124>
          /* older than the previous oldest */
          oldest = r;
 203ca24:	e0bff717 	ldw	r2,-36(fp)
 203ca28:	e0bff815 	stw	r2,-32(fp)
          oldest_prev = prev;
 203ca2c:	e0bff917 	ldw	r2,-28(fp)
 203ca30:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (r->next != NULL) {
 203ca34:	e0bff717 	ldw	r2,-36(fp)
 203ca38:	10800017 	ldw	r2,0(r2)
 203ca3c:	10000226 	beq	r2,zero,203ca48 <ip_reass_remove_oldest_datagram+0x138>
        prev = r;
 203ca40:	e0bff717 	ldw	r2,-36(fp)
 203ca44:	e0bff915 	stw	r2,-28(fp)
      }
      r = r->next;
 203ca48:	e0bff717 	ldw	r2,-36(fp)
 203ca4c:	10800017 	ldw	r2,0(r2)
 203ca50:	e0bff715 	stw	r2,-36(fp)
    oldest = NULL;
    prev = NULL;
    oldest_prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
 203ca54:	e0bff717 	ldw	r2,-36(fp)
 203ca58:	103fbb1e 	bne	r2,zero,203c948 <__alt_mem_mem_0+0xfd01c948>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
 203ca5c:	e0bff817 	ldw	r2,-32(fp)
 203ca60:	10000826 	beq	r2,zero,203ca84 <ip_reass_remove_oldest_datagram+0x174>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 203ca64:	e17ffa17 	ldw	r5,-24(fp)
 203ca68:	e13ff817 	ldw	r4,-32(fp)
 203ca6c:	203c7800 	call	203c780 <ip_reass_free_complete_datagram>
 203ca70:	e0bffd15 	stw	r2,-12(fp)
      pbufs_freed += pbufs_freed_current;
 203ca74:	e0fffb17 	ldw	r3,-20(fp)
 203ca78:	e0bffd17 	ldw	r2,-12(fp)
 203ca7c:	1885883a 	add	r2,r3,r2
 203ca80:	e0bffb15 	stw	r2,-20(fp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 203ca84:	e0fffb17 	ldw	r3,-20(fp)
 203ca88:	e0bfff17 	ldw	r2,-4(fp)
 203ca8c:	1880030e 	bge	r3,r2,203ca9c <ip_reass_remove_oldest_datagram+0x18c>
 203ca90:	e0bffc17 	ldw	r2,-16(fp)
 203ca94:	10800088 	cmpgei	r2,r2,2
 203ca98:	103fa41e 	bne	r2,zero,203c92c <__alt_mem_mem_0+0xfd01c92c>
  return pbufs_freed;
 203ca9c:	e0bffb17 	ldw	r2,-20(fp)
}
 203caa0:	e037883a 	mov	sp,fp
 203caa4:	dfc00117 	ldw	ra,4(sp)
 203caa8:	df000017 	ldw	fp,0(sp)
 203caac:	dec00204 	addi	sp,sp,8
 203cab0:	f800283a 	ret

0203cab4 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata *
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
 203cab4:	defffb04 	addi	sp,sp,-20
 203cab8:	dfc00415 	stw	ra,16(sp)
 203cabc:	df000315 	stw	fp,12(sp)
 203cac0:	df000304 	addi	fp,sp,12
 203cac4:	e13ffe15 	stw	r4,-8(fp)
 203cac8:	e17fff15 	stw	r5,-4(fp)
#if ! IP_REASS_FREE_OLDEST
  LWIP_UNUSED_ARG(clen);
#endif

  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 203cacc:	01000144 	movi	r4,5
 203cad0:	201b82c0 	call	201b82c <memp_malloc>
 203cad4:	e0bffd15 	stw	r2,-12(fp)
  if (ipr == NULL) {
 203cad8:	e0bffd17 	ldw	r2,-12(fp)
 203cadc:	1000141e 	bne	r2,zero,203cb30 <ip_reass_enqueue_new_datagram+0x7c>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 203cae0:	e17fff17 	ldw	r5,-4(fp)
 203cae4:	e13ffe17 	ldw	r4,-8(fp)
 203cae8:	203c9100 	call	203c910 <ip_reass_remove_oldest_datagram>
 203caec:	1007883a 	mov	r3,r2
 203caf0:	e0bfff17 	ldw	r2,-4(fp)
 203caf4:	18800316 	blt	r3,r2,203cb04 <ip_reass_enqueue_new_datagram+0x50>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 203caf8:	01000144 	movi	r4,5
 203cafc:	201b82c0 	call	201b82c <memp_malloc>
 203cb00:	e0bffd15 	stw	r2,-12(fp)
    }
    if (ipr == NULL)
 203cb04:	e0bffd17 	ldw	r2,-12(fp)
 203cb08:	1000091e 	bne	r2,zero,203cb30 <ip_reass_enqueue_new_datagram+0x7c>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
 203cb0c:	008085f4 	movhi	r2,535
 203cb10:	10bd8204 	addi	r2,r2,-2552
 203cb14:	10801e17 	ldw	r2,120(r2)
 203cb18:	10c00044 	addi	r3,r2,1
 203cb1c:	008085f4 	movhi	r2,535
 203cb20:	10bd8204 	addi	r2,r2,-2552
 203cb24:	10c01e15 	stw	r3,120(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("Failed to alloc reassdata struct\n"));
      return NULL;
 203cb28:	0005883a 	mov	r2,zero
 203cb2c:	00001306 	br	203cb7c <ip_reass_enqueue_new_datagram+0xc8>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 203cb30:	01800804 	movi	r6,32
 203cb34:	000b883a 	mov	r5,zero
 203cb38:	e13ffd17 	ldw	r4,-12(fp)
 203cb3c:	2005fa00 	call	2005fa0 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 203cb40:	e0bffd17 	ldw	r2,-12(fp)
 203cb44:	00c000c4 	movi	r3,3
 203cb48:	10c007c5 	stb	r3,31(r2)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 203cb4c:	d0e80217 	ldw	r3,-24568(gp)
 203cb50:	e0bffd17 	ldw	r2,-12(fp)
 203cb54:	10c00015 	stw	r3,0(r2)
  reassdatagrams = ipr;
 203cb58:	e0bffd17 	ldw	r2,-12(fp)
 203cb5c:	d0a80215 	stw	r2,-24568(gp)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 203cb60:	e0bffd17 	ldw	r2,-12(fp)
 203cb64:	10800204 	addi	r2,r2,8
 203cb68:	01800504 	movi	r6,20
 203cb6c:	e17ffe17 	ldw	r5,-8(fp)
 203cb70:	1009883a 	mov	r4,r2
 203cb74:	2005e580 	call	2005e58 <memcpy>
  return ipr;
 203cb78:	e0bffd17 	ldw	r2,-12(fp)
}
 203cb7c:	e037883a 	mov	sp,fp
 203cb80:	dfc00117 	ldw	ra,4(sp)
 203cb84:	df000017 	ldw	fp,0(sp)
 203cb88:	dec00204 	addi	sp,sp,8
 203cb8c:	f800283a 	ret

0203cb90 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 203cb90:	defffc04 	addi	sp,sp,-16
 203cb94:	dfc00315 	stw	ra,12(sp)
 203cb98:	df000215 	stw	fp,8(sp)
 203cb9c:	df000204 	addi	fp,sp,8
 203cba0:	e13ffe15 	stw	r4,-8(fp)
 203cba4:	e17fff15 	stw	r5,-4(fp)
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 203cba8:	d0e80217 	ldw	r3,-24568(gp)
 203cbac:	e0bffe17 	ldw	r2,-8(fp)
 203cbb0:	1880041e 	bne	r3,r2,203cbc4 <ip_reass_dequeue_datagram+0x34>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 203cbb4:	e0bffe17 	ldw	r2,-8(fp)
 203cbb8:	10800017 	ldw	r2,0(r2)
 203cbbc:	d0a80215 	stw	r2,-24568(gp)
 203cbc0:	00000406 	br	203cbd4 <ip_reass_dequeue_datagram+0x44>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 203cbc4:	e0bffe17 	ldw	r2,-8(fp)
 203cbc8:	10c00017 	ldw	r3,0(r2)
 203cbcc:	e0bfff17 	ldw	r2,-4(fp)
 203cbd0:	10c00015 	stw	r3,0(r2)
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
 203cbd4:	e17ffe17 	ldw	r5,-8(fp)
 203cbd8:	01000144 	movi	r4,5
 203cbdc:	201b9640 	call	201b964 <memp_free>
}
 203cbe0:	0001883a 	nop
 203cbe4:	e037883a 	mov	sp,fp
 203cbe8:	dfc00117 	ldw	ra,4(sp)
 203cbec:	df000017 	ldw	fp,0(sp)
 203cbf0:	dec00204 	addi	sp,sp,8
 203cbf4:	f800283a 	ret

0203cbf8 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param is_last is 1 if this pbuf has MF==0 (ipr->flags not updated yet)
 * @return see IP_REASS_VALIDATE_* defines
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p, int is_last)
{
 203cbf8:	defff304 	addi	sp,sp,-52
 203cbfc:	dfc00c15 	stw	ra,48(sp)
 203cc00:	df000b15 	stw	fp,44(sp)
 203cc04:	df000b04 	addi	fp,sp,44
 203cc08:	e13ffd15 	stw	r4,-12(fp)
 203cc0c:	e17ffe15 	stw	r5,-8(fp)
 203cc10:	e1bfff15 	stw	r6,-4(fp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev = NULL;
 203cc14:	e03ff515 	stw	zero,-44(fp)
  struct pbuf *q;
  u16_t offset, len;
  u8_t hlen;
  struct ip_hdr *fraghdr;
  int valid = 1;
 203cc18:	00800044 	movi	r2,1
 203cc1c:	e0bff715 	stw	r2,-36(fp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr *)new_p->payload;
 203cc20:	e0bffe17 	ldw	r2,-8(fp)
 203cc24:	10800117 	ldw	r2,4(r2)
 203cc28:	e0bff815 	stw	r2,-32(fp)
  len = lwip_ntohs(IPH_LEN(fraghdr));
 203cc2c:	e0bff817 	ldw	r2,-32(fp)
 203cc30:	10c00083 	ldbu	r3,2(r2)
 203cc34:	108000c3 	ldbu	r2,3(r2)
 203cc38:	1004923a 	slli	r2,r2,8
 203cc3c:	10c4b03a 	or	r2,r2,r3
 203cc40:	10bfffcc 	andi	r2,r2,65535
 203cc44:	1009883a 	mov	r4,r2
 203cc48:	20394740 	call	2039474 <lwip_htons>
 203cc4c:	e0bff90d 	sth	r2,-28(fp)
  hlen = IPH_HL_BYTES(fraghdr);
 203cc50:	e0bff817 	ldw	r2,-32(fp)
 203cc54:	10800003 	ldbu	r2,0(r2)
 203cc58:	108003cc 	andi	r2,r2,15
 203cc5c:	1085883a 	add	r2,r2,r2
 203cc60:	1085883a 	add	r2,r2,r2
 203cc64:	e0bff985 	stb	r2,-26(fp)
  if (hlen > len) {
 203cc68:	e0bff983 	ldbu	r2,-26(fp)
 203cc6c:	10bfffcc 	andi	r2,r2,65535
 203cc70:	e0fff90b 	ldhu	r3,-28(fp)
 203cc74:	1880022e 	bgeu	r3,r2,203cc80 <ip_reass_chain_frag_into_datagram_and_validate+0x88>
    /* invalid datagram */
    return IP_REASS_VALIDATE_PBUF_DROPPED;
 203cc78:	00bfffc4 	movi	r2,-1
 203cc7c:	0001bd06 	br	203d374 <ip_reass_chain_frag_into_datagram_and_validate+0x77c>
  }
  len = (u16_t)(len - hlen);
 203cc80:	e0bff983 	ldbu	r2,-26(fp)
 203cc84:	e0fff90b 	ldhu	r3,-28(fp)
 203cc88:	1885c83a 	sub	r2,r3,r2
 203cc8c:	e0bff90d 	sth	r2,-28(fp)
  offset = IPH_OFFSET_BYTES(fraghdr);
 203cc90:	e0bff817 	ldw	r2,-32(fp)
 203cc94:	10c00183 	ldbu	r3,6(r2)
 203cc98:	108001c3 	ldbu	r2,7(r2)
 203cc9c:	1004923a 	slli	r2,r2,8
 203cca0:	10c4b03a 	or	r2,r2,r3
 203cca4:	10bfffcc 	andi	r2,r2,65535
 203cca8:	1009883a 	mov	r4,r2
 203ccac:	20394740 	call	2039474 <lwip_htons>
 203ccb0:	1087ffcc 	andi	r2,r2,8191
 203ccb4:	100490fa 	slli	r2,r2,3
 203ccb8:	e0bffa0d 	sth	r2,-24(fp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper *)new_p->payload;
 203ccbc:	e0bffe17 	ldw	r2,-8(fp)
 203ccc0:	10800117 	ldw	r2,4(r2)
 203ccc4:	e0bffb15 	stw	r2,-20(fp)
  iprh->next_pbuf = NULL;
 203ccc8:	e0bffb17 	ldw	r2,-20(fp)
 203cccc:	10c00003 	ldbu	r3,0(r2)
 203ccd0:	1806703a 	and	r3,r3,zero
 203ccd4:	10c00005 	stb	r3,0(r2)
 203ccd8:	10c00043 	ldbu	r3,1(r2)
 203ccdc:	1806703a 	and	r3,r3,zero
 203cce0:	10c00045 	stb	r3,1(r2)
 203cce4:	10c00083 	ldbu	r3,2(r2)
 203cce8:	1806703a 	and	r3,r3,zero
 203ccec:	10c00085 	stb	r3,2(r2)
 203ccf0:	10c000c3 	ldbu	r3,3(r2)
 203ccf4:	1806703a 	and	r3,r3,zero
 203ccf8:	10c000c5 	stb	r3,3(r2)
  iprh->start = offset;
 203ccfc:	e0bffb17 	ldw	r2,-20(fp)
 203cd00:	e0fffa0b 	ldhu	r3,-24(fp)
 203cd04:	19403fcc 	andi	r5,r3,255
 203cd08:	10c00103 	ldbu	r3,4(r2)
 203cd0c:	1806703a 	and	r3,r3,zero
 203cd10:	1809883a 	mov	r4,r3
 203cd14:	2807883a 	mov	r3,r5
 203cd18:	20c6b03a 	or	r3,r4,r3
 203cd1c:	10c00105 	stb	r3,4(r2)
 203cd20:	e0fffa0b 	ldhu	r3,-24(fp)
 203cd24:	1806d23a 	srli	r3,r3,8
 203cd28:	197fffcc 	andi	r5,r3,65535
 203cd2c:	10c00143 	ldbu	r3,5(r2)
 203cd30:	1806703a 	and	r3,r3,zero
 203cd34:	1809883a 	mov	r4,r3
 203cd38:	2807883a 	mov	r3,r5
 203cd3c:	20c6b03a 	or	r3,r4,r3
 203cd40:	10c00145 	stb	r3,5(r2)
  iprh->end = (u16_t)(offset + len);
 203cd44:	e0fffa0b 	ldhu	r3,-24(fp)
 203cd48:	e0bff90b 	ldhu	r2,-28(fp)
 203cd4c:	1885883a 	add	r2,r3,r2
 203cd50:	100d883a 	mov	r6,r2
 203cd54:	e0bffb17 	ldw	r2,-20(fp)
 203cd58:	30ffffcc 	andi	r3,r6,65535
 203cd5c:	19403fcc 	andi	r5,r3,255
 203cd60:	10c00183 	ldbu	r3,6(r2)
 203cd64:	1806703a 	and	r3,r3,zero
 203cd68:	1809883a 	mov	r4,r3
 203cd6c:	2807883a 	mov	r3,r5
 203cd70:	20c6b03a 	or	r3,r4,r3
 203cd74:	10c00185 	stb	r3,6(r2)
 203cd78:	30ffffcc 	andi	r3,r6,65535
 203cd7c:	1806d23a 	srli	r3,r3,8
 203cd80:	197fffcc 	andi	r5,r3,65535
 203cd84:	10c001c3 	ldbu	r3,7(r2)
 203cd88:	1806703a 	and	r3,r3,zero
 203cd8c:	1809883a 	mov	r4,r3
 203cd90:	2807883a 	mov	r3,r5
 203cd94:	20c6b03a 	or	r3,r4,r3
 203cd98:	10c001c5 	stb	r3,7(r2)
  if (iprh->end < offset) {
 203cd9c:	e0bffb17 	ldw	r2,-20(fp)
 203cda0:	10c00183 	ldbu	r3,6(r2)
 203cda4:	108001c3 	ldbu	r2,7(r2)
 203cda8:	1004923a 	slli	r2,r2,8
 203cdac:	10c4b03a 	or	r2,r2,r3
 203cdb0:	10ffffcc 	andi	r3,r2,65535
 203cdb4:	e0bffa0b 	ldhu	r2,-24(fp)
 203cdb8:	1880022e 	bgeu	r3,r2,203cdc4 <ip_reass_chain_frag_into_datagram_and_validate+0x1cc>
    /* u16_t overflow, cannot handle this */
    return IP_REASS_VALIDATE_PBUF_DROPPED;
 203cdbc:	00bfffc4 	movi	r2,-1
 203cdc0:	00016c06 	br	203d374 <ip_reass_chain_frag_into_datagram_and_validate+0x77c>
  }

  /* Iterate through until we either get to the end of the list (append),
   * or we find one with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 203cdc4:	e0bffd17 	ldw	r2,-12(fp)
 203cdc8:	10800117 	ldw	r2,4(r2)
 203cdcc:	e0bff615 	stw	r2,-40(fp)
 203cdd0:	0000dc06 	br	203d144 <ip_reass_chain_frag_into_datagram_and_validate+0x54c>
    iprh_tmp = (struct ip_reass_helper *)q->payload;
 203cdd4:	e0bff617 	ldw	r2,-40(fp)
 203cdd8:	10800117 	ldw	r2,4(r2)
 203cddc:	e0bffc15 	stw	r2,-16(fp)
    if (iprh->start < iprh_tmp->start) {
 203cde0:	e0bffb17 	ldw	r2,-20(fp)
 203cde4:	10c00103 	ldbu	r3,4(r2)
 203cde8:	10800143 	ldbu	r2,5(r2)
 203cdec:	1004923a 	slli	r2,r2,8
 203cdf0:	10c4b03a 	or	r2,r2,r3
 203cdf4:	1009883a 	mov	r4,r2
 203cdf8:	e0bffc17 	ldw	r2,-16(fp)
 203cdfc:	10c00103 	ldbu	r3,4(r2)
 203ce00:	10800143 	ldbu	r2,5(r2)
 203ce04:	1004923a 	slli	r2,r2,8
 203ce08:	10c4b03a 	or	r2,r2,r3
 203ce0c:	20ffffcc 	andi	r3,r4,65535
 203ce10:	10bfffcc 	andi	r2,r2,65535
 203ce14:	18808c2e 	bgeu	r3,r2,203d048 <ip_reass_chain_frag_into_datagram_and_validate+0x450>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 203ce18:	e0bffb17 	ldw	r2,-20(fp)
 203ce1c:	e0fff617 	ldw	r3,-40(fp)
 203ce20:	19403fcc 	andi	r5,r3,255
 203ce24:	10c00003 	ldbu	r3,0(r2)
 203ce28:	1806703a 	and	r3,r3,zero
 203ce2c:	1809883a 	mov	r4,r3
 203ce30:	2807883a 	mov	r3,r5
 203ce34:	20c6b03a 	or	r3,r4,r3
 203ce38:	10c00005 	stb	r3,0(r2)
 203ce3c:	e0fff617 	ldw	r3,-40(fp)
 203ce40:	1806d23a 	srli	r3,r3,8
 203ce44:	19403fcc 	andi	r5,r3,255
 203ce48:	10c00043 	ldbu	r3,1(r2)
 203ce4c:	1806703a 	and	r3,r3,zero
 203ce50:	1809883a 	mov	r4,r3
 203ce54:	2807883a 	mov	r3,r5
 203ce58:	20c6b03a 	or	r3,r4,r3
 203ce5c:	10c00045 	stb	r3,1(r2)
 203ce60:	e0fff617 	ldw	r3,-40(fp)
 203ce64:	1806d43a 	srli	r3,r3,16
 203ce68:	19403fcc 	andi	r5,r3,255
 203ce6c:	10c00083 	ldbu	r3,2(r2)
 203ce70:	1806703a 	and	r3,r3,zero
 203ce74:	1809883a 	mov	r4,r3
 203ce78:	2807883a 	mov	r3,r5
 203ce7c:	20c6b03a 	or	r3,r4,r3
 203ce80:	10c00085 	stb	r3,2(r2)
 203ce84:	e0fff617 	ldw	r3,-40(fp)
 203ce88:	180ad63a 	srli	r5,r3,24
 203ce8c:	10c000c3 	ldbu	r3,3(r2)
 203ce90:	1806703a 	and	r3,r3,zero
 203ce94:	1809883a 	mov	r4,r3
 203ce98:	2807883a 	mov	r3,r5
 203ce9c:	20c6b03a 	or	r3,r4,r3
 203cea0:	10c000c5 	stb	r3,3(r2)
      if (iprh_prev != NULL) {
 203cea4:	e0bff517 	ldw	r2,-44(fp)
 203cea8:	10005226 	beq	r2,zero,203cff4 <ip_reass_chain_frag_into_datagram_and_validate+0x3fc>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 203ceac:	e0bffb17 	ldw	r2,-20(fp)
 203ceb0:	10c00103 	ldbu	r3,4(r2)
 203ceb4:	10800143 	ldbu	r2,5(r2)
 203ceb8:	1004923a 	slli	r2,r2,8
 203cebc:	10c4b03a 	or	r2,r2,r3
 203cec0:	1009883a 	mov	r4,r2
 203cec4:	e0bff517 	ldw	r2,-44(fp)
 203cec8:	10c00183 	ldbu	r3,6(r2)
 203cecc:	108001c3 	ldbu	r2,7(r2)
 203ced0:	1004923a 	slli	r2,r2,8
 203ced4:	10c4b03a 	or	r2,r2,r3
 203ced8:	20ffffcc 	andi	r3,r4,65535
 203cedc:	10bfffcc 	andi	r2,r2,65535
 203cee0:	18800f36 	bltu	r3,r2,203cf20 <ip_reass_chain_frag_into_datagram_and_validate+0x328>
 203cee4:	e0bffb17 	ldw	r2,-20(fp)
 203cee8:	10c00183 	ldbu	r3,6(r2)
 203ceec:	108001c3 	ldbu	r2,7(r2)
 203cef0:	1004923a 	slli	r2,r2,8
 203cef4:	10c4b03a 	or	r2,r2,r3
 203cef8:	1009883a 	mov	r4,r2
 203cefc:	e0bffc17 	ldw	r2,-16(fp)
 203cf00:	10c00103 	ldbu	r3,4(r2)
 203cf04:	10800143 	ldbu	r2,5(r2)
 203cf08:	1004923a 	slli	r2,r2,8
 203cf0c:	10c4b03a 	or	r2,r2,r3
 203cf10:	1007883a 	mov	r3,r2
 203cf14:	20bfffcc 	andi	r2,r4,65535
 203cf18:	18ffffcc 	andi	r3,r3,65535
 203cf1c:	1880022e 	bgeu	r3,r2,203cf28 <ip_reass_chain_frag_into_datagram_and_validate+0x330>
          /* fragment overlaps with previous or following, throw away */
          return IP_REASS_VALIDATE_PBUF_DROPPED;
 203cf20:	00bfffc4 	movi	r2,-1
 203cf24:	00011306 	br	203d374 <ip_reass_chain_frag_into_datagram_and_validate+0x77c>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 203cf28:	e0bff517 	ldw	r2,-44(fp)
 203cf2c:	e0fffe17 	ldw	r3,-8(fp)
 203cf30:	19403fcc 	andi	r5,r3,255
 203cf34:	10c00003 	ldbu	r3,0(r2)
 203cf38:	1806703a 	and	r3,r3,zero
 203cf3c:	1809883a 	mov	r4,r3
 203cf40:	2807883a 	mov	r3,r5
 203cf44:	20c6b03a 	or	r3,r4,r3
 203cf48:	10c00005 	stb	r3,0(r2)
 203cf4c:	e0fffe17 	ldw	r3,-8(fp)
 203cf50:	1806d23a 	srli	r3,r3,8
 203cf54:	19403fcc 	andi	r5,r3,255
 203cf58:	10c00043 	ldbu	r3,1(r2)
 203cf5c:	1806703a 	and	r3,r3,zero
 203cf60:	1809883a 	mov	r4,r3
 203cf64:	2807883a 	mov	r3,r5
 203cf68:	20c6b03a 	or	r3,r4,r3
 203cf6c:	10c00045 	stb	r3,1(r2)
 203cf70:	e0fffe17 	ldw	r3,-8(fp)
 203cf74:	1806d43a 	srli	r3,r3,16
 203cf78:	19403fcc 	andi	r5,r3,255
 203cf7c:	10c00083 	ldbu	r3,2(r2)
 203cf80:	1806703a 	and	r3,r3,zero
 203cf84:	1809883a 	mov	r4,r3
 203cf88:	2807883a 	mov	r3,r5
 203cf8c:	20c6b03a 	or	r3,r4,r3
 203cf90:	10c00085 	stb	r3,2(r2)
 203cf94:	e0fffe17 	ldw	r3,-8(fp)
 203cf98:	180ad63a 	srli	r5,r3,24
 203cf9c:	10c000c3 	ldbu	r3,3(r2)
 203cfa0:	1806703a 	and	r3,r3,zero
 203cfa4:	1809883a 	mov	r4,r3
 203cfa8:	2807883a 	mov	r3,r5
 203cfac:	20c6b03a 	or	r3,r4,r3
 203cfb0:	10c000c5 	stb	r3,3(r2)
        if (iprh_prev->end != iprh->start) {
 203cfb4:	e0bff517 	ldw	r2,-44(fp)
 203cfb8:	10c00183 	ldbu	r3,6(r2)
 203cfbc:	108001c3 	ldbu	r2,7(r2)
 203cfc0:	1004923a 	slli	r2,r2,8
 203cfc4:	10c4b03a 	or	r2,r2,r3
 203cfc8:	1009883a 	mov	r4,r2
 203cfcc:	e0bffb17 	ldw	r2,-20(fp)
 203cfd0:	10c00103 	ldbu	r3,4(r2)
 203cfd4:	10800143 	ldbu	r2,5(r2)
 203cfd8:	1004923a 	slli	r2,r2,8
 203cfdc:	10c4b03a 	or	r2,r2,r3
 203cfe0:	20ffffcc 	andi	r3,r4,65535
 203cfe4:	10bfffcc 	andi	r2,r2,65535
 203cfe8:	18805926 	beq	r3,r2,203d150 <ip_reass_chain_frag_into_datagram_and_validate+0x558>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 203cfec:	e03ff715 	stw	zero,-36(fp)
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
 203cff0:	00005706 	br	203d150 <ip_reass_chain_frag_into_datagram_and_validate+0x558>
           * and the previous fragment */
          valid = 0;
        }
      } else {
#if IP_REASS_CHECK_OVERLAP
        if (iprh->end > iprh_tmp->start) {
 203cff4:	e0bffb17 	ldw	r2,-20(fp)
 203cff8:	10c00183 	ldbu	r3,6(r2)
 203cffc:	108001c3 	ldbu	r2,7(r2)
 203d000:	1004923a 	slli	r2,r2,8
 203d004:	10c4b03a 	or	r2,r2,r3
 203d008:	1009883a 	mov	r4,r2
 203d00c:	e0bffc17 	ldw	r2,-16(fp)
 203d010:	10c00103 	ldbu	r3,4(r2)
 203d014:	10800143 	ldbu	r2,5(r2)
 203d018:	1004923a 	slli	r2,r2,8
 203d01c:	10c4b03a 	or	r2,r2,r3
 203d020:	1007883a 	mov	r3,r2
 203d024:	20bfffcc 	andi	r2,r4,65535
 203d028:	18ffffcc 	andi	r3,r3,65535
 203d02c:	1880022e 	bgeu	r3,r2,203d038 <ip_reass_chain_frag_into_datagram_and_validate+0x440>
          /* fragment overlaps with following, throw away */
          return IP_REASS_VALIDATE_PBUF_DROPPED;
 203d030:	00bfffc4 	movi	r2,-1
 203d034:	0000cf06 	br	203d374 <ip_reass_chain_frag_into_datagram_and_validate+0x77c>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        /* fragment with the lowest offset */
        ipr->p = new_p;
 203d038:	e0bffd17 	ldw	r2,-12(fp)
 203d03c:	e0fffe17 	ldw	r3,-8(fp)
 203d040:	10c00115 	stw	r3,4(r2)
      }
      break;
 203d044:	00004206 	br	203d150 <ip_reass_chain_frag_into_datagram_and_validate+0x558>
    } else if (iprh->start == iprh_tmp->start) {
 203d048:	e0bffb17 	ldw	r2,-20(fp)
 203d04c:	10c00103 	ldbu	r3,4(r2)
 203d050:	10800143 	ldbu	r2,5(r2)
 203d054:	1004923a 	slli	r2,r2,8
 203d058:	10c4b03a 	or	r2,r2,r3
 203d05c:	1009883a 	mov	r4,r2
 203d060:	e0bffc17 	ldw	r2,-16(fp)
 203d064:	10c00103 	ldbu	r3,4(r2)
 203d068:	10800143 	ldbu	r2,5(r2)
 203d06c:	1004923a 	slli	r2,r2,8
 203d070:	10c4b03a 	or	r2,r2,r3
 203d074:	20ffffcc 	andi	r3,r4,65535
 203d078:	10bfffcc 	andi	r2,r2,65535
 203d07c:	1880021e 	bne	r3,r2,203d088 <ip_reass_chain_frag_into_datagram_and_validate+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      return IP_REASS_VALIDATE_PBUF_DROPPED;
 203d080:	00bfffc4 	movi	r2,-1
 203d084:	0000bb06 	br	203d374 <ip_reass_chain_frag_into_datagram_and_validate+0x77c>
#if IP_REASS_CHECK_OVERLAP
    } else if (iprh->start < iprh_tmp->end) {
 203d088:	e0bffb17 	ldw	r2,-20(fp)
 203d08c:	10c00103 	ldbu	r3,4(r2)
 203d090:	10800143 	ldbu	r2,5(r2)
 203d094:	1004923a 	slli	r2,r2,8
 203d098:	10c4b03a 	or	r2,r2,r3
 203d09c:	1009883a 	mov	r4,r2
 203d0a0:	e0bffc17 	ldw	r2,-16(fp)
 203d0a4:	10c00183 	ldbu	r3,6(r2)
 203d0a8:	108001c3 	ldbu	r2,7(r2)
 203d0ac:	1004923a 	slli	r2,r2,8
 203d0b0:	10c4b03a 	or	r2,r2,r3
 203d0b4:	20ffffcc 	andi	r3,r4,65535
 203d0b8:	10bfffcc 	andi	r2,r2,65535
 203d0bc:	1880022e 	bgeu	r3,r2,203d0c8 <ip_reass_chain_frag_into_datagram_and_validate+0x4d0>
      /* overlap: no need to keep the new datagram */
      return IP_REASS_VALIDATE_PBUF_DROPPED;
 203d0c0:	00bfffc4 	movi	r2,-1
 203d0c4:	0000ab06 	br	203d374 <ip_reass_chain_frag_into_datagram_and_validate+0x77c>
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no holes. */
      if (iprh_prev != NULL) {
 203d0c8:	e0bff517 	ldw	r2,-44(fp)
 203d0cc:	10000f26 	beq	r2,zero,203d10c <ip_reass_chain_frag_into_datagram_and_validate+0x514>
        if (iprh_prev->end != iprh_tmp->start) {
 203d0d0:	e0bff517 	ldw	r2,-44(fp)
 203d0d4:	10c00183 	ldbu	r3,6(r2)
 203d0d8:	108001c3 	ldbu	r2,7(r2)
 203d0dc:	1004923a 	slli	r2,r2,8
 203d0e0:	10c4b03a 	or	r2,r2,r3
 203d0e4:	1009883a 	mov	r4,r2
 203d0e8:	e0bffc17 	ldw	r2,-16(fp)
 203d0ec:	10c00103 	ldbu	r3,4(r2)
 203d0f0:	10800143 	ldbu	r2,5(r2)
 203d0f4:	1004923a 	slli	r2,r2,8
 203d0f8:	10c4b03a 	or	r2,r2,r3
 203d0fc:	20ffffcc 	andi	r3,r4,65535
 203d100:	10bfffcc 	andi	r2,r2,65535
 203d104:	18800126 	beq	r3,r2,203d10c <ip_reass_chain_frag_into_datagram_and_validate+0x514>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 203d108:	e03ff715 	stw	zero,-36(fp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 203d10c:	e0bffc17 	ldw	r2,-16(fp)
 203d110:	10c00003 	ldbu	r3,0(r2)
 203d114:	11000043 	ldbu	r4,1(r2)
 203d118:	2008923a 	slli	r4,r4,8
 203d11c:	20c6b03a 	or	r3,r4,r3
 203d120:	11000083 	ldbu	r4,2(r2)
 203d124:	2008943a 	slli	r4,r4,16
 203d128:	20c6b03a 	or	r3,r4,r3
 203d12c:	108000c3 	ldbu	r2,3(r2)
 203d130:	1004963a 	slli	r2,r2,24
 203d134:	10c4b03a 	or	r2,r2,r3
 203d138:	e0bff615 	stw	r2,-40(fp)
    iprh_prev = iprh_tmp;
 203d13c:	e0bffc17 	ldw	r2,-16(fp)
 203d140:	e0bff515 	stw	r2,-44(fp)
    return IP_REASS_VALIDATE_PBUF_DROPPED;
  }

  /* Iterate through until we either get to the end of the list (append),
   * or we find one with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 203d144:	e0bff617 	ldw	r2,-40(fp)
 203d148:	103f221e 	bne	r2,zero,203cdd4 <__alt_mem_mem_0+0xfd01cdd4>
 203d14c:	00000106 	br	203d154 <ip_reass_chain_frag_into_datagram_and_validate+0x55c>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
 203d150:	0001883a 	nop
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
 203d154:	e0bff617 	ldw	r2,-40(fp)
 203d158:	1000381e 	bne	r2,zero,203d23c <ip_reass_chain_frag_into_datagram_and_validate+0x644>
    if (iprh_prev != NULL) {
 203d15c:	e0bff517 	ldw	r2,-44(fp)
 203d160:	10003326 	beq	r2,zero,203d230 <ip_reass_chain_frag_into_datagram_and_validate+0x638>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 203d164:	e0bff517 	ldw	r2,-44(fp)
 203d168:	e0fffe17 	ldw	r3,-8(fp)
 203d16c:	19403fcc 	andi	r5,r3,255
 203d170:	10c00003 	ldbu	r3,0(r2)
 203d174:	1806703a 	and	r3,r3,zero
 203d178:	1809883a 	mov	r4,r3
 203d17c:	2807883a 	mov	r3,r5
 203d180:	20c6b03a 	or	r3,r4,r3
 203d184:	10c00005 	stb	r3,0(r2)
 203d188:	e0fffe17 	ldw	r3,-8(fp)
 203d18c:	1806d23a 	srli	r3,r3,8
 203d190:	19403fcc 	andi	r5,r3,255
 203d194:	10c00043 	ldbu	r3,1(r2)
 203d198:	1806703a 	and	r3,r3,zero
 203d19c:	1809883a 	mov	r4,r3
 203d1a0:	2807883a 	mov	r3,r5
 203d1a4:	20c6b03a 	or	r3,r4,r3
 203d1a8:	10c00045 	stb	r3,1(r2)
 203d1ac:	e0fffe17 	ldw	r3,-8(fp)
 203d1b0:	1806d43a 	srli	r3,r3,16
 203d1b4:	19403fcc 	andi	r5,r3,255
 203d1b8:	10c00083 	ldbu	r3,2(r2)
 203d1bc:	1806703a 	and	r3,r3,zero
 203d1c0:	1809883a 	mov	r4,r3
 203d1c4:	2807883a 	mov	r3,r5
 203d1c8:	20c6b03a 	or	r3,r4,r3
 203d1cc:	10c00085 	stb	r3,2(r2)
 203d1d0:	e0fffe17 	ldw	r3,-8(fp)
 203d1d4:	180ad63a 	srli	r5,r3,24
 203d1d8:	10c000c3 	ldbu	r3,3(r2)
 203d1dc:	1806703a 	and	r3,r3,zero
 203d1e0:	1809883a 	mov	r4,r3
 203d1e4:	2807883a 	mov	r3,r5
 203d1e8:	20c6b03a 	or	r3,r4,r3
 203d1ec:	10c000c5 	stb	r3,3(r2)
      if (iprh_prev->end != iprh->start) {
 203d1f0:	e0bff517 	ldw	r2,-44(fp)
 203d1f4:	10c00183 	ldbu	r3,6(r2)
 203d1f8:	108001c3 	ldbu	r2,7(r2)
 203d1fc:	1004923a 	slli	r2,r2,8
 203d200:	10c4b03a 	or	r2,r2,r3
 203d204:	1009883a 	mov	r4,r2
 203d208:	e0bffb17 	ldw	r2,-20(fp)
 203d20c:	10c00103 	ldbu	r3,4(r2)
 203d210:	10800143 	ldbu	r2,5(r2)
 203d214:	1004923a 	slli	r2,r2,8
 203d218:	10c4b03a 	or	r2,r2,r3
 203d21c:	20ffffcc 	andi	r3,r4,65535
 203d220:	10bfffcc 	andi	r2,r2,65535
 203d224:	18800526 	beq	r3,r2,203d23c <ip_reass_chain_frag_into_datagram_and_validate+0x644>
        valid = 0;
 203d228:	e03ff715 	stw	zero,-36(fp)
 203d22c:	00000306 	br	203d23c <ip_reass_chain_frag_into_datagram_and_validate+0x644>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
                  ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 203d230:	e0bffd17 	ldw	r2,-12(fp)
 203d234:	e0fffe17 	ldw	r3,-8(fp)
 203d238:	10c00115 	stw	r3,4(r2)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 203d23c:	e0bfff17 	ldw	r2,-4(fp)
 203d240:	1000051e 	bne	r2,zero,203d258 <ip_reass_chain_frag_into_datagram_and_validate+0x660>
 203d244:	e0bffd17 	ldw	r2,-12(fp)
 203d248:	10800783 	ldbu	r2,30(r2)
 203d24c:	10803fcc 	andi	r2,r2,255
 203d250:	1080004c 	andi	r2,r2,1
 203d254:	10004626 	beq	r2,zero,203d370 <ip_reass_chain_frag_into_datagram_and_validate+0x778>
    /* and had no holes so far */
    if (valid) {
 203d258:	e0bff717 	ldw	r2,-36(fp)
 203d25c:	10004026 	beq	r2,zero,203d360 <ip_reass_chain_frag_into_datagram_and_validate+0x768>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if ((ipr->p == NULL) || (((struct ip_reass_helper *)ipr->p->payload)->start != 0)) {
 203d260:	e0bffd17 	ldw	r2,-12(fp)
 203d264:	10800117 	ldw	r2,4(r2)
 203d268:	10000926 	beq	r2,zero,203d290 <ip_reass_chain_frag_into_datagram_and_validate+0x698>
 203d26c:	e0bffd17 	ldw	r2,-12(fp)
 203d270:	10800117 	ldw	r2,4(r2)
 203d274:	10800117 	ldw	r2,4(r2)
 203d278:	10c00103 	ldbu	r3,4(r2)
 203d27c:	10800143 	ldbu	r2,5(r2)
 203d280:	1004923a 	slli	r2,r2,8
 203d284:	10c4b03a 	or	r2,r2,r3
 203d288:	10bfffcc 	andi	r2,r2,65535
 203d28c:	10000226 	beq	r2,zero,203d298 <ip_reass_chain_frag_into_datagram_and_validate+0x6a0>
        valid = 0;
 203d290:	e03ff715 	stw	zero,-36(fp)
 203d294:	00003206 	br	203d360 <ip_reass_chain_frag_into_datagram_and_validate+0x768>
      } else {
        /* and check that there are no holes after this datagram */
        iprh_prev = iprh;
 203d298:	e0bffb17 	ldw	r2,-20(fp)
 203d29c:	e0bff515 	stw	r2,-44(fp)
        q = iprh->next_pbuf;
 203d2a0:	e0bffb17 	ldw	r2,-20(fp)
 203d2a4:	10c00003 	ldbu	r3,0(r2)
 203d2a8:	11000043 	ldbu	r4,1(r2)
 203d2ac:	2008923a 	slli	r4,r4,8
 203d2b0:	20c6b03a 	or	r3,r4,r3
 203d2b4:	11000083 	ldbu	r4,2(r2)
 203d2b8:	2008943a 	slli	r4,r4,16
 203d2bc:	20c6b03a 	or	r3,r4,r3
 203d2c0:	108000c3 	ldbu	r2,3(r2)
 203d2c4:	1004963a 	slli	r2,r2,24
 203d2c8:	10c4b03a 	or	r2,r2,r3
 203d2cc:	e0bff615 	stw	r2,-40(fp)
        while (q != NULL) {
 203d2d0:	00002106 	br	203d358 <ip_reass_chain_frag_into_datagram_and_validate+0x760>
          iprh = (struct ip_reass_helper *)q->payload;
 203d2d4:	e0bff617 	ldw	r2,-40(fp)
 203d2d8:	10800117 	ldw	r2,4(r2)
 203d2dc:	e0bffb15 	stw	r2,-20(fp)
          if (iprh_prev->end != iprh->start) {
 203d2e0:	e0bff517 	ldw	r2,-44(fp)
 203d2e4:	10c00183 	ldbu	r3,6(r2)
 203d2e8:	108001c3 	ldbu	r2,7(r2)
 203d2ec:	1004923a 	slli	r2,r2,8
 203d2f0:	10c4b03a 	or	r2,r2,r3
 203d2f4:	1009883a 	mov	r4,r2
 203d2f8:	e0bffb17 	ldw	r2,-20(fp)
 203d2fc:	10c00103 	ldbu	r3,4(r2)
 203d300:	10800143 	ldbu	r2,5(r2)
 203d304:	1004923a 	slli	r2,r2,8
 203d308:	10c4b03a 	or	r2,r2,r3
 203d30c:	20ffffcc 	andi	r3,r4,65535
 203d310:	10bfffcc 	andi	r2,r2,65535
 203d314:	18800226 	beq	r3,r2,203d320 <ip_reass_chain_frag_into_datagram_and_validate+0x728>
            valid = 0;
 203d318:	e03ff715 	stw	zero,-36(fp)
            break;
 203d31c:	00001006 	br	203d360 <ip_reass_chain_frag_into_datagram_and_validate+0x768>
          }
          iprh_prev = iprh;
 203d320:	e0bffb17 	ldw	r2,-20(fp)
 203d324:	e0bff515 	stw	r2,-44(fp)
          q = iprh->next_pbuf;
 203d328:	e0bffb17 	ldw	r2,-20(fp)
 203d32c:	10c00003 	ldbu	r3,0(r2)
 203d330:	11000043 	ldbu	r4,1(r2)
 203d334:	2008923a 	slli	r4,r4,8
 203d338:	20c6b03a 	or	r3,r4,r3
 203d33c:	11000083 	ldbu	r4,2(r2)
 203d340:	2008943a 	slli	r4,r4,16
 203d344:	20c6b03a 	or	r3,r4,r3
 203d348:	108000c3 	ldbu	r2,3(r2)
 203d34c:	1004963a 	slli	r2,r2,24
 203d350:	10c4b03a 	or	r2,r2,r3
 203d354:	e0bff615 	stw	r2,-40(fp)
        valid = 0;
      } else {
        /* and check that there are no holes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 203d358:	e0bff617 	ldw	r2,-40(fp)
 203d35c:	103fdd1e 	bne	r2,zero,203d2d4 <__alt_mem_mem_0+0xfd01d2d4>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
 203d360:	e0bff717 	ldw	r2,-36(fp)
 203d364:	1004c03a 	cmpne	r2,r2,zero
 203d368:	10803fcc 	andi	r2,r2,255
 203d36c:	00000106 	br	203d374 <ip_reass_chain_frag_into_datagram_and_validate+0x77c>
  }
  /* If we come here, not all fragments were received, yet! */
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
 203d370:	0005883a 	mov	r2,zero
}
 203d374:	e037883a 	mov	sp,fp
 203d378:	dfc00117 	ldw	ra,4(sp)
 203d37c:	df000017 	ldw	fp,0(sp)
 203d380:	dec00204 	addi	sp,sp,8
 203d384:	f800283a 	ret

0203d388 <ip4_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip4_reass(struct pbuf *p)
{
 203d388:	defff204 	addi	sp,sp,-56
 203d38c:	dfc00d15 	stw	ra,52(sp)
 203d390:	df000c15 	stw	fp,48(sp)
 203d394:	df000c04 	addi	fp,sp,48
 203d398:	e13fff15 	stw	r4,-4(fp)
  u16_t offset, len, clen;
  u8_t hlen;
  int valid;
  int is_last;

  IPFRAG_STATS_INC(ip_frag.recv);
 203d39c:	008085f4 	movhi	r2,535
 203d3a0:	10bd8204 	addi	r2,r2,-2552
 203d3a4:	10801917 	ldw	r2,100(r2)
 203d3a8:	10c00044 	addi	r3,r2,1
 203d3ac:	008085f4 	movhi	r2,535
 203d3b0:	10bd8204 	addi	r2,r2,-2552
 203d3b4:	10c01915 	stw	r3,100(r2)
  MIB2_STATS_INC(mib2.ipreasmreqds);

  fraghdr = (struct ip_hdr *)p->payload;
 203d3b8:	e0bfff17 	ldw	r2,-4(fp)
 203d3bc:	10800117 	ldw	r2,4(r2)
 203d3c0:	e0bff715 	stw	r2,-36(fp)

  if (IPH_HL_BYTES(fraghdr) != IP_HLEN) {
 203d3c4:	e0bff717 	ldw	r2,-36(fp)
 203d3c8:	10800003 	ldbu	r2,0(r2)
 203d3cc:	108003cc 	andi	r2,r2,15
 203d3d0:	1085883a 	add	r2,r2,r2
 203d3d4:	1085883a 	add	r2,r2,r2
 203d3d8:	10803fcc 	andi	r2,r2,255
 203d3dc:	10800520 	cmpeqi	r2,r2,20
 203d3e0:	1000081e 	bne	r2,zero,203d404 <ip4_reass+0x7c>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
 203d3e4:	008085f4 	movhi	r2,535
 203d3e8:	10bd8204 	addi	r2,r2,-2552
 203d3ec:	10802217 	ldw	r2,136(r2)
 203d3f0:	10c00044 	addi	r3,r2,1
 203d3f4:	008085f4 	movhi	r2,535
 203d3f8:	10bd8204 	addi	r2,r2,-2552
 203d3fc:	10c02215 	stw	r3,136(r2)
    goto nullreturn;
 203d400:	00016606 	br	203d99c <ip4_reass+0x614>
  }

  offset = IPH_OFFSET_BYTES(fraghdr);
 203d404:	e0bff717 	ldw	r2,-36(fp)
 203d408:	10c00183 	ldbu	r3,6(r2)
 203d40c:	108001c3 	ldbu	r2,7(r2)
 203d410:	1004923a 	slli	r2,r2,8
 203d414:	10c4b03a 	or	r2,r2,r3
 203d418:	10bfffcc 	andi	r2,r2,65535
 203d41c:	1009883a 	mov	r4,r2
 203d420:	20394740 	call	2039474 <lwip_htons>
 203d424:	1087ffcc 	andi	r2,r2,8191
 203d428:	100490fa 	slli	r2,r2,3
 203d42c:	e0bff80d 	sth	r2,-32(fp)
  len = lwip_ntohs(IPH_LEN(fraghdr));
 203d430:	e0bff717 	ldw	r2,-36(fp)
 203d434:	10c00083 	ldbu	r3,2(r2)
 203d438:	108000c3 	ldbu	r2,3(r2)
 203d43c:	1004923a 	slli	r2,r2,8
 203d440:	10c4b03a 	or	r2,r2,r3
 203d444:	10bfffcc 	andi	r2,r2,65535
 203d448:	1009883a 	mov	r4,r2
 203d44c:	20394740 	call	2039474 <lwip_htons>
 203d450:	e0bff88d 	sth	r2,-30(fp)
  hlen = IPH_HL_BYTES(fraghdr);
 203d454:	e0bff717 	ldw	r2,-36(fp)
 203d458:	10800003 	ldbu	r2,0(r2)
 203d45c:	108003cc 	andi	r2,r2,15
 203d460:	1085883a 	add	r2,r2,r2
 203d464:	1085883a 	add	r2,r2,r2
 203d468:	e0bff905 	stb	r2,-28(fp)
  if (hlen > len) {
 203d46c:	e0bff903 	ldbu	r2,-28(fp)
 203d470:	10bfffcc 	andi	r2,r2,65535
 203d474:	e0fff88b 	ldhu	r3,-30(fp)
 203d478:	18814736 	bltu	r3,r2,203d998 <ip4_reass+0x610>
    /* invalid datagram */
    goto nullreturn;
  }
  len = (u16_t)(len - hlen);
 203d47c:	e0bff903 	ldbu	r2,-28(fp)
 203d480:	e0fff88b 	ldhu	r3,-30(fp)
 203d484:	1885c83a 	sub	r2,r3,r2
 203d488:	e0bff88d 	sth	r2,-30(fp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 203d48c:	e13fff17 	ldw	r4,-4(fp)
 203d490:	201d42c0 	call	201d42c <pbuf_clen>
 203d494:	e0bff98d 	sth	r2,-26(fp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 203d498:	d0a8030b 	ldhu	r2,-24564(gp)
 203d49c:	10ffffcc 	andi	r3,r2,65535
 203d4a0:	e0bff98b 	ldhu	r2,-26(fp)
 203d4a4:	1885883a 	add	r2,r3,r2
 203d4a8:	108002d0 	cmplti	r2,r2,11
 203d4ac:	1000131e 	bne	r2,zero,203d4fc <ip4_reass+0x174>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 203d4b0:	e0bff98b 	ldhu	r2,-26(fp)
 203d4b4:	100b883a 	mov	r5,r2
 203d4b8:	e13ff717 	ldw	r4,-36(fp)
 203d4bc:	203c9100 	call	203c910 <ip_reass_remove_oldest_datagram>
 203d4c0:	10000626 	beq	r2,zero,203d4dc <ip4_reass+0x154>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 203d4c4:	d0a8030b 	ldhu	r2,-24564(gp)
 203d4c8:	10ffffcc 	andi	r3,r2,65535
 203d4cc:	e0bff98b 	ldhu	r2,-26(fp)
 203d4d0:	1885883a 	add	r2,r3,r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 203d4d4:	108002d0 	cmplti	r2,r2,11
 203d4d8:	1000081e 	bne	r2,zero,203d4fc <ip4_reass+0x174>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
                                   ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
 203d4dc:	008085f4 	movhi	r2,535
 203d4e0:	10bd8204 	addi	r2,r2,-2552
 203d4e4:	10801e17 	ldw	r2,120(r2)
 203d4e8:	10c00044 	addi	r3,r2,1
 203d4ec:	008085f4 	movhi	r2,535
 203d4f0:	10bd8204 	addi	r2,r2,-2552
 203d4f4:	10c01e15 	stw	r3,120(r2)
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
 203d4f8:	00012806 	br	203d99c <ip4_reass+0x614>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 203d4fc:	d0a80217 	ldw	r2,-24568(gp)
 203d500:	e0bff515 	stw	r2,-44(fp)
 203d504:	00003106 	br	203d5cc <ip4_reass+0x244>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 203d508:	e0bff517 	ldw	r2,-44(fp)
 203d50c:	10c00517 	ldw	r3,20(r2)
 203d510:	e0bff717 	ldw	r2,-36(fp)
 203d514:	11000303 	ldbu	r4,12(r2)
 203d518:	11400343 	ldbu	r5,13(r2)
 203d51c:	280a923a 	slli	r5,r5,8
 203d520:	2908b03a 	or	r4,r5,r4
 203d524:	11400383 	ldbu	r5,14(r2)
 203d528:	280a943a 	slli	r5,r5,16
 203d52c:	2908b03a 	or	r4,r5,r4
 203d530:	108003c3 	ldbu	r2,15(r2)
 203d534:	1004963a 	slli	r2,r2,24
 203d538:	1104b03a 	or	r2,r2,r4
 203d53c:	1880201e 	bne	r3,r2,203d5c0 <ip4_reass+0x238>
 203d540:	e0bff517 	ldw	r2,-44(fp)
 203d544:	10c00617 	ldw	r3,24(r2)
 203d548:	e0bff717 	ldw	r2,-36(fp)
 203d54c:	11000403 	ldbu	r4,16(r2)
 203d550:	11400443 	ldbu	r5,17(r2)
 203d554:	280a923a 	slli	r5,r5,8
 203d558:	2908b03a 	or	r4,r5,r4
 203d55c:	11400483 	ldbu	r5,18(r2)
 203d560:	280a943a 	slli	r5,r5,16
 203d564:	2908b03a 	or	r4,r5,r4
 203d568:	108004c3 	ldbu	r2,19(r2)
 203d56c:	1004963a 	slli	r2,r2,24
 203d570:	1104b03a 	or	r2,r2,r4
 203d574:	1880121e 	bne	r3,r2,203d5c0 <ip4_reass+0x238>
 203d578:	e0bff517 	ldw	r2,-44(fp)
 203d57c:	1100030b 	ldhu	r4,12(r2)
 203d580:	e0bff717 	ldw	r2,-36(fp)
 203d584:	10c00103 	ldbu	r3,4(r2)
 203d588:	10800143 	ldbu	r2,5(r2)
 203d58c:	1004923a 	slli	r2,r2,8
 203d590:	10c4b03a 	or	r2,r2,r3
 203d594:	20ffffcc 	andi	r3,r4,65535
 203d598:	10bfffcc 	andi	r2,r2,65535
 203d59c:	1880081e 	bne	r3,r2,203d5c0 <ip4_reass+0x238>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
                                   lwip_ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
 203d5a0:	008085f4 	movhi	r2,535
 203d5a4:	10bd8204 	addi	r2,r2,-2552
 203d5a8:	10802317 	ldw	r2,140(r2)
 203d5ac:	10c00044 	addi	r3,r2,1
 203d5b0:	008085f4 	movhi	r2,535
 203d5b4:	10bd8204 	addi	r2,r2,-2552
 203d5b8:	10c02315 	stw	r3,140(r2)
      break;
 203d5bc:	00000506 	br	203d5d4 <ip4_reass+0x24c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 203d5c0:	e0bff517 	ldw	r2,-44(fp)
 203d5c4:	10800017 	ldw	r2,0(r2)
 203d5c8:	e0bff515 	stw	r2,-44(fp)
 203d5cc:	e0bff517 	ldw	r2,-44(fp)
 203d5d0:	103fcd1e 	bne	r2,zero,203d508 <__alt_mem_mem_0+0xfd01d508>
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
  }

  if (ipr == NULL) {
 203d5d4:	e0bff517 	ldw	r2,-44(fp)
 203d5d8:	1000081e 	bne	r2,zero,203d5fc <ip4_reass+0x274>
    /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 203d5dc:	e0bff98b 	ldhu	r2,-26(fp)
 203d5e0:	100b883a 	mov	r5,r2
 203d5e4:	e13ff717 	ldw	r4,-36(fp)
 203d5e8:	203cab40 	call	203cab4 <ip_reass_enqueue_new_datagram>
 203d5ec:	e0bff515 	stw	r2,-44(fp)
    /* Bail if unable to enqueue */
    if (ipr == NULL) {
 203d5f0:	e0bff517 	ldw	r2,-44(fp)
 203d5f4:	10001a1e 	bne	r2,zero,203d660 <ip4_reass+0x2d8>
      goto nullreturn;
 203d5f8:	0000e806 	br	203d99c <ip4_reass+0x614>
    }
  } else {
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 203d5fc:	e0bff717 	ldw	r2,-36(fp)
 203d600:	10c00183 	ldbu	r3,6(r2)
 203d604:	108001c3 	ldbu	r2,7(r2)
 203d608:	1004923a 	slli	r2,r2,8
 203d60c:	10c4b03a 	or	r2,r2,r3
 203d610:	10bfffcc 	andi	r2,r2,65535
 203d614:	1009883a 	mov	r4,r2
 203d618:	20394740 	call	2039474 <lwip_htons>
 203d61c:	10bfffcc 	andi	r2,r2,65535
 203d620:	1087ffcc 	andi	r2,r2,8191
 203d624:	10000e1e 	bne	r2,zero,203d660 <ip4_reass+0x2d8>
        ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 203d628:	e0bff517 	ldw	r2,-44(fp)
 203d62c:	1080038b 	ldhu	r2,14(r2)
 203d630:	10bfffcc 	andi	r2,r2,65535
 203d634:	1009883a 	mov	r4,r2
 203d638:	20394740 	call	2039474 <lwip_htons>
 203d63c:	10bfffcc 	andi	r2,r2,65535
 203d640:	1087ffcc 	andi	r2,r2,8191
    /* Bail if unable to enqueue */
    if (ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 203d644:	10000626 	beq	r2,zero,203d660 <ip4_reass+0x2d8>
        ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 203d648:	e0bff517 	ldw	r2,-44(fp)
 203d64c:	10800204 	addi	r2,r2,8
 203d650:	01800504 	movi	r6,20
 203d654:	e17ff717 	ldw	r5,-36(fp)
 203d658:	1009883a 	mov	r4,r2
 203d65c:	2005e580 	call	2005e58 <memcpy>

  /* At this point, we have either created a new entry or pointing
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
 203d660:	e0bff717 	ldw	r2,-36(fp)
 203d664:	10c00183 	ldbu	r3,6(r2)
 203d668:	108001c3 	ldbu	r2,7(r2)
 203d66c:	1004923a 	slli	r2,r2,8
 203d670:	10c4b03a 	or	r2,r2,r3
 203d674:	10bfffcc 	andi	r2,r2,65535
 203d678:	1080080c 	andi	r2,r2,32
 203d67c:	1005003a 	cmpeq	r2,r2,zero
 203d680:	10803fcc 	andi	r2,r2,255
 203d684:	e0bffa15 	stw	r2,-24(fp)
  if (is_last) {
 203d688:	e0bffa17 	ldw	r2,-24(fp)
 203d68c:	10000a26 	beq	r2,zero,203d6b8 <ip4_reass+0x330>
    u16_t datagram_len = (u16_t)(offset + len);
 203d690:	e0fff80b 	ldhu	r3,-32(fp)
 203d694:	e0bff88b 	ldhu	r2,-30(fp)
 203d698:	1885883a 	add	r2,r3,r2
 203d69c:	e0bffb0d 	sth	r2,-20(fp)
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 203d6a0:	e0fffb0b 	ldhu	r3,-20(fp)
 203d6a4:	e0bff80b 	ldhu	r2,-32(fp)
 203d6a8:	1880b436 	bltu	r3,r2,203d97c <ip4_reass+0x5f4>
 203d6ac:	e0bffb0b 	ldhu	r2,-20(fp)
 203d6b0:	10bffb28 	cmpgeui	r2,r2,65516
 203d6b4:	1000b11e 	bne	r2,zero,203d97c <ip4_reass+0x5f4>
      goto nullreturn_ipr;
    }
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
 203d6b8:	e1bffa17 	ldw	r6,-24(fp)
 203d6bc:	e17fff17 	ldw	r5,-4(fp)
 203d6c0:	e13ff517 	ldw	r4,-44(fp)
 203d6c4:	203cbf80 	call	203cbf8 <ip_reass_chain_frag_into_datagram_and_validate>
 203d6c8:	e0bffc15 	stw	r2,-16(fp)
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
 203d6cc:	e0bffc17 	ldw	r2,-16(fp)
 203d6d0:	10bfffd8 	cmpnei	r2,r2,-1
 203d6d4:	1000a826 	beq	r2,zero,203d978 <ip4_reass+0x5f0>
  /* if we come here, the pbuf has been enqueued */

  /* Track the current number of pbufs current 'in-flight', in order to limit
     the number of fragments that may be enqueued at any one time
     (overflow checked by testing against IP_REASS_MAX_PBUFS) */
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
 203d6d8:	d0e8030b 	ldhu	r3,-24564(gp)
 203d6dc:	e0bff98b 	ldhu	r2,-26(fp)
 203d6e0:	1885883a 	add	r2,r3,r2
 203d6e4:	d0a8030d 	sth	r2,-24564(gp)
  if (is_last) {
 203d6e8:	e0bffa17 	ldw	r2,-24(fp)
 203d6ec:	10000d26 	beq	r2,zero,203d724 <ip4_reass+0x39c>
    u16_t datagram_len = (u16_t)(offset + len);
 203d6f0:	e0fff80b 	ldhu	r3,-32(fp)
 203d6f4:	e0bff88b 	ldhu	r2,-30(fp)
 203d6f8:	1885883a 	add	r2,r3,r2
 203d6fc:	e0bffd0d 	sth	r2,-12(fp)
    ipr->datagram_len = datagram_len;
 203d700:	e0bff517 	ldw	r2,-44(fp)
 203d704:	e0fffd0b 	ldhu	r3,-12(fp)
 203d708:	10c0070d 	sth	r3,28(r2)
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 203d70c:	e0bff517 	ldw	r2,-44(fp)
 203d710:	10800783 	ldbu	r2,30(r2)
 203d714:	10800054 	ori	r2,r2,1
 203d718:	1007883a 	mov	r3,r2
 203d71c:	e0bff517 	ldw	r2,-44(fp)
 203d720:	10c00785 	stb	r3,30(r2)
    LWIP_DEBUGF(IP_REASS_DEBUG,
                ("ip4_reass: last fragment seen, total len %"S16_F"\n",
                 ipr->datagram_len));
  }

  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
 203d724:	e0bffc17 	ldw	r2,-16(fp)
 203d728:	10800058 	cmpnei	r2,r2,1
 203d72c:	1000901e 	bne	r2,zero,203d970 <ip4_reass+0x5e8>
    struct ip_reassdata *ipr_prev;
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    u16_t datagram_len = (u16_t)(ipr->datagram_len + IP_HLEN);
 203d730:	e0bff517 	ldw	r2,-44(fp)
 203d734:	1080070b 	ldhu	r2,28(r2)
 203d738:	10800504 	addi	r2,r2,20
 203d73c:	e0bffd8d 	sth	r2,-10(fp)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
 203d740:	e0bff517 	ldw	r2,-44(fp)
 203d744:	10800117 	ldw	r2,4(r2)
 203d748:	10800117 	ldw	r2,4(r2)
 203d74c:	10c00003 	ldbu	r3,0(r2)
 203d750:	11000043 	ldbu	r4,1(r2)
 203d754:	2008923a 	slli	r4,r4,8
 203d758:	20c6b03a 	or	r3,r4,r3
 203d75c:	11000083 	ldbu	r4,2(r2)
 203d760:	2008943a 	slli	r4,r4,16
 203d764:	20c6b03a 	or	r3,r4,r3
 203d768:	108000c3 	ldbu	r2,3(r2)
 203d76c:	1004963a 	slli	r2,r2,24
 203d770:	10c4b03a 	or	r2,r2,r3
 203d774:	e0bff415 	stw	r2,-48(fp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr *)(ipr->p->payload);
 203d778:	e0bff517 	ldw	r2,-44(fp)
 203d77c:	10800117 	ldw	r2,4(r2)
 203d780:	10800117 	ldw	r2,4(r2)
 203d784:	e0bff715 	stw	r2,-36(fp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 203d788:	e0bff517 	ldw	r2,-44(fp)
 203d78c:	10800204 	addi	r2,r2,8
 203d790:	01800504 	movi	r6,20
 203d794:	100b883a 	mov	r5,r2
 203d798:	e13ff717 	ldw	r4,-36(fp)
 203d79c:	2005e580 	call	2005e58 <memcpy>
    IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 203d7a0:	e0bffd8b 	ldhu	r2,-10(fp)
 203d7a4:	1009883a 	mov	r4,r2
 203d7a8:	20394740 	call	2039474 <lwip_htons>
 203d7ac:	100d883a 	mov	r6,r2
 203d7b0:	e0bff717 	ldw	r2,-36(fp)
 203d7b4:	30ffffcc 	andi	r3,r6,65535
 203d7b8:	19403fcc 	andi	r5,r3,255
 203d7bc:	10c00083 	ldbu	r3,2(r2)
 203d7c0:	1806703a 	and	r3,r3,zero
 203d7c4:	1809883a 	mov	r4,r3
 203d7c8:	2807883a 	mov	r3,r5
 203d7cc:	20c6b03a 	or	r3,r4,r3
 203d7d0:	10c00085 	stb	r3,2(r2)
 203d7d4:	30ffffcc 	andi	r3,r6,65535
 203d7d8:	1806d23a 	srli	r3,r3,8
 203d7dc:	197fffcc 	andi	r5,r3,65535
 203d7e0:	10c000c3 	ldbu	r3,3(r2)
 203d7e4:	1806703a 	and	r3,r3,zero
 203d7e8:	1809883a 	mov	r4,r3
 203d7ec:	2807883a 	mov	r3,r5
 203d7f0:	20c6b03a 	or	r3,r4,r3
 203d7f4:	10c000c5 	stb	r3,3(r2)
    IPH_OFFSET_SET(fraghdr, 0);
 203d7f8:	e0bff717 	ldw	r2,-36(fp)
 203d7fc:	10c00183 	ldbu	r3,6(r2)
 203d800:	1806703a 	and	r3,r3,zero
 203d804:	10c00185 	stb	r3,6(r2)
 203d808:	10c001c3 	ldbu	r3,7(r2)
 203d80c:	1806703a 	and	r3,r3,zero
 203d810:	10c001c5 	stb	r3,7(r2)
    IPH_CHKSUM_SET(fraghdr, 0);
 203d814:	e0bff717 	ldw	r2,-36(fp)
 203d818:	10c00283 	ldbu	r3,10(r2)
 203d81c:	1806703a 	and	r3,r3,zero
 203d820:	10c00285 	stb	r3,10(r2)
 203d824:	10c002c3 	ldbu	r3,11(r2)
 203d828:	1806703a 	and	r3,r3,zero
 203d82c:	10c002c5 	stb	r3,11(r2)
    /* @todo: do we need to set/calculate the correct checksum? */
#if CHECKSUM_GEN_IP
    IF__NETIF_CHECKSUM_ENABLED(ip_current_input_netif(), NETIF_CHECKSUM_GEN_IP) {
      IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 203d830:	01400504 	movi	r5,20
 203d834:	e13ff717 	ldw	r4,-36(fp)
 203d838:	203a1c40 	call	203a1c4 <inet_chksum>
 203d83c:	100d883a 	mov	r6,r2
 203d840:	e0bff717 	ldw	r2,-36(fp)
 203d844:	30ffffcc 	andi	r3,r6,65535
 203d848:	19403fcc 	andi	r5,r3,255
 203d84c:	10c00283 	ldbu	r3,10(r2)
 203d850:	1806703a 	and	r3,r3,zero
 203d854:	1809883a 	mov	r4,r3
 203d858:	2807883a 	mov	r3,r5
 203d85c:	20c6b03a 	or	r3,r4,r3
 203d860:	10c00285 	stb	r3,10(r2)
 203d864:	30ffffcc 	andi	r3,r6,65535
 203d868:	1806d23a 	srli	r3,r3,8
 203d86c:	197fffcc 	andi	r5,r3,65535
 203d870:	10c002c3 	ldbu	r3,11(r2)
 203d874:	1806703a 	and	r3,r3,zero
 203d878:	1809883a 	mov	r4,r3
 203d87c:	2807883a 	mov	r3,r5
 203d880:	20c6b03a 	or	r3,r4,r3
 203d884:	10c002c5 	stb	r3,11(r2)
    }
#endif /* CHECKSUM_GEN_IP */

    p = ipr->p;
 203d888:	e0bff517 	ldw	r2,-44(fp)
 203d88c:	10800117 	ldw	r2,4(r2)
 203d890:	e0bfff15 	stw	r2,-4(fp)

    /* chain together the pbufs contained within the reass_data list. */
    while (r != NULL) {
 203d894:	00001506 	br	203d8ec <ip4_reass+0x564>
      iprh = (struct ip_reass_helper *)r->payload;
 203d898:	e0bff417 	ldw	r2,-48(fp)
 203d89c:	10800117 	ldw	r2,4(r2)
 203d8a0:	e0bffe15 	stw	r2,-8(fp)

      /* hide the ip header for every succeeding fragment */
      pbuf_remove_header(r, IP_HLEN);
 203d8a4:	01400504 	movi	r5,20
 203d8a8:	e13ff417 	ldw	r4,-48(fp)
 203d8ac:	201d06c0 	call	201d06c <pbuf_remove_header>
      pbuf_cat(p, r);
 203d8b0:	e17ff417 	ldw	r5,-48(fp)
 203d8b4:	e13fff17 	ldw	r4,-4(fp)
 203d8b8:	201d4d40 	call	201d4d4 <pbuf_cat>
      r = iprh->next_pbuf;
 203d8bc:	e0bffe17 	ldw	r2,-8(fp)
 203d8c0:	10c00003 	ldbu	r3,0(r2)
 203d8c4:	11000043 	ldbu	r4,1(r2)
 203d8c8:	2008923a 	slli	r4,r4,8
 203d8cc:	20c6b03a 	or	r3,r4,r3
 203d8d0:	11000083 	ldbu	r4,2(r2)
 203d8d4:	2008943a 	slli	r4,r4,16
 203d8d8:	20c6b03a 	or	r3,r4,r3
 203d8dc:	108000c3 	ldbu	r2,3(r2)
 203d8e0:	1004963a 	slli	r2,r2,24
 203d8e4:	10c4b03a 	or	r2,r2,r3
 203d8e8:	e0bff415 	stw	r2,-48(fp)
#endif /* CHECKSUM_GEN_IP */

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while (r != NULL) {
 203d8ec:	e0bff417 	ldw	r2,-48(fp)
 203d8f0:	103fe91e 	bne	r2,zero,203d898 <__alt_mem_mem_0+0xfd01d898>
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }

    /* find the previous entry in the linked list */
    if (ipr == reassdatagrams) {
 203d8f4:	d0a80217 	ldw	r2,-24568(gp)
 203d8f8:	e0fff517 	ldw	r3,-44(fp)
 203d8fc:	1880021e 	bne	r3,r2,203d908 <ip4_reass+0x580>
      ipr_prev = NULL;
 203d900:	e03ff615 	stw	zero,-40(fp)
 203d904:	00000e06 	br	203d940 <ip4_reass+0x5b8>
    } else {
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 203d908:	d0a80217 	ldw	r2,-24568(gp)
 203d90c:	e0bff615 	stw	r2,-40(fp)
 203d910:	00000706 	br	203d930 <ip4_reass+0x5a8>
        if (ipr_prev->next == ipr) {
 203d914:	e0bff617 	ldw	r2,-40(fp)
 203d918:	10c00017 	ldw	r3,0(r2)
 203d91c:	e0bff517 	ldw	r2,-44(fp)
 203d920:	18800626 	beq	r3,r2,203d93c <ip4_reass+0x5b4>

    /* find the previous entry in the linked list */
    if (ipr == reassdatagrams) {
      ipr_prev = NULL;
    } else {
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 203d924:	e0bff617 	ldw	r2,-40(fp)
 203d928:	10800017 	ldw	r2,0(r2)
 203d92c:	e0bff615 	stw	r2,-40(fp)
 203d930:	e0bff617 	ldw	r2,-40(fp)
 203d934:	103ff71e 	bne	r2,zero,203d914 <__alt_mem_mem_0+0xfd01d914>
 203d938:	00000106 	br	203d940 <ip4_reass+0x5b8>
        if (ipr_prev->next == ipr) {
          break;
 203d93c:	0001883a 	nop
        }
      }
    }

    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 203d940:	e17ff617 	ldw	r5,-40(fp)
 203d944:	e13ff517 	ldw	r4,-44(fp)
 203d948:	203cb900 	call	203cb90 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    clen = pbuf_clen(p);
 203d94c:	e13fff17 	ldw	r4,-4(fp)
 203d950:	201d42c0 	call	201d42c <pbuf_clen>
 203d954:	e0bff98d 	sth	r2,-26(fp)
    LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
    ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 203d958:	d0e8030b 	ldhu	r3,-24564(gp)
 203d95c:	e0bff98b 	ldhu	r2,-26(fp)
 203d960:	1885c83a 	sub	r2,r3,r2
 203d964:	d0a8030d 	sth	r2,-24564(gp)

    MIB2_STATS_INC(mib2.ipreasmoks);

    /* Return the pbuf chain */
    return p;
 203d968:	e0bfff17 	ldw	r2,-4(fp)
 203d96c:	00001506 	br	203d9c4 <ip4_reass+0x63c>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 203d970:	0005883a 	mov	r2,zero
 203d974:	00001306 	br	203d9c4 <ip4_reass+0x63c>
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
    goto nullreturn_ipr;
 203d978:	0001883a 	nop
  LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;

nullreturn_ipr:
  LWIP_ASSERT("ipr != NULL", ipr != NULL);
  if (ipr->p == NULL) {
 203d97c:	e0bff517 	ldw	r2,-44(fp)
 203d980:	10800117 	ldw	r2,4(r2)
 203d984:	1000051e 	bne	r2,zero,203d99c <ip4_reass+0x614>
    /* dropped pbuf after creating a new datagram entry: remove the entry, too */
    LWIP_ASSERT("not firstalthough just enqueued", ipr == reassdatagrams);
    ip_reass_dequeue_datagram(ipr, NULL);
 203d988:	000b883a 	mov	r5,zero
 203d98c:	e13ff517 	ldw	r4,-44(fp)
 203d990:	203cb900 	call	203cb90 <ip_reass_dequeue_datagram>
 203d994:	00000106 	br	203d99c <ip4_reass+0x614>
  offset = IPH_OFFSET_BYTES(fraghdr);
  len = lwip_ntohs(IPH_LEN(fraghdr));
  hlen = IPH_HL_BYTES(fraghdr);
  if (hlen > len) {
    /* invalid datagram */
    goto nullreturn;
 203d998:	0001883a 	nop
    ip_reass_dequeue_datagram(ipr, NULL);
  }

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
 203d99c:	008085f4 	movhi	r2,535
 203d9a0:	10bd8204 	addi	r2,r2,-2552
 203d9a4:	10801b17 	ldw	r2,108(r2)
 203d9a8:	10c00044 	addi	r3,r2,1
 203d9ac:	008085f4 	movhi	r2,535
 203d9b0:	10bd8204 	addi	r2,r2,-2552
 203d9b4:	10c01b15 	stw	r3,108(r2)
  pbuf_free(p);
 203d9b8:	e13fff17 	ldw	r4,-4(fp)
 203d9bc:	201d2f40 	call	201d2f4 <pbuf_free>
  return NULL;
 203d9c0:	0005883a 	mov	r2,zero
}
 203d9c4:	e037883a 	mov	sp,fp
 203d9c8:	dfc00117 	ldw	ra,4(sp)
 203d9cc:	df000017 	ldw	fp,0(sp)
 203d9d0:	dec00204 	addi	sp,sp,8
 203d9d4:	f800283a 	ret

0203d9d8 <ip_frag_alloc_pbuf_custom_ref>:
#if IP_FRAG
#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref *
ip_frag_alloc_pbuf_custom_ref(void)
{
 203d9d8:	defffe04 	addi	sp,sp,-8
 203d9dc:	dfc00115 	stw	ra,4(sp)
 203d9e0:	df000015 	stw	fp,0(sp)
 203d9e4:	d839883a 	mov	fp,sp
  return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
 203d9e8:	01000184 	movi	r4,6
 203d9ec:	201b82c0 	call	201b82c <memp_malloc>
}
 203d9f0:	e037883a 	mov	sp,fp
 203d9f4:	dfc00117 	ldw	ra,4(sp)
 203d9f8:	df000017 	ldw	fp,0(sp)
 203d9fc:	dec00204 	addi	sp,sp,8
 203da00:	f800283a 	ret

0203da04 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref *p)
{
 203da04:	defffd04 	addi	sp,sp,-12
 203da08:	dfc00215 	stw	ra,8(sp)
 203da0c:	df000115 	stw	fp,4(sp)
 203da10:	df000104 	addi	fp,sp,4
 203da14:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
 203da18:	e17fff17 	ldw	r5,-4(fp)
 203da1c:	01000184 	movi	r4,6
 203da20:	201b9640 	call	201b964 <memp_free>
}
 203da24:	0001883a 	nop
 203da28:	e037883a 	mov	sp,fp
 203da2c:	dfc00117 	ldw	ra,4(sp)
 203da30:	df000017 	ldw	fp,0(sp)
 203da34:	dec00204 	addi	sp,sp,8
 203da38:	f800283a 	ret

0203da3c <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 203da3c:	defffc04 	addi	sp,sp,-16
 203da40:	dfc00315 	stw	ra,12(sp)
 203da44:	df000215 	stw	fp,8(sp)
 203da48:	df000204 	addi	fp,sp,8
 203da4c:	e13fff15 	stw	r4,-4(fp)
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
 203da50:	e0bfff17 	ldw	r2,-4(fp)
 203da54:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
  if (pcr->original != NULL) {
 203da58:	e0bffe17 	ldw	r2,-8(fp)
 203da5c:	10800517 	ldw	r2,20(r2)
 203da60:	10000426 	beq	r2,zero,203da74 <ipfrag_free_pbuf_custom+0x38>
    pbuf_free(pcr->original);
 203da64:	e0bffe17 	ldw	r2,-8(fp)
 203da68:	10800517 	ldw	r2,20(r2)
 203da6c:	1009883a 	mov	r4,r2
 203da70:	201d2f40 	call	201d2f4 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 203da74:	e13ffe17 	ldw	r4,-8(fp)
 203da78:	203da040 	call	203da04 <ip_frag_free_pbuf_custom_ref>
}
 203da7c:	0001883a 	nop
 203da80:	e037883a 	mov	sp,fp
 203da84:	dfc00117 	ldw	ra,4(sp)
 203da88:	df000017 	ldw	fp,0(sp)
 203da8c:	dec00204 	addi	sp,sp,8
 203da90:	f800283a 	ret

0203da94 <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
 203da94:	deffec04 	addi	sp,sp,-80
 203da98:	dfc01315 	stw	ra,76(sp)
 203da9c:	df001215 	stw	fp,72(sp)
 203daa0:	df001204 	addi	fp,sp,72
 203daa4:	e13ffd15 	stw	r4,-12(fp)
 203daa8:	e17ffe15 	stw	r5,-8(fp)
 203daac:	e1bfff15 	stw	r6,-4(fp)
  struct pbuf *rambuf;
#if !LWIP_NETIF_TX_SINGLE_PBUF
  struct pbuf *newpbuf;
  u16_t newpbuflen = 0;
 203dab0:	e03ff00d 	sth	zero,-64(fp)
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
 203dab4:	e0bffe17 	ldw	r2,-8(fp)
 203dab8:	10800d0b 	ldhu	r2,52(r2)
 203dabc:	10bfffcc 	andi	r2,r2,65535
 203dac0:	10bffb04 	addi	r2,r2,-20
 203dac4:	1000010e 	bge	r2,zero,203dacc <ip4_frag+0x38>
 203dac8:	108001c4 	addi	r2,r2,7
 203dacc:	1005d0fa 	srai	r2,r2,3
 203dad0:	e0bff30d 	sth	r2,-52(fp)
  u16_t left, fragsize;
  u16_t ofo;
  int last;
  u16_t poff = IP_HLEN;
 203dad4:	00800504 	movi	r2,20
 203dad8:	e0bff20d 	sth	r2,-56(fp)
  u16_t tmp;
  int mf_set;

  original_iphdr = (struct ip_hdr *)p->payload;
 203dadc:	e0bffd17 	ldw	r2,-12(fp)
 203dae0:	10800117 	ldw	r2,4(r2)
 203dae4:	e0bff415 	stw	r2,-48(fp)
  iphdr = original_iphdr;
 203dae8:	e0bff417 	ldw	r2,-48(fp)
 203daec:	e0bff515 	stw	r2,-44(fp)
  if (IPH_HL_BYTES(iphdr) != IP_HLEN) {
 203daf0:	e0bff517 	ldw	r2,-44(fp)
 203daf4:	10800003 	ldbu	r2,0(r2)
 203daf8:	108003cc 	andi	r2,r2,15
 203dafc:	1085883a 	add	r2,r2,r2
 203db00:	1085883a 	add	r2,r2,r2
 203db04:	10803fcc 	andi	r2,r2,255
 203db08:	10800520 	cmpeqi	r2,r2,20
 203db0c:	1000021e 	bne	r2,zero,203db18 <ip4_frag+0x84>
    /* ip4_frag() does not support IP options */
    return ERR_VAL;
 203db10:	00bffe84 	movi	r2,-6
 203db14:	0000fc06 	br	203df08 <ip4_frag+0x474>
  }
  LWIP_ERROR("ip4_frag(): pbuf too short", p->len >= IP_HLEN, return ERR_VAL);
 203db18:	e0bffd17 	ldw	r2,-12(fp)
 203db1c:	1080028b 	ldhu	r2,10(r2)
 203db20:	10bfffcc 	andi	r2,r2,65535
 203db24:	10800528 	cmpgeui	r2,r2,20
 203db28:	1000021e 	bne	r2,zero,203db34 <ip4_frag+0xa0>
 203db2c:	00bffe84 	movi	r2,-6
 203db30:	0000f506 	br	203df08 <ip4_frag+0x474>

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
 203db34:	e0bff517 	ldw	r2,-44(fp)
 203db38:	10c00183 	ldbu	r3,6(r2)
 203db3c:	108001c3 	ldbu	r2,7(r2)
 203db40:	1004923a 	slli	r2,r2,8
 203db44:	10c4b03a 	or	r2,r2,r3
 203db48:	10bfffcc 	andi	r2,r2,65535
 203db4c:	1009883a 	mov	r4,r2
 203db50:	20394740 	call	2039474 <lwip_htons>
 203db54:	e0bff28d 	sth	r2,-54(fp)
  ofo = tmp & IP_OFFMASK;
 203db58:	e0bff28b 	ldhu	r2,-54(fp)
 203db5c:	1087ffcc 	andi	r2,r2,8191
 203db60:	e0bff18d 	sth	r2,-58(fp)
  /* already fragmented? if so, the last fragment we create must have MF, too */
  mf_set = tmp & IP_MF;
 203db64:	e0bff28b 	ldhu	r2,-54(fp)
 203db68:	1088000c 	andi	r2,r2,8192
 203db6c:	e0bff615 	stw	r2,-40(fp)

  left = (u16_t)(p->tot_len - IP_HLEN);
 203db70:	e0bffd17 	ldw	r2,-12(fp)
 203db74:	1080020b 	ldhu	r2,8(r2)
 203db78:	10bffb04 	addi	r2,r2,-20
 203db7c:	e0bff10d 	sth	r2,-60(fp)

  while (left) {
 203db80:	0000db06 	br	203def0 <ip4_frag+0x45c>
    /* Fill this fragment */
    fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
 203db84:	e0bff30b 	ldhu	r2,-52(fp)
 203db88:	100490fa 	slli	r2,r2,3
 203db8c:	e17ff10b 	ldhu	r5,-60(fp)
 203db90:	10ffffcc 	andi	r3,r2,65535
 203db94:	293fffcc 	andi	r4,r5,65535
 203db98:	20c0012e 	bgeu	r4,r3,203dba0 <ip4_frag+0x10c>
 203db9c:	2805883a 	mov	r2,r5
 203dba0:	e0bff70d 	sth	r2,-36(fp)
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 203dba4:	0180a004 	movi	r6,640
 203dba8:	01400504 	movi	r5,20
 203dbac:	01000404 	movi	r4,16
 203dbb0:	201c9740 	call	201c974 <pbuf_alloc>
 203dbb4:	e0bff815 	stw	r2,-32(fp)
    if (rambuf == NULL) {
 203dbb8:	e0bff817 	ldw	r2,-32(fp)
 203dbbc:	1000d026 	beq	r2,zero,203df00 <ip4_frag+0x46c>
      goto memerr;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (rambuf->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 203dbc0:	e0bff817 	ldw	r2,-32(fp)
 203dbc4:	10800117 	ldw	r2,4(r2)
 203dbc8:	01800504 	movi	r6,20
 203dbcc:	e17ff417 	ldw	r5,-48(fp)
 203dbd0:	1009883a 	mov	r4,r2
 203dbd4:	2005e580 	call	2005e58 <memcpy>
    iphdr = (struct ip_hdr *)rambuf->payload;
 203dbd8:	e0bff817 	ldw	r2,-32(fp)
 203dbdc:	10800117 	ldw	r2,4(r2)
 203dbe0:	e0bff515 	stw	r2,-44(fp)

    left_to_copy = fragsize;
 203dbe4:	e0bff70b 	ldhu	r2,-36(fp)
 203dbe8:	e0bff08d 	sth	r2,-62(fp)
    while (left_to_copy) {
 203dbec:	00004606 	br	203dd08 <ip4_frag+0x274>
      struct pbuf_custom_ref *pcr;
      u16_t plen = (u16_t)(p->len - poff);
 203dbf0:	e0bffd17 	ldw	r2,-12(fp)
 203dbf4:	10c0028b 	ldhu	r3,10(r2)
 203dbf8:	e0bff20b 	ldhu	r2,-56(fp)
 203dbfc:	1885c83a 	sub	r2,r3,r2
 203dc00:	e0bff90d 	sth	r2,-28(fp)
      LWIP_ASSERT("p->len >= poff", p->len >= poff);
      newpbuflen = LWIP_MIN(left_to_copy, plen);
 203dc04:	e17ff08b 	ldhu	r5,-62(fp)
 203dc08:	e0bff90b 	ldhu	r2,-28(fp)
 203dc0c:	10ffffcc 	andi	r3,r2,65535
 203dc10:	293fffcc 	andi	r4,r5,65535
 203dc14:	20c0012e 	bgeu	r4,r3,203dc1c <ip4_frag+0x188>
 203dc18:	2805883a 	mov	r2,r5
 203dc1c:	e0bff00d 	sth	r2,-64(fp)
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
 203dc20:	e0bff00b 	ldhu	r2,-64(fp)
 203dc24:	1000051e 	bne	r2,zero,203dc3c <ip4_frag+0x1a8>
        poff = 0;
 203dc28:	e03ff20d 	sth	zero,-56(fp)
        p = p->next;
 203dc2c:	e0bffd17 	ldw	r2,-12(fp)
 203dc30:	10800017 	ldw	r2,0(r2)
 203dc34:	e0bffd15 	stw	r2,-12(fp)
        continue;
 203dc38:	00003306 	br	203dd08 <ip4_frag+0x274>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
 203dc3c:	203d9d80 	call	203d9d8 <ip_frag_alloc_pbuf_custom_ref>
 203dc40:	e0bffa15 	stw	r2,-24(fp)
      if (pcr == NULL) {
 203dc44:	e0bffa17 	ldw	r2,-24(fp)
 203dc48:	1000031e 	bne	r2,zero,203dc58 <ip4_frag+0x1c4>
        pbuf_free(rambuf);
 203dc4c:	e13ff817 	ldw	r4,-32(fp)
 203dc50:	201d2f40 	call	201d2f4 <pbuf_free>
        goto memerr;
 203dc54:	0000ab06 	br	203df04 <ip4_frag+0x470>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 203dc58:	e13ff00b 	ldhu	r4,-64(fp)
 203dc5c:	e17ffa17 	ldw	r5,-24(fp)
                                    (u8_t *)p->payload + poff, newpbuflen);
 203dc60:	e0bffd17 	ldw	r2,-12(fp)
 203dc64:	10c00117 	ldw	r3,4(r2)
      if (pcr == NULL) {
        pbuf_free(rambuf);
        goto memerr;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 203dc68:	e0bff20b 	ldhu	r2,-56(fp)
 203dc6c:	1885883a 	add	r2,r3,r2
 203dc70:	e0fff00b 	ldhu	r3,-64(fp)
 203dc74:	d8c00115 	stw	r3,4(sp)
 203dc78:	d8800015 	stw	r2,0(sp)
 203dc7c:	280f883a 	mov	r7,r5
 203dc80:	01801044 	movi	r6,65
 203dc84:	200b883a 	mov	r5,r4
 203dc88:	0009883a 	mov	r4,zero
 203dc8c:	201cc6c0 	call	201cc6c <pbuf_alloced_custom>
 203dc90:	e0bffb15 	stw	r2,-20(fp)
                                    (u8_t *)p->payload + poff, newpbuflen);
      if (newpbuf == NULL) {
 203dc94:	e0bffb17 	ldw	r2,-20(fp)
 203dc98:	1000051e 	bne	r2,zero,203dcb0 <ip4_frag+0x21c>
        ip_frag_free_pbuf_custom_ref(pcr);
 203dc9c:	e13ffa17 	ldw	r4,-24(fp)
 203dca0:	203da040 	call	203da04 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 203dca4:	e13ff817 	ldw	r4,-32(fp)
 203dca8:	201d2f40 	call	201d2f4 <pbuf_free>
        goto memerr;
 203dcac:	00009506 	br	203df04 <ip4_frag+0x470>
      }
      pbuf_ref(p);
 203dcb0:	e13ffd17 	ldw	r4,-12(fp)
 203dcb4:	201d4780 	call	201d478 <pbuf_ref>
      pcr->original = p;
 203dcb8:	e0bffa17 	ldw	r2,-24(fp)
 203dcbc:	e0fffd17 	ldw	r3,-12(fp)
 203dcc0:	10c00515 	stw	r3,20(r2)
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 203dcc4:	e0fffa17 	ldw	r3,-24(fp)
 203dcc8:	00808134 	movhi	r2,516
 203dccc:	10b68f04 	addi	r2,r2,-9668
 203dcd0:	18800415 	stw	r2,16(r3)

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 203dcd4:	e17ffb17 	ldw	r5,-20(fp)
 203dcd8:	e13ff817 	ldw	r4,-32(fp)
 203dcdc:	201d4d40 	call	201d4d4 <pbuf_cat>
      left_to_copy = (u16_t)(left_to_copy - newpbuflen);
 203dce0:	e0fff08b 	ldhu	r3,-62(fp)
 203dce4:	e0bff00b 	ldhu	r2,-64(fp)
 203dce8:	1885c83a 	sub	r2,r3,r2
 203dcec:	e0bff08d 	sth	r2,-62(fp)
      if (left_to_copy) {
 203dcf0:	e0bff08b 	ldhu	r2,-62(fp)
 203dcf4:	10000426 	beq	r2,zero,203dd08 <ip4_frag+0x274>
        poff = 0;
 203dcf8:	e03ff20d 	sth	zero,-56(fp)
        p = p->next;
 203dcfc:	e0bffd17 	ldw	r2,-12(fp)
 203dd00:	10800017 	ldw	r2,0(r2)
 203dd04:	e0bffd15 	stw	r2,-12(fp)
                (rambuf->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    iphdr = (struct ip_hdr *)rambuf->payload;

    left_to_copy = fragsize;
    while (left_to_copy) {
 203dd08:	e0bff08b 	ldhu	r2,-62(fp)
 203dd0c:	103fb81e 	bne	r2,zero,203dbf0 <__alt_mem_mem_0+0xfd01dbf0>
      if (left_to_copy) {
        poff = 0;
        p = p->next;
      }
    }
    poff = (u16_t)(poff + newpbuflen);
 203dd10:	e0fff20b 	ldhu	r3,-56(fp)
 203dd14:	e0bff00b 	ldhu	r2,-64(fp)
 203dd18:	1885883a 	add	r2,r3,r2
 203dd1c:	e0bff20d 	sth	r2,-56(fp)
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

    /* Correct header */
    last = (left <= netif->mtu - IP_HLEN);
 203dd20:	e0bff10b 	ldhu	r2,-60(fp)
 203dd24:	e0fffe17 	ldw	r3,-8(fp)
 203dd28:	18c00d0b 	ldhu	r3,52(r3)
 203dd2c:	18ffffcc 	andi	r3,r3,65535
 203dd30:	18fffb04 	addi	r3,r3,-20
 203dd34:	1884403a 	cmpge	r2,r3,r2
 203dd38:	10803fcc 	andi	r2,r2,255
 203dd3c:	e0bffc15 	stw	r2,-16(fp)

    /* Set new offset and MF flag */
    tmp = (IP_OFFMASK & (ofo));
 203dd40:	e0bff18b 	ldhu	r2,-58(fp)
 203dd44:	1087ffcc 	andi	r2,r2,8191
 203dd48:	e0bff28d 	sth	r2,-54(fp)
    if (!last || mf_set) {
 203dd4c:	e0bffc17 	ldw	r2,-16(fp)
 203dd50:	10000226 	beq	r2,zero,203dd5c <ip4_frag+0x2c8>
 203dd54:	e0bff617 	ldw	r2,-40(fp)
 203dd58:	10000326 	beq	r2,zero,203dd68 <ip4_frag+0x2d4>
      /* the last fragment has MF set if the input frame had it */
      tmp = tmp | IP_MF;
 203dd5c:	e0bff28b 	ldhu	r2,-54(fp)
 203dd60:	10880014 	ori	r2,r2,8192
 203dd64:	e0bff28d 	sth	r2,-54(fp)
    }
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
 203dd68:	e0bff28b 	ldhu	r2,-54(fp)
 203dd6c:	1009883a 	mov	r4,r2
 203dd70:	20394740 	call	2039474 <lwip_htons>
 203dd74:	100d883a 	mov	r6,r2
 203dd78:	e0bff517 	ldw	r2,-44(fp)
 203dd7c:	30ffffcc 	andi	r3,r6,65535
 203dd80:	19403fcc 	andi	r5,r3,255
 203dd84:	10c00183 	ldbu	r3,6(r2)
 203dd88:	1806703a 	and	r3,r3,zero
 203dd8c:	1809883a 	mov	r4,r3
 203dd90:	2807883a 	mov	r3,r5
 203dd94:	20c6b03a 	or	r3,r4,r3
 203dd98:	10c00185 	stb	r3,6(r2)
 203dd9c:	30ffffcc 	andi	r3,r6,65535
 203dda0:	1806d23a 	srli	r3,r3,8
 203dda4:	197fffcc 	andi	r5,r3,65535
 203dda8:	10c001c3 	ldbu	r3,7(r2)
 203ddac:	1806703a 	and	r3,r3,zero
 203ddb0:	1809883a 	mov	r4,r3
 203ddb4:	2807883a 	mov	r3,r5
 203ddb8:	20c6b03a 	or	r3,r4,r3
 203ddbc:	10c001c5 	stb	r3,7(r2)
    IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
 203ddc0:	e0bff70b 	ldhu	r2,-36(fp)
 203ddc4:	10800504 	addi	r2,r2,20
 203ddc8:	10bfffcc 	andi	r2,r2,65535
 203ddcc:	1009883a 	mov	r4,r2
 203ddd0:	20394740 	call	2039474 <lwip_htons>
 203ddd4:	100d883a 	mov	r6,r2
 203ddd8:	e0bff517 	ldw	r2,-44(fp)
 203dddc:	30ffffcc 	andi	r3,r6,65535
 203dde0:	19403fcc 	andi	r5,r3,255
 203dde4:	10c00083 	ldbu	r3,2(r2)
 203dde8:	1806703a 	and	r3,r3,zero
 203ddec:	1809883a 	mov	r4,r3
 203ddf0:	2807883a 	mov	r3,r5
 203ddf4:	20c6b03a 	or	r3,r4,r3
 203ddf8:	10c00085 	stb	r3,2(r2)
 203ddfc:	30ffffcc 	andi	r3,r6,65535
 203de00:	1806d23a 	srli	r3,r3,8
 203de04:	197fffcc 	andi	r5,r3,65535
 203de08:	10c000c3 	ldbu	r3,3(r2)
 203de0c:	1806703a 	and	r3,r3,zero
 203de10:	1809883a 	mov	r4,r3
 203de14:	2807883a 	mov	r3,r5
 203de18:	20c6b03a 	or	r3,r4,r3
 203de1c:	10c000c5 	stb	r3,3(r2)
    IPH_CHKSUM_SET(iphdr, 0);
 203de20:	e0bff517 	ldw	r2,-44(fp)
 203de24:	10c00283 	ldbu	r3,10(r2)
 203de28:	1806703a 	and	r3,r3,zero
 203de2c:	10c00285 	stb	r3,10(r2)
 203de30:	10c002c3 	ldbu	r3,11(r2)
 203de34:	1806703a 	and	r3,r3,zero
 203de38:	10c002c5 	stb	r3,11(r2)
#if CHECKSUM_GEN_IP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 203de3c:	01400504 	movi	r5,20
 203de40:	e13ff517 	ldw	r4,-44(fp)
 203de44:	203a1c40 	call	203a1c4 <inet_chksum>
 203de48:	100d883a 	mov	r6,r2
 203de4c:	e0bff517 	ldw	r2,-44(fp)
 203de50:	30ffffcc 	andi	r3,r6,65535
 203de54:	19403fcc 	andi	r5,r3,255
 203de58:	10c00283 	ldbu	r3,10(r2)
 203de5c:	1806703a 	and	r3,r3,zero
 203de60:	1809883a 	mov	r4,r3
 203de64:	2807883a 	mov	r3,r5
 203de68:	20c6b03a 	or	r3,r4,r3
 203de6c:	10c00285 	stb	r3,10(r2)
 203de70:	30ffffcc 	andi	r3,r6,65535
 203de74:	1806d23a 	srli	r3,r3,8
 203de78:	197fffcc 	andi	r5,r3,65535
 203de7c:	10c002c3 	ldbu	r3,11(r2)
 203de80:	1806703a 	and	r3,r3,zero
 203de84:	1809883a 	mov	r4,r3
 203de88:	2807883a 	mov	r3,r5
 203de8c:	20c6b03a 	or	r3,r4,r3
 203de90:	10c002c5 	stb	r3,11(r2)
#endif /* CHECKSUM_GEN_IP */

    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 203de94:	e0bffe17 	ldw	r2,-8(fp)
 203de98:	10800517 	ldw	r2,20(r2)
 203de9c:	e1bfff17 	ldw	r6,-4(fp)
 203dea0:	e17ff817 	ldw	r5,-32(fp)
 203dea4:	e13ffe17 	ldw	r4,-8(fp)
 203dea8:	103ee83a 	callr	r2
    IPFRAG_STATS_INC(ip_frag.xmit);
 203deac:	008085f4 	movhi	r2,535
 203deb0:	10bd8204 	addi	r2,r2,-2552
 203deb4:	10801817 	ldw	r2,96(r2)
 203deb8:	10c00044 	addi	r3,r2,1
 203debc:	008085f4 	movhi	r2,535
 203dec0:	10bd8204 	addi	r2,r2,-2552
 203dec4:	10c01815 	stw	r3,96(r2)
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */

    pbuf_free(rambuf);
 203dec8:	e13ff817 	ldw	r4,-32(fp)
 203decc:	201d2f40 	call	201d2f4 <pbuf_free>
    left = (u16_t)(left - fragsize);
 203ded0:	e0fff10b 	ldhu	r3,-60(fp)
 203ded4:	e0bff70b 	ldhu	r2,-36(fp)
 203ded8:	1885c83a 	sub	r2,r3,r2
 203dedc:	e0bff10d 	sth	r2,-60(fp)
    ofo = (u16_t)(ofo + nfb);
 203dee0:	e0fff18b 	ldhu	r3,-58(fp)
 203dee4:	e0bff30b 	ldhu	r2,-52(fp)
 203dee8:	1885883a 	add	r2,r3,r2
 203deec:	e0bff18d 	sth	r2,-58(fp)
  /* already fragmented? if so, the last fragment we create must have MF, too */
  mf_set = tmp & IP_MF;

  left = (u16_t)(p->tot_len - IP_HLEN);

  while (left) {
 203def0:	e0bff10b 	ldhu	r2,-60(fp)
 203def4:	103f231e 	bne	r2,zero,203db84 <__alt_mem_mem_0+0xfd01db84>
    pbuf_free(rambuf);
    left = (u16_t)(left - fragsize);
    ofo = (u16_t)(ofo + nfb);
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
 203def8:	0005883a 	mov	r2,zero
 203defc:	00000206 	br	203df08 <ip4_frag+0x474>
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    if (rambuf == NULL) {
      goto memerr;
 203df00:	0001883a 	nop
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
 203df04:	00bfffc4 	movi	r2,-1
}
 203df08:	e037883a 	mov	sp,fp
 203df0c:	dfc00117 	ldw	ra,4(sp)
 203df10:	df000017 	ldw	fp,0(sp)
 203df14:	dec00204 	addi	sp,sp,8
 203df18:	f800283a 	ret

0203df1c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 203df1c:	defffa04 	addi	sp,sp,-24
 203df20:	dfc00515 	stw	ra,20(sp)
 203df24:	df000415 	stw	fp,16(sp)
 203df28:	df000404 	addi	fp,sp,16
 203df2c:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 203df30:	008000c4 	movi	r2,3
 203df34:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 203df38:	e0fffd17 	ldw	r3,-12(fp)
 203df3c:	008003f4 	movhi	r2,15
 203df40:	10909004 	addi	r2,r2,16960
 203df44:	1885383a 	mul	r2,r3,r2
 203df48:	100b883a 	mov	r5,r2
 203df4c:	01017db4 	movhi	r4,1526
 203df50:	21384004 	addi	r4,r4,-7936
 203df54:	200aadc0 	call	200aadc <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 203df58:	100b883a 	mov	r5,r2
 203df5c:	01200034 	movhi	r4,32768
 203df60:	213fffc4 	addi	r4,r4,-1
 203df64:	200aadc0 	call	200aadc <__udivsi3>
 203df68:	100b883a 	mov	r5,r2
 203df6c:	e13fff17 	ldw	r4,-4(fp)
 203df70:	200aadc0 	call	200aadc <__udivsi3>
 203df74:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 203df78:	e0bffe17 	ldw	r2,-8(fp)
 203df7c:	10002a26 	beq	r2,zero,203e028 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 203df80:	e03ffc15 	stw	zero,-16(fp)
 203df84:	00001706 	br	203dfe4 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 203df88:	00a00034 	movhi	r2,32768
 203df8c:	10bfffc4 	addi	r2,r2,-1
 203df90:	10bfffc4 	addi	r2,r2,-1
 203df94:	103ffe1e 	bne	r2,zero,203df90 <__alt_mem_mem_0+0xfd01df90>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 203df98:	e0fffd17 	ldw	r3,-12(fp)
 203df9c:	008003f4 	movhi	r2,15
 203dfa0:	10909004 	addi	r2,r2,16960
 203dfa4:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 203dfa8:	100b883a 	mov	r5,r2
 203dfac:	01017db4 	movhi	r4,1526
 203dfb0:	21384004 	addi	r4,r4,-7936
 203dfb4:	200aadc0 	call	200aadc <__udivsi3>
 203dfb8:	100b883a 	mov	r5,r2
 203dfbc:	01200034 	movhi	r4,32768
 203dfc0:	213fffc4 	addi	r4,r4,-1
 203dfc4:	200aadc0 	call	200aadc <__udivsi3>
 203dfc8:	1007883a 	mov	r3,r2
 203dfcc:	e0bfff17 	ldw	r2,-4(fp)
 203dfd0:	10c5c83a 	sub	r2,r2,r3
 203dfd4:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 203dfd8:	e0bffc17 	ldw	r2,-16(fp)
 203dfdc:	10800044 	addi	r2,r2,1
 203dfe0:	e0bffc15 	stw	r2,-16(fp)
 203dfe4:	e0fffc17 	ldw	r3,-16(fp)
 203dfe8:	e0bffe17 	ldw	r2,-8(fp)
 203dfec:	18bfe616 	blt	r3,r2,203df88 <__alt_mem_mem_0+0xfd01df88>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 203dff0:	e0fffd17 	ldw	r3,-12(fp)
 203dff4:	008003f4 	movhi	r2,15
 203dff8:	10909004 	addi	r2,r2,16960
 203dffc:	1885383a 	mul	r2,r3,r2
 203e000:	100b883a 	mov	r5,r2
 203e004:	01017db4 	movhi	r4,1526
 203e008:	21384004 	addi	r4,r4,-7936
 203e00c:	200aadc0 	call	200aadc <__udivsi3>
 203e010:	1007883a 	mov	r3,r2
 203e014:	e0bfff17 	ldw	r2,-4(fp)
 203e018:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 203e01c:	10bfffc4 	addi	r2,r2,-1
 203e020:	103ffe1e 	bne	r2,zero,203e01c <__alt_mem_mem_0+0xfd01e01c>
 203e024:	00000d06 	br	203e05c <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 203e028:	e0fffd17 	ldw	r3,-12(fp)
 203e02c:	008003f4 	movhi	r2,15
 203e030:	10909004 	addi	r2,r2,16960
 203e034:	1885383a 	mul	r2,r3,r2
 203e038:	100b883a 	mov	r5,r2
 203e03c:	01017db4 	movhi	r4,1526
 203e040:	21384004 	addi	r4,r4,-7936
 203e044:	200aadc0 	call	200aadc <__udivsi3>
 203e048:	1007883a 	mov	r3,r2
 203e04c:	e0bfff17 	ldw	r2,-4(fp)
 203e050:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 203e054:	10bfffc4 	addi	r2,r2,-1
 203e058:	00bffe16 	blt	zero,r2,203e054 <__alt_mem_mem_0+0xfd01e054>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 203e05c:	0005883a 	mov	r2,zero
}
 203e060:	e037883a 	mov	sp,fp
 203e064:	dfc00117 	ldw	ra,4(sp)
 203e068:	df000017 	ldw	fp,0(sp)
 203e06c:	dec00204 	addi	sp,sp,8
 203e070:	f800283a 	ret

0203e074 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 203e074:	defffb04 	addi	sp,sp,-20
 203e078:	df000415 	stw	fp,16(sp)
 203e07c:	df000404 	addi	fp,sp,16
 203e080:	e13ffe15 	stw	r4,-8(fp)
 203e084:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 203e088:	e0bfff17 	ldw	r2,-4(fp)
 203e08c:	10900070 	cmpltui	r2,r2,16385
 203e090:	1000021e 	bne	r2,zero,203e09c <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 203e094:	00900004 	movi	r2,16384
 203e098:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 203e09c:	e0fffe17 	ldw	r3,-8(fp)
 203e0a0:	e0bfff17 	ldw	r2,-4(fp)
 203e0a4:	1885883a 	add	r2,r3,r2
 203e0a8:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 203e0ac:	e0bffe17 	ldw	r2,-8(fp)
 203e0b0:	e0bffc15 	stw	r2,-16(fp)
 203e0b4:	00000506 	br	203e0cc <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 203e0b8:	e0bffc17 	ldw	r2,-16(fp)
 203e0bc:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 203e0c0:	e0bffc17 	ldw	r2,-16(fp)
 203e0c4:	10800804 	addi	r2,r2,32
 203e0c8:	e0bffc15 	stw	r2,-16(fp)
 203e0cc:	e0fffc17 	ldw	r3,-16(fp)
 203e0d0:	e0bffd17 	ldw	r2,-12(fp)
 203e0d4:	18bff836 	bltu	r3,r2,203e0b8 <__alt_mem_mem_0+0xfd01e0b8>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 203e0d8:	e0bffe17 	ldw	r2,-8(fp)
 203e0dc:	108007cc 	andi	r2,r2,31
 203e0e0:	10000226 	beq	r2,zero,203e0ec <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 203e0e4:	e0bffc17 	ldw	r2,-16(fp)
 203e0e8:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 203e0ec:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 203e0f0:	0001883a 	nop
 203e0f4:	e037883a 	mov	sp,fp
 203e0f8:	df000017 	ldw	fp,0(sp)
 203e0fc:	dec00104 	addi	sp,sp,4
 203e100:	f800283a 	ret

0203e104 <netconn_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
static err_t
netconn_apimsg(tcpip_callback_fn fn, struct api_msg *apimsg)
{
 203e104:	defffb04 	addi	sp,sp,-20
 203e108:	dfc00415 	stw	ra,16(sp)
 203e10c:	df000315 	stw	fp,12(sp)
 203e110:	df000304 	addi	fp,sp,12
 203e114:	e13ffe15 	stw	r4,-8(fp)
 203e118:	e17fff15 	stw	r5,-4(fp)

#if LWIP_NETCONN_SEM_PER_THREAD
  apimsg->op_completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

  err = tcpip_send_msg_wait_sem(fn, apimsg, LWIP_API_MSG_SEM(apimsg));
 203e11c:	e0bfff17 	ldw	r2,-4(fp)
 203e120:	10800017 	ldw	r2,0(r2)
 203e124:	10800404 	addi	r2,r2,16
 203e128:	100d883a 	mov	r6,r2
 203e12c:	e17fff17 	ldw	r5,-4(fp)
 203e130:	e13ffe17 	ldw	r4,-8(fp)
 203e134:	20340b80 	call	20340b8 <tcpip_send_msg_wait_sem>
 203e138:	e0bffd05 	stb	r2,-12(fp)
  if (err == ERR_OK) {
 203e13c:	e0bffd07 	ldb	r2,-12(fp)
 203e140:	1000031e 	bne	r2,zero,203e150 <netconn_apimsg+0x4c>
    return apimsg->err;
 203e144:	e0bfff17 	ldw	r2,-4(fp)
 203e148:	10800103 	ldbu	r2,4(r2)
 203e14c:	00000106 	br	203e154 <netconn_apimsg+0x50>
  }
  return err;
 203e150:	e0bffd03 	ldbu	r2,-12(fp)
}
 203e154:	e037883a 	mov	sp,fp
 203e158:	dfc00117 	ldw	ra,4(sp)
 203e15c:	df000017 	ldw	fp,0(sp)
 203e160:	dec00204 	addi	sp,sp,8
 203e164:	f800283a 	ret

0203e168 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn *
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
 203e168:	defff104 	addi	sp,sp,-60
 203e16c:	dfc00e15 	stw	ra,56(sp)
 203e170:	df000d15 	stw	fp,52(sp)
 203e174:	df000d04 	addi	fp,sp,52
 203e178:	e13ffd15 	stw	r4,-12(fp)
 203e17c:	2805883a 	mov	r2,r5
 203e180:	e1bfff15 	stw	r6,-4(fp)
 203e184:	e0bffe05 	stb	r2,-8(fp)
  struct netconn *conn;
  API_MSG_VAR_DECLARE(msg);
  API_MSG_VAR_ALLOC_RETURN_NULL(msg);

  conn = netconn_alloc(t, callback);
 203e188:	e17fff17 	ldw	r5,-4(fp)
 203e18c:	e13ffd17 	ldw	r4,-12(fp)
 203e190:	20401100 	call	2040110 <netconn_alloc>
 203e194:	e0bff315 	stw	r2,-52(fp)
  if (conn != NULL) {
 203e198:	e0bff317 	ldw	r2,-52(fp)
 203e19c:	10001926 	beq	r2,zero,203e204 <netconn_new_with_proto_and_callback+0x9c>
    err_t err;

    API_MSG_VAR_REF(msg).msg.n.proto = proto;
 203e1a0:	e0bffe03 	ldbu	r2,-8(fp)
 203e1a4:	e0bff705 	stb	r2,-36(fp)
    API_MSG_VAR_REF(msg).conn = conn;
 203e1a8:	e0bff317 	ldw	r2,-52(fp)
 203e1ac:	e0bff515 	stw	r2,-44(fp)
    err = netconn_apimsg(lwip_netconn_do_newconn, &API_MSG_VAR_REF(msg));
 203e1b0:	e0bff504 	addi	r2,fp,-44
 203e1b4:	100b883a 	mov	r5,r2
 203e1b8:	01008134 	movhi	r4,516
 203e1bc:	21002a04 	addi	r4,r4,168
 203e1c0:	203e1040 	call	203e104 <netconn_apimsg>
 203e1c4:	e0bff405 	stb	r2,-48(fp)
    if (err != ERR_OK) {
 203e1c8:	e0bff407 	ldb	r2,-48(fp)
 203e1cc:	10000d26 	beq	r2,zero,203e204 <netconn_new_with_proto_and_callback+0x9c>
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */
#if !LWIP_NETCONN_SEM_PER_THREAD
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
      sys_sem_free(&conn->op_completed);
 203e1d0:	e0bff317 	ldw	r2,-52(fp)
 203e1d4:	10800404 	addi	r2,r2,16
 203e1d8:	1009883a 	mov	r4,r2
 203e1dc:	20151040 	call	2015104 <sys_sem_free>
#endif /* !LWIP_NETCONN_SEM_PER_THREAD */
      sys_mbox_free(&conn->recvmbox);
 203e1e0:	e0bff317 	ldw	r2,-52(fp)
 203e1e4:	10800504 	addi	r2,r2,20
 203e1e8:	1009883a 	mov	r4,r2
 203e1ec:	20154c80 	call	20154c8 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
 203e1f0:	e17ff317 	ldw	r5,-52(fp)
 203e1f4:	01000204 	movi	r4,8
 203e1f8:	201b9640 	call	201b964 <memp_free>
      API_MSG_VAR_FREE(msg);
      return NULL;
 203e1fc:	0005883a 	mov	r2,zero
 203e200:	00000106 	br	203e208 <netconn_new_with_proto_and_callback+0xa0>
    }
  }
  API_MSG_VAR_FREE(msg);
  return conn;
 203e204:	e0bff317 	ldw	r2,-52(fp)
}
 203e208:	e037883a 	mov	sp,fp
 203e20c:	dfc00117 	ldw	ra,4(sp)
 203e210:	df000017 	ldw	fp,0(sp)
 203e214:	dec00204 	addi	sp,sp,8
 203e218:	f800283a 	ret

0203e21c <netconn_prepare_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_prepare_delete(struct netconn *conn)
{
 203e21c:	defff404 	addi	sp,sp,-48
 203e220:	dfc00b15 	stw	ra,44(sp)
 203e224:	df000a15 	stw	fp,40(sp)
 203e228:	df000a04 	addi	fp,sp,40
 203e22c:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  API_MSG_VAR_DECLARE(msg);

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
 203e230:	e0bfff17 	ldw	r2,-4(fp)
 203e234:	1000021e 	bne	r2,zero,203e240 <netconn_prepare_delete+0x24>
    return ERR_OK;
 203e238:	0005883a 	mov	r2,zero
 203e23c:	00000f06 	br	203e27c <netconn_prepare_delete+0x60>
  }

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203e240:	e0bfff17 	ldw	r2,-4(fp)
 203e244:	e0bff715 	stw	r2,-36(fp)
#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
  /* get the time we started, which is later compared to
     sys_now() + conn->send_timeout */
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
  API_MSG_VAR_REF(msg).msg.sd.polls_left =
 203e248:	00800a44 	movi	r2,41
 203e24c:	e0bff945 	stb	r2,-27(fp)
    ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - 1) / TCP_SLOW_INTERVAL) + 1;
#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
#endif /* LWIP_TCP */
  err = netconn_apimsg(lwip_netconn_do_delconn, &API_MSG_VAR_REF(msg));
 203e250:	e0bff704 	addi	r2,fp,-36
 203e254:	100b883a 	mov	r5,r2
 203e258:	01008134 	movhi	r4,516
 203e25c:	2101dd04 	addi	r4,r4,1908
 203e260:	203e1040 	call	203e104 <netconn_apimsg>
 203e264:	e0bff605 	stb	r2,-40(fp)
  API_MSG_VAR_FREE(msg);

  if (err != ERR_OK) {
 203e268:	e0bff607 	ldb	r2,-40(fp)
 203e26c:	10000226 	beq	r2,zero,203e278 <netconn_prepare_delete+0x5c>
    return err;
 203e270:	e0bff603 	ldbu	r2,-40(fp)
 203e274:	00000106 	br	203e27c <netconn_prepare_delete+0x60>
  }
  return ERR_OK;
 203e278:	0005883a 	mov	r2,zero
}
 203e27c:	e037883a 	mov	sp,fp
 203e280:	dfc00117 	ldw	ra,4(sp)
 203e284:	df000017 	ldw	fp,0(sp)
 203e288:	dec00204 	addi	sp,sp,8
 203e28c:	f800283a 	ret

0203e290 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
 203e290:	defffc04 	addi	sp,sp,-16
 203e294:	dfc00315 	stw	ra,12(sp)
 203e298:	df000215 	stw	fp,8(sp)
 203e29c:	df000204 	addi	fp,sp,8
 203e2a0:	e13fff15 	stw	r4,-4(fp)
  err_t err;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
 203e2a4:	e0bfff17 	ldw	r2,-4(fp)
 203e2a8:	1000021e 	bne	r2,zero,203e2b4 <netconn_delete+0x24>
    return ERR_OK;
 203e2ac:	0005883a 	mov	r2,zero
 203e2b0:	00000806 	br	203e2d4 <netconn_delete+0x44>
    /* Already called netconn_prepare_delete() before */
    err = ERR_OK;
  } else
#endif /* LWIP_NETCONN_FULLDUPLEX */
  {
    err = netconn_prepare_delete(conn);
 203e2b4:	e13fff17 	ldw	r4,-4(fp)
 203e2b8:	203e21c0 	call	203e21c <netconn_prepare_delete>
 203e2bc:	e0bffe05 	stb	r2,-8(fp)
  }
  if (err == ERR_OK) {
 203e2c0:	e0bffe07 	ldb	r2,-8(fp)
 203e2c4:	1000021e 	bne	r2,zero,203e2d0 <netconn_delete+0x40>
    netconn_free(conn);
 203e2c8:	e13fff17 	ldw	r4,-4(fp)
 203e2cc:	204027c0 	call	204027c <netconn_free>
  }
  return err;
 203e2d0:	e0bffe03 	ldbu	r2,-8(fp)
}
 203e2d4:	e037883a 	mov	sp,fp
 203e2d8:	dfc00117 	ldw	ra,4(sp)
 203e2dc:	df000017 	ldw	fp,0(sp)
 203e2e0:	dec00204 	addi	sp,sp,8
 203e2e4:	f800283a 	ret

0203e2e8 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
{
 203e2e8:	defff104 	addi	sp,sp,-60
 203e2ec:	dfc00e15 	stw	ra,56(sp)
 203e2f0:	df000d15 	stw	fp,52(sp)
 203e2f4:	df000d04 	addi	fp,sp,52
 203e2f8:	e13ffc15 	stw	r4,-16(fp)
 203e2fc:	e17ffd15 	stw	r5,-12(fp)
 203e300:	e1bffe15 	stw	r6,-8(fp)
 203e304:	3805883a 	mov	r2,r7
 203e308:	e0bfff05 	stb	r2,-4(fp)
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
 203e30c:	e0bffc17 	ldw	r2,-16(fp)
 203e310:	1000021e 	bne	r2,zero,203e31c <netconn_getaddr+0x34>
 203e314:	00bffc04 	movi	r2,-16
 203e318:	00001706 	br	203e378 <netconn_getaddr+0x90>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
 203e31c:	e0bffd17 	ldw	r2,-12(fp)
 203e320:	1000021e 	bne	r2,zero,203e32c <netconn_getaddr+0x44>
 203e324:	00bffc04 	movi	r2,-16
 203e328:	00001306 	br	203e378 <netconn_getaddr+0x90>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
 203e32c:	e0bffe17 	ldw	r2,-8(fp)
 203e330:	1000021e 	bne	r2,zero,203e33c <netconn_getaddr+0x54>
 203e334:	00bffc04 	movi	r2,-16
 203e338:	00000f06 	br	203e378 <netconn_getaddr+0x90>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203e33c:	e0bffc17 	ldw	r2,-16(fp)
 203e340:	e0bff415 	stw	r2,-48(fp)
  API_MSG_VAR_REF(msg).msg.ad.local = local;
 203e344:	e0bfff03 	ldbu	r2,-4(fp)
 203e348:	e0bff805 	stb	r2,-32(fp)
#if LWIP_MPU_COMPATIBLE
  err = netconn_apimsg(lwip_netconn_do_getaddr, &API_MSG_VAR_REF(msg));
  *addr = msg->msg.ad.ipaddr;
  *port = msg->msg.ad.port;
#else /* LWIP_MPU_COMPATIBLE */
  msg.msg.ad.ipaddr = addr;
 203e34c:	e0bffd17 	ldw	r2,-12(fp)
 203e350:	e0bff615 	stw	r2,-40(fp)
  msg.msg.ad.port = port;
 203e354:	e0bffe17 	ldw	r2,-8(fp)
 203e358:	e0bff715 	stw	r2,-36(fp)
  err = netconn_apimsg(lwip_netconn_do_getaddr, &msg);
 203e35c:	e0bff404 	addi	r2,fp,-48
 203e360:	100b883a 	mov	r5,r2
 203e364:	01008134 	movhi	r4,516
 203e368:	2106c904 	addi	r4,r4,6948
 203e36c:	203e1040 	call	203e104 <netconn_apimsg>
 203e370:	e0bff305 	stb	r2,-52(fp)
#endif /* LWIP_MPU_COMPATIBLE */
  API_MSG_VAR_FREE(msg);

  return err;
 203e374:	e0bff303 	ldbu	r2,-52(fp)
}
 203e378:	e037883a 	mov	sp,fp
 203e37c:	dfc00117 	ldw	ra,4(sp)
 203e380:	df000017 	ldw	fp,0(sp)
 203e384:	dec00204 	addi	sp,sp,8
 203e388:	f800283a 	ret

0203e38c <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, const ip_addr_t *addr, u16_t port)
{
 203e38c:	defff204 	addi	sp,sp,-56
 203e390:	dfc00d15 	stw	ra,52(sp)
 203e394:	df000c15 	stw	fp,48(sp)
 203e398:	df000c04 	addi	fp,sp,48
 203e39c:	e13ffd15 	stw	r4,-12(fp)
 203e3a0:	e17ffe15 	stw	r5,-8(fp)
 203e3a4:	3005883a 	mov	r2,r6
 203e3a8:	e0bfff0d 	sth	r2,-4(fp)
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 203e3ac:	e0bffd17 	ldw	r2,-12(fp)
 203e3b0:	1000021e 	bne	r2,zero,203e3bc <netconn_bind+0x30>
 203e3b4:	00bffc04 	movi	r2,-16
 203e3b8:	00001106 	br	203e400 <netconn_bind+0x74>

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
  if (addr == NULL) {
 203e3bc:	e0bffe17 	ldw	r2,-8(fp)
 203e3c0:	1000021e 	bne	r2,zero,203e3cc <netconn_bind+0x40>
    addr = IP4_ADDR_ANY;
 203e3c4:	d0a00e04 	addi	r2,gp,-32712
 203e3c8:	e0bffe15 	stw	r2,-8(fp)
    addr = IP_ANY_TYPE;
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203e3cc:	e0bffd17 	ldw	r2,-12(fp)
 203e3d0:	e0bff515 	stw	r2,-44(fp)
  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
 203e3d4:	e0bffe17 	ldw	r2,-8(fp)
 203e3d8:	e0bff715 	stw	r2,-36(fp)
  API_MSG_VAR_REF(msg).msg.bc.port = port;
 203e3dc:	e0bfff0b 	ldhu	r2,-4(fp)
 203e3e0:	e0bff80d 	sth	r2,-32(fp)
  err = netconn_apimsg(lwip_netconn_do_bind, &API_MSG_VAR_REF(msg));
 203e3e4:	e0bff504 	addi	r2,fp,-44
 203e3e8:	100b883a 	mov	r5,r2
 203e3ec:	01008134 	movhi	r4,516
 203e3f0:	21026104 	addi	r4,r4,2436
 203e3f4:	203e1040 	call	203e104 <netconn_apimsg>
 203e3f8:	e0bff405 	stb	r2,-48(fp)
  API_MSG_VAR_FREE(msg);

  return err;
 203e3fc:	e0bff403 	ldbu	r2,-48(fp)
}
 203e400:	e037883a 	mov	sp,fp
 203e404:	dfc00117 	ldw	ra,4(sp)
 203e408:	df000017 	ldw	fp,0(sp)
 203e40c:	dec00204 	addi	sp,sp,8
 203e410:	f800283a 	ret

0203e414 <netconn_bind_if>:
 * @param if_idx the local interface index to bind the netconn to
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind_if(struct netconn *conn, u8_t if_idx)
{
 203e414:	defff304 	addi	sp,sp,-52
 203e418:	dfc00c15 	stw	ra,48(sp)
 203e41c:	df000b15 	stw	fp,44(sp)
 203e420:	df000b04 	addi	fp,sp,44
 203e424:	e13ffe15 	stw	r4,-8(fp)
 203e428:	2805883a 	mov	r2,r5
 203e42c:	e0bfff05 	stb	r2,-4(fp)
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_bind_if: invalid conn", (conn != NULL), return ERR_ARG;);
 203e430:	e0bffe17 	ldw	r2,-8(fp)
 203e434:	1000021e 	bne	r2,zero,203e440 <netconn_bind_if+0x2c>
 203e438:	00bffc04 	movi	r2,-16
 203e43c:	00000b06 	br	203e46c <netconn_bind_if+0x58>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203e440:	e0bffe17 	ldw	r2,-8(fp)
 203e444:	e0bff615 	stw	r2,-40(fp)
  API_MSG_VAR_REF(msg).msg.bc.if_idx = if_idx;
 203e448:	e0bfff03 	ldbu	r2,-4(fp)
 203e44c:	e0bff985 	stb	r2,-26(fp)
  err = netconn_apimsg(lwip_netconn_do_bind_if, &API_MSG_VAR_REF(msg));
 203e450:	e0bff604 	addi	r2,fp,-40
 203e454:	100b883a 	mov	r5,r2
 203e458:	01008134 	movhi	r4,516
 203e45c:	2102b104 	addi	r4,r4,2756
 203e460:	203e1040 	call	203e104 <netconn_apimsg>
 203e464:	e0bff505 	stb	r2,-44(fp)
  API_MSG_VAR_FREE(msg);

  return err;
 203e468:	e0bff503 	ldbu	r2,-44(fp)
}
 203e46c:	e037883a 	mov	sp,fp
 203e470:	dfc00117 	ldw	ra,4(sp)
 203e474:	df000017 	ldw	fp,0(sp)
 203e478:	dec00204 	addi	sp,sp,8
 203e47c:	f800283a 	ret

0203e480 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, const ip_addr_t *addr, u16_t port)
{
 203e480:	defff204 	addi	sp,sp,-56
 203e484:	dfc00d15 	stw	ra,52(sp)
 203e488:	df000c15 	stw	fp,48(sp)
 203e48c:	df000c04 	addi	fp,sp,48
 203e490:	e13ffd15 	stw	r4,-12(fp)
 203e494:	e17ffe15 	stw	r5,-8(fp)
 203e498:	3005883a 	mov	r2,r6
 203e49c:	e0bfff0d 	sth	r2,-4(fp)
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 203e4a0:	e0bffd17 	ldw	r2,-12(fp)
 203e4a4:	1000021e 	bne	r2,zero,203e4b0 <netconn_connect+0x30>
 203e4a8:	00bffc04 	movi	r2,-16
 203e4ac:	00001106 	br	203e4f4 <netconn_connect+0x74>

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
  if (addr == NULL) {
 203e4b0:	e0bffe17 	ldw	r2,-8(fp)
 203e4b4:	1000021e 	bne	r2,zero,203e4c0 <netconn_connect+0x40>
    addr = IP4_ADDR_ANY;
 203e4b8:	d0a00e04 	addi	r2,gp,-32712
 203e4bc:	e0bffe15 	stw	r2,-8(fp)
  }
#endif /* LWIP_IPV4 */

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203e4c0:	e0bffd17 	ldw	r2,-12(fp)
 203e4c4:	e0bff515 	stw	r2,-44(fp)
  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
 203e4c8:	e0bffe17 	ldw	r2,-8(fp)
 203e4cc:	e0bff715 	stw	r2,-36(fp)
  API_MSG_VAR_REF(msg).msg.bc.port = port;
 203e4d0:	e0bfff0b 	ldhu	r2,-4(fp)
 203e4d4:	e0bff80d 	sth	r2,-32(fp)
  err = netconn_apimsg(lwip_netconn_do_connect, &API_MSG_VAR_REF(msg));
 203e4d8:	e0bff504 	addi	r2,fp,-44
 203e4dc:	100b883a 	mov	r5,r2
 203e4e0:	01008134 	movhi	r4,516
 203e4e4:	21034204 	addi	r4,r4,3336
 203e4e8:	203e1040 	call	203e104 <netconn_apimsg>
 203e4ec:	e0bff405 	stb	r2,-48(fp)
  API_MSG_VAR_FREE(msg);

  return err;
 203e4f0:	e0bff403 	ldbu	r2,-48(fp)
}
 203e4f4:	e037883a 	mov	sp,fp
 203e4f8:	dfc00117 	ldw	ra,4(sp)
 203e4fc:	df000017 	ldw	fp,0(sp)
 203e500:	dec00204 	addi	sp,sp,8
 203e504:	f800283a 	ret

0203e508 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return See @ref err_t
 */
err_t
netconn_disconnect(struct netconn *conn)
{
 203e508:	defff404 	addi	sp,sp,-48
 203e50c:	dfc00b15 	stw	ra,44(sp)
 203e510:	df000a15 	stw	fp,40(sp)
 203e514:	df000a04 	addi	fp,sp,40
 203e518:	e13fff15 	stw	r4,-4(fp)
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
 203e51c:	e0bfff17 	ldw	r2,-4(fp)
 203e520:	1000021e 	bne	r2,zero,203e52c <netconn_disconnect+0x24>
 203e524:	00bffc04 	movi	r2,-16
 203e528:	00000906 	br	203e550 <netconn_disconnect+0x48>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203e52c:	e0bfff17 	ldw	r2,-4(fp)
 203e530:	e0bff715 	stw	r2,-36(fp)
  err = netconn_apimsg(lwip_netconn_do_disconnect, &API_MSG_VAR_REF(msg));
 203e534:	e0bff704 	addi	r2,fp,-36
 203e538:	100b883a 	mov	r5,r2
 203e53c:	01008134 	movhi	r4,516
 203e540:	2103cf04 	addi	r4,r4,3900
 203e544:	203e1040 	call	203e104 <netconn_apimsg>
 203e548:	e0bff605 	stb	r2,-40(fp)
  API_MSG_VAR_FREE(msg);

  return err;
 203e54c:	e0bff603 	ldbu	r2,-40(fp)
}
 203e550:	e037883a 	mov	sp,fp
 203e554:	dfc00117 	ldw	ra,4(sp)
 203e558:	df000017 	ldw	fp,0(sp)
 203e55c:	dec00204 	addi	sp,sp,8
 203e560:	f800283a 	ret

0203e564 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
 203e564:	defff304 	addi	sp,sp,-52
 203e568:	dfc00c15 	stw	ra,48(sp)
 203e56c:	df000b15 	stw	fp,44(sp)
 203e570:	df000b04 	addi	fp,sp,44
 203e574:	e13ffe15 	stw	r4,-8(fp)
 203e578:	2805883a 	mov	r2,r5
 203e57c:	e0bfff05 	stb	r2,-4(fp)
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 203e580:	e0bffe17 	ldw	r2,-8(fp)
 203e584:	1000021e 	bne	r2,zero,203e590 <netconn_listen_with_backlog+0x2c>
 203e588:	00bffc04 	movi	r2,-16
 203e58c:	00000b06 	br	203e5bc <netconn_listen_with_backlog+0x58>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203e590:	e0bffe17 	ldw	r2,-8(fp)
 203e594:	e0bff615 	stw	r2,-40(fp)
#if TCP_LISTEN_BACKLOG
  API_MSG_VAR_REF(msg).msg.lb.backlog = backlog;
 203e598:	e0bfff03 	ldbu	r2,-4(fp)
 203e59c:	e0bff805 	stb	r2,-32(fp)
#endif /* TCP_LISTEN_BACKLOG */
  err = netconn_apimsg(lwip_netconn_do_listen, &API_MSG_VAR_REF(msg));
 203e5a0:	e0bff604 	addi	r2,fp,-40
 203e5a4:	100b883a 	mov	r5,r2
 203e5a8:	01008134 	movhi	r4,516
 203e5ac:	2103f204 	addi	r4,r4,4040
 203e5b0:	203e1040 	call	203e104 <netconn_apimsg>
 203e5b4:	e0bff505 	stb	r2,-44(fp)
  API_MSG_VAR_FREE(msg);

  return err;
 203e5b8:	e0bff503 	ldbu	r2,-44(fp)
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(backlog);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 203e5bc:	e037883a 	mov	sp,fp
 203e5c0:	dfc00117 	ldw	ra,4(sp)
 203e5c4:	df000017 	ldw	fp,0(sp)
 203e5c8:	dec00204 	addi	sp,sp,8
 203e5cc:	f800283a 	ret

0203e5d0 <netconn_accept>:
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
 203e5d0:	defff104 	addi	sp,sp,-60
 203e5d4:	dfc00e15 	stw	ra,56(sp)
 203e5d8:	df000d15 	stw	fp,52(sp)
 203e5dc:	df000d04 	addi	fp,sp,52
 203e5e0:	e13ffe15 	stw	r4,-8(fp)
 203e5e4:	e17fff15 	stw	r5,-4(fp)
  struct netconn *newconn;
#if TCP_LISTEN_BACKLOG
  API_MSG_VAR_DECLARE(msg);
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 203e5e8:	e0bfff17 	ldw	r2,-4(fp)
 203e5ec:	1000021e 	bne	r2,zero,203e5f8 <netconn_accept+0x28>
 203e5f0:	00bffc04 	movi	r2,-16
 203e5f4:	00005b06 	br	203e764 <netconn_accept+0x194>
  *new_conn = NULL;
 203e5f8:	e0bfff17 	ldw	r2,-4(fp)
 203e5fc:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 203e600:	e0bffe17 	ldw	r2,-8(fp)
 203e604:	1000021e 	bne	r2,zero,203e610 <netconn_accept+0x40>
 203e608:	00bffc04 	movi	r2,-16
 203e60c:	00005506 	br	203e764 <netconn_accept+0x194>

  /* NOTE: Although the opengroup spec says a pending error shall be returned to
           send/recv/getsockopt(SO_ERROR) only, we return it for listening
           connections also, to handle embedded-system errors */
  err = netconn_err(conn);
 203e610:	e13ffe17 	ldw	r4,-8(fp)
 203e614:	203f2800 	call	203f280 <netconn_err>
 203e618:	e0bff405 	stb	r2,-48(fp)
  if (err != ERR_OK) {
 203e61c:	e0bff403 	ldbu	r2,-48(fp)
 203e620:	10803fcc 	andi	r2,r2,255
 203e624:	1080201c 	xori	r2,r2,128
 203e628:	10bfe004 	addi	r2,r2,-128
 203e62c:	10000226 	beq	r2,zero,203e638 <netconn_accept+0x68>
    /* return pending error */
    return err;
 203e630:	e0bff403 	ldbu	r2,-48(fp)
 203e634:	00004b06 	br	203e764 <netconn_accept+0x194>
  }
  if (!NETCONN_ACCEPTMBOX_WAITABLE(conn)) {
 203e638:	e0bffe17 	ldw	r2,-8(fp)
 203e63c:	10800604 	addi	r2,r2,24
 203e640:	10000826 	beq	r2,zero,203e664 <netconn_accept+0x94>
 203e644:	e0bffe17 	ldw	r2,-8(fp)
 203e648:	10800617 	ldw	r2,24(r2)
 203e64c:	10000526 	beq	r2,zero,203e664 <netconn_accept+0x94>
 203e650:	e0bffe17 	ldw	r2,-8(fp)
 203e654:	10800903 	ldbu	r2,36(r2)
 203e658:	10803fcc 	andi	r2,r2,255
 203e65c:	1080004c 	andi	r2,r2,1
 203e660:	10000226 	beq	r2,zero,203e66c <netconn_accept+0x9c>
    /* don't accept if closed: this might block the application task
       waiting on acceptmbox forever! */
    return ERR_CLSD;
 203e664:	00bffc44 	movi	r2,-15
 203e668:	00003e06 	br	203e764 <netconn_accept+0x194>
  }

  API_MSG_VAR_ALLOC_ACCEPT(msg);

  NETCONN_MBOX_WAITING_INC(conn);
  if (netconn_is_nonblocking(conn)) {
 203e66c:	e0bffe17 	ldw	r2,-8(fp)
 203e670:	10800903 	ldbu	r2,36(r2)
 203e674:	10803fcc 	andi	r2,r2,255
 203e678:	1080008c 	andi	r2,r2,2
 203e67c:	10000a26 	beq	r2,zero,203e6a8 <netconn_accept+0xd8>
    if (sys_arch_mbox_tryfetch(&conn->acceptmbox, &accept_ptr) == SYS_MBOX_EMPTY) {
 203e680:	e0bffe17 	ldw	r2,-8(fp)
 203e684:	10800604 	addi	r2,r2,24
 203e688:	e0fff504 	addi	r3,fp,-44
 203e68c:	180b883a 	mov	r5,r3
 203e690:	1009883a 	mov	r4,r2
 203e694:	20154540 	call	2015454 <sys_arch_mbox_tryfetch>
 203e698:	10bfffd8 	cmpnei	r2,r2,-1
 203e69c:	10000f1e 	bne	r2,zero,203e6dc <netconn_accept+0x10c>
      API_MSG_VAR_FREE_ACCEPT(msg);
      NETCONN_MBOX_WAITING_DEC(conn);
      return ERR_WOULDBLOCK;
 203e6a0:	00bffe44 	movi	r2,-7
 203e6a4:	00002f06 	br	203e764 <netconn_accept+0x194>
    }
  } else {
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
 203e6a8:	e0bffe17 	ldw	r2,-8(fp)
 203e6ac:	10c00604 	addi	r3,r2,24
 203e6b0:	e0bffe17 	ldw	r2,-8(fp)
 203e6b4:	11000817 	ldw	r4,32(r2)
 203e6b8:	e0bff504 	addi	r2,fp,-44
 203e6bc:	200d883a 	mov	r6,r4
 203e6c0:	100b883a 	mov	r5,r2
 203e6c4:	1809883a 	mov	r4,r3
 203e6c8:	20153ac0 	call	20153ac <sys_arch_mbox_fetch>
 203e6cc:	10bfffd8 	cmpnei	r2,r2,-1
 203e6d0:	1000021e 	bne	r2,zero,203e6dc <netconn_accept+0x10c>
      API_MSG_VAR_FREE_ACCEPT(msg);
      NETCONN_MBOX_WAITING_DEC(conn);
      return ERR_TIMEOUT;
 203e6d4:	00bfff44 	movi	r2,-3
 203e6d8:	00002206 	br	203e764 <netconn_accept+0x194>
    }
  }
#endif

  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 203e6dc:	e0bffe17 	ldw	r2,-8(fp)
 203e6e0:	10800b17 	ldw	r2,44(r2)
 203e6e4:	10000626 	beq	r2,zero,203e700 <netconn_accept+0x130>
 203e6e8:	e0bffe17 	ldw	r2,-8(fp)
 203e6ec:	10800b17 	ldw	r2,44(r2)
 203e6f0:	000d883a 	mov	r6,zero
 203e6f4:	01400044 	movi	r5,1
 203e6f8:	e13ffe17 	ldw	r4,-8(fp)
 203e6fc:	103ee83a 	callr	r2

  if (lwip_netconn_is_err_msg(accept_ptr, &err)) {
 203e700:	e0bff517 	ldw	r2,-44(fp)
 203e704:	e0fff404 	addi	r3,fp,-48
 203e708:	180b883a 	mov	r5,r3
 203e70c:	1009883a 	mov	r4,r2
 203e710:	203f3b40 	call	203f3b4 <lwip_netconn_is_err_msg>
 203e714:	10000226 	beq	r2,zero,203e720 <netconn_accept+0x150>
    /* a connection has been aborted: e.g. out of pcbs or out of netconns during accept */
    API_MSG_VAR_FREE_ACCEPT(msg);
    return err;
 203e718:	e0bff403 	ldbu	r2,-48(fp)
 203e71c:	00001106 	br	203e764 <netconn_accept+0x194>
  }
  if (accept_ptr == NULL) {
 203e720:	e0bff517 	ldw	r2,-44(fp)
 203e724:	1000021e 	bne	r2,zero,203e730 <netconn_accept+0x160>
    /* connection has been aborted */
    API_MSG_VAR_FREE_ACCEPT(msg);
    return ERR_CLSD;
 203e728:	00bffc44 	movi	r2,-15
 203e72c:	00000d06 	br	203e764 <netconn_accept+0x194>
  }
  newconn = (struct netconn *)accept_ptr;
 203e730:	e0bff517 	ldw	r2,-44(fp)
 203e734:	e0bff315 	stw	r2,-52(fp)
#if TCP_LISTEN_BACKLOG
  /* Let the stack know that we have accepted the connection. */
  API_MSG_VAR_REF(msg).conn = newconn;
 203e738:	e0bff317 	ldw	r2,-52(fp)
 203e73c:	e0bff615 	stw	r2,-40(fp)
  /* don't care for the return value of lwip_netconn_do_recv */
  netconn_apimsg(lwip_netconn_do_accepted, &API_MSG_VAR_REF(msg));
 203e740:	e0bff604 	addi	r2,fp,-40
 203e744:	100b883a 	mov	r5,r2
 203e748:	01008134 	movhi	r4,516
 203e74c:	21054804 	addi	r4,r4,5408
 203e750:	203e1040 	call	203e104 <netconn_apimsg>
  API_MSG_VAR_FREE(msg);
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
 203e754:	e0bfff17 	ldw	r2,-4(fp)
 203e758:	e0fff317 	ldw	r3,-52(fp)
 203e75c:	10c00015 	stw	r3,0(r2)
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 203e760:	0005883a 	mov	r2,zero
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 203e764:	e037883a 	mov	sp,fp
 203e768:	dfc00117 	ldw	ra,4(sp)
 203e76c:	df000017 	ldw	fp,0(sp)
 203e770:	dec00204 	addi	sp,sp,8
 203e774:	f800283a 	ret

0203e778 <netconn_recv_data>:
 *         ERR_WOULDBLOCK if the netconn is nonblocking but would block to wait for data
 *         ERR_TIMEOUT if the netconn has a receive timeout and no data was received
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf, u8_t apiflags)
{
 203e778:	defff804 	addi	sp,sp,-32
 203e77c:	dfc00715 	stw	ra,28(sp)
 203e780:	df000615 	stw	fp,24(sp)
 203e784:	df000604 	addi	fp,sp,24
 203e788:	e13ffd15 	stw	r4,-12(fp)
 203e78c:	e17ffe15 	stw	r5,-8(fp)
 203e790:	3005883a 	mov	r2,r6
 203e794:	e0bfff05 	stb	r2,-4(fp)
  void *buf = NULL;
 203e798:	e03ffb15 	stw	zero,-20(fp)
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 203e79c:	e0bffe17 	ldw	r2,-8(fp)
 203e7a0:	1000021e 	bne	r2,zero,203e7ac <netconn_recv_data+0x34>
 203e7a4:	00bffc04 	movi	r2,-16
 203e7a8:	00007806 	br	203e98c <netconn_recv_data+0x214>
  *new_buf = NULL;
 203e7ac:	e0bffe17 	ldw	r2,-8(fp)
 203e7b0:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 203e7b4:	e0bffd17 	ldw	r2,-12(fp)
 203e7b8:	1000021e 	bne	r2,zero,203e7c4 <netconn_recv_data+0x4c>
 203e7bc:	00bffc04 	movi	r2,-16
 203e7c0:	00007206 	br	203e98c <netconn_recv_data+0x214>

  if (!NETCONN_RECVMBOX_WAITABLE(conn)) {
 203e7c4:	e0bffd17 	ldw	r2,-12(fp)
 203e7c8:	10800504 	addi	r2,r2,20
 203e7cc:	10000326 	beq	r2,zero,203e7dc <netconn_recv_data+0x64>
 203e7d0:	e0bffd17 	ldw	r2,-12(fp)
 203e7d4:	10800517 	ldw	r2,20(r2)
 203e7d8:	1000091e 	bne	r2,zero,203e800 <netconn_recv_data+0x88>
    err_t err = netconn_err(conn);
 203e7dc:	e13ffd17 	ldw	r4,-12(fp)
 203e7e0:	203f2800 	call	203f280 <netconn_err>
 203e7e4:	e0bffac5 	stb	r2,-21(fp)
    if (err != ERR_OK) {
 203e7e8:	e0bffac7 	ldb	r2,-21(fp)
 203e7ec:	10000226 	beq	r2,zero,203e7f8 <netconn_recv_data+0x80>
      /* return pending error */
      return err;
 203e7f0:	e0bffac3 	ldbu	r2,-21(fp)
 203e7f4:	00006506 	br	203e98c <netconn_recv_data+0x214>
    }
    return ERR_CONN;
 203e7f8:	00bffd44 	movi	r2,-11
 203e7fc:	00006306 	br	203e98c <netconn_recv_data+0x214>
  }

  NETCONN_MBOX_WAITING_INC(conn);
  if (netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK) ||
 203e800:	e0bffd17 	ldw	r2,-12(fp)
 203e804:	10800903 	ldbu	r2,36(r2)
 203e808:	10803fcc 	andi	r2,r2,255
 203e80c:	1080008c 	andi	r2,r2,2
 203e810:	10000e1e 	bne	r2,zero,203e84c <netconn_recv_data+0xd4>
 203e814:	e0bfff03 	ldbu	r2,-4(fp)
 203e818:	1080010c 	andi	r2,r2,4
 203e81c:	10000b1e 	bne	r2,zero,203e84c <netconn_recv_data+0xd4>
      (conn->flags & NETCONN_FLAG_MBOXCLOSED) || (conn->pending_err != ERR_OK)) {
 203e820:	e0bffd17 	ldw	r2,-12(fp)
 203e824:	10800903 	ldbu	r2,36(r2)
 203e828:	10803fcc 	andi	r2,r2,255
 203e82c:	1080004c 	andi	r2,r2,1
    }
    return ERR_CONN;
  }

  NETCONN_MBOX_WAITING_INC(conn);
  if (netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK) ||
 203e830:	1000061e 	bne	r2,zero,203e84c <netconn_recv_data+0xd4>
      (conn->flags & NETCONN_FLAG_MBOXCLOSED) || (conn->pending_err != ERR_OK)) {
 203e834:	e0bffd17 	ldw	r2,-12(fp)
 203e838:	10800303 	ldbu	r2,12(r2)
 203e83c:	10803fcc 	andi	r2,r2,255
 203e840:	1080201c 	xori	r2,r2,128
 203e844:	10bfe004 	addi	r2,r2,-128
 203e848:	10001826 	beq	r2,zero,203e8ac <netconn_recv_data+0x134>
    if (sys_arch_mbox_tryfetch(&conn->recvmbox, &buf) == SYS_MBOX_EMPTY) {
 203e84c:	e0bffd17 	ldw	r2,-12(fp)
 203e850:	10800504 	addi	r2,r2,20
 203e854:	e0fffb04 	addi	r3,fp,-20
 203e858:	180b883a 	mov	r5,r3
 203e85c:	1009883a 	mov	r4,r2
 203e860:	20154540 	call	2015454 <sys_arch_mbox_tryfetch>
 203e864:	10bfffd8 	cmpnei	r2,r2,-1
 203e868:	10001d1e 	bne	r2,zero,203e8e0 <netconn_recv_data+0x168>
      err_t err;
      NETCONN_MBOX_WAITING_DEC(conn);
      err = netconn_err(conn);
 203e86c:	e13ffd17 	ldw	r4,-12(fp)
 203e870:	203f2800 	call	203f280 <netconn_err>
 203e874:	e0bffa85 	stb	r2,-22(fp)
      if (err != ERR_OK) {
 203e878:	e0bffa87 	ldb	r2,-22(fp)
 203e87c:	10000226 	beq	r2,zero,203e888 <netconn_recv_data+0x110>
        /* return pending error */
        return err;
 203e880:	e0bffa83 	ldbu	r2,-22(fp)
 203e884:	00004106 	br	203e98c <netconn_recv_data+0x214>
      }
      if (conn->flags & NETCONN_FLAG_MBOXCLOSED) {
 203e888:	e0bffd17 	ldw	r2,-12(fp)
 203e88c:	10800903 	ldbu	r2,36(r2)
 203e890:	10803fcc 	andi	r2,r2,255
 203e894:	1080004c 	andi	r2,r2,1
 203e898:	10000226 	beq	r2,zero,203e8a4 <netconn_recv_data+0x12c>
        return ERR_CONN;
 203e89c:	00bffd44 	movi	r2,-11
 203e8a0:	00003a06 	br	203e98c <netconn_recv_data+0x214>
      }
      return ERR_WOULDBLOCK;
 203e8a4:	00bffe44 	movi	r2,-7
 203e8a8:	00003806 	br	203e98c <netconn_recv_data+0x214>
    }
  } else {
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
 203e8ac:	e0bffd17 	ldw	r2,-12(fp)
 203e8b0:	10c00504 	addi	r3,r2,20
 203e8b4:	e0bffd17 	ldw	r2,-12(fp)
 203e8b8:	11000817 	ldw	r4,32(r2)
 203e8bc:	e0bffb04 	addi	r2,fp,-20
 203e8c0:	200d883a 	mov	r6,r4
 203e8c4:	100b883a 	mov	r5,r2
 203e8c8:	1809883a 	mov	r4,r3
 203e8cc:	20153ac0 	call	20153ac <sys_arch_mbox_fetch>
 203e8d0:	10bfffd8 	cmpnei	r2,r2,-1
 203e8d4:	1000021e 	bne	r2,zero,203e8e0 <netconn_recv_data+0x168>
      NETCONN_MBOX_WAITING_DEC(conn);
      return ERR_TIMEOUT;
 203e8d8:	00bfff44 	movi	r2,-3
 203e8dc:	00002b06 	br	203e98c <netconn_recv_data+0x214>
  }
#endif

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 203e8e0:	e0bffd17 	ldw	r2,-12(fp)
 203e8e4:	10800017 	ldw	r2,0(r2)
 203e8e8:	10803c0c 	andi	r2,r2,240
 203e8ec:	10800418 	cmpnei	r2,r2,16
 203e8f0:	1000141e 	bne	r2,zero,203e944 <netconn_recv_data+0x1cc>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    err_t err;
    /* Check if this is an error message or a pbuf */
    if (lwip_netconn_is_err_msg(buf, &err)) {
 203e8f4:	e0bffb17 	ldw	r2,-20(fp)
 203e8f8:	e0fffc04 	addi	r3,fp,-16
 203e8fc:	180b883a 	mov	r5,r3
 203e900:	1009883a 	mov	r4,r2
 203e904:	203f3b40 	call	203f3b4 <lwip_netconn_is_err_msg>
 203e908:	10000a26 	beq	r2,zero,203e934 <netconn_recv_data+0x1bc>
      /* new_buf has been zeroed above already */
      if (err == ERR_CLSD) {
 203e90c:	e0bffc03 	ldbu	r2,-16(fp)
 203e910:	10803fcc 	andi	r2,r2,255
 203e914:	1080201c 	xori	r2,r2,128
 203e918:	10bfe004 	addi	r2,r2,-128
 203e91c:	10bffc58 	cmpnei	r2,r2,-15
 203e920:	1000021e 	bne	r2,zero,203e92c <netconn_recv_data+0x1b4>
        /* connection closed translates to ERR_OK with *new_buf == NULL */
        return ERR_OK;
 203e924:	0005883a 	mov	r2,zero
 203e928:	00001806 	br	203e98c <netconn_recv_data+0x214>
      }
      return err;
 203e92c:	e0bffc03 	ldbu	r2,-16(fp)
 203e930:	00001606 	br	203e98c <netconn_recv_data+0x214>
    }
    len = ((struct pbuf *)buf)->tot_len;
 203e934:	e0bffb17 	ldw	r2,-20(fp)
 203e938:	1080020b 	ldhu	r2,8(r2)
 203e93c:	e0bffa0d 	sth	r2,-24(fp)
 203e940:	00000406 	br	203e954 <netconn_recv_data+0x1dc>
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
    len = netbuf_len((struct netbuf *)buf);
 203e944:	e0bffb17 	ldw	r2,-20(fp)
 203e948:	10800017 	ldw	r2,0(r2)
 203e94c:	1080020b 	ldhu	r2,8(r2)
 203e950:	e0bffa0d 	sth	r2,-24(fp)

#if LWIP_SO_RCVBUF
  SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 203e954:	e0bffd17 	ldw	r2,-12(fp)
 203e958:	10800b17 	ldw	r2,44(r2)
 203e95c:	10000726 	beq	r2,zero,203e97c <netconn_recv_data+0x204>
 203e960:	e0bffd17 	ldw	r2,-12(fp)
 203e964:	10800b17 	ldw	r2,44(r2)
 203e968:	e0fffa0b 	ldhu	r3,-24(fp)
 203e96c:	180d883a 	mov	r6,r3
 203e970:	01400044 	movi	r5,1
 203e974:	e13ffd17 	ldw	r4,-12(fp)
 203e978:	103ee83a 	callr	r2

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
 203e97c:	e0fffb17 	ldw	r3,-20(fp)
 203e980:	e0bffe17 	ldw	r2,-8(fp)
 203e984:	10c00015 	stw	r3,0(r2)
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 203e988:	0005883a 	mov	r2,zero
}
 203e98c:	e037883a 	mov	sp,fp
 203e990:	dfc00117 	ldw	ra,4(sp)
 203e994:	df000017 	ldw	fp,0(sp)
 203e998:	dec00204 	addi	sp,sp,8
 203e99c:	f800283a 	ret

0203e9a0 <netconn_tcp_recvd_msg>:

#if LWIP_TCP
static err_t
netconn_tcp_recvd_msg(struct netconn *conn, size_t len, struct api_msg *msg)
{
 203e9a0:	defffb04 	addi	sp,sp,-20
 203e9a4:	dfc00415 	stw	ra,16(sp)
 203e9a8:	df000315 	stw	fp,12(sp)
 203e9ac:	df000304 	addi	fp,sp,12
 203e9b0:	e13ffd15 	stw	r4,-12(fp)
 203e9b4:	e17ffe15 	stw	r5,-8(fp)
 203e9b8:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
 203e9bc:	e0bffd17 	ldw	r2,-12(fp)
 203e9c0:	10000526 	beq	r2,zero,203e9d8 <netconn_tcp_recvd_msg+0x38>
 203e9c4:	e0bffd17 	ldw	r2,-12(fp)
 203e9c8:	10800017 	ldw	r2,0(r2)
 203e9cc:	10803c0c 	andi	r2,r2,240
 203e9d0:	10800420 	cmpeqi	r2,r2,16
 203e9d4:	1000021e 	bne	r2,zero,203e9e0 <netconn_tcp_recvd_msg+0x40>
 203e9d8:	00bffc04 	movi	r2,-16
 203e9dc:	00000a06 	br	203ea08 <netconn_tcp_recvd_msg+0x68>
             NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);

  msg->conn = conn;
 203e9e0:	e0bfff17 	ldw	r2,-4(fp)
 203e9e4:	e0fffd17 	ldw	r3,-12(fp)
 203e9e8:	10c00015 	stw	r3,0(r2)
  msg->msg.r.len = len;
 203e9ec:	e0bfff17 	ldw	r2,-4(fp)
 203e9f0:	e0fffe17 	ldw	r3,-8(fp)
 203e9f4:	10c00215 	stw	r3,8(r2)

  return netconn_apimsg(lwip_netconn_do_recv, msg);
 203e9f8:	e17fff17 	ldw	r5,-4(fp)
 203e9fc:	01008134 	movhi	r4,516
 203ea00:	21051304 	addi	r4,r4,5196
 203ea04:	203e1040 	call	203e104 <netconn_apimsg>
}
 203ea08:	e037883a 	mov	sp,fp
 203ea0c:	dfc00117 	ldw	ra,4(sp)
 203ea10:	df000017 	ldw	fp,0(sp)
 203ea14:	dec00204 	addi	sp,sp,8
 203ea18:	f800283a 	ret

0203ea1c <netconn_tcp_recvd>:

err_t
netconn_tcp_recvd(struct netconn *conn, size_t len)
{
 203ea1c:	defff304 	addi	sp,sp,-52
 203ea20:	dfc00c15 	stw	ra,48(sp)
 203ea24:	df000b15 	stw	fp,44(sp)
 203ea28:	df000b04 	addi	fp,sp,44
 203ea2c:	e13ffe15 	stw	r4,-8(fp)
 203ea30:	e17fff15 	stw	r5,-4(fp)
  err_t err;
  API_MSG_VAR_DECLARE(msg);
  LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
 203ea34:	e0bffe17 	ldw	r2,-8(fp)
 203ea38:	10000526 	beq	r2,zero,203ea50 <netconn_tcp_recvd+0x34>
 203ea3c:	e0bffe17 	ldw	r2,-8(fp)
 203ea40:	10800017 	ldw	r2,0(r2)
 203ea44:	10803c0c 	andi	r2,r2,240
 203ea48:	10800420 	cmpeqi	r2,r2,16
 203ea4c:	1000021e 	bne	r2,zero,203ea58 <netconn_tcp_recvd+0x3c>
 203ea50:	00bffc04 	movi	r2,-16
 203ea54:	00000706 	br	203ea74 <netconn_tcp_recvd+0x58>
             NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);

  API_MSG_VAR_ALLOC(msg);
  err = netconn_tcp_recvd_msg(conn, len, &API_VAR_REF(msg));
 203ea58:	e0bff604 	addi	r2,fp,-40
 203ea5c:	100d883a 	mov	r6,r2
 203ea60:	e17fff17 	ldw	r5,-4(fp)
 203ea64:	e13ffe17 	ldw	r4,-8(fp)
 203ea68:	203e9a00 	call	203e9a0 <netconn_tcp_recvd_msg>
 203ea6c:	e0bff505 	stb	r2,-44(fp)
  API_MSG_VAR_FREE(msg);
  return err;
 203ea70:	e0bff503 	ldbu	r2,-44(fp)
}
 203ea74:	e037883a 	mov	sp,fp
 203ea78:	dfc00117 	ldw	ra,4(sp)
 203ea7c:	df000017 	ldw	fp,0(sp)
 203ea80:	dec00204 	addi	sp,sp,8
 203ea84:	f800283a 	ret

0203ea88 <netconn_recv_data_tcp>:

static err_t
netconn_recv_data_tcp(struct netconn *conn, struct pbuf **new_buf, u8_t apiflags)
{
 203ea88:	defff004 	addi	sp,sp,-64
 203ea8c:	dfc00f15 	stw	ra,60(sp)
 203ea90:	df000e15 	stw	fp,56(sp)
 203ea94:	df000e04 	addi	fp,sp,56
 203ea98:	e13ffd15 	stw	r4,-12(fp)
 203ea9c:	e17ffe15 	stw	r5,-8(fp)
 203eaa0:	3005883a 	mov	r2,r6
 203eaa4:	e0bfff05 	stb	r2,-4(fp)
  API_MSG_VAR_DECLARE(msg);
#if LWIP_MPU_COMPATIBLE
  msg = NULL;
#endif

  if (!NETCONN_RECVMBOX_WAITABLE(conn)) {
 203eaa8:	e0bffd17 	ldw	r2,-12(fp)
 203eaac:	10800504 	addi	r2,r2,20
 203eab0:	10000326 	beq	r2,zero,203eac0 <netconn_recv_data_tcp+0x38>
 203eab4:	e0bffd17 	ldw	r2,-12(fp)
 203eab8:	10800517 	ldw	r2,20(r2)
 203eabc:	1000021e 	bne	r2,zero,203eac8 <netconn_recv_data_tcp+0x40>
    /* This only happens when calling this function more than once *after* receiving FIN */
    return ERR_CONN;
 203eac0:	00bffd44 	movi	r2,-11
 203eac4:	00005306 	br	203ec14 <netconn_recv_data_tcp+0x18c>
  }
  if (netconn_is_flag_set(conn, NETCONN_FIN_RX_PENDING)) {
 203eac8:	e0bffd17 	ldw	r2,-12(fp)
 203eacc:	10800903 	ldbu	r2,36(r2)
 203ead0:	10803fcc 	andi	r2,r2,255
 203ead4:	1080201c 	xori	r2,r2,128
 203ead8:	10bfe004 	addi	r2,r2,-128
 203eadc:	1000070e 	bge	r2,zero,203eafc <netconn_recv_data_tcp+0x74>
    netconn_clear_flags(conn, NETCONN_FIN_RX_PENDING);
 203eae0:	e0bffd17 	ldw	r2,-12(fp)
 203eae4:	10800903 	ldbu	r2,36(r2)
 203eae8:	10801fcc 	andi	r2,r2,127
 203eaec:	1007883a 	mov	r3,r2
 203eaf0:	e0bffd17 	ldw	r2,-12(fp)
 203eaf4:	10c00905 	stb	r3,36(r2)
    goto handle_fin;
 203eaf8:	00002b06 	br	203eba8 <netconn_recv_data_tcp+0x120>
    /* need to allocate API message here so empty message pool does not result in event loss
      * see bug #47512: MPU_COMPATIBLE may fail on empty pool */
    API_MSG_VAR_ALLOC(msg);
  }

  err = netconn_recv_data(conn, (void **)new_buf, apiflags);
 203eafc:	e0bfff03 	ldbu	r2,-4(fp)
 203eb00:	100d883a 	mov	r6,r2
 203eb04:	e17ffe17 	ldw	r5,-8(fp)
 203eb08:	e13ffd17 	ldw	r4,-12(fp)
 203eb0c:	203e7780 	call	203e778 <netconn_recv_data>
 203eb10:	e0bff205 	stb	r2,-56(fp)
  if (err != ERR_OK) {
 203eb14:	e0bff207 	ldb	r2,-56(fp)
 203eb18:	10000226 	beq	r2,zero,203eb24 <netconn_recv_data_tcp+0x9c>
    if (!(apiflags & NETCONN_NOAUTORCVD)) {
      API_MSG_VAR_FREE(msg);
    }
    return err;
 203eb1c:	e0bff203 	ldbu	r2,-56(fp)
 203eb20:	00003c06 	br	203ec14 <netconn_recv_data_tcp+0x18c>
  }
  buf = *new_buf;
 203eb24:	e0bffe17 	ldw	r2,-8(fp)
 203eb28:	10800017 	ldw	r2,0(r2)
 203eb2c:	e0bff315 	stw	r2,-52(fp)
  if (!(apiflags & NETCONN_NOAUTORCVD)) {
 203eb30:	e0bfff03 	ldbu	r2,-4(fp)
 203eb34:	1080020c 	andi	r2,r2,8
 203eb38:	10000d1e 	bne	r2,zero,203eb70 <netconn_recv_data_tcp+0xe8>
    /* Let the stack know that we have taken the data. */
    u16_t len = buf ? buf->tot_len : 1;
 203eb3c:	e0bff317 	ldw	r2,-52(fp)
 203eb40:	10000326 	beq	r2,zero,203eb50 <netconn_recv_data_tcp+0xc8>
 203eb44:	e0bff317 	ldw	r2,-52(fp)
 203eb48:	1080020b 	ldhu	r2,8(r2)
 203eb4c:	00000106 	br	203eb54 <netconn_recv_data_tcp+0xcc>
 203eb50:	00800044 	movi	r2,1
 203eb54:	e0bff40d 	sth	r2,-48(fp)
    /* don't care for the return value of lwip_netconn_do_recv */
    /* @todo: this should really be fixed, e.g. by retrying in poll on error */
    netconn_tcp_recvd_msg(conn, len,  &API_VAR_REF(msg));
 203eb58:	e0bff40b 	ldhu	r2,-48(fp)
 203eb5c:	e0fff504 	addi	r3,fp,-44
 203eb60:	180d883a 	mov	r6,r3
 203eb64:	100b883a 	mov	r5,r2
 203eb68:	e13ffd17 	ldw	r4,-12(fp)
 203eb6c:	203e9a00 	call	203e9a0 <netconn_tcp_recvd_msg>
    API_MSG_VAR_FREE(msg);
  }

  /* If we are closed, we indicate that we no longer wish to use the socket */
  if (buf == NULL) {
 203eb70:	e0bff317 	ldw	r2,-52(fp)
 203eb74:	1000261e 	bne	r2,zero,203ec10 <netconn_recv_data_tcp+0x188>
    if (apiflags & NETCONN_NOFIN) {
 203eb78:	e0bfff03 	ldbu	r2,-4(fp)
 203eb7c:	1080040c 	andi	r2,r2,16
 203eb80:	10000926 	beq	r2,zero,203eba8 <netconn_recv_data_tcp+0x120>
      /* received a FIN but the caller cannot handle it right now:
         re-enqueue it and return "no data" */
      netconn_set_flags(conn, NETCONN_FIN_RX_PENDING);
 203eb84:	e0bffd17 	ldw	r2,-12(fp)
 203eb88:	10c00903 	ldbu	r3,36(r2)
 203eb8c:	00bfe004 	movi	r2,-128
 203eb90:	1884b03a 	or	r2,r3,r2
 203eb94:	1007883a 	mov	r3,r2
 203eb98:	e0bffd17 	ldw	r2,-12(fp)
 203eb9c:	10c00905 	stb	r3,36(r2)
      return ERR_WOULDBLOCK;
 203eba0:	00bffe44 	movi	r2,-7
 203eba4:	00001b06 	br	203ec14 <netconn_recv_data_tcp+0x18c>
    } else {
handle_fin:
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 203eba8:	e0bffd17 	ldw	r2,-12(fp)
 203ebac:	10800b17 	ldw	r2,44(r2)
 203ebb0:	10000626 	beq	r2,zero,203ebcc <netconn_recv_data_tcp+0x144>
 203ebb4:	e0bffd17 	ldw	r2,-12(fp)
 203ebb8:	10800b17 	ldw	r2,44(r2)
 203ebbc:	000d883a 	mov	r6,zero
 203ebc0:	01400044 	movi	r5,1
 203ebc4:	e13ffd17 	ldw	r4,-12(fp)
 203ebc8:	103ee83a 	callr	r2
      if (conn->pcb.ip == NULL) {
 203ebcc:	e0bffd17 	ldw	r2,-12(fp)
 203ebd0:	10800217 	ldw	r2,8(r2)
 203ebd4:	1000091e 	bne	r2,zero,203ebfc <netconn_recv_data_tcp+0x174>
        /* race condition: RST during recv */
        err = netconn_err(conn);
 203ebd8:	e13ffd17 	ldw	r4,-12(fp)
 203ebdc:	203f2800 	call	203f280 <netconn_err>
 203ebe0:	e0bff205 	stb	r2,-56(fp)
        if (err != ERR_OK) {
 203ebe4:	e0bff207 	ldb	r2,-56(fp)
 203ebe8:	10000226 	beq	r2,zero,203ebf4 <netconn_recv_data_tcp+0x16c>
          return err;
 203ebec:	e0bff203 	ldbu	r2,-56(fp)
 203ebf0:	00000806 	br	203ec14 <netconn_recv_data_tcp+0x18c>
        }
        return ERR_RST;
 203ebf4:	00bffc84 	movi	r2,-14
 203ebf8:	00000606 	br	203ec14 <netconn_recv_data_tcp+0x18c>
      }
      /* RX side is closed, so deallocate the recvmbox */
      netconn_close_shutdown(conn, NETCONN_SHUT_RD);
 203ebfc:	01400044 	movi	r5,1
 203ec00:	e13ffd17 	ldw	r4,-12(fp)
 203ec04:	203f1d80 	call	203f1d8 <netconn_close_shutdown>
      /* Don' store ERR_CLSD as conn->err since we are only half-closed */
      return ERR_CLSD;
 203ec08:	00bffc44 	movi	r2,-15
 203ec0c:	00000106 	br	203ec14 <netconn_recv_data_tcp+0x18c>
    }
  }
  return err;
 203ec10:	e0bff203 	ldbu	r2,-56(fp)
}
 203ec14:	e037883a 	mov	sp,fp
 203ec18:	dfc00117 	ldw	ra,4(sp)
 203ec1c:	df000017 	ldw	fp,0(sp)
 203ec20:	dec00204 	addi	sp,sp,8
 203ec24:	f800283a 	ret

0203ec28 <netconn_recv_tcp_pbuf>:
 *                memory error or another error, @see netconn_recv_data)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
 203ec28:	defffc04 	addi	sp,sp,-16
 203ec2c:	dfc00315 	stw	ra,12(sp)
 203ec30:	df000215 	stw	fp,8(sp)
 203ec34:	df000204 	addi	fp,sp,8
 203ec38:	e13ffe15 	stw	r4,-8(fp)
 203ec3c:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
 203ec40:	e0bffe17 	ldw	r2,-8(fp)
 203ec44:	10000526 	beq	r2,zero,203ec5c <netconn_recv_tcp_pbuf+0x34>
 203ec48:	e0bffe17 	ldw	r2,-8(fp)
 203ec4c:	10800017 	ldw	r2,0(r2)
 203ec50:	10803c0c 	andi	r2,r2,240
 203ec54:	10800420 	cmpeqi	r2,r2,16
 203ec58:	1000021e 	bne	r2,zero,203ec64 <netconn_recv_tcp_pbuf+0x3c>
 203ec5c:	00bffc04 	movi	r2,-16
 203ec60:	00000406 	br	203ec74 <netconn_recv_tcp_pbuf+0x4c>
             NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data_tcp(conn, new_buf, 0);
 203ec64:	000d883a 	mov	r6,zero
 203ec68:	e17fff17 	ldw	r5,-4(fp)
 203ec6c:	e13ffe17 	ldw	r4,-8(fp)
 203ec70:	203ea880 	call	203ea88 <netconn_recv_data_tcp>
}
 203ec74:	e037883a 	mov	sp,fp
 203ec78:	dfc00117 	ldw	ra,4(sp)
 203ec7c:	df000017 	ldw	fp,0(sp)
 203ec80:	dec00204 	addi	sp,sp,8
 203ec84:	f800283a 	ret

0203ec88 <netconn_recv_tcp_pbuf_flags>:
 *                memory error or another error, @see netconn_recv_data)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf_flags(struct netconn *conn, struct pbuf **new_buf, u8_t apiflags)
{
 203ec88:	defffb04 	addi	sp,sp,-20
 203ec8c:	dfc00415 	stw	ra,16(sp)
 203ec90:	df000315 	stw	fp,12(sp)
 203ec94:	df000304 	addi	fp,sp,12
 203ec98:	e13ffd15 	stw	r4,-12(fp)
 203ec9c:	e17ffe15 	stw	r5,-8(fp)
 203eca0:	3005883a 	mov	r2,r6
 203eca4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
 203eca8:	e0bffd17 	ldw	r2,-12(fp)
 203ecac:	10000526 	beq	r2,zero,203ecc4 <netconn_recv_tcp_pbuf_flags+0x3c>
 203ecb0:	e0bffd17 	ldw	r2,-12(fp)
 203ecb4:	10800017 	ldw	r2,0(r2)
 203ecb8:	10803c0c 	andi	r2,r2,240
 203ecbc:	10800420 	cmpeqi	r2,r2,16
 203ecc0:	1000021e 	bne	r2,zero,203eccc <netconn_recv_tcp_pbuf_flags+0x44>
 203ecc4:	00bffc04 	movi	r2,-16
 203ecc8:	00000506 	br	203ece0 <netconn_recv_tcp_pbuf_flags+0x58>
             NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data_tcp(conn, new_buf, apiflags);
 203eccc:	e0bfff03 	ldbu	r2,-4(fp)
 203ecd0:	100d883a 	mov	r6,r2
 203ecd4:	e17ffe17 	ldw	r5,-8(fp)
 203ecd8:	e13ffd17 	ldw	r4,-12(fp)
 203ecdc:	203ea880 	call	203ea88 <netconn_recv_data_tcp>
}
 203ece0:	e037883a 	mov	sp,fp
 203ece4:	dfc00117 	ldw	ra,4(sp)
 203ece8:	df000017 	ldw	fp,0(sp)
 203ecec:	dec00204 	addi	sp,sp,8
 203ecf0:	f800283a 	ret

0203ecf4 <netconn_recv_udp_raw_netbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a UDP/RAW netconn
 */
err_t
netconn_recv_udp_raw_netbuf(struct netconn *conn, struct netbuf **new_buf)
{
 203ecf4:	defffc04 	addi	sp,sp,-16
 203ecf8:	dfc00315 	stw	ra,12(sp)
 203ecfc:	df000215 	stw	fp,8(sp)
 203ed00:	df000204 	addi	fp,sp,8
 203ed04:	e13ffe15 	stw	r4,-8(fp)
 203ed08:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netconn_recv_udp_raw_netbuf: invalid conn", (conn != NULL) &&
 203ed0c:	e0bffe17 	ldw	r2,-8(fp)
 203ed10:	10000526 	beq	r2,zero,203ed28 <netconn_recv_udp_raw_netbuf+0x34>
 203ed14:	e0bffe17 	ldw	r2,-8(fp)
 203ed18:	10800017 	ldw	r2,0(r2)
 203ed1c:	10803c0c 	andi	r2,r2,240
 203ed20:	10800418 	cmpnei	r2,r2,16
 203ed24:	1000021e 	bne	r2,zero,203ed30 <netconn_recv_udp_raw_netbuf+0x3c>
 203ed28:	00bffc04 	movi	r2,-16
 203ed2c:	00000406 	br	203ed40 <netconn_recv_udp_raw_netbuf+0x4c>
             NETCONNTYPE_GROUP(netconn_type(conn)) != NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf, 0);
 203ed30:	000d883a 	mov	r6,zero
 203ed34:	e17fff17 	ldw	r5,-4(fp)
 203ed38:	e13ffe17 	ldw	r4,-8(fp)
 203ed3c:	203e7780 	call	203e778 <netconn_recv_data>
}
 203ed40:	e037883a 	mov	sp,fp
 203ed44:	dfc00117 	ldw	ra,4(sp)
 203ed48:	df000017 	ldw	fp,0(sp)
 203ed4c:	dec00204 	addi	sp,sp,8
 203ed50:	f800283a 	ret

0203ed54 <netconn_recv_udp_raw_netbuf_flags>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a UDP/RAW netconn
 */
err_t
netconn_recv_udp_raw_netbuf_flags(struct netconn *conn, struct netbuf **new_buf, u8_t apiflags)
{
 203ed54:	defffb04 	addi	sp,sp,-20
 203ed58:	dfc00415 	stw	ra,16(sp)
 203ed5c:	df000315 	stw	fp,12(sp)
 203ed60:	df000304 	addi	fp,sp,12
 203ed64:	e13ffd15 	stw	r4,-12(fp)
 203ed68:	e17ffe15 	stw	r5,-8(fp)
 203ed6c:	3005883a 	mov	r2,r6
 203ed70:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ERROR("netconn_recv_udp_raw_netbuf: invalid conn", (conn != NULL) &&
 203ed74:	e0bffd17 	ldw	r2,-12(fp)
 203ed78:	10000526 	beq	r2,zero,203ed90 <netconn_recv_udp_raw_netbuf_flags+0x3c>
 203ed7c:	e0bffd17 	ldw	r2,-12(fp)
 203ed80:	10800017 	ldw	r2,0(r2)
 203ed84:	10803c0c 	andi	r2,r2,240
 203ed88:	10800418 	cmpnei	r2,r2,16
 203ed8c:	1000021e 	bne	r2,zero,203ed98 <netconn_recv_udp_raw_netbuf_flags+0x44>
 203ed90:	00bffc04 	movi	r2,-16
 203ed94:	00000506 	br	203edac <netconn_recv_udp_raw_netbuf_flags+0x58>
             NETCONNTYPE_GROUP(netconn_type(conn)) != NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf, apiflags);
 203ed98:	e0bfff03 	ldbu	r2,-4(fp)
 203ed9c:	100d883a 	mov	r6,r2
 203eda0:	e17ffe17 	ldw	r5,-8(fp)
 203eda4:	e13ffd17 	ldw	r4,-12(fp)
 203eda8:	203e7780 	call	203e778 <netconn_recv_data>
}
 203edac:	e037883a 	mov	sp,fp
 203edb0:	dfc00117 	ldw	ra,4(sp)
 203edb4:	df000017 	ldw	fp,0(sp)
 203edb8:	dec00204 	addi	sp,sp,8
 203edbc:	f800283a 	ret

0203edc0 <netconn_recv>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
 203edc0:	defff904 	addi	sp,sp,-28
 203edc4:	dfc00615 	stw	ra,24(sp)
 203edc8:	df000515 	stw	fp,20(sp)
 203edcc:	df000504 	addi	fp,sp,20
 203edd0:	e13ffe15 	stw	r4,-8(fp)
 203edd4:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct netbuf *buf = NULL;
 203edd8:	e03ffb15 	stw	zero,-20(fp)
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 203eddc:	e0bfff17 	ldw	r2,-4(fp)
 203ede0:	1000021e 	bne	r2,zero,203edec <netconn_recv+0x2c>
 203ede4:	00bffc04 	movi	r2,-16
 203ede8:	00003306 	br	203eeb8 <netconn_recv+0xf8>
  *new_buf = NULL;
 203edec:	e0bfff17 	ldw	r2,-4(fp)
 203edf0:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 203edf4:	e0bffe17 	ldw	r2,-8(fp)
 203edf8:	1000021e 	bne	r2,zero,203ee04 <netconn_recv+0x44>
 203edfc:	00bffc04 	movi	r2,-16
 203ee00:	00002d06 	br	203eeb8 <netconn_recv+0xf8>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 203ee04:	e0bffe17 	ldw	r2,-8(fp)
 203ee08:	10800017 	ldw	r2,0(r2)
 203ee0c:	10803c0c 	andi	r2,r2,240
 203ee10:	10800418 	cmpnei	r2,r2,16
 203ee14:	1000241e 	bne	r2,zero,203eea8 <netconn_recv+0xe8>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
 203ee18:	e03ffd15 	stw	zero,-12(fp)
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 203ee1c:	010001c4 	movi	r4,7
 203ee20:	201b82c0 	call	201b82c <memp_malloc>
 203ee24:	e0bffb15 	stw	r2,-20(fp)
    if (buf == NULL) {
 203ee28:	e0bffb17 	ldw	r2,-20(fp)
 203ee2c:	1000021e 	bne	r2,zero,203ee38 <netconn_recv+0x78>
      return ERR_MEM;
 203ee30:	00bfffc4 	movi	r2,-1
 203ee34:	00002006 	br	203eeb8 <netconn_recv+0xf8>
    }

    err = netconn_recv_data_tcp(conn, &p, 0);
 203ee38:	e0bffd04 	addi	r2,fp,-12
 203ee3c:	000d883a 	mov	r6,zero
 203ee40:	100b883a 	mov	r5,r2
 203ee44:	e13ffe17 	ldw	r4,-8(fp)
 203ee48:	203ea880 	call	203ea88 <netconn_recv_data_tcp>
 203ee4c:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
 203ee50:	e0bffc07 	ldb	r2,-16(fp)
 203ee54:	10000526 	beq	r2,zero,203ee6c <netconn_recv+0xac>
      memp_free(MEMP_NETBUF, buf);
 203ee58:	e17ffb17 	ldw	r5,-20(fp)
 203ee5c:	010001c4 	movi	r4,7
 203ee60:	201b9640 	call	201b964 <memp_free>
      return err;
 203ee64:	e0bffc03 	ldbu	r2,-16(fp)
 203ee68:	00001306 	br	203eeb8 <netconn_recv+0xf8>
    }
    LWIP_ASSERT("p != NULL", p != NULL);

    buf->p = p;
 203ee6c:	e0fffd17 	ldw	r3,-12(fp)
 203ee70:	e0bffb17 	ldw	r2,-20(fp)
 203ee74:	10c00015 	stw	r3,0(r2)
    buf->ptr = p;
 203ee78:	e0fffd17 	ldw	r3,-12(fp)
 203ee7c:	e0bffb17 	ldw	r2,-20(fp)
 203ee80:	10c00115 	stw	r3,4(r2)
    buf->port = 0;
 203ee84:	e0bffb17 	ldw	r2,-20(fp)
 203ee88:	1000030d 	sth	zero,12(r2)
    ip_addr_set_zero(&buf->addr);
 203ee8c:	e0bffb17 	ldw	r2,-20(fp)
 203ee90:	10000215 	stw	zero,8(r2)
    *new_buf = buf;
 203ee94:	e0bfff17 	ldw	r2,-4(fp)
 203ee98:	e0fffb17 	ldw	r3,-20(fp)
 203ee9c:	10c00015 	stw	r3,0(r2)
    /* don't set conn->last_err: it's only ERR_OK, anyway */
    return ERR_OK;
 203eea0:	0005883a 	mov	r2,zero
 203eea4:	00000406 	br	203eeb8 <netconn_recv+0xf8>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf, 0);
 203eea8:	000d883a 	mov	r6,zero
 203eeac:	e17fff17 	ldw	r5,-4(fp)
 203eeb0:	e13ffe17 	ldw	r4,-8(fp)
 203eeb4:	203e7780 	call	203e778 <netconn_recv_data>
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 203eeb8:	e037883a 	mov	sp,fp
 203eebc:	dfc00117 	ldw	ra,4(sp)
 203eec0:	df000017 	ldw	fp,0(sp)
 203eec4:	dec00204 	addi	sp,sp,8
 203eec8:	f800283a 	ret

0203eecc <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, const ip_addr_t *addr, u16_t port)
{
 203eecc:	defffa04 	addi	sp,sp,-24
 203eed0:	dfc00515 	stw	ra,20(sp)
 203eed4:	df000415 	stw	fp,16(sp)
 203eed8:	df000404 	addi	fp,sp,16
 203eedc:	e13ffc15 	stw	r4,-16(fp)
 203eee0:	e17ffd15 	stw	r5,-12(fp)
 203eee4:	e1bffe15 	stw	r6,-8(fp)
 203eee8:	3805883a 	mov	r2,r7
 203eeec:	e0bfff0d 	sth	r2,-4(fp)
  if (buf != NULL) {
 203eef0:	e0bffd17 	ldw	r2,-12(fp)
 203eef4:	10000f26 	beq	r2,zero,203ef34 <netconn_sendto+0x68>
    ip_addr_set(&buf->addr, addr);
 203eef8:	e0bffe17 	ldw	r2,-8(fp)
 203eefc:	10000326 	beq	r2,zero,203ef0c <netconn_sendto+0x40>
 203ef00:	e0bffe17 	ldw	r2,-8(fp)
 203ef04:	10800017 	ldw	r2,0(r2)
 203ef08:	00000106 	br	203ef10 <netconn_sendto+0x44>
 203ef0c:	0005883a 	mov	r2,zero
 203ef10:	e0fffd17 	ldw	r3,-12(fp)
 203ef14:	18800215 	stw	r2,8(r3)
    buf->port = port;
 203ef18:	e0bffd17 	ldw	r2,-12(fp)
 203ef1c:	e0ffff0b 	ldhu	r3,-4(fp)
 203ef20:	10c0030d 	sth	r3,12(r2)
    return netconn_send(conn, buf);
 203ef24:	e17ffd17 	ldw	r5,-12(fp)
 203ef28:	e13ffc17 	ldw	r4,-16(fp)
 203ef2c:	203ef4c0 	call	203ef4c <netconn_send>
 203ef30:	00000106 	br	203ef38 <netconn_sendto+0x6c>
  }
  return ERR_VAL;
 203ef34:	00bffe84 	movi	r2,-6
}
 203ef38:	e037883a 	mov	sp,fp
 203ef3c:	dfc00117 	ldw	ra,4(sp)
 203ef40:	df000017 	ldw	fp,0(sp)
 203ef44:	dec00204 	addi	sp,sp,8
 203ef48:	f800283a 	ret

0203ef4c <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
 203ef4c:	defff304 	addi	sp,sp,-52
 203ef50:	dfc00c15 	stw	ra,48(sp)
 203ef54:	df000b15 	stw	fp,44(sp)
 203ef58:	df000b04 	addi	fp,sp,44
 203ef5c:	e13ffe15 	stw	r4,-8(fp)
 203ef60:	e17fff15 	stw	r5,-4(fp)
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 203ef64:	e0bffe17 	ldw	r2,-8(fp)
 203ef68:	1000021e 	bne	r2,zero,203ef74 <netconn_send+0x28>
 203ef6c:	00bffc04 	movi	r2,-16
 203ef70:	00000b06 	br	203efa0 <netconn_send+0x54>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203ef74:	e0bffe17 	ldw	r2,-8(fp)
 203ef78:	e0bff615 	stw	r2,-40(fp)
  API_MSG_VAR_REF(msg).msg.b = buf;
 203ef7c:	e0bfff17 	ldw	r2,-4(fp)
 203ef80:	e0bff815 	stw	r2,-32(fp)
  err = netconn_apimsg(lwip_netconn_do_send, &API_MSG_VAR_REF(msg));
 203ef84:	e0bff604 	addi	r2,fp,-40
 203ef88:	100b883a 	mov	r5,r2
 203ef8c:	01008134 	movhi	r4,516
 203ef90:	21048a04 	addi	r4,r4,4648
 203ef94:	203e1040 	call	203e104 <netconn_apimsg>
 203ef98:	e0bff505 	stb	r2,-44(fp)
  API_MSG_VAR_FREE(msg);

  return err;
 203ef9c:	e0bff503 	ldbu	r2,-44(fp)
}
 203efa0:	e037883a 	mov	sp,fp
 203efa4:	dfc00117 	ldw	ra,4(sp)
 203efa8:	df000017 	ldw	fp,0(sp)
 203efac:	dec00204 	addi	sp,sp,8
 203efb0:	f800283a 	ret

0203efb4 <netconn_write_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
 203efb4:	defff704 	addi	sp,sp,-36
 203efb8:	dfc00815 	stw	ra,32(sp)
 203efbc:	df000715 	stw	fp,28(sp)
 203efc0:	df000704 	addi	fp,sp,28
 203efc4:	e13ffc15 	stw	r4,-16(fp)
 203efc8:	e17ffd15 	stw	r5,-12(fp)
 203efcc:	e1bffe15 	stw	r6,-8(fp)
 203efd0:	3805883a 	mov	r2,r7
 203efd4:	e0bfff05 	stb	r2,-4(fp)
  struct netvector vector;
  vector.ptr = dataptr;
 203efd8:	e0bffd17 	ldw	r2,-12(fp)
 203efdc:	e0bffa15 	stw	r2,-24(fp)
  vector.len = size;
 203efe0:	e0bffe17 	ldw	r2,-8(fp)
 203efe4:	e0bffb15 	stw	r2,-20(fp)
  return netconn_write_vectors_partly(conn, &vector, 1, apiflags, bytes_written);
 203efe8:	e0ffff03 	ldbu	r3,-4(fp)
 203efec:	e0800217 	ldw	r2,8(fp)
 203eff0:	d8800015 	stw	r2,0(sp)
 203eff4:	180f883a 	mov	r7,r3
 203eff8:	01800044 	movi	r6,1
 203effc:	e17ffa04 	addi	r5,fp,-24
 203f000:	e13ffc17 	ldw	r4,-16(fp)
 203f004:	203f01c0 	call	203f01c <netconn_write_vectors_partly>
}
 203f008:	e037883a 	mov	sp,fp
 203f00c:	dfc00117 	ldw	ra,4(sp)
 203f010:	df000017 	ldw	fp,0(sp)
 203f014:	dec00204 	addi	sp,sp,8
 203f018:	f800283a 	ret

0203f01c <netconn_write_vectors_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_vectors_partly(struct netconn *conn, struct netvector *vectors, u16_t vectorcnt,
                             u8_t apiflags, size_t *bytes_written)
{
 203f01c:	deffed04 	addi	sp,sp,-76
 203f020:	dfc01215 	stw	ra,72(sp)
 203f024:	df001115 	stw	fp,68(sp)
 203f028:	df001104 	addi	fp,sp,68
 203f02c:	e13ffc15 	stw	r4,-16(fp)
 203f030:	e17ffd15 	stw	r5,-12(fp)
 203f034:	3007883a 	mov	r3,r6
 203f038:	3805883a 	mov	r2,r7
 203f03c:	e0fffe0d 	sth	r3,-8(fp)
 203f040:	e0bfff05 	stb	r2,-4(fp)
  err_t err;
  u8_t dontblock;
  size_t size;
  int i;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 203f044:	e0bffc17 	ldw	r2,-16(fp)
 203f048:	1000021e 	bne	r2,zero,203f054 <netconn_write_vectors_partly+0x38>
 203f04c:	00bffc04 	movi	r2,-16
 203f050:	00005c06 	br	203f1c4 <netconn_write_vectors_partly+0x1a8>
  LWIP_ERROR("netconn_write: invalid conn->type",  (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP), return ERR_VAL;);
 203f054:	e0bffc17 	ldw	r2,-16(fp)
 203f058:	10800017 	ldw	r2,0(r2)
 203f05c:	10803c0c 	andi	r2,r2,240
 203f060:	10800420 	cmpeqi	r2,r2,16
 203f064:	1000021e 	bne	r2,zero,203f070 <netconn_write_vectors_partly+0x54>
 203f068:	00bffe84 	movi	r2,-6
 203f06c:	00005506 	br	203f1c4 <netconn_write_vectors_partly+0x1a8>
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 203f070:	e0bffc17 	ldw	r2,-16(fp)
 203f074:	10800903 	ldbu	r2,36(r2)
 203f078:	10803fcc 	andi	r2,r2,255
 203f07c:	1080008c 	andi	r2,r2,2
 203f080:	1000031e 	bne	r2,zero,203f090 <netconn_write_vectors_partly+0x74>
 203f084:	e0bfff03 	ldbu	r2,-4(fp)
 203f088:	1080010c 	andi	r2,r2,4
 203f08c:	10000226 	beq	r2,zero,203f098 <netconn_write_vectors_partly+0x7c>
 203f090:	00800044 	movi	r2,1
 203f094:	00000106 	br	203f09c <netconn_write_vectors_partly+0x80>
 203f098:	0005883a 	mov	r2,zero
 203f09c:	e0bff105 	stb	r2,-60(fp)
#if LWIP_SO_SNDTIMEO
  if (conn->send_timeout != 0) {
    dontblock = 1;
  }
#endif /* LWIP_SO_SNDTIMEO */
  if (dontblock && !bytes_written) {
 203f0a0:	e0bff103 	ldbu	r2,-60(fp)
 203f0a4:	10000426 	beq	r2,zero,203f0b8 <netconn_write_vectors_partly+0x9c>
 203f0a8:	e0800217 	ldw	r2,8(fp)
 203f0ac:	1000021e 	bne	r2,zero,203f0b8 <netconn_write_vectors_partly+0x9c>
    /* This implies netconn_write() cannot be used for non-blocking send, since
       it has no way to return the number of bytes written. */
    return ERR_VAL;
 203f0b0:	00bffe84 	movi	r2,-6
 203f0b4:	00004306 	br	203f1c4 <netconn_write_vectors_partly+0x1a8>
  }

  /* sum up the total size */
  size = 0;
 203f0b8:	e03fef15 	stw	zero,-68(fp)
  for (i = 0; i < vectorcnt; i++) {
 203f0bc:	e03ff015 	stw	zero,-64(fp)
 203f0c0:	00001406 	br	203f114 <netconn_write_vectors_partly+0xf8>
    size += vectors[i].len;
 203f0c4:	e0bff017 	ldw	r2,-64(fp)
 203f0c8:	100490fa 	slli	r2,r2,3
 203f0cc:	e0fffd17 	ldw	r3,-12(fp)
 203f0d0:	1885883a 	add	r2,r3,r2
 203f0d4:	10800117 	ldw	r2,4(r2)
 203f0d8:	e0ffef17 	ldw	r3,-68(fp)
 203f0dc:	1885883a 	add	r2,r3,r2
 203f0e0:	e0bfef15 	stw	r2,-68(fp)
    if (size < vectors[i].len) {
 203f0e4:	e0bff017 	ldw	r2,-64(fp)
 203f0e8:	100490fa 	slli	r2,r2,3
 203f0ec:	e0fffd17 	ldw	r3,-12(fp)
 203f0f0:	1885883a 	add	r2,r3,r2
 203f0f4:	10800117 	ldw	r2,4(r2)
 203f0f8:	e0ffef17 	ldw	r3,-68(fp)
 203f0fc:	1880022e 	bgeu	r3,r2,203f108 <netconn_write_vectors_partly+0xec>
      /* overflow */
      return ERR_VAL;
 203f100:	00bffe84 	movi	r2,-6
 203f104:	00002f06 	br	203f1c4 <netconn_write_vectors_partly+0x1a8>
    return ERR_VAL;
  }

  /* sum up the total size */
  size = 0;
  for (i = 0; i < vectorcnt; i++) {
 203f108:	e0bff017 	ldw	r2,-64(fp)
 203f10c:	10800044 	addi	r2,r2,1
 203f110:	e0bff015 	stw	r2,-64(fp)
 203f114:	e0bffe0b 	ldhu	r2,-8(fp)
 203f118:	e0fff017 	ldw	r3,-64(fp)
 203f11c:	18bfe916 	blt	r3,r2,203f0c4 <__alt_mem_mem_0+0xfd01f0c4>
    if (size < vectors[i].len) {
      /* overflow */
      return ERR_VAL;
    }
  }
  if (size == 0) {
 203f120:	e0bfef17 	ldw	r2,-68(fp)
 203f124:	1000021e 	bne	r2,zero,203f130 <netconn_write_vectors_partly+0x114>
    return ERR_OK;
 203f128:	0005883a 	mov	r2,zero
 203f12c:	00002506 	br	203f1c4 <netconn_write_vectors_partly+0x1a8>
  } else if (size > SSIZE_MAX) {
 203f130:	e0bfef17 	ldw	r2,-68(fp)
 203f134:	1000090e 	bge	r2,zero,203f15c <netconn_write_vectors_partly+0x140>
    ssize_t limited;
    /* this is required by the socket layer (cannot send full size_t range) */
    if (!bytes_written) {
 203f138:	e0800217 	ldw	r2,8(fp)
 203f13c:	1000021e 	bne	r2,zero,203f148 <netconn_write_vectors_partly+0x12c>
      return ERR_VAL;
 203f140:	00bffe84 	movi	r2,-6
 203f144:	00001f06 	br	203f1c4 <netconn_write_vectors_partly+0x1a8>
    }
    /* limit the amount of data to send */
    limited = SSIZE_MAX;
 203f148:	00a00034 	movhi	r2,32768
 203f14c:	10bfffc4 	addi	r2,r2,-1
 203f150:	e0bff215 	stw	r2,-56(fp)
    size = (size_t)limited;
 203f154:	e0bff217 	ldw	r2,-56(fp)
 203f158:	e0bfef15 	stw	r2,-68(fp)
  }

  API_MSG_VAR_ALLOC(msg);
  /* non-blocking write sends as much  */
  API_MSG_VAR_REF(msg).conn = conn;
 203f15c:	e0bffc17 	ldw	r2,-16(fp)
 203f160:	e0bff415 	stw	r2,-48(fp)
  API_MSG_VAR_REF(msg).msg.w.vector = vectors;
 203f164:	e0bffd17 	ldw	r2,-12(fp)
 203f168:	e0bff615 	stw	r2,-40(fp)
  API_MSG_VAR_REF(msg).msg.w.vector_cnt = vectorcnt;
 203f16c:	e0bffe0b 	ldhu	r2,-8(fp)
 203f170:	e0bff70d 	sth	r2,-36(fp)
  API_MSG_VAR_REF(msg).msg.w.vector_off = 0;
 203f174:	e03ff815 	stw	zero,-32(fp)
  API_MSG_VAR_REF(msg).msg.w.apiflags = apiflags;
 203f178:	e0bfff03 	ldbu	r2,-4(fp)
 203f17c:	e0bffb05 	stb	r2,-20(fp)
  API_MSG_VAR_REF(msg).msg.w.len = size;
 203f180:	e0bfef17 	ldw	r2,-68(fp)
 203f184:	e0bff915 	stw	r2,-28(fp)
  API_MSG_VAR_REF(msg).msg.w.offset = 0;
 203f188:	e03ffa15 	stw	zero,-24(fp)
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = netconn_apimsg(lwip_netconn_do_write, &API_MSG_VAR_REF(msg));
 203f18c:	e0bff404 	addi	r2,fp,-48
 203f190:	100b883a 	mov	r5,r2
 203f194:	01008134 	movhi	r4,516
 203f198:	21068b04 	addi	r4,r4,6700
 203f19c:	203e1040 	call	203e104 <netconn_apimsg>
 203f1a0:	e0bff305 	stb	r2,-52(fp)
  if (err == ERR_OK) {
 203f1a4:	e0bff307 	ldb	r2,-52(fp)
 203f1a8:	1000051e 	bne	r2,zero,203f1c0 <netconn_write_vectors_partly+0x1a4>
    if (bytes_written != NULL) {
 203f1ac:	e0800217 	ldw	r2,8(fp)
 203f1b0:	10000326 	beq	r2,zero,203f1c0 <netconn_write_vectors_partly+0x1a4>
      *bytes_written = API_MSG_VAR_REF(msg).msg.w.offset;
 203f1b4:	e0fffa17 	ldw	r3,-24(fp)
 203f1b8:	e0800217 	ldw	r2,8(fp)
 203f1bc:	10c00015 	stw	r3,0(r2)
      LWIP_ASSERT("do_write failed to write all bytes", API_MSG_VAR_REF(msg).msg.w.offset == size);
    }
  }
  API_MSG_VAR_FREE(msg);

  return err;
 203f1c0:	e0bff303 	ldbu	r2,-52(fp)
}
 203f1c4:	e037883a 	mov	sp,fp
 203f1c8:	dfc00117 	ldw	ra,4(sp)
 203f1cc:	df000017 	ldw	fp,0(sp)
 203f1d0:	dec00204 	addi	sp,sp,8
 203f1d4:	f800283a 	ret

0203f1d8 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 203f1d8:	defff304 	addi	sp,sp,-52
 203f1dc:	dfc00c15 	stw	ra,48(sp)
 203f1e0:	df000b15 	stw	fp,44(sp)
 203f1e4:	df000b04 	addi	fp,sp,44
 203f1e8:	e13ffe15 	stw	r4,-8(fp)
 203f1ec:	2805883a 	mov	r2,r5
 203f1f0:	e0bfff05 	stb	r2,-4(fp)
  API_MSG_VAR_DECLARE(msg);
  err_t err;
  LWIP_UNUSED_ARG(how);

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 203f1f4:	e0bffe17 	ldw	r2,-8(fp)
 203f1f8:	1000021e 	bne	r2,zero,203f204 <netconn_close_shutdown+0x2c>
 203f1fc:	00bffc04 	movi	r2,-16
 203f200:	00000d06 	br	203f238 <netconn_close_shutdown+0x60>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 203f204:	e0bffe17 	ldw	r2,-8(fp)
 203f208:	e0bff615 	stw	r2,-40(fp)
#if LWIP_TCP
  /* shutting down both ends is the same as closing */
  API_MSG_VAR_REF(msg).msg.sd.shut = how;
 203f20c:	e0bfff03 	ldbu	r2,-4(fp)
 203f210:	e0bff805 	stb	r2,-32(fp)
#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
  /* get the time we started, which is later compared to
     sys_now() + conn->send_timeout */
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
  API_MSG_VAR_REF(msg).msg.sd.polls_left =
 203f214:	00800a44 	movi	r2,41
 203f218:	e0bff845 	stb	r2,-31(fp)
    ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - 1) / TCP_SLOW_INTERVAL) + 1;
#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
#endif /* LWIP_TCP */
  err = netconn_apimsg(lwip_netconn_do_close, &API_MSG_VAR_REF(msg));
 203f21c:	e0bff604 	addi	r2,fp,-40
 203f220:	100b883a 	mov	r5,r2
 203f224:	01008134 	movhi	r4,516
 203f228:	21075604 	addi	r4,r4,7512
 203f22c:	203e1040 	call	203e104 <netconn_apimsg>
 203f230:	e0bff505 	stb	r2,-44(fp)
  API_MSG_VAR_FREE(msg);

  return err;
 203f234:	e0bff503 	ldbu	r2,-44(fp)
}
 203f238:	e037883a 	mov	sp,fp
 203f23c:	dfc00117 	ldw	ra,4(sp)
 203f240:	df000017 	ldw	fp,0(sp)
 203f244:	dec00204 	addi	sp,sp,8
 203f248:	f800283a 	ret

0203f24c <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
 203f24c:	defffd04 	addi	sp,sp,-12
 203f250:	dfc00215 	stw	ra,8(sp)
 203f254:	df000115 	stw	fp,4(sp)
 203f258:	df000104 	addi	fp,sp,4
 203f25c:	e13fff15 	stw	r4,-4(fp)
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 203f260:	014000c4 	movi	r5,3
 203f264:	e13fff17 	ldw	r4,-4(fp)
 203f268:	203f1d80 	call	203f1d8 <netconn_close_shutdown>
}
 203f26c:	e037883a 	mov	sp,fp
 203f270:	dfc00117 	ldw	ra,4(sp)
 203f274:	df000017 	ldw	fp,0(sp)
 203f278:	dec00204 	addi	sp,sp,8
 203f27c:	f800283a 	ret

0203f280 <netconn_err>:
 * @param conn the netconn to get the error from
 * @return and pending error or ERR_OK if no error was pending
 */
err_t
netconn_err(struct netconn *conn)
{
 203f280:	defffb04 	addi	sp,sp,-20
 203f284:	dfc00415 	stw	ra,16(sp)
 203f288:	df000315 	stw	fp,12(sp)
 203f28c:	df000304 	addi	fp,sp,12
 203f290:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  SYS_ARCH_DECL_PROTECT(lev);
  if (conn == NULL) {
 203f294:	e0bfff17 	ldw	r2,-4(fp)
 203f298:	1000021e 	bne	r2,zero,203f2a4 <netconn_err+0x24>
    return ERR_OK;
 203f29c:	0005883a 	mov	r2,zero
 203f2a0:	00000a06 	br	203f2cc <netconn_err+0x4c>
  }
  SYS_ARCH_PROTECT(lev);
 203f2a4:	2014cec0 	call	2014cec <sys_arch_protect>
 203f2a8:	e0bffd15 	stw	r2,-12(fp)
  err = conn->pending_err;
 203f2ac:	e0bfff17 	ldw	r2,-4(fp)
 203f2b0:	10800303 	ldbu	r2,12(r2)
 203f2b4:	e0bffe05 	stb	r2,-8(fp)
  conn->pending_err = ERR_OK;
 203f2b8:	e0bfff17 	ldw	r2,-4(fp)
 203f2bc:	10000305 	stb	zero,12(r2)
  SYS_ARCH_UNPROTECT(lev);
 203f2c0:	e13ffd17 	ldw	r4,-12(fp)
 203f2c4:	2014d200 	call	2014d20 <sys_arch_unprotect>
  return err;
 203f2c8:	e0bffe03 	ldbu	r2,-8(fp)
}
 203f2cc:	e037883a 	mov	sp,fp
 203f2d0:	dfc00117 	ldw	ra,4(sp)
 203f2d4:	df000017 	ldw	fp,0(sp)
 203f2d8:	dec00204 	addi	sp,sp,8
 203f2dc:	f800283a 	ret

0203f2e0 <netconn_shutdown>:
 * @param shut_tx shut down the TX side (no more write possible after this)
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
{
 203f2e0:	defffb04 	addi	sp,sp,-20
 203f2e4:	dfc00415 	stw	ra,16(sp)
 203f2e8:	df000315 	stw	fp,12(sp)
 203f2ec:	df000304 	addi	fp,sp,12
 203f2f0:	e13ffd15 	stw	r4,-12(fp)
 203f2f4:	2807883a 	mov	r3,r5
 203f2f8:	3005883a 	mov	r2,r6
 203f2fc:	e0fffe05 	stb	r3,-8(fp)
 203f300:	e0bfff05 	stb	r2,-4(fp)
  return netconn_close_shutdown(conn, (u8_t)((shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0)));
 203f304:	e0bffe03 	ldbu	r2,-8(fp)
 203f308:	10000226 	beq	r2,zero,203f314 <netconn_shutdown+0x34>
 203f30c:	00c00044 	movi	r3,1
 203f310:	00000106 	br	203f318 <netconn_shutdown+0x38>
 203f314:	0007883a 	mov	r3,zero
 203f318:	e0bfff03 	ldbu	r2,-4(fp)
 203f31c:	10000226 	beq	r2,zero,203f328 <netconn_shutdown+0x48>
 203f320:	00800084 	movi	r2,2
 203f324:	00000106 	br	203f32c <netconn_shutdown+0x4c>
 203f328:	0005883a 	mov	r2,zero
 203f32c:	1884b03a 	or	r2,r3,r2
 203f330:	10803fcc 	andi	r2,r2,255
 203f334:	100b883a 	mov	r5,r2
 203f338:	e13ffd17 	ldw	r4,-12(fp)
 203f33c:	203f1d80 	call	203f1d8 <netconn_close_shutdown>
}
 203f340:	e037883a 	mov	sp,fp
 203f344:	dfc00117 	ldw	ra,4(sp)
 203f348:	df000017 	ldw	fp,0(sp)
 203f34c:	dec00204 	addi	sp,sp,8
 203f350:	f800283a 	ret

0203f354 <lwip_netconn_err_to_msg>:
const u8_t netconn_closed = 0;

/** Translate an error to a unique void* passed via an mbox */
static void *
lwip_netconn_err_to_msg(err_t err)
{
 203f354:	defffe04 	addi	sp,sp,-8
 203f358:	df000115 	stw	fp,4(sp)
 203f35c:	df000104 	addi	fp,sp,4
 203f360:	2005883a 	mov	r2,r4
 203f364:	e0bfff05 	stb	r2,-4(fp)
  switch (err) {
 203f368:	e0bfff07 	ldb	r2,-4(fp)
 203f36c:	10fffca0 	cmpeqi	r3,r2,-14
 203f370:	1800071e 	bne	r3,zero,203f390 <lwip_netconn_err_to_msg+0x3c>
 203f374:	10fffce0 	cmpeqi	r3,r2,-13
 203f378:	1800031e 	bne	r3,zero,203f388 <lwip_netconn_err_to_msg+0x34>
 203f37c:	10bffc60 	cmpeqi	r2,r2,-15
 203f380:	1000051e 	bne	r2,zero,203f398 <lwip_netconn_err_to_msg+0x44>
 203f384:	00000606 	br	203f3a0 <lwip_netconn_err_to_msg+0x4c>
    case ERR_ABRT:
      return LWIP_CONST_CAST(void *, &netconn_aborted);
 203f388:	d0a01f44 	addi	r2,gp,-32643
 203f38c:	00000506 	br	203f3a4 <lwip_netconn_err_to_msg+0x50>
    case ERR_RST:
      return LWIP_CONST_CAST(void *, &netconn_reset);
 203f390:	d0a01f84 	addi	r2,gp,-32642
 203f394:	00000306 	br	203f3a4 <lwip_netconn_err_to_msg+0x50>
    case ERR_CLSD:
      return LWIP_CONST_CAST(void *, &netconn_closed);
 203f398:	d0a01fc4 	addi	r2,gp,-32641
 203f39c:	00000106 	br	203f3a4 <lwip_netconn_err_to_msg+0x50>
    default:
      LWIP_ASSERT("unhandled error", err == ERR_OK);
      return NULL;
 203f3a0:	0005883a 	mov	r2,zero
  }
}
 203f3a4:	e037883a 	mov	sp,fp
 203f3a8:	df000017 	ldw	fp,0(sp)
 203f3ac:	dec00104 	addi	sp,sp,4
 203f3b0:	f800283a 	ret

0203f3b4 <lwip_netconn_is_err_msg>:

int
lwip_netconn_is_err_msg(void *msg, err_t *err)
{
 203f3b4:	defffd04 	addi	sp,sp,-12
 203f3b8:	df000215 	stw	fp,8(sp)
 203f3bc:	df000204 	addi	fp,sp,8
 203f3c0:	e13ffe15 	stw	r4,-8(fp)
 203f3c4:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("err != NULL", err != NULL);

  if (msg == &netconn_aborted) {
 203f3c8:	e0fffe17 	ldw	r3,-8(fp)
 203f3cc:	d0a01f44 	addi	r2,gp,-32643
 203f3d0:	1880051e 	bne	r3,r2,203f3e8 <lwip_netconn_is_err_msg+0x34>
    *err = ERR_ABRT;
 203f3d4:	e0bfff17 	ldw	r2,-4(fp)
 203f3d8:	00fffcc4 	movi	r3,-13
 203f3dc:	10c00005 	stb	r3,0(r2)
    return 1;
 203f3e0:	00800044 	movi	r2,1
 203f3e4:	00001106 	br	203f42c <lwip_netconn_is_err_msg+0x78>
  } else if (msg == &netconn_reset) {
 203f3e8:	e0fffe17 	ldw	r3,-8(fp)
 203f3ec:	d0a01f84 	addi	r2,gp,-32642
 203f3f0:	1880051e 	bne	r3,r2,203f408 <lwip_netconn_is_err_msg+0x54>
    *err = ERR_RST;
 203f3f4:	e0bfff17 	ldw	r2,-4(fp)
 203f3f8:	00fffc84 	movi	r3,-14
 203f3fc:	10c00005 	stb	r3,0(r2)
    return 1;
 203f400:	00800044 	movi	r2,1
 203f404:	00000906 	br	203f42c <lwip_netconn_is_err_msg+0x78>
  } else if (msg == &netconn_closed) {
 203f408:	e0fffe17 	ldw	r3,-8(fp)
 203f40c:	d0a01fc4 	addi	r2,gp,-32641
 203f410:	1880051e 	bne	r3,r2,203f428 <lwip_netconn_is_err_msg+0x74>
    *err = ERR_CLSD;
 203f414:	e0bfff17 	ldw	r2,-4(fp)
 203f418:	00fffc44 	movi	r3,-15
 203f41c:	10c00005 	stb	r3,0(r2)
    return 1;
 203f420:	00800044 	movi	r2,1
 203f424:	00000106 	br	203f42c <lwip_netconn_is_err_msg+0x78>
  }
  return 0;
 203f428:	0005883a 	mov	r2,zero
}
 203f42c:	e037883a 	mov	sp,fp
 203f430:	df000017 	ldw	fp,0(sp)
 203f434:	dec00104 	addi	sp,sp,4
 203f438:	f800283a 	ret

0203f43c <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
         const ip_addr_t *addr)
{
 203f43c:	defff604 	addi	sp,sp,-40
 203f440:	dfc00915 	stw	ra,36(sp)
 203f444:	df000815 	stw	fp,32(sp)
 203f448:	df000804 	addi	fp,sp,32
 203f44c:	e13ffc15 	stw	r4,-16(fp)
 203f450:	e17ffd15 	stw	r5,-12(fp)
 203f454:	e1bffe15 	stw	r6,-8(fp)
 203f458:	e1ffff15 	stw	r7,-4(fp)
  struct pbuf *q;
  struct netbuf *buf;
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;
 203f45c:	e0bffc17 	ldw	r2,-16(fp)
 203f460:	e0bff815 	stw	r2,-32(fp)

  if ((conn != NULL) && NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
 203f464:	e0bff817 	ldw	r2,-32(fp)
 203f468:	10004026 	beq	r2,zero,203f56c <recv_raw+0x130>
 203f46c:	e0bff817 	ldw	r2,-32(fp)
 203f470:	10800504 	addi	r2,r2,20
 203f474:	10003d26 	beq	r2,zero,203f56c <recv_raw+0x130>
 203f478:	e0bff817 	ldw	r2,-32(fp)
 203f47c:	10800517 	ldw	r2,20(r2)
 203f480:	10003a26 	beq	r2,zero,203f56c <recv_raw+0x130>
    if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
      return 0;
    }
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_clone(PBUF_RAW, PBUF_RAM, p);
 203f484:	e1bffe17 	ldw	r6,-8(fp)
 203f488:	0140a004 	movi	r5,640
 203f48c:	0009883a 	mov	r4,zero
 203f490:	201de800 	call	201de80 <pbuf_clone>
 203f494:	e0bff915 	stw	r2,-28(fp)
    if (q != NULL) {
 203f498:	e0bff917 	ldw	r2,-28(fp)
 203f49c:	10003326 	beq	r2,zero,203f56c <recv_raw+0x130>
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 203f4a0:	010001c4 	movi	r4,7
 203f4a4:	201b82c0 	call	201b82c <memp_malloc>
 203f4a8:	e0bffa15 	stw	r2,-24(fp)
      if (buf == NULL) {
 203f4ac:	e0bffa17 	ldw	r2,-24(fp)
 203f4b0:	1000041e 	bne	r2,zero,203f4c4 <recv_raw+0x88>
        pbuf_free(q);
 203f4b4:	e13ff917 	ldw	r4,-28(fp)
 203f4b8:	201d2f40 	call	201d2f4 <pbuf_free>
        return 0;
 203f4bc:	0005883a 	mov	r2,zero
 203f4c0:	00002b06 	br	203f570 <recv_raw+0x134>
      }

      buf->p = q;
 203f4c4:	e0bffa17 	ldw	r2,-24(fp)
 203f4c8:	e0fff917 	ldw	r3,-28(fp)
 203f4cc:	10c00015 	stw	r3,0(r2)
      buf->ptr = q;
 203f4d0:	e0bffa17 	ldw	r2,-24(fp)
 203f4d4:	e0fff917 	ldw	r3,-28(fp)
 203f4d8:	10c00115 	stw	r3,4(r2)
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 203f4dc:	008085f4 	movhi	r2,535
 203f4e0:	10be4204 	addi	r2,r2,-1784
 203f4e4:	10c00417 	ldw	r3,16(r2)
 203f4e8:	e0bffa17 	ldw	r2,-24(fp)
 203f4ec:	10c00215 	stw	r3,8(r2)
      buf->port = pcb->protocol;
 203f4f0:	e0bffd17 	ldw	r2,-12(fp)
 203f4f4:	10800503 	ldbu	r2,20(r2)
 203f4f8:	10c03fcc 	andi	r3,r2,255
 203f4fc:	e0bffa17 	ldw	r2,-24(fp)
 203f500:	10c0030d 	sth	r3,12(r2)

      len = q->tot_len;
 203f504:	e0bff917 	ldw	r2,-28(fp)
 203f508:	1080020b 	ldhu	r2,8(r2)
 203f50c:	e0bffb0d 	sth	r2,-20(fp)
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 203f510:	e0bff817 	ldw	r2,-32(fp)
 203f514:	10800504 	addi	r2,r2,20
 203f518:	e17ffa17 	ldw	r5,-24(fp)
 203f51c:	1009883a 	mov	r4,r2
 203f520:	20152880 	call	2015288 <sys_mbox_trypost>
 203f524:	10803fcc 	andi	r2,r2,255
 203f528:	1080201c 	xori	r2,r2,128
 203f52c:	10bfe004 	addi	r2,r2,-128
 203f530:	10000426 	beq	r2,zero,203f544 <recv_raw+0x108>
        netbuf_delete(buf);
 203f534:	e13ffa17 	ldw	r4,-24(fp)
 203f538:	2041f400 	call	2041f40 <netbuf_delete>
        return 0;
 203f53c:	0005883a 	mov	r2,zero
 203f540:	00000b06 	br	203f570 <recv_raw+0x134>
      } else {
#if LWIP_SO_RCVBUF
        SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
        /* Register event with callback */
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 203f544:	e0bff817 	ldw	r2,-32(fp)
 203f548:	10800b17 	ldw	r2,44(r2)
 203f54c:	10000726 	beq	r2,zero,203f56c <recv_raw+0x130>
 203f550:	e0bff817 	ldw	r2,-32(fp)
 203f554:	10800b17 	ldw	r2,44(r2)
 203f558:	e0fffb0b 	ldhu	r3,-20(fp)
 203f55c:	180d883a 	mov	r6,r3
 203f560:	000b883a 	mov	r5,zero
 203f564:	e13ff817 	ldw	r4,-32(fp)
 203f568:	103ee83a 	callr	r2
      }
    }
  }

  return 0; /* do not eat the packet */
 203f56c:	0005883a 	mov	r2,zero
}
 203f570:	e037883a 	mov	sp,fp
 203f574:	dfc00117 	ldw	ra,4(sp)
 203f578:	df000017 	ldw	fp,0(sp)
 203f57c:	dec00204 	addi	sp,sp,8
 203f580:	f800283a 	ret

0203f584 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
         const ip_addr_t *addr, u16_t port)
{
 203f584:	defff604 	addi	sp,sp,-40
 203f588:	dfc00915 	stw	ra,36(sp)
 203f58c:	df000815 	stw	fp,32(sp)
 203f590:	df000804 	addi	fp,sp,32
 203f594:	e13ffb15 	stw	r4,-20(fp)
 203f598:	e17ffc15 	stw	r5,-16(fp)
 203f59c:	e1bffd15 	stw	r6,-12(fp)
 203f5a0:	e1fffe15 	stw	r7,-8(fp)
 203f5a4:	e0800217 	ldw	r2,8(fp)
 203f5a8:	e0bfff0d 	sth	r2,-4(fp)
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
 203f5ac:	e0bffb17 	ldw	r2,-20(fp)
 203f5b0:	e0bff815 	stw	r2,-32(fp)

  if (conn == NULL) {
 203f5b4:	e0bff817 	ldw	r2,-32(fp)
 203f5b8:	1000031e 	bne	r2,zero,203f5c8 <recv_udp+0x44>
    pbuf_free(p);
 203f5bc:	e13ffd17 	ldw	r4,-12(fp)
 203f5c0:	201d2f40 	call	201d2f4 <pbuf_free>
    return;
 203f5c4:	00003a06 	br	203f6b0 <recv_udp+0x12c>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
 203f5c8:	e0bff817 	ldw	r2,-32(fp)
 203f5cc:	10800504 	addi	r2,r2,20
 203f5d0:	10000326 	beq	r2,zero,203f5e0 <recv_udp+0x5c>
 203f5d4:	e0bff817 	ldw	r2,-32(fp)
 203f5d8:	10800517 	ldw	r2,20(r2)
 203f5dc:	1000031e 	bne	r2,zero,203f5ec <recv_udp+0x68>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
 203f5e0:	e13ffd17 	ldw	r4,-12(fp)
 203f5e4:	201d2f40 	call	201d2f4 <pbuf_free>
    return;
 203f5e8:	00003106 	br	203f6b0 <recv_udp+0x12c>
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 203f5ec:	010001c4 	movi	r4,7
 203f5f0:	201b82c0 	call	201b82c <memp_malloc>
 203f5f4:	e0bff915 	stw	r2,-28(fp)
  if (buf == NULL) {
 203f5f8:	e0bff917 	ldw	r2,-28(fp)
 203f5fc:	1000031e 	bne	r2,zero,203f60c <recv_udp+0x88>
    pbuf_free(p);
 203f600:	e13ffd17 	ldw	r4,-12(fp)
 203f604:	201d2f40 	call	201d2f4 <pbuf_free>
    return;
 203f608:	00002906 	br	203f6b0 <recv_udp+0x12c>
  } else {
    buf->p = p;
 203f60c:	e0bff917 	ldw	r2,-28(fp)
 203f610:	e0fffd17 	ldw	r3,-12(fp)
 203f614:	10c00015 	stw	r3,0(r2)
    buf->ptr = p;
 203f618:	e0bff917 	ldw	r2,-28(fp)
 203f61c:	e0fffd17 	ldw	r3,-12(fp)
 203f620:	10c00115 	stw	r3,4(r2)
    ip_addr_set(&buf->addr, addr);
 203f624:	e0bffe17 	ldw	r2,-8(fp)
 203f628:	10000326 	beq	r2,zero,203f638 <recv_udp+0xb4>
 203f62c:	e0bffe17 	ldw	r2,-8(fp)
 203f630:	10800017 	ldw	r2,0(r2)
 203f634:	00000106 	br	203f63c <recv_udp+0xb8>
 203f638:	0005883a 	mov	r2,zero
 203f63c:	e0fff917 	ldw	r3,-28(fp)
 203f640:	18800215 	stw	r2,8(r3)
    buf->port = port;
 203f644:	e0bff917 	ldw	r2,-28(fp)
 203f648:	e0ffff0b 	ldhu	r3,-4(fp)
 203f64c:	10c0030d 	sth	r3,12(r2)
      buf->toport_chksum = udphdr->dest;
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
 203f650:	e0bffd17 	ldw	r2,-12(fp)
 203f654:	1080020b 	ldhu	r2,8(r2)
 203f658:	e0bffa0d 	sth	r2,-24(fp)
  err = sys_mbox_trypost(&conn->recvmbox, buf);
 203f65c:	e0bff817 	ldw	r2,-32(fp)
 203f660:	10800504 	addi	r2,r2,20
 203f664:	e17ff917 	ldw	r5,-28(fp)
 203f668:	1009883a 	mov	r4,r2
 203f66c:	20152880 	call	2015288 <sys_mbox_trypost>
 203f670:	e0bffa85 	stb	r2,-22(fp)
  if (err != ERR_OK) {
 203f674:	e0bffa87 	ldb	r2,-22(fp)
 203f678:	10000326 	beq	r2,zero,203f688 <recv_udp+0x104>
    netbuf_delete(buf);
 203f67c:	e13ff917 	ldw	r4,-28(fp)
 203f680:	2041f400 	call	2041f40 <netbuf_delete>
    LWIP_DEBUGF(API_MSG_DEBUG, ("recv_udp: sys_mbox_trypost failed, err=%d\n", err));
    return;
 203f684:	00000a06 	br	203f6b0 <recv_udp+0x12c>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 203f688:	e0bff817 	ldw	r2,-32(fp)
 203f68c:	10800b17 	ldw	r2,44(r2)
 203f690:	10000726 	beq	r2,zero,203f6b0 <recv_udp+0x12c>
 203f694:	e0bff817 	ldw	r2,-32(fp)
 203f698:	10800b17 	ldw	r2,44(r2)
 203f69c:	e0fffa0b 	ldhu	r3,-24(fp)
 203f6a0:	180d883a 	mov	r6,r3
 203f6a4:	000b883a 	mov	r5,zero
 203f6a8:	e13ff817 	ldw	r4,-32(fp)
 203f6ac:	103ee83a 	callr	r2
  }
}
 203f6b0:	e037883a 	mov	sp,fp
 203f6b4:	dfc00117 	ldw	ra,4(sp)
 203f6b8:	df000017 	ldw	fp,0(sp)
 203f6bc:	dec00204 	addi	sp,sp,8
 203f6c0:	f800283a 	ret

0203f6c4 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 203f6c4:	defff704 	addi	sp,sp,-36
 203f6c8:	dfc00815 	stw	ra,32(sp)
 203f6cc:	df000715 	stw	fp,28(sp)
 203f6d0:	df000704 	addi	fp,sp,28
 203f6d4:	e13ffc15 	stw	r4,-16(fp)
 203f6d8:	e17ffd15 	stw	r5,-12(fp)
 203f6dc:	e1bffe15 	stw	r6,-8(fp)
 203f6e0:	3805883a 	mov	r2,r7
 203f6e4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  LWIP_ASSERT("err != ERR_OK unhandled", err == ERR_OK);
  LWIP_UNUSED_ARG(err); /* for LWIP_NOASSERT */
  conn = (struct netconn *)arg;
 203f6e8:	e0bffc17 	ldw	r2,-16(fp)
 203f6ec:	e0bffb15 	stw	r2,-20(fp)

  if (conn == NULL) {
 203f6f0:	e0bffb17 	ldw	r2,-20(fp)
 203f6f4:	1000021e 	bne	r2,zero,203f700 <recv_tcp+0x3c>
    return ERR_VAL;
 203f6f8:	00bffe84 	movi	r2,-6
 203f6fc:	00003306 	br	203f7cc <recv_tcp+0x108>
  }
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
 203f700:	e0bffb17 	ldw	r2,-20(fp)
 203f704:	10800504 	addi	r2,r2,20
 203f708:	10000326 	beq	r2,zero,203f718 <recv_tcp+0x54>
 203f70c:	e0bffb17 	ldw	r2,-20(fp)
 203f710:	10800517 	ldw	r2,20(r2)
 203f714:	10000c1e 	bne	r2,zero,203f748 <recv_tcp+0x84>
    /* recvmbox already deleted */
    if (p != NULL) {
 203f718:	e0bffe17 	ldw	r2,-8(fp)
 203f71c:	10000826 	beq	r2,zero,203f740 <recv_tcp+0x7c>
      tcp_recved(pcb, p->tot_len);
 203f720:	e0bffe17 	ldw	r2,-8(fp)
 203f724:	1080020b 	ldhu	r2,8(r2)
 203f728:	10bfffcc 	andi	r2,r2,65535
 203f72c:	100b883a 	mov	r5,r2
 203f730:	e13ffd17 	ldw	r4,-12(fp)
 203f734:	201fd780 	call	201fd78 <tcp_recved>
      pbuf_free(p);
 203f738:	e13ffe17 	ldw	r4,-8(fp)
 203f73c:	201d2f40 	call	201d2f4 <pbuf_free>
    }
    return ERR_OK;
 203f740:	0005883a 	mov	r2,zero
 203f744:	00002106 	br	203f7cc <recv_tcp+0x108>
  }
  /* Unlike for UDP or RAW pcbs, don't check for available space
     using recv_avail since that could break the connection
     (data is already ACKed) */

  if (p != NULL) {
 203f748:	e0bffe17 	ldw	r2,-8(fp)
 203f74c:	10000626 	beq	r2,zero,203f768 <recv_tcp+0xa4>
    msg = p;
 203f750:	e0bffe17 	ldw	r2,-8(fp)
 203f754:	e0bffa15 	stw	r2,-24(fp)
    len = p->tot_len;
 203f758:	e0bffe17 	ldw	r2,-8(fp)
 203f75c:	1080020b 	ldhu	r2,8(r2)
 203f760:	e0bff90d 	sth	r2,-28(fp)
 203f764:	00000306 	br	203f774 <recv_tcp+0xb0>
  } else {
    msg = LWIP_CONST_CAST(void *, &netconn_closed);
 203f768:	d0a01fc4 	addi	r2,gp,-32641
 203f76c:	e0bffa15 	stw	r2,-24(fp)
    len = 0;
 203f770:	e03ff90d 	sth	zero,-28(fp)
  }

  if (sys_mbox_trypost(&conn->recvmbox, msg) != ERR_OK) {
 203f774:	e0bffb17 	ldw	r2,-20(fp)
 203f778:	10800504 	addi	r2,r2,20
 203f77c:	e17ffa17 	ldw	r5,-24(fp)
 203f780:	1009883a 	mov	r4,r2
 203f784:	20152880 	call	2015288 <sys_mbox_trypost>
 203f788:	10803fcc 	andi	r2,r2,255
 203f78c:	1080201c 	xori	r2,r2,128
 203f790:	10bfe004 	addi	r2,r2,-128
 203f794:	10000226 	beq	r2,zero,203f7a0 <recv_tcp+0xdc>
    /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
    return ERR_MEM;
 203f798:	00bfffc4 	movi	r2,-1
 203f79c:	00000b06 	br	203f7cc <recv_tcp+0x108>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 203f7a0:	e0bffb17 	ldw	r2,-20(fp)
 203f7a4:	10800b17 	ldw	r2,44(r2)
 203f7a8:	10000726 	beq	r2,zero,203f7c8 <recv_tcp+0x104>
 203f7ac:	e0bffb17 	ldw	r2,-20(fp)
 203f7b0:	10800b17 	ldw	r2,44(r2)
 203f7b4:	e0fff90b 	ldhu	r3,-28(fp)
 203f7b8:	180d883a 	mov	r6,r3
 203f7bc:	000b883a 	mov	r5,zero
 203f7c0:	e13ffb17 	ldw	r4,-20(fp)
 203f7c4:	103ee83a 	callr	r2
  }

  return ERR_OK;
 203f7c8:	0005883a 	mov	r2,zero
}
 203f7cc:	e037883a 	mov	sp,fp
 203f7d0:	dfc00117 	ldw	ra,4(sp)
 203f7d4:	df000017 	ldw	fp,0(sp)
 203f7d8:	dec00204 	addi	sp,sp,8
 203f7dc:	f800283a 	ret

0203f7e0 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
 203f7e0:	defffb04 	addi	sp,sp,-20
 203f7e4:	dfc00415 	stw	ra,16(sp)
 203f7e8:	df000315 	stw	fp,12(sp)
 203f7ec:	df000304 	addi	fp,sp,12
 203f7f0:	e13ffe15 	stw	r4,-8(fp)
 203f7f4:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn = (struct netconn *)arg;
 203f7f8:	e0bffe17 	ldw	r2,-8(fp)
 203f7fc:	e0bffd15 	stw	r2,-12(fp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
 203f800:	e0bffd17 	ldw	r2,-12(fp)
 203f804:	10800117 	ldw	r2,4(r2)
 203f808:	10800058 	cmpnei	r2,r2,1
 203f80c:	1000031e 	bne	r2,zero,203f81c <poll_tcp+0x3c>
    lwip_netconn_do_writemore(conn  WRITE_DELAYED);
 203f810:	e13ffd17 	ldw	r4,-12(fp)
 203f814:	20415ac0 	call	20415ac <lwip_netconn_do_writemore>
 203f818:	00001306 	br	203f868 <poll_tcp+0x88>
  } else if (conn->state == NETCONN_CLOSE) {
 203f81c:	e0bffd17 	ldw	r2,-12(fp)
 203f820:	10800117 	ldw	r2,4(r2)
 203f824:	10800118 	cmpnei	r2,r2,4
 203f828:	10000f1e 	bne	r2,zero,203f868 <poll_tcp+0x88>
#if !LWIP_SO_SNDTIMEO && !LWIP_SO_LINGER
    if (conn->current_msg && conn->current_msg->msg.sd.polls_left) {
 203f82c:	e0bffd17 	ldw	r2,-12(fp)
 203f830:	10800a17 	ldw	r2,40(r2)
 203f834:	10000a26 	beq	r2,zero,203f860 <poll_tcp+0x80>
 203f838:	e0bffd17 	ldw	r2,-12(fp)
 203f83c:	10800a17 	ldw	r2,40(r2)
 203f840:	10800243 	ldbu	r2,9(r2)
 203f844:	10803fcc 	andi	r2,r2,255
 203f848:	10000526 	beq	r2,zero,203f860 <poll_tcp+0x80>
      conn->current_msg->msg.sd.polls_left--;
 203f84c:	e0bffd17 	ldw	r2,-12(fp)
 203f850:	10800a17 	ldw	r2,40(r2)
 203f854:	10c00243 	ldbu	r3,9(r2)
 203f858:	18ffffc4 	addi	r3,r3,-1
 203f85c:	10c00245 	stb	r3,9(r2)
    }
#endif /* !LWIP_SO_SNDTIMEO && !LWIP_SO_LINGER */
    lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
 203f860:	e13ffd17 	ldw	r4,-12(fp)
 203f864:	204043c0 	call	204043c <lwip_netconn_do_close_internal>
  }
  /* @todo: implement connect timeout here? */

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
 203f868:	e0bffd17 	ldw	r2,-12(fp)
 203f86c:	10800903 	ldbu	r2,36(r2)
 203f870:	10803fcc 	andi	r2,r2,255
 203f874:	1080040c 	andi	r2,r2,16
 203f878:	10001f26 	beq	r2,zero,203f8f8 <poll_tcp+0x118>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 203f87c:	e0bffd17 	ldw	r2,-12(fp)
 203f880:	10800217 	ldw	r2,8(r2)
 203f884:	10001c26 	beq	r2,zero,203f8f8 <poll_tcp+0x118>
 203f888:	e0bffd17 	ldw	r2,-12(fp)
 203f88c:	10800217 	ldw	r2,8(r2)
 203f890:	10801b0b 	ldhu	r2,108(r2)
 203f894:	10bfffcc 	andi	r2,r2,65535
 203f898:	10816d70 	cmpltui	r2,r2,1461
 203f89c:	1000161e 	bne	r2,zero,203f8f8 <poll_tcp+0x118>
        (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
 203f8a0:	e0bffd17 	ldw	r2,-12(fp)
 203f8a4:	10800217 	ldw	r2,8(r2)
 203f8a8:	10801b8b 	ldhu	r2,110(r2)

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 203f8ac:	10bfffcc 	andi	r2,r2,65535
 203f8b0:	10800128 	cmpgeui	r2,r2,4
 203f8b4:	1000101e 	bne	r2,zero,203f8f8 <poll_tcp+0x118>
        (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      netconn_clear_flags(conn, NETCONN_FLAG_CHECK_WRITESPACE);
 203f8b8:	e0bffd17 	ldw	r2,-12(fp)
 203f8bc:	10c00903 	ldbu	r3,36(r2)
 203f8c0:	00bffbc4 	movi	r2,-17
 203f8c4:	1884703a 	and	r2,r3,r2
 203f8c8:	1007883a 	mov	r3,r2
 203f8cc:	e0bffd17 	ldw	r2,-12(fp)
 203f8d0:	10c00905 	stb	r3,36(r2)
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 203f8d4:	e0bffd17 	ldw	r2,-12(fp)
 203f8d8:	10800b17 	ldw	r2,44(r2)
 203f8dc:	10000626 	beq	r2,zero,203f8f8 <poll_tcp+0x118>
 203f8e0:	e0bffd17 	ldw	r2,-12(fp)
 203f8e4:	10800b17 	ldw	r2,44(r2)
 203f8e8:	000d883a 	mov	r6,zero
 203f8ec:	01400084 	movi	r5,2
 203f8f0:	e13ffd17 	ldw	r4,-12(fp)
 203f8f4:	103ee83a 	callr	r2
    }
  }

  return ERR_OK;
 203f8f8:	0005883a 	mov	r2,zero
}
 203f8fc:	e037883a 	mov	sp,fp
 203f900:	dfc00117 	ldw	ra,4(sp)
 203f904:	df000017 	ldw	fp,0(sp)
 203f908:	dec00204 	addi	sp,sp,8
 203f90c:	f800283a 	ret

0203f910 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
 203f910:	defffa04 	addi	sp,sp,-24
 203f914:	dfc00515 	stw	ra,20(sp)
 203f918:	df000415 	stw	fp,16(sp)
 203f91c:	df000404 	addi	fp,sp,16
 203f920:	e13ffd15 	stw	r4,-12(fp)
 203f924:	e17ffe15 	stw	r5,-8(fp)
 203f928:	3005883a 	mov	r2,r6
 203f92c:	e0bfff0d 	sth	r2,-4(fp)
  struct netconn *conn = (struct netconn *)arg;
 203f930:	e0bffd17 	ldw	r2,-12(fp)
 203f934:	e0bffc15 	stw	r2,-16(fp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn) {
 203f938:	e0bffc17 	ldw	r2,-16(fp)
 203f93c:	10002d26 	beq	r2,zero,203f9f4 <sent_tcp+0xe4>
    if (conn->state == NETCONN_WRITE) {
 203f940:	e0bffc17 	ldw	r2,-16(fp)
 203f944:	10800117 	ldw	r2,4(r2)
 203f948:	10800058 	cmpnei	r2,r2,1
 203f94c:	1000031e 	bne	r2,zero,203f95c <sent_tcp+0x4c>
      lwip_netconn_do_writemore(conn  WRITE_DELAYED);
 203f950:	e13ffc17 	ldw	r4,-16(fp)
 203f954:	20415ac0 	call	20415ac <lwip_netconn_do_writemore>
 203f958:	00000606 	br	203f974 <sent_tcp+0x64>
    } else if (conn->state == NETCONN_CLOSE) {
 203f95c:	e0bffc17 	ldw	r2,-16(fp)
 203f960:	10800117 	ldw	r2,4(r2)
 203f964:	10800118 	cmpnei	r2,r2,4
 203f968:	1000021e 	bne	r2,zero,203f974 <sent_tcp+0x64>
      lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
 203f96c:	e13ffc17 	ldw	r4,-16(fp)
 203f970:	204043c0 	call	204043c <lwip_netconn_do_close_internal>
    }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 203f974:	e0bffc17 	ldw	r2,-16(fp)
 203f978:	10800217 	ldw	r2,8(r2)
 203f97c:	10001d26 	beq	r2,zero,203f9f4 <sent_tcp+0xe4>
 203f980:	e0bffc17 	ldw	r2,-16(fp)
 203f984:	10800217 	ldw	r2,8(r2)
 203f988:	10801b0b 	ldhu	r2,108(r2)
 203f98c:	10bfffcc 	andi	r2,r2,65535
 203f990:	10816d70 	cmpltui	r2,r2,1461
 203f994:	1000171e 	bne	r2,zero,203f9f4 <sent_tcp+0xe4>
        (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
 203f998:	e0bffc17 	ldw	r2,-16(fp)
 203f99c:	10800217 	ldw	r2,8(r2)
 203f9a0:	10801b8b 	ldhu	r2,110(r2)
      lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
    }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 203f9a4:	10bfffcc 	andi	r2,r2,65535
 203f9a8:	10800128 	cmpgeui	r2,r2,4
 203f9ac:	1000111e 	bne	r2,zero,203f9f4 <sent_tcp+0xe4>
        (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      netconn_clear_flags(conn, NETCONN_FLAG_CHECK_WRITESPACE);
 203f9b0:	e0bffc17 	ldw	r2,-16(fp)
 203f9b4:	10c00903 	ldbu	r3,36(r2)
 203f9b8:	00bffbc4 	movi	r2,-17
 203f9bc:	1884703a 	and	r2,r3,r2
 203f9c0:	1007883a 	mov	r3,r2
 203f9c4:	e0bffc17 	ldw	r2,-16(fp)
 203f9c8:	10c00905 	stb	r3,36(r2)
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 203f9cc:	e0bffc17 	ldw	r2,-16(fp)
 203f9d0:	10800b17 	ldw	r2,44(r2)
 203f9d4:	10000726 	beq	r2,zero,203f9f4 <sent_tcp+0xe4>
 203f9d8:	e0bffc17 	ldw	r2,-16(fp)
 203f9dc:	10800b17 	ldw	r2,44(r2)
 203f9e0:	e0ffff0b 	ldhu	r3,-4(fp)
 203f9e4:	180d883a 	mov	r6,r3
 203f9e8:	01400084 	movi	r5,2
 203f9ec:	e13ffc17 	ldw	r4,-16(fp)
 203f9f0:	103ee83a 	callr	r2
    }
  }

  return ERR_OK;
 203f9f4:	0005883a 	mov	r2,zero
}
 203f9f8:	e037883a 	mov	sp,fp
 203f9fc:	dfc00117 	ldw	ra,4(sp)
 203fa00:	df000017 	ldw	fp,0(sp)
 203fa04:	dec00204 	addi	sp,sp,8
 203fa08:	f800283a 	ret

0203fa0c <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
 203fa0c:	defff604 	addi	sp,sp,-40
 203fa10:	dfc00915 	stw	ra,36(sp)
 203fa14:	df000815 	stw	fp,32(sp)
 203fa18:	df000804 	addi	fp,sp,32
 203fa1c:	e13ffe15 	stw	r4,-8(fp)
 203fa20:	2805883a 	mov	r2,r5
 203fa24:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *conn;
  enum netconn_state old_state;
  void *mbox_msg;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
 203fa28:	e0bffe17 	ldw	r2,-8(fp)
 203fa2c:	e0bff815 	stw	r2,-32(fp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  SYS_ARCH_PROTECT(lev);
 203fa30:	2014cec0 	call	2014cec <sys_arch_protect>
 203fa34:	e0bff915 	stw	r2,-28(fp)

  /* when err is called, the pcb is deallocated, so delete the reference */
  conn->pcb.tcp = NULL;
 203fa38:	e0bff817 	ldw	r2,-32(fp)
 203fa3c:	10000215 	stw	zero,8(r2)
  /* store pending error */
  conn->pending_err = err;
 203fa40:	e0bff817 	ldw	r2,-32(fp)
 203fa44:	e0ffff03 	ldbu	r3,-4(fp)
 203fa48:	10c00305 	stb	r3,12(r2)
  /* prevent application threads from blocking on 'recvmbox'/'acceptmbox' */
  conn->flags |= NETCONN_FLAG_MBOXCLOSED;
 203fa4c:	e0bff817 	ldw	r2,-32(fp)
 203fa50:	10800903 	ldbu	r2,36(r2)
 203fa54:	10800054 	ori	r2,r2,1
 203fa58:	1007883a 	mov	r3,r2
 203fa5c:	e0bff817 	ldw	r2,-32(fp)
 203fa60:	10c00905 	stb	r3,36(r2)

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
 203fa64:	e0bff817 	ldw	r2,-32(fp)
 203fa68:	10800117 	ldw	r2,4(r2)
 203fa6c:	e0bffa15 	stw	r2,-24(fp)
  conn->state = NETCONN_NONE;
 203fa70:	e0bff817 	ldw	r2,-32(fp)
 203fa74:	10000115 	stw	zero,4(r2)

  SYS_ARCH_UNPROTECT(lev);
 203fa78:	e13ff917 	ldw	r4,-28(fp)
 203fa7c:	2014d200 	call	2014d20 <sys_arch_unprotect>

  /* Notify the user layer about a connection error. Used to signal select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 203fa80:	e0bff817 	ldw	r2,-32(fp)
 203fa84:	10800b17 	ldw	r2,44(r2)
 203fa88:	10000626 	beq	r2,zero,203faa4 <err_tcp+0x98>
 203fa8c:	e0bff817 	ldw	r2,-32(fp)
 203fa90:	10800b17 	ldw	r2,44(r2)
 203fa94:	000d883a 	mov	r6,zero
 203fa98:	01400104 	movi	r5,4
 203fa9c:	e13ff817 	ldw	r4,-32(fp)
 203faa0:	103ee83a 	callr	r2
  /* Try to release selects pending on 'read' or 'write', too.
     They will get an error if they actually try to read or write. */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 203faa4:	e0bff817 	ldw	r2,-32(fp)
 203faa8:	10800b17 	ldw	r2,44(r2)
 203faac:	10000626 	beq	r2,zero,203fac8 <err_tcp+0xbc>
 203fab0:	e0bff817 	ldw	r2,-32(fp)
 203fab4:	10800b17 	ldw	r2,44(r2)
 203fab8:	000d883a 	mov	r6,zero
 203fabc:	000b883a 	mov	r5,zero
 203fac0:	e13ff817 	ldw	r4,-32(fp)
 203fac4:	103ee83a 	callr	r2
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 203fac8:	e0bff817 	ldw	r2,-32(fp)
 203facc:	10800b17 	ldw	r2,44(r2)
 203fad0:	10000626 	beq	r2,zero,203faec <err_tcp+0xe0>
 203fad4:	e0bff817 	ldw	r2,-32(fp)
 203fad8:	10800b17 	ldw	r2,44(r2)
 203fadc:	000d883a 	mov	r6,zero
 203fae0:	01400084 	movi	r5,2
 203fae4:	e13ff817 	ldw	r4,-32(fp)
 203fae8:	103ee83a 	callr	r2

  mbox_msg = lwip_netconn_err_to_msg(err);
 203faec:	e0bfff07 	ldb	r2,-4(fp)
 203faf0:	1009883a 	mov	r4,r2
 203faf4:	203f3540 	call	203f354 <lwip_netconn_err_to_msg>
 203faf8:	e0bffb15 	stw	r2,-20(fp)
  /* pass error message to recvmbox to wake up pending recv */
  if (NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
 203fafc:	e0bff817 	ldw	r2,-32(fp)
 203fb00:	10800504 	addi	r2,r2,20
 203fb04:	10000826 	beq	r2,zero,203fb28 <err_tcp+0x11c>
 203fb08:	e0bff817 	ldw	r2,-32(fp)
 203fb0c:	10800517 	ldw	r2,20(r2)
 203fb10:	10000526 	beq	r2,zero,203fb28 <err_tcp+0x11c>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, mbox_msg);
 203fb14:	e0bff817 	ldw	r2,-32(fp)
 203fb18:	10800504 	addi	r2,r2,20
 203fb1c:	e17ffb17 	ldw	r5,-20(fp)
 203fb20:	1009883a 	mov	r4,r2
 203fb24:	20152880 	call	2015288 <sys_mbox_trypost>
  }
  /* pass error message to acceptmbox to wake up pending accept */
  if (NETCONN_MBOX_VALID(conn, &conn->acceptmbox)) {
 203fb28:	e0bff817 	ldw	r2,-32(fp)
 203fb2c:	10800604 	addi	r2,r2,24
 203fb30:	10000826 	beq	r2,zero,203fb54 <err_tcp+0x148>
 203fb34:	e0bff817 	ldw	r2,-32(fp)
 203fb38:	10800617 	ldw	r2,24(r2)
 203fb3c:	10000526 	beq	r2,zero,203fb54 <err_tcp+0x148>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->acceptmbox, mbox_msg);
 203fb40:	e0bff817 	ldw	r2,-32(fp)
 203fb44:	10800604 	addi	r2,r2,24
 203fb48:	e17ffb17 	ldw	r5,-20(fp)
 203fb4c:	1009883a 	mov	r4,r2
 203fb50:	20152880 	call	2015288 <sys_mbox_trypost>
  }

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
 203fb54:	e0bffa17 	ldw	r2,-24(fp)
 203fb58:	10800060 	cmpeqi	r2,r2,1
 203fb5c:	1000061e 	bne	r2,zero,203fb78 <err_tcp+0x16c>
 203fb60:	e0bffa17 	ldw	r2,-24(fp)
 203fb64:	10800120 	cmpeqi	r2,r2,4
 203fb68:	1000031e 	bne	r2,zero,203fb78 <err_tcp+0x16c>
 203fb6c:	e0bffa17 	ldw	r2,-24(fp)
 203fb70:	108000d8 	cmpnei	r2,r2,3
 203fb74:	1000241e 	bne	r2,zero,203fc08 <err_tcp+0x1fc>
      (old_state == NETCONN_CONNECT)) {
    /* calling lwip_netconn_do_writemore/lwip_netconn_do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
 203fb78:	e0bff817 	ldw	r2,-32(fp)
 203fb7c:	10800903 	ldbu	r2,36(r2)
 203fb80:	10803fcc 	andi	r2,r2,255
 203fb84:	1080010c 	andi	r2,r2,4
 203fb88:	1004c03a 	cmpne	r2,r2,zero
 203fb8c:	10803fcc 	andi	r2,r2,255
 203fb90:	e0bffc15 	stw	r2,-16(fp)
    SET_NONBLOCKING_CONNECT(conn, 0);
 203fb94:	e0bff817 	ldw	r2,-32(fp)
 203fb98:	10c00903 	ldbu	r3,36(r2)
 203fb9c:	00bffec4 	movi	r2,-5
 203fba0:	1884703a 	and	r2,r3,r2
 203fba4:	1007883a 	mov	r3,r2
 203fba8:	e0bff817 	ldw	r2,-32(fp)
 203fbac:	10c00905 	stb	r3,36(r2)

    if (!was_nonblocking_connect) {
 203fbb0:	e0bffc17 	ldw	r2,-16(fp)
 203fbb4:	1000141e 	bne	r2,zero,203fc08 <err_tcp+0x1fc>
      sys_sem_t *op_completed_sem;
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      if (old_state == NETCONN_CLOSE) {
 203fbb8:	e0bffa17 	ldw	r2,-24(fp)
 203fbbc:	10800118 	cmpnei	r2,r2,4
 203fbc0:	1000041e 	bne	r2,zero,203fbd4 <err_tcp+0x1c8>
        /* let close succeed: the connection is closed after all... */
        conn->current_msg->err = ERR_OK;
 203fbc4:	e0bff817 	ldw	r2,-32(fp)
 203fbc8:	10800a17 	ldw	r2,40(r2)
 203fbcc:	10000105 	stb	zero,4(r2)
 203fbd0:	00000406 	br	203fbe4 <err_tcp+0x1d8>
      } else {
        /* Write and connect fail */
        conn->current_msg->err = err;
 203fbd4:	e0bff817 	ldw	r2,-32(fp)
 203fbd8:	10800a17 	ldw	r2,40(r2)
 203fbdc:	e0ffff03 	ldbu	r3,-4(fp)
 203fbe0:	10c00105 	stb	r3,4(r2)
      }
      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 203fbe4:	e0bff817 	ldw	r2,-32(fp)
 203fbe8:	10800a17 	ldw	r2,40(r2)
 203fbec:	10800017 	ldw	r2,0(r2)
 203fbf0:	10800404 	addi	r2,r2,16
 203fbf4:	e0bffd15 	stw	r2,-12(fp)
      LWIP_ASSERT("invalid op_completed_sem", sys_sem_valid(op_completed_sem));
      conn->current_msg = NULL;
 203fbf8:	e0bff817 	ldw	r2,-32(fp)
 203fbfc:	10000a15 	stw	zero,40(r2)
      /* wake up the waiting task */
      sys_sem_signal(op_completed_sem);
 203fc00:	e13ffd17 	ldw	r4,-12(fp)
 203fc04:	20150340 	call	2015034 <sys_sem_signal>
      /* @todo: test what happens for error on nonblocking connect */
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  }
}
 203fc08:	0001883a 	nop
 203fc0c:	e037883a 	mov	sp,fp
 203fc10:	dfc00117 	ldw	ra,4(sp)
 203fc14:	df000017 	ldw	fp,0(sp)
 203fc18:	dec00204 	addi	sp,sp,8
 203fc1c:	f800283a 	ret

0203fc20 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
 203fc20:	defffc04 	addi	sp,sp,-16
 203fc24:	dfc00315 	stw	ra,12(sp)
 203fc28:	df000215 	stw	fp,8(sp)
 203fc2c:	df000204 	addi	fp,sp,8
 203fc30:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
 203fc34:	e0bfff17 	ldw	r2,-4(fp)
 203fc38:	10800217 	ldw	r2,8(r2)
 203fc3c:	e0bffe15 	stw	r2,-8(fp)
  tcp_arg(pcb, conn);
 203fc40:	e17fff17 	ldw	r5,-4(fp)
 203fc44:	e13ffe17 	ldw	r4,-8(fp)
 203fc48:	20215d40 	call	20215d4 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
 203fc4c:	01408134 	movhi	r5,516
 203fc50:	297db104 	addi	r5,r5,-2364
 203fc54:	e13ffe17 	ldw	r4,-8(fp)
 203fc58:	20216100 	call	2021610 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
 203fc5c:	01408134 	movhi	r5,516
 203fc60:	297e4404 	addi	r5,r5,-1776
 203fc64:	e13ffe17 	ldw	r4,-8(fp)
 203fc68:	202164c0 	call	202164c <tcp_sent>
  tcp_poll(pcb, poll_tcp, NETCONN_TCP_POLL_INTERVAL);
 203fc6c:	01800084 	movi	r6,2
 203fc70:	01408134 	movhi	r5,516
 203fc74:	297df804 	addi	r5,r5,-2080
 203fc78:	e13ffe17 	ldw	r4,-8(fp)
 203fc7c:	20217180 	call	2021718 <tcp_poll>
  tcp_err(pcb, err_tcp);
 203fc80:	01408134 	movhi	r5,516
 203fc84:	297e8304 	addi	r5,r5,-1524
 203fc88:	e13ffe17 	ldw	r4,-8(fp)
 203fc8c:	20216880 	call	2021688 <tcp_err>
}
 203fc90:	0001883a 	nop
 203fc94:	e037883a 	mov	sp,fp
 203fc98:	dfc00117 	ldw	ra,4(sp)
 203fc9c:	df000017 	ldw	fp,0(sp)
 203fca0:	dec00204 	addi	sp,sp,8
 203fca4:	f800283a 	ret

0203fca8 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 203fca8:	defff704 	addi	sp,sp,-36
 203fcac:	dfc00815 	stw	ra,32(sp)
 203fcb0:	df000715 	stw	fp,28(sp)
 203fcb4:	dc000615 	stw	r16,24(sp)
 203fcb8:	df000704 	addi	fp,sp,28
 203fcbc:	e13ffc15 	stw	r4,-16(fp)
 203fcc0:	e17ffd15 	stw	r5,-12(fp)
 203fcc4:	3005883a 	mov	r2,r6
 203fcc8:	e0bffe05 	stb	r2,-8(fp)
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;
 203fccc:	e0bffc17 	ldw	r2,-16(fp)
 203fcd0:	e0bff915 	stw	r2,-28(fp)

  if (conn == NULL) {
 203fcd4:	e0bff917 	ldw	r2,-28(fp)
 203fcd8:	1000021e 	bne	r2,zero,203fce4 <accept_function+0x3c>
    return ERR_VAL;
 203fcdc:	00bffe84 	movi	r2,-6
 203fce0:	00007906 	br	203fec8 <accept_function+0x220>
  }
  if (!NETCONN_MBOX_VALID(conn, &conn->acceptmbox)) {
 203fce4:	e0bff917 	ldw	r2,-28(fp)
 203fce8:	10800604 	addi	r2,r2,24
 203fcec:	10000326 	beq	r2,zero,203fcfc <accept_function+0x54>
 203fcf0:	e0bff917 	ldw	r2,-28(fp)
 203fcf4:	10800617 	ldw	r2,24(r2)
 203fcf8:	1000021e 	bne	r2,zero,203fd04 <accept_function+0x5c>
    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
    return ERR_VAL;
 203fcfc:	00bffe84 	movi	r2,-6
 203fd00:	00007106 	br	203fec8 <accept_function+0x220>
  }

  if (newpcb == NULL) {
 203fd04:	e0bffd17 	ldw	r2,-12(fp)
 203fd08:	1000161e 	bne	r2,zero,203fd64 <accept_function+0xbc>
    /* out-of-pcbs during connect: pass on this error to the application */
    if (sys_mbox_trypost(&conn->acceptmbox, lwip_netconn_err_to_msg(ERR_ABRT)) == ERR_OK) {
 203fd0c:	e0bff917 	ldw	r2,-28(fp)
 203fd10:	14000604 	addi	r16,r2,24
 203fd14:	013ffcc4 	movi	r4,-13
 203fd18:	203f3540 	call	203f354 <lwip_netconn_err_to_msg>
 203fd1c:	100b883a 	mov	r5,r2
 203fd20:	8009883a 	mov	r4,r16
 203fd24:	20152880 	call	2015288 <sys_mbox_trypost>
 203fd28:	10803fcc 	andi	r2,r2,255
 203fd2c:	1080201c 	xori	r2,r2,128
 203fd30:	10bfe004 	addi	r2,r2,-128
 203fd34:	1000091e 	bne	r2,zero,203fd5c <accept_function+0xb4>
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 203fd38:	e0bff917 	ldw	r2,-28(fp)
 203fd3c:	10800b17 	ldw	r2,44(r2)
 203fd40:	10000626 	beq	r2,zero,203fd5c <accept_function+0xb4>
 203fd44:	e0bff917 	ldw	r2,-28(fp)
 203fd48:	10800b17 	ldw	r2,44(r2)
 203fd4c:	000d883a 	mov	r6,zero
 203fd50:	000b883a 	mov	r5,zero
 203fd54:	e13ff917 	ldw	r4,-28(fp)
 203fd58:	103ee83a 	callr	r2
    }
    return ERR_VAL;
 203fd5c:	00bffe84 	movi	r2,-6
 203fd60:	00005906 	br	203fec8 <accept_function+0x220>

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->state: %s\n", tcp_debug_state_str(newpcb->state)));

  /* We have to set the callback here even though
   * the new socket is unknown. newconn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
 203fd64:	e0bff917 	ldw	r2,-28(fp)
 203fd68:	10c00017 	ldw	r3,0(r2)
 203fd6c:	e0bff917 	ldw	r2,-28(fp)
 203fd70:	10800b17 	ldw	r2,44(r2)
 203fd74:	100b883a 	mov	r5,r2
 203fd78:	1809883a 	mov	r4,r3
 203fd7c:	20401100 	call	2040110 <netconn_alloc>
 203fd80:	e0bffa15 	stw	r2,-24(fp)
  if (newconn == NULL) {
 203fd84:	e0bffa17 	ldw	r2,-24(fp)
 203fd88:	1000161e 	bne	r2,zero,203fde4 <accept_function+0x13c>
    /* outof netconns: pass on this error to the application */
    if (sys_mbox_trypost(&conn->acceptmbox, lwip_netconn_err_to_msg(ERR_ABRT)) == ERR_OK) {
 203fd8c:	e0bff917 	ldw	r2,-28(fp)
 203fd90:	14000604 	addi	r16,r2,24
 203fd94:	013ffcc4 	movi	r4,-13
 203fd98:	203f3540 	call	203f354 <lwip_netconn_err_to_msg>
 203fd9c:	100b883a 	mov	r5,r2
 203fda0:	8009883a 	mov	r4,r16
 203fda4:	20152880 	call	2015288 <sys_mbox_trypost>
 203fda8:	10803fcc 	andi	r2,r2,255
 203fdac:	1080201c 	xori	r2,r2,128
 203fdb0:	10bfe004 	addi	r2,r2,-128
 203fdb4:	1000091e 	bne	r2,zero,203fddc <accept_function+0x134>
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 203fdb8:	e0bff917 	ldw	r2,-28(fp)
 203fdbc:	10800b17 	ldw	r2,44(r2)
 203fdc0:	10000626 	beq	r2,zero,203fddc <accept_function+0x134>
 203fdc4:	e0bff917 	ldw	r2,-28(fp)
 203fdc8:	10800b17 	ldw	r2,44(r2)
 203fdcc:	000d883a 	mov	r6,zero
 203fdd0:	000b883a 	mov	r5,zero
 203fdd4:	e13ff917 	ldw	r4,-28(fp)
 203fdd8:	103ee83a 	callr	r2
    }
    return ERR_MEM;
 203fddc:	00bfffc4 	movi	r2,-1
 203fde0:	00003906 	br	203fec8 <accept_function+0x220>
  }
  newconn->pcb.tcp = newpcb;
 203fde4:	e0bffa17 	ldw	r2,-24(fp)
 203fde8:	e0fffd17 	ldw	r3,-12(fp)
 203fdec:	10c00215 	stw	r3,8(r2)
  setup_tcp(newconn);
 203fdf0:	e13ffa17 	ldw	r4,-24(fp)
 203fdf4:	203fc200 	call	203fc20 <setup_tcp>

  /* handle backlog counter */
  tcp_backlog_delayed(newpcb);
 203fdf8:	e13ffd17 	ldw	r4,-12(fp)
 203fdfc:	201ef380 	call	201ef38 <tcp_backlog_delayed>

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 203fe00:	e0bff917 	ldw	r2,-28(fp)
 203fe04:	10800604 	addi	r2,r2,24
 203fe08:	e17ffa17 	ldw	r5,-24(fp)
 203fe0c:	1009883a 	mov	r4,r2
 203fe10:	20152880 	call	2015288 <sys_mbox_trypost>
 203fe14:	10803fcc 	andi	r2,r2,255
 203fe18:	1080201c 	xori	r2,r2,128
 203fe1c:	10bfe004 	addi	r2,r2,-128
 203fe20:	10001f26 	beq	r2,zero,203fea0 <accept_function+0x1f8>
    /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
       so do nothing here! */
    /* remove all references to this netconn from the pcb */
    struct tcp_pcb *pcb = newconn->pcb.tcp;
 203fe24:	e0bffa17 	ldw	r2,-24(fp)
 203fe28:	10800217 	ldw	r2,8(r2)
 203fe2c:	e0bffb15 	stw	r2,-20(fp)
    tcp_arg(pcb, NULL);
 203fe30:	000b883a 	mov	r5,zero
 203fe34:	e13ffb17 	ldw	r4,-20(fp)
 203fe38:	20215d40 	call	20215d4 <tcp_arg>
    tcp_recv(pcb, NULL);
 203fe3c:	000b883a 	mov	r5,zero
 203fe40:	e13ffb17 	ldw	r4,-20(fp)
 203fe44:	20216100 	call	2021610 <tcp_recv>
    tcp_sent(pcb, NULL);
 203fe48:	000b883a 	mov	r5,zero
 203fe4c:	e13ffb17 	ldw	r4,-20(fp)
 203fe50:	202164c0 	call	202164c <tcp_sent>
    tcp_poll(pcb, NULL, 0);
 203fe54:	000d883a 	mov	r6,zero
 203fe58:	000b883a 	mov	r5,zero
 203fe5c:	e13ffb17 	ldw	r4,-20(fp)
 203fe60:	20217180 	call	2021718 <tcp_poll>
    tcp_err(pcb, NULL);
 203fe64:	000b883a 	mov	r5,zero
 203fe68:	e13ffb17 	ldw	r4,-20(fp)
 203fe6c:	20216880 	call	2021688 <tcp_err>
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
 203fe70:	e0bffa17 	ldw	r2,-24(fp)
 203fe74:	10000215 	stw	zero,8(r2)
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
 203fe78:	e0bffa17 	ldw	r2,-24(fp)
 203fe7c:	10800504 	addi	r2,r2,20
 203fe80:	1009883a 	mov	r4,r2
 203fe84:	20154c80 	call	20154c8 <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
 203fe88:	e0bffa17 	ldw	r2,-24(fp)
 203fe8c:	10000515 	stw	zero,20(r2)
    netconn_free(newconn);
 203fe90:	e13ffa17 	ldw	r4,-24(fp)
 203fe94:	204027c0 	call	204027c <netconn_free>
    return ERR_MEM;
 203fe98:	00bfffc4 	movi	r2,-1
 203fe9c:	00000a06 	br	203fec8 <accept_function+0x220>
  } else {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 203fea0:	e0bff917 	ldw	r2,-28(fp)
 203fea4:	10800b17 	ldw	r2,44(r2)
 203fea8:	10000626 	beq	r2,zero,203fec4 <accept_function+0x21c>
 203feac:	e0bff917 	ldw	r2,-28(fp)
 203feb0:	10800b17 	ldw	r2,44(r2)
 203feb4:	000d883a 	mov	r6,zero
 203feb8:	000b883a 	mov	r5,zero
 203febc:	e13ff917 	ldw	r4,-28(fp)
 203fec0:	103ee83a 	callr	r2
  }

  return ERR_OK;
 203fec4:	0005883a 	mov	r2,zero
}
 203fec8:	e6ffff04 	addi	sp,fp,-4
 203fecc:	dfc00217 	ldw	ra,8(sp)
 203fed0:	df000117 	ldw	fp,4(sp)
 203fed4:	dc000017 	ldw	r16,0(sp)
 203fed8:	dec00304 	addi	sp,sp,12
 203fedc:	f800283a 	ret

0203fee0 <pcb_new>:
 *
 * @param msg the api_msg describing the connection type
 */
static void
pcb_new(struct api_msg *msg)
{
 203fee0:	defffb04 	addi	sp,sp,-20
 203fee4:	dfc00415 	stw	ra,16(sp)
 203fee8:	df000315 	stw	fp,12(sp)
 203feec:	dc000215 	stw	r16,8(sp)
 203fef0:	df000304 	addi	fp,sp,12
 203fef4:	e13ffe15 	stw	r4,-8(fp)
  enum lwip_ip_addr_type iptype = IPADDR_TYPE_V4;
 203fef8:	e03ffd15 	stw	zero,-12(fp)
    iptype = IPADDR_TYPE_ANY;
  }
#endif

  /* Allocate a PCB for this connection */
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 203fefc:	e0bffe17 	ldw	r2,-8(fp)
 203ff00:	10800017 	ldw	r2,0(r2)
 203ff04:	10800017 	ldw	r2,0(r2)
 203ff08:	10803c0c 	andi	r2,r2,240
 203ff0c:	10c00820 	cmpeqi	r3,r2,32
 203ff10:	18001f1e 	bne	r3,zero,203ff90 <pcb_new+0xb0>
 203ff14:	10c01020 	cmpeqi	r3,r2,64
 203ff18:	1800031e 	bne	r3,zero,203ff28 <pcb_new+0x48>
 203ff1c:	10800420 	cmpeqi	r2,r2,16
 203ff20:	10003b1e 	bne	r2,zero,2040010 <pcb_new+0x130>
 203ff24:	00004a06 	br	2040050 <pcb_new+0x170>
#if LWIP_RAW
    case NETCONN_RAW:
      msg->conn->pcb.raw = raw_new_ip_type(iptype, msg->msg.n.proto);
 203ff28:	e0bffe17 	ldw	r2,-8(fp)
 203ff2c:	14000017 	ldw	r16,0(r2)
 203ff30:	e0bffd17 	ldw	r2,-12(fp)
 203ff34:	10c03fcc 	andi	r3,r2,255
 203ff38:	e0bffe17 	ldw	r2,-8(fp)
 203ff3c:	10800203 	ldbu	r2,8(r2)
 203ff40:	10803fcc 	andi	r2,r2,255
 203ff44:	100b883a 	mov	r5,r2
 203ff48:	1809883a 	mov	r4,r3
 203ff4c:	201ec840 	call	201ec84 <raw_new_ip_type>
 203ff50:	80800215 	stw	r2,8(r16)
      if (msg->conn->pcb.raw != NULL) {
 203ff54:	e0bffe17 	ldw	r2,-8(fp)
 203ff58:	10800017 	ldw	r2,0(r2)
 203ff5c:	10800217 	ldw	r2,8(r2)
 203ff60:	10003f26 	beq	r2,zero,2040060 <pcb_new+0x180>
        if (NETCONNTYPE_ISIPV6(msg->conn->type) && msg->conn->pcb.raw->protocol == IP6_NEXTH_ICMP6) {
          msg->conn->pcb.raw->chksum_reqd = 1;
          msg->conn->pcb.raw->chksum_offset = 2;
        }
#endif /* LWIP_IPV6 */
        raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
 203ff64:	e0bffe17 	ldw	r2,-8(fp)
 203ff68:	10800017 	ldw	r2,0(r2)
 203ff6c:	10c00217 	ldw	r3,8(r2)
 203ff70:	e0bffe17 	ldw	r2,-8(fp)
 203ff74:	10800017 	ldw	r2,0(r2)
 203ff78:	100d883a 	mov	r6,r2
 203ff7c:	01408134 	movhi	r5,516
 203ff80:	297d0f04 	addi	r5,r5,-3012
 203ff84:	1809883a 	mov	r4,r3
 203ff88:	201e7cc0 	call	201e7cc <raw_recv>
      }
      break;
 203ff8c:	00003406 	br	2040060 <pcb_new+0x180>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp = udp_new_ip_type(iptype);
 203ff90:	e0bffe17 	ldw	r2,-8(fp)
 203ff94:	14000017 	ldw	r16,0(r2)
 203ff98:	e0bffd17 	ldw	r2,-12(fp)
 203ff9c:	10803fcc 	andi	r2,r2,255
 203ffa0:	1009883a 	mov	r4,r2
 203ffa4:	202ac3c0 	call	202ac3c <udp_new_ip_type>
 203ffa8:	80800215 	stw	r2,8(r16)
      if (msg->conn->pcb.udp != NULL) {
 203ffac:	e0bffe17 	ldw	r2,-8(fp)
 203ffb0:	10800017 	ldw	r2,0(r2)
 203ffb4:	10800217 	ldw	r2,8(r2)
 203ffb8:	10002b26 	beq	r2,zero,2040068 <pcb_new+0x188>
#if LWIP_UDPLITE
        if (NETCONNTYPE_ISUDPLITE(msg->conn->type)) {
          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
        }
#endif /* LWIP_UDPLITE */
        if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
 203ffbc:	e0bffe17 	ldw	r2,-8(fp)
 203ffc0:	10800017 	ldw	r2,0(r2)
 203ffc4:	10800017 	ldw	r2,0(r2)
 203ffc8:	10800898 	cmpnei	r2,r2,34
 203ffcc:	1000051e 	bne	r2,zero,203ffe4 <pcb_new+0x104>
          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 203ffd0:	e0bffe17 	ldw	r2,-8(fp)
 203ffd4:	10800017 	ldw	r2,0(r2)
 203ffd8:	10800217 	ldw	r2,8(r2)
 203ffdc:	00c00044 	movi	r3,1
 203ffe0:	10c00505 	stb	r3,20(r2)
        }
        udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 203ffe4:	e0bffe17 	ldw	r2,-8(fp)
 203ffe8:	10800017 	ldw	r2,0(r2)
 203ffec:	10c00217 	ldw	r3,8(r2)
 203fff0:	e0bffe17 	ldw	r2,-8(fp)
 203fff4:	10800017 	ldw	r2,0(r2)
 203fff8:	100d883a 	mov	r6,r2
 203fffc:	01408134 	movhi	r5,516
 2040000:	297d6104 	addi	r5,r5,-2684
 2040004:	1809883a 	mov	r4,r3
 2040008:	202aae40 	call	202aae4 <udp_recv>
      }
      break;
 204000c:	00001606 	br	2040068 <pcb_new+0x188>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_new_ip_type(iptype);
 2040010:	e0bffe17 	ldw	r2,-8(fp)
 2040014:	14000017 	ldw	r16,0(r2)
 2040018:	e0bffd17 	ldw	r2,-12(fp)
 204001c:	10803fcc 	andi	r2,r2,255
 2040020:	1009883a 	mov	r4,r2
 2040024:	20215980 	call	2021598 <tcp_new_ip_type>
 2040028:	80800215 	stw	r2,8(r16)
      if (msg->conn->pcb.tcp != NULL) {
 204002c:	e0bffe17 	ldw	r2,-8(fp)
 2040030:	10800017 	ldw	r2,0(r2)
 2040034:	10800217 	ldw	r2,8(r2)
 2040038:	10000d26 	beq	r2,zero,2040070 <pcb_new+0x190>
        setup_tcp(msg->conn);
 204003c:	e0bffe17 	ldw	r2,-8(fp)
 2040040:	10800017 	ldw	r2,0(r2)
 2040044:	1009883a 	mov	r4,r2
 2040048:	203fc200 	call	203fc20 <setup_tcp>
      }
      break;
 204004c:	00000806 	br	2040070 <pcb_new+0x190>
#endif /* LWIP_TCP */
    default:
      /* Unsupported netconn type, e.g. protocol disabled */
      msg->err = ERR_VAL;
 2040050:	e0bffe17 	ldw	r2,-8(fp)
 2040054:	00fffe84 	movi	r3,-6
 2040058:	10c00105 	stb	r3,4(r2)
      return;
 204005c:	00000c06 	br	2040090 <pcb_new+0x1b0>
          msg->conn->pcb.raw->chksum_offset = 2;
        }
#endif /* LWIP_IPV6 */
        raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
      }
      break;
 2040060:	0001883a 	nop
 2040064:	00000306 	br	2040074 <pcb_new+0x194>
        if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
        }
        udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
      }
      break;
 2040068:	0001883a 	nop
 204006c:	00000106 	br	2040074 <pcb_new+0x194>
    case NETCONN_TCP:
      msg->conn->pcb.tcp = tcp_new_ip_type(iptype);
      if (msg->conn->pcb.tcp != NULL) {
        setup_tcp(msg->conn);
      }
      break;
 2040070:	0001883a 	nop
    default:
      /* Unsupported netconn type, e.g. protocol disabled */
      msg->err = ERR_VAL;
      return;
  }
  if (msg->conn->pcb.ip == NULL) {
 2040074:	e0bffe17 	ldw	r2,-8(fp)
 2040078:	10800017 	ldw	r2,0(r2)
 204007c:	10800217 	ldw	r2,8(r2)
 2040080:	1000031e 	bne	r2,zero,2040090 <pcb_new+0x1b0>
    msg->err = ERR_MEM;
 2040084:	e0bffe17 	ldw	r2,-8(fp)
 2040088:	00ffffc4 	movi	r3,-1
 204008c:	10c00105 	stb	r3,4(r2)
  }
}
 2040090:	e6ffff04 	addi	sp,fp,-4
 2040094:	dfc00217 	ldw	ra,8(sp)
 2040098:	df000117 	ldw	fp,4(sp)
 204009c:	dc000017 	ldw	r16,0(sp)
 20400a0:	dec00304 	addi	sp,sp,12
 20400a4:	f800283a 	ret

020400a8 <lwip_netconn_do_newconn>:
 *
 * @param m the api_msg describing the connection type
 */
void
lwip_netconn_do_newconn(void *m)
{
 20400a8:	defffc04 	addi	sp,sp,-16
 20400ac:	dfc00315 	stw	ra,12(sp)
 20400b0:	df000215 	stw	fp,8(sp)
 20400b4:	df000204 	addi	fp,sp,8
 20400b8:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 20400bc:	e0bfff17 	ldw	r2,-4(fp)
 20400c0:	e0bffe15 	stw	r2,-8(fp)

  msg->err = ERR_OK;
 20400c4:	e0bffe17 	ldw	r2,-8(fp)
 20400c8:	10000105 	stb	zero,4(r2)
  if (msg->conn->pcb.tcp == NULL) {
 20400cc:	e0bffe17 	ldw	r2,-8(fp)
 20400d0:	10800017 	ldw	r2,0(r2)
 20400d4:	10800217 	ldw	r2,8(r2)
 20400d8:	1000021e 	bne	r2,zero,20400e4 <lwip_netconn_do_newconn+0x3c>
    pcb_new(msg);
 20400dc:	e13ffe17 	ldw	r4,-8(fp)
 20400e0:	203fee00 	call	203fee0 <pcb_new>
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
 20400e4:	e0bffe17 	ldw	r2,-8(fp)
 20400e8:	10800017 	ldw	r2,0(r2)
 20400ec:	10800404 	addi	r2,r2,16
 20400f0:	1009883a 	mov	r4,r2
 20400f4:	20150340 	call	2015034 <sys_sem_signal>
}
 20400f8:	0001883a 	nop
 20400fc:	e037883a 	mov	sp,fp
 2040100:	dfc00117 	ldw	ra,4(sp)
 2040104:	df000017 	ldw	fp,0(sp)
 2040108:	dec00204 	addi	sp,sp,8
 204010c:	f800283a 	ret

02040110 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn *
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
 2040110:	defff904 	addi	sp,sp,-28
 2040114:	dfc00615 	stw	ra,24(sp)
 2040118:	df000515 	stw	fp,20(sp)
 204011c:	df000504 	addi	fp,sp,20
 2040120:	e13ffe15 	stw	r4,-8(fp)
 2040124:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn;
  int size;
  u8_t init_flags = 0;
 2040128:	e03ffc05 	stb	zero,-16(fp)

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 204012c:	01000204 	movi	r4,8
 2040130:	201b82c0 	call	201b82c <memp_malloc>
 2040134:	e0bffd15 	stw	r2,-12(fp)
  if (conn == NULL) {
 2040138:	e0bffd17 	ldw	r2,-12(fp)
 204013c:	1000021e 	bne	r2,zero,2040148 <netconn_alloc+0x38>
    return NULL;
 2040140:	0005883a 	mov	r2,zero
 2040144:	00004806 	br	2040268 <netconn_alloc+0x158>
  }

  conn->pending_err = ERR_OK;
 2040148:	e0bffd17 	ldw	r2,-12(fp)
 204014c:	10000305 	stb	zero,12(r2)
  conn->type = t;
 2040150:	e0bffd17 	ldw	r2,-12(fp)
 2040154:	e0fffe17 	ldw	r3,-8(fp)
 2040158:	10c00015 	stw	r3,0(r2)
  conn->pcb.tcp = NULL;
 204015c:	e0bffd17 	ldw	r2,-12(fp)
 2040160:	10000215 	stw	zero,8(r2)
#if LWIP_NETCONN_FULLDUPLEX
  conn->mbox_threads_waiting = 0;
#endif

  /* If all sizes are the same, every compiler should optimize this switch to nothing */
  switch (NETCONNTYPE_GROUP(t)) {
 2040164:	e0bffe17 	ldw	r2,-8(fp)
 2040168:	10803c0c 	andi	r2,r2,240
 204016c:	10c00820 	cmpeqi	r3,r2,32
 2040170:	1800081e 	bne	r3,zero,2040194 <netconn_alloc+0x84>
 2040174:	10c01020 	cmpeqi	r3,r2,64
 2040178:	1800031e 	bne	r3,zero,2040188 <netconn_alloc+0x78>
 204017c:	10800420 	cmpeqi	r2,r2,16
 2040180:	1000071e 	bne	r2,zero,20401a0 <netconn_alloc+0x90>
      size = DEFAULT_TCP_RECVMBOX_SIZE;
      break;
#endif /* LWIP_TCP */
    default:
      LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
      goto free_and_return;
 2040184:	00003406 	br	2040258 <netconn_alloc+0x148>

  /* If all sizes are the same, every compiler should optimize this switch to nothing */
  switch (NETCONNTYPE_GROUP(t)) {
#if LWIP_RAW
    case NETCONN_RAW:
      size = DEFAULT_RAW_RECVMBOX_SIZE;
 2040188:	00840004 	movi	r2,4096
 204018c:	e0bffb15 	stw	r2,-20(fp)
      break;
 2040190:	00000606 	br	20401ac <netconn_alloc+0x9c>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      size = DEFAULT_UDP_RECVMBOX_SIZE;
 2040194:	00840004 	movi	r2,4096
 2040198:	e0bffb15 	stw	r2,-20(fp)
#if LWIP_NETBUF_RECVINFO
      init_flags |= NETCONN_FLAG_PKTINFO;
#endif /* LWIP_NETBUF_RECVINFO */
      break;
 204019c:	00000306 	br	20401ac <netconn_alloc+0x9c>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      size = DEFAULT_TCP_RECVMBOX_SIZE;
 20401a0:	00840004 	movi	r2,4096
 20401a4:	e0bffb15 	stw	r2,-20(fp)
      break;
 20401a8:	0001883a 	nop
    default:
      LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
      goto free_and_return;
  }

  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
 20401ac:	e0bffd17 	ldw	r2,-12(fp)
 20401b0:	10800504 	addi	r2,r2,20
 20401b4:	e17ffb17 	ldw	r5,-20(fp)
 20401b8:	1009883a 	mov	r4,r2
 20401bc:	20151640 	call	2015164 <sys_mbox_new>
 20401c0:	10803fcc 	andi	r2,r2,255
 20401c4:	1080201c 	xori	r2,r2,128
 20401c8:	10bfe004 	addi	r2,r2,-128
 20401cc:	1000211e 	bne	r2,zero,2040254 <netconn_alloc+0x144>
    goto free_and_return;
  }
#if !LWIP_NETCONN_SEM_PER_THREAD
  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 20401d0:	e0bffd17 	ldw	r2,-12(fp)
 20401d4:	10800404 	addi	r2,r2,16
 20401d8:	000b883a 	mov	r5,zero
 20401dc:	1009883a 	mov	r4,r2
 20401e0:	2014f380 	call	2014f38 <sys_sem_new>
 20401e4:	10803fcc 	andi	r2,r2,255
 20401e8:	1080201c 	xori	r2,r2,128
 20401ec:	10bfe004 	addi	r2,r2,-128
 20401f0:	10000526 	beq	r2,zero,2040208 <netconn_alloc+0xf8>
    sys_mbox_free(&conn->recvmbox);
 20401f4:	e0bffd17 	ldw	r2,-12(fp)
 20401f8:	10800504 	addi	r2,r2,20
 20401fc:	1009883a 	mov	r4,r2
 2040200:	20154c80 	call	20154c8 <sys_mbox_free>
    goto free_and_return;
 2040204:	00001406 	br	2040258 <netconn_alloc+0x148>
  }
#endif

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
 2040208:	e0bffd17 	ldw	r2,-12(fp)
 204020c:	10000615 	stw	zero,24(r2)
#endif
  conn->state        = NETCONN_NONE;
 2040210:	e0bffd17 	ldw	r2,-12(fp)
 2040214:	10000115 	stw	zero,4(r2)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->callback_arg.socket = -1;
 2040218:	e0bffd17 	ldw	r2,-12(fp)
 204021c:	00ffffc4 	movi	r3,-1
 2040220:	10c00715 	stw	r3,28(r2)
  conn->callback     = callback;
 2040224:	e0bffd17 	ldw	r2,-12(fp)
 2040228:	e0ffff17 	ldw	r3,-4(fp)
 204022c:	10c00b15 	stw	r3,44(r2)
#if LWIP_TCP
  conn->current_msg  = NULL;
 2040230:	e0bffd17 	ldw	r2,-12(fp)
 2040234:	10000a15 	stw	zero,40(r2)
#endif /* LWIP_TCP */
#if LWIP_SO_SNDTIMEO
  conn->send_timeout = 0;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
  conn->recv_timeout = 0;
 2040238:	e0bffd17 	ldw	r2,-12(fp)
 204023c:	10000815 	stw	zero,32(r2)
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_SO_LINGER
  conn->linger = -1;
#endif /* LWIP_SO_LINGER */
  conn->flags = init_flags;
 2040240:	e0bffd17 	ldw	r2,-12(fp)
 2040244:	e0fffc03 	ldbu	r3,-16(fp)
 2040248:	10c00905 	stb	r3,36(r2)
  return conn;
 204024c:	e0bffd17 	ldw	r2,-12(fp)
 2040250:	00000506 	br	2040268 <netconn_alloc+0x158>
      LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
      goto free_and_return;
  }

  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
    goto free_and_return;
 2040254:	0001883a 	nop
  conn->linger = -1;
#endif /* LWIP_SO_LINGER */
  conn->flags = init_flags;
  return conn;
free_and_return:
  memp_free(MEMP_NETCONN, conn);
 2040258:	e17ffd17 	ldw	r5,-12(fp)
 204025c:	01000204 	movi	r4,8
 2040260:	201b9640 	call	201b964 <memp_free>
  return NULL;
 2040264:	0005883a 	mov	r2,zero
}
 2040268:	e037883a 	mov	sp,fp
 204026c:	dfc00117 	ldw	ra,4(sp)
 2040270:	df000017 	ldw	fp,0(sp)
 2040274:	dec00204 	addi	sp,sp,8
 2040278:	f800283a 	ret

0204027c <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
 204027c:	defffd04 	addi	sp,sp,-12
 2040280:	dfc00215 	stw	ra,8(sp)
 2040284:	df000115 	stw	fp,4(sp)
 2040288:	df000104 	addi	fp,sp,4
 204028c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
              !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */

#if !LWIP_NETCONN_SEM_PER_THREAD
  sys_sem_free(&conn->op_completed);
 2040290:	e0bfff17 	ldw	r2,-4(fp)
 2040294:	10800404 	addi	r2,r2,16
 2040298:	1009883a 	mov	r4,r2
 204029c:	20151040 	call	2015104 <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
 20402a0:	e0bfff17 	ldw	r2,-4(fp)
 20402a4:	10000415 	stw	zero,16(r2)
#endif

  memp_free(MEMP_NETCONN, conn);
 20402a8:	e17fff17 	ldw	r5,-4(fp)
 20402ac:	01000204 	movi	r4,8
 20402b0:	201b9640 	call	201b964 <memp_free>
}
 20402b4:	0001883a 	nop
 20402b8:	e037883a 	mov	sp,fp
 20402bc:	dfc00117 	ldw	ra,4(sp)
 20402c0:	df000017 	ldw	fp,0(sp)
 20402c4:	dec00204 	addi	sp,sp,8
 20402c8:	f800283a 	ret

020402cc <netconn_drain>:
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
 20402cc:	defffa04 	addi	sp,sp,-24
 20402d0:	dfc00515 	stw	ra,20(sp)
 20402d4:	df000415 	stw	fp,16(sp)
 20402d8:	df000404 	addi	fp,sp,16
 20402dc:	e13fff15 	stw	r4,-4(fp)
#if LWIP_NETCONN_FULLDUPLEX
  LWIP_ASSERT("netconn marked closed", conn->flags & NETCONN_FLAG_MBOXINVALID);
#endif /* LWIP_NETCONN_FULLDUPLEX */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
 20402e0:	e0bfff17 	ldw	r2,-4(fp)
 20402e4:	10800504 	addi	r2,r2,20
 20402e8:	10002426 	beq	r2,zero,204037c <netconn_drain+0xb0>
 20402ec:	e0bfff17 	ldw	r2,-4(fp)
 20402f0:	10800517 	ldw	r2,20(r2)
 20402f4:	10002126 	beq	r2,zero,204037c <netconn_drain+0xb0>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 20402f8:	00001206 	br	2040344 <netconn_drain+0x78>
#if LWIP_NETCONN_FULLDUPLEX
      if (!lwip_netconn_is_deallocated_msg(mem))
#endif /* LWIP_NETCONN_FULLDUPLEX */
      {
#if LWIP_TCP
        if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) {
 20402fc:	e0bfff17 	ldw	r2,-4(fp)
 2040300:	10800017 	ldw	r2,0(r2)
 2040304:	10803c0c 	andi	r2,r2,240
 2040308:	10800418 	cmpnei	r2,r2,16
 204030c:	10000a1e 	bne	r2,zero,2040338 <netconn_drain+0x6c>
          err_t err;
          if (!lwip_netconn_is_err_msg(mem, &err)) {
 2040310:	e0bffd17 	ldw	r2,-12(fp)
 2040314:	e0fffe04 	addi	r3,fp,-8
 2040318:	180b883a 	mov	r5,r3
 204031c:	1009883a 	mov	r4,r2
 2040320:	203f3b40 	call	203f3b4 <lwip_netconn_is_err_msg>
 2040324:	1000071e 	bne	r2,zero,2040344 <netconn_drain+0x78>
            pbuf_free((struct pbuf *)mem);
 2040328:	e0bffd17 	ldw	r2,-12(fp)
 204032c:	1009883a 	mov	r4,r2
 2040330:	201d2f40 	call	201d2f4 <pbuf_free>
 2040334:	00000306 	br	2040344 <netconn_drain+0x78>
          }
        } else
#endif /* LWIP_TCP */
        {
          netbuf_delete((struct netbuf *)mem);
 2040338:	e0bffd17 	ldw	r2,-12(fp)
 204033c:	1009883a 	mov	r4,r2
 2040340:	2041f400 	call	2041f40 <netbuf_delete>
  LWIP_ASSERT("netconn marked closed", conn->flags & NETCONN_FLAG_MBOXINVALID);
#endif /* LWIP_NETCONN_FULLDUPLEX */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 2040344:	e0bfff17 	ldw	r2,-4(fp)
 2040348:	10800504 	addi	r2,r2,20
 204034c:	e0fffd04 	addi	r3,fp,-12
 2040350:	180b883a 	mov	r5,r3
 2040354:	1009883a 	mov	r4,r2
 2040358:	20154540 	call	2015454 <sys_arch_mbox_tryfetch>
 204035c:	10bfffd8 	cmpnei	r2,r2,-1
 2040360:	103fe61e 	bne	r2,zero,20402fc <__alt_mem_mem_0+0xfd0202fc>
        {
          netbuf_delete((struct netbuf *)mem);
        }
      }
    }
    sys_mbox_free(&conn->recvmbox);
 2040364:	e0bfff17 	ldw	r2,-4(fp)
 2040368:	10800504 	addi	r2,r2,20
 204036c:	1009883a 	mov	r4,r2
 2040370:	20154c80 	call	20154c8 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
 2040374:	e0bfff17 	ldw	r2,-4(fp)
 2040378:	10000515 	stw	zero,20(r2)
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
 204037c:	e0bfff17 	ldw	r2,-4(fp)
 2040380:	10800604 	addi	r2,r2,24
 2040384:	10002726 	beq	r2,zero,2040424 <netconn_drain+0x158>
 2040388:	e0bfff17 	ldw	r2,-4(fp)
 204038c:	10800617 	ldw	r2,24(r2)
 2040390:	10002426 	beq	r2,zero,2040424 <netconn_drain+0x158>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 2040394:	00001506 	br	20403ec <netconn_drain+0x120>
#if LWIP_NETCONN_FULLDUPLEX
      if (!lwip_netconn_is_deallocated_msg(mem))
#endif /* LWIP_NETCONN_FULLDUPLEX */
      {
        err_t err;
        if (!lwip_netconn_is_err_msg(mem, &err)) {
 2040398:	e0bffd17 	ldw	r2,-12(fp)
 204039c:	e0fffe44 	addi	r3,fp,-7
 20403a0:	180b883a 	mov	r5,r3
 20403a4:	1009883a 	mov	r4,r2
 20403a8:	203f3b40 	call	203f3b4 <lwip_netconn_is_err_msg>
 20403ac:	10000f1e 	bne	r2,zero,20403ec <netconn_drain+0x120>
          struct netconn *newconn = (struct netconn *)mem;
 20403b0:	e0bffd17 	ldw	r2,-12(fp)
 20403b4:	e0bffc15 	stw	r2,-16(fp)
          /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
          /* pcb might be set to NULL already by err_tcp() */
          /* drain recvmbox */
          netconn_drain(newconn);
 20403b8:	e13ffc17 	ldw	r4,-16(fp)
 20403bc:	20402cc0 	call	20402cc <netconn_drain>
          if (newconn->pcb.tcp != NULL) {
 20403c0:	e0bffc17 	ldw	r2,-16(fp)
 20403c4:	10800217 	ldw	r2,8(r2)
 20403c8:	10000626 	beq	r2,zero,20403e4 <netconn_drain+0x118>
            tcp_abort(newconn->pcb.tcp);
 20403cc:	e0bffc17 	ldw	r2,-16(fp)
 20403d0:	10800217 	ldw	r2,8(r2)
 20403d4:	1009883a 	mov	r4,r2
 20403d8:	201f70c0 	call	201f70c <tcp_abort>
            newconn->pcb.tcp = NULL;
 20403dc:	e0bffc17 	ldw	r2,-16(fp)
 20403e0:	10000215 	stw	zero,8(r2)
          }
          netconn_free(newconn);
 20403e4:	e13ffc17 	ldw	r4,-16(fp)
 20403e8:	204027c0 	call	204027c <netconn_free>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 20403ec:	e0bfff17 	ldw	r2,-4(fp)
 20403f0:	10800604 	addi	r2,r2,24
 20403f4:	e0fffd04 	addi	r3,fp,-12
 20403f8:	180b883a 	mov	r5,r3
 20403fc:	1009883a 	mov	r4,r2
 2040400:	20154540 	call	2015454 <sys_arch_mbox_tryfetch>
 2040404:	10bfffd8 	cmpnei	r2,r2,-1
 2040408:	103fe31e 	bne	r2,zero,2040398 <__alt_mem_mem_0+0xfd020398>
          }
          netconn_free(newconn);
        }
      }
    }
    sys_mbox_free(&conn->acceptmbox);
 204040c:	e0bfff17 	ldw	r2,-4(fp)
 2040410:	10800604 	addi	r2,r2,24
 2040414:	1009883a 	mov	r4,r2
 2040418:	20154c80 	call	20154c8 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
 204041c:	e0bfff17 	ldw	r2,-4(fp)
 2040420:	10000615 	stw	zero,24(r2)
  }
#endif /* LWIP_TCP */
}
 2040424:	0001883a 	nop
 2040428:	e037883a 	mov	sp,fp
 204042c:	dfc00117 	ldw	ra,4(sp)
 2040430:	df000017 	ldw	fp,0(sp)
 2040434:	dec00204 	addi	sp,sp,8
 2040438:	f800283a 	ret

0204043c <lwip_netconn_do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static err_t
lwip_netconn_do_close_internal(struct netconn *conn  WRITE_DELAYED_PARAM)
{
 204043c:	defff904 	addi	sp,sp,-28
 2040440:	dfc00615 	stw	ra,24(sp)
 2040444:	df000515 	stw	fp,20(sp)
 2040448:	df000504 	addi	fp,sp,20
 204044c:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  u8_t shut, shut_rx, shut_tx, shut_close;
  u8_t close_finished = 0;
 2040450:	e03ffb85 	stb	zero,-18(fp)
  LWIP_ASSERT("this is for tcp netconns only", (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  tpcb = conn->pcb.tcp;
 2040454:	e0bfff17 	ldw	r2,-4(fp)
 2040458:	10800217 	ldw	r2,8(r2)
 204045c:	e0bffc15 	stw	r2,-16(fp)
  shut = conn->current_msg->msg.sd.shut;
 2040460:	e0bfff17 	ldw	r2,-4(fp)
 2040464:	10800a17 	ldw	r2,40(r2)
 2040468:	10800203 	ldbu	r2,8(r2)
 204046c:	e0bffd05 	stb	r2,-12(fp)
  shut_rx = shut & NETCONN_SHUT_RD;
 2040470:	e0bffd03 	ldbu	r2,-12(fp)
 2040474:	1080004c 	andi	r2,r2,1
 2040478:	e0bffd45 	stb	r2,-11(fp)
  shut_tx = shut & NETCONN_SHUT_WR;
 204047c:	e0bffd03 	ldbu	r2,-12(fp)
 2040480:	1080008c 	andi	r2,r2,2
 2040484:	e0bffd85 	stb	r2,-10(fp)
  /* shutting down both ends is the same as closing
     (also if RD or WR side was shut down before already) */
  if (shut == NETCONN_SHUT_RDWR) {
 2040488:	e0bffd03 	ldbu	r2,-12(fp)
 204048c:	108000d8 	cmpnei	r2,r2,3
 2040490:	1000031e 	bne	r2,zero,20404a0 <lwip_netconn_do_close_internal+0x64>
    shut_close = 1;
 2040494:	00800044 	movi	r2,1
 2040498:	e0bffb45 	stb	r2,-19(fp)
 204049c:	00001c06 	br	2040510 <lwip_netconn_do_close_internal+0xd4>
  } else if (shut_rx &&
 20404a0:	e0bffd43 	ldbu	r2,-11(fp)
 20404a4:	10000f26 	beq	r2,zero,20404e4 <lwip_netconn_do_close_internal+0xa8>
             ((tpcb->state == FIN_WAIT_1) ||
 20404a8:	e0bffc17 	ldw	r2,-16(fp)
 20404ac:	10800617 	ldw	r2,24(r2)
  shut_tx = shut & NETCONN_SHUT_WR;
  /* shutting down both ends is the same as closing
     (also if RD or WR side was shut down before already) */
  if (shut == NETCONN_SHUT_RDWR) {
    shut_close = 1;
  } else if (shut_rx &&
 20404b0:	10800160 	cmpeqi	r2,r2,5
 20404b4:	1000081e 	bne	r2,zero,20404d8 <lwip_netconn_do_close_internal+0x9c>
             ((tpcb->state == FIN_WAIT_1) ||
              (tpcb->state == FIN_WAIT_2) ||
 20404b8:	e0bffc17 	ldw	r2,-16(fp)
 20404bc:	10800617 	ldw	r2,24(r2)
  /* shutting down both ends is the same as closing
     (also if RD or WR side was shut down before already) */
  if (shut == NETCONN_SHUT_RDWR) {
    shut_close = 1;
  } else if (shut_rx &&
             ((tpcb->state == FIN_WAIT_1) ||
 20404c0:	108001a0 	cmpeqi	r2,r2,6
 20404c4:	1000041e 	bne	r2,zero,20404d8 <lwip_netconn_do_close_internal+0x9c>
              (tpcb->state == FIN_WAIT_2) ||
              (tpcb->state == CLOSING))) {
 20404c8:	e0bffc17 	ldw	r2,-16(fp)
 20404cc:	10800617 	ldw	r2,24(r2)
     (also if RD or WR side was shut down before already) */
  if (shut == NETCONN_SHUT_RDWR) {
    shut_close = 1;
  } else if (shut_rx &&
             ((tpcb->state == FIN_WAIT_1) ||
              (tpcb->state == FIN_WAIT_2) ||
 20404d0:	10800218 	cmpnei	r2,r2,8
 20404d4:	1000031e 	bne	r2,zero,20404e4 <lwip_netconn_do_close_internal+0xa8>
              (tpcb->state == CLOSING))) {
    shut_close = 1;
 20404d8:	00800044 	movi	r2,1
 20404dc:	e0bffb45 	stb	r2,-19(fp)
 20404e0:	00000b06 	br	2040510 <lwip_netconn_do_close_internal+0xd4>
  } else if (shut_tx && ((tpcb->flags & TF_RXCLOSED) != 0)) {
 20404e4:	e0bffd83 	ldbu	r2,-10(fp)
 20404e8:	10000826 	beq	r2,zero,204050c <lwip_netconn_do_close_internal+0xd0>
 20404ec:	e0bffc17 	ldw	r2,-16(fp)
 20404f0:	1080088b 	ldhu	r2,34(r2)
 20404f4:	10bfffcc 	andi	r2,r2,65535
 20404f8:	1080040c 	andi	r2,r2,16
 20404fc:	10000326 	beq	r2,zero,204050c <lwip_netconn_do_close_internal+0xd0>
    shut_close = 1;
 2040500:	00800044 	movi	r2,1
 2040504:	e0bffb45 	stb	r2,-19(fp)
 2040508:	00000106 	br	2040510 <lwip_netconn_do_close_internal+0xd4>
  } else {
    shut_close = 0;
 204050c:	e03ffb45 	stb	zero,-19(fp)
  }

  /* Set back some callback pointers */
  if (shut_close) {
 2040510:	e0bffb43 	ldbu	r2,-19(fp)
 2040514:	10000326 	beq	r2,zero,2040524 <lwip_netconn_do_close_internal+0xe8>
    tcp_arg(tpcb, NULL);
 2040518:	000b883a 	mov	r5,zero
 204051c:	e13ffc17 	ldw	r4,-16(fp)
 2040520:	20215d40 	call	20215d4 <tcp_arg>
  }
  if (tpcb->state == LISTEN) {
 2040524:	e0bffc17 	ldw	r2,-16(fp)
 2040528:	10800617 	ldw	r2,24(r2)
 204052c:	10800058 	cmpnei	r2,r2,1
 2040530:	1000041e 	bne	r2,zero,2040544 <lwip_netconn_do_close_internal+0x108>
    tcp_accept(tpcb, NULL);
 2040534:	000b883a 	mov	r5,zero
 2040538:	e13ffc17 	ldw	r4,-16(fp)
 204053c:	20216c40 	call	20216c4 <tcp_accept>
 2040540:	00001606 	br	204059c <lwip_netconn_do_close_internal+0x160>
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
 2040544:	e0bffd43 	ldbu	r2,-11(fp)
 2040548:	10000626 	beq	r2,zero,2040564 <lwip_netconn_do_close_internal+0x128>
      tcp_recv(tpcb, NULL);
 204054c:	000b883a 	mov	r5,zero
 2040550:	e13ffc17 	ldw	r4,-16(fp)
 2040554:	20216100 	call	2021610 <tcp_recv>
      tcp_accept(tpcb, NULL);
 2040558:	000b883a 	mov	r5,zero
 204055c:	e13ffc17 	ldw	r4,-16(fp)
 2040560:	20216c40 	call	20216c4 <tcp_accept>
    }
    if (shut_tx) {
 2040564:	e0bffd83 	ldbu	r2,-10(fp)
 2040568:	10000326 	beq	r2,zero,2040578 <lwip_netconn_do_close_internal+0x13c>
      tcp_sent(tpcb, NULL);
 204056c:	000b883a 	mov	r5,zero
 2040570:	e13ffc17 	ldw	r4,-16(fp)
 2040574:	202164c0 	call	202164c <tcp_sent>
    }
    if (shut_close) {
 2040578:	e0bffb43 	ldbu	r2,-19(fp)
 204057c:	10000726 	beq	r2,zero,204059c <lwip_netconn_do_close_internal+0x160>
      tcp_poll(tpcb, NULL, 0);
 2040580:	000d883a 	mov	r6,zero
 2040584:	000b883a 	mov	r5,zero
 2040588:	e13ffc17 	ldw	r4,-16(fp)
 204058c:	20217180 	call	2021718 <tcp_poll>
      tcp_err(tpcb, NULL);
 2040590:	000b883a 	mov	r5,zero
 2040594:	e13ffc17 	ldw	r4,-16(fp)
 2040598:	20216880 	call	2021688 <tcp_err>
    }
  }
  /* Try to close the connection */
  if (shut_close) {
 204059c:	e0bffb43 	ldbu	r2,-19(fp)
 20405a0:	10000426 	beq	r2,zero,20405b4 <lwip_netconn_do_close_internal+0x178>
      }
    }
    if ((err == ERR_OK) && (tpcb != NULL))
#endif /* LWIP_SO_LINGER */
    {
      err = tcp_close(tpcb);
 20405a4:	e13ffc17 	ldw	r4,-16(fp)
 20405a8:	201f3880 	call	201f388 <tcp_close>
 20405ac:	e0bffb05 	stb	r2,-20(fp)
 20405b0:	00000706 	br	20405d0 <lwip_netconn_do_close_internal+0x194>
    }
  } else {
    err = tcp_shutdown(tpcb, shut_rx, shut_tx);
 20405b4:	e0bffd43 	ldbu	r2,-11(fp)
 20405b8:	e0fffd83 	ldbu	r3,-10(fp)
 20405bc:	180d883a 	mov	r6,r3
 20405c0:	100b883a 	mov	r5,r2
 20405c4:	e13ffc17 	ldw	r4,-16(fp)
 20405c8:	201f3f40 	call	201f3f4 <tcp_shutdown>
 20405cc:	e0bffb05 	stb	r2,-20(fp)
  }
  if (err == ERR_OK) {
 20405d0:	e0bffb07 	ldb	r2,-20(fp)
 20405d4:	1000031e 	bne	r2,zero,20405e4 <lwip_netconn_do_close_internal+0x1a8>
    close_finished = 1;
 20405d8:	00800044 	movi	r2,1
 20405dc:	e0bffb85 	stb	r2,-18(fp)
 20405e0:	00001206 	br	204062c <lwip_netconn_do_close_internal+0x1f0>
      close_finished = 0;
      err = ERR_INPROGRESS;
    }
#endif /* LWIP_SO_LINGER */
  } else {
    if (err == ERR_MEM) {
 20405e4:	e0bffb07 	ldb	r2,-20(fp)
 20405e8:	10bfffd8 	cmpnei	r2,r2,-1
 20405ec:	10000d1e 	bne	r2,zero,2040624 <lwip_netconn_do_close_internal+0x1e8>
        close_timeout = conn->linger * 1000U;
      }
#endif
      if ((s32_t)(sys_now() - conn->current_msg->msg.sd.time_started) >= close_timeout) {
#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
      if (conn->current_msg->msg.sd.polls_left == 0) {
 20405f0:	e0bfff17 	ldw	r2,-4(fp)
 20405f4:	10800a17 	ldw	r2,40(r2)
 20405f8:	10800243 	ldbu	r2,9(r2)
 20405fc:	10803fcc 	andi	r2,r2,255
 2040600:	10000a1e 	bne	r2,zero,204062c <lwip_netconn_do_close_internal+0x1f0>
#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
        close_finished = 1;
 2040604:	00800044 	movi	r2,1
 2040608:	e0bffb85 	stb	r2,-18(fp)
        if (shut_close) {
 204060c:	e0bffb43 	ldbu	r2,-19(fp)
 2040610:	10000626 	beq	r2,zero,204062c <lwip_netconn_do_close_internal+0x1f0>
          /* in this case, we want to RST the connection */
          tcp_abort(tpcb);
 2040614:	e13ffc17 	ldw	r4,-16(fp)
 2040618:	201f70c0 	call	201f70c <tcp_abort>
          err = ERR_OK;
 204061c:	e03ffb05 	stb	zero,-20(fp)
 2040620:	00000206 	br	204062c <lwip_netconn_do_close_internal+0x1f0>
        }
      }
    } else {
      /* Closing failed for a non-memory error: give up */
      close_finished = 1;
 2040624:	00800044 	movi	r2,1
 2040628:	e0bffb85 	stb	r2,-18(fp)
    }
  }
  if (close_finished) {
 204062c:	e0bffb83 	ldbu	r2,-18(fp)
 2040630:	10003626 	beq	r2,zero,204070c <lwip_netconn_do_close_internal+0x2d0>
    /* Closing done (succeeded, non-memory error, nonblocking error or timeout) */
    sys_sem_t *op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 2040634:	e0bfff17 	ldw	r2,-4(fp)
 2040638:	10800a17 	ldw	r2,40(r2)
 204063c:	10800017 	ldw	r2,0(r2)
 2040640:	10800404 	addi	r2,r2,16
 2040644:	e0bffe15 	stw	r2,-8(fp)
    conn->current_msg->err = err;
 2040648:	e0bfff17 	ldw	r2,-4(fp)
 204064c:	10800a17 	ldw	r2,40(r2)
 2040650:	e0fffb03 	ldbu	r3,-20(fp)
 2040654:	10c00105 	stb	r3,4(r2)
    conn->current_msg = NULL;
 2040658:	e0bfff17 	ldw	r2,-4(fp)
 204065c:	10000a15 	stw	zero,40(r2)
    conn->state = NETCONN_NONE;
 2040660:	e0bfff17 	ldw	r2,-4(fp)
 2040664:	10000115 	stw	zero,4(r2)
    if (err == ERR_OK) {
 2040668:	e0bffb07 	ldb	r2,-20(fp)
 204066c:	1000231e 	bne	r2,zero,20406fc <lwip_netconn_do_close_internal+0x2c0>
      if (shut_close) {
 2040670:	e0bffb43 	ldbu	r2,-19(fp)
 2040674:	10000b26 	beq	r2,zero,20406a4 <lwip_netconn_do_close_internal+0x268>
        /* Set back some callback pointers as conn is going away */
        conn->pcb.tcp = NULL;
 2040678:	e0bfff17 	ldw	r2,-4(fp)
 204067c:	10000215 	stw	zero,8(r2)
        /* Trigger select() in socket layer. Make sure everybody notices activity
         on the connection, error first! */
        API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 2040680:	e0bfff17 	ldw	r2,-4(fp)
 2040684:	10800b17 	ldw	r2,44(r2)
 2040688:	10000626 	beq	r2,zero,20406a4 <lwip_netconn_do_close_internal+0x268>
 204068c:	e0bfff17 	ldw	r2,-4(fp)
 2040690:	10800b17 	ldw	r2,44(r2)
 2040694:	000d883a 	mov	r6,zero
 2040698:	01400104 	movi	r5,4
 204069c:	e13fff17 	ldw	r4,-4(fp)
 20406a0:	103ee83a 	callr	r2
      }
      if (shut_rx) {
 20406a4:	e0bffd43 	ldbu	r2,-11(fp)
 20406a8:	10000926 	beq	r2,zero,20406d0 <lwip_netconn_do_close_internal+0x294>
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 20406ac:	e0bfff17 	ldw	r2,-4(fp)
 20406b0:	10800b17 	ldw	r2,44(r2)
 20406b4:	10000626 	beq	r2,zero,20406d0 <lwip_netconn_do_close_internal+0x294>
 20406b8:	e0bfff17 	ldw	r2,-4(fp)
 20406bc:	10800b17 	ldw	r2,44(r2)
 20406c0:	000d883a 	mov	r6,zero
 20406c4:	000b883a 	mov	r5,zero
 20406c8:	e13fff17 	ldw	r4,-4(fp)
 20406cc:	103ee83a 	callr	r2
      }
      if (shut_tx) {
 20406d0:	e0bffd83 	ldbu	r2,-10(fp)
 20406d4:	10000926 	beq	r2,zero,20406fc <lwip_netconn_do_close_internal+0x2c0>
        API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 20406d8:	e0bfff17 	ldw	r2,-4(fp)
 20406dc:	10800b17 	ldw	r2,44(r2)
 20406e0:	10000626 	beq	r2,zero,20406fc <lwip_netconn_do_close_internal+0x2c0>
 20406e4:	e0bfff17 	ldw	r2,-4(fp)
 20406e8:	10800b17 	ldw	r2,44(r2)
 20406ec:	000d883a 	mov	r6,zero
 20406f0:	01400084 	movi	r5,2
 20406f4:	e13fff17 	ldw	r4,-4(fp)
 20406f8:	103ee83a 	callr	r2
#if LWIP_TCPIP_CORE_LOCKING
    if (delayed)
#endif
    {
      /* wake up the application task */
      sys_sem_signal(op_completed_sem);
 20406fc:	e13ffe17 	ldw	r4,-8(fp)
 2040700:	20150340 	call	2015034 <sys_sem_signal>
    }
    return ERR_OK;
 2040704:	0005883a 	mov	r2,zero
 2040708:	00001506 	br	2040760 <lwip_netconn_do_close_internal+0x324>
  }
  if (!close_finished) {
 204070c:	e0bffb83 	ldbu	r2,-18(fp)
 2040710:	1000121e 	bne	r2,zero,204075c <lwip_netconn_do_close_internal+0x320>
    /* Closing failed and we want to wait: restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (tpcb->state != LISTEN));
    if (shut_tx) {
 2040714:	e0bffd83 	ldbu	r2,-10(fp)
 2040718:	10000426 	beq	r2,zero,204072c <lwip_netconn_do_close_internal+0x2f0>
      tcp_sent(tpcb, sent_tcp);
 204071c:	01408134 	movhi	r5,516
 2040720:	297e4404 	addi	r5,r5,-1776
 2040724:	e13ffc17 	ldw	r4,-16(fp)
 2040728:	202164c0 	call	202164c <tcp_sent>
    }
    /* when waiting for close, set up poll interval to 500ms */
    tcp_poll(tpcb, poll_tcp, 1);
 204072c:	01800044 	movi	r6,1
 2040730:	01408134 	movhi	r5,516
 2040734:	297df804 	addi	r5,r5,-2080
 2040738:	e13ffc17 	ldw	r4,-16(fp)
 204073c:	20217180 	call	2021718 <tcp_poll>
    tcp_err(tpcb, err_tcp);
 2040740:	01408134 	movhi	r5,516
 2040744:	297e8304 	addi	r5,r5,-1524
 2040748:	e13ffc17 	ldw	r4,-16(fp)
 204074c:	20216880 	call	2021688 <tcp_err>
    tcp_arg(tpcb, conn);
 2040750:	e17fff17 	ldw	r5,-4(fp)
 2040754:	e13ffc17 	ldw	r4,-16(fp)
 2040758:	20215d40 	call	20215d4 <tcp_arg>
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
  LWIP_ASSERT("err != ERR_OK", err != ERR_OK);
  return err;
 204075c:	e0bffb03 	ldbu	r2,-20(fp)
}
 2040760:	e037883a 	mov	sp,fp
 2040764:	dfc00117 	ldw	ra,4(sp)
 2040768:	df000017 	ldw	fp,0(sp)
 204076c:	dec00204 	addi	sp,sp,8
 2040770:	f800283a 	ret

02040774 <lwip_netconn_do_delconn>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_delconn(void *m)
{
 2040774:	defffb04 	addi	sp,sp,-20
 2040778:	dfc00415 	stw	ra,16(sp)
 204077c:	df000315 	stw	fp,12(sp)
 2040780:	df000304 	addi	fp,sp,12
 2040784:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2040788:	e0bfff17 	ldw	r2,-4(fp)
 204078c:	e0bffd15 	stw	r2,-12(fp)

  enum netconn_state state = msg->conn->state;
 2040790:	e0bffd17 	ldw	r2,-12(fp)
 2040794:	10800017 	ldw	r2,0(r2)
 2040798:	10800117 	ldw	r2,4(r2)
 204079c:	e0bffe15 	stw	r2,-8(fp)
      msg->conn->state = NETCONN_NONE;
      sys_sem_signal(op_completed_sem);
    }
  }
#else /* LWIP_NETCONN_FULLDUPLEX */
  if (((state != NETCONN_NONE) &&
 20407a0:	e0bffe17 	ldw	r2,-8(fp)
 20407a4:	10000626 	beq	r2,zero,20407c0 <lwip_netconn_do_delconn+0x4c>
 20407a8:	e0bffe17 	ldw	r2,-8(fp)
 20407ac:	108000a0 	cmpeqi	r2,r2,2
 20407b0:	1000031e 	bne	r2,zero,20407c0 <lwip_netconn_do_delconn+0x4c>
       (state != NETCONN_LISTEN) &&
 20407b4:	e0bffe17 	ldw	r2,-8(fp)
 20407b8:	108000d8 	cmpnei	r2,r2,3
 20407bc:	1000091e 	bne	r2,zero,20407e4 <lwip_netconn_do_delconn+0x70>
       (state != NETCONN_CONNECT)) ||
 20407c0:	e0bffe17 	ldw	r2,-8(fp)
 20407c4:	108000d8 	cmpnei	r2,r2,3
 20407c8:	10000a1e 	bne	r2,zero,20407f4 <lwip_netconn_do_delconn+0x80>
      ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
 20407cc:	e0bffd17 	ldw	r2,-12(fp)
 20407d0:	10800017 	ldw	r2,0(r2)
 20407d4:	10800903 	ldbu	r2,36(r2)
 20407d8:	10803fcc 	andi	r2,r2,255
 20407dc:	1080010c 	andi	r2,r2,4
 20407e0:	1000041e 	bne	r2,zero,20407f4 <lwip_netconn_do_delconn+0x80>
    /* This means either a blocking write or blocking connect is running
       (nonblocking write returns and sets state to NONE) */
    msg->err = ERR_INPROGRESS;
 20407e4:	e0bffd17 	ldw	r2,-12(fp)
 20407e8:	00fffec4 	movi	r3,-5
 20407ec:	10c00105 	stb	r3,4(r2)
 20407f0:	00005206 	br	204093c <lwip_netconn_do_delconn+0x1c8>
  } else
#endif /* LWIP_NETCONN_FULLDUPLEX */
  {
    LWIP_ASSERT("blocking connect in progress",
                (state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
    msg->err = ERR_OK;
 20407f4:	e0bffd17 	ldw	r2,-12(fp)
 20407f8:	10000105 	stb	zero,4(r2)
#if LWIP_NETCONN_FULLDUPLEX
    /* Mark mboxes invalid */
    netconn_mark_mbox_invalid(msg->conn);
#else /* LWIP_NETCONN_FULLDUPLEX */
    netconn_drain(msg->conn);
 20407fc:	e0bffd17 	ldw	r2,-12(fp)
 2040800:	10800017 	ldw	r2,0(r2)
 2040804:	1009883a 	mov	r4,r2
 2040808:	20402cc0 	call	20402cc <netconn_drain>
#endif /* LWIP_NETCONN_FULLDUPLEX */

    if (msg->conn->pcb.tcp != NULL) {
 204080c:	e0bffd17 	ldw	r2,-12(fp)
 2040810:	10800017 	ldw	r2,0(r2)
 2040814:	10800217 	ldw	r2,8(r2)
 2040818:	10002e26 	beq	r2,zero,20408d4 <lwip_netconn_do_delconn+0x160>

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 204081c:	e0bffd17 	ldw	r2,-12(fp)
 2040820:	10800017 	ldw	r2,0(r2)
 2040824:	10800017 	ldw	r2,0(r2)
 2040828:	10803c0c 	andi	r2,r2,240
 204082c:	10c00820 	cmpeqi	r3,r2,32
 2040830:	18000b1e 	bne	r3,zero,2040860 <lwip_netconn_do_delconn+0xec>
 2040834:	10c01020 	cmpeqi	r3,r2,64
 2040838:	1800031e 	bne	r3,zero,2040848 <lwip_netconn_do_delconn+0xd4>
 204083c:	10800420 	cmpeqi	r2,r2,16
 2040840:	1000111e 	bne	r2,zero,2040888 <lwip_netconn_do_delconn+0x114>
          /* API_EVENT is called inside lwip_netconn_do_close_internal, before releasing
             the application thread, so we can return at this point! */
          return;
#endif /* LWIP_TCP */
        default:
          break;
 2040844:	00002006 	br	20408c8 <lwip_netconn_do_delconn+0x154>
    if (msg->conn->pcb.tcp != NULL) {

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
        case NETCONN_RAW:
          raw_remove(msg->conn->pcb.raw);
 2040848:	e0bffd17 	ldw	r2,-12(fp)
 204084c:	10800017 	ldw	r2,0(r2)
 2040850:	10800217 	ldw	r2,8(r2)
 2040854:	1009883a 	mov	r4,r2
 2040858:	201eb600 	call	201eb60 <raw_remove>
          break;
 204085c:	00001a06 	br	20408c8 <lwip_netconn_do_delconn+0x154>
#endif /* LWIP_RAW */
#if LWIP_UDP
        case NETCONN_UDP:
          msg->conn->pcb.udp->recv_arg = NULL;
 2040860:	e0bffd17 	ldw	r2,-12(fp)
 2040864:	10800017 	ldw	r2,0(r2)
 2040868:	10800217 	ldw	r2,8(r2)
 204086c:	10000815 	stw	zero,32(r2)
          udp_remove(msg->conn->pcb.udp);
 2040870:	e0bffd17 	ldw	r2,-12(fp)
 2040874:	10800017 	ldw	r2,0(r2)
 2040878:	10800217 	ldw	r2,8(r2)
 204087c:	1009883a 	mov	r4,r2
 2040880:	202ab340 	call	202ab34 <udp_remove>
          break;
 2040884:	00001006 	br	20408c8 <lwip_netconn_do_delconn+0x154>
#endif /* LWIP_UDP */
#if LWIP_TCP
        case NETCONN_TCP:
          LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
          msg->conn->state = NETCONN_CLOSE;
 2040888:	e0bffd17 	ldw	r2,-12(fp)
 204088c:	10800017 	ldw	r2,0(r2)
 2040890:	00c00104 	movi	r3,4
 2040894:	10c00115 	stw	r3,4(r2)
          msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 2040898:	e0bffd17 	ldw	r2,-12(fp)
 204089c:	00c000c4 	movi	r3,3
 20408a0:	10c00205 	stb	r3,8(r2)
          msg->conn->current_msg = msg;
 20408a4:	e0bffd17 	ldw	r2,-12(fp)
 20408a8:	10800017 	ldw	r2,0(r2)
 20408ac:	e0fffd17 	ldw	r3,-12(fp)
 20408b0:	10c00a15 	stw	r3,40(r2)
            sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
            LOCK_TCPIP_CORE();
            LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
          }
#else /* LWIP_TCPIP_CORE_LOCKING */
          lwip_netconn_do_close_internal(msg->conn);
 20408b4:	e0bffd17 	ldw	r2,-12(fp)
 20408b8:	10800017 	ldw	r2,0(r2)
 20408bc:	1009883a 	mov	r4,r2
 20408c0:	204043c0 	call	204043c <lwip_netconn_do_close_internal>
#endif /* LWIP_TCPIP_CORE_LOCKING */
          /* API_EVENT is called inside lwip_netconn_do_close_internal, before releasing
             the application thread, so we can return at this point! */
          return;
 20408c4:	00002a06 	br	2040970 <lwip_netconn_do_delconn+0x1fc>
#endif /* LWIP_TCP */
        default:
          break;
      }
      msg->conn->pcb.tcp = NULL;
 20408c8:	e0bffd17 	ldw	r2,-12(fp)
 20408cc:	10800017 	ldw	r2,0(r2)
 20408d0:	10000215 	stw	zero,8(r2)
    }
    /* tcp netconns don't come here! */

    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
 20408d4:	e0bffd17 	ldw	r2,-12(fp)
 20408d8:	10800017 	ldw	r2,0(r2)
 20408dc:	10800b17 	ldw	r2,44(r2)
 20408e0:	10000926 	beq	r2,zero,2040908 <lwip_netconn_do_delconn+0x194>
 20408e4:	e0bffd17 	ldw	r2,-12(fp)
 20408e8:	10800017 	ldw	r2,0(r2)
 20408ec:	10800b17 	ldw	r2,44(r2)
 20408f0:	e0fffd17 	ldw	r3,-12(fp)
 20408f4:	18c00017 	ldw	r3,0(r3)
 20408f8:	000d883a 	mov	r6,zero
 20408fc:	000b883a 	mov	r5,zero
 2040900:	1809883a 	mov	r4,r3
 2040904:	103ee83a 	callr	r2
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
 2040908:	e0bffd17 	ldw	r2,-12(fp)
 204090c:	10800017 	ldw	r2,0(r2)
 2040910:	10800b17 	ldw	r2,44(r2)
 2040914:	10000926 	beq	r2,zero,204093c <lwip_netconn_do_delconn+0x1c8>
 2040918:	e0bffd17 	ldw	r2,-12(fp)
 204091c:	10800017 	ldw	r2,0(r2)
 2040920:	10800b17 	ldw	r2,44(r2)
 2040924:	e0fffd17 	ldw	r3,-12(fp)
 2040928:	18c00017 	ldw	r3,0(r3)
 204092c:	000d883a 	mov	r6,zero
 2040930:	01400084 	movi	r5,2
 2040934:	1809883a 	mov	r4,r3
 2040938:	103ee83a 	callr	r2
  }
  if (sys_sem_valid(LWIP_API_MSG_SEM(msg))) {
 204093c:	e0bffd17 	ldw	r2,-12(fp)
 2040940:	10800017 	ldw	r2,0(r2)
 2040944:	10800404 	addi	r2,r2,16
 2040948:	10000926 	beq	r2,zero,2040970 <lwip_netconn_do_delconn+0x1fc>
 204094c:	e0bffd17 	ldw	r2,-12(fp)
 2040950:	10800017 	ldw	r2,0(r2)
 2040954:	10800417 	ldw	r2,16(r2)
 2040958:	10000526 	beq	r2,zero,2040970 <lwip_netconn_do_delconn+0x1fc>
    TCPIP_APIMSG_ACK(msg);
 204095c:	e0bffd17 	ldw	r2,-12(fp)
 2040960:	10800017 	ldw	r2,0(r2)
 2040964:	10800404 	addi	r2,r2,16
 2040968:	1009883a 	mov	r4,r2
 204096c:	20150340 	call	2015034 <sys_sem_signal>
  }
}
 2040970:	e037883a 	mov	sp,fp
 2040974:	dfc00117 	ldw	ra,4(sp)
 2040978:	df000017 	ldw	fp,0(sp)
 204097c:	dec00204 	addi	sp,sp,8
 2040980:	f800283a 	ret

02040984 <lwip_netconn_do_bind>:
 * @param m the api_msg pointing to the connection and containing
 *          the IP address and port to bind to
 */
void
lwip_netconn_do_bind(void *m)
{
 2040984:	defffb04 	addi	sp,sp,-20
 2040988:	dfc00415 	stw	ra,16(sp)
 204098c:	df000315 	stw	fp,12(sp)
 2040990:	df000304 	addi	fp,sp,12
 2040994:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2040998:	e0bfff17 	ldw	r2,-4(fp)
 204099c:	e0bffe15 	stw	r2,-8(fp)
  err_t err;

  if (msg->conn->pcb.tcp != NULL) {
 20409a0:	e0bffe17 	ldw	r2,-8(fp)
 20409a4:	10800017 	ldw	r2,0(r2)
 20409a8:	10800217 	ldw	r2,8(r2)
 20409ac:	10003526 	beq	r2,zero,2040a84 <lwip_netconn_do_bind+0x100>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 20409b0:	e0bffe17 	ldw	r2,-8(fp)
 20409b4:	10800017 	ldw	r2,0(r2)
 20409b8:	10800017 	ldw	r2,0(r2)
 20409bc:	10803c0c 	andi	r2,r2,240
 20409c0:	10c00820 	cmpeqi	r3,r2,32
 20409c4:	18000f1e 	bne	r3,zero,2040a04 <lwip_netconn_do_bind+0x80>
 20409c8:	10c01020 	cmpeqi	r3,r2,64
 20409cc:	1800031e 	bne	r3,zero,20409dc <lwip_netconn_do_bind+0x58>
 20409d0:	10800420 	cmpeqi	r2,r2,16
 20409d4:	1000191e 	bne	r2,zero,2040a3c <lwip_netconn_do_bind+0xb8>
 20409d8:	00002606 	br	2040a74 <lwip_netconn_do_bind+0xf0>
#if LWIP_RAW
      case NETCONN_RAW:
        err = raw_bind(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
 20409dc:	e0bffe17 	ldw	r2,-8(fp)
 20409e0:	10800017 	ldw	r2,0(r2)
 20409e4:	10c00217 	ldw	r3,8(r2)
 20409e8:	e0bffe17 	ldw	r2,-8(fp)
 20409ec:	10800217 	ldw	r2,8(r2)
 20409f0:	100b883a 	mov	r5,r2
 20409f4:	1809883a 	mov	r4,r3
 20409f8:	201e6500 	call	201e650 <raw_bind>
 20409fc:	e0bffd05 	stb	r2,-12(fp)
        break;
 2040a00:	00002206 	br	2040a8c <lwip_netconn_do_bind+0x108>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        err = udp_bind(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 2040a04:	e0bffe17 	ldw	r2,-8(fp)
 2040a08:	10800017 	ldw	r2,0(r2)
 2040a0c:	10c00217 	ldw	r3,8(r2)
 2040a10:	e0bffe17 	ldw	r2,-8(fp)
 2040a14:	11000217 	ldw	r4,8(r2)
 2040a18:	e0bffe17 	ldw	r2,-8(fp)
 2040a1c:	1080030b 	ldhu	r2,12(r2)
 2040a20:	10bfffcc 	andi	r2,r2,65535
 2040a24:	100d883a 	mov	r6,r2
 2040a28:	200b883a 	mov	r5,r4
 2040a2c:	1809883a 	mov	r4,r3
 2040a30:	202a75c0 	call	202a75c <udp_bind>
 2040a34:	e0bffd05 	stb	r2,-12(fp)
        break;
 2040a38:	00001406 	br	2040a8c <lwip_netconn_do_bind+0x108>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 2040a3c:	e0bffe17 	ldw	r2,-8(fp)
 2040a40:	10800017 	ldw	r2,0(r2)
 2040a44:	10c00217 	ldw	r3,8(r2)
 2040a48:	e0bffe17 	ldw	r2,-8(fp)
 2040a4c:	11000217 	ldw	r4,8(r2)
 2040a50:	e0bffe17 	ldw	r2,-8(fp)
 2040a54:	1080030b 	ldhu	r2,12(r2)
 2040a58:	10bfffcc 	andi	r2,r2,65535
 2040a5c:	100d883a 	mov	r6,r2
 2040a60:	200b883a 	mov	r5,r4
 2040a64:	1809883a 	mov	r4,r3
 2040a68:	201f7440 	call	201f744 <tcp_bind>
 2040a6c:	e0bffd05 	stb	r2,-12(fp)
        break;
 2040a70:	00000606 	br	2040a8c <lwip_netconn_do_bind+0x108>
#endif /* LWIP_TCP */
      default:
        err = ERR_VAL;
 2040a74:	00bffe84 	movi	r2,-6
 2040a78:	e0bffd05 	stb	r2,-12(fp)
        break;
 2040a7c:	0001883a 	nop
 2040a80:	00000206 	br	2040a8c <lwip_netconn_do_bind+0x108>
    }
  } else {
    err = ERR_VAL;
 2040a84:	00bffe84 	movi	r2,-6
 2040a88:	e0bffd05 	stb	r2,-12(fp)
  }
  msg->err = err;
 2040a8c:	e0bffe17 	ldw	r2,-8(fp)
 2040a90:	e0fffd03 	ldbu	r3,-12(fp)
 2040a94:	10c00105 	stb	r3,4(r2)
  TCPIP_APIMSG_ACK(msg);
 2040a98:	e0bffe17 	ldw	r2,-8(fp)
 2040a9c:	10800017 	ldw	r2,0(r2)
 2040aa0:	10800404 	addi	r2,r2,16
 2040aa4:	1009883a 	mov	r4,r2
 2040aa8:	20150340 	call	2015034 <sys_sem_signal>
}
 2040aac:	0001883a 	nop
 2040ab0:	e037883a 	mov	sp,fp
 2040ab4:	dfc00117 	ldw	ra,4(sp)
 2040ab8:	df000017 	ldw	fp,0(sp)
 2040abc:	dec00204 	addi	sp,sp,8
 2040ac0:	f800283a 	ret

02040ac4 <lwip_netconn_do_bind_if>:
 * @param m the api_msg pointing to the connection and containing
 *          the IP address and port to bind to
 */
void
lwip_netconn_do_bind_if(void *m)
{
 2040ac4:	defffa04 	addi	sp,sp,-24
 2040ac8:	dfc00515 	stw	ra,20(sp)
 2040acc:	df000415 	stw	fp,16(sp)
 2040ad0:	df000404 	addi	fp,sp,16
 2040ad4:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;
  struct api_msg *msg = (struct api_msg *)m;
 2040ad8:	e0bfff17 	ldw	r2,-4(fp)
 2040adc:	e0bffd15 	stw	r2,-12(fp)
  err_t err;

  netif = netif_get_by_index(msg->msg.bc.if_idx);
 2040ae0:	e0bffd17 	ldw	r2,-12(fp)
 2040ae4:	10800383 	ldbu	r2,14(r2)
 2040ae8:	10803fcc 	andi	r2,r2,255
 2040aec:	1009883a 	mov	r4,r2
 2040af0:	201c62c0 	call	201c62c <netif_get_by_index>
 2040af4:	e0bffe15 	stw	r2,-8(fp)

  if ((netif != NULL) && (msg->conn->pcb.tcp != NULL)) {
 2040af8:	e0bffe17 	ldw	r2,-8(fp)
 2040afc:	10002926 	beq	r2,zero,2040ba4 <lwip_netconn_do_bind_if+0xe0>
 2040b00:	e0bffd17 	ldw	r2,-12(fp)
 2040b04:	10800017 	ldw	r2,0(r2)
 2040b08:	10800217 	ldw	r2,8(r2)
 2040b0c:	10002526 	beq	r2,zero,2040ba4 <lwip_netconn_do_bind_if+0xe0>
    err = ERR_OK;
 2040b10:	e03ffc05 	stb	zero,-16(fp)
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 2040b14:	e0bffd17 	ldw	r2,-12(fp)
 2040b18:	10800017 	ldw	r2,0(r2)
 2040b1c:	10800017 	ldw	r2,0(r2)
 2040b20:	10803c0c 	andi	r2,r2,240
 2040b24:	10c00820 	cmpeqi	r3,r2,32
 2040b28:	18000c1e 	bne	r3,zero,2040b5c <lwip_netconn_do_bind_if+0x98>
 2040b2c:	10c01020 	cmpeqi	r3,r2,64
 2040b30:	1800031e 	bne	r3,zero,2040b40 <lwip_netconn_do_bind_if+0x7c>
 2040b34:	10800420 	cmpeqi	r2,r2,16
 2040b38:	10000f1e 	bne	r2,zero,2040b78 <lwip_netconn_do_bind_if+0xb4>
 2040b3c:	00001506 	br	2040b94 <lwip_netconn_do_bind_if+0xd0>
#if LWIP_RAW
      case NETCONN_RAW:
        raw_bind_netif(msg->conn->pcb.raw, netif);
 2040b40:	e0bffd17 	ldw	r2,-12(fp)
 2040b44:	10800017 	ldw	r2,0(r2)
 2040b48:	10800217 	ldw	r2,8(r2)
 2040b4c:	e17ffe17 	ldw	r5,-8(fp)
 2040b50:	1009883a 	mov	r4,r2
 2040b54:	201e6b00 	call	201e6b0 <raw_bind_netif>
        break;
 2040b58:	00001106 	br	2040ba0 <lwip_netconn_do_bind_if+0xdc>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        udp_bind_netif(msg->conn->pcb.udp, netif);
 2040b5c:	e0bffd17 	ldw	r2,-12(fp)
 2040b60:	10800017 	ldw	r2,0(r2)
 2040b64:	10800217 	ldw	r2,8(r2)
 2040b68:	e17ffe17 	ldw	r5,-8(fp)
 2040b6c:	1009883a 	mov	r4,r2
 2040b70:	202a9040 	call	202a904 <udp_bind_netif>
        break;
 2040b74:	00000a06 	br	2040ba0 <lwip_netconn_do_bind_if+0xdc>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        tcp_bind_netif(msg->conn->pcb.tcp, netif);
 2040b78:	e0bffd17 	ldw	r2,-12(fp)
 2040b7c:	10800017 	ldw	r2,0(r2)
 2040b80:	10800217 	ldw	r2,8(r2)
 2040b84:	e17ffe17 	ldw	r5,-8(fp)
 2040b88:	1009883a 	mov	r4,r2
 2040b8c:	201f9280 	call	201f928 <tcp_bind_netif>
        break;
 2040b90:	00000306 	br	2040ba0 <lwip_netconn_do_bind_if+0xdc>
#endif /* LWIP_TCP */
      default:
        err = ERR_VAL;
 2040b94:	00bffe84 	movi	r2,-6
 2040b98:	e0bffc05 	stb	r2,-16(fp)
        break;
 2040b9c:	0001883a 	nop
    }
  } else {
 2040ba0:	00000206 	br	2040bac <lwip_netconn_do_bind_if+0xe8>
    err = ERR_VAL;
 2040ba4:	00bffe84 	movi	r2,-6
 2040ba8:	e0bffc05 	stb	r2,-16(fp)
  }
  msg->err = err;
 2040bac:	e0bffd17 	ldw	r2,-12(fp)
 2040bb0:	e0fffc03 	ldbu	r3,-16(fp)
 2040bb4:	10c00105 	stb	r3,4(r2)
  TCPIP_APIMSG_ACK(msg);
 2040bb8:	e0bffd17 	ldw	r2,-12(fp)
 2040bbc:	10800017 	ldw	r2,0(r2)
 2040bc0:	10800404 	addi	r2,r2,16
 2040bc4:	1009883a 	mov	r4,r2
 2040bc8:	20150340 	call	2015034 <sys_sem_signal>
}
 2040bcc:	0001883a 	nop
 2040bd0:	e037883a 	mov	sp,fp
 2040bd4:	dfc00117 	ldw	ra,4(sp)
 2040bd8:	df000017 	ldw	fp,0(sp)
 2040bdc:	dec00204 	addi	sp,sp,8
 2040be0:	f800283a 	ret

02040be4 <lwip_netconn_do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
lwip_netconn_do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
 2040be4:	defff804 	addi	sp,sp,-32
 2040be8:	dfc00715 	stw	ra,28(sp)
 2040bec:	df000615 	stw	fp,24(sp)
 2040bf0:	df000604 	addi	fp,sp,24
 2040bf4:	e13ffd15 	stw	r4,-12(fp)
 2040bf8:	e17ffe15 	stw	r5,-8(fp)
 2040bfc:	3005883a 	mov	r2,r6
 2040c00:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *conn;
  int was_blocking;
  sys_sem_t *op_completed_sem = NULL;
 2040c04:	e03ffa15 	stw	zero,-24(fp)

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;
 2040c08:	e0bffd17 	ldw	r2,-12(fp)
 2040c0c:	e0bffb15 	stw	r2,-20(fp)

  if (conn == NULL) {
 2040c10:	e0bffb17 	ldw	r2,-20(fp)
 2040c14:	1000021e 	bne	r2,zero,2040c20 <lwip_netconn_do_connected+0x3c>
    return ERR_VAL;
 2040c18:	00bffe84 	movi	r2,-6
 2040c1c:	00003506 	br	2040cf4 <lwip_netconn_do_connected+0x110>

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
              (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
 2040c20:	e0bffb17 	ldw	r2,-20(fp)
 2040c24:	10800a17 	ldw	r2,40(r2)
 2040c28:	10000926 	beq	r2,zero,2040c50 <lwip_netconn_do_connected+0x6c>
    conn->current_msg->err = err;
 2040c2c:	e0bffb17 	ldw	r2,-20(fp)
 2040c30:	10800a17 	ldw	r2,40(r2)
 2040c34:	e0ffff03 	ldbu	r3,-4(fp)
 2040c38:	10c00105 	stb	r3,4(r2)
    op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 2040c3c:	e0bffb17 	ldw	r2,-20(fp)
 2040c40:	10800a17 	ldw	r2,40(r2)
 2040c44:	10800017 	ldw	r2,0(r2)
 2040c48:	10800404 	addi	r2,r2,16
 2040c4c:	e0bffa15 	stw	r2,-24(fp)
  }
  if ((NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) && (err == ERR_OK)) {
 2040c50:	e0bffb17 	ldw	r2,-20(fp)
 2040c54:	10800017 	ldw	r2,0(r2)
 2040c58:	10803c0c 	andi	r2,r2,240
 2040c5c:	10800418 	cmpnei	r2,r2,16
 2040c60:	1000041e 	bne	r2,zero,2040c74 <lwip_netconn_do_connected+0x90>
 2040c64:	e0bfff07 	ldb	r2,-4(fp)
 2040c68:	1000021e 	bne	r2,zero,2040c74 <lwip_netconn_do_connected+0x90>
    setup_tcp(conn);
 2040c6c:	e13ffb17 	ldw	r4,-20(fp)
 2040c70:	203fc200 	call	203fc20 <setup_tcp>
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
 2040c74:	e0bffb17 	ldw	r2,-20(fp)
 2040c78:	10800903 	ldbu	r2,36(r2)
 2040c7c:	10803fcc 	andi	r2,r2,255
 2040c80:	1080010c 	andi	r2,r2,4
 2040c84:	1005003a 	cmpeq	r2,r2,zero
 2040c88:	10803fcc 	andi	r2,r2,255
 2040c8c:	e0bffc15 	stw	r2,-16(fp)
  SET_NONBLOCKING_CONNECT(conn, 0);
 2040c90:	e0bffb17 	ldw	r2,-20(fp)
 2040c94:	10c00903 	ldbu	r3,36(r2)
 2040c98:	00bffec4 	movi	r2,-5
 2040c9c:	1884703a 	and	r2,r3,r2
 2040ca0:	1007883a 	mov	r3,r2
 2040ca4:	e0bffb17 	ldw	r2,-20(fp)
 2040ca8:	10c00905 	stb	r3,36(r2)
  LWIP_ASSERT("blocking connect state error",
              (was_blocking && op_completed_sem != NULL) ||
              (!was_blocking && op_completed_sem == NULL));
  conn->current_msg = NULL;
 2040cac:	e0bffb17 	ldw	r2,-20(fp)
 2040cb0:	10000a15 	stw	zero,40(r2)
  conn->state = NETCONN_NONE;
 2040cb4:	e0bffb17 	ldw	r2,-20(fp)
 2040cb8:	10000115 	stw	zero,4(r2)
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 2040cbc:	e0bffb17 	ldw	r2,-20(fp)
 2040cc0:	10800b17 	ldw	r2,44(r2)
 2040cc4:	10000626 	beq	r2,zero,2040ce0 <lwip_netconn_do_connected+0xfc>
 2040cc8:	e0bffb17 	ldw	r2,-20(fp)
 2040ccc:	10800b17 	ldw	r2,44(r2)
 2040cd0:	000d883a 	mov	r6,zero
 2040cd4:	01400084 	movi	r5,2
 2040cd8:	e13ffb17 	ldw	r4,-20(fp)
 2040cdc:	103ee83a 	callr	r2

  if (was_blocking) {
 2040ce0:	e0bffc17 	ldw	r2,-16(fp)
 2040ce4:	10000226 	beq	r2,zero,2040cf0 <lwip_netconn_do_connected+0x10c>
    sys_sem_signal(op_completed_sem);
 2040ce8:	e13ffa17 	ldw	r4,-24(fp)
 2040cec:	20150340 	call	2015034 <sys_sem_signal>
  }
  return ERR_OK;
 2040cf0:	0005883a 	mov	r2,zero
}
 2040cf4:	e037883a 	mov	sp,fp
 2040cf8:	dfc00117 	ldw	ra,4(sp)
 2040cfc:	df000017 	ldw	fp,0(sp)
 2040d00:	dec00204 	addi	sp,sp,8
 2040d04:	f800283a 	ret

02040d08 <lwip_netconn_do_connect>:
 * @param m the api_msg pointing to the connection and containing
 *          the IP address and port to connect to
 */
void
lwip_netconn_do_connect(void *m)
{
 2040d08:	defffa04 	addi	sp,sp,-24
 2040d0c:	dfc00515 	stw	ra,20(sp)
 2040d10:	df000415 	stw	fp,16(sp)
 2040d14:	df000404 	addi	fp,sp,16
 2040d18:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2040d1c:	e0bfff17 	ldw	r2,-4(fp)
 2040d20:	e0bffd15 	stw	r2,-12(fp)
  err_t err;

  if (msg->conn->pcb.tcp == NULL) {
 2040d24:	e0bffd17 	ldw	r2,-12(fp)
 2040d28:	10800017 	ldw	r2,0(r2)
 2040d2c:	10800217 	ldw	r2,8(r2)
 2040d30:	1000031e 	bne	r2,zero,2040d40 <lwip_netconn_do_connect+0x38>
    /* This may happen when calling netconn_connect() a second time */
    err = ERR_CLSD;
 2040d34:	00bffc44 	movi	r2,-15
 2040d38:	e0bffc05 	stb	r2,-16(fp)
 2040d3c:	00007206 	br	2040f08 <lwip_netconn_do_connect+0x200>
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 2040d40:	e0bffd17 	ldw	r2,-12(fp)
 2040d44:	10800017 	ldw	r2,0(r2)
 2040d48:	10800017 	ldw	r2,0(r2)
 2040d4c:	10803c0c 	andi	r2,r2,240
 2040d50:	10c00820 	cmpeqi	r3,r2,32
 2040d54:	18000f1e 	bne	r3,zero,2040d94 <lwip_netconn_do_connect+0x8c>
 2040d58:	10c01020 	cmpeqi	r3,r2,64
 2040d5c:	1800031e 	bne	r3,zero,2040d6c <lwip_netconn_do_connect+0x64>
 2040d60:	10800420 	cmpeqi	r2,r2,16
 2040d64:	1000191e 	bne	r2,zero,2040dcc <lwip_netconn_do_connect+0xc4>
 2040d68:	00006306 	br	2040ef8 <lwip_netconn_do_connect+0x1f0>
#if LWIP_RAW
      case NETCONN_RAW:
        err = raw_connect(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
 2040d6c:	e0bffd17 	ldw	r2,-12(fp)
 2040d70:	10800017 	ldw	r2,0(r2)
 2040d74:	10c00217 	ldw	r3,8(r2)
 2040d78:	e0bffd17 	ldw	r2,-12(fp)
 2040d7c:	10800217 	ldw	r2,8(r2)
 2040d80:	100b883a 	mov	r5,r2
 2040d84:	1809883a 	mov	r4,r3
 2040d88:	201e7040 	call	201e704 <raw_connect>
 2040d8c:	e0bffc05 	stb	r2,-16(fp)
        break;
 2040d90:	00005d06 	br	2040f08 <lwip_netconn_do_connect+0x200>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        err = udp_connect(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 2040d94:	e0bffd17 	ldw	r2,-12(fp)
 2040d98:	10800017 	ldw	r2,0(r2)
 2040d9c:	10c00217 	ldw	r3,8(r2)
 2040da0:	e0bffd17 	ldw	r2,-12(fp)
 2040da4:	11000217 	ldw	r4,8(r2)
 2040da8:	e0bffd17 	ldw	r2,-12(fp)
 2040dac:	1080030b 	ldhu	r2,12(r2)
 2040db0:	10bfffcc 	andi	r2,r2,65535
 2040db4:	100d883a 	mov	r6,r2
 2040db8:	200b883a 	mov	r5,r4
 2040dbc:	1809883a 	mov	r4,r3
 2040dc0:	202a9580 	call	202a958 <udp_connect>
 2040dc4:	e0bffc05 	stb	r2,-16(fp)
        break;
 2040dc8:	00004f06 	br	2040f08 <lwip_netconn_do_connect+0x200>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        /* Prevent connect while doing any other action. */
        if (msg->conn->state == NETCONN_CONNECT) {
 2040dcc:	e0bffd17 	ldw	r2,-12(fp)
 2040dd0:	10800017 	ldw	r2,0(r2)
 2040dd4:	10800117 	ldw	r2,4(r2)
 2040dd8:	108000d8 	cmpnei	r2,r2,3
 2040ddc:	1000031e 	bne	r2,zero,2040dec <lwip_netconn_do_connect+0xe4>
          err = ERR_ALREADY;
 2040de0:	00bffdc4 	movi	r2,-9
 2040de4:	e0bffc05 	stb	r2,-16(fp)
#endif /* LWIP_TCPIP_CORE_LOCKING */
              return;
            }
          }
        }
        break;
 2040de8:	00004606 	br	2040f04 <lwip_netconn_do_connect+0x1fc>
#if LWIP_TCP
      case NETCONN_TCP:
        /* Prevent connect while doing any other action. */
        if (msg->conn->state == NETCONN_CONNECT) {
          err = ERR_ALREADY;
        } else if (msg->conn->state != NETCONN_NONE) {
 2040dec:	e0bffd17 	ldw	r2,-12(fp)
 2040df0:	10800017 	ldw	r2,0(r2)
 2040df4:	10800117 	ldw	r2,4(r2)
 2040df8:	10000326 	beq	r2,zero,2040e08 <lwip_netconn_do_connect+0x100>
          err = ERR_ISCONN;
 2040dfc:	00bffd84 	movi	r2,-10
 2040e00:	e0bffc05 	stb	r2,-16(fp)
#endif /* LWIP_TCPIP_CORE_LOCKING */
              return;
            }
          }
        }
        break;
 2040e04:	00003f06 	br	2040f04 <lwip_netconn_do_connect+0x1fc>
        if (msg->conn->state == NETCONN_CONNECT) {
          err = ERR_ALREADY;
        } else if (msg->conn->state != NETCONN_NONE) {
          err = ERR_ISCONN;
        } else {
          setup_tcp(msg->conn);
 2040e08:	e0bffd17 	ldw	r2,-12(fp)
 2040e0c:	10800017 	ldw	r2,0(r2)
 2040e10:	1009883a 	mov	r4,r2
 2040e14:	203fc200 	call	203fc20 <setup_tcp>
          err = tcp_connect(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr),
 2040e18:	e0bffd17 	ldw	r2,-12(fp)
 2040e1c:	10800017 	ldw	r2,0(r2)
 2040e20:	10c00217 	ldw	r3,8(r2)
 2040e24:	e0bffd17 	ldw	r2,-12(fp)
 2040e28:	11000217 	ldw	r4,8(r2)
                            msg->msg.bc.port, lwip_netconn_do_connected);
 2040e2c:	e0bffd17 	ldw	r2,-12(fp)
 2040e30:	1080030b 	ldhu	r2,12(r2)
          err = ERR_ALREADY;
        } else if (msg->conn->state != NETCONN_NONE) {
          err = ERR_ISCONN;
        } else {
          setup_tcp(msg->conn);
          err = tcp_connect(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr),
 2040e34:	10bfffcc 	andi	r2,r2,65535
 2040e38:	01c08134 	movhi	r7,516
 2040e3c:	39c2f904 	addi	r7,r7,3044
 2040e40:	100d883a 	mov	r6,r2
 2040e44:	200b883a 	mov	r5,r4
 2040e48:	1809883a 	mov	r4,r3
 2040e4c:	201ff1c0 	call	201ff1c <tcp_connect>
 2040e50:	e0bffc05 	stb	r2,-16(fp)
                            msg->msg.bc.port, lwip_netconn_do_connected);
          if (err == ERR_OK) {
 2040e54:	e0bffc07 	ldb	r2,-16(fp)
 2040e58:	10002a1e 	bne	r2,zero,2040f04 <lwip_netconn_do_connect+0x1fc>
            u8_t non_blocking = netconn_is_nonblocking(msg->conn);
 2040e5c:	e0bffd17 	ldw	r2,-12(fp)
 2040e60:	10800017 	ldw	r2,0(r2)
 2040e64:	10800903 	ldbu	r2,36(r2)
 2040e68:	10803fcc 	andi	r2,r2,255
 2040e6c:	1080008c 	andi	r2,r2,2
 2040e70:	1004c03a 	cmpne	r2,r2,zero
 2040e74:	e0bffe05 	stb	r2,-8(fp)
            msg->conn->state = NETCONN_CONNECT;
 2040e78:	e0bffd17 	ldw	r2,-12(fp)
 2040e7c:	10800017 	ldw	r2,0(r2)
 2040e80:	00c000c4 	movi	r3,3
 2040e84:	10c00115 	stw	r3,4(r2)
            SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 2040e88:	e0bffe03 	ldbu	r2,-8(fp)
 2040e8c:	10000826 	beq	r2,zero,2040eb0 <lwip_netconn_do_connect+0x1a8>
 2040e90:	e0bffd17 	ldw	r2,-12(fp)
 2040e94:	10800017 	ldw	r2,0(r2)
 2040e98:	e0fffd17 	ldw	r3,-12(fp)
 2040e9c:	18c00017 	ldw	r3,0(r3)
 2040ea0:	18c00903 	ldbu	r3,36(r3)
 2040ea4:	18c00114 	ori	r3,r3,4
 2040ea8:	10c00905 	stb	r3,36(r2)
 2040eac:	00000806 	br	2040ed0 <lwip_netconn_do_connect+0x1c8>
 2040eb0:	e0bffd17 	ldw	r2,-12(fp)
 2040eb4:	10800017 	ldw	r2,0(r2)
 2040eb8:	e0fffd17 	ldw	r3,-12(fp)
 2040ebc:	18c00017 	ldw	r3,0(r3)
 2040ec0:	19000903 	ldbu	r4,36(r3)
 2040ec4:	00fffec4 	movi	r3,-5
 2040ec8:	20c6703a 	and	r3,r4,r3
 2040ecc:	10c00905 	stb	r3,36(r2)
            if (non_blocking) {
 2040ed0:	e0bffe03 	ldbu	r2,-8(fp)
 2040ed4:	10000326 	beq	r2,zero,2040ee4 <lwip_netconn_do_connect+0x1dc>
              err = ERR_INPROGRESS;
 2040ed8:	00bffec4 	movi	r2,-5
 2040edc:	e0bffc05 	stb	r2,-16(fp)
#endif /* LWIP_TCPIP_CORE_LOCKING */
              return;
            }
          }
        }
        break;
 2040ee0:	00000806 	br	2040f04 <lwip_netconn_do_connect+0x1fc>
            msg->conn->state = NETCONN_CONNECT;
            SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
            if (non_blocking) {
              err = ERR_INPROGRESS;
            } else {
              msg->conn->current_msg = msg;
 2040ee4:	e0bffd17 	ldw	r2,-12(fp)
 2040ee8:	10800017 	ldw	r2,0(r2)
 2040eec:	e0fffd17 	ldw	r3,-12(fp)
 2040ef0:	10c00a15 	stw	r3,40(r2)
              UNLOCK_TCPIP_CORE();
              sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
              LOCK_TCPIP_CORE();
              LWIP_ASSERT("state!", msg->conn->state != NETCONN_CONNECT);
#endif /* LWIP_TCPIP_CORE_LOCKING */
              return;
 2040ef4:	00000c06 	br	2040f28 <lwip_netconn_do_connect+0x220>
          }
        }
        break;
#endif /* LWIP_TCP */
      default:
        LWIP_ERROR("Invalid netconn type", 0, do {
 2040ef8:	00bffe84 	movi	r2,-6
 2040efc:	e0bffc05 	stb	r2,-16(fp)
          err = ERR_VAL;
        } while (0));
        break;
 2040f00:	00000106 	br	2040f08 <lwip_netconn_do_connect+0x200>
#endif /* LWIP_TCPIP_CORE_LOCKING */
              return;
            }
          }
        }
        break;
 2040f04:	0001883a 	nop
          err = ERR_VAL;
        } while (0));
        break;
    }
  }
  msg->err = err;
 2040f08:	e0bffd17 	ldw	r2,-12(fp)
 2040f0c:	e0fffc03 	ldbu	r3,-16(fp)
 2040f10:	10c00105 	stb	r3,4(r2)
  /* For all other protocols, netconn_connect() calls netconn_apimsg(),
     so use TCPIP_APIMSG_ACK() here. */
  TCPIP_APIMSG_ACK(msg);
 2040f14:	e0bffd17 	ldw	r2,-12(fp)
 2040f18:	10800017 	ldw	r2,0(r2)
 2040f1c:	10800404 	addi	r2,r2,16
 2040f20:	1009883a 	mov	r4,r2
 2040f24:	20150340 	call	2015034 <sys_sem_signal>
}
 2040f28:	e037883a 	mov	sp,fp
 2040f2c:	dfc00117 	ldw	ra,4(sp)
 2040f30:	df000017 	ldw	fp,0(sp)
 2040f34:	dec00204 	addi	sp,sp,8
 2040f38:	f800283a 	ret

02040f3c <lwip_netconn_do_disconnect>:
 *
 * @param m the api_msg pointing to the connection to disconnect
 */
void
lwip_netconn_do_disconnect(void *m)
{
 2040f3c:	defffc04 	addi	sp,sp,-16
 2040f40:	dfc00315 	stw	ra,12(sp)
 2040f44:	df000215 	stw	fp,8(sp)
 2040f48:	df000204 	addi	fp,sp,8
 2040f4c:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2040f50:	e0bfff17 	ldw	r2,-4(fp)
 2040f54:	e0bffe15 	stw	r2,-8(fp)

#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
 2040f58:	e0bffe17 	ldw	r2,-8(fp)
 2040f5c:	10800017 	ldw	r2,0(r2)
 2040f60:	10800017 	ldw	r2,0(r2)
 2040f64:	10803c0c 	andi	r2,r2,240
 2040f68:	10800818 	cmpnei	r2,r2,32
 2040f6c:	1000081e 	bne	r2,zero,2040f90 <lwip_netconn_do_disconnect+0x54>
    udp_disconnect(msg->conn->pcb.udp);
 2040f70:	e0bffe17 	ldw	r2,-8(fp)
 2040f74:	10800017 	ldw	r2,0(r2)
 2040f78:	10800217 	ldw	r2,8(r2)
 2040f7c:	1009883a 	mov	r4,r2
 2040f80:	202aa800 	call	202aa80 <udp_disconnect>
    msg->err = ERR_OK;
 2040f84:	e0bffe17 	ldw	r2,-8(fp)
 2040f88:	10000105 	stb	zero,4(r2)
 2040f8c:	00000306 	br	2040f9c <lwip_netconn_do_disconnect+0x60>
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
 2040f90:	e0bffe17 	ldw	r2,-8(fp)
 2040f94:	00fffe84 	movi	r3,-6
 2040f98:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
 2040f9c:	e0bffe17 	ldw	r2,-8(fp)
 2040fa0:	10800017 	ldw	r2,0(r2)
 2040fa4:	10800404 	addi	r2,r2,16
 2040fa8:	1009883a 	mov	r4,r2
 2040fac:	20150340 	call	2015034 <sys_sem_signal>
}
 2040fb0:	0001883a 	nop
 2040fb4:	e037883a 	mov	sp,fp
 2040fb8:	dfc00117 	ldw	ra,4(sp)
 2040fbc:	df000017 	ldw	fp,0(sp)
 2040fc0:	dec00204 	addi	sp,sp,8
 2040fc4:	f800283a 	ret

02040fc8 <lwip_netconn_do_listen>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_listen(void *m)
{
 2040fc8:	defff904 	addi	sp,sp,-28
 2040fcc:	dfc00615 	stw	ra,24(sp)
 2040fd0:	df000515 	stw	fp,20(sp)
 2040fd4:	df000504 	addi	fp,sp,20
 2040fd8:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2040fdc:	e0bfff17 	ldw	r2,-4(fp)
 2040fe0:	e0bffb15 	stw	r2,-20(fp)
  err_t err;

  if (msg->conn->pcb.tcp != NULL) {
 2040fe4:	e0bffb17 	ldw	r2,-20(fp)
 2040fe8:	10800017 	ldw	r2,0(r2)
 2040fec:	10800217 	ldw	r2,8(r2)
 2040ff0:	10007d26 	beq	r2,zero,20411e8 <lwip_netconn_do_listen+0x220>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 2040ff4:	e0bffb17 	ldw	r2,-20(fp)
 2040ff8:	10800017 	ldw	r2,0(r2)
 2040ffc:	10800017 	ldw	r2,0(r2)
 2041000:	10803c0c 	andi	r2,r2,240
 2041004:	10800418 	cmpnei	r2,r2,16
 2041008:	1000741e 	bne	r2,zero,20411dc <lwip_netconn_do_listen+0x214>
      if (msg->conn->state == NETCONN_NONE) {
 204100c:	e0bffb17 	ldw	r2,-20(fp)
 2041010:	10800017 	ldw	r2,0(r2)
 2041014:	10800117 	ldw	r2,4(r2)
 2041018:	10005a1e 	bne	r2,zero,2041184 <lwip_netconn_do_listen+0x1bc>
        struct tcp_pcb *lpcb;
        if (msg->conn->pcb.tcp->state != CLOSED) {
 204101c:	e0bffb17 	ldw	r2,-20(fp)
 2041020:	10800017 	ldw	r2,0(r2)
 2041024:	10800217 	ldw	r2,8(r2)
 2041028:	10800617 	ldw	r2,24(r2)
 204102c:	10000326 	beq	r2,zero,204103c <lwip_netconn_do_listen+0x74>
          /* connection is not closed, cannot listen */
          err = ERR_VAL;
 2041030:	00bffe84 	movi	r2,-6
 2041034:	e0bffe05 	stb	r2,-8(fp)
 2041038:	00006d06 	br	20411f0 <lwip_netconn_do_listen+0x228>
        } else {
          u8_t backlog;
#if TCP_LISTEN_BACKLOG
          backlog = msg->msg.lb.backlog;
 204103c:	e0bffb17 	ldw	r2,-20(fp)
 2041040:	10800203 	ldbu	r2,8(r2)
 2041044:	e0bffc05 	stb	r2,-16(fp)
            IP_SET_TYPE_VAL(msg->conn->pcb.tcp->local_ip,  IPADDR_TYPE_ANY);
            IP_SET_TYPE_VAL(msg->conn->pcb.tcp->remote_ip, IPADDR_TYPE_ANY);
          }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

          lpcb = tcp_listen_with_backlog_and_err(msg->conn->pcb.tcp, backlog, &err);
 2041048:	e0bffb17 	ldw	r2,-20(fp)
 204104c:	10800017 	ldw	r2,0(r2)
 2041050:	10800217 	ldw	r2,8(r2)
 2041054:	e0fffc03 	ldbu	r3,-16(fp)
 2041058:	e13ffe04 	addi	r4,fp,-8
 204105c:	200d883a 	mov	r6,r4
 2041060:	180b883a 	mov	r5,r3
 2041064:	1009883a 	mov	r4,r2
 2041068:	201fa000 	call	201fa00 <tcp_listen_with_backlog_and_err>
 204106c:	e0bffd15 	stw	r2,-12(fp)

          if (lpcb == NULL) {
 2041070:	e0bffd17 	ldw	r2,-12(fp)
 2041074:	10005e26 	beq	r2,zero,20411f0 <lwip_netconn_do_listen+0x228>
            /* in this case, the old pcb is still allocated */
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
 2041078:	e0bffb17 	ldw	r2,-20(fp)
 204107c:	10800017 	ldw	r2,0(r2)
 2041080:	10800504 	addi	r2,r2,20
 2041084:	10000c26 	beq	r2,zero,20410b8 <lwip_netconn_do_listen+0xf0>
 2041088:	e0bffb17 	ldw	r2,-20(fp)
 204108c:	10800017 	ldw	r2,0(r2)
 2041090:	10800517 	ldw	r2,20(r2)
 2041094:	10000826 	beq	r2,zero,20410b8 <lwip_netconn_do_listen+0xf0>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
 2041098:	e0bffb17 	ldw	r2,-20(fp)
 204109c:	10800017 	ldw	r2,0(r2)
 20410a0:	10800504 	addi	r2,r2,20
 20410a4:	1009883a 	mov	r4,r2
 20410a8:	20154c80 	call	20154c8 <sys_mbox_free>
              sys_mbox_set_invalid(&msg->conn->recvmbox);
 20410ac:	e0bffb17 	ldw	r2,-20(fp)
 20410b0:	10800017 	ldw	r2,0(r2)
 20410b4:	10000515 	stw	zero,20(r2)
            }
            err = ERR_OK;
 20410b8:	e03ffe05 	stb	zero,-8(fp)
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 20410bc:	e0bffb17 	ldw	r2,-20(fp)
 20410c0:	10800017 	ldw	r2,0(r2)
 20410c4:	10800604 	addi	r2,r2,24
 20410c8:	10000426 	beq	r2,zero,20410dc <lwip_netconn_do_listen+0x114>
 20410cc:	e0bffb17 	ldw	r2,-20(fp)
 20410d0:	10800017 	ldw	r2,0(r2)
 20410d4:	10800617 	ldw	r2,24(r2)
 20410d8:	1000071e 	bne	r2,zero,20410f8 <lwip_netconn_do_listen+0x130>
              err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
 20410dc:	e0bffb17 	ldw	r2,-20(fp)
 20410e0:	10800017 	ldw	r2,0(r2)
 20410e4:	10800604 	addi	r2,r2,24
 20410e8:	01420004 	movi	r5,2048
 20410ec:	1009883a 	mov	r4,r2
 20410f0:	20151640 	call	2015164 <sys_mbox_new>
 20410f4:	e0bffe05 	stb	r2,-8(fp)
            }
            if (err == ERR_OK) {
 20410f8:	e0bffe03 	ldbu	r2,-8(fp)
 20410fc:	10803fcc 	andi	r2,r2,255
 2041100:	1080201c 	xori	r2,r2,128
 2041104:	10bfe004 	addi	r2,r2,-128
 2041108:	1000181e 	bne	r2,zero,204116c <lwip_netconn_do_listen+0x1a4>
              msg->conn->state = NETCONN_LISTEN;
 204110c:	e0bffb17 	ldw	r2,-20(fp)
 2041110:	10800017 	ldw	r2,0(r2)
 2041114:	00c00084 	movi	r3,2
 2041118:	10c00115 	stw	r3,4(r2)
              msg->conn->pcb.tcp = lpcb;
 204111c:	e0bffb17 	ldw	r2,-20(fp)
 2041120:	10800017 	ldw	r2,0(r2)
 2041124:	e0fffd17 	ldw	r3,-12(fp)
 2041128:	10c00215 	stw	r3,8(r2)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
 204112c:	e0bffb17 	ldw	r2,-20(fp)
 2041130:	10800017 	ldw	r2,0(r2)
 2041134:	10c00217 	ldw	r3,8(r2)
 2041138:	e0bffb17 	ldw	r2,-20(fp)
 204113c:	10800017 	ldw	r2,0(r2)
 2041140:	100b883a 	mov	r5,r2
 2041144:	1809883a 	mov	r4,r3
 2041148:	20215d40 	call	20215d4 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
 204114c:	e0bffb17 	ldw	r2,-20(fp)
 2041150:	10800017 	ldw	r2,0(r2)
 2041154:	10800217 	ldw	r2,8(r2)
 2041158:	01408134 	movhi	r5,516
 204115c:	297f2a04 	addi	r5,r5,-856
 2041160:	1009883a 	mov	r4,r2
 2041164:	20216c40 	call	20216c4 <tcp_accept>
 2041168:	00002106 	br	20411f0 <lwip_netconn_do_listen+0x228>
            } else {
              /* since the old pcb is already deallocated, free lpcb now */
              tcp_close(lpcb);
 204116c:	e13ffd17 	ldw	r4,-12(fp)
 2041170:	201f3880 	call	201f388 <tcp_close>
              msg->conn->pcb.tcp = NULL;
 2041174:	e0bffb17 	ldw	r2,-20(fp)
 2041178:	10800017 	ldw	r2,0(r2)
 204117c:	10000215 	stw	zero,8(r2)
 2041180:	00001b06 	br	20411f0 <lwip_netconn_do_listen+0x228>
            }
          }
        }
      } else if (msg->conn->state == NETCONN_LISTEN) {
 2041184:	e0bffb17 	ldw	r2,-20(fp)
 2041188:	10800017 	ldw	r2,0(r2)
 204118c:	10800117 	ldw	r2,4(r2)
 2041190:	10800098 	cmpnei	r2,r2,2
 2041194:	10000e1e 	bne	r2,zero,20411d0 <lwip_netconn_do_listen+0x208>
        /* already listening, allow updating of the backlog */
        err = ERR_OK;
 2041198:	e03ffe05 	stb	zero,-8(fp)
        tcp_backlog_set(msg->conn->pcb.tcp, msg->msg.lb.backlog);
 204119c:	e0bffb17 	ldw	r2,-20(fp)
 20411a0:	10800017 	ldw	r2,0(r2)
 20411a4:	10c00217 	ldw	r3,8(r2)
 20411a8:	e0bffb17 	ldw	r2,-20(fp)
 20411ac:	10800203 	ldbu	r2,8(r2)
 20411b0:	10803fcc 	andi	r2,r2,255
 20411b4:	10000326 	beq	r2,zero,20411c4 <lwip_netconn_do_listen+0x1fc>
 20411b8:	e0bffb17 	ldw	r2,-20(fp)
 20411bc:	10800203 	ldbu	r2,8(r2)
 20411c0:	00000106 	br	20411c8 <lwip_netconn_do_listen+0x200>
 20411c4:	00800044 	movi	r2,1
 20411c8:	18800905 	stb	r2,36(r3)
 20411cc:	00000806 	br	20411f0 <lwip_netconn_do_listen+0x228>
      } else {
        err = ERR_CONN;
 20411d0:	00bffd44 	movi	r2,-11
 20411d4:	e0bffe05 	stb	r2,-8(fp)
 20411d8:	00000506 	br	20411f0 <lwip_netconn_do_listen+0x228>
      }
    } else {
      err = ERR_ARG;
 20411dc:	00bffc04 	movi	r2,-16
 20411e0:	e0bffe05 	stb	r2,-8(fp)
 20411e4:	00000206 	br	20411f0 <lwip_netconn_do_listen+0x228>
    }
  } else {
    err = ERR_CONN;
 20411e8:	00bffd44 	movi	r2,-11
 20411ec:	e0bffe05 	stb	r2,-8(fp)
  }
  msg->err = err;
 20411f0:	e0fffe03 	ldbu	r3,-8(fp)
 20411f4:	e0bffb17 	ldw	r2,-20(fp)
 20411f8:	10c00105 	stb	r3,4(r2)
  TCPIP_APIMSG_ACK(msg);
 20411fc:	e0bffb17 	ldw	r2,-20(fp)
 2041200:	10800017 	ldw	r2,0(r2)
 2041204:	10800404 	addi	r2,r2,16
 2041208:	1009883a 	mov	r4,r2
 204120c:	20150340 	call	2015034 <sys_sem_signal>
}
 2041210:	0001883a 	nop
 2041214:	e037883a 	mov	sp,fp
 2041218:	dfc00117 	ldw	ra,4(sp)
 204121c:	df000017 	ldw	fp,0(sp)
 2041220:	dec00204 	addi	sp,sp,8
 2041224:	f800283a 	ret

02041228 <lwip_netconn_do_send>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_send(void *m)
{
 2041228:	defff904 	addi	sp,sp,-28
 204122c:	dfc00615 	stw	ra,24(sp)
 2041230:	df000515 	stw	fp,20(sp)
 2041234:	df000504 	addi	fp,sp,20
 2041238:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 204123c:	e0bfff17 	ldw	r2,-4(fp)
 2041240:	e0bffe15 	stw	r2,-8(fp)

  err_t err = netconn_err(msg->conn);
 2041244:	e0bffe17 	ldw	r2,-8(fp)
 2041248:	10800017 	ldw	r2,0(r2)
 204124c:	1009883a 	mov	r4,r2
 2041250:	203f2800 	call	203f280 <netconn_err>
 2041254:	e0bffd05 	stb	r2,-12(fp)
  if (err == ERR_OK) {
 2041258:	e0bffd07 	ldb	r2,-12(fp)
 204125c:	10006d1e 	bne	r2,zero,2041414 <lwip_netconn_do_send+0x1ec>
    if (msg->conn->pcb.tcp != NULL) {
 2041260:	e0bffe17 	ldw	r2,-8(fp)
 2041264:	10800017 	ldw	r2,0(r2)
 2041268:	10800217 	ldw	r2,8(r2)
 204126c:	10006726 	beq	r2,zero,204140c <lwip_netconn_do_send+0x1e4>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 2041270:	e0bffe17 	ldw	r2,-8(fp)
 2041274:	10800017 	ldw	r2,0(r2)
 2041278:	10800017 	ldw	r2,0(r2)
 204127c:	10803c0c 	andi	r2,r2,240
 2041280:	10c00820 	cmpeqi	r3,r2,32
 2041284:	1800241e 	bne	r3,zero,2041318 <lwip_netconn_do_send+0xf0>
 2041288:	10801020 	cmpeqi	r2,r2,64
 204128c:	10005b26 	beq	r2,zero,20413fc <lwip_netconn_do_send+0x1d4>
#if LWIP_RAW
        case NETCONN_RAW:
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
 2041290:	e0bffe17 	ldw	r2,-8(fp)
 2041294:	10800217 	ldw	r2,8(r2)
 2041298:	10800204 	addi	r2,r2,8
 204129c:	10000426 	beq	r2,zero,20412b0 <lwip_netconn_do_send+0x88>
 20412a0:	e0bffe17 	ldw	r2,-8(fp)
 20412a4:	10800217 	ldw	r2,8(r2)
 20412a8:	10800217 	ldw	r2,8(r2)
 20412ac:	10000b1e 	bne	r2,zero,20412dc <lwip_netconn_do_send+0xb4>
            err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
 20412b0:	e0bffe17 	ldw	r2,-8(fp)
 20412b4:	10800017 	ldw	r2,0(r2)
 20412b8:	10c00217 	ldw	r3,8(r2)
 20412bc:	e0bffe17 	ldw	r2,-8(fp)
 20412c0:	10800217 	ldw	r2,8(r2)
 20412c4:	10800017 	ldw	r2,0(r2)
 20412c8:	100b883a 	mov	r5,r2
 20412cc:	1809883a 	mov	r4,r3
 20412d0:	201eb1c0 	call	201eb1c <raw_send>
 20412d4:	e0bffd05 	stb	r2,-12(fp)
          } else {
            err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
          }
          break;
 20412d8:	00004e06 	br	2041414 <lwip_netconn_do_send+0x1ec>
#if LWIP_RAW
        case NETCONN_RAW:
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
            err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
          } else {
            err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
 20412dc:	e0bffe17 	ldw	r2,-8(fp)
 20412e0:	10800017 	ldw	r2,0(r2)
 20412e4:	10c00217 	ldw	r3,8(r2)
 20412e8:	e0bffe17 	ldw	r2,-8(fp)
 20412ec:	10800217 	ldw	r2,8(r2)
 20412f0:	11000017 	ldw	r4,0(r2)
 20412f4:	e0bffe17 	ldw	r2,-8(fp)
 20412f8:	10800217 	ldw	r2,8(r2)
 20412fc:	10800204 	addi	r2,r2,8
 2041300:	100d883a 	mov	r6,r2
 2041304:	200b883a 	mov	r5,r4
 2041308:	1809883a 	mov	r4,r3
 204130c:	201e8100 	call	201e810 <raw_sendto>
 2041310:	e0bffd05 	stb	r2,-12(fp)
          }
          break;
 2041314:	00003f06 	br	2041414 <lwip_netconn_do_send+0x1ec>
#endif
#if LWIP_UDP
        case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
 2041318:	e0bffe17 	ldw	r2,-8(fp)
 204131c:	10800217 	ldw	r2,8(r2)
 2041320:	10800204 	addi	r2,r2,8
 2041324:	10000426 	beq	r2,zero,2041338 <lwip_netconn_do_send+0x110>
 2041328:	e0bffe17 	ldw	r2,-8(fp)
 204132c:	10800217 	ldw	r2,8(r2)
 2041330:	10800217 	ldw	r2,8(r2)
 2041334:	1000161e 	bne	r2,zero,2041390 <lwip_netconn_do_send+0x168>
            err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 2041338:	e0bffe17 	ldw	r2,-8(fp)
 204133c:	10800017 	ldw	r2,0(r2)
 2041340:	10c00217 	ldw	r3,8(r2)
 2041344:	e0bffe17 	ldw	r2,-8(fp)
 2041348:	10800217 	ldw	r2,8(r2)
 204134c:	11000017 	ldw	r4,0(r2)
                                  msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 2041350:	e0bffe17 	ldw	r2,-8(fp)
 2041354:	10800217 	ldw	r2,8(r2)
 2041358:	10800383 	ldbu	r2,14(r2)
#endif
#if LWIP_UDP
        case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
            err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 204135c:	10803fcc 	andi	r2,r2,255
 2041360:	1140008c 	andi	r5,r2,2
                                  msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 2041364:	e0bffe17 	ldw	r2,-8(fp)
 2041368:	10800217 	ldw	r2,8(r2)
 204136c:	1080040b 	ldhu	r2,16(r2)
#endif
#if LWIP_UDP
        case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
            err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 2041370:	10bfffcc 	andi	r2,r2,65535
 2041374:	100f883a 	mov	r7,r2
 2041378:	280d883a 	mov	r6,r5
 204137c:	200b883a 	mov	r5,r4
 2041380:	1809883a 	mov	r4,r3
 2041384:	2029f2c0 	call	2029f2c <udp_send_chksum>
 2041388:	e0bffd05 	stb	r2,-12(fp)
            err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
          } else {
            err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
          }
#endif /* LWIP_CHECKSUM_ON_COPY */
          break;
 204138c:	00002106 	br	2041414 <lwip_netconn_do_send+0x1ec>
#if LWIP_CHECKSUM_ON_COPY
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
            err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
                                  msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
          } else {
            err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 2041390:	e0bffe17 	ldw	r2,-8(fp)
 2041394:	10800017 	ldw	r2,0(r2)
 2041398:	11000217 	ldw	r4,8(r2)
 204139c:	e0bffe17 	ldw	r2,-8(fp)
 20413a0:	10800217 	ldw	r2,8(r2)
 20413a4:	11400017 	ldw	r5,0(r2)
                                    &msg->msg.b->addr, msg->msg.b->port,
 20413a8:	e0bffe17 	ldw	r2,-8(fp)
 20413ac:	10800217 	ldw	r2,8(r2)
 20413b0:	11800204 	addi	r6,r2,8
 20413b4:	e0bffe17 	ldw	r2,-8(fp)
 20413b8:	10800217 	ldw	r2,8(r2)
 20413bc:	1080030b 	ldhu	r2,12(r2)
#if LWIP_CHECKSUM_ON_COPY
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
            err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
                                  msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
          } else {
            err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 20413c0:	11ffffcc 	andi	r7,r2,65535
                                    &msg->msg.b->addr, msg->msg.b->port,
                                    msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 20413c4:	e0bffe17 	ldw	r2,-8(fp)
 20413c8:	10800217 	ldw	r2,8(r2)
 20413cc:	10800383 	ldbu	r2,14(r2)
#if LWIP_CHECKSUM_ON_COPY
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
            err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
                                  msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
          } else {
            err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 20413d0:	10803fcc 	andi	r2,r2,255
 20413d4:	1080008c 	andi	r2,r2,2
                                    &msg->msg.b->addr, msg->msg.b->port,
                                    msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 20413d8:	e0fffe17 	ldw	r3,-8(fp)
 20413dc:	18c00217 	ldw	r3,8(r3)
 20413e0:	18c0040b 	ldhu	r3,16(r3)
#if LWIP_CHECKSUM_ON_COPY
          if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
            err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
                                  msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
          } else {
            err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 20413e4:	18ffffcc 	andi	r3,r3,65535
 20413e8:	d8c00115 	stw	r3,4(sp)
 20413ec:	d8800015 	stw	r2,0(sp)
 20413f0:	202a0180 	call	202a018 <udp_sendto_chksum>
 20413f4:	e0bffd05 	stb	r2,-12(fp)
            err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
          } else {
            err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
          }
#endif /* LWIP_CHECKSUM_ON_COPY */
          break;
 20413f8:	00000606 	br	2041414 <lwip_netconn_do_send+0x1ec>
#endif /* LWIP_UDP */
        default:
          err = ERR_CONN;
 20413fc:	00bffd44 	movi	r2,-11
 2041400:	e0bffd05 	stb	r2,-12(fp)
          break;
 2041404:	0001883a 	nop
 2041408:	00000206 	br	2041414 <lwip_netconn_do_send+0x1ec>
      }
    } else {
      err = ERR_CONN;
 204140c:	00bffd44 	movi	r2,-11
 2041410:	e0bffd05 	stb	r2,-12(fp)
    }
  }
  msg->err = err;
 2041414:	e0bffe17 	ldw	r2,-8(fp)
 2041418:	e0fffd03 	ldbu	r3,-12(fp)
 204141c:	10c00105 	stb	r3,4(r2)
  TCPIP_APIMSG_ACK(msg);
 2041420:	e0bffe17 	ldw	r2,-8(fp)
 2041424:	10800017 	ldw	r2,0(r2)
 2041428:	10800404 	addi	r2,r2,16
 204142c:	1009883a 	mov	r4,r2
 2041430:	20150340 	call	2015034 <sys_sem_signal>
}
 2041434:	0001883a 	nop
 2041438:	e037883a 	mov	sp,fp
 204143c:	dfc00117 	ldw	ra,4(sp)
 2041440:	df000017 	ldw	fp,0(sp)
 2041444:	dec00204 	addi	sp,sp,8
 2041448:	f800283a 	ret

0204144c <lwip_netconn_do_recv>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_recv(void *m)
{
 204144c:	defffa04 	addi	sp,sp,-24
 2041450:	dfc00515 	stw	ra,20(sp)
 2041454:	df000415 	stw	fp,16(sp)
 2041458:	df000404 	addi	fp,sp,16
 204145c:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2041460:	e0bfff17 	ldw	r2,-4(fp)
 2041464:	e0bffd15 	stw	r2,-12(fp)

  msg->err = ERR_OK;
 2041468:	e0bffd17 	ldw	r2,-12(fp)
 204146c:	10000105 	stb	zero,4(r2)
  if (msg->conn->pcb.tcp != NULL) {
 2041470:	e0bffd17 	ldw	r2,-12(fp)
 2041474:	10800017 	ldw	r2,0(r2)
 2041478:	10800217 	ldw	r2,8(r2)
 204147c:	10001d26 	beq	r2,zero,20414f4 <lwip_netconn_do_recv+0xa8>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 2041480:	e0bffd17 	ldw	r2,-12(fp)
 2041484:	10800017 	ldw	r2,0(r2)
 2041488:	10800017 	ldw	r2,0(r2)
 204148c:	10803c0c 	andi	r2,r2,240
 2041490:	10800418 	cmpnei	r2,r2,16
 2041494:	1000171e 	bne	r2,zero,20414f4 <lwip_netconn_do_recv+0xa8>
      size_t remaining = msg->msg.r.len;
 2041498:	e0bffd17 	ldw	r2,-12(fp)
 204149c:	10800217 	ldw	r2,8(r2)
 20414a0:	e0bffc15 	stw	r2,-16(fp)
      do {
        u16_t recved = (u16_t)((remaining > 0xffff) ? 0xffff : remaining);
 20414a4:	e0bffc17 	ldw	r2,-16(fp)
 20414a8:	00ffffd4 	movui	r3,65535
 20414ac:	18800236 	bltu	r3,r2,20414b8 <lwip_netconn_do_recv+0x6c>
 20414b0:	e0bffc17 	ldw	r2,-16(fp)
 20414b4:	00000106 	br	20414bc <lwip_netconn_do_recv+0x70>
 20414b8:	00bfffc4 	movi	r2,-1
 20414bc:	e0bffe0d 	sth	r2,-8(fp)
        tcp_recved(msg->conn->pcb.tcp, recved);
 20414c0:	e0bffd17 	ldw	r2,-12(fp)
 20414c4:	10800017 	ldw	r2,0(r2)
 20414c8:	10800217 	ldw	r2,8(r2)
 20414cc:	e0fffe0b 	ldhu	r3,-8(fp)
 20414d0:	180b883a 	mov	r5,r3
 20414d4:	1009883a 	mov	r4,r2
 20414d8:	201fd780 	call	201fd78 <tcp_recved>
        remaining -= recved;
 20414dc:	e0bffe0b 	ldhu	r2,-8(fp)
 20414e0:	e0fffc17 	ldw	r3,-16(fp)
 20414e4:	1885c83a 	sub	r2,r3,r2
 20414e8:	e0bffc15 	stw	r2,-16(fp)
      } while (remaining != 0);
 20414ec:	e0bffc17 	ldw	r2,-16(fp)
 20414f0:	103fec1e 	bne	r2,zero,20414a4 <__alt_mem_mem_0+0xfd0214a4>
    }
  }
  TCPIP_APIMSG_ACK(msg);
 20414f4:	e0bffd17 	ldw	r2,-12(fp)
 20414f8:	10800017 	ldw	r2,0(r2)
 20414fc:	10800404 	addi	r2,r2,16
 2041500:	1009883a 	mov	r4,r2
 2041504:	20150340 	call	2015034 <sys_sem_signal>
}
 2041508:	0001883a 	nop
 204150c:	e037883a 	mov	sp,fp
 2041510:	dfc00117 	ldw	ra,4(sp)
 2041514:	df000017 	ldw	fp,0(sp)
 2041518:	dec00204 	addi	sp,sp,8
 204151c:	f800283a 	ret

02041520 <lwip_netconn_do_accepted>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_accepted(void *m)
{
 2041520:	defffc04 	addi	sp,sp,-16
 2041524:	dfc00315 	stw	ra,12(sp)
 2041528:	df000215 	stw	fp,8(sp)
 204152c:	df000204 	addi	fp,sp,8
 2041530:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2041534:	e0bfff17 	ldw	r2,-4(fp)
 2041538:	e0bffe15 	stw	r2,-8(fp)

  msg->err = ERR_OK;
 204153c:	e0bffe17 	ldw	r2,-8(fp)
 2041540:	10000105 	stb	zero,4(r2)
  if (msg->conn->pcb.tcp != NULL) {
 2041544:	e0bffe17 	ldw	r2,-8(fp)
 2041548:	10800017 	ldw	r2,0(r2)
 204154c:	10800217 	ldw	r2,8(r2)
 2041550:	10000b26 	beq	r2,zero,2041580 <lwip_netconn_do_accepted+0x60>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 2041554:	e0bffe17 	ldw	r2,-8(fp)
 2041558:	10800017 	ldw	r2,0(r2)
 204155c:	10800017 	ldw	r2,0(r2)
 2041560:	10803c0c 	andi	r2,r2,240
 2041564:	10800418 	cmpnei	r2,r2,16
 2041568:	1000051e 	bne	r2,zero,2041580 <lwip_netconn_do_accepted+0x60>
      tcp_backlog_accepted(msg->conn->pcb.tcp);
 204156c:	e0bffe17 	ldw	r2,-8(fp)
 2041570:	10800017 	ldw	r2,0(r2)
 2041574:	10800217 	ldw	r2,8(r2)
 2041578:	1009883a 	mov	r4,r2
 204157c:	201efa80 	call	201efa8 <tcp_backlog_accepted>
    }
  }
  TCPIP_APIMSG_ACK(msg);
 2041580:	e0bffe17 	ldw	r2,-8(fp)
 2041584:	10800017 	ldw	r2,0(r2)
 2041588:	10800404 	addi	r2,r2,16
 204158c:	1009883a 	mov	r4,r2
 2041590:	20150340 	call	2015034 <sys_sem_signal>
}
 2041594:	0001883a 	nop
 2041598:	e037883a 	mov	sp,fp
 204159c:	dfc00117 	ldw	ra,4(sp)
 20415a0:	df000017 	ldw	fp,0(sp)
 20415a4:	dec00204 	addi	sp,sp,8
 20415a8:	f800283a 	ret

020415ac <lwip_netconn_do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
lwip_netconn_do_writemore(struct netconn *conn  WRITE_DELAYED_PARAM)
{
 20415ac:	defff704 	addi	sp,sp,-36
 20415b0:	dfc00815 	stw	ra,32(sp)
 20415b4:	df000715 	stw	fp,28(sp)
 20415b8:	df000704 	addi	fp,sp,28
 20415bc:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  const void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
 20415c0:	e03ffa05 	stb	zero,-24(fp)
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  LWIP_ASSERT("conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len",
              conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len);
  LWIP_ASSERT("conn->current_msg->msg.w.vector_cnt > 0", conn->current_msg->msg.w.vector_cnt > 0);

  apiflags = conn->current_msg->msg.w.apiflags;
 20415c4:	e0bfff17 	ldw	r2,-4(fp)
 20415c8:	10800a17 	ldw	r2,40(r2)
 20415cc:	10800703 	ldbu	r2,28(r2)
 20415d0:	e0bffa45 	stb	r2,-23(fp)
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 20415d4:	e0bfff17 	ldw	r2,-4(fp)
 20415d8:	10800903 	ldbu	r2,36(r2)
 20415dc:	10803fcc 	andi	r2,r2,255
 20415e0:	1080008c 	andi	r2,r2,2
 20415e4:	1000031e 	bne	r2,zero,20415f4 <lwip_netconn_do_writemore+0x48>
 20415e8:	e0bffa43 	ldbu	r2,-23(fp)
 20415ec:	1080010c 	andi	r2,r2,4
 20415f0:	10000226 	beq	r2,zero,20415fc <lwip_netconn_do_writemore+0x50>
 20415f4:	00800044 	movi	r2,1
 20415f8:	00000106 	br	2041600 <lwip_netconn_do_writemore+0x54>
 20415fc:	0005883a 	mov	r2,zero
 2041600:	e0bffac5 	stb	r2,-21(fp)
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    do {
      dataptr = (const u8_t *)conn->current_msg->msg.w.vector->ptr + conn->current_msg->msg.w.vector_off;
 2041604:	e0bfff17 	ldw	r2,-4(fp)
 2041608:	10800a17 	ldw	r2,40(r2)
 204160c:	10800217 	ldw	r2,8(r2)
 2041610:	10c00017 	ldw	r3,0(r2)
 2041614:	e0bfff17 	ldw	r2,-4(fp)
 2041618:	10800a17 	ldw	r2,40(r2)
 204161c:	10800417 	ldw	r2,16(r2)
 2041620:	1885883a 	add	r2,r3,r2
 2041624:	e0bffb15 	stw	r2,-20(fp)
      diff = conn->current_msg->msg.w.vector->len - conn->current_msg->msg.w.vector_off;
 2041628:	e0bfff17 	ldw	r2,-4(fp)
 204162c:	10800a17 	ldw	r2,40(r2)
 2041630:	10800217 	ldw	r2,8(r2)
 2041634:	10c00117 	ldw	r3,4(r2)
 2041638:	e0bfff17 	ldw	r2,-4(fp)
 204163c:	10800a17 	ldw	r2,40(r2)
 2041640:	10800417 	ldw	r2,16(r2)
 2041644:	1885c83a 	sub	r2,r3,r2
 2041648:	e0bffc15 	stw	r2,-16(fp)
      if (diff > 0xffffUL) { /* max_u16_t */
 204164c:	e0bffc17 	ldw	r2,-16(fp)
 2041650:	00ffffd4 	movui	r3,65535
 2041654:	1880062e 	bgeu	r3,r2,2041670 <lwip_netconn_do_writemore+0xc4>
        len = 0xffff;
 2041658:	00bfffc4 	movi	r2,-1
 204165c:	e0bff98d 	sth	r2,-26(fp)
        apiflags |= TCP_WRITE_FLAG_MORE;
 2041660:	e0bffa43 	ldbu	r2,-23(fp)
 2041664:	10800094 	ori	r2,r2,2
 2041668:	e0bffa45 	stb	r2,-23(fp)
 204166c:	00000206 	br	2041678 <lwip_netconn_do_writemore+0xcc>
      } else {
        len = (u16_t)diff;
 2041670:	e0bffc17 	ldw	r2,-16(fp)
 2041674:	e0bff98d 	sth	r2,-26(fp)
      }
      available = tcp_sndbuf(conn->pcb.tcp);
 2041678:	e0bfff17 	ldw	r2,-4(fp)
 204167c:	10800217 	ldw	r2,8(r2)
 2041680:	10801b0b 	ldhu	r2,108(r2)
 2041684:	e0bffd0d 	sth	r2,-12(fp)
      if (available < len) {
 2041688:	e0fffd0b 	ldhu	r3,-12(fp)
 204168c:	e0bff98b 	ldhu	r2,-26(fp)
 2041690:	1880122e 	bgeu	r3,r2,20416dc <lwip_netconn_do_writemore+0x130>
        /* don't try to write more than sendbuf */
        len = available;
 2041694:	e0bffd0b 	ldhu	r2,-12(fp)
 2041698:	e0bff98d 	sth	r2,-26(fp)
        if (dontblock) {
 204169c:	e0bffac3 	ldbu	r2,-21(fp)
 20416a0:	10000b26 	beq	r2,zero,20416d0 <lwip_netconn_do_writemore+0x124>
          if (!len) {
 20416a4:	e0bff98b 	ldhu	r2,-26(fp)
 20416a8:	10000c1e 	bne	r2,zero,20416dc <lwip_netconn_do_writemore+0x130>
            /* set error according to partial write or not */
            err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
 20416ac:	e0bfff17 	ldw	r2,-4(fp)
 20416b0:	10800a17 	ldw	r2,40(r2)
 20416b4:	10800617 	ldw	r2,24(r2)
 20416b8:	1000021e 	bne	r2,zero,20416c4 <lwip_netconn_do_writemore+0x118>
 20416bc:	00bffe44 	movi	r2,-7
 20416c0:	00000106 	br	20416c8 <lwip_netconn_do_writemore+0x11c>
 20416c4:	0005883a 	mov	r2,zero
 20416c8:	e0bff905 	stb	r2,-28(fp)
            goto err_mem;
 20416cc:	00005906 	br	2041834 <lwip_netconn_do_writemore+0x288>
          }
        } else {
          apiflags |= TCP_WRITE_FLAG_MORE;
 20416d0:	e0bffa43 	ldbu	r2,-23(fp)
 20416d4:	10800094 	ori	r2,r2,2
 20416d8:	e0bffa45 	stb	r2,-23(fp)
                  ((conn->current_msg->msg.w.vector_off + len) <= conn->current_msg->msg.w.vector->len));
      /* we should loop around for more sending in the following cases:
           1) We couldn't finish the current vector because of 16-bit size limitations.
              tcp_write() and tcp_sndbuf() both are limited to 16-bit sizes
           2) We are sending the remainder of the current vector and have more */
      if ((len == 0xffff && diff > 0xffffUL) ||
 20416dc:	e0fff98b 	ldhu	r3,-26(fp)
 20416e0:	00bfffd4 	movui	r2,65535
 20416e4:	1880031e 	bne	r3,r2,20416f4 <lwip_netconn_do_writemore+0x148>
 20416e8:	e0bffc17 	ldw	r2,-16(fp)
 20416ec:	00ffffd4 	movui	r3,65535
 20416f0:	18800a36 	bltu	r3,r2,204171c <lwip_netconn_do_writemore+0x170>
          (len == (u16_t)diff && conn->current_msg->msg.w.vector_cnt > 1)) {
 20416f4:	e0fff98b 	ldhu	r3,-26(fp)
 20416f8:	e0bffc17 	ldw	r2,-16(fp)
 20416fc:	10bfffcc 	andi	r2,r2,65535
                  ((conn->current_msg->msg.w.vector_off + len) <= conn->current_msg->msg.w.vector->len));
      /* we should loop around for more sending in the following cases:
           1) We couldn't finish the current vector because of 16-bit size limitations.
              tcp_write() and tcp_sndbuf() both are limited to 16-bit sizes
           2) We are sending the remainder of the current vector and have more */
      if ((len == 0xffff && diff > 0xffffUL) ||
 2041700:	18800c1e 	bne	r3,r2,2041734 <lwip_netconn_do_writemore+0x188>
          (len == (u16_t)diff && conn->current_msg->msg.w.vector_cnt > 1)) {
 2041704:	e0bfff17 	ldw	r2,-4(fp)
 2041708:	10800a17 	ldw	r2,40(r2)
 204170c:	1080030b 	ldhu	r2,12(r2)
 2041710:	10bfffcc 	andi	r2,r2,65535
 2041714:	108000b0 	cmpltui	r2,r2,2
 2041718:	1000061e 	bne	r2,zero,2041734 <lwip_netconn_do_writemore+0x188>
        write_more = 1;
 204171c:	00800044 	movi	r2,1
 2041720:	e0bffa85 	stb	r2,-22(fp)
        apiflags |= TCP_WRITE_FLAG_MORE;
 2041724:	e0bffa43 	ldbu	r2,-23(fp)
 2041728:	10800094 	ori	r2,r2,2
 204172c:	e0bffa45 	stb	r2,-23(fp)
 2041730:	00000106 	br	2041738 <lwip_netconn_do_writemore+0x18c>
      } else {
        write_more = 0;
 2041734:	e03ffa85 	stb	zero,-22(fp)
      }
      err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 2041738:	e0bfff17 	ldw	r2,-4(fp)
 204173c:	10800217 	ldw	r2,8(r2)
 2041740:	e0fff98b 	ldhu	r3,-26(fp)
 2041744:	e13ffa43 	ldbu	r4,-23(fp)
 2041748:	200f883a 	mov	r7,r4
 204174c:	180d883a 	mov	r6,r3
 2041750:	e17ffb17 	ldw	r5,-20(fp)
 2041754:	1009883a 	mov	r4,r2
 2041758:	20262040 	call	2026204 <tcp_write>
 204175c:	e0bff905 	stb	r2,-28(fp)
      if (err == ERR_OK) {
 2041760:	e0bff907 	ldb	r2,-28(fp)
 2041764:	10002a1e 	bne	r2,zero,2041810 <lwip_netconn_do_writemore+0x264>
        conn->current_msg->msg.w.offset += len;
 2041768:	e0bfff17 	ldw	r2,-4(fp)
 204176c:	10800a17 	ldw	r2,40(r2)
 2041770:	e0ffff17 	ldw	r3,-4(fp)
 2041774:	18c00a17 	ldw	r3,40(r3)
 2041778:	19000617 	ldw	r4,24(r3)
 204177c:	e0fff98b 	ldhu	r3,-26(fp)
 2041780:	20c7883a 	add	r3,r4,r3
 2041784:	10c00615 	stw	r3,24(r2)
        conn->current_msg->msg.w.vector_off += len;
 2041788:	e0bfff17 	ldw	r2,-4(fp)
 204178c:	10800a17 	ldw	r2,40(r2)
 2041790:	e0ffff17 	ldw	r3,-4(fp)
 2041794:	18c00a17 	ldw	r3,40(r3)
 2041798:	19000417 	ldw	r4,16(r3)
 204179c:	e0fff98b 	ldhu	r3,-26(fp)
 20417a0:	20c7883a 	add	r3,r4,r3
 20417a4:	10c00415 	stw	r3,16(r2)
        /* check if current vector is finished */
        if (conn->current_msg->msg.w.vector_off == conn->current_msg->msg.w.vector->len) {
 20417a8:	e0bfff17 	ldw	r2,-4(fp)
 20417ac:	10800a17 	ldw	r2,40(r2)
 20417b0:	10c00417 	ldw	r3,16(r2)
 20417b4:	e0bfff17 	ldw	r2,-4(fp)
 20417b8:	10800a17 	ldw	r2,40(r2)
 20417bc:	10800217 	ldw	r2,8(r2)
 20417c0:	10800117 	ldw	r2,4(r2)
 20417c4:	1880121e 	bne	r3,r2,2041810 <lwip_netconn_do_writemore+0x264>
          conn->current_msg->msg.w.vector_cnt--;
 20417c8:	e0bfff17 	ldw	r2,-4(fp)
 20417cc:	10800a17 	ldw	r2,40(r2)
 20417d0:	10c0030b 	ldhu	r3,12(r2)
 20417d4:	18ffffc4 	addi	r3,r3,-1
 20417d8:	10c0030d 	sth	r3,12(r2)
          /* if we have additional vectors, move on to them */
          if (conn->current_msg->msg.w.vector_cnt > 0) {
 20417dc:	e0bfff17 	ldw	r2,-4(fp)
 20417e0:	10800a17 	ldw	r2,40(r2)
 20417e4:	1080030b 	ldhu	r2,12(r2)
 20417e8:	10bfffcc 	andi	r2,r2,65535
 20417ec:	10000826 	beq	r2,zero,2041810 <lwip_netconn_do_writemore+0x264>
            conn->current_msg->msg.w.vector++;
 20417f0:	e0bfff17 	ldw	r2,-4(fp)
 20417f4:	10800a17 	ldw	r2,40(r2)
 20417f8:	10c00217 	ldw	r3,8(r2)
 20417fc:	18c00204 	addi	r3,r3,8
 2041800:	10c00215 	stw	r3,8(r2)
            conn->current_msg->msg.w.vector_off = 0;
 2041804:	e0bfff17 	ldw	r2,-4(fp)
 2041808:	10800a17 	ldw	r2,40(r2)
 204180c:	10000415 	stw	zero,16(r2)
          }
        }
      }
    } while (write_more && err == ERR_OK);
 2041810:	e0bffa83 	ldbu	r2,-22(fp)
 2041814:	10000226 	beq	r2,zero,2041820 <lwip_netconn_do_writemore+0x274>
 2041818:	e0bff907 	ldb	r2,-28(fp)
 204181c:	103f7926 	beq	r2,zero,2041604 <__alt_mem_mem_0+0xfd021604>
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 2041820:	e0bff907 	ldb	r2,-28(fp)
 2041824:	10000326 	beq	r2,zero,2041834 <lwip_netconn_do_writemore+0x288>
 2041828:	e0bff907 	ldb	r2,-28(fp)
 204182c:	10bfffd8 	cmpnei	r2,r2,-1
 2041830:	10002e1e 	bne	r2,zero,20418ec <lwip_netconn_do_writemore+0x340>
err_mem:
      if (dontblock && (conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len)) {
 2041834:	e0bffac3 	ldbu	r2,-21(fp)
 2041838:	10001726 	beq	r2,zero,2041898 <lwip_netconn_do_writemore+0x2ec>
 204183c:	e0bfff17 	ldw	r2,-4(fp)
 2041840:	10800a17 	ldw	r2,40(r2)
 2041844:	10c00617 	ldw	r3,24(r2)
 2041848:	e0bfff17 	ldw	r2,-4(fp)
 204184c:	10800a17 	ldw	r2,40(r2)
 2041850:	10800517 	ldw	r2,20(r2)
 2041854:	1880102e 	bgeu	r3,r2,2041898 <lwip_netconn_do_writemore+0x2ec>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
 2041858:	e0bfff17 	ldw	r2,-4(fp)
 204185c:	10800b17 	ldw	r2,44(r2)
 2041860:	10000626 	beq	r2,zero,204187c <lwip_netconn_do_writemore+0x2d0>
 2041864:	e0bfff17 	ldw	r2,-4(fp)
 2041868:	10800b17 	ldw	r2,44(r2)
 204186c:	000d883a 	mov	r6,zero
 2041870:	014000c4 	movi	r5,3
 2041874:	e13fff17 	ldw	r4,-4(fp)
 2041878:	103ee83a 	callr	r2
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
 204187c:	e0bfff17 	ldw	r2,-4(fp)
 2041880:	10800903 	ldbu	r2,36(r2)
 2041884:	10800414 	ori	r2,r2,16
 2041888:	1007883a 	mov	r3,r2
 204188c:	e0bfff17 	ldw	r2,-4(fp)
 2041890:	10c00905 	stb	r3,36(r2)
 2041894:	00001506 	br	20418ec <lwip_netconn_do_writemore+0x340>
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 2041898:	e0bfff17 	ldw	r2,-4(fp)
 204189c:	10800217 	ldw	r2,8(r2)
 20418a0:	10801b0b 	ldhu	r2,108(r2)
 20418a4:	10bfffcc 	andi	r2,r2,65535
 20418a8:	10816d70 	cmpltui	r2,r2,1461
 20418ac:	1000061e 	bne	r2,zero,20418c8 <lwip_netconn_do_writemore+0x31c>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
 20418b0:	e0bfff17 	ldw	r2,-4(fp)
 20418b4:	10800217 	ldw	r2,8(r2)
 20418b8:	10801b8b 	ldhu	r2,110(r2)
      if (dontblock && (conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len)) {
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 20418bc:	10bfffcc 	andi	r2,r2,65535
 20418c0:	10800130 	cmpltui	r2,r2,4
 20418c4:	1000091e 	bne	r2,zero,20418ec <lwip_netconn_do_writemore+0x340>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
 20418c8:	e0bfff17 	ldw	r2,-4(fp)
 20418cc:	10800b17 	ldw	r2,44(r2)
 20418d0:	10000626 	beq	r2,zero,20418ec <lwip_netconn_do_writemore+0x340>
 20418d4:	e0bfff17 	ldw	r2,-4(fp)
 20418d8:	10800b17 	ldw	r2,44(r2)
 20418dc:	000d883a 	mov	r6,zero
 20418e0:	014000c4 	movi	r5,3
 20418e4:	e13fff17 	ldw	r4,-4(fp)
 20418e8:	103ee83a 	callr	r2
      }
    }

    if (err == ERR_OK) {
 20418ec:	e0bff907 	ldb	r2,-28(fp)
 20418f0:	1000181e 	bne	r2,zero,2041954 <lwip_netconn_do_writemore+0x3a8>
      err_t out_err;
      if ((conn->current_msg->msg.w.offset == conn->current_msg->msg.w.len) || dontblock) {
 20418f4:	e0bfff17 	ldw	r2,-4(fp)
 20418f8:	10800a17 	ldw	r2,40(r2)
 20418fc:	10c00617 	ldw	r3,24(r2)
 2041900:	e0bfff17 	ldw	r2,-4(fp)
 2041904:	10800a17 	ldw	r2,40(r2)
 2041908:	10800517 	ldw	r2,20(r2)
 204190c:	18800226 	beq	r3,r2,2041918 <lwip_netconn_do_writemore+0x36c>
 2041910:	e0bffac3 	ldbu	r2,-21(fp)
 2041914:	10000226 	beq	r2,zero,2041920 <lwip_netconn_do_writemore+0x374>
        /* return sent length (caller reads length from msg.w.offset) */
        write_finished = 1;
 2041918:	00800044 	movi	r2,1
 204191c:	e0bffa05 	stb	r2,-24(fp)
      }
      out_err = tcp_output(conn->pcb.tcp);
 2041920:	e0bfff17 	ldw	r2,-4(fp)
 2041924:	10800217 	ldw	r2,8(r2)
 2041928:	1009883a 	mov	r4,r2
 204192c:	20275b40 	call	20275b4 <tcp_output>
 2041930:	e0bffd85 	stb	r2,-10(fp)
      if (out_err == ERR_RTE) {
 2041934:	e0bffd87 	ldb	r2,-10(fp)
 2041938:	10bfff18 	cmpnei	r2,r2,-4
 204193c:	1000241e 	bne	r2,zero,20419d0 <lwip_netconn_do_writemore+0x424>
        /* If tcp_output fails because no route is found,
           don't try writing any more but return the error
           to the application thread. */
        err = out_err;
 2041940:	e0bffd83 	ldbu	r2,-10(fp)
 2041944:	e0bff905 	stb	r2,-28(fp)
        write_finished = 1;
 2041948:	00800044 	movi	r2,1
 204194c:	e0bffa05 	stb	r2,-24(fp)
 2041950:	00001f06 	br	20419d0 <lwip_netconn_do_writemore+0x424>
      }
    } else if (err == ERR_MEM) {
 2041954:	e0bff907 	ldb	r2,-28(fp)
 2041958:	10bfffd8 	cmpnei	r2,r2,-1
 204195c:	10001a1e 	bne	r2,zero,20419c8 <lwip_netconn_do_writemore+0x41c>
         For blocking sockets, we do NOT return to the application
         thread, since ERR_MEM is only a temporary error! Non-blocking
         will remain non-writable until sent_tcp/poll_tcp is called */

      /* tcp_write returned ERR_MEM, try tcp_output anyway */
      err_t out_err = tcp_output(conn->pcb.tcp);
 2041960:	e0bfff17 	ldw	r2,-4(fp)
 2041964:	10800217 	ldw	r2,8(r2)
 2041968:	1009883a 	mov	r4,r2
 204196c:	20275b40 	call	20275b4 <tcp_output>
 2041970:	e0bffdc5 	stb	r2,-9(fp)
      if (out_err == ERR_RTE) {
 2041974:	e0bffdc7 	ldb	r2,-9(fp)
 2041978:	10bfff18 	cmpnei	r2,r2,-4
 204197c:	1000051e 	bne	r2,zero,2041994 <lwip_netconn_do_writemore+0x3e8>
        /* If tcp_output fails because no route is found,
           don't try writing any more but return the error
           to the application thread. */
        err = out_err;
 2041980:	e0bffdc3 	ldbu	r2,-9(fp)
 2041984:	e0bff905 	stb	r2,-28(fp)
        write_finished = 1;
 2041988:	00800044 	movi	r2,1
 204198c:	e0bffa05 	stb	r2,-24(fp)
 2041990:	00000f06 	br	20419d0 <lwip_netconn_do_writemore+0x424>
      } else if (dontblock) {
 2041994:	e0bffac3 	ldbu	r2,-21(fp)
 2041998:	10000d26 	beq	r2,zero,20419d0 <lwip_netconn_do_writemore+0x424>
        /* non-blocking write is done on ERR_MEM, set error according
           to partial write or not */
        err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
 204199c:	e0bfff17 	ldw	r2,-4(fp)
 20419a0:	10800a17 	ldw	r2,40(r2)
 20419a4:	10800617 	ldw	r2,24(r2)
 20419a8:	1000021e 	bne	r2,zero,20419b4 <lwip_netconn_do_writemore+0x408>
 20419ac:	00bffe44 	movi	r2,-7
 20419b0:	00000106 	br	20419b8 <lwip_netconn_do_writemore+0x40c>
 20419b4:	0005883a 	mov	r2,zero
 20419b8:	e0bff905 	stb	r2,-28(fp)
        write_finished = 1;
 20419bc:	00800044 	movi	r2,1
 20419c0:	e0bffa05 	stb	r2,-24(fp)
 20419c4:	00000206 	br	20419d0 <lwip_netconn_do_writemore+0x424>
      }
    } else {
      /* On errors != ERR_MEM, we don't try writing any more but return
         the error to the application thread. */
      write_finished = 1;
 20419c8:	00800044 	movi	r2,1
 20419cc:	e0bffa05 	stb	r2,-24(fp)
    }
  }
  if (write_finished) {
 20419d0:	e0bffa03 	ldbu	r2,-24(fp)
 20419d4:	10000f26 	beq	r2,zero,2041a14 <lwip_netconn_do_writemore+0x468>
    /* everything was written: set back connection state
       and back to application task */
    sys_sem_t *op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 20419d8:	e0bfff17 	ldw	r2,-4(fp)
 20419dc:	10800a17 	ldw	r2,40(r2)
 20419e0:	10800017 	ldw	r2,0(r2)
 20419e4:	10800404 	addi	r2,r2,16
 20419e8:	e0bffe15 	stw	r2,-8(fp)
    conn->current_msg->err = err;
 20419ec:	e0bfff17 	ldw	r2,-4(fp)
 20419f0:	10800a17 	ldw	r2,40(r2)
 20419f4:	e0fff903 	ldbu	r3,-28(fp)
 20419f8:	10c00105 	stb	r3,4(r2)
    conn->current_msg = NULL;
 20419fc:	e0bfff17 	ldw	r2,-4(fp)
 2041a00:	10000a15 	stw	zero,40(r2)
    conn->state = NETCONN_NONE;
 2041a04:	e0bfff17 	ldw	r2,-4(fp)
 2041a08:	10000115 	stw	zero,4(r2)
#if LWIP_TCPIP_CORE_LOCKING
    if (delayed)
#endif
    {
      sys_sem_signal(op_completed_sem);
 2041a0c:	e13ffe17 	ldw	r4,-8(fp)
 2041a10:	20150340 	call	2015034 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else {
    return ERR_MEM;
  }
#endif
  return ERR_OK;
 2041a14:	0005883a 	mov	r2,zero
}
 2041a18:	e037883a 	mov	sp,fp
 2041a1c:	dfc00117 	ldw	ra,4(sp)
 2041a20:	df000017 	ldw	fp,0(sp)
 2041a24:	dec00204 	addi	sp,sp,8
 2041a28:	f800283a 	ret

02041a2c <lwip_netconn_do_write>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_write(void *m)
{
 2041a2c:	defffb04 	addi	sp,sp,-20
 2041a30:	dfc00415 	stw	ra,16(sp)
 2041a34:	df000315 	stw	fp,12(sp)
 2041a38:	df000304 	addi	fp,sp,12
 2041a3c:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2041a40:	e0bfff17 	ldw	r2,-4(fp)
 2041a44:	e0bffe15 	stw	r2,-8(fp)

  err_t err = netconn_err(msg->conn);
 2041a48:	e0bffe17 	ldw	r2,-8(fp)
 2041a4c:	10800017 	ldw	r2,0(r2)
 2041a50:	1009883a 	mov	r4,r2
 2041a54:	203f2800 	call	203f280 <netconn_err>
 2041a58:	e0bffd05 	stb	r2,-12(fp)
  if (err == ERR_OK) {
 2041a5c:	e0bffd07 	ldb	r2,-12(fp)
 2041a60:	1000231e 	bne	r2,zero,2041af0 <lwip_netconn_do_write+0xc4>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 2041a64:	e0bffe17 	ldw	r2,-8(fp)
 2041a68:	10800017 	ldw	r2,0(r2)
 2041a6c:	10800017 	ldw	r2,0(r2)
 2041a70:	10803c0c 	andi	r2,r2,240
 2041a74:	10800418 	cmpnei	r2,r2,16
 2041a78:	10001b1e 	bne	r2,zero,2041ae8 <lwip_netconn_do_write+0xbc>
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
 2041a7c:	e0bffe17 	ldw	r2,-8(fp)
 2041a80:	10800017 	ldw	r2,0(r2)
 2041a84:	10800117 	ldw	r2,4(r2)
 2041a88:	10000326 	beq	r2,zero,2041a98 <lwip_netconn_do_write+0x6c>
        /* netconn is connecting, closing or in blocking write */
        err = ERR_INPROGRESS;
 2041a8c:	00bffec4 	movi	r2,-5
 2041a90:	e0bffd05 	stb	r2,-12(fp)
 2041a94:	00001606 	br	2041af0 <lwip_netconn_do_write+0xc4>
      } else if (msg->conn->pcb.tcp != NULL) {
 2041a98:	e0bffe17 	ldw	r2,-8(fp)
 2041a9c:	10800017 	ldw	r2,0(r2)
 2041aa0:	10800217 	ldw	r2,8(r2)
 2041aa4:	10000d26 	beq	r2,zero,2041adc <lwip_netconn_do_write+0xb0>
        msg->conn->state = NETCONN_WRITE;
 2041aa8:	e0bffe17 	ldw	r2,-8(fp)
 2041aac:	10800017 	ldw	r2,0(r2)
 2041ab0:	00c00044 	movi	r3,1
 2041ab4:	10c00115 	stw	r3,4(r2)
        /* set all the variables used by lwip_netconn_do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
        msg->conn->current_msg = msg;
 2041ab8:	e0bffe17 	ldw	r2,-8(fp)
 2041abc:	10800017 	ldw	r2,0(r2)
 2041ac0:	e0fffe17 	ldw	r3,-8(fp)
 2041ac4:	10c00a15 	stw	r3,40(r2)
          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
          LOCK_TCPIP_CORE();
          LWIP_ASSERT("state!", msg->conn->state != NETCONN_WRITE);
        }
#else /* LWIP_TCPIP_CORE_LOCKING */
        lwip_netconn_do_writemore(msg->conn);
 2041ac8:	e0bffe17 	ldw	r2,-8(fp)
 2041acc:	10800017 	ldw	r2,0(r2)
 2041ad0:	1009883a 	mov	r4,r2
 2041ad4:	20415ac0 	call	20415ac <lwip_netconn_do_writemore>
#endif /* LWIP_TCPIP_CORE_LOCKING */
        /* for both cases: if lwip_netconn_do_writemore was called, don't ACK the APIMSG
           since lwip_netconn_do_writemore ACKs it! */
        return;
 2041ad8:	00000d06 	br	2041b10 <lwip_netconn_do_write+0xe4>
      } else {
        err = ERR_CONN;
 2041adc:	00bffd44 	movi	r2,-11
 2041ae0:	e0bffd05 	stb	r2,-12(fp)
 2041ae4:	00000206 	br	2041af0 <lwip_netconn_do_write+0xc4>
#else /* LWIP_TCP */
      err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      err = ERR_VAL;
 2041ae8:	00bffe84 	movi	r2,-6
 2041aec:	e0bffd05 	stb	r2,-12(fp)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  msg->err = err;
 2041af0:	e0bffe17 	ldw	r2,-8(fp)
 2041af4:	e0fffd03 	ldbu	r3,-12(fp)
 2041af8:	10c00105 	stb	r3,4(r2)
  TCPIP_APIMSG_ACK(msg);
 2041afc:	e0bffe17 	ldw	r2,-8(fp)
 2041b00:	10800017 	ldw	r2,0(r2)
 2041b04:	10800404 	addi	r2,r2,16
 2041b08:	1009883a 	mov	r4,r2
 2041b0c:	20150340 	call	2015034 <sys_sem_signal>
}
 2041b10:	e037883a 	mov	sp,fp
 2041b14:	dfc00117 	ldw	ra,4(sp)
 2041b18:	df000017 	ldw	fp,0(sp)
 2041b1c:	dec00204 	addi	sp,sp,8
 2041b20:	f800283a 	ret

02041b24 <lwip_netconn_do_getaddr>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_getaddr(void *m)
{
 2041b24:	defffc04 	addi	sp,sp,-16
 2041b28:	dfc00315 	stw	ra,12(sp)
 2041b2c:	df000215 	stw	fp,8(sp)
 2041b30:	df000204 	addi	fp,sp,8
 2041b34:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2041b38:	e0bfff17 	ldw	r2,-4(fp)
 2041b3c:	e0bffe15 	stw	r2,-8(fp)

  if (msg->conn->pcb.ip != NULL) {
 2041b40:	e0bffe17 	ldw	r2,-8(fp)
 2041b44:	10800017 	ldw	r2,0(r2)
 2041b48:	10800217 	ldw	r2,8(r2)
 2041b4c:	10007426 	beq	r2,zero,2041d20 <lwip_netconn_do_getaddr+0x1fc>
    if (msg->msg.ad.local) {
 2041b50:	e0bffe17 	ldw	r2,-8(fp)
 2041b54:	10800403 	ldbu	r2,16(r2)
 2041b58:	10803fcc 	andi	r2,r2,255
 2041b5c:	10000826 	beq	r2,zero,2041b80 <lwip_netconn_do_getaddr+0x5c>
      ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
 2041b60:	e0bffe17 	ldw	r2,-8(fp)
 2041b64:	10800217 	ldw	r2,8(r2)
 2041b68:	e0fffe17 	ldw	r3,-8(fp)
 2041b6c:	18c00017 	ldw	r3,0(r3)
 2041b70:	18c00217 	ldw	r3,8(r3)
 2041b74:	18c00017 	ldw	r3,0(r3)
 2041b78:	10c00015 	stw	r3,0(r2)
 2041b7c:	00000706 	br	2041b9c <lwip_netconn_do_getaddr+0x78>
                   msg->conn->pcb.ip->local_ip);
    } else {
      ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
 2041b80:	e0bffe17 	ldw	r2,-8(fp)
 2041b84:	10800217 	ldw	r2,8(r2)
 2041b88:	e0fffe17 	ldw	r3,-8(fp)
 2041b8c:	18c00017 	ldw	r3,0(r3)
 2041b90:	18c00217 	ldw	r3,8(r3)
 2041b94:	18c00117 	ldw	r3,4(r3)
 2041b98:	10c00015 	stw	r3,0(r2)
                   msg->conn->pcb.ip->remote_ip);
    }

    msg->err = ERR_OK;
 2041b9c:	e0bffe17 	ldw	r2,-8(fp)
 2041ba0:	10000105 	stb	zero,4(r2)
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 2041ba4:	e0bffe17 	ldw	r2,-8(fp)
 2041ba8:	10800017 	ldw	r2,0(r2)
 2041bac:	10800017 	ldw	r2,0(r2)
 2041bb0:	10803c0c 	andi	r2,r2,240
 2041bb4:	10c00820 	cmpeqi	r3,r2,32
 2041bb8:	1800161e 	bne	r3,zero,2041c14 <lwip_netconn_do_getaddr+0xf0>
 2041bbc:	10c01020 	cmpeqi	r3,r2,64
 2041bc0:	1800031e 	bne	r3,zero,2041bd0 <lwip_netconn_do_getaddr+0xac>
 2041bc4:	10800420 	cmpeqi	r2,r2,16
 2041bc8:	1000311e 	bne	r2,zero,2041c90 <lwip_netconn_do_getaddr+0x16c>
        }
        break;
#endif /* LWIP_TCP */
      default:
        LWIP_ASSERT("invalid netconn_type", 0);
        break;
 2041bcc:	00005706 	br	2041d2c <lwip_netconn_do_getaddr+0x208>

    msg->err = ERR_OK;
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.ad.local) {
 2041bd0:	e0bffe17 	ldw	r2,-8(fp)
 2041bd4:	10800403 	ldbu	r2,16(r2)
 2041bd8:	10803fcc 	andi	r2,r2,255
 2041bdc:	10000926 	beq	r2,zero,2041c04 <lwip_netconn_do_getaddr+0xe0>
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
 2041be0:	e0bffe17 	ldw	r2,-8(fp)
 2041be4:	10800317 	ldw	r2,12(r2)
 2041be8:	e0fffe17 	ldw	r3,-8(fp)
 2041bec:	18c00017 	ldw	r3,0(r3)
 2041bf0:	18c00217 	ldw	r3,8(r3)
 2041bf4:	18c00503 	ldbu	r3,20(r3)
 2041bf8:	18c03fcc 	andi	r3,r3,255
 2041bfc:	10c0000d 	sth	r3,0(r2)
        } else {
          /* return an error as connecting is only a helper for upper layers */
          msg->err = ERR_CONN;
        }
        break;
 2041c00:	00004a06 	br	2041d2c <lwip_netconn_do_getaddr+0x208>
      case NETCONN_RAW:
        if (msg->msg.ad.local) {
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
        } else {
          /* return an error as connecting is only a helper for upper layers */
          msg->err = ERR_CONN;
 2041c04:	e0bffe17 	ldw	r2,-8(fp)
 2041c08:	00fffd44 	movi	r3,-11
 2041c0c:	10c00105 	stb	r3,4(r2)
        }
        break;
 2041c10:	00004606 	br	2041d2c <lwip_netconn_do_getaddr+0x208>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.ad.local) {
 2041c14:	e0bffe17 	ldw	r2,-8(fp)
 2041c18:	10800403 	ldbu	r2,16(r2)
 2041c1c:	10803fcc 	andi	r2,r2,255
 2041c20:	10000826 	beq	r2,zero,2041c44 <lwip_netconn_do_getaddr+0x120>
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
 2041c24:	e0bffe17 	ldw	r2,-8(fp)
 2041c28:	10800317 	ldw	r2,12(r2)
 2041c2c:	e0fffe17 	ldw	r3,-8(fp)
 2041c30:	18c00017 	ldw	r3,0(r3)
 2041c34:	18c00217 	ldw	r3,8(r3)
 2041c38:	18c0058b 	ldhu	r3,22(r3)
 2041c3c:	10c0000d 	sth	r3,0(r2)
            msg->err = ERR_CONN;
          } else {
            API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
          }
        }
        break;
 2041c40:	00003a06 	br	2041d2c <lwip_netconn_do_getaddr+0x208>
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.ad.local) {
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
        } else {
          if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
 2041c44:	e0bffe17 	ldw	r2,-8(fp)
 2041c48:	10800017 	ldw	r2,0(r2)
 2041c4c:	10800217 	ldw	r2,8(r2)
 2041c50:	10800503 	ldbu	r2,20(r2)
 2041c54:	10803fcc 	andi	r2,r2,255
 2041c58:	1080010c 	andi	r2,r2,4
 2041c5c:	1000041e 	bne	r2,zero,2041c70 <lwip_netconn_do_getaddr+0x14c>
            msg->err = ERR_CONN;
 2041c60:	e0bffe17 	ldw	r2,-8(fp)
 2041c64:	00fffd44 	movi	r3,-11
 2041c68:	10c00105 	stb	r3,4(r2)
          } else {
            API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
          }
        }
        break;
 2041c6c:	00002f06 	br	2041d2c <lwip_netconn_do_getaddr+0x208>
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
        } else {
          if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
            msg->err = ERR_CONN;
          } else {
            API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
 2041c70:	e0bffe17 	ldw	r2,-8(fp)
 2041c74:	10800317 	ldw	r2,12(r2)
 2041c78:	e0fffe17 	ldw	r3,-8(fp)
 2041c7c:	18c00017 	ldw	r3,0(r3)
 2041c80:	18c00217 	ldw	r3,8(r3)
 2041c84:	18c0060b 	ldhu	r3,24(r3)
 2041c88:	10c0000d 	sth	r3,0(r2)
          }
        }
        break;
 2041c8c:	00002706 	br	2041d2c <lwip_netconn_do_getaddr+0x208>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        if ((msg->msg.ad.local == 0) &&
 2041c90:	e0bffe17 	ldw	r2,-8(fp)
 2041c94:	10800403 	ldbu	r2,16(r2)
 2041c98:	10803fcc 	andi	r2,r2,255
 2041c9c:	10000f1e 	bne	r2,zero,2041cdc <lwip_netconn_do_getaddr+0x1b8>
            ((msg->conn->pcb.tcp->state == CLOSED) || (msg->conn->pcb.tcp->state == LISTEN))) {
 2041ca0:	e0bffe17 	ldw	r2,-8(fp)
 2041ca4:	10800017 	ldw	r2,0(r2)
 2041ca8:	10800217 	ldw	r2,8(r2)
 2041cac:	10800617 	ldw	r2,24(r2)
        }
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        if ((msg->msg.ad.local == 0) &&
 2041cb0:	10000626 	beq	r2,zero,2041ccc <lwip_netconn_do_getaddr+0x1a8>
            ((msg->conn->pcb.tcp->state == CLOSED) || (msg->conn->pcb.tcp->state == LISTEN))) {
 2041cb4:	e0bffe17 	ldw	r2,-8(fp)
 2041cb8:	10800017 	ldw	r2,0(r2)
 2041cbc:	10800217 	ldw	r2,8(r2)
 2041cc0:	10800617 	ldw	r2,24(r2)
 2041cc4:	10800058 	cmpnei	r2,r2,1
 2041cc8:	1000041e 	bne	r2,zero,2041cdc <lwip_netconn_do_getaddr+0x1b8>
          /* pcb is not connected and remote name is requested */
          msg->err = ERR_CONN;
 2041ccc:	e0bffe17 	ldw	r2,-8(fp)
 2041cd0:	00fffd44 	movi	r3,-11
 2041cd4:	10c00105 	stb	r3,4(r2)
        } else {
          API_EXPR_DEREF(msg->msg.ad.port) = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
        }
        break;
 2041cd8:	00001406 	br	2041d2c <lwip_netconn_do_getaddr+0x208>
        if ((msg->msg.ad.local == 0) &&
            ((msg->conn->pcb.tcp->state == CLOSED) || (msg->conn->pcb.tcp->state == LISTEN))) {
          /* pcb is not connected and remote name is requested */
          msg->err = ERR_CONN;
        } else {
          API_EXPR_DEREF(msg->msg.ad.port) = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
 2041cdc:	e0bffe17 	ldw	r2,-8(fp)
 2041ce0:	10c00317 	ldw	r3,12(r2)
 2041ce4:	e0bffe17 	ldw	r2,-8(fp)
 2041ce8:	10800403 	ldbu	r2,16(r2)
 2041cec:	10803fcc 	andi	r2,r2,255
 2041cf0:	10000526 	beq	r2,zero,2041d08 <lwip_netconn_do_getaddr+0x1e4>
 2041cf4:	e0bffe17 	ldw	r2,-8(fp)
 2041cf8:	10800017 	ldw	r2,0(r2)
 2041cfc:	10800217 	ldw	r2,8(r2)
 2041d00:	1080078b 	ldhu	r2,30(r2)
 2041d04:	00000406 	br	2041d18 <lwip_netconn_do_getaddr+0x1f4>
 2041d08:	e0bffe17 	ldw	r2,-8(fp)
 2041d0c:	10800017 	ldw	r2,0(r2)
 2041d10:	10800217 	ldw	r2,8(r2)
 2041d14:	1080080b 	ldhu	r2,32(r2)
 2041d18:	1880000d 	sth	r2,0(r3)
        }
        break;
 2041d1c:	00000306 	br	2041d2c <lwip_netconn_do_getaddr+0x208>
      default:
        LWIP_ASSERT("invalid netconn_type", 0);
        break;
    }
  } else {
    msg->err = ERR_CONN;
 2041d20:	e0bffe17 	ldw	r2,-8(fp)
 2041d24:	00fffd44 	movi	r3,-11
 2041d28:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
 2041d2c:	e0bffe17 	ldw	r2,-8(fp)
 2041d30:	10800017 	ldw	r2,0(r2)
 2041d34:	10800404 	addi	r2,r2,16
 2041d38:	1009883a 	mov	r4,r2
 2041d3c:	20150340 	call	2015034 <sys_sem_signal>
}
 2041d40:	0001883a 	nop
 2041d44:	e037883a 	mov	sp,fp
 2041d48:	dfc00117 	ldw	ra,4(sp)
 2041d4c:	df000017 	ldw	fp,0(sp)
 2041d50:	dec00204 	addi	sp,sp,8
 2041d54:	f800283a 	ret

02041d58 <lwip_netconn_do_close>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_close(void *m)
{
 2041d58:	defffb04 	addi	sp,sp,-20
 2041d5c:	dfc00415 	stw	ra,16(sp)
 2041d60:	df000315 	stw	fp,12(sp)
 2041d64:	df000304 	addi	fp,sp,12
 2041d68:	e13fff15 	stw	r4,-4(fp)
  struct api_msg *msg = (struct api_msg *)m;
 2041d6c:	e0bfff17 	ldw	r2,-4(fp)
 2041d70:	e0bffd15 	stw	r2,-12(fp)

#if LWIP_TCP
  enum netconn_state state = msg->conn->state;
 2041d74:	e0bffd17 	ldw	r2,-12(fp)
 2041d78:	10800017 	ldw	r2,0(r2)
 2041d7c:	10800117 	ldw	r2,4(r2)
 2041d80:	e0bffe15 	stw	r2,-8(fp)
  /* First check if this is a TCP netconn and if it is in a correct state
      (LISTEN doesn't support half shutdown) */
  if ((msg->conn->pcb.tcp != NULL) &&
 2041d84:	e0bffd17 	ldw	r2,-12(fp)
 2041d88:	10800017 	ldw	r2,0(r2)
 2041d8c:	10800217 	ldw	r2,8(r2)
 2041d90:	10003226 	beq	r2,zero,2041e5c <lwip_netconn_do_close+0x104>
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
 2041d94:	e0bffd17 	ldw	r2,-12(fp)
 2041d98:	10800017 	ldw	r2,0(r2)
 2041d9c:	10800017 	ldw	r2,0(r2)
 2041da0:	10803c0c 	andi	r2,r2,240

#if LWIP_TCP
  enum netconn_state state = msg->conn->state;
  /* First check if this is a TCP netconn and if it is in a correct state
      (LISTEN doesn't support half shutdown) */
  if ((msg->conn->pcb.tcp != NULL) &&
 2041da4:	10800418 	cmpnei	r2,r2,16
 2041da8:	10002c1e 	bne	r2,zero,2041e5c <lwip_netconn_do_close+0x104>
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
 2041dac:	e0bffd17 	ldw	r2,-12(fp)
 2041db0:	10800203 	ldbu	r2,8(r2)
#if LWIP_TCP
  enum netconn_state state = msg->conn->state;
  /* First check if this is a TCP netconn and if it is in a correct state
      (LISTEN doesn't support half shutdown) */
  if ((msg->conn->pcb.tcp != NULL) &&
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
 2041db4:	10803fcc 	andi	r2,r2,255
 2041db8:	108000e0 	cmpeqi	r2,r2,3
 2041dbc:	1000031e 	bne	r2,zero,2041dcc <lwip_netconn_do_close+0x74>
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
 2041dc0:	e0bffe17 	ldw	r2,-8(fp)
 2041dc4:	108000a0 	cmpeqi	r2,r2,2
 2041dc8:	1000241e 	bne	r2,zero,2041e5c <lwip_netconn_do_close+0x104>
    /* Check if we are in a connected state */
    if (state == NETCONN_CONNECT) {
 2041dcc:	e0bffe17 	ldw	r2,-8(fp)
 2041dd0:	108000d8 	cmpnei	r2,r2,3
 2041dd4:	1000041e 	bne	r2,zero,2041de8 <lwip_netconn_do_close+0x90>
      /* TCP connect in progress: cannot shutdown */
      msg->err = ERR_CONN;
 2041dd8:	e0bffd17 	ldw	r2,-12(fp)
 2041ddc:	00fffd44 	movi	r3,-11
 2041de0:	10c00105 	stb	r3,4(r2)
      (LISTEN doesn't support half shutdown) */
  if ((msg->conn->pcb.tcp != NULL) &&
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
    /* Check if we are in a connected state */
    if (state == NETCONN_CONNECT) {
 2041de4:	00002006 	br	2041e68 <lwip_netconn_do_close+0x110>
      /* TCP connect in progress: cannot shutdown */
      msg->err = ERR_CONN;
    } else if (state == NETCONN_WRITE) {
 2041de8:	e0bffe17 	ldw	r2,-8(fp)
 2041dec:	10800058 	cmpnei	r2,r2,1
 2041df0:	1000041e 	bne	r2,zero,2041e04 <lwip_netconn_do_close+0xac>
        msg->err = tcp_shutdown(msg->conn->pcb.tcp, 1, 0);
      }
    }
    if (state == NETCONN_NONE) {
#else /* LWIP_NETCONN_FULLDUPLEX */
      msg->err = ERR_INPROGRESS;
 2041df4:	e0bffd17 	ldw	r2,-12(fp)
 2041df8:	00fffec4 	movi	r3,-5
 2041dfc:	10c00105 	stb	r3,4(r2)
      (LISTEN doesn't support half shutdown) */
  if ((msg->conn->pcb.tcp != NULL) &&
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
    /* Check if we are in a connected state */
    if (state == NETCONN_CONNECT) {
 2041e00:	00001906 	br	2041e68 <lwip_netconn_do_close+0x110>
    if (state == NETCONN_NONE) {
#else /* LWIP_NETCONN_FULLDUPLEX */
      msg->err = ERR_INPROGRESS;
    } else {
#endif /* LWIP_NETCONN_FULLDUPLEX */
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
 2041e04:	e0bffd17 	ldw	r2,-12(fp)
 2041e08:	10800203 	ldbu	r2,8(r2)
 2041e0c:	10803fcc 	andi	r2,r2,255
 2041e10:	1080004c 	andi	r2,r2,1
 2041e14:	10000426 	beq	r2,zero,2041e28 <lwip_netconn_do_close+0xd0>
#if LWIP_NETCONN_FULLDUPLEX
        /* Mark mboxes invalid */
        netconn_mark_mbox_invalid(msg->conn);
#else /* LWIP_NETCONN_FULLDUPLEX */
        netconn_drain(msg->conn);
 2041e18:	e0bffd17 	ldw	r2,-12(fp)
 2041e1c:	10800017 	ldw	r2,0(r2)
 2041e20:	1009883a 	mov	r4,r2
 2041e24:	20402cc0 	call	20402cc <netconn_drain>
#endif /* LWIP_NETCONN_FULLDUPLEX */
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
      msg->conn->state = NETCONN_CLOSE;
 2041e28:	e0bffd17 	ldw	r2,-12(fp)
 2041e2c:	10800017 	ldw	r2,0(r2)
 2041e30:	00c00104 	movi	r3,4
 2041e34:	10c00115 	stw	r3,4(r2)
      msg->conn->current_msg = msg;
 2041e38:	e0bffd17 	ldw	r2,-12(fp)
 2041e3c:	10800017 	ldw	r2,0(r2)
 2041e40:	e0fffd17 	ldw	r3,-12(fp)
 2041e44:	10c00a15 	stw	r3,40(r2)
        sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else /* LWIP_TCPIP_CORE_LOCKING */
      lwip_netconn_do_close_internal(msg->conn);
 2041e48:	e0bffd17 	ldw	r2,-12(fp)
 2041e4c:	10800017 	ldw	r2,0(r2)
 2041e50:	1009883a 	mov	r4,r2
 2041e54:	204043c0 	call	204043c <lwip_netconn_do_close_internal>
#endif /* LWIP_TCPIP_CORE_LOCKING */
      /* for tcp netconns, lwip_netconn_do_close_internal ACKs the message */
      return;
 2041e58:	00000806 	br	2041e7c <lwip_netconn_do_close+0x124>
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_CONN;
 2041e5c:	e0bffd17 	ldw	r2,-12(fp)
 2041e60:	00fffd44 	movi	r3,-11
 2041e64:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
 2041e68:	e0bffd17 	ldw	r2,-12(fp)
 2041e6c:	10800017 	ldw	r2,0(r2)
 2041e70:	10800404 	addi	r2,r2,16
 2041e74:	1009883a 	mov	r4,r2
 2041e78:	20150340 	call	2015034 <sys_sem_signal>
}
 2041e7c:	e037883a 	mov	sp,fp
 2041e80:	dfc00117 	ldw	ra,4(sp)
 2041e84:	df000017 	ldw	fp,0(sp)
 2041e88:	dec00204 	addi	sp,sp,8
 2041e8c:	f800283a 	ret

02041e90 <err_to_errno>:
  EIO            /* ERR_ARG        -16     Illegal argument.        */
};

int
err_to_errno(err_t err)
{
 2041e90:	defffe04 	addi	sp,sp,-8
 2041e94:	df000115 	stw	fp,4(sp)
 2041e98:	df000104 	addi	fp,sp,4
 2041e9c:	2005883a 	mov	r2,r4
 2041ea0:	e0bfff05 	stb	r2,-4(fp)
  if ((err > 0) || (-err >= (err_t)LWIP_ARRAYSIZE(err_to_errno_table))) {
 2041ea4:	e0bfff07 	ldb	r2,-4(fp)
 2041ea8:	00800416 	blt	zero,r2,2041ebc <err_to_errno+0x2c>
 2041eac:	e0bfff07 	ldb	r2,-4(fp)
 2041eb0:	0085c83a 	sub	r2,zero,r2
 2041eb4:	10800450 	cmplti	r2,r2,17
 2041eb8:	1000021e 	bne	r2,zero,2041ec4 <err_to_errno+0x34>
    return EIO;
 2041ebc:	00800144 	movi	r2,5
 2041ec0:	00000806 	br	2041ee4 <err_to_errno+0x54>
  }
  return err_to_errno_table[-err];
 2041ec4:	e0bfff07 	ldb	r2,-4(fp)
 2041ec8:	0087c83a 	sub	r3,zero,r2
 2041ecc:	00808174 	movhi	r2,517
 2041ed0:	10a32404 	addi	r2,r2,-29552
 2041ed4:	18c7883a 	add	r3,r3,r3
 2041ed8:	18c7883a 	add	r3,r3,r3
 2041edc:	10c5883a 	add	r2,r2,r3
 2041ee0:	10800017 	ldw	r2,0(r2)
}
 2041ee4:	e037883a 	mov	sp,fp
 2041ee8:	df000017 	ldw	fp,0(sp)
 2041eec:	dec00104 	addi	sp,sp,4
 2041ef0:	f800283a 	ret

02041ef4 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
 2041ef4:	defffd04 	addi	sp,sp,-12
 2041ef8:	dfc00215 	stw	ra,8(sp)
 2041efc:	df000115 	stw	fp,4(sp)
 2041f00:	df000104 	addi	fp,sp,4
  struct netbuf *buf;

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 2041f04:	010001c4 	movi	r4,7
 2041f08:	201b82c0 	call	201b82c <memp_malloc>
 2041f0c:	e0bfff15 	stw	r2,-4(fp)
  if (buf != NULL) {
 2041f10:	e0bfff17 	ldw	r2,-4(fp)
 2041f14:	10000426 	beq	r2,zero,2041f28 <netbuf_new+0x34>
    memset(buf, 0, sizeof(struct netbuf));
 2041f18:	01800504 	movi	r6,20
 2041f1c:	000b883a 	mov	r5,zero
 2041f20:	e13fff17 	ldw	r4,-4(fp)
 2041f24:	2005fa00 	call	2005fa0 <memset>
  }
  return buf;
 2041f28:	e0bfff17 	ldw	r2,-4(fp)
}
 2041f2c:	e037883a 	mov	sp,fp
 2041f30:	dfc00117 	ldw	ra,4(sp)
 2041f34:	df000017 	ldw	fp,0(sp)
 2041f38:	dec00204 	addi	sp,sp,8
 2041f3c:	f800283a 	ret

02041f40 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
 2041f40:	defffd04 	addi	sp,sp,-12
 2041f44:	dfc00215 	stw	ra,8(sp)
 2041f48:	df000115 	stw	fp,4(sp)
 2041f4c:	df000104 	addi	fp,sp,4
 2041f50:	e13fff15 	stw	r4,-4(fp)
  if (buf != NULL) {
 2041f54:	e0bfff17 	ldw	r2,-4(fp)
 2041f58:	10001026 	beq	r2,zero,2041f9c <netbuf_delete+0x5c>
    if (buf->p != NULL) {
 2041f5c:	e0bfff17 	ldw	r2,-4(fp)
 2041f60:	10800017 	ldw	r2,0(r2)
 2041f64:	10000a26 	beq	r2,zero,2041f90 <netbuf_delete+0x50>
      pbuf_free(buf->p);
 2041f68:	e0bfff17 	ldw	r2,-4(fp)
 2041f6c:	10800017 	ldw	r2,0(r2)
 2041f70:	1009883a 	mov	r4,r2
 2041f74:	201d2f40 	call	201d2f4 <pbuf_free>
      buf->p = buf->ptr = NULL;
 2041f78:	e0bfff17 	ldw	r2,-4(fp)
 2041f7c:	10000115 	stw	zero,4(r2)
 2041f80:	e0bfff17 	ldw	r2,-4(fp)
 2041f84:	10c00117 	ldw	r3,4(r2)
 2041f88:	e0bfff17 	ldw	r2,-4(fp)
 2041f8c:	10c00015 	stw	r3,0(r2)
    }
    memp_free(MEMP_NETBUF, buf);
 2041f90:	e17fff17 	ldw	r5,-4(fp)
 2041f94:	010001c4 	movi	r4,7
 2041f98:	201b9640 	call	201b964 <memp_free>
  }
}
 2041f9c:	0001883a 	nop
 2041fa0:	e037883a 	mov	sp,fp
 2041fa4:	dfc00117 	ldw	ra,4(sp)
 2041fa8:	df000017 	ldw	fp,0(sp)
 2041fac:	dec00204 	addi	sp,sp,8
 2041fb0:	f800283a 	ret

02041fb4 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
 2041fb4:	defffc04 	addi	sp,sp,-16
 2041fb8:	dfc00315 	stw	ra,12(sp)
 2041fbc:	df000215 	stw	fp,8(sp)
 2041fc0:	df000204 	addi	fp,sp,8
 2041fc4:	e13ffe15 	stw	r4,-8(fp)
 2041fc8:	2805883a 	mov	r2,r5
 2041fcc:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
 2041fd0:	e0bffe17 	ldw	r2,-8(fp)
 2041fd4:	1000021e 	bne	r2,zero,2041fe0 <netbuf_alloc+0x2c>
 2041fd8:	0005883a 	mov	r2,zero
 2041fdc:	00001b06 	br	204204c <netbuf_alloc+0x98>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
 2041fe0:	e0bffe17 	ldw	r2,-8(fp)
 2041fe4:	10800017 	ldw	r2,0(r2)
 2041fe8:	10000426 	beq	r2,zero,2041ffc <netbuf_alloc+0x48>
    pbuf_free(buf->p);
 2041fec:	e0bffe17 	ldw	r2,-8(fp)
 2041ff0:	10800017 	ldw	r2,0(r2)
 2041ff4:	1009883a 	mov	r4,r2
 2041ff8:	201d2f40 	call	201d2f4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
 2041ffc:	e0bfff0b 	ldhu	r2,-4(fp)
 2042000:	0180a004 	movi	r6,640
 2042004:	100b883a 	mov	r5,r2
 2042008:	01000e04 	movi	r4,56
 204200c:	201c9740 	call	201c974 <pbuf_alloc>
 2042010:	1007883a 	mov	r3,r2
 2042014:	e0bffe17 	ldw	r2,-8(fp)
 2042018:	10c00015 	stw	r3,0(r2)
  if (buf->p == NULL) {
 204201c:	e0bffe17 	ldw	r2,-8(fp)
 2042020:	10800017 	ldw	r2,0(r2)
 2042024:	1000021e 	bne	r2,zero,2042030 <netbuf_alloc+0x7c>
    return NULL;
 2042028:	0005883a 	mov	r2,zero
 204202c:	00000706 	br	204204c <netbuf_alloc+0x98>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
              (buf->p->len >= size));
  buf->ptr = buf->p;
 2042030:	e0bffe17 	ldw	r2,-8(fp)
 2042034:	10c00017 	ldw	r3,0(r2)
 2042038:	e0bffe17 	ldw	r2,-8(fp)
 204203c:	10c00115 	stw	r3,4(r2)
  return buf->p->payload;
 2042040:	e0bffe17 	ldw	r2,-8(fp)
 2042044:	10800017 	ldw	r2,0(r2)
 2042048:	10800117 	ldw	r2,4(r2)
}
 204204c:	e037883a 	mov	sp,fp
 2042050:	dfc00117 	ldw	ra,4(sp)
 2042054:	df000017 	ldw	fp,0(sp)
 2042058:	dec00204 	addi	sp,sp,8
 204205c:	f800283a 	ret

02042060 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
 2042060:	defffd04 	addi	sp,sp,-12
 2042064:	dfc00215 	stw	ra,8(sp)
 2042068:	df000115 	stw	fp,4(sp)
 204206c:	df000104 	addi	fp,sp,4
 2042070:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 2042074:	e0bfff17 	ldw	r2,-4(fp)
 2042078:	10001226 	beq	r2,zero,20420c4 <netbuf_free+0x64>
  if (buf->p != NULL) {
 204207c:	e0bfff17 	ldw	r2,-4(fp)
 2042080:	10800017 	ldw	r2,0(r2)
 2042084:	10000426 	beq	r2,zero,2042098 <netbuf_free+0x38>
    pbuf_free(buf->p);
 2042088:	e0bfff17 	ldw	r2,-4(fp)
 204208c:	10800017 	ldw	r2,0(r2)
 2042090:	1009883a 	mov	r4,r2
 2042094:	201d2f40 	call	201d2f4 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
 2042098:	e0bfff17 	ldw	r2,-4(fp)
 204209c:	10000115 	stw	zero,4(r2)
 20420a0:	e0bfff17 	ldw	r2,-4(fp)
 20420a4:	10c00117 	ldw	r3,4(r2)
 20420a8:	e0bfff17 	ldw	r2,-4(fp)
 20420ac:	10c00015 	stw	r3,0(r2)
#if LWIP_CHECKSUM_ON_COPY
  buf->flags = 0;
 20420b0:	e0bfff17 	ldw	r2,-4(fp)
 20420b4:	10000385 	stb	zero,14(r2)
  buf->toport_chksum = 0;
 20420b8:	e0bfff17 	ldw	r2,-4(fp)
 20420bc:	1000040d 	sth	zero,16(r2)
 20420c0:	00000106 	br	20420c8 <netbuf_free+0x68>
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 20420c4:	0001883a 	nop
  buf->p = buf->ptr = NULL;
#if LWIP_CHECKSUM_ON_COPY
  buf->flags = 0;
  buf->toport_chksum = 0;
#endif /* LWIP_CHECKSUM_ON_COPY */
}
 20420c8:	e037883a 	mov	sp,fp
 20420cc:	dfc00117 	ldw	ra,4(sp)
 20420d0:	df000017 	ldw	fp,0(sp)
 20420d4:	dec00204 	addi	sp,sp,8
 20420d8:	f800283a 	ret

020420dc <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
 20420dc:	defffb04 	addi	sp,sp,-20
 20420e0:	dfc00415 	stw	ra,16(sp)
 20420e4:	df000315 	stw	fp,12(sp)
 20420e8:	df000304 	addi	fp,sp,12
 20420ec:	e13ffd15 	stw	r4,-12(fp)
 20420f0:	e17ffe15 	stw	r5,-8(fp)
 20420f4:	3005883a 	mov	r2,r6
 20420f8:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
 20420fc:	e0bffd17 	ldw	r2,-12(fp)
 2042100:	1000021e 	bne	r2,zero,204210c <netbuf_ref+0x30>
 2042104:	00bffc04 	movi	r2,-16
 2042108:	00002606 	br	20421a4 <netbuf_ref+0xc8>
  if (buf->p != NULL) {
 204210c:	e0bffd17 	ldw	r2,-12(fp)
 2042110:	10800017 	ldw	r2,0(r2)
 2042114:	10000426 	beq	r2,zero,2042128 <netbuf_ref+0x4c>
    pbuf_free(buf->p);
 2042118:	e0bffd17 	ldw	r2,-12(fp)
 204211c:	10800017 	ldw	r2,0(r2)
 2042120:	1009883a 	mov	r4,r2
 2042124:	201d2f40 	call	201d2f4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
 2042128:	01801044 	movi	r6,65
 204212c:	000b883a 	mov	r5,zero
 2042130:	01000e04 	movi	r4,56
 2042134:	201c9740 	call	201c974 <pbuf_alloc>
 2042138:	1007883a 	mov	r3,r2
 204213c:	e0bffd17 	ldw	r2,-12(fp)
 2042140:	10c00015 	stw	r3,0(r2)
  if (buf->p == NULL) {
 2042144:	e0bffd17 	ldw	r2,-12(fp)
 2042148:	10800017 	ldw	r2,0(r2)
 204214c:	1000041e 	bne	r2,zero,2042160 <netbuf_ref+0x84>
    buf->ptr = NULL;
 2042150:	e0bffd17 	ldw	r2,-12(fp)
 2042154:	10000115 	stw	zero,4(r2)
    return ERR_MEM;
 2042158:	00bfffc4 	movi	r2,-1
 204215c:	00001106 	br	20421a4 <netbuf_ref+0xc8>
  }
  ((struct pbuf_rom *)buf->p)->payload = dataptr;
 2042160:	e0bffd17 	ldw	r2,-12(fp)
 2042164:	10800017 	ldw	r2,0(r2)
 2042168:	e0fffe17 	ldw	r3,-8(fp)
 204216c:	10c00115 	stw	r3,4(r2)
  buf->p->len = buf->p->tot_len = size;
 2042170:	e0bffd17 	ldw	r2,-12(fp)
 2042174:	10c00017 	ldw	r3,0(r2)
 2042178:	e0bffd17 	ldw	r2,-12(fp)
 204217c:	10800017 	ldw	r2,0(r2)
 2042180:	e13fff0b 	ldhu	r4,-4(fp)
 2042184:	1100020d 	sth	r4,8(r2)
 2042188:	1080020b 	ldhu	r2,8(r2)
 204218c:	1880028d 	sth	r2,10(r3)
  buf->ptr = buf->p;
 2042190:	e0bffd17 	ldw	r2,-12(fp)
 2042194:	10c00017 	ldw	r3,0(r2)
 2042198:	e0bffd17 	ldw	r2,-12(fp)
 204219c:	10c00115 	stw	r3,4(r2)
  return ERR_OK;
 20421a0:	0005883a 	mov	r2,zero
}
 20421a4:	e037883a 	mov	sp,fp
 20421a8:	dfc00117 	ldw	ra,4(sp)
 20421ac:	df000017 	ldw	fp,0(sp)
 20421b0:	dec00204 	addi	sp,sp,8
 20421b4:	f800283a 	ret

020421b8 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
 20421b8:	defffc04 	addi	sp,sp,-16
 20421bc:	dfc00315 	stw	ra,12(sp)
 20421c0:	df000215 	stw	fp,8(sp)
 20421c4:	df000204 	addi	fp,sp,8
 20421c8:	e13ffe15 	stw	r4,-8(fp)
 20421cc:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netbuf_chain: invalid head", (head != NULL), return;);
 20421d0:	e0bffe17 	ldw	r2,-8(fp)
 20421d4:	10001126 	beq	r2,zero,204221c <netbuf_chain+0x64>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
 20421d8:	e0bfff17 	ldw	r2,-4(fp)
 20421dc:	10001126 	beq	r2,zero,2042224 <netbuf_chain+0x6c>
  pbuf_cat(head->p, tail->p);
 20421e0:	e0bffe17 	ldw	r2,-8(fp)
 20421e4:	10c00017 	ldw	r3,0(r2)
 20421e8:	e0bfff17 	ldw	r2,-4(fp)
 20421ec:	10800017 	ldw	r2,0(r2)
 20421f0:	100b883a 	mov	r5,r2
 20421f4:	1809883a 	mov	r4,r3
 20421f8:	201d4d40 	call	201d4d4 <pbuf_cat>
  head->ptr = head->p;
 20421fc:	e0bffe17 	ldw	r2,-8(fp)
 2042200:	10c00017 	ldw	r3,0(r2)
 2042204:	e0bffe17 	ldw	r2,-8(fp)
 2042208:	10c00115 	stw	r3,4(r2)
  memp_free(MEMP_NETBUF, tail);
 204220c:	e17fff17 	ldw	r5,-4(fp)
 2042210:	010001c4 	movi	r4,7
 2042214:	201b9640 	call	201b964 <memp_free>
 2042218:	00000306 	br	2042228 <netbuf_chain+0x70>
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  LWIP_ERROR("netbuf_chain: invalid head", (head != NULL), return;);
 204221c:	0001883a 	nop
 2042220:	00000106 	br	2042228 <netbuf_chain+0x70>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
 2042224:	0001883a 	nop
  pbuf_cat(head->p, tail->p);
  head->ptr = head->p;
  memp_free(MEMP_NETBUF, tail);
}
 2042228:	e037883a 	mov	sp,fp
 204222c:	dfc00117 	ldw	ra,4(sp)
 2042230:	df000017 	ldw	fp,0(sp)
 2042234:	dec00204 	addi	sp,sp,8
 2042238:	f800283a 	ret

0204223c <netbuf_data>:
 * @return ERR_OK if the information was retrieved,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
 204223c:	defffc04 	addi	sp,sp,-16
 2042240:	df000315 	stw	fp,12(sp)
 2042244:	df000304 	addi	fp,sp,12
 2042248:	e13ffd15 	stw	r4,-12(fp)
 204224c:	e17ffe15 	stw	r5,-8(fp)
 2042250:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 2042254:	e0bffd17 	ldw	r2,-12(fp)
 2042258:	1000021e 	bne	r2,zero,2042264 <netbuf_data+0x28>
 204225c:	00bffc04 	movi	r2,-16
 2042260:	00001806 	br	20422c4 <netbuf_data+0x88>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 2042264:	e0bffe17 	ldw	r2,-8(fp)
 2042268:	1000021e 	bne	r2,zero,2042274 <netbuf_data+0x38>
 204226c:	00bffc04 	movi	r2,-16
 2042270:	00001406 	br	20422c4 <netbuf_data+0x88>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 2042274:	e0bfff17 	ldw	r2,-4(fp)
 2042278:	1000021e 	bne	r2,zero,2042284 <netbuf_data+0x48>
 204227c:	00bffc04 	movi	r2,-16
 2042280:	00001006 	br	20422c4 <netbuf_data+0x88>

  if (buf->ptr == NULL) {
 2042284:	e0bffd17 	ldw	r2,-12(fp)
 2042288:	10800117 	ldw	r2,4(r2)
 204228c:	1000021e 	bne	r2,zero,2042298 <netbuf_data+0x5c>
    return ERR_BUF;
 2042290:	00bfff84 	movi	r2,-2
 2042294:	00000b06 	br	20422c4 <netbuf_data+0x88>
  }
  *dataptr = buf->ptr->payload;
 2042298:	e0bffd17 	ldw	r2,-12(fp)
 204229c:	10800117 	ldw	r2,4(r2)
 20422a0:	10c00117 	ldw	r3,4(r2)
 20422a4:	e0bffe17 	ldw	r2,-8(fp)
 20422a8:	10c00015 	stw	r3,0(r2)
  *len = buf->ptr->len;
 20422ac:	e0bffd17 	ldw	r2,-12(fp)
 20422b0:	10800117 	ldw	r2,4(r2)
 20422b4:	10c0028b 	ldhu	r3,10(r2)
 20422b8:	e0bfff17 	ldw	r2,-4(fp)
 20422bc:	10c0000d 	sth	r3,0(r2)
  return ERR_OK;
 20422c0:	0005883a 	mov	r2,zero
}
 20422c4:	e037883a 	mov	sp,fp
 20422c8:	df000017 	ldw	fp,0(sp)
 20422cc:	dec00104 	addi	sp,sp,4
 20422d0:	f800283a 	ret

020422d4 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
 20422d4:	defffe04 	addi	sp,sp,-8
 20422d8:	df000115 	stw	fp,4(sp)
 20422dc:	df000104 	addi	fp,sp,4
 20422e0:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_next: invalid buf", (buf != NULL), return -1;);
 20422e4:	e0bfff17 	ldw	r2,-4(fp)
 20422e8:	1000021e 	bne	r2,zero,20422f4 <netbuf_next+0x20>
 20422ec:	00bfffc4 	movi	r2,-1
 20422f0:	00001206 	br	204233c <netbuf_next+0x68>
  if (buf->ptr->next == NULL) {
 20422f4:	e0bfff17 	ldw	r2,-4(fp)
 20422f8:	10800117 	ldw	r2,4(r2)
 20422fc:	10800017 	ldw	r2,0(r2)
 2042300:	1000021e 	bne	r2,zero,204230c <netbuf_next+0x38>
    return -1;
 2042304:	00bfffc4 	movi	r2,-1
 2042308:	00000c06 	br	204233c <netbuf_next+0x68>
  }
  buf->ptr = buf->ptr->next;
 204230c:	e0bfff17 	ldw	r2,-4(fp)
 2042310:	10800117 	ldw	r2,4(r2)
 2042314:	10c00017 	ldw	r3,0(r2)
 2042318:	e0bfff17 	ldw	r2,-4(fp)
 204231c:	10c00115 	stw	r3,4(r2)
  if (buf->ptr->next == NULL) {
 2042320:	e0bfff17 	ldw	r2,-4(fp)
 2042324:	10800117 	ldw	r2,4(r2)
 2042328:	10800017 	ldw	r2,0(r2)
 204232c:	1000021e 	bne	r2,zero,2042338 <netbuf_next+0x64>
    return 1;
 2042330:	00800044 	movi	r2,1
 2042334:	00000106 	br	204233c <netbuf_next+0x68>
  }
  return 0;
 2042338:	0005883a 	mov	r2,zero
}
 204233c:	e037883a 	mov	sp,fp
 2042340:	df000017 	ldw	fp,0(sp)
 2042344:	dec00104 	addi	sp,sp,4
 2042348:	f800283a 	ret

0204234c <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
 204234c:	defffe04 	addi	sp,sp,-8
 2042350:	df000115 	stw	fp,4(sp)
 2042354:	df000104 	addi	fp,sp,4
 2042358:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_first: invalid buf", (buf != NULL), return;);
 204235c:	e0bfff17 	ldw	r2,-4(fp)
 2042360:	10000526 	beq	r2,zero,2042378 <netbuf_first+0x2c>
  buf->ptr = buf->p;
 2042364:	e0bfff17 	ldw	r2,-4(fp)
 2042368:	10c00017 	ldw	r3,0(r2)
 204236c:	e0bfff17 	ldw	r2,-4(fp)
 2042370:	10c00115 	stw	r3,4(r2)
 2042374:	00000106 	br	204237c <netbuf_first+0x30>
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_first: invalid buf", (buf != NULL), return;);
 2042378:	0001883a 	nop
  buf->ptr = buf->p;
}
 204237c:	e037883a 	mov	sp,fp
 2042380:	df000017 	ldw	fp,0(sp)
 2042384:	dec00104 	addi	sp,sp,4
 2042388:	f800283a 	ret

0204238c <atexit>:
 204238c:	200b883a 	mov	r5,r4
 2042390:	000f883a 	mov	r7,zero
 2042394:	000d883a 	mov	r6,zero
 2042398:	0009883a 	mov	r4,zero
 204239c:	2044e281 	jmpi	2044e28 <__register_exitproc>

020423a0 <atoi>:
 20423a0:	01800284 	movi	r6,10
 20423a4:	000b883a 	mov	r5,zero
 20423a8:	2042c341 	jmpi	2042c34 <strtol>

020423ac <_atoi_r>:
 20423ac:	01c00284 	movi	r7,10
 20423b0:	000d883a 	mov	r6,zero
 20423b4:	20429fc1 	jmpi	20429fc <_strtol_r>

020423b8 <__errno>:
 20423b8:	00808174 	movhi	r2,517
 20423bc:	10ab4004 	addi	r2,r2,-21248
 20423c0:	10800017 	ldw	r2,0(r2)
 20423c4:	f800283a 	ret

020423c8 <exit>:
 20423c8:	defffe04 	addi	sp,sp,-8
 20423cc:	000b883a 	mov	r5,zero
 20423d0:	dc000015 	stw	r16,0(sp)
 20423d4:	dfc00115 	stw	ra,4(sp)
 20423d8:	2021883a 	mov	r16,r4
 20423dc:	2044f400 	call	2044f40 <__call_exitprocs>
 20423e0:	00808174 	movhi	r2,517
 20423e4:	10ab3f04 	addi	r2,r2,-21252
 20423e8:	11000017 	ldw	r4,0(r2)
 20423ec:	20800f17 	ldw	r2,60(r4)
 20423f0:	10000126 	beq	r2,zero,20423f8 <exit+0x30>
 20423f4:	103ee83a 	callr	r2
 20423f8:	8009883a 	mov	r4,r16
 20423fc:	20464cc0 	call	20464cc <_exit>

02042400 <malloc>:
 2042400:	00808174 	movhi	r2,517
 2042404:	10ab4004 	addi	r2,r2,-21248
 2042408:	200b883a 	mov	r5,r4
 204240c:	11000017 	ldw	r4,0(r2)
 2042410:	20055681 	jmpi	2005568 <_malloc_r>

02042414 <free>:
 2042414:	00808174 	movhi	r2,517
 2042418:	10ab4004 	addi	r2,r2,-21248
 204241c:	200b883a 	mov	r5,r4
 2042420:	11000017 	ldw	r4,0(r2)
 2042424:	2004e381 	jmpi	2004e38 <_free_r>

02042428 <memcmp>:
 2042428:	01c000c4 	movi	r7,3
 204242c:	3980192e 	bgeu	r7,r6,2042494 <memcmp+0x6c>
 2042430:	2144b03a 	or	r2,r4,r5
 2042434:	11c4703a 	and	r2,r2,r7
 2042438:	10000f26 	beq	r2,zero,2042478 <memcmp+0x50>
 204243c:	20800003 	ldbu	r2,0(r4)
 2042440:	28c00003 	ldbu	r3,0(r5)
 2042444:	10c0151e 	bne	r2,r3,204249c <memcmp+0x74>
 2042448:	31bfff84 	addi	r6,r6,-2
 204244c:	01ffffc4 	movi	r7,-1
 2042450:	00000406 	br	2042464 <memcmp+0x3c>
 2042454:	20800003 	ldbu	r2,0(r4)
 2042458:	28c00003 	ldbu	r3,0(r5)
 204245c:	31bfffc4 	addi	r6,r6,-1
 2042460:	10c00e1e 	bne	r2,r3,204249c <memcmp+0x74>
 2042464:	21000044 	addi	r4,r4,1
 2042468:	29400044 	addi	r5,r5,1
 204246c:	31fff91e 	bne	r6,r7,2042454 <__alt_mem_mem_0+0xfd022454>
 2042470:	0005883a 	mov	r2,zero
 2042474:	f800283a 	ret
 2042478:	20c00017 	ldw	r3,0(r4)
 204247c:	28800017 	ldw	r2,0(r5)
 2042480:	18bfee1e 	bne	r3,r2,204243c <__alt_mem_mem_0+0xfd02243c>
 2042484:	31bfff04 	addi	r6,r6,-4
 2042488:	21000104 	addi	r4,r4,4
 204248c:	29400104 	addi	r5,r5,4
 2042490:	39bff936 	bltu	r7,r6,2042478 <__alt_mem_mem_0+0xfd022478>
 2042494:	303fe91e 	bne	r6,zero,204243c <__alt_mem_mem_0+0xfd02243c>
 2042498:	003ff506 	br	2042470 <__alt_mem_mem_0+0xfd022470>
 204249c:	10c5c83a 	sub	r2,r2,r3
 20424a0:	f800283a 	ret

020424a4 <_putc_r>:
 20424a4:	defffc04 	addi	sp,sp,-16
 20424a8:	dc000215 	stw	r16,8(sp)
 20424ac:	dfc00315 	stw	ra,12(sp)
 20424b0:	2021883a 	mov	r16,r4
 20424b4:	20000226 	beq	r4,zero,20424c0 <_putc_r+0x1c>
 20424b8:	20800e17 	ldw	r2,56(r4)
 20424bc:	10001b26 	beq	r2,zero,204252c <_putc_r+0x88>
 20424c0:	30800217 	ldw	r2,8(r6)
 20424c4:	10bfffc4 	addi	r2,r2,-1
 20424c8:	30800215 	stw	r2,8(r6)
 20424cc:	10000a16 	blt	r2,zero,20424f8 <_putc_r+0x54>
 20424d0:	30800017 	ldw	r2,0(r6)
 20424d4:	11400005 	stb	r5,0(r2)
 20424d8:	30800017 	ldw	r2,0(r6)
 20424dc:	10c00044 	addi	r3,r2,1
 20424e0:	30c00015 	stw	r3,0(r6)
 20424e4:	10800003 	ldbu	r2,0(r2)
 20424e8:	dfc00317 	ldw	ra,12(sp)
 20424ec:	dc000217 	ldw	r16,8(sp)
 20424f0:	dec00404 	addi	sp,sp,16
 20424f4:	f800283a 	ret
 20424f8:	30c00617 	ldw	r3,24(r6)
 20424fc:	10c00616 	blt	r2,r3,2042518 <_putc_r+0x74>
 2042500:	30800017 	ldw	r2,0(r6)
 2042504:	00c00284 	movi	r3,10
 2042508:	11400005 	stb	r5,0(r2)
 204250c:	30800017 	ldw	r2,0(r6)
 2042510:	11400003 	ldbu	r5,0(r2)
 2042514:	28fff11e 	bne	r5,r3,20424dc <__alt_mem_mem_0+0xfd0224dc>
 2042518:	8009883a 	mov	r4,r16
 204251c:	dfc00317 	ldw	ra,12(sp)
 2042520:	dc000217 	ldw	r16,8(sp)
 2042524:	dec00404 	addi	sp,sp,16
 2042528:	2009bf41 	jmpi	2009bf4 <__swbuf_r>
 204252c:	d9400015 	stw	r5,0(sp)
 2042530:	d9800115 	stw	r6,4(sp)
 2042534:	2004cc40 	call	2004cc4 <__sinit>
 2042538:	d9800117 	ldw	r6,4(sp)
 204253c:	d9400017 	ldw	r5,0(sp)
 2042540:	003fdf06 	br	20424c0 <__alt_mem_mem_0+0xfd0224c0>

02042544 <putc>:
 2042544:	00808174 	movhi	r2,517
 2042548:	defffc04 	addi	sp,sp,-16
 204254c:	10ab4004 	addi	r2,r2,-21248
 2042550:	dc000115 	stw	r16,4(sp)
 2042554:	14000017 	ldw	r16,0(r2)
 2042558:	dc400215 	stw	r17,8(sp)
 204255c:	dfc00315 	stw	ra,12(sp)
 2042560:	2023883a 	mov	r17,r4
 2042564:	80000226 	beq	r16,zero,2042570 <putc+0x2c>
 2042568:	80800e17 	ldw	r2,56(r16)
 204256c:	10001a26 	beq	r2,zero,20425d8 <putc+0x94>
 2042570:	28800217 	ldw	r2,8(r5)
 2042574:	10bfffc4 	addi	r2,r2,-1
 2042578:	28800215 	stw	r2,8(r5)
 204257c:	10000b16 	blt	r2,zero,20425ac <putc+0x68>
 2042580:	28800017 	ldw	r2,0(r5)
 2042584:	14400005 	stb	r17,0(r2)
 2042588:	28800017 	ldw	r2,0(r5)
 204258c:	10c00044 	addi	r3,r2,1
 2042590:	28c00015 	stw	r3,0(r5)
 2042594:	10800003 	ldbu	r2,0(r2)
 2042598:	dfc00317 	ldw	ra,12(sp)
 204259c:	dc400217 	ldw	r17,8(sp)
 20425a0:	dc000117 	ldw	r16,4(sp)
 20425a4:	dec00404 	addi	sp,sp,16
 20425a8:	f800283a 	ret
 20425ac:	28c00617 	ldw	r3,24(r5)
 20425b0:	10c00e16 	blt	r2,r3,20425ec <putc+0xa8>
 20425b4:	28800017 	ldw	r2,0(r5)
 20425b8:	01000284 	movi	r4,10
 20425bc:	14400005 	stb	r17,0(r2)
 20425c0:	28800017 	ldw	r2,0(r5)
 20425c4:	10c00003 	ldbu	r3,0(r2)
 20425c8:	193ff01e 	bne	r3,r4,204258c <__alt_mem_mem_0+0xfd02258c>
 20425cc:	280d883a 	mov	r6,r5
 20425d0:	180b883a 	mov	r5,r3
 20425d4:	00000706 	br	20425f4 <putc+0xb0>
 20425d8:	8009883a 	mov	r4,r16
 20425dc:	d9400015 	stw	r5,0(sp)
 20425e0:	2004cc40 	call	2004cc4 <__sinit>
 20425e4:	d9400017 	ldw	r5,0(sp)
 20425e8:	003fe106 	br	2042570 <__alt_mem_mem_0+0xfd022570>
 20425ec:	280d883a 	mov	r6,r5
 20425f0:	880b883a 	mov	r5,r17
 20425f4:	8009883a 	mov	r4,r16
 20425f8:	dfc00317 	ldw	ra,12(sp)
 20425fc:	dc400217 	ldw	r17,8(sp)
 2042600:	dc000117 	ldw	r16,4(sp)
 2042604:	dec00404 	addi	sp,sp,16
 2042608:	2009bf41 	jmpi	2009bf4 <__swbuf_r>

0204260c <_puts_r>:
 204260c:	defff604 	addi	sp,sp,-40
 2042610:	dc000715 	stw	r16,28(sp)
 2042614:	2021883a 	mov	r16,r4
 2042618:	2809883a 	mov	r4,r5
 204261c:	dc400815 	stw	r17,32(sp)
 2042620:	dfc00915 	stw	ra,36(sp)
 2042624:	2823883a 	mov	r17,r5
 2042628:	20073a40 	call	20073a4 <strlen>
 204262c:	10c00044 	addi	r3,r2,1
 2042630:	d8800115 	stw	r2,4(sp)
 2042634:	00808174 	movhi	r2,517
 2042638:	10a3d604 	addi	r2,r2,-28840
 204263c:	d8800215 	stw	r2,8(sp)
 2042640:	00800044 	movi	r2,1
 2042644:	d8800315 	stw	r2,12(sp)
 2042648:	00800084 	movi	r2,2
 204264c:	dc400015 	stw	r17,0(sp)
 2042650:	d8c00615 	stw	r3,24(sp)
 2042654:	dec00415 	stw	sp,16(sp)
 2042658:	d8800515 	stw	r2,20(sp)
 204265c:	80000226 	beq	r16,zero,2042668 <_puts_r+0x5c>
 2042660:	80800e17 	ldw	r2,56(r16)
 2042664:	10001426 	beq	r2,zero,20426b8 <_puts_r+0xac>
 2042668:	81400217 	ldw	r5,8(r16)
 204266c:	2880030b 	ldhu	r2,12(r5)
 2042670:	10c8000c 	andi	r3,r2,8192
 2042674:	1800061e 	bne	r3,zero,2042690 <_puts_r+0x84>
 2042678:	29001917 	ldw	r4,100(r5)
 204267c:	00f7ffc4 	movi	r3,-8193
 2042680:	10880014 	ori	r2,r2,8192
 2042684:	20c6703a 	and	r3,r4,r3
 2042688:	2880030d 	sth	r2,12(r5)
 204268c:	28c01915 	stw	r3,100(r5)
 2042690:	d9800404 	addi	r6,sp,16
 2042694:	8009883a 	mov	r4,r16
 2042698:	2008f640 	call	2008f64 <__sfvwrite_r>
 204269c:	1000091e 	bne	r2,zero,20426c4 <_puts_r+0xb8>
 20426a0:	00800284 	movi	r2,10
 20426a4:	dfc00917 	ldw	ra,36(sp)
 20426a8:	dc400817 	ldw	r17,32(sp)
 20426ac:	dc000717 	ldw	r16,28(sp)
 20426b0:	dec00a04 	addi	sp,sp,40
 20426b4:	f800283a 	ret
 20426b8:	8009883a 	mov	r4,r16
 20426bc:	2004cc40 	call	2004cc4 <__sinit>
 20426c0:	003fe906 	br	2042668 <__alt_mem_mem_0+0xfd022668>
 20426c4:	00bfffc4 	movi	r2,-1
 20426c8:	003ff606 	br	20426a4 <__alt_mem_mem_0+0xfd0226a4>

020426cc <puts>:
 20426cc:	00808174 	movhi	r2,517
 20426d0:	10ab4004 	addi	r2,r2,-21248
 20426d4:	200b883a 	mov	r5,r4
 20426d8:	11000017 	ldw	r4,0(r2)
 20426dc:	204260c1 	jmpi	204260c <_puts_r>

020426e0 <_snprintf_r>:
 20426e0:	30003116 	blt	r6,zero,20427a8 <_snprintf_r+0xc8>
 20426e4:	deffe404 	addi	sp,sp,-112
 20426e8:	00c08204 	movi	r3,520
 20426ec:	dc001a15 	stw	r16,104(sp)
 20426f0:	3005883a 	mov	r2,r6
 20426f4:	dfc01b15 	stw	ra,108(sp)
 20426f8:	d8c0030d 	sth	r3,12(sp)
 20426fc:	d9400015 	stw	r5,0(sp)
 2042700:	d9400415 	stw	r5,16(sp)
 2042704:	380d883a 	mov	r6,r7
 2042708:	2021883a 	mov	r16,r4
 204270c:	10001026 	beq	r2,zero,2042750 <_snprintf_r+0x70>
 2042710:	10bfffc4 	addi	r2,r2,-1
 2042714:	d8800215 	stw	r2,8(sp)
 2042718:	d8800515 	stw	r2,20(sp)
 204271c:	d9c01c04 	addi	r7,sp,112
 2042720:	00bfffc4 	movi	r2,-1
 2042724:	d80b883a 	mov	r5,sp
 2042728:	d880038d 	sth	r2,14(sp)
 204272c:	2042c500 	call	2042c50 <___svfprintf_internal_r>
 2042730:	00ffffc4 	movi	r3,-1
 2042734:	10c01316 	blt	r2,r3,2042784 <_snprintf_r+0xa4>
 2042738:	d8c00017 	ldw	r3,0(sp)
 204273c:	18000005 	stb	zero,0(r3)
 2042740:	dfc01b17 	ldw	ra,108(sp)
 2042744:	dc001a17 	ldw	r16,104(sp)
 2042748:	dec01c04 	addi	sp,sp,112
 204274c:	f800283a 	ret
 2042750:	00bfffc4 	movi	r2,-1
 2042754:	d9c01c04 	addi	r7,sp,112
 2042758:	d80b883a 	mov	r5,sp
 204275c:	d8000215 	stw	zero,8(sp)
 2042760:	d8000515 	stw	zero,20(sp)
 2042764:	d880038d 	sth	r2,14(sp)
 2042768:	2042c500 	call	2042c50 <___svfprintf_internal_r>
 204276c:	00ffffc4 	movi	r3,-1
 2042770:	10c00716 	blt	r2,r3,2042790 <_snprintf_r+0xb0>
 2042774:	dfc01b17 	ldw	ra,108(sp)
 2042778:	dc001a17 	ldw	r16,104(sp)
 204277c:	dec01c04 	addi	sp,sp,112
 2042780:	f800283a 	ret
 2042784:	00c022c4 	movi	r3,139
 2042788:	80c00015 	stw	r3,0(r16)
 204278c:	003fea06 	br	2042738 <__alt_mem_mem_0+0xfd022738>
 2042790:	00c022c4 	movi	r3,139
 2042794:	80c00015 	stw	r3,0(r16)
 2042798:	dfc01b17 	ldw	ra,108(sp)
 204279c:	dc001a17 	ldw	r16,104(sp)
 20427a0:	dec01c04 	addi	sp,sp,112
 20427a4:	f800283a 	ret
 20427a8:	008022c4 	movi	r2,139
 20427ac:	20800015 	stw	r2,0(r4)
 20427b0:	00bfffc4 	movi	r2,-1
 20427b4:	f800283a 	ret

020427b8 <snprintf>:
 20427b8:	deffe304 	addi	sp,sp,-116
 20427bc:	dfc01b15 	stw	ra,108(sp)
 20427c0:	dc001a15 	stw	r16,104(sp)
 20427c4:	d9c01c15 	stw	r7,112(sp)
 20427c8:	00808174 	movhi	r2,517
 20427cc:	10ab4004 	addi	r2,r2,-21248
 20427d0:	14000017 	ldw	r16,0(r2)
 20427d4:	28002d16 	blt	r5,zero,204288c <snprintf+0xd4>
 20427d8:	00808204 	movi	r2,520
 20427dc:	d880030d 	sth	r2,12(sp)
 20427e0:	d9000015 	stw	r4,0(sp)
 20427e4:	d9000415 	stw	r4,16(sp)
 20427e8:	28001126 	beq	r5,zero,2042830 <snprintf+0x78>
 20427ec:	28bfffc4 	addi	r2,r5,-1
 20427f0:	d8800215 	stw	r2,8(sp)
 20427f4:	d8800515 	stw	r2,20(sp)
 20427f8:	d9c01c04 	addi	r7,sp,112
 20427fc:	00bfffc4 	movi	r2,-1
 2042800:	d80b883a 	mov	r5,sp
 2042804:	8009883a 	mov	r4,r16
 2042808:	d880038d 	sth	r2,14(sp)
 204280c:	2042c500 	call	2042c50 <___svfprintf_internal_r>
 2042810:	00ffffc4 	movi	r3,-1
 2042814:	10c01416 	blt	r2,r3,2042868 <snprintf+0xb0>
 2042818:	d8c00017 	ldw	r3,0(sp)
 204281c:	18000005 	stb	zero,0(r3)
 2042820:	dfc01b17 	ldw	ra,108(sp)
 2042824:	dc001a17 	ldw	r16,104(sp)
 2042828:	dec01d04 	addi	sp,sp,116
 204282c:	f800283a 	ret
 2042830:	00bfffc4 	movi	r2,-1
 2042834:	d9c01c04 	addi	r7,sp,112
 2042838:	d80b883a 	mov	r5,sp
 204283c:	8009883a 	mov	r4,r16
 2042840:	d8000215 	stw	zero,8(sp)
 2042844:	d8000515 	stw	zero,20(sp)
 2042848:	d880038d 	sth	r2,14(sp)
 204284c:	2042c500 	call	2042c50 <___svfprintf_internal_r>
 2042850:	00ffffc4 	movi	r3,-1
 2042854:	10c00716 	blt	r2,r3,2042874 <snprintf+0xbc>
 2042858:	dfc01b17 	ldw	ra,108(sp)
 204285c:	dc001a17 	ldw	r16,104(sp)
 2042860:	dec01d04 	addi	sp,sp,116
 2042864:	f800283a 	ret
 2042868:	00c022c4 	movi	r3,139
 204286c:	80c00015 	stw	r3,0(r16)
 2042870:	003fe906 	br	2042818 <__alt_mem_mem_0+0xfd022818>
 2042874:	00c022c4 	movi	r3,139
 2042878:	80c00015 	stw	r3,0(r16)
 204287c:	dfc01b17 	ldw	ra,108(sp)
 2042880:	dc001a17 	ldw	r16,104(sp)
 2042884:	dec01d04 	addi	sp,sp,116
 2042888:	f800283a 	ret
 204288c:	008022c4 	movi	r2,139
 2042890:	80800015 	stw	r2,0(r16)
 2042894:	00bfffc4 	movi	r2,-1
 2042898:	003fef06 	br	2042858 <__alt_mem_mem_0+0xfd022858>

0204289c <strcpy>:
 204289c:	2906b03a 	or	r3,r5,r4
 20428a0:	18c000cc 	andi	r3,r3,3
 20428a4:	2005883a 	mov	r2,r4
 20428a8:	1800161e 	bne	r3,zero,2042904 <strcpy+0x68>
 20428ac:	29c00017 	ldw	r7,0(r5)
 20428b0:	02ffbff4 	movhi	r11,65279
 20428b4:	5affbfc4 	addi	r11,r11,-257
 20428b8:	02a02074 	movhi	r10,32897
 20428bc:	01c6303a 	nor	r3,zero,r7
 20428c0:	3ac9883a 	add	r4,r7,r11
 20428c4:	52a02004 	addi	r10,r10,-32640
 20428c8:	20c6703a 	and	r3,r4,r3
 20428cc:	1a86703a 	and	r3,r3,r10
 20428d0:	18000c1e 	bne	r3,zero,2042904 <strcpy+0x68>
 20428d4:	1011883a 	mov	r8,r2
 20428d8:	41c00015 	stw	r7,0(r8)
 20428dc:	29400104 	addi	r5,r5,4
 20428e0:	29c00017 	ldw	r7,0(r5)
 20428e4:	41800104 	addi	r6,r8,4
 20428e8:	3011883a 	mov	r8,r6
 20428ec:	3ad3883a 	add	r9,r7,r11
 20428f0:	01c6303a 	nor	r3,zero,r7
 20428f4:	48c6703a 	and	r3,r9,r3
 20428f8:	1a86703a 	and	r3,r3,r10
 20428fc:	183ff626 	beq	r3,zero,20428d8 <__alt_mem_mem_0+0xfd0228d8>
 2042900:	00000106 	br	2042908 <strcpy+0x6c>
 2042904:	100d883a 	mov	r6,r2
 2042908:	28c00003 	ldbu	r3,0(r5)
 204290c:	31800044 	addi	r6,r6,1
 2042910:	29400044 	addi	r5,r5,1
 2042914:	30ffffc5 	stb	r3,-1(r6)
 2042918:	18c03fcc 	andi	r3,r3,255
 204291c:	18c0201c 	xori	r3,r3,128
 2042920:	18ffe004 	addi	r3,r3,-128
 2042924:	183ff81e 	bne	r3,zero,2042908 <__alt_mem_mem_0+0xfd022908>
 2042928:	f800283a 	ret

0204292c <strncmp>:
 204292c:	30003126 	beq	r6,zero,20429f4 <strncmp+0xc8>
 2042930:	2144b03a 	or	r2,r4,r5
 2042934:	108000cc 	andi	r2,r2,3
 2042938:	10001e1e 	bne	r2,zero,20429b4 <strncmp+0x88>
 204293c:	024000c4 	movi	r9,3
 2042940:	49801c2e 	bgeu	r9,r6,20429b4 <strncmp+0x88>
 2042944:	20800017 	ldw	r2,0(r4)
 2042948:	28c00017 	ldw	r3,0(r5)
 204294c:	10c0191e 	bne	r2,r3,20429b4 <strncmp+0x88>
 2042950:	31bfff04 	addi	r6,r6,-4
 2042954:	30002726 	beq	r6,zero,20429f4 <strncmp+0xc8>
 2042958:	02ffbff4 	movhi	r11,65279
 204295c:	5affbfc4 	addi	r11,r11,-257
 2042960:	0086303a 	nor	r3,zero,r2
 2042964:	02a02074 	movhi	r10,32897
 2042968:	12c5883a 	add	r2,r2,r11
 204296c:	52a02004 	addi	r10,r10,-32640
 2042970:	10c4703a 	and	r2,r2,r3
 2042974:	1284703a 	and	r2,r2,r10
 2042978:	10000b26 	beq	r2,zero,20429a8 <strncmp+0x7c>
 204297c:	00001d06 	br	20429f4 <strncmp+0xc8>
 2042980:	20c00017 	ldw	r3,0(r4)
 2042984:	29c00017 	ldw	r7,0(r5)
 2042988:	1ad1883a 	add	r8,r3,r11
 204298c:	00c4303a 	nor	r2,zero,r3
 2042990:	4084703a 	and	r2,r8,r2
 2042994:	1284703a 	and	r2,r2,r10
 2042998:	19c0061e 	bne	r3,r7,20429b4 <strncmp+0x88>
 204299c:	31bfff04 	addi	r6,r6,-4
 20429a0:	30001426 	beq	r6,zero,20429f4 <strncmp+0xc8>
 20429a4:	1000131e 	bne	r2,zero,20429f4 <strncmp+0xc8>
 20429a8:	21000104 	addi	r4,r4,4
 20429ac:	29400104 	addi	r5,r5,4
 20429b0:	49bff336 	bltu	r9,r6,2042980 <__alt_mem_mem_0+0xfd022980>
 20429b4:	28800007 	ldb	r2,0(r5)
 20429b8:	20c00007 	ldb	r3,0(r4)
 20429bc:	31bfffc4 	addi	r6,r6,-1
 20429c0:	10c0081e 	bne	r2,r3,20429e4 <strncmp+0xb8>
 20429c4:	30000b26 	beq	r6,zero,20429f4 <strncmp+0xc8>
 20429c8:	10000a26 	beq	r2,zero,20429f4 <strncmp+0xc8>
 20429cc:	21000044 	addi	r4,r4,1
 20429d0:	29400044 	addi	r5,r5,1
 20429d4:	20800007 	ldb	r2,0(r4)
 20429d8:	28c00007 	ldb	r3,0(r5)
 20429dc:	31bfffc4 	addi	r6,r6,-1
 20429e0:	10fff826 	beq	r2,r3,20429c4 <__alt_mem_mem_0+0xfd0229c4>
 20429e4:	20800003 	ldbu	r2,0(r4)
 20429e8:	28c00003 	ldbu	r3,0(r5)
 20429ec:	10c5c83a 	sub	r2,r2,r3
 20429f0:	f800283a 	ret
 20429f4:	0005883a 	mov	r2,zero
 20429f8:	f800283a 	ret

020429fc <_strtol_r>:
 20429fc:	00808174 	movhi	r2,517
 2042a00:	defff404 	addi	sp,sp,-48
 2042a04:	10ab5f04 	addi	r2,r2,-21124
 2042a08:	dd400715 	stw	r21,28(sp)
 2042a0c:	15400017 	ldw	r21,0(r2)
 2042a10:	dd800815 	stw	r22,32(sp)
 2042a14:	dd000615 	stw	r20,24(sp)
 2042a18:	dcc00515 	stw	r19,20(sp)
 2042a1c:	d9000015 	stw	r4,0(sp)
 2042a20:	dfc00b15 	stw	ra,44(sp)
 2042a24:	df000a15 	stw	fp,40(sp)
 2042a28:	ddc00915 	stw	r23,36(sp)
 2042a2c:	dc800415 	stw	r18,16(sp)
 2042a30:	dc400315 	stw	r17,12(sp)
 2042a34:	dc000215 	stw	r16,8(sp)
 2042a38:	2829883a 	mov	r20,r5
 2042a3c:	3027883a 	mov	r19,r6
 2042a40:	382d883a 	mov	r22,r7
 2042a44:	2809883a 	mov	r4,r5
 2042a48:	24000003 	ldbu	r16,0(r4)
 2042a4c:	24400044 	addi	r17,r4,1
 2042a50:	2007883a 	mov	r3,r4
 2042a54:	ac05883a 	add	r2,r21,r16
 2042a58:	10800043 	ldbu	r2,1(r2)
 2042a5c:	8809883a 	mov	r4,r17
 2042a60:	1080020c 	andi	r2,r2,8
 2042a64:	103ff81e 	bne	r2,zero,2042a48 <__alt_mem_mem_0+0xfd022a48>
 2042a68:	00800b44 	movi	r2,45
 2042a6c:	80805826 	beq	r16,r2,2042bd0 <_strtol_r+0x1d4>
 2042a70:	00800ac4 	movi	r2,43
 2042a74:	80805a26 	beq	r16,r2,2042be0 <_strtol_r+0x1e4>
 2042a78:	0039883a 	mov	fp,zero
 2042a7c:	b0004426 	beq	r22,zero,2042b90 <_strtol_r+0x194>
 2042a80:	00800404 	movi	r2,16
 2042a84:	b0806026 	beq	r22,r2,2042c08 <_strtol_r+0x20c>
 2042a88:	b02f883a 	mov	r23,r22
 2042a8c:	00a00034 	movhi	r2,32768
 2042a90:	e025003a 	cmpeq	r18,fp,zero
 2042a94:	14a5c83a 	sub	r18,r2,r18
 2042a98:	b80b883a 	mov	r5,r23
 2042a9c:	9009883a 	mov	r4,r18
 2042aa0:	200ab400 	call	200ab40 <__umodsi3>
 2042aa4:	b80b883a 	mov	r5,r23
 2042aa8:	9009883a 	mov	r4,r18
 2042aac:	d8800115 	stw	r2,4(sp)
 2042ab0:	200aadc0 	call	200aadc <__udivsi3>
 2042ab4:	ac07883a 	add	r3,r21,r16
 2042ab8:	18c00043 	ldbu	r3,1(r3)
 2042abc:	880b883a 	mov	r5,r17
 2042ac0:	000d883a 	mov	r6,zero
 2042ac4:	1a00010c 	andi	r8,r3,4
 2042ac8:	0009883a 	mov	r4,zero
 2042acc:	02800044 	movi	r10,1
 2042ad0:	027fffc4 	movi	r9,-1
 2042ad4:	d9c00117 	ldw	r7,4(sp)
 2042ad8:	40000e26 	beq	r8,zero,2042b14 <_strtol_r+0x118>
 2042adc:	843ff404 	addi	r16,r16,-48
 2042ae0:	8580120e 	bge	r16,r22,2042b2c <_strtol_r+0x130>
 2042ae4:	32400526 	beq	r6,r9,2042afc <_strtol_r+0x100>
 2042ae8:	11002536 	bltu	r2,r4,2042b80 <_strtol_r+0x184>
 2042aec:	20802326 	beq	r4,r2,2042b7c <_strtol_r+0x180>
 2042af0:	25c9383a 	mul	r4,r4,r23
 2042af4:	01800044 	movi	r6,1
 2042af8:	8109883a 	add	r4,r16,r4
 2042afc:	2c000003 	ldbu	r16,0(r5)
 2042b00:	29400044 	addi	r5,r5,1
 2042b04:	ac07883a 	add	r3,r21,r16
 2042b08:	18c00043 	ldbu	r3,1(r3)
 2042b0c:	1a00010c 	andi	r8,r3,4
 2042b10:	403ff21e 	bne	r8,zero,2042adc <__alt_mem_mem_0+0xfd022adc>
 2042b14:	18c000cc 	andi	r3,r3,3
 2042b18:	18000426 	beq	r3,zero,2042b2c <_strtol_r+0x130>
 2042b1c:	1a801a26 	beq	r3,r10,2042b88 <_strtol_r+0x18c>
 2042b20:	00c015c4 	movi	r3,87
 2042b24:	80e1c83a 	sub	r16,r16,r3
 2042b28:	85bfee16 	blt	r16,r22,2042ae4 <__alt_mem_mem_0+0xfd022ae4>
 2042b2c:	00bfffc4 	movi	r2,-1
 2042b30:	30801e26 	beq	r6,r2,2042bac <_strtol_r+0x1b0>
 2042b34:	e0001b1e 	bne	fp,zero,2042ba4 <_strtol_r+0x1a8>
 2042b38:	2005883a 	mov	r2,r4
 2042b3c:	98000326 	beq	r19,zero,2042b4c <_strtol_r+0x150>
 2042b40:	3000211e 	bne	r6,zero,2042bc8 <_strtol_r+0x1cc>
 2042b44:	a00b883a 	mov	r5,r20
 2042b48:	99400015 	stw	r5,0(r19)
 2042b4c:	dfc00b17 	ldw	ra,44(sp)
 2042b50:	df000a17 	ldw	fp,40(sp)
 2042b54:	ddc00917 	ldw	r23,36(sp)
 2042b58:	dd800817 	ldw	r22,32(sp)
 2042b5c:	dd400717 	ldw	r21,28(sp)
 2042b60:	dd000617 	ldw	r20,24(sp)
 2042b64:	dcc00517 	ldw	r19,20(sp)
 2042b68:	dc800417 	ldw	r18,16(sp)
 2042b6c:	dc400317 	ldw	r17,12(sp)
 2042b70:	dc000217 	ldw	r16,8(sp)
 2042b74:	dec00c04 	addi	sp,sp,48
 2042b78:	f800283a 	ret
 2042b7c:	3c3fdc0e 	bge	r7,r16,2042af0 <__alt_mem_mem_0+0xfd022af0>
 2042b80:	01bfffc4 	movi	r6,-1
 2042b84:	003fdd06 	br	2042afc <__alt_mem_mem_0+0xfd022afc>
 2042b88:	00c00dc4 	movi	r3,55
 2042b8c:	003fe506 	br	2042b24 <__alt_mem_mem_0+0xfd022b24>
 2042b90:	00800c04 	movi	r2,48
 2042b94:	80801626 	beq	r16,r2,2042bf0 <_strtol_r+0x1f4>
 2042b98:	05800284 	movi	r22,10
 2042b9c:	b02f883a 	mov	r23,r22
 2042ba0:	003fba06 	br	2042a8c <__alt_mem_mem_0+0xfd022a8c>
 2042ba4:	0109c83a 	sub	r4,zero,r4
 2042ba8:	003fe306 	br	2042b38 <__alt_mem_mem_0+0xfd022b38>
 2042bac:	d9000017 	ldw	r4,0(sp)
 2042bb0:	00c00884 	movi	r3,34
 2042bb4:	e005003a 	cmpeq	r2,fp,zero
 2042bb8:	20c00015 	stw	r3,0(r4)
 2042bbc:	00e00034 	movhi	r3,32768
 2042bc0:	1885c83a 	sub	r2,r3,r2
 2042bc4:	983fe126 	beq	r19,zero,2042b4c <__alt_mem_mem_0+0xfd022b4c>
 2042bc8:	297fffc4 	addi	r5,r5,-1
 2042bcc:	003fde06 	br	2042b48 <__alt_mem_mem_0+0xfd022b48>
 2042bd0:	1c400084 	addi	r17,r3,2
 2042bd4:	1c000043 	ldbu	r16,1(r3)
 2042bd8:	07000044 	movi	fp,1
 2042bdc:	003fa706 	br	2042a7c <__alt_mem_mem_0+0xfd022a7c>
 2042be0:	1c400084 	addi	r17,r3,2
 2042be4:	1c000043 	ldbu	r16,1(r3)
 2042be8:	0039883a 	mov	fp,zero
 2042bec:	003fa306 	br	2042a7c <__alt_mem_mem_0+0xfd022a7c>
 2042bf0:	88800003 	ldbu	r2,0(r17)
 2042bf4:	00c01604 	movi	r3,88
 2042bf8:	108037cc 	andi	r2,r2,223
 2042bfc:	10c00826 	beq	r2,r3,2042c20 <_strtol_r+0x224>
 2042c00:	05800204 	movi	r22,8
 2042c04:	003fa006 	br	2042a88 <__alt_mem_mem_0+0xfd022a88>
 2042c08:	00800c04 	movi	r2,48
 2042c0c:	80bf9e1e 	bne	r16,r2,2042a88 <__alt_mem_mem_0+0xfd022a88>
 2042c10:	88800003 	ldbu	r2,0(r17)
 2042c14:	00c01604 	movi	r3,88
 2042c18:	108037cc 	andi	r2,r2,223
 2042c1c:	10ff9a1e 	bne	r2,r3,2042a88 <__alt_mem_mem_0+0xfd022a88>
 2042c20:	05c00404 	movi	r23,16
 2042c24:	8c000043 	ldbu	r16,1(r17)
 2042c28:	b82d883a 	mov	r22,r23
 2042c2c:	8c400084 	addi	r17,r17,2
 2042c30:	003f9606 	br	2042a8c <__alt_mem_mem_0+0xfd022a8c>

02042c34 <strtol>:
 2042c34:	00808174 	movhi	r2,517
 2042c38:	10ab4004 	addi	r2,r2,-21248
 2042c3c:	300f883a 	mov	r7,r6
 2042c40:	280d883a 	mov	r6,r5
 2042c44:	200b883a 	mov	r5,r4
 2042c48:	11000017 	ldw	r4,0(r2)
 2042c4c:	20429fc1 	jmpi	20429fc <_strtol_r>

02042c50 <___svfprintf_internal_r>:
 2042c50:	deffb704 	addi	sp,sp,-292
 2042c54:	dfc04815 	stw	ra,288(sp)
 2042c58:	ddc04615 	stw	r23,280(sp)
 2042c5c:	d9402c15 	stw	r5,176(sp)
 2042c60:	d9003915 	stw	r4,228(sp)
 2042c64:	302f883a 	mov	r23,r6
 2042c68:	d9c02d15 	stw	r7,180(sp)
 2042c6c:	df004715 	stw	fp,284(sp)
 2042c70:	dd804515 	stw	r22,276(sp)
 2042c74:	dd404415 	stw	r21,272(sp)
 2042c78:	dd004315 	stw	r20,268(sp)
 2042c7c:	dcc04215 	stw	r19,264(sp)
 2042c80:	dc804115 	stw	r18,260(sp)
 2042c84:	dc404015 	stw	r17,256(sp)
 2042c88:	dc003f15 	stw	r16,252(sp)
 2042c8c:	200537c0 	call	200537c <_localeconv_r>
 2042c90:	10800017 	ldw	r2,0(r2)
 2042c94:	1009883a 	mov	r4,r2
 2042c98:	d8803415 	stw	r2,208(sp)
 2042c9c:	20073a40 	call	20073a4 <strlen>
 2042ca0:	d8c02c17 	ldw	r3,176(sp)
 2042ca4:	d8803815 	stw	r2,224(sp)
 2042ca8:	1880030b 	ldhu	r2,12(r3)
 2042cac:	1080200c 	andi	r2,r2,128
 2042cb0:	10000226 	beq	r2,zero,2042cbc <___svfprintf_internal_r+0x6c>
 2042cb4:	18800417 	ldw	r2,16(r3)
 2042cb8:	10067f26 	beq	r2,zero,20446b8 <___svfprintf_internal_r+0x1a68>
 2042cbc:	dcc03917 	ldw	r19,228(sp)
 2042cc0:	d8c00404 	addi	r3,sp,16
 2042cc4:	05408174 	movhi	r21,517
 2042cc8:	d9001e04 	addi	r4,sp,120
 2042ccc:	ad63d704 	addi	r21,r21,-28836
 2042cd0:	d8c01e15 	stw	r3,120(sp)
 2042cd4:	d8002015 	stw	zero,128(sp)
 2042cd8:	d8001f15 	stw	zero,124(sp)
 2042cdc:	d8003315 	stw	zero,204(sp)
 2042ce0:	d8003615 	stw	zero,216(sp)
 2042ce4:	d8003715 	stw	zero,220(sp)
 2042ce8:	1811883a 	mov	r8,r3
 2042cec:	d8003a15 	stw	zero,232(sp)
 2042cf0:	d8003b15 	stw	zero,236(sp)
 2042cf4:	d8002f15 	stw	zero,188(sp)
 2042cf8:	d9002815 	stw	r4,160(sp)
 2042cfc:	b8800007 	ldb	r2,0(r23)
 2042d00:	10026726 	beq	r2,zero,20436a0 <___svfprintf_internal_r+0xa50>
 2042d04:	00c00944 	movi	r3,37
 2042d08:	b821883a 	mov	r16,r23
 2042d0c:	10c0021e 	bne	r2,r3,2042d18 <___svfprintf_internal_r+0xc8>
 2042d10:	00001406 	br	2042d64 <___svfprintf_internal_r+0x114>
 2042d14:	10c00326 	beq	r2,r3,2042d24 <___svfprintf_internal_r+0xd4>
 2042d18:	84000044 	addi	r16,r16,1
 2042d1c:	80800007 	ldb	r2,0(r16)
 2042d20:	103ffc1e 	bne	r2,zero,2042d14 <__alt_mem_mem_0+0xfd022d14>
 2042d24:	85e3c83a 	sub	r17,r16,r23
 2042d28:	88000e26 	beq	r17,zero,2042d64 <___svfprintf_internal_r+0x114>
 2042d2c:	d8c02017 	ldw	r3,128(sp)
 2042d30:	d8801f17 	ldw	r2,124(sp)
 2042d34:	45c00015 	stw	r23,0(r8)
 2042d38:	1c47883a 	add	r3,r3,r17
 2042d3c:	10800044 	addi	r2,r2,1
 2042d40:	d8c02015 	stw	r3,128(sp)
 2042d44:	44400115 	stw	r17,4(r8)
 2042d48:	d8801f15 	stw	r2,124(sp)
 2042d4c:	00c001c4 	movi	r3,7
 2042d50:	18809716 	blt	r3,r2,2042fb0 <___svfprintf_internal_r+0x360>
 2042d54:	42000204 	addi	r8,r8,8
 2042d58:	d9402f17 	ldw	r5,188(sp)
 2042d5c:	2c4b883a 	add	r5,r5,r17
 2042d60:	d9402f15 	stw	r5,188(sp)
 2042d64:	80800007 	ldb	r2,0(r16)
 2042d68:	10009826 	beq	r2,zero,2042fcc <___svfprintf_internal_r+0x37c>
 2042d6c:	84400047 	ldb	r17,1(r16)
 2042d70:	00bfffc4 	movi	r2,-1
 2042d74:	85c00044 	addi	r23,r16,1
 2042d78:	d8002785 	stb	zero,158(sp)
 2042d7c:	0007883a 	mov	r3,zero
 2042d80:	000f883a 	mov	r7,zero
 2042d84:	d8802915 	stw	r2,164(sp)
 2042d88:	d8003115 	stw	zero,196(sp)
 2042d8c:	0025883a 	mov	r18,zero
 2042d90:	01401604 	movi	r5,88
 2042d94:	01800244 	movi	r6,9
 2042d98:	02800a84 	movi	r10,42
 2042d9c:	02401b04 	movi	r9,108
 2042da0:	bdc00044 	addi	r23,r23,1
 2042da4:	88bff804 	addi	r2,r17,-32
 2042da8:	2882f036 	bltu	r5,r2,204396c <___svfprintf_internal_r+0xd1c>
 2042dac:	100490ba 	slli	r2,r2,2
 2042db0:	01008134 	movhi	r4,516
 2042db4:	210b7104 	addi	r4,r4,11716
 2042db8:	1105883a 	add	r2,r2,r4
 2042dbc:	10800017 	ldw	r2,0(r2)
 2042dc0:	1000683a 	jmp	r2
 2042dc4:	020438d4 	movui	r8,4323
 2042dc8:	0204396c 	andhi	r8,zero,4325
 2042dcc:	0204396c 	andhi	r8,zero,4325
 2042dd0:	020438c8 	cmpgei	r8,zero,4323
 2042dd4:	0204396c 	andhi	r8,zero,4325
 2042dd8:	0204396c 	andhi	r8,zero,4325
 2042ddc:	0204396c 	andhi	r8,zero,4325
 2042de0:	0204396c 	andhi	r8,zero,4325
 2042de4:	0204396c 	andhi	r8,zero,4325
 2042de8:	0204396c 	andhi	r8,zero,4325
 2042dec:	02043028 	cmpgeui	r8,zero,4288
 2042df0:	02043804 	movi	r8,4320
 2042df4:	0204396c 	andhi	r8,zero,4325
 2042df8:	02042f38 	rdprs	r8,zero,4284
 2042dfc:	02043050 	cmplti	r8,zero,4289
 2042e00:	0204396c 	andhi	r8,zero,4325
 2042e04:	020430c4 	movi	r8,4291
 2042e08:	02043090 	cmplti	r8,zero,4290
 2042e0c:	02043090 	cmplti	r8,zero,4290
 2042e10:	02043090 	cmplti	r8,zero,4290
 2042e14:	02043090 	cmplti	r8,zero,4290
 2042e18:	02043090 	cmplti	r8,zero,4290
 2042e1c:	02043090 	cmplti	r8,zero,4290
 2042e20:	02043090 	cmplti	r8,zero,4290
 2042e24:	02043090 	cmplti	r8,zero,4290
 2042e28:	02043090 	cmplti	r8,zero,4290
 2042e2c:	0204396c 	andhi	r8,zero,4325
 2042e30:	0204396c 	andhi	r8,zero,4325
 2042e34:	0204396c 	andhi	r8,zero,4325
 2042e38:	0204396c 	andhi	r8,zero,4325
 2042e3c:	0204396c 	andhi	r8,zero,4325
 2042e40:	0204396c 	andhi	r8,zero,4325
 2042e44:	0204396c 	andhi	r8,zero,4325
 2042e48:	0204396c 	andhi	r8,zero,4325
 2042e4c:	0204396c 	andhi	r8,zero,4325
 2042e50:	0204396c 	andhi	r8,zero,4325
 2042e54:	0204317c 	xorhi	r8,zero,4293
 2042e58:	020430d0 	cmplti	r8,zero,4291
 2042e5c:	0204396c 	andhi	r8,zero,4325
 2042e60:	020430d0 	cmplti	r8,zero,4291
 2042e64:	0204396c 	andhi	r8,zero,4325
 2042e68:	0204396c 	andhi	r8,zero,4325
 2042e6c:	0204396c 	andhi	r8,zero,4325
 2042e70:	0204396c 	andhi	r8,zero,4325
 2042e74:	02043170 	cmpltui	r8,zero,4293
 2042e78:	0204396c 	andhi	r8,zero,4325
 2042e7c:	0204396c 	andhi	r8,zero,4325
 2042e80:	02043238 	rdprs	r8,zero,4296
 2042e84:	0204396c 	andhi	r8,zero,4325
 2042e88:	0204396c 	andhi	r8,zero,4325
 2042e8c:	0204396c 	andhi	r8,zero,4325
 2042e90:	0204396c 	andhi	r8,zero,4325
 2042e94:	0204396c 	andhi	r8,zero,4325
 2042e98:	020436a8 	cmpgeui	r8,zero,4314
 2042e9c:	0204396c 	andhi	r8,zero,4325
 2042ea0:	0204396c 	andhi	r8,zero,4325
 2042ea4:	02043708 	cmpgei	r8,zero,4316
 2042ea8:	0204396c 	andhi	r8,zero,4325
 2042eac:	0204396c 	andhi	r8,zero,4325
 2042eb0:	0204396c 	andhi	r8,zero,4325
 2042eb4:	0204396c 	andhi	r8,zero,4325
 2042eb8:	0204396c 	andhi	r8,zero,4325
 2042ebc:	0204396c 	andhi	r8,zero,4325
 2042ec0:	0204396c 	andhi	r8,zero,4325
 2042ec4:	0204396c 	andhi	r8,zero,4325
 2042ec8:	0204396c 	andhi	r8,zero,4325
 2042ecc:	0204396c 	andhi	r8,zero,4325
 2042ed0:	020437b8 	rdprs	r8,zero,4318
 2042ed4:	020438f4 	movhi	r8,4323
 2042ed8:	020430d0 	cmplti	r8,zero,4291
 2042edc:	020430d0 	cmplti	r8,zero,4291
 2042ee0:	020430d0 	cmplti	r8,zero,4291
 2042ee4:	02043948 	cmpgei	r8,zero,4325
 2042ee8:	020438f4 	movhi	r8,4323
 2042eec:	0204396c 	andhi	r8,zero,4325
 2042ef0:	0204396c 	andhi	r8,zero,4325
 2042ef4:	02043904 	movi	r8,4324
 2042ef8:	0204396c 	andhi	r8,zero,4325
 2042efc:	02043914 	movui	r8,4324
 2042f00:	020437f4 	movhi	r8,4319
 2042f04:	02042f44 	movi	r8,4285
 2042f08:	02043814 	movui	r8,4320
 2042f0c:	0204396c 	andhi	r8,zero,4325
 2042f10:	02043820 	cmpeqi	r8,zero,4320
 2042f14:	0204396c 	andhi	r8,zero,4325
 2042f18:	0204387c 	xorhi	r8,zero,4321
 2042f1c:	0204396c 	andhi	r8,zero,4325
 2042f20:	0204396c 	andhi	r8,zero,4325
 2042f24:	0204388c 	andi	r8,zero,4322
 2042f28:	d9003117 	ldw	r4,196(sp)
 2042f2c:	d8802d15 	stw	r2,180(sp)
 2042f30:	0109c83a 	sub	r4,zero,r4
 2042f34:	d9003115 	stw	r4,196(sp)
 2042f38:	94800114 	ori	r18,r18,4
 2042f3c:	bc400007 	ldb	r17,0(r23)
 2042f40:	003f9706 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2042f44:	00800c04 	movi	r2,48
 2042f48:	d9002d17 	ldw	r4,180(sp)
 2042f4c:	d9402917 	ldw	r5,164(sp)
 2042f50:	d8802705 	stb	r2,156(sp)
 2042f54:	00801e04 	movi	r2,120
 2042f58:	d8802745 	stb	r2,157(sp)
 2042f5c:	d8002785 	stb	zero,158(sp)
 2042f60:	20c00104 	addi	r3,r4,4
 2042f64:	25000017 	ldw	r20,0(r4)
 2042f68:	002d883a 	mov	r22,zero
 2042f6c:	90800094 	ori	r2,r18,2
 2042f70:	28028616 	blt	r5,zero,204398c <___svfprintf_internal_r+0xd3c>
 2042f74:	00bfdfc4 	movi	r2,-129
 2042f78:	90a4703a 	and	r18,r18,r2
 2042f7c:	d8c02d15 	stw	r3,180(sp)
 2042f80:	94800094 	ori	r18,r18,2
 2042f84:	a002731e 	bne	r20,zero,2043954 <___svfprintf_internal_r+0xd04>
 2042f88:	00808134 	movhi	r2,516
 2042f8c:	109a8504 	addi	r2,r2,27156
 2042f90:	d8803a15 	stw	r2,232(sp)
 2042f94:	04401e04 	movi	r17,120
 2042f98:	d8c02917 	ldw	r3,164(sp)
 2042f9c:	0039883a 	mov	fp,zero
 2042fa0:	1801d526 	beq	r3,zero,20436f8 <___svfprintf_internal_r+0xaa8>
 2042fa4:	0029883a 	mov	r20,zero
 2042fa8:	002d883a 	mov	r22,zero
 2042fac:	0001f106 	br	2043774 <___svfprintf_internal_r+0xb24>
 2042fb0:	d9402c17 	ldw	r5,176(sp)
 2042fb4:	d9801e04 	addi	r6,sp,120
 2042fb8:	9809883a 	mov	r4,r19
 2042fbc:	20450c00 	call	20450c0 <__ssprint_r>
 2042fc0:	1000081e 	bne	r2,zero,2042fe4 <___svfprintf_internal_r+0x394>
 2042fc4:	da000404 	addi	r8,sp,16
 2042fc8:	003f6306 	br	2042d58 <__alt_mem_mem_0+0xfd022d58>
 2042fcc:	d8802017 	ldw	r2,128(sp)
 2042fd0:	10000426 	beq	r2,zero,2042fe4 <___svfprintf_internal_r+0x394>
 2042fd4:	d9402c17 	ldw	r5,176(sp)
 2042fd8:	d9003917 	ldw	r4,228(sp)
 2042fdc:	d9801e04 	addi	r6,sp,120
 2042fe0:	20450c00 	call	20450c0 <__ssprint_r>
 2042fe4:	d8802c17 	ldw	r2,176(sp)
 2042fe8:	10c0030b 	ldhu	r3,12(r2)
 2042fec:	d8802f17 	ldw	r2,188(sp)
 2042ff0:	18c0100c 	andi	r3,r3,64
 2042ff4:	1805f51e 	bne	r3,zero,20447cc <___svfprintf_internal_r+0x1b7c>
 2042ff8:	dfc04817 	ldw	ra,288(sp)
 2042ffc:	df004717 	ldw	fp,284(sp)
 2043000:	ddc04617 	ldw	r23,280(sp)
 2043004:	dd804517 	ldw	r22,276(sp)
 2043008:	dd404417 	ldw	r21,272(sp)
 204300c:	dd004317 	ldw	r20,268(sp)
 2043010:	dcc04217 	ldw	r19,264(sp)
 2043014:	dc804117 	ldw	r18,260(sp)
 2043018:	dc404017 	ldw	r17,256(sp)
 204301c:	dc003f17 	ldw	r16,252(sp)
 2043020:	dec04904 	addi	sp,sp,292
 2043024:	f800283a 	ret
 2043028:	d8802d17 	ldw	r2,180(sp)
 204302c:	d9002d17 	ldw	r4,180(sp)
 2043030:	10800017 	ldw	r2,0(r2)
 2043034:	d8803115 	stw	r2,196(sp)
 2043038:	20800104 	addi	r2,r4,4
 204303c:	d9003117 	ldw	r4,196(sp)
 2043040:	203fb916 	blt	r4,zero,2042f28 <__alt_mem_mem_0+0xfd022f28>
 2043044:	d8802d15 	stw	r2,180(sp)
 2043048:	bc400007 	ldb	r17,0(r23)
 204304c:	003f5406 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2043050:	bc400007 	ldb	r17,0(r23)
 2043054:	bac00044 	addi	r11,r23,1
 2043058:	8a873926 	beq	r17,r10,2044d40 <___svfprintf_internal_r+0x20f0>
 204305c:	88bff404 	addi	r2,r17,-48
 2043060:	0009883a 	mov	r4,zero
 2043064:	30868836 	bltu	r6,r2,2044a88 <___svfprintf_internal_r+0x1e38>
 2043068:	5c400007 	ldb	r17,0(r11)
 204306c:	210002a4 	muli	r4,r4,10
 2043070:	5dc00044 	addi	r23,r11,1
 2043074:	b817883a 	mov	r11,r23
 2043078:	2089883a 	add	r4,r4,r2
 204307c:	88bff404 	addi	r2,r17,-48
 2043080:	30bff92e 	bgeu	r6,r2,2043068 <__alt_mem_mem_0+0xfd023068>
 2043084:	2005d716 	blt	r4,zero,20447e4 <___svfprintf_internal_r+0x1b94>
 2043088:	d9002915 	stw	r4,164(sp)
 204308c:	003f4506 	br	2042da4 <__alt_mem_mem_0+0xfd022da4>
 2043090:	b809883a 	mov	r4,r23
 2043094:	d8003115 	stw	zero,196(sp)
 2043098:	88bff404 	addi	r2,r17,-48
 204309c:	0017883a 	mov	r11,zero
 20430a0:	24400007 	ldb	r17,0(r4)
 20430a4:	5ac002a4 	muli	r11,r11,10
 20430a8:	bdc00044 	addi	r23,r23,1
 20430ac:	b809883a 	mov	r4,r23
 20430b0:	12d7883a 	add	r11,r2,r11
 20430b4:	88bff404 	addi	r2,r17,-48
 20430b8:	30bff92e 	bgeu	r6,r2,20430a0 <__alt_mem_mem_0+0xfd0230a0>
 20430bc:	dac03115 	stw	r11,196(sp)
 20430c0:	003f3806 	br	2042da4 <__alt_mem_mem_0+0xfd022da4>
 20430c4:	94802014 	ori	r18,r18,128
 20430c8:	bc400007 	ldb	r17,0(r23)
 20430cc:	003f3406 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 20430d0:	18c03fcc 	andi	r3,r3,255
 20430d4:	1807471e 	bne	r3,zero,2044df4 <___svfprintf_internal_r+0x21a4>
 20430d8:	9080020c 	andi	r2,r18,8
 20430dc:	10047d26 	beq	r2,zero,20442d4 <___svfprintf_internal_r+0x1684>
 20430e0:	d8c02d17 	ldw	r3,180(sp)
 20430e4:	d9002d17 	ldw	r4,180(sp)
 20430e8:	d9402d17 	ldw	r5,180(sp)
 20430ec:	18c00017 	ldw	r3,0(r3)
 20430f0:	21000117 	ldw	r4,4(r4)
 20430f4:	29400204 	addi	r5,r5,8
 20430f8:	d8c03615 	stw	r3,216(sp)
 20430fc:	d9003715 	stw	r4,220(sp)
 2043100:	d9402d15 	stw	r5,180(sp)
 2043104:	d9003617 	ldw	r4,216(sp)
 2043108:	d9403717 	ldw	r5,220(sp)
 204310c:	da003e15 	stw	r8,248(sp)
 2043110:	04000044 	movi	r16,1
 2043114:	20070c40 	call	20070c4 <__fpclassifyd>
 2043118:	da003e17 	ldw	r8,248(sp)
 204311c:	14044b1e 	bne	r2,r16,204424c <___svfprintf_internal_r+0x15fc>
 2043120:	d9003617 	ldw	r4,216(sp)
 2043124:	d9403717 	ldw	r5,220(sp)
 2043128:	000d883a 	mov	r6,zero
 204312c:	000f883a 	mov	r7,zero
 2043130:	200be900 	call	200be90 <__ledf2>
 2043134:	da003e17 	ldw	r8,248(sp)
 2043138:	1005f316 	blt	r2,zero,2044908 <___svfprintf_internal_r+0x1cb8>
 204313c:	df002783 	ldbu	fp,158(sp)
 2043140:	008011c4 	movi	r2,71
 2043144:	1445590e 	bge	r2,r17,20446ac <___svfprintf_internal_r+0x1a5c>
 2043148:	04008134 	movhi	r16,516
 204314c:	841a7d04 	addi	r16,r16,27124
 2043150:	00c000c4 	movi	r3,3
 2043154:	00bfdfc4 	movi	r2,-129
 2043158:	d8c02a15 	stw	r3,168(sp)
 204315c:	90a4703a 	and	r18,r18,r2
 2043160:	d8c02e15 	stw	r3,184(sp)
 2043164:	d8002915 	stw	zero,164(sp)
 2043168:	d8003215 	stw	zero,200(sp)
 204316c:	00006606 	br	2043308 <___svfprintf_internal_r+0x6b8>
 2043170:	94800214 	ori	r18,r18,8
 2043174:	bc400007 	ldb	r17,0(r23)
 2043178:	003f0906 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 204317c:	18c03fcc 	andi	r3,r3,255
 2043180:	1807181e 	bne	r3,zero,2044de4 <___svfprintf_internal_r+0x2194>
 2043184:	94800414 	ori	r18,r18,16
 2043188:	9080080c 	andi	r2,r18,32
 204318c:	10039626 	beq	r2,zero,2043fe8 <___svfprintf_internal_r+0x1398>
 2043190:	d9402d17 	ldw	r5,180(sp)
 2043194:	28800117 	ldw	r2,4(r5)
 2043198:	2d000017 	ldw	r20,0(r5)
 204319c:	29400204 	addi	r5,r5,8
 20431a0:	d9402d15 	stw	r5,180(sp)
 20431a4:	102d883a 	mov	r22,r2
 20431a8:	10039816 	blt	r2,zero,204400c <___svfprintf_internal_r+0x13bc>
 20431ac:	d9402917 	ldw	r5,164(sp)
 20431b0:	df002783 	ldbu	fp,158(sp)
 20431b4:	2803ab16 	blt	r5,zero,2044064 <___svfprintf_internal_r+0x1414>
 20431b8:	00ffdfc4 	movi	r3,-129
 20431bc:	a584b03a 	or	r2,r20,r22
 20431c0:	90e4703a 	and	r18,r18,r3
 20431c4:	10014a26 	beq	r2,zero,20436f0 <___svfprintf_internal_r+0xaa0>
 20431c8:	b0034b26 	beq	r22,zero,2043ef8 <___svfprintf_internal_r+0x12a8>
 20431cc:	dc402a15 	stw	r17,168(sp)
 20431d0:	dc001e04 	addi	r16,sp,120
 20431d4:	b023883a 	mov	r17,r22
 20431d8:	402d883a 	mov	r22,r8
 20431dc:	a009883a 	mov	r4,r20
 20431e0:	880b883a 	mov	r5,r17
 20431e4:	01800284 	movi	r6,10
 20431e8:	000f883a 	mov	r7,zero
 20431ec:	200a4ac0 	call	200a4ac <__umoddi3>
 20431f0:	10800c04 	addi	r2,r2,48
 20431f4:	843fffc4 	addi	r16,r16,-1
 20431f8:	a009883a 	mov	r4,r20
 20431fc:	880b883a 	mov	r5,r17
 2043200:	80800005 	stb	r2,0(r16)
 2043204:	01800284 	movi	r6,10
 2043208:	000f883a 	mov	r7,zero
 204320c:	2009f340 	call	2009f34 <__udivdi3>
 2043210:	1029883a 	mov	r20,r2
 2043214:	10c4b03a 	or	r2,r2,r3
 2043218:	1823883a 	mov	r17,r3
 204321c:	103fef1e 	bne	r2,zero,20431dc <__alt_mem_mem_0+0xfd0231dc>
 2043220:	d8c02817 	ldw	r3,160(sp)
 2043224:	dc402a17 	ldw	r17,168(sp)
 2043228:	b011883a 	mov	r8,r22
 204322c:	1c07c83a 	sub	r3,r3,r16
 2043230:	d8c02e15 	stw	r3,184(sp)
 2043234:	00002e06 	br	20432f0 <___svfprintf_internal_r+0x6a0>
 2043238:	18c03fcc 	andi	r3,r3,255
 204323c:	1806e71e 	bne	r3,zero,2044ddc <___svfprintf_internal_r+0x218c>
 2043240:	94800414 	ori	r18,r18,16
 2043244:	9080080c 	andi	r2,r18,32
 2043248:	1002d426 	beq	r2,zero,2043d9c <___svfprintf_internal_r+0x114c>
 204324c:	d9402d17 	ldw	r5,180(sp)
 2043250:	d8c02917 	ldw	r3,164(sp)
 2043254:	d8002785 	stb	zero,158(sp)
 2043258:	28800204 	addi	r2,r5,8
 204325c:	2d000017 	ldw	r20,0(r5)
 2043260:	2d800117 	ldw	r22,4(r5)
 2043264:	18041516 	blt	r3,zero,20442bc <___svfprintf_internal_r+0x166c>
 2043268:	013fdfc4 	movi	r4,-129
 204326c:	a586b03a 	or	r3,r20,r22
 2043270:	d8802d15 	stw	r2,180(sp)
 2043274:	9124703a 	and	r18,r18,r4
 2043278:	1802d51e 	bne	r3,zero,2043dd0 <___svfprintf_internal_r+0x1180>
 204327c:	d9402917 	ldw	r5,164(sp)
 2043280:	0039883a 	mov	fp,zero
 2043284:	2806be26 	beq	r5,zero,2044d80 <___svfprintf_internal_r+0x2130>
 2043288:	0029883a 	mov	r20,zero
 204328c:	002d883a 	mov	r22,zero
 2043290:	dc001e04 	addi	r16,sp,120
 2043294:	a006d0fa 	srli	r3,r20,3
 2043298:	b008977a 	slli	r4,r22,29
 204329c:	b02cd0fa 	srli	r22,r22,3
 20432a0:	a50001cc 	andi	r20,r20,7
 20432a4:	a0800c04 	addi	r2,r20,48
 20432a8:	843fffc4 	addi	r16,r16,-1
 20432ac:	20e8b03a 	or	r20,r4,r3
 20432b0:	80800005 	stb	r2,0(r16)
 20432b4:	a586b03a 	or	r3,r20,r22
 20432b8:	183ff61e 	bne	r3,zero,2043294 <__alt_mem_mem_0+0xfd023294>
 20432bc:	90c0004c 	andi	r3,r18,1
 20432c0:	18013926 	beq	r3,zero,20437a8 <___svfprintf_internal_r+0xb58>
 20432c4:	10803fcc 	andi	r2,r2,255
 20432c8:	1080201c 	xori	r2,r2,128
 20432cc:	10bfe004 	addi	r2,r2,-128
 20432d0:	00c00c04 	movi	r3,48
 20432d4:	10c13426 	beq	r2,r3,20437a8 <___svfprintf_internal_r+0xb58>
 20432d8:	80ffffc5 	stb	r3,-1(r16)
 20432dc:	d8c02817 	ldw	r3,160(sp)
 20432e0:	80bfffc4 	addi	r2,r16,-1
 20432e4:	1021883a 	mov	r16,r2
 20432e8:	1887c83a 	sub	r3,r3,r2
 20432ec:	d8c02e15 	stw	r3,184(sp)
 20432f0:	d8802e17 	ldw	r2,184(sp)
 20432f4:	d9002917 	ldw	r4,164(sp)
 20432f8:	1100010e 	bge	r2,r4,2043300 <___svfprintf_internal_r+0x6b0>
 20432fc:	2005883a 	mov	r2,r4
 2043300:	d8802a15 	stw	r2,168(sp)
 2043304:	d8003215 	stw	zero,200(sp)
 2043308:	e7003fcc 	andi	fp,fp,255
 204330c:	e700201c 	xori	fp,fp,128
 2043310:	e73fe004 	addi	fp,fp,-128
 2043314:	e0000326 	beq	fp,zero,2043324 <___svfprintf_internal_r+0x6d4>
 2043318:	d8c02a17 	ldw	r3,168(sp)
 204331c:	18c00044 	addi	r3,r3,1
 2043320:	d8c02a15 	stw	r3,168(sp)
 2043324:	90c0008c 	andi	r3,r18,2
 2043328:	d8c02b15 	stw	r3,172(sp)
 204332c:	18000326 	beq	r3,zero,204333c <___svfprintf_internal_r+0x6ec>
 2043330:	d8c02a17 	ldw	r3,168(sp)
 2043334:	18c00084 	addi	r3,r3,2
 2043338:	d8c02a15 	stw	r3,168(sp)
 204333c:	90c0210c 	andi	r3,r18,132
 2043340:	d8c03015 	stw	r3,192(sp)
 2043344:	1801a11e 	bne	r3,zero,20439cc <___svfprintf_internal_r+0xd7c>
 2043348:	d9003117 	ldw	r4,196(sp)
 204334c:	d8c02a17 	ldw	r3,168(sp)
 2043350:	20e9c83a 	sub	r20,r4,r3
 2043354:	05019d0e 	bge	zero,r20,20439cc <___svfprintf_internal_r+0xd7c>
 2043358:	02400404 	movi	r9,16
 204335c:	d8c02017 	ldw	r3,128(sp)
 2043360:	d8801f17 	ldw	r2,124(sp)
 2043364:	4d051b0e 	bge	r9,r20,20447d4 <___svfprintf_internal_r+0x1b84>
 2043368:	01408174 	movhi	r5,517
 204336c:	2963db04 	addi	r5,r5,-28820
 2043370:	dc403c15 	stw	r17,240(sp)
 2043374:	d9403515 	stw	r5,212(sp)
 2043378:	a023883a 	mov	r17,r20
 204337c:	482d883a 	mov	r22,r9
 2043380:	9029883a 	mov	r20,r18
 2043384:	070001c4 	movi	fp,7
 2043388:	8025883a 	mov	r18,r16
 204338c:	dc002c17 	ldw	r16,176(sp)
 2043390:	00000306 	br	20433a0 <___svfprintf_internal_r+0x750>
 2043394:	8c7ffc04 	addi	r17,r17,-16
 2043398:	42000204 	addi	r8,r8,8
 204339c:	b440130e 	bge	r22,r17,20433ec <___svfprintf_internal_r+0x79c>
 20433a0:	01008174 	movhi	r4,517
 20433a4:	18c00404 	addi	r3,r3,16
 20433a8:	10800044 	addi	r2,r2,1
 20433ac:	2123db04 	addi	r4,r4,-28820
 20433b0:	41000015 	stw	r4,0(r8)
 20433b4:	45800115 	stw	r22,4(r8)
 20433b8:	d8c02015 	stw	r3,128(sp)
 20433bc:	d8801f15 	stw	r2,124(sp)
 20433c0:	e0bff40e 	bge	fp,r2,2043394 <__alt_mem_mem_0+0xfd023394>
 20433c4:	d9801e04 	addi	r6,sp,120
 20433c8:	800b883a 	mov	r5,r16
 20433cc:	9809883a 	mov	r4,r19
 20433d0:	20450c00 	call	20450c0 <__ssprint_r>
 20433d4:	103f031e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 20433d8:	8c7ffc04 	addi	r17,r17,-16
 20433dc:	d8c02017 	ldw	r3,128(sp)
 20433e0:	d8801f17 	ldw	r2,124(sp)
 20433e4:	da000404 	addi	r8,sp,16
 20433e8:	b47fed16 	blt	r22,r17,20433a0 <__alt_mem_mem_0+0xfd0233a0>
 20433ec:	9021883a 	mov	r16,r18
 20433f0:	a025883a 	mov	r18,r20
 20433f4:	8829883a 	mov	r20,r17
 20433f8:	dc403c17 	ldw	r17,240(sp)
 20433fc:	d9403517 	ldw	r5,212(sp)
 2043400:	a0c7883a 	add	r3,r20,r3
 2043404:	10800044 	addi	r2,r2,1
 2043408:	41400015 	stw	r5,0(r8)
 204340c:	45000115 	stw	r20,4(r8)
 2043410:	d8c02015 	stw	r3,128(sp)
 2043414:	d8801f15 	stw	r2,124(sp)
 2043418:	010001c4 	movi	r4,7
 204341c:	20829f16 	blt	r4,r2,2043e9c <___svfprintf_internal_r+0x124c>
 2043420:	df002787 	ldb	fp,158(sp)
 2043424:	42000204 	addi	r8,r8,8
 2043428:	e0000c26 	beq	fp,zero,204345c <___svfprintf_internal_r+0x80c>
 204342c:	d8801f17 	ldw	r2,124(sp)
 2043430:	d9002784 	addi	r4,sp,158
 2043434:	18c00044 	addi	r3,r3,1
 2043438:	10800044 	addi	r2,r2,1
 204343c:	41000015 	stw	r4,0(r8)
 2043440:	01000044 	movi	r4,1
 2043444:	41000115 	stw	r4,4(r8)
 2043448:	d8c02015 	stw	r3,128(sp)
 204344c:	d8801f15 	stw	r2,124(sp)
 2043450:	010001c4 	movi	r4,7
 2043454:	20823816 	blt	r4,r2,2043d38 <___svfprintf_internal_r+0x10e8>
 2043458:	42000204 	addi	r8,r8,8
 204345c:	d8802b17 	ldw	r2,172(sp)
 2043460:	10000c26 	beq	r2,zero,2043494 <___svfprintf_internal_r+0x844>
 2043464:	d8801f17 	ldw	r2,124(sp)
 2043468:	d9002704 	addi	r4,sp,156
 204346c:	18c00084 	addi	r3,r3,2
 2043470:	10800044 	addi	r2,r2,1
 2043474:	41000015 	stw	r4,0(r8)
 2043478:	01000084 	movi	r4,2
 204347c:	41000115 	stw	r4,4(r8)
 2043480:	d8c02015 	stw	r3,128(sp)
 2043484:	d8801f15 	stw	r2,124(sp)
 2043488:	010001c4 	movi	r4,7
 204348c:	20823216 	blt	r4,r2,2043d58 <___svfprintf_internal_r+0x1108>
 2043490:	42000204 	addi	r8,r8,8
 2043494:	d9003017 	ldw	r4,192(sp)
 2043498:	00802004 	movi	r2,128
 204349c:	20819726 	beq	r4,r2,2043afc <___svfprintf_internal_r+0xeac>
 20434a0:	d9402917 	ldw	r5,164(sp)
 20434a4:	d8802e17 	ldw	r2,184(sp)
 20434a8:	28adc83a 	sub	r22,r5,r2
 20434ac:	05802f0e 	bge	zero,r22,204356c <___svfprintf_internal_r+0x91c>
 20434b0:	07000404 	movi	fp,16
 20434b4:	d8801f17 	ldw	r2,124(sp)
 20434b8:	e583c00e 	bge	fp,r22,20443bc <___svfprintf_internal_r+0x176c>
 20434bc:	01408174 	movhi	r5,517
 20434c0:	2963d704 	addi	r5,r5,-28836
 20434c4:	dc402915 	stw	r17,164(sp)
 20434c8:	d9402b15 	stw	r5,172(sp)
 20434cc:	b023883a 	mov	r17,r22
 20434d0:	050001c4 	movi	r20,7
 20434d4:	902d883a 	mov	r22,r18
 20434d8:	8025883a 	mov	r18,r16
 20434dc:	dc002c17 	ldw	r16,176(sp)
 20434e0:	00000306 	br	20434f0 <___svfprintf_internal_r+0x8a0>
 20434e4:	8c7ffc04 	addi	r17,r17,-16
 20434e8:	42000204 	addi	r8,r8,8
 20434ec:	e440110e 	bge	fp,r17,2043534 <___svfprintf_internal_r+0x8e4>
 20434f0:	18c00404 	addi	r3,r3,16
 20434f4:	10800044 	addi	r2,r2,1
 20434f8:	45400015 	stw	r21,0(r8)
 20434fc:	47000115 	stw	fp,4(r8)
 2043500:	d8c02015 	stw	r3,128(sp)
 2043504:	d8801f15 	stw	r2,124(sp)
 2043508:	a0bff60e 	bge	r20,r2,20434e4 <__alt_mem_mem_0+0xfd0234e4>
 204350c:	d9801e04 	addi	r6,sp,120
 2043510:	800b883a 	mov	r5,r16
 2043514:	9809883a 	mov	r4,r19
 2043518:	20450c00 	call	20450c0 <__ssprint_r>
 204351c:	103eb11e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043520:	8c7ffc04 	addi	r17,r17,-16
 2043524:	d8c02017 	ldw	r3,128(sp)
 2043528:	d8801f17 	ldw	r2,124(sp)
 204352c:	da000404 	addi	r8,sp,16
 2043530:	e47fef16 	blt	fp,r17,20434f0 <__alt_mem_mem_0+0xfd0234f0>
 2043534:	9021883a 	mov	r16,r18
 2043538:	b025883a 	mov	r18,r22
 204353c:	882d883a 	mov	r22,r17
 2043540:	dc402917 	ldw	r17,164(sp)
 2043544:	d9002b17 	ldw	r4,172(sp)
 2043548:	1d87883a 	add	r3,r3,r22
 204354c:	10800044 	addi	r2,r2,1
 2043550:	41000015 	stw	r4,0(r8)
 2043554:	45800115 	stw	r22,4(r8)
 2043558:	d8c02015 	stw	r3,128(sp)
 204355c:	d8801f15 	stw	r2,124(sp)
 2043560:	010001c4 	movi	r4,7
 2043564:	2081ec16 	blt	r4,r2,2043d18 <___svfprintf_internal_r+0x10c8>
 2043568:	42000204 	addi	r8,r8,8
 204356c:	9080400c 	andi	r2,r18,256
 2043570:	1001181e 	bne	r2,zero,20439d4 <___svfprintf_internal_r+0xd84>
 2043574:	d9402e17 	ldw	r5,184(sp)
 2043578:	d8801f17 	ldw	r2,124(sp)
 204357c:	44000015 	stw	r16,0(r8)
 2043580:	1947883a 	add	r3,r3,r5
 2043584:	10800044 	addi	r2,r2,1
 2043588:	41400115 	stw	r5,4(r8)
 204358c:	d8c02015 	stw	r3,128(sp)
 2043590:	d8801f15 	stw	r2,124(sp)
 2043594:	010001c4 	movi	r4,7
 2043598:	2081d116 	blt	r4,r2,2043ce0 <___svfprintf_internal_r+0x1090>
 204359c:	42000204 	addi	r8,r8,8
 20435a0:	9480010c 	andi	r18,r18,4
 20435a4:	90003226 	beq	r18,zero,2043670 <___svfprintf_internal_r+0xa20>
 20435a8:	d9403117 	ldw	r5,196(sp)
 20435ac:	d8802a17 	ldw	r2,168(sp)
 20435b0:	28a1c83a 	sub	r16,r5,r2
 20435b4:	04002e0e 	bge	zero,r16,2043670 <___svfprintf_internal_r+0xa20>
 20435b8:	04400404 	movi	r17,16
 20435bc:	d8801f17 	ldw	r2,124(sp)
 20435c0:	8c04b90e 	bge	r17,r16,20448a8 <___svfprintf_internal_r+0x1c58>
 20435c4:	01408174 	movhi	r5,517
 20435c8:	2963db04 	addi	r5,r5,-28820
 20435cc:	d9403515 	stw	r5,212(sp)
 20435d0:	048001c4 	movi	r18,7
 20435d4:	dd002c17 	ldw	r20,176(sp)
 20435d8:	00000306 	br	20435e8 <___svfprintf_internal_r+0x998>
 20435dc:	843ffc04 	addi	r16,r16,-16
 20435e0:	42000204 	addi	r8,r8,8
 20435e4:	8c00130e 	bge	r17,r16,2043634 <___svfprintf_internal_r+0x9e4>
 20435e8:	01008174 	movhi	r4,517
 20435ec:	18c00404 	addi	r3,r3,16
 20435f0:	10800044 	addi	r2,r2,1
 20435f4:	2123db04 	addi	r4,r4,-28820
 20435f8:	41000015 	stw	r4,0(r8)
 20435fc:	44400115 	stw	r17,4(r8)
 2043600:	d8c02015 	stw	r3,128(sp)
 2043604:	d8801f15 	stw	r2,124(sp)
 2043608:	90bff40e 	bge	r18,r2,20435dc <__alt_mem_mem_0+0xfd0235dc>
 204360c:	d9801e04 	addi	r6,sp,120
 2043610:	a00b883a 	mov	r5,r20
 2043614:	9809883a 	mov	r4,r19
 2043618:	20450c00 	call	20450c0 <__ssprint_r>
 204361c:	103e711e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043620:	843ffc04 	addi	r16,r16,-16
 2043624:	d8c02017 	ldw	r3,128(sp)
 2043628:	d8801f17 	ldw	r2,124(sp)
 204362c:	da000404 	addi	r8,sp,16
 2043630:	8c3fed16 	blt	r17,r16,20435e8 <__alt_mem_mem_0+0xfd0235e8>
 2043634:	d9403517 	ldw	r5,212(sp)
 2043638:	1c07883a 	add	r3,r3,r16
 204363c:	10800044 	addi	r2,r2,1
 2043640:	41400015 	stw	r5,0(r8)
 2043644:	44000115 	stw	r16,4(r8)
 2043648:	d8c02015 	stw	r3,128(sp)
 204364c:	d8801f15 	stw	r2,124(sp)
 2043650:	010001c4 	movi	r4,7
 2043654:	2080060e 	bge	r4,r2,2043670 <___svfprintf_internal_r+0xa20>
 2043658:	d9402c17 	ldw	r5,176(sp)
 204365c:	d9801e04 	addi	r6,sp,120
 2043660:	9809883a 	mov	r4,r19
 2043664:	20450c00 	call	20450c0 <__ssprint_r>
 2043668:	103e5e1e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 204366c:	d8c02017 	ldw	r3,128(sp)
 2043670:	d8803117 	ldw	r2,196(sp)
 2043674:	d9002a17 	ldw	r4,168(sp)
 2043678:	1100010e 	bge	r2,r4,2043680 <___svfprintf_internal_r+0xa30>
 204367c:	2005883a 	mov	r2,r4
 2043680:	d9402f17 	ldw	r5,188(sp)
 2043684:	288b883a 	add	r5,r5,r2
 2043688:	d9402f15 	stw	r5,188(sp)
 204368c:	18019c1e 	bne	r3,zero,2043d00 <___svfprintf_internal_r+0x10b0>
 2043690:	b8800007 	ldb	r2,0(r23)
 2043694:	d8001f15 	stw	zero,124(sp)
 2043698:	da000404 	addi	r8,sp,16
 204369c:	103d991e 	bne	r2,zero,2042d04 <__alt_mem_mem_0+0xfd022d04>
 20436a0:	b821883a 	mov	r16,r23
 20436a4:	003daf06 	br	2042d64 <__alt_mem_mem_0+0xfd022d64>
 20436a8:	18c03fcc 	andi	r3,r3,255
 20436ac:	1805c71e 	bne	r3,zero,2044dcc <___svfprintf_internal_r+0x217c>
 20436b0:	94800414 	ori	r18,r18,16
 20436b4:	9080080c 	andi	r2,r18,32
 20436b8:	10020126 	beq	r2,zero,2043ec0 <___svfprintf_internal_r+0x1270>
 20436bc:	d8802d17 	ldw	r2,180(sp)
 20436c0:	d9002917 	ldw	r4,164(sp)
 20436c4:	d8002785 	stb	zero,158(sp)
 20436c8:	10c00204 	addi	r3,r2,8
 20436cc:	15000017 	ldw	r20,0(r2)
 20436d0:	15800117 	ldw	r22,4(r2)
 20436d4:	20038e16 	blt	r4,zero,2044510 <___svfprintf_internal_r+0x18c0>
 20436d8:	013fdfc4 	movi	r4,-129
 20436dc:	a584b03a 	or	r2,r20,r22
 20436e0:	d8c02d15 	stw	r3,180(sp)
 20436e4:	9124703a 	and	r18,r18,r4
 20436e8:	0039883a 	mov	fp,zero
 20436ec:	103eb61e 	bne	r2,zero,20431c8 <__alt_mem_mem_0+0xfd0231c8>
 20436f0:	d8802917 	ldw	r2,164(sp)
 20436f4:	1002c81e 	bne	r2,zero,2044218 <___svfprintf_internal_r+0x15c8>
 20436f8:	d8002915 	stw	zero,164(sp)
 20436fc:	d8002e15 	stw	zero,184(sp)
 2043700:	dc001e04 	addi	r16,sp,120
 2043704:	003efa06 	br	20432f0 <__alt_mem_mem_0+0xfd0232f0>
 2043708:	18c03fcc 	andi	r3,r3,255
 204370c:	1805ad1e 	bne	r3,zero,2044dc4 <___svfprintf_internal_r+0x2174>
 2043710:	01408134 	movhi	r5,516
 2043714:	295a8004 	addi	r5,r5,27136
 2043718:	d9403a15 	stw	r5,232(sp)
 204371c:	9080080c 	andi	r2,r18,32
 2043720:	10006126 	beq	r2,zero,20438a8 <___svfprintf_internal_r+0xc58>
 2043724:	d8802d17 	ldw	r2,180(sp)
 2043728:	15000017 	ldw	r20,0(r2)
 204372c:	15800117 	ldw	r22,4(r2)
 2043730:	10800204 	addi	r2,r2,8
 2043734:	d8802d15 	stw	r2,180(sp)
 2043738:	9080004c 	andi	r2,r18,1
 204373c:	10018e26 	beq	r2,zero,2043d78 <___svfprintf_internal_r+0x1128>
 2043740:	a584b03a 	or	r2,r20,r22
 2043744:	10030926 	beq	r2,zero,204436c <___svfprintf_internal_r+0x171c>
 2043748:	d8c02917 	ldw	r3,164(sp)
 204374c:	00800c04 	movi	r2,48
 2043750:	d8802705 	stb	r2,156(sp)
 2043754:	dc402745 	stb	r17,157(sp)
 2043758:	d8002785 	stb	zero,158(sp)
 204375c:	90800094 	ori	r2,r18,2
 2043760:	18048716 	blt	r3,zero,2044980 <___svfprintf_internal_r+0x1d30>
 2043764:	00bfdfc4 	movi	r2,-129
 2043768:	90a4703a 	and	r18,r18,r2
 204376c:	94800094 	ori	r18,r18,2
 2043770:	0039883a 	mov	fp,zero
 2043774:	d9003a17 	ldw	r4,232(sp)
 2043778:	dc001e04 	addi	r16,sp,120
 204377c:	a08003cc 	andi	r2,r20,15
 2043780:	b006973a 	slli	r3,r22,28
 2043784:	2085883a 	add	r2,r4,r2
 2043788:	a028d13a 	srli	r20,r20,4
 204378c:	10800003 	ldbu	r2,0(r2)
 2043790:	b02cd13a 	srli	r22,r22,4
 2043794:	843fffc4 	addi	r16,r16,-1
 2043798:	1d28b03a 	or	r20,r3,r20
 204379c:	80800005 	stb	r2,0(r16)
 20437a0:	a584b03a 	or	r2,r20,r22
 20437a4:	103ff51e 	bne	r2,zero,204377c <__alt_mem_mem_0+0xfd02377c>
 20437a8:	d8c02817 	ldw	r3,160(sp)
 20437ac:	1c07c83a 	sub	r3,r3,r16
 20437b0:	d8c02e15 	stw	r3,184(sp)
 20437b4:	003ece06 	br	20432f0 <__alt_mem_mem_0+0xfd0232f0>
 20437b8:	d8c02d17 	ldw	r3,180(sp)
 20437bc:	d9002d17 	ldw	r4,180(sp)
 20437c0:	d8002785 	stb	zero,158(sp)
 20437c4:	18800017 	ldw	r2,0(r3)
 20437c8:	21000104 	addi	r4,r4,4
 20437cc:	00c00044 	movi	r3,1
 20437d0:	d8c02a15 	stw	r3,168(sp)
 20437d4:	d8801405 	stb	r2,80(sp)
 20437d8:	d9002d15 	stw	r4,180(sp)
 20437dc:	d8c02e15 	stw	r3,184(sp)
 20437e0:	d8002915 	stw	zero,164(sp)
 20437e4:	d8003215 	stw	zero,200(sp)
 20437e8:	dc001404 	addi	r16,sp,80
 20437ec:	0039883a 	mov	fp,zero
 20437f0:	003ecc06 	br	2043324 <__alt_mem_mem_0+0xfd023324>
 20437f4:	18c03fcc 	andi	r3,r3,255
 20437f8:	183e9226 	beq	r3,zero,2043244 <__alt_mem_mem_0+0xfd023244>
 20437fc:	d9c02785 	stb	r7,158(sp)
 2043800:	003e9006 	br	2043244 <__alt_mem_mem_0+0xfd023244>
 2043804:	00c00044 	movi	r3,1
 2043808:	01c00ac4 	movi	r7,43
 204380c:	bc400007 	ldb	r17,0(r23)
 2043810:	003d6306 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2043814:	94800814 	ori	r18,r18,32
 2043818:	bc400007 	ldb	r17,0(r23)
 204381c:	003d6006 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2043820:	d8c02d17 	ldw	r3,180(sp)
 2043824:	d8002785 	stb	zero,158(sp)
 2043828:	1c000017 	ldw	r16,0(r3)
 204382c:	1d000104 	addi	r20,r3,4
 2043830:	80040f26 	beq	r16,zero,2044870 <___svfprintf_internal_r+0x1c20>
 2043834:	d9002917 	ldw	r4,164(sp)
 2043838:	2003dc16 	blt	r4,zero,20447ac <___svfprintf_internal_r+0x1b5c>
 204383c:	200d883a 	mov	r6,r4
 2043840:	000b883a 	mov	r5,zero
 2043844:	8009883a 	mov	r4,r16
 2043848:	da003e15 	stw	r8,248(sp)
 204384c:	2005d740 	call	2005d74 <memchr>
 2043850:	da003e17 	ldw	r8,248(sp)
 2043854:	10045826 	beq	r2,zero,20449b8 <___svfprintf_internal_r+0x1d68>
 2043858:	1405c83a 	sub	r2,r2,r16
 204385c:	d8802e15 	stw	r2,184(sp)
 2043860:	1003d816 	blt	r2,zero,20447c4 <___svfprintf_internal_r+0x1b74>
 2043864:	df002783 	ldbu	fp,158(sp)
 2043868:	d8802a15 	stw	r2,168(sp)
 204386c:	dd002d15 	stw	r20,180(sp)
 2043870:	d8002915 	stw	zero,164(sp)
 2043874:	d8003215 	stw	zero,200(sp)
 2043878:	003ea306 	br	2043308 <__alt_mem_mem_0+0xfd023308>
 204387c:	18c03fcc 	andi	r3,r3,255
 2043880:	183f8c26 	beq	r3,zero,20436b4 <__alt_mem_mem_0+0xfd0236b4>
 2043884:	d9c02785 	stb	r7,158(sp)
 2043888:	003f8a06 	br	20436b4 <__alt_mem_mem_0+0xfd0236b4>
 204388c:	18c03fcc 	andi	r3,r3,255
 2043890:	1805631e 	bne	r3,zero,2044e20 <___svfprintf_internal_r+0x21d0>
 2043894:	01408134 	movhi	r5,516
 2043898:	295a8504 	addi	r5,r5,27156
 204389c:	d9403a15 	stw	r5,232(sp)
 20438a0:	9080080c 	andi	r2,r18,32
 20438a4:	103f9f1e 	bne	r2,zero,2043724 <__alt_mem_mem_0+0xfd023724>
 20438a8:	9080040c 	andi	r2,r18,16
 20438ac:	10029c26 	beq	r2,zero,2044320 <___svfprintf_internal_r+0x16d0>
 20438b0:	d8c02d17 	ldw	r3,180(sp)
 20438b4:	002d883a 	mov	r22,zero
 20438b8:	1d000017 	ldw	r20,0(r3)
 20438bc:	18c00104 	addi	r3,r3,4
 20438c0:	d8c02d15 	stw	r3,180(sp)
 20438c4:	003f9c06 	br	2043738 <__alt_mem_mem_0+0xfd023738>
 20438c8:	94800054 	ori	r18,r18,1
 20438cc:	bc400007 	ldb	r17,0(r23)
 20438d0:	003d3306 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 20438d4:	38803fcc 	andi	r2,r7,255
 20438d8:	1080201c 	xori	r2,r2,128
 20438dc:	10bfe004 	addi	r2,r2,-128
 20438e0:	1002971e 	bne	r2,zero,2044340 <___svfprintf_internal_r+0x16f0>
 20438e4:	00c00044 	movi	r3,1
 20438e8:	01c00804 	movi	r7,32
 20438ec:	bc400007 	ldb	r17,0(r23)
 20438f0:	003d2b06 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 20438f4:	18c03fcc 	andi	r3,r3,255
 20438f8:	183e2326 	beq	r3,zero,2043188 <__alt_mem_mem_0+0xfd023188>
 20438fc:	d9c02785 	stb	r7,158(sp)
 2043900:	003e2106 	br	2043188 <__alt_mem_mem_0+0xfd023188>
 2043904:	bc400007 	ldb	r17,0(r23)
 2043908:	8a430426 	beq	r17,r9,204451c <___svfprintf_internal_r+0x18cc>
 204390c:	94800414 	ori	r18,r18,16
 2043910:	003d2306 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2043914:	18c03fcc 	andi	r3,r3,255
 2043918:	18053f1e 	bne	r3,zero,2044e18 <___svfprintf_internal_r+0x21c8>
 204391c:	9080080c 	andi	r2,r18,32
 2043920:	10028926 	beq	r2,zero,2044348 <___svfprintf_internal_r+0x16f8>
 2043924:	d9402d17 	ldw	r5,180(sp)
 2043928:	d9002f17 	ldw	r4,188(sp)
 204392c:	28800017 	ldw	r2,0(r5)
 2043930:	2007d7fa 	srai	r3,r4,31
 2043934:	29400104 	addi	r5,r5,4
 2043938:	d9402d15 	stw	r5,180(sp)
 204393c:	11000015 	stw	r4,0(r2)
 2043940:	10c00115 	stw	r3,4(r2)
 2043944:	003ced06 	br	2042cfc <__alt_mem_mem_0+0xfd022cfc>
 2043948:	94801014 	ori	r18,r18,64
 204394c:	bc400007 	ldb	r17,0(r23)
 2043950:	003d1306 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2043954:	01008134 	movhi	r4,516
 2043958:	211a8504 	addi	r4,r4,27156
 204395c:	0039883a 	mov	fp,zero
 2043960:	d9003a15 	stw	r4,232(sp)
 2043964:	04401e04 	movi	r17,120
 2043968:	003f8206 	br	2043774 <__alt_mem_mem_0+0xfd023774>
 204396c:	18c03fcc 	andi	r3,r3,255
 2043970:	1805221e 	bne	r3,zero,2044dfc <___svfprintf_internal_r+0x21ac>
 2043974:	883d9526 	beq	r17,zero,2042fcc <__alt_mem_mem_0+0xfd022fcc>
 2043978:	00c00044 	movi	r3,1
 204397c:	d8c02a15 	stw	r3,168(sp)
 2043980:	dc401405 	stb	r17,80(sp)
 2043984:	d8002785 	stb	zero,158(sp)
 2043988:	003f9406 	br	20437dc <__alt_mem_mem_0+0xfd0237dc>
 204398c:	01008134 	movhi	r4,516
 2043990:	211a8504 	addi	r4,r4,27156
 2043994:	d9003a15 	stw	r4,232(sp)
 2043998:	d8c02d15 	stw	r3,180(sp)
 204399c:	1025883a 	mov	r18,r2
 20439a0:	04401e04 	movi	r17,120
 20439a4:	a584b03a 	or	r2,r20,r22
 20439a8:	1000fa1e 	bne	r2,zero,2043d94 <___svfprintf_internal_r+0x1144>
 20439ac:	0039883a 	mov	fp,zero
 20439b0:	00800084 	movi	r2,2
 20439b4:	10803fcc 	andi	r2,r2,255
 20439b8:	00c00044 	movi	r3,1
 20439bc:	10c21626 	beq	r2,r3,2044218 <___svfprintf_internal_r+0x15c8>
 20439c0:	00c00084 	movi	r3,2
 20439c4:	10fe301e 	bne	r2,r3,2043288 <__alt_mem_mem_0+0xfd023288>
 20439c8:	003d7606 	br	2042fa4 <__alt_mem_mem_0+0xfd022fa4>
 20439cc:	d8c02017 	ldw	r3,128(sp)
 20439d0:	003e9506 	br	2043428 <__alt_mem_mem_0+0xfd023428>
 20439d4:	00801944 	movi	r2,101
 20439d8:	14407c0e 	bge	r2,r17,2043bcc <___svfprintf_internal_r+0xf7c>
 20439dc:	d9003617 	ldw	r4,216(sp)
 20439e0:	d9403717 	ldw	r5,220(sp)
 20439e4:	000d883a 	mov	r6,zero
 20439e8:	000f883a 	mov	r7,zero
 20439ec:	d8c03d15 	stw	r3,244(sp)
 20439f0:	da003e15 	stw	r8,248(sp)
 20439f4:	200bd2c0 	call	200bd2c <__eqdf2>
 20439f8:	d8c03d17 	ldw	r3,244(sp)
 20439fc:	da003e17 	ldw	r8,248(sp)
 2043a00:	1000f51e 	bne	r2,zero,2043dd8 <___svfprintf_internal_r+0x1188>
 2043a04:	d8801f17 	ldw	r2,124(sp)
 2043a08:	01008134 	movhi	r4,516
 2043a0c:	211a8c04 	addi	r4,r4,27184
 2043a10:	18c00044 	addi	r3,r3,1
 2043a14:	10800044 	addi	r2,r2,1
 2043a18:	41000015 	stw	r4,0(r8)
 2043a1c:	01000044 	movi	r4,1
 2043a20:	41000115 	stw	r4,4(r8)
 2043a24:	d8c02015 	stw	r3,128(sp)
 2043a28:	d8801f15 	stw	r2,124(sp)
 2043a2c:	010001c4 	movi	r4,7
 2043a30:	20826616 	blt	r4,r2,20443cc <___svfprintf_internal_r+0x177c>
 2043a34:	42000204 	addi	r8,r8,8
 2043a38:	d8802617 	ldw	r2,152(sp)
 2043a3c:	d9403317 	ldw	r5,204(sp)
 2043a40:	11400216 	blt	r2,r5,2043a4c <___svfprintf_internal_r+0xdfc>
 2043a44:	9080004c 	andi	r2,r18,1
 2043a48:	103ed526 	beq	r2,zero,20435a0 <__alt_mem_mem_0+0xfd0235a0>
 2043a4c:	d8803817 	ldw	r2,224(sp)
 2043a50:	d9003417 	ldw	r4,208(sp)
 2043a54:	d9403817 	ldw	r5,224(sp)
 2043a58:	1887883a 	add	r3,r3,r2
 2043a5c:	d8801f17 	ldw	r2,124(sp)
 2043a60:	41000015 	stw	r4,0(r8)
 2043a64:	41400115 	stw	r5,4(r8)
 2043a68:	10800044 	addi	r2,r2,1
 2043a6c:	d8c02015 	stw	r3,128(sp)
 2043a70:	d8801f15 	stw	r2,124(sp)
 2043a74:	010001c4 	movi	r4,7
 2043a78:	2082af16 	blt	r4,r2,2044538 <___svfprintf_internal_r+0x18e8>
 2043a7c:	42000204 	addi	r8,r8,8
 2043a80:	d8803317 	ldw	r2,204(sp)
 2043a84:	143fffc4 	addi	r16,r2,-1
 2043a88:	043ec50e 	bge	zero,r16,20435a0 <__alt_mem_mem_0+0xfd0235a0>
 2043a8c:	04400404 	movi	r17,16
 2043a90:	d8801f17 	ldw	r2,124(sp)
 2043a94:	8c00860e 	bge	r17,r16,2043cb0 <___svfprintf_internal_r+0x1060>
 2043a98:	01408174 	movhi	r5,517
 2043a9c:	2963d704 	addi	r5,r5,-28836
 2043aa0:	d9402b15 	stw	r5,172(sp)
 2043aa4:	058001c4 	movi	r22,7
 2043aa8:	dd002c17 	ldw	r20,176(sp)
 2043aac:	00000306 	br	2043abc <___svfprintf_internal_r+0xe6c>
 2043ab0:	42000204 	addi	r8,r8,8
 2043ab4:	843ffc04 	addi	r16,r16,-16
 2043ab8:	8c00800e 	bge	r17,r16,2043cbc <___svfprintf_internal_r+0x106c>
 2043abc:	18c00404 	addi	r3,r3,16
 2043ac0:	10800044 	addi	r2,r2,1
 2043ac4:	45400015 	stw	r21,0(r8)
 2043ac8:	44400115 	stw	r17,4(r8)
 2043acc:	d8c02015 	stw	r3,128(sp)
 2043ad0:	d8801f15 	stw	r2,124(sp)
 2043ad4:	b0bff60e 	bge	r22,r2,2043ab0 <__alt_mem_mem_0+0xfd023ab0>
 2043ad8:	d9801e04 	addi	r6,sp,120
 2043adc:	a00b883a 	mov	r5,r20
 2043ae0:	9809883a 	mov	r4,r19
 2043ae4:	20450c00 	call	20450c0 <__ssprint_r>
 2043ae8:	103d3e1e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043aec:	d8c02017 	ldw	r3,128(sp)
 2043af0:	d8801f17 	ldw	r2,124(sp)
 2043af4:	da000404 	addi	r8,sp,16
 2043af8:	003fee06 	br	2043ab4 <__alt_mem_mem_0+0xfd023ab4>
 2043afc:	d9403117 	ldw	r5,196(sp)
 2043b00:	d8802a17 	ldw	r2,168(sp)
 2043b04:	28adc83a 	sub	r22,r5,r2
 2043b08:	05be650e 	bge	zero,r22,20434a0 <__alt_mem_mem_0+0xfd0234a0>
 2043b0c:	07000404 	movi	fp,16
 2043b10:	d8801f17 	ldw	r2,124(sp)
 2043b14:	e583a20e 	bge	fp,r22,20449a0 <___svfprintf_internal_r+0x1d50>
 2043b18:	01408174 	movhi	r5,517
 2043b1c:	2963d704 	addi	r5,r5,-28836
 2043b20:	dc403015 	stw	r17,192(sp)
 2043b24:	d9402b15 	stw	r5,172(sp)
 2043b28:	b023883a 	mov	r17,r22
 2043b2c:	050001c4 	movi	r20,7
 2043b30:	902d883a 	mov	r22,r18
 2043b34:	8025883a 	mov	r18,r16
 2043b38:	dc002c17 	ldw	r16,176(sp)
 2043b3c:	00000306 	br	2043b4c <___svfprintf_internal_r+0xefc>
 2043b40:	8c7ffc04 	addi	r17,r17,-16
 2043b44:	42000204 	addi	r8,r8,8
 2043b48:	e440110e 	bge	fp,r17,2043b90 <___svfprintf_internal_r+0xf40>
 2043b4c:	18c00404 	addi	r3,r3,16
 2043b50:	10800044 	addi	r2,r2,1
 2043b54:	45400015 	stw	r21,0(r8)
 2043b58:	47000115 	stw	fp,4(r8)
 2043b5c:	d8c02015 	stw	r3,128(sp)
 2043b60:	d8801f15 	stw	r2,124(sp)
 2043b64:	a0bff60e 	bge	r20,r2,2043b40 <__alt_mem_mem_0+0xfd023b40>
 2043b68:	d9801e04 	addi	r6,sp,120
 2043b6c:	800b883a 	mov	r5,r16
 2043b70:	9809883a 	mov	r4,r19
 2043b74:	20450c00 	call	20450c0 <__ssprint_r>
 2043b78:	103d1a1e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043b7c:	8c7ffc04 	addi	r17,r17,-16
 2043b80:	d8c02017 	ldw	r3,128(sp)
 2043b84:	d8801f17 	ldw	r2,124(sp)
 2043b88:	da000404 	addi	r8,sp,16
 2043b8c:	e47fef16 	blt	fp,r17,2043b4c <__alt_mem_mem_0+0xfd023b4c>
 2043b90:	9021883a 	mov	r16,r18
 2043b94:	b025883a 	mov	r18,r22
 2043b98:	882d883a 	mov	r22,r17
 2043b9c:	dc403017 	ldw	r17,192(sp)
 2043ba0:	d9002b17 	ldw	r4,172(sp)
 2043ba4:	1d87883a 	add	r3,r3,r22
 2043ba8:	10800044 	addi	r2,r2,1
 2043bac:	41000015 	stw	r4,0(r8)
 2043bb0:	45800115 	stw	r22,4(r8)
 2043bb4:	d8c02015 	stw	r3,128(sp)
 2043bb8:	d8801f15 	stw	r2,124(sp)
 2043bbc:	010001c4 	movi	r4,7
 2043bc0:	20819a16 	blt	r4,r2,204422c <___svfprintf_internal_r+0x15dc>
 2043bc4:	42000204 	addi	r8,r8,8
 2043bc8:	003e3506 	br	20434a0 <__alt_mem_mem_0+0xfd0234a0>
 2043bcc:	d9403317 	ldw	r5,204(sp)
 2043bd0:	00800044 	movi	r2,1
 2043bd4:	18c00044 	addi	r3,r3,1
 2043bd8:	1141710e 	bge	r2,r5,20441a0 <___svfprintf_internal_r+0x1550>
 2043bdc:	dc401f17 	ldw	r17,124(sp)
 2043be0:	00800044 	movi	r2,1
 2043be4:	40800115 	stw	r2,4(r8)
 2043be8:	8c400044 	addi	r17,r17,1
 2043bec:	44000015 	stw	r16,0(r8)
 2043bf0:	d8c02015 	stw	r3,128(sp)
 2043bf4:	dc401f15 	stw	r17,124(sp)
 2043bf8:	008001c4 	movi	r2,7
 2043bfc:	14417416 	blt	r2,r17,20441d0 <___svfprintf_internal_r+0x1580>
 2043c00:	42000204 	addi	r8,r8,8
 2043c04:	d8803817 	ldw	r2,224(sp)
 2043c08:	d9003417 	ldw	r4,208(sp)
 2043c0c:	8c400044 	addi	r17,r17,1
 2043c10:	10c7883a 	add	r3,r2,r3
 2043c14:	40800115 	stw	r2,4(r8)
 2043c18:	41000015 	stw	r4,0(r8)
 2043c1c:	d8c02015 	stw	r3,128(sp)
 2043c20:	dc401f15 	stw	r17,124(sp)
 2043c24:	008001c4 	movi	r2,7
 2043c28:	14417216 	blt	r2,r17,20441f4 <___svfprintf_internal_r+0x15a4>
 2043c2c:	45800204 	addi	r22,r8,8
 2043c30:	d9003617 	ldw	r4,216(sp)
 2043c34:	d9403717 	ldw	r5,220(sp)
 2043c38:	000d883a 	mov	r6,zero
 2043c3c:	000f883a 	mov	r7,zero
 2043c40:	d8c03d15 	stw	r3,244(sp)
 2043c44:	200bd2c0 	call	200bd2c <__eqdf2>
 2043c48:	d8c03d17 	ldw	r3,244(sp)
 2043c4c:	1000b326 	beq	r2,zero,2043f1c <___svfprintf_internal_r+0x12cc>
 2043c50:	d9403317 	ldw	r5,204(sp)
 2043c54:	84000044 	addi	r16,r16,1
 2043c58:	8c400044 	addi	r17,r17,1
 2043c5c:	28bfffc4 	addi	r2,r5,-1
 2043c60:	1887883a 	add	r3,r3,r2
 2043c64:	b0800115 	stw	r2,4(r22)
 2043c68:	b4000015 	stw	r16,0(r22)
 2043c6c:	d8c02015 	stw	r3,128(sp)
 2043c70:	dc401f15 	stw	r17,124(sp)
 2043c74:	008001c4 	movi	r2,7
 2043c78:	1440d216 	blt	r2,r17,2043fc4 <___svfprintf_internal_r+0x1374>
 2043c7c:	b5800204 	addi	r22,r22,8
 2043c80:	d9003b17 	ldw	r4,236(sp)
 2043c84:	df0022c4 	addi	fp,sp,139
 2043c88:	8c400044 	addi	r17,r17,1
 2043c8c:	20c7883a 	add	r3,r4,r3
 2043c90:	b7000015 	stw	fp,0(r22)
 2043c94:	b1000115 	stw	r4,4(r22)
 2043c98:	d8c02015 	stw	r3,128(sp)
 2043c9c:	dc401f15 	stw	r17,124(sp)
 2043ca0:	008001c4 	movi	r2,7
 2043ca4:	14400e16 	blt	r2,r17,2043ce0 <___svfprintf_internal_r+0x1090>
 2043ca8:	b2000204 	addi	r8,r22,8
 2043cac:	003e3c06 	br	20435a0 <__alt_mem_mem_0+0xfd0235a0>
 2043cb0:	01008174 	movhi	r4,517
 2043cb4:	2123d704 	addi	r4,r4,-28836
 2043cb8:	d9002b15 	stw	r4,172(sp)
 2043cbc:	d9002b17 	ldw	r4,172(sp)
 2043cc0:	1c07883a 	add	r3,r3,r16
 2043cc4:	44000115 	stw	r16,4(r8)
 2043cc8:	41000015 	stw	r4,0(r8)
 2043ccc:	10800044 	addi	r2,r2,1
 2043cd0:	d8c02015 	stw	r3,128(sp)
 2043cd4:	d8801f15 	stw	r2,124(sp)
 2043cd8:	010001c4 	movi	r4,7
 2043cdc:	20be2f0e 	bge	r4,r2,204359c <__alt_mem_mem_0+0xfd02359c>
 2043ce0:	d9402c17 	ldw	r5,176(sp)
 2043ce4:	d9801e04 	addi	r6,sp,120
 2043ce8:	9809883a 	mov	r4,r19
 2043cec:	20450c00 	call	20450c0 <__ssprint_r>
 2043cf0:	103cbc1e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043cf4:	d8c02017 	ldw	r3,128(sp)
 2043cf8:	da000404 	addi	r8,sp,16
 2043cfc:	003e2806 	br	20435a0 <__alt_mem_mem_0+0xfd0235a0>
 2043d00:	d9402c17 	ldw	r5,176(sp)
 2043d04:	d9801e04 	addi	r6,sp,120
 2043d08:	9809883a 	mov	r4,r19
 2043d0c:	20450c00 	call	20450c0 <__ssprint_r>
 2043d10:	103e5f26 	beq	r2,zero,2043690 <__alt_mem_mem_0+0xfd023690>
 2043d14:	003cb306 	br	2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043d18:	d9402c17 	ldw	r5,176(sp)
 2043d1c:	d9801e04 	addi	r6,sp,120
 2043d20:	9809883a 	mov	r4,r19
 2043d24:	20450c00 	call	20450c0 <__ssprint_r>
 2043d28:	103cae1e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043d2c:	d8c02017 	ldw	r3,128(sp)
 2043d30:	da000404 	addi	r8,sp,16
 2043d34:	003e0d06 	br	204356c <__alt_mem_mem_0+0xfd02356c>
 2043d38:	d9402c17 	ldw	r5,176(sp)
 2043d3c:	d9801e04 	addi	r6,sp,120
 2043d40:	9809883a 	mov	r4,r19
 2043d44:	20450c00 	call	20450c0 <__ssprint_r>
 2043d48:	103ca61e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043d4c:	d8c02017 	ldw	r3,128(sp)
 2043d50:	da000404 	addi	r8,sp,16
 2043d54:	003dc106 	br	204345c <__alt_mem_mem_0+0xfd02345c>
 2043d58:	d9402c17 	ldw	r5,176(sp)
 2043d5c:	d9801e04 	addi	r6,sp,120
 2043d60:	9809883a 	mov	r4,r19
 2043d64:	20450c00 	call	20450c0 <__ssprint_r>
 2043d68:	103c9e1e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043d6c:	d8c02017 	ldw	r3,128(sp)
 2043d70:	da000404 	addi	r8,sp,16
 2043d74:	003dc706 	br	2043494 <__alt_mem_mem_0+0xfd023494>
 2043d78:	d8802917 	ldw	r2,164(sp)
 2043d7c:	d8002785 	stb	zero,158(sp)
 2043d80:	103f0816 	blt	r2,zero,20439a4 <__alt_mem_mem_0+0xfd0239a4>
 2043d84:	00ffdfc4 	movi	r3,-129
 2043d88:	a584b03a 	or	r2,r20,r22
 2043d8c:	90e4703a 	and	r18,r18,r3
 2043d90:	103c8126 	beq	r2,zero,2042f98 <__alt_mem_mem_0+0xfd022f98>
 2043d94:	0039883a 	mov	fp,zero
 2043d98:	003e7606 	br	2043774 <__alt_mem_mem_0+0xfd023774>
 2043d9c:	9080040c 	andi	r2,r18,16
 2043da0:	10013d26 	beq	r2,zero,2044298 <___svfprintf_internal_r+0x1648>
 2043da4:	d9002d17 	ldw	r4,180(sp)
 2043da8:	d9402917 	ldw	r5,164(sp)
 2043dac:	d8002785 	stb	zero,158(sp)
 2043db0:	20800104 	addi	r2,r4,4
 2043db4:	25000017 	ldw	r20,0(r4)
 2043db8:	002d883a 	mov	r22,zero
 2043dbc:	28013f16 	blt	r5,zero,20442bc <___svfprintf_internal_r+0x166c>
 2043dc0:	00ffdfc4 	movi	r3,-129
 2043dc4:	d8802d15 	stw	r2,180(sp)
 2043dc8:	90e4703a 	and	r18,r18,r3
 2043dcc:	a03d2b26 	beq	r20,zero,204327c <__alt_mem_mem_0+0xfd02327c>
 2043dd0:	0039883a 	mov	fp,zero
 2043dd4:	003d2e06 	br	2043290 <__alt_mem_mem_0+0xfd023290>
 2043dd8:	dc402617 	ldw	r17,152(sp)
 2043ddc:	0441830e 	bge	zero,r17,20443ec <___svfprintf_internal_r+0x179c>
 2043de0:	dc403217 	ldw	r17,200(sp)
 2043de4:	d8803317 	ldw	r2,204(sp)
 2043de8:	1440010e 	bge	r2,r17,2043df0 <___svfprintf_internal_r+0x11a0>
 2043dec:	1023883a 	mov	r17,r2
 2043df0:	04400a0e 	bge	zero,r17,2043e1c <___svfprintf_internal_r+0x11cc>
 2043df4:	d8801f17 	ldw	r2,124(sp)
 2043df8:	1c47883a 	add	r3,r3,r17
 2043dfc:	44000015 	stw	r16,0(r8)
 2043e00:	10800044 	addi	r2,r2,1
 2043e04:	44400115 	stw	r17,4(r8)
 2043e08:	d8c02015 	stw	r3,128(sp)
 2043e0c:	d8801f15 	stw	r2,124(sp)
 2043e10:	010001c4 	movi	r4,7
 2043e14:	20827516 	blt	r4,r2,20447ec <___svfprintf_internal_r+0x1b9c>
 2043e18:	42000204 	addi	r8,r8,8
 2043e1c:	88027b16 	blt	r17,zero,204480c <___svfprintf_internal_r+0x1bbc>
 2043e20:	d9003217 	ldw	r4,200(sp)
 2043e24:	2463c83a 	sub	r17,r4,r17
 2043e28:	0440990e 	bge	zero,r17,2044090 <___svfprintf_internal_r+0x1440>
 2043e2c:	05800404 	movi	r22,16
 2043e30:	d8801f17 	ldw	r2,124(sp)
 2043e34:	b441530e 	bge	r22,r17,2044384 <___svfprintf_internal_r+0x1734>
 2043e38:	01008174 	movhi	r4,517
 2043e3c:	2123d704 	addi	r4,r4,-28836
 2043e40:	d9002b15 	stw	r4,172(sp)
 2043e44:	070001c4 	movi	fp,7
 2043e48:	dd002c17 	ldw	r20,176(sp)
 2043e4c:	00000306 	br	2043e5c <___svfprintf_internal_r+0x120c>
 2043e50:	42000204 	addi	r8,r8,8
 2043e54:	8c7ffc04 	addi	r17,r17,-16
 2043e58:	b4414d0e 	bge	r22,r17,2044390 <___svfprintf_internal_r+0x1740>
 2043e5c:	18c00404 	addi	r3,r3,16
 2043e60:	10800044 	addi	r2,r2,1
 2043e64:	45400015 	stw	r21,0(r8)
 2043e68:	45800115 	stw	r22,4(r8)
 2043e6c:	d8c02015 	stw	r3,128(sp)
 2043e70:	d8801f15 	stw	r2,124(sp)
 2043e74:	e0bff60e 	bge	fp,r2,2043e50 <__alt_mem_mem_0+0xfd023e50>
 2043e78:	d9801e04 	addi	r6,sp,120
 2043e7c:	a00b883a 	mov	r5,r20
 2043e80:	9809883a 	mov	r4,r19
 2043e84:	20450c00 	call	20450c0 <__ssprint_r>
 2043e88:	103c561e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043e8c:	d8c02017 	ldw	r3,128(sp)
 2043e90:	d8801f17 	ldw	r2,124(sp)
 2043e94:	da000404 	addi	r8,sp,16
 2043e98:	003fee06 	br	2043e54 <__alt_mem_mem_0+0xfd023e54>
 2043e9c:	d9402c17 	ldw	r5,176(sp)
 2043ea0:	d9801e04 	addi	r6,sp,120
 2043ea4:	9809883a 	mov	r4,r19
 2043ea8:	20450c00 	call	20450c0 <__ssprint_r>
 2043eac:	103c4d1e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043eb0:	d8c02017 	ldw	r3,128(sp)
 2043eb4:	df002787 	ldb	fp,158(sp)
 2043eb8:	da000404 	addi	r8,sp,16
 2043ebc:	003d5a06 	br	2043428 <__alt_mem_mem_0+0xfd023428>
 2043ec0:	9080040c 	andi	r2,r18,16
 2043ec4:	10005c26 	beq	r2,zero,2044038 <___svfprintf_internal_r+0x13e8>
 2043ec8:	d9402d17 	ldw	r5,180(sp)
 2043ecc:	d8c02917 	ldw	r3,164(sp)
 2043ed0:	d8002785 	stb	zero,158(sp)
 2043ed4:	28800104 	addi	r2,r5,4
 2043ed8:	2d000017 	ldw	r20,0(r5)
 2043edc:	002d883a 	mov	r22,zero
 2043ee0:	18005e16 	blt	r3,zero,204405c <___svfprintf_internal_r+0x140c>
 2043ee4:	00ffdfc4 	movi	r3,-129
 2043ee8:	d8802d15 	stw	r2,180(sp)
 2043eec:	90e4703a 	and	r18,r18,r3
 2043ef0:	0039883a 	mov	fp,zero
 2043ef4:	a03dfe26 	beq	r20,zero,20436f0 <__alt_mem_mem_0+0xfd0236f0>
 2043ef8:	00800244 	movi	r2,9
 2043efc:	153cb336 	bltu	r2,r20,20431cc <__alt_mem_mem_0+0xfd0231cc>
 2043f00:	a5000c04 	addi	r20,r20,48
 2043f04:	dc001dc4 	addi	r16,sp,119
 2043f08:	dd001dc5 	stb	r20,119(sp)
 2043f0c:	d8c02817 	ldw	r3,160(sp)
 2043f10:	1c07c83a 	sub	r3,r3,r16
 2043f14:	d8c02e15 	stw	r3,184(sp)
 2043f18:	003cf506 	br	20432f0 <__alt_mem_mem_0+0xfd0232f0>
 2043f1c:	d8803317 	ldw	r2,204(sp)
 2043f20:	143fffc4 	addi	r16,r2,-1
 2043f24:	043f560e 	bge	zero,r16,2043c80 <__alt_mem_mem_0+0xfd023c80>
 2043f28:	07000404 	movi	fp,16
 2043f2c:	e403530e 	bge	fp,r16,2044c7c <___svfprintf_internal_r+0x202c>
 2043f30:	01408174 	movhi	r5,517
 2043f34:	2963d704 	addi	r5,r5,-28836
 2043f38:	d9402b15 	stw	r5,172(sp)
 2043f3c:	01c001c4 	movi	r7,7
 2043f40:	dd002c17 	ldw	r20,176(sp)
 2043f44:	00000306 	br	2043f54 <___svfprintf_internal_r+0x1304>
 2043f48:	843ffc04 	addi	r16,r16,-16
 2043f4c:	b5800204 	addi	r22,r22,8
 2043f50:	e400130e 	bge	fp,r16,2043fa0 <___svfprintf_internal_r+0x1350>
 2043f54:	18c00404 	addi	r3,r3,16
 2043f58:	8c400044 	addi	r17,r17,1
 2043f5c:	b5400015 	stw	r21,0(r22)
 2043f60:	b7000115 	stw	fp,4(r22)
 2043f64:	d8c02015 	stw	r3,128(sp)
 2043f68:	dc401f15 	stw	r17,124(sp)
 2043f6c:	3c7ff60e 	bge	r7,r17,2043f48 <__alt_mem_mem_0+0xfd023f48>
 2043f70:	d9801e04 	addi	r6,sp,120
 2043f74:	a00b883a 	mov	r5,r20
 2043f78:	9809883a 	mov	r4,r19
 2043f7c:	d9c03d15 	stw	r7,244(sp)
 2043f80:	20450c00 	call	20450c0 <__ssprint_r>
 2043f84:	d9c03d17 	ldw	r7,244(sp)
 2043f88:	103c161e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043f8c:	843ffc04 	addi	r16,r16,-16
 2043f90:	d8c02017 	ldw	r3,128(sp)
 2043f94:	dc401f17 	ldw	r17,124(sp)
 2043f98:	dd800404 	addi	r22,sp,16
 2043f9c:	e43fed16 	blt	fp,r16,2043f54 <__alt_mem_mem_0+0xfd023f54>
 2043fa0:	d8802b17 	ldw	r2,172(sp)
 2043fa4:	1c07883a 	add	r3,r3,r16
 2043fa8:	8c400044 	addi	r17,r17,1
 2043fac:	b0800015 	stw	r2,0(r22)
 2043fb0:	b4000115 	stw	r16,4(r22)
 2043fb4:	d8c02015 	stw	r3,128(sp)
 2043fb8:	dc401f15 	stw	r17,124(sp)
 2043fbc:	008001c4 	movi	r2,7
 2043fc0:	147f2e0e 	bge	r2,r17,2043c7c <__alt_mem_mem_0+0xfd023c7c>
 2043fc4:	d9402c17 	ldw	r5,176(sp)
 2043fc8:	d9801e04 	addi	r6,sp,120
 2043fcc:	9809883a 	mov	r4,r19
 2043fd0:	20450c00 	call	20450c0 <__ssprint_r>
 2043fd4:	103c031e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2043fd8:	d8c02017 	ldw	r3,128(sp)
 2043fdc:	dc401f17 	ldw	r17,124(sp)
 2043fe0:	dd800404 	addi	r22,sp,16
 2043fe4:	003f2606 	br	2043c80 <__alt_mem_mem_0+0xfd023c80>
 2043fe8:	9080040c 	andi	r2,r18,16
 2043fec:	1000c326 	beq	r2,zero,20442fc <___svfprintf_internal_r+0x16ac>
 2043ff0:	d8802d17 	ldw	r2,180(sp)
 2043ff4:	15000017 	ldw	r20,0(r2)
 2043ff8:	10800104 	addi	r2,r2,4
 2043ffc:	d8802d15 	stw	r2,180(sp)
 2044000:	a02dd7fa 	srai	r22,r20,31
 2044004:	b005883a 	mov	r2,r22
 2044008:	103c680e 	bge	r2,zero,20431ac <__alt_mem_mem_0+0xfd0231ac>
 204400c:	0529c83a 	sub	r20,zero,r20
 2044010:	a004c03a 	cmpne	r2,r20,zero
 2044014:	05adc83a 	sub	r22,zero,r22
 2044018:	b0adc83a 	sub	r22,r22,r2
 204401c:	d8802917 	ldw	r2,164(sp)
 2044020:	07000b44 	movi	fp,45
 2044024:	df002785 	stb	fp,158(sp)
 2044028:	10022e16 	blt	r2,zero,20448e4 <___svfprintf_internal_r+0x1c94>
 204402c:	00bfdfc4 	movi	r2,-129
 2044030:	90a4703a 	and	r18,r18,r2
 2044034:	003c6406 	br	20431c8 <__alt_mem_mem_0+0xfd0231c8>
 2044038:	9080100c 	andi	r2,r18,64
 204403c:	d8002785 	stb	zero,158(sp)
 2044040:	10012526 	beq	r2,zero,20444d8 <___svfprintf_internal_r+0x1888>
 2044044:	d9002d17 	ldw	r4,180(sp)
 2044048:	d9402917 	ldw	r5,164(sp)
 204404c:	002d883a 	mov	r22,zero
 2044050:	20800104 	addi	r2,r4,4
 2044054:	2500000b 	ldhu	r20,0(r4)
 2044058:	283fa20e 	bge	r5,zero,2043ee4 <__alt_mem_mem_0+0xfd023ee4>
 204405c:	d8802d15 	stw	r2,180(sp)
 2044060:	0039883a 	mov	fp,zero
 2044064:	a584b03a 	or	r2,r20,r22
 2044068:	103c571e 	bne	r2,zero,20431c8 <__alt_mem_mem_0+0xfd0231c8>
 204406c:	00800044 	movi	r2,1
 2044070:	003e5006 	br	20439b4 <__alt_mem_mem_0+0xfd0239b4>
 2044074:	d9402c17 	ldw	r5,176(sp)
 2044078:	d9801e04 	addi	r6,sp,120
 204407c:	9809883a 	mov	r4,r19
 2044080:	20450c00 	call	20450c0 <__ssprint_r>
 2044084:	103bd71e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2044088:	d8c02017 	ldw	r3,128(sp)
 204408c:	da000404 	addi	r8,sp,16
 2044090:	d9003217 	ldw	r4,200(sp)
 2044094:	d8802617 	ldw	r2,152(sp)
 2044098:	d9403317 	ldw	r5,204(sp)
 204409c:	8123883a 	add	r17,r16,r4
 20440a0:	11400216 	blt	r2,r5,20440ac <___svfprintf_internal_r+0x145c>
 20440a4:	9100004c 	andi	r4,r18,1
 20440a8:	20000d26 	beq	r4,zero,20440e0 <___svfprintf_internal_r+0x1490>
 20440ac:	d9003817 	ldw	r4,224(sp)
 20440b0:	d9403417 	ldw	r5,208(sp)
 20440b4:	1907883a 	add	r3,r3,r4
 20440b8:	d9001f17 	ldw	r4,124(sp)
 20440bc:	41400015 	stw	r5,0(r8)
 20440c0:	d9403817 	ldw	r5,224(sp)
 20440c4:	21000044 	addi	r4,r4,1
 20440c8:	d8c02015 	stw	r3,128(sp)
 20440cc:	41400115 	stw	r5,4(r8)
 20440d0:	d9001f15 	stw	r4,124(sp)
 20440d4:	014001c4 	movi	r5,7
 20440d8:	2901dc16 	blt	r5,r4,204484c <___svfprintf_internal_r+0x1bfc>
 20440dc:	42000204 	addi	r8,r8,8
 20440e0:	d9003317 	ldw	r4,204(sp)
 20440e4:	8121883a 	add	r16,r16,r4
 20440e8:	2085c83a 	sub	r2,r4,r2
 20440ec:	8461c83a 	sub	r16,r16,r17
 20440f0:	1400010e 	bge	r2,r16,20440f8 <___svfprintf_internal_r+0x14a8>
 20440f4:	1021883a 	mov	r16,r2
 20440f8:	04000a0e 	bge	zero,r16,2044124 <___svfprintf_internal_r+0x14d4>
 20440fc:	d9001f17 	ldw	r4,124(sp)
 2044100:	1c07883a 	add	r3,r3,r16
 2044104:	44400015 	stw	r17,0(r8)
 2044108:	21000044 	addi	r4,r4,1
 204410c:	44000115 	stw	r16,4(r8)
 2044110:	d8c02015 	stw	r3,128(sp)
 2044114:	d9001f15 	stw	r4,124(sp)
 2044118:	014001c4 	movi	r5,7
 204411c:	2901e616 	blt	r5,r4,20448b8 <___svfprintf_internal_r+0x1c68>
 2044120:	42000204 	addi	r8,r8,8
 2044124:	8001f616 	blt	r16,zero,2044900 <___svfprintf_internal_r+0x1cb0>
 2044128:	1421c83a 	sub	r16,r2,r16
 204412c:	043d1c0e 	bge	zero,r16,20435a0 <__alt_mem_mem_0+0xfd0235a0>
 2044130:	04400404 	movi	r17,16
 2044134:	d8801f17 	ldw	r2,124(sp)
 2044138:	8c3edd0e 	bge	r17,r16,2043cb0 <__alt_mem_mem_0+0xfd023cb0>
 204413c:	01408174 	movhi	r5,517
 2044140:	2963d704 	addi	r5,r5,-28836
 2044144:	d9402b15 	stw	r5,172(sp)
 2044148:	058001c4 	movi	r22,7
 204414c:	dd002c17 	ldw	r20,176(sp)
 2044150:	00000306 	br	2044160 <___svfprintf_internal_r+0x1510>
 2044154:	42000204 	addi	r8,r8,8
 2044158:	843ffc04 	addi	r16,r16,-16
 204415c:	8c3ed70e 	bge	r17,r16,2043cbc <__alt_mem_mem_0+0xfd023cbc>
 2044160:	18c00404 	addi	r3,r3,16
 2044164:	10800044 	addi	r2,r2,1
 2044168:	45400015 	stw	r21,0(r8)
 204416c:	44400115 	stw	r17,4(r8)
 2044170:	d8c02015 	stw	r3,128(sp)
 2044174:	d8801f15 	stw	r2,124(sp)
 2044178:	b0bff60e 	bge	r22,r2,2044154 <__alt_mem_mem_0+0xfd024154>
 204417c:	d9801e04 	addi	r6,sp,120
 2044180:	a00b883a 	mov	r5,r20
 2044184:	9809883a 	mov	r4,r19
 2044188:	20450c00 	call	20450c0 <__ssprint_r>
 204418c:	103b951e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2044190:	d8c02017 	ldw	r3,128(sp)
 2044194:	d8801f17 	ldw	r2,124(sp)
 2044198:	da000404 	addi	r8,sp,16
 204419c:	003fee06 	br	2044158 <__alt_mem_mem_0+0xfd024158>
 20441a0:	9088703a 	and	r4,r18,r2
 20441a4:	203e8d1e 	bne	r4,zero,2043bdc <__alt_mem_mem_0+0xfd023bdc>
 20441a8:	dc401f17 	ldw	r17,124(sp)
 20441ac:	40800115 	stw	r2,4(r8)
 20441b0:	44000015 	stw	r16,0(r8)
 20441b4:	8c400044 	addi	r17,r17,1
 20441b8:	d8c02015 	stw	r3,128(sp)
 20441bc:	dc401f15 	stw	r17,124(sp)
 20441c0:	008001c4 	movi	r2,7
 20441c4:	147f7f16 	blt	r2,r17,2043fc4 <__alt_mem_mem_0+0xfd023fc4>
 20441c8:	45800204 	addi	r22,r8,8
 20441cc:	003eac06 	br	2043c80 <__alt_mem_mem_0+0xfd023c80>
 20441d0:	d9402c17 	ldw	r5,176(sp)
 20441d4:	d9801e04 	addi	r6,sp,120
 20441d8:	9809883a 	mov	r4,r19
 20441dc:	20450c00 	call	20450c0 <__ssprint_r>
 20441e0:	103b801e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 20441e4:	d8c02017 	ldw	r3,128(sp)
 20441e8:	dc401f17 	ldw	r17,124(sp)
 20441ec:	da000404 	addi	r8,sp,16
 20441f0:	003e8406 	br	2043c04 <__alt_mem_mem_0+0xfd023c04>
 20441f4:	d9402c17 	ldw	r5,176(sp)
 20441f8:	d9801e04 	addi	r6,sp,120
 20441fc:	9809883a 	mov	r4,r19
 2044200:	20450c00 	call	20450c0 <__ssprint_r>
 2044204:	103b771e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2044208:	d8c02017 	ldw	r3,128(sp)
 204420c:	dc401f17 	ldw	r17,124(sp)
 2044210:	dd800404 	addi	r22,sp,16
 2044214:	003e8606 	br	2043c30 <__alt_mem_mem_0+0xfd023c30>
 2044218:	0029883a 	mov	r20,zero
 204421c:	a5000c04 	addi	r20,r20,48
 2044220:	dc001dc4 	addi	r16,sp,119
 2044224:	dd001dc5 	stb	r20,119(sp)
 2044228:	003f3806 	br	2043f0c <__alt_mem_mem_0+0xfd023f0c>
 204422c:	d9402c17 	ldw	r5,176(sp)
 2044230:	d9801e04 	addi	r6,sp,120
 2044234:	9809883a 	mov	r4,r19
 2044238:	20450c00 	call	20450c0 <__ssprint_r>
 204423c:	103b691e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2044240:	d8c02017 	ldw	r3,128(sp)
 2044244:	da000404 	addi	r8,sp,16
 2044248:	003c9506 	br	20434a0 <__alt_mem_mem_0+0xfd0234a0>
 204424c:	d9003617 	ldw	r4,216(sp)
 2044250:	d9403717 	ldw	r5,220(sp)
 2044254:	da003e15 	stw	r8,248(sp)
 2044258:	20070c40 	call	20070c4 <__fpclassifyd>
 204425c:	da003e17 	ldw	r8,248(sp)
 2044260:	1000bd1e 	bne	r2,zero,2044558 <___svfprintf_internal_r+0x1908>
 2044264:	008011c4 	movi	r2,71
 2044268:	14411e0e 	bge	r2,r17,20446e4 <___svfprintf_internal_r+0x1a94>
 204426c:	04008134 	movhi	r16,516
 2044270:	841a7f04 	addi	r16,r16,27132
 2044274:	00c000c4 	movi	r3,3
 2044278:	00bfdfc4 	movi	r2,-129
 204427c:	d8c02a15 	stw	r3,168(sp)
 2044280:	90a4703a 	and	r18,r18,r2
 2044284:	df002783 	ldbu	fp,158(sp)
 2044288:	d8c02e15 	stw	r3,184(sp)
 204428c:	d8002915 	stw	zero,164(sp)
 2044290:	d8003215 	stw	zero,200(sp)
 2044294:	003c1c06 	br	2043308 <__alt_mem_mem_0+0xfd023308>
 2044298:	9080100c 	andi	r2,r18,64
 204429c:	d8002785 	stb	zero,158(sp)
 20442a0:	10009426 	beq	r2,zero,20444f4 <___svfprintf_internal_r+0x18a4>
 20442a4:	d8c02d17 	ldw	r3,180(sp)
 20442a8:	d9002917 	ldw	r4,164(sp)
 20442ac:	002d883a 	mov	r22,zero
 20442b0:	18800104 	addi	r2,r3,4
 20442b4:	1d00000b 	ldhu	r20,0(r3)
 20442b8:	203ec10e 	bge	r4,zero,2043dc0 <__alt_mem_mem_0+0xfd023dc0>
 20442bc:	a586b03a 	or	r3,r20,r22
 20442c0:	d8802d15 	stw	r2,180(sp)
 20442c4:	183ec21e 	bne	r3,zero,2043dd0 <__alt_mem_mem_0+0xfd023dd0>
 20442c8:	0039883a 	mov	fp,zero
 20442cc:	0005883a 	mov	r2,zero
 20442d0:	003db806 	br	20439b4 <__alt_mem_mem_0+0xfd0239b4>
 20442d4:	d8802d17 	ldw	r2,180(sp)
 20442d8:	d8c02d17 	ldw	r3,180(sp)
 20442dc:	d9002d17 	ldw	r4,180(sp)
 20442e0:	10800017 	ldw	r2,0(r2)
 20442e4:	18c00117 	ldw	r3,4(r3)
 20442e8:	21000204 	addi	r4,r4,8
 20442ec:	d8803615 	stw	r2,216(sp)
 20442f0:	d8c03715 	stw	r3,220(sp)
 20442f4:	d9002d15 	stw	r4,180(sp)
 20442f8:	003b8206 	br	2043104 <__alt_mem_mem_0+0xfd023104>
 20442fc:	9080100c 	andi	r2,r18,64
 2044300:	10010726 	beq	r2,zero,2044720 <___svfprintf_internal_r+0x1ad0>
 2044304:	d8c02d17 	ldw	r3,180(sp)
 2044308:	1d00000f 	ldh	r20,0(r3)
 204430c:	18c00104 	addi	r3,r3,4
 2044310:	d8c02d15 	stw	r3,180(sp)
 2044314:	a02dd7fa 	srai	r22,r20,31
 2044318:	b005883a 	mov	r2,r22
 204431c:	003ba206 	br	20431a8 <__alt_mem_mem_0+0xfd0231a8>
 2044320:	9080100c 	andi	r2,r18,64
 2044324:	10010526 	beq	r2,zero,204473c <___svfprintf_internal_r+0x1aec>
 2044328:	d9002d17 	ldw	r4,180(sp)
 204432c:	002d883a 	mov	r22,zero
 2044330:	2500000b 	ldhu	r20,0(r4)
 2044334:	21000104 	addi	r4,r4,4
 2044338:	d9002d15 	stw	r4,180(sp)
 204433c:	003cfe06 	br	2043738 <__alt_mem_mem_0+0xfd023738>
 2044340:	bc400007 	ldb	r17,0(r23)
 2044344:	003a9606 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2044348:	9080040c 	andi	r2,r18,16
 204434c:	10010126 	beq	r2,zero,2044754 <___svfprintf_internal_r+0x1b04>
 2044350:	d9402d17 	ldw	r5,180(sp)
 2044354:	d8c02f17 	ldw	r3,188(sp)
 2044358:	28800017 	ldw	r2,0(r5)
 204435c:	29400104 	addi	r5,r5,4
 2044360:	d9402d15 	stw	r5,180(sp)
 2044364:	10c00015 	stw	r3,0(r2)
 2044368:	003a6406 	br	2042cfc <__alt_mem_mem_0+0xfd022cfc>
 204436c:	d9002917 	ldw	r4,164(sp)
 2044370:	d8002785 	stb	zero,158(sp)
 2044374:	203d8d16 	blt	r4,zero,20439ac <__alt_mem_mem_0+0xfd0239ac>
 2044378:	00bfdfc4 	movi	r2,-129
 204437c:	90a4703a 	and	r18,r18,r2
 2044380:	003b0506 	br	2042f98 <__alt_mem_mem_0+0xfd022f98>
 2044384:	01408174 	movhi	r5,517
 2044388:	2963d704 	addi	r5,r5,-28836
 204438c:	d9402b15 	stw	r5,172(sp)
 2044390:	d9402b17 	ldw	r5,172(sp)
 2044394:	1c47883a 	add	r3,r3,r17
 2044398:	10800044 	addi	r2,r2,1
 204439c:	41400015 	stw	r5,0(r8)
 20443a0:	44400115 	stw	r17,4(r8)
 20443a4:	d8c02015 	stw	r3,128(sp)
 20443a8:	d8801f15 	stw	r2,124(sp)
 20443ac:	010001c4 	movi	r4,7
 20443b0:	20bf3016 	blt	r4,r2,2044074 <__alt_mem_mem_0+0xfd024074>
 20443b4:	42000204 	addi	r8,r8,8
 20443b8:	003f3506 	br	2044090 <__alt_mem_mem_0+0xfd024090>
 20443bc:	01008174 	movhi	r4,517
 20443c0:	2123d704 	addi	r4,r4,-28836
 20443c4:	d9002b15 	stw	r4,172(sp)
 20443c8:	003c5e06 	br	2043544 <__alt_mem_mem_0+0xfd023544>
 20443cc:	d9402c17 	ldw	r5,176(sp)
 20443d0:	d9801e04 	addi	r6,sp,120
 20443d4:	9809883a 	mov	r4,r19
 20443d8:	20450c00 	call	20450c0 <__ssprint_r>
 20443dc:	103b011e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 20443e0:	d8c02017 	ldw	r3,128(sp)
 20443e4:	da000404 	addi	r8,sp,16
 20443e8:	003d9306 	br	2043a38 <__alt_mem_mem_0+0xfd023a38>
 20443ec:	d8801f17 	ldw	r2,124(sp)
 20443f0:	01408134 	movhi	r5,516
 20443f4:	01000044 	movi	r4,1
 20443f8:	18c00044 	addi	r3,r3,1
 20443fc:	10800044 	addi	r2,r2,1
 2044400:	295a8c04 	addi	r5,r5,27184
 2044404:	41000115 	stw	r4,4(r8)
 2044408:	41400015 	stw	r5,0(r8)
 204440c:	d8c02015 	stw	r3,128(sp)
 2044410:	d8801f15 	stw	r2,124(sp)
 2044414:	010001c4 	movi	r4,7
 2044418:	2080b516 	blt	r4,r2,20446f0 <___svfprintf_internal_r+0x1aa0>
 204441c:	42000204 	addi	r8,r8,8
 2044420:	8800041e 	bne	r17,zero,2044434 <___svfprintf_internal_r+0x17e4>
 2044424:	d8803317 	ldw	r2,204(sp)
 2044428:	1000021e 	bne	r2,zero,2044434 <___svfprintf_internal_r+0x17e4>
 204442c:	9080004c 	andi	r2,r18,1
 2044430:	103c5b26 	beq	r2,zero,20435a0 <__alt_mem_mem_0+0xfd0235a0>
 2044434:	d9003817 	ldw	r4,224(sp)
 2044438:	d8801f17 	ldw	r2,124(sp)
 204443c:	d9403417 	ldw	r5,208(sp)
 2044440:	20c7883a 	add	r3,r4,r3
 2044444:	10800044 	addi	r2,r2,1
 2044448:	41000115 	stw	r4,4(r8)
 204444c:	41400015 	stw	r5,0(r8)
 2044450:	d8c02015 	stw	r3,128(sp)
 2044454:	d8801f15 	stw	r2,124(sp)
 2044458:	010001c4 	movi	r4,7
 204445c:	20818016 	blt	r4,r2,2044a60 <___svfprintf_internal_r+0x1e10>
 2044460:	42000204 	addi	r8,r8,8
 2044464:	0463c83a 	sub	r17,zero,r17
 2044468:	0440cb0e 	bge	zero,r17,2044798 <___svfprintf_internal_r+0x1b48>
 204446c:	05800404 	movi	r22,16
 2044470:	b440e80e 	bge	r22,r17,2044814 <___svfprintf_internal_r+0x1bc4>
 2044474:	01408174 	movhi	r5,517
 2044478:	2963d704 	addi	r5,r5,-28836
 204447c:	d9402b15 	stw	r5,172(sp)
 2044480:	070001c4 	movi	fp,7
 2044484:	dd002c17 	ldw	r20,176(sp)
 2044488:	00000306 	br	2044498 <___svfprintf_internal_r+0x1848>
 204448c:	42000204 	addi	r8,r8,8
 2044490:	8c7ffc04 	addi	r17,r17,-16
 2044494:	b440e20e 	bge	r22,r17,2044820 <___svfprintf_internal_r+0x1bd0>
 2044498:	18c00404 	addi	r3,r3,16
 204449c:	10800044 	addi	r2,r2,1
 20444a0:	45400015 	stw	r21,0(r8)
 20444a4:	45800115 	stw	r22,4(r8)
 20444a8:	d8c02015 	stw	r3,128(sp)
 20444ac:	d8801f15 	stw	r2,124(sp)
 20444b0:	e0bff60e 	bge	fp,r2,204448c <__alt_mem_mem_0+0xfd02448c>
 20444b4:	d9801e04 	addi	r6,sp,120
 20444b8:	a00b883a 	mov	r5,r20
 20444bc:	9809883a 	mov	r4,r19
 20444c0:	20450c00 	call	20450c0 <__ssprint_r>
 20444c4:	103ac71e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 20444c8:	d8c02017 	ldw	r3,128(sp)
 20444cc:	d8801f17 	ldw	r2,124(sp)
 20444d0:	da000404 	addi	r8,sp,16
 20444d4:	003fee06 	br	2044490 <__alt_mem_mem_0+0xfd024490>
 20444d8:	d8c02d17 	ldw	r3,180(sp)
 20444dc:	d9002917 	ldw	r4,164(sp)
 20444e0:	002d883a 	mov	r22,zero
 20444e4:	18800104 	addi	r2,r3,4
 20444e8:	1d000017 	ldw	r20,0(r3)
 20444ec:	203e7d0e 	bge	r4,zero,2043ee4 <__alt_mem_mem_0+0xfd023ee4>
 20444f0:	003eda06 	br	204405c <__alt_mem_mem_0+0xfd02405c>
 20444f4:	d9402d17 	ldw	r5,180(sp)
 20444f8:	d8c02917 	ldw	r3,164(sp)
 20444fc:	002d883a 	mov	r22,zero
 2044500:	28800104 	addi	r2,r5,4
 2044504:	2d000017 	ldw	r20,0(r5)
 2044508:	183e2d0e 	bge	r3,zero,2043dc0 <__alt_mem_mem_0+0xfd023dc0>
 204450c:	003f6b06 	br	20442bc <__alt_mem_mem_0+0xfd0242bc>
 2044510:	d8c02d15 	stw	r3,180(sp)
 2044514:	0039883a 	mov	fp,zero
 2044518:	003ed206 	br	2044064 <__alt_mem_mem_0+0xfd024064>
 204451c:	bc400043 	ldbu	r17,1(r23)
 2044520:	94800814 	ori	r18,r18,32
 2044524:	bdc00044 	addi	r23,r23,1
 2044528:	8c403fcc 	andi	r17,r17,255
 204452c:	8c40201c 	xori	r17,r17,128
 2044530:	8c7fe004 	addi	r17,r17,-128
 2044534:	003a1a06 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2044538:	d9402c17 	ldw	r5,176(sp)
 204453c:	d9801e04 	addi	r6,sp,120
 2044540:	9809883a 	mov	r4,r19
 2044544:	20450c00 	call	20450c0 <__ssprint_r>
 2044548:	103aa61e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 204454c:	d8c02017 	ldw	r3,128(sp)
 2044550:	da000404 	addi	r8,sp,16
 2044554:	003d4a06 	br	2043a80 <__alt_mem_mem_0+0xfd023a80>
 2044558:	d9002917 	ldw	r4,164(sp)
 204455c:	05bff7c4 	movi	r22,-33
 2044560:	00bfffc4 	movi	r2,-1
 2044564:	8dac703a 	and	r22,r17,r22
 2044568:	20806a26 	beq	r4,r2,2044714 <___svfprintf_internal_r+0x1ac4>
 204456c:	008011c4 	movi	r2,71
 2044570:	b0813726 	beq	r22,r2,2044a50 <___svfprintf_internal_r+0x1e00>
 2044574:	d9003717 	ldw	r4,220(sp)
 2044578:	90c04014 	ori	r3,r18,256
 204457c:	d8c02b15 	stw	r3,172(sp)
 2044580:	20015d16 	blt	r4,zero,2044af8 <___svfprintf_internal_r+0x1ea8>
 2044584:	dd003717 	ldw	r20,220(sp)
 2044588:	d8002a05 	stb	zero,168(sp)
 204458c:	00801984 	movi	r2,102
 2044590:	88814026 	beq	r17,r2,2044a94 <___svfprintf_internal_r+0x1e44>
 2044594:	00801184 	movi	r2,70
 2044598:	88817126 	beq	r17,r2,2044b60 <___svfprintf_internal_r+0x1f10>
 204459c:	00801144 	movi	r2,69
 20445a0:	b0816226 	beq	r22,r2,2044b2c <___svfprintf_internal_r+0x1edc>
 20445a4:	d8c02917 	ldw	r3,164(sp)
 20445a8:	d8802104 	addi	r2,sp,132
 20445ac:	d8800315 	stw	r2,12(sp)
 20445b0:	d9403617 	ldw	r5,216(sp)
 20445b4:	d8802504 	addi	r2,sp,148
 20445b8:	d8800215 	stw	r2,8(sp)
 20445bc:	d8802604 	addi	r2,sp,152
 20445c0:	d8c00015 	stw	r3,0(sp)
 20445c4:	d8800115 	stw	r2,4(sp)
 20445c8:	01c00084 	movi	r7,2
 20445cc:	a00d883a 	mov	r6,r20
 20445d0:	9809883a 	mov	r4,r19
 20445d4:	d8c03d15 	stw	r3,244(sp)
 20445d8:	da003e15 	stw	r8,248(sp)
 20445dc:	20030440 	call	2003044 <_dtoa_r>
 20445e0:	1021883a 	mov	r16,r2
 20445e4:	008019c4 	movi	r2,103
 20445e8:	d8c03d17 	ldw	r3,244(sp)
 20445ec:	da003e17 	ldw	r8,248(sp)
 20445f0:	8880e726 	beq	r17,r2,2044990 <___svfprintf_internal_r+0x1d40>
 20445f4:	008011c4 	movi	r2,71
 20445f8:	8880d426 	beq	r17,r2,204494c <___svfprintf_internal_r+0x1cfc>
 20445fc:	80f9883a 	add	fp,r16,r3
 2044600:	d9003617 	ldw	r4,216(sp)
 2044604:	000d883a 	mov	r6,zero
 2044608:	000f883a 	mov	r7,zero
 204460c:	a00b883a 	mov	r5,r20
 2044610:	da003e15 	stw	r8,248(sp)
 2044614:	200bd2c0 	call	200bd2c <__eqdf2>
 2044618:	da003e17 	ldw	r8,248(sp)
 204461c:	1000e426 	beq	r2,zero,20449b0 <___svfprintf_internal_r+0x1d60>
 2044620:	d8802117 	ldw	r2,132(sp)
 2044624:	1700062e 	bgeu	r2,fp,2044640 <___svfprintf_internal_r+0x19f0>
 2044628:	01000c04 	movi	r4,48
 204462c:	10c00044 	addi	r3,r2,1
 2044630:	d8c02115 	stw	r3,132(sp)
 2044634:	11000005 	stb	r4,0(r2)
 2044638:	d8802117 	ldw	r2,132(sp)
 204463c:	173ffb36 	bltu	r2,fp,204462c <__alt_mem_mem_0+0xfd02462c>
 2044640:	1405c83a 	sub	r2,r2,r16
 2044644:	d8803315 	stw	r2,204(sp)
 2044648:	008011c4 	movi	r2,71
 204464c:	b080c526 	beq	r22,r2,2044964 <___svfprintf_internal_r+0x1d14>
 2044650:	00801944 	movi	r2,101
 2044654:	1441d90e 	bge	r2,r17,2044dbc <___svfprintf_internal_r+0x216c>
 2044658:	d8c02617 	ldw	r3,152(sp)
 204465c:	00801984 	movi	r2,102
 2044660:	d8c03215 	stw	r3,200(sp)
 2044664:	88813426 	beq	r17,r2,2044b38 <___svfprintf_internal_r+0x1ee8>
 2044668:	d8c03217 	ldw	r3,200(sp)
 204466c:	d9003317 	ldw	r4,204(sp)
 2044670:	19012516 	blt	r3,r4,2044b08 <___svfprintf_internal_r+0x1eb8>
 2044674:	9480004c 	andi	r18,r18,1
 2044678:	9001841e 	bne	r18,zero,2044c8c <___svfprintf_internal_r+0x203c>
 204467c:	1805883a 	mov	r2,r3
 2044680:	1801cc16 	blt	r3,zero,2044db4 <___svfprintf_internal_r+0x2164>
 2044684:	d8c03217 	ldw	r3,200(sp)
 2044688:	044019c4 	movi	r17,103
 204468c:	d8c02e15 	stw	r3,184(sp)
 2044690:	df002a07 	ldb	fp,168(sp)
 2044694:	e000a61e 	bne	fp,zero,2044930 <___svfprintf_internal_r+0x1ce0>
 2044698:	df002783 	ldbu	fp,158(sp)
 204469c:	d8802a15 	stw	r2,168(sp)
 20446a0:	dc802b17 	ldw	r18,172(sp)
 20446a4:	d8002915 	stw	zero,164(sp)
 20446a8:	003b1706 	br	2043308 <__alt_mem_mem_0+0xfd023308>
 20446ac:	04008134 	movhi	r16,516
 20446b0:	841a7c04 	addi	r16,r16,27120
 20446b4:	003aa606 	br	2043150 <__alt_mem_mem_0+0xfd023150>
 20446b8:	d9003917 	ldw	r4,228(sp)
 20446bc:	04001004 	movi	r16,64
 20446c0:	800b883a 	mov	r5,r16
 20446c4:	20055680 	call	2005568 <_malloc_r>
 20446c8:	d9002c17 	ldw	r4,176(sp)
 20446cc:	20800015 	stw	r2,0(r4)
 20446d0:	20800415 	stw	r2,16(r4)
 20446d4:	1001cb26 	beq	r2,zero,2044e04 <___svfprintf_internal_r+0x21b4>
 20446d8:	d8802c17 	ldw	r2,176(sp)
 20446dc:	14000515 	stw	r16,20(r2)
 20446e0:	00397606 	br	2042cbc <__alt_mem_mem_0+0xfd022cbc>
 20446e4:	04008134 	movhi	r16,516
 20446e8:	841a7e04 	addi	r16,r16,27128
 20446ec:	003ee106 	br	2044274 <__alt_mem_mem_0+0xfd024274>
 20446f0:	d9402c17 	ldw	r5,176(sp)
 20446f4:	d9801e04 	addi	r6,sp,120
 20446f8:	9809883a 	mov	r4,r19
 20446fc:	20450c00 	call	20450c0 <__ssprint_r>
 2044700:	103a381e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2044704:	dc402617 	ldw	r17,152(sp)
 2044708:	d8c02017 	ldw	r3,128(sp)
 204470c:	da000404 	addi	r8,sp,16
 2044710:	003f4306 	br	2044420 <__alt_mem_mem_0+0xfd024420>
 2044714:	01400184 	movi	r5,6
 2044718:	d9402915 	stw	r5,164(sp)
 204471c:	003f9506 	br	2044574 <__alt_mem_mem_0+0xfd024574>
 2044720:	d9002d17 	ldw	r4,180(sp)
 2044724:	25000017 	ldw	r20,0(r4)
 2044728:	21000104 	addi	r4,r4,4
 204472c:	d9002d15 	stw	r4,180(sp)
 2044730:	a02dd7fa 	srai	r22,r20,31
 2044734:	b005883a 	mov	r2,r22
 2044738:	003a9b06 	br	20431a8 <__alt_mem_mem_0+0xfd0231a8>
 204473c:	d9402d17 	ldw	r5,180(sp)
 2044740:	002d883a 	mov	r22,zero
 2044744:	2d000017 	ldw	r20,0(r5)
 2044748:	29400104 	addi	r5,r5,4
 204474c:	d9402d15 	stw	r5,180(sp)
 2044750:	003bf906 	br	2043738 <__alt_mem_mem_0+0xfd023738>
 2044754:	9480100c 	andi	r18,r18,64
 2044758:	90006e26 	beq	r18,zero,2044914 <___svfprintf_internal_r+0x1cc4>
 204475c:	d9002d17 	ldw	r4,180(sp)
 2044760:	d9402f17 	ldw	r5,188(sp)
 2044764:	20800017 	ldw	r2,0(r4)
 2044768:	21000104 	addi	r4,r4,4
 204476c:	d9002d15 	stw	r4,180(sp)
 2044770:	1140000d 	sth	r5,0(r2)
 2044774:	00396106 	br	2042cfc <__alt_mem_mem_0+0xfd022cfc>
 2044778:	d9402c17 	ldw	r5,176(sp)
 204477c:	d9801e04 	addi	r6,sp,120
 2044780:	9809883a 	mov	r4,r19
 2044784:	20450c00 	call	20450c0 <__ssprint_r>
 2044788:	103a161e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 204478c:	d8c02017 	ldw	r3,128(sp)
 2044790:	d8801f17 	ldw	r2,124(sp)
 2044794:	da000404 	addi	r8,sp,16
 2044798:	d9403317 	ldw	r5,204(sp)
 204479c:	10800044 	addi	r2,r2,1
 20447a0:	44000015 	stw	r16,0(r8)
 20447a4:	28c7883a 	add	r3,r5,r3
 20447a8:	003b7706 	br	2043588 <__alt_mem_mem_0+0xfd023588>
 20447ac:	8009883a 	mov	r4,r16
 20447b0:	da003e15 	stw	r8,248(sp)
 20447b4:	20073a40 	call	20073a4 <strlen>
 20447b8:	d8802e15 	stw	r2,184(sp)
 20447bc:	da003e17 	ldw	r8,248(sp)
 20447c0:	103c280e 	bge	r2,zero,2043864 <__alt_mem_mem_0+0xfd023864>
 20447c4:	0005883a 	mov	r2,zero
 20447c8:	003c2606 	br	2043864 <__alt_mem_mem_0+0xfd023864>
 20447cc:	00bfffc4 	movi	r2,-1
 20447d0:	003a0906 	br	2042ff8 <__alt_mem_mem_0+0xfd022ff8>
 20447d4:	01008174 	movhi	r4,517
 20447d8:	2123db04 	addi	r4,r4,-28820
 20447dc:	d9003515 	stw	r4,212(sp)
 20447e0:	003b0606 	br	20433fc <__alt_mem_mem_0+0xfd0233fc>
 20447e4:	013fffc4 	movi	r4,-1
 20447e8:	003a2706 	br	2043088 <__alt_mem_mem_0+0xfd023088>
 20447ec:	d9402c17 	ldw	r5,176(sp)
 20447f0:	d9801e04 	addi	r6,sp,120
 20447f4:	9809883a 	mov	r4,r19
 20447f8:	20450c00 	call	20450c0 <__ssprint_r>
 20447fc:	1039f91e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2044800:	d8c02017 	ldw	r3,128(sp)
 2044804:	da000404 	addi	r8,sp,16
 2044808:	003d8406 	br	2043e1c <__alt_mem_mem_0+0xfd023e1c>
 204480c:	0023883a 	mov	r17,zero
 2044810:	003d8306 	br	2043e20 <__alt_mem_mem_0+0xfd023e20>
 2044814:	01008174 	movhi	r4,517
 2044818:	2123d704 	addi	r4,r4,-28836
 204481c:	d9002b15 	stw	r4,172(sp)
 2044820:	d9002b17 	ldw	r4,172(sp)
 2044824:	1c47883a 	add	r3,r3,r17
 2044828:	10800044 	addi	r2,r2,1
 204482c:	41000015 	stw	r4,0(r8)
 2044830:	44400115 	stw	r17,4(r8)
 2044834:	d8c02015 	stw	r3,128(sp)
 2044838:	d8801f15 	stw	r2,124(sp)
 204483c:	010001c4 	movi	r4,7
 2044840:	20bfcd16 	blt	r4,r2,2044778 <__alt_mem_mem_0+0xfd024778>
 2044844:	42000204 	addi	r8,r8,8
 2044848:	003fd306 	br	2044798 <__alt_mem_mem_0+0xfd024798>
 204484c:	d9402c17 	ldw	r5,176(sp)
 2044850:	d9801e04 	addi	r6,sp,120
 2044854:	9809883a 	mov	r4,r19
 2044858:	20450c00 	call	20450c0 <__ssprint_r>
 204485c:	1039e11e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2044860:	d8802617 	ldw	r2,152(sp)
 2044864:	d8c02017 	ldw	r3,128(sp)
 2044868:	da000404 	addi	r8,sp,16
 204486c:	003e1c06 	br	20440e0 <__alt_mem_mem_0+0xfd0240e0>
 2044870:	d8802917 	ldw	r2,164(sp)
 2044874:	00c00184 	movi	r3,6
 2044878:	1880012e 	bgeu	r3,r2,2044880 <___svfprintf_internal_r+0x1c30>
 204487c:	1805883a 	mov	r2,r3
 2044880:	d8802e15 	stw	r2,184(sp)
 2044884:	1000f316 	blt	r2,zero,2044c54 <___svfprintf_internal_r+0x2004>
 2044888:	04008134 	movhi	r16,516
 204488c:	d8802a15 	stw	r2,168(sp)
 2044890:	dd002d15 	stw	r20,180(sp)
 2044894:	d8002915 	stw	zero,164(sp)
 2044898:	d8003215 	stw	zero,200(sp)
 204489c:	841a8a04 	addi	r16,r16,27176
 20448a0:	0039883a 	mov	fp,zero
 20448a4:	003a9f06 	br	2043324 <__alt_mem_mem_0+0xfd023324>
 20448a8:	01008174 	movhi	r4,517
 20448ac:	2123db04 	addi	r4,r4,-28820
 20448b0:	d9003515 	stw	r4,212(sp)
 20448b4:	003b5f06 	br	2043634 <__alt_mem_mem_0+0xfd023634>
 20448b8:	d9402c17 	ldw	r5,176(sp)
 20448bc:	d9801e04 	addi	r6,sp,120
 20448c0:	9809883a 	mov	r4,r19
 20448c4:	20450c00 	call	20450c0 <__ssprint_r>
 20448c8:	1039c61e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 20448cc:	d8802617 	ldw	r2,152(sp)
 20448d0:	d9403317 	ldw	r5,204(sp)
 20448d4:	d8c02017 	ldw	r3,128(sp)
 20448d8:	da000404 	addi	r8,sp,16
 20448dc:	2885c83a 	sub	r2,r5,r2
 20448e0:	003e1006 	br	2044124 <__alt_mem_mem_0+0xfd024124>
 20448e4:	00800044 	movi	r2,1
 20448e8:	10803fcc 	andi	r2,r2,255
 20448ec:	00c00044 	movi	r3,1
 20448f0:	10fa3526 	beq	r2,r3,20431c8 <__alt_mem_mem_0+0xfd0231c8>
 20448f4:	00c00084 	movi	r3,2
 20448f8:	10fb9e26 	beq	r2,r3,2043774 <__alt_mem_mem_0+0xfd023774>
 20448fc:	003a6406 	br	2043290 <__alt_mem_mem_0+0xfd023290>
 2044900:	0021883a 	mov	r16,zero
 2044904:	003e0806 	br	2044128 <__alt_mem_mem_0+0xfd024128>
 2044908:	07000b44 	movi	fp,45
 204490c:	df002785 	stb	fp,158(sp)
 2044910:	003a0b06 	br	2043140 <__alt_mem_mem_0+0xfd023140>
 2044914:	d8c02d17 	ldw	r3,180(sp)
 2044918:	d9002f17 	ldw	r4,188(sp)
 204491c:	18800017 	ldw	r2,0(r3)
 2044920:	18c00104 	addi	r3,r3,4
 2044924:	d8c02d15 	stw	r3,180(sp)
 2044928:	11000015 	stw	r4,0(r2)
 204492c:	0038f306 	br	2042cfc <__alt_mem_mem_0+0xfd022cfc>
 2044930:	00c00b44 	movi	r3,45
 2044934:	d8c02785 	stb	r3,158(sp)
 2044938:	d8802a15 	stw	r2,168(sp)
 204493c:	dc802b17 	ldw	r18,172(sp)
 2044940:	d8002915 	stw	zero,164(sp)
 2044944:	07000b44 	movi	fp,45
 2044948:	003a7306 	br	2043318 <__alt_mem_mem_0+0xfd023318>
 204494c:	9080004c 	andi	r2,r18,1
 2044950:	1000941e 	bne	r2,zero,2044ba4 <___svfprintf_internal_r+0x1f54>
 2044954:	d8802117 	ldw	r2,132(sp)
 2044958:	1405c83a 	sub	r2,r2,r16
 204495c:	d8803315 	stw	r2,204(sp)
 2044960:	b441161e 	bne	r22,r17,2044dbc <___svfprintf_internal_r+0x216c>
 2044964:	dd802617 	ldw	r22,152(sp)
 2044968:	00bfff44 	movi	r2,-3
 204496c:	b0801a16 	blt	r22,r2,20449d8 <___svfprintf_internal_r+0x1d88>
 2044970:	d9402917 	ldw	r5,164(sp)
 2044974:	2d801816 	blt	r5,r22,20449d8 <___svfprintf_internal_r+0x1d88>
 2044978:	dd803215 	stw	r22,200(sp)
 204497c:	003f3a06 	br	2044668 <__alt_mem_mem_0+0xfd024668>
 2044980:	1025883a 	mov	r18,r2
 2044984:	0039883a 	mov	fp,zero
 2044988:	00800084 	movi	r2,2
 204498c:	003fd606 	br	20448e8 <__alt_mem_mem_0+0xfd0248e8>
 2044990:	9080004c 	andi	r2,r18,1
 2044994:	103f191e 	bne	r2,zero,20445fc <__alt_mem_mem_0+0xfd0245fc>
 2044998:	d8802117 	ldw	r2,132(sp)
 204499c:	003f2806 	br	2044640 <__alt_mem_mem_0+0xfd024640>
 20449a0:	01008174 	movhi	r4,517
 20449a4:	2123d704 	addi	r4,r4,-28836
 20449a8:	d9002b15 	stw	r4,172(sp)
 20449ac:	003c7c06 	br	2043ba0 <__alt_mem_mem_0+0xfd023ba0>
 20449b0:	e005883a 	mov	r2,fp
 20449b4:	003f2206 	br	2044640 <__alt_mem_mem_0+0xfd024640>
 20449b8:	d9402917 	ldw	r5,164(sp)
 20449bc:	df002783 	ldbu	fp,158(sp)
 20449c0:	dd002d15 	stw	r20,180(sp)
 20449c4:	d9402a15 	stw	r5,168(sp)
 20449c8:	d9402e15 	stw	r5,184(sp)
 20449cc:	d8002915 	stw	zero,164(sp)
 20449d0:	d8003215 	stw	zero,200(sp)
 20449d4:	003a4c06 	br	2043308 <__alt_mem_mem_0+0xfd023308>
 20449d8:	8c7fff84 	addi	r17,r17,-2
 20449dc:	b5bfffc4 	addi	r22,r22,-1
 20449e0:	dd802615 	stw	r22,152(sp)
 20449e4:	dc4022c5 	stb	r17,139(sp)
 20449e8:	b000c316 	blt	r22,zero,2044cf8 <___svfprintf_internal_r+0x20a8>
 20449ec:	00800ac4 	movi	r2,43
 20449f0:	d8802305 	stb	r2,140(sp)
 20449f4:	00800244 	movi	r2,9
 20449f8:	15806e16 	blt	r2,r22,2044bb4 <___svfprintf_internal_r+0x1f64>
 20449fc:	00800c04 	movi	r2,48
 2044a00:	b5800c04 	addi	r22,r22,48
 2044a04:	d8802345 	stb	r2,141(sp)
 2044a08:	dd802385 	stb	r22,142(sp)
 2044a0c:	d88023c4 	addi	r2,sp,143
 2044a10:	df0022c4 	addi	fp,sp,139
 2044a14:	d8c03317 	ldw	r3,204(sp)
 2044a18:	1739c83a 	sub	fp,r2,fp
 2044a1c:	d9003317 	ldw	r4,204(sp)
 2044a20:	e0c7883a 	add	r3,fp,r3
 2044a24:	df003b15 	stw	fp,236(sp)
 2044a28:	d8c02e15 	stw	r3,184(sp)
 2044a2c:	00800044 	movi	r2,1
 2044a30:	1100b70e 	bge	r2,r4,2044d10 <___svfprintf_internal_r+0x20c0>
 2044a34:	d8c02e17 	ldw	r3,184(sp)
 2044a38:	18c00044 	addi	r3,r3,1
 2044a3c:	d8c02e15 	stw	r3,184(sp)
 2044a40:	1805883a 	mov	r2,r3
 2044a44:	1800b016 	blt	r3,zero,2044d08 <___svfprintf_internal_r+0x20b8>
 2044a48:	d8003215 	stw	zero,200(sp)
 2044a4c:	003f1006 	br	2044690 <__alt_mem_mem_0+0xfd024690>
 2044a50:	d8802917 	ldw	r2,164(sp)
 2044a54:	103ec71e 	bne	r2,zero,2044574 <__alt_mem_mem_0+0xfd024574>
 2044a58:	dc002915 	stw	r16,164(sp)
 2044a5c:	003ec506 	br	2044574 <__alt_mem_mem_0+0xfd024574>
 2044a60:	d9402c17 	ldw	r5,176(sp)
 2044a64:	d9801e04 	addi	r6,sp,120
 2044a68:	9809883a 	mov	r4,r19
 2044a6c:	20450c00 	call	20450c0 <__ssprint_r>
 2044a70:	10395c1e 	bne	r2,zero,2042fe4 <__alt_mem_mem_0+0xfd022fe4>
 2044a74:	dc402617 	ldw	r17,152(sp)
 2044a78:	d8c02017 	ldw	r3,128(sp)
 2044a7c:	d8801f17 	ldw	r2,124(sp)
 2044a80:	da000404 	addi	r8,sp,16
 2044a84:	003e7706 	br	2044464 <__alt_mem_mem_0+0xfd024464>
 2044a88:	582f883a 	mov	r23,r11
 2044a8c:	d8002915 	stw	zero,164(sp)
 2044a90:	0038c406 	br	2042da4 <__alt_mem_mem_0+0xfd022da4>
 2044a94:	d8c02917 	ldw	r3,164(sp)
 2044a98:	d8802104 	addi	r2,sp,132
 2044a9c:	d8800315 	stw	r2,12(sp)
 2044aa0:	d9403617 	ldw	r5,216(sp)
 2044aa4:	d8802504 	addi	r2,sp,148
 2044aa8:	d8800215 	stw	r2,8(sp)
 2044aac:	d8802604 	addi	r2,sp,152
 2044ab0:	d8c00015 	stw	r3,0(sp)
 2044ab4:	9809883a 	mov	r4,r19
 2044ab8:	d8800115 	stw	r2,4(sp)
 2044abc:	01c000c4 	movi	r7,3
 2044ac0:	a00d883a 	mov	r6,r20
 2044ac4:	da003e15 	stw	r8,248(sp)
 2044ac8:	20030440 	call	2003044 <_dtoa_r>
 2044acc:	d9002917 	ldw	r4,164(sp)
 2044ad0:	da003e17 	ldw	r8,248(sp)
 2044ad4:	1021883a 	mov	r16,r2
 2044ad8:	1139883a 	add	fp,r2,r4
 2044adc:	2007883a 	mov	r3,r4
 2044ae0:	81000007 	ldb	r4,0(r16)
 2044ae4:	00800c04 	movi	r2,48
 2044ae8:	20806f26 	beq	r4,r2,2044ca8 <___svfprintf_internal_r+0x2058>
 2044aec:	d8c02617 	ldw	r3,152(sp)
 2044af0:	e0f9883a 	add	fp,fp,r3
 2044af4:	003ec206 	br	2044600 <__alt_mem_mem_0+0xfd024600>
 2044af8:	00c00b44 	movi	r3,45
 2044afc:	2520003c 	xorhi	r20,r4,32768
 2044b00:	d8c02a05 	stb	r3,168(sp)
 2044b04:	003ea106 	br	204458c <__alt_mem_mem_0+0xfd02458c>
 2044b08:	d8c03217 	ldw	r3,200(sp)
 2044b0c:	00c0890e 	bge	zero,r3,2044d34 <___svfprintf_internal_r+0x20e4>
 2044b10:	00800044 	movi	r2,1
 2044b14:	d9003317 	ldw	r4,204(sp)
 2044b18:	1105883a 	add	r2,r2,r4
 2044b1c:	d8802e15 	stw	r2,184(sp)
 2044b20:	10005f16 	blt	r2,zero,2044ca0 <___svfprintf_internal_r+0x2050>
 2044b24:	044019c4 	movi	r17,103
 2044b28:	003ed906 	br	2044690 <__alt_mem_mem_0+0xfd024690>
 2044b2c:	d9002917 	ldw	r4,164(sp)
 2044b30:	20c00044 	addi	r3,r4,1
 2044b34:	003e9c06 	br	20445a8 <__alt_mem_mem_0+0xfd0245a8>
 2044b38:	d9002917 	ldw	r4,164(sp)
 2044b3c:	00c0680e 	bge	zero,r3,2044ce0 <___svfprintf_internal_r+0x2090>
 2044b40:	2000461e 	bne	r4,zero,2044c5c <___svfprintf_internal_r+0x200c>
 2044b44:	9480004c 	andi	r18,r18,1
 2044b48:	9000441e 	bne	r18,zero,2044c5c <___svfprintf_internal_r+0x200c>
 2044b4c:	1805883a 	mov	r2,r3
 2044b50:	1800a016 	blt	r3,zero,2044dd4 <___svfprintf_internal_r+0x2184>
 2044b54:	d8c03217 	ldw	r3,200(sp)
 2044b58:	d8c02e15 	stw	r3,184(sp)
 2044b5c:	003ecc06 	br	2044690 <__alt_mem_mem_0+0xfd024690>
 2044b60:	d9402917 	ldw	r5,164(sp)
 2044b64:	d8802104 	addi	r2,sp,132
 2044b68:	d8800315 	stw	r2,12(sp)
 2044b6c:	d9400015 	stw	r5,0(sp)
 2044b70:	d8802504 	addi	r2,sp,148
 2044b74:	d9403617 	ldw	r5,216(sp)
 2044b78:	d8800215 	stw	r2,8(sp)
 2044b7c:	d8802604 	addi	r2,sp,152
 2044b80:	d8800115 	stw	r2,4(sp)
 2044b84:	01c000c4 	movi	r7,3
 2044b88:	a00d883a 	mov	r6,r20
 2044b8c:	9809883a 	mov	r4,r19
 2044b90:	da003e15 	stw	r8,248(sp)
 2044b94:	20030440 	call	2003044 <_dtoa_r>
 2044b98:	d8c02917 	ldw	r3,164(sp)
 2044b9c:	da003e17 	ldw	r8,248(sp)
 2044ba0:	1021883a 	mov	r16,r2
 2044ba4:	00801184 	movi	r2,70
 2044ba8:	80f9883a 	add	fp,r16,r3
 2044bac:	88bfcc26 	beq	r17,r2,2044ae0 <__alt_mem_mem_0+0xfd024ae0>
 2044bb0:	003e9306 	br	2044600 <__alt_mem_mem_0+0xfd024600>
 2044bb4:	df0022c4 	addi	fp,sp,139
 2044bb8:	dc002915 	stw	r16,164(sp)
 2044bbc:	9829883a 	mov	r20,r19
 2044bc0:	e021883a 	mov	r16,fp
 2044bc4:	4027883a 	mov	r19,r8
 2044bc8:	b009883a 	mov	r4,r22
 2044bcc:	01400284 	movi	r5,10
 2044bd0:	200aa680 	call	200aa68 <__modsi3>
 2044bd4:	10800c04 	addi	r2,r2,48
 2044bd8:	843fffc4 	addi	r16,r16,-1
 2044bdc:	b009883a 	mov	r4,r22
 2044be0:	01400284 	movi	r5,10
 2044be4:	80800005 	stb	r2,0(r16)
 2044be8:	200a9e40 	call	200a9e4 <__divsi3>
 2044bec:	102d883a 	mov	r22,r2
 2044bf0:	00800244 	movi	r2,9
 2044bf4:	15bff416 	blt	r2,r22,2044bc8 <__alt_mem_mem_0+0xfd024bc8>
 2044bf8:	9811883a 	mov	r8,r19
 2044bfc:	b0800c04 	addi	r2,r22,48
 2044c00:	a027883a 	mov	r19,r20
 2044c04:	8029883a 	mov	r20,r16
 2044c08:	a17fffc4 	addi	r5,r20,-1
 2044c0c:	a0bfffc5 	stb	r2,-1(r20)
 2044c10:	dc002917 	ldw	r16,164(sp)
 2044c14:	2f00752e 	bgeu	r5,fp,2044dec <___svfprintf_internal_r+0x219c>
 2044c18:	d9c02384 	addi	r7,sp,142
 2044c1c:	3d0fc83a 	sub	r7,r7,r20
 2044c20:	d9002344 	addi	r4,sp,141
 2044c24:	e1cf883a 	add	r7,fp,r7
 2044c28:	00000106 	br	2044c30 <___svfprintf_internal_r+0x1fe0>
 2044c2c:	28800003 	ldbu	r2,0(r5)
 2044c30:	20800005 	stb	r2,0(r4)
 2044c34:	21000044 	addi	r4,r4,1
 2044c38:	29400044 	addi	r5,r5,1
 2044c3c:	21fffb1e 	bne	r4,r7,2044c2c <__alt_mem_mem_0+0xfd024c2c>
 2044c40:	d8802304 	addi	r2,sp,140
 2044c44:	1505c83a 	sub	r2,r2,r20
 2044c48:	d8c02344 	addi	r3,sp,141
 2044c4c:	1885883a 	add	r2,r3,r2
 2044c50:	003f7006 	br	2044a14 <__alt_mem_mem_0+0xfd024a14>
 2044c54:	0005883a 	mov	r2,zero
 2044c58:	003f0b06 	br	2044888 <__alt_mem_mem_0+0xfd024888>
 2044c5c:	d9002917 	ldw	r4,164(sp)
 2044c60:	d8c03217 	ldw	r3,200(sp)
 2044c64:	20800044 	addi	r2,r4,1
 2044c68:	1885883a 	add	r2,r3,r2
 2044c6c:	d8802e15 	stw	r2,184(sp)
 2044c70:	103e870e 	bge	r2,zero,2044690 <__alt_mem_mem_0+0xfd024690>
 2044c74:	0005883a 	mov	r2,zero
 2044c78:	003e8506 	br	2044690 <__alt_mem_mem_0+0xfd024690>
 2044c7c:	01008174 	movhi	r4,517
 2044c80:	2123d704 	addi	r4,r4,-28836
 2044c84:	d9002b15 	stw	r4,172(sp)
 2044c88:	003cc506 	br	2043fa0 <__alt_mem_mem_0+0xfd023fa0>
 2044c8c:	d8c03217 	ldw	r3,200(sp)
 2044c90:	18c00044 	addi	r3,r3,1
 2044c94:	d8c02e15 	stw	r3,184(sp)
 2044c98:	1805883a 	mov	r2,r3
 2044c9c:	183fa10e 	bge	r3,zero,2044b24 <__alt_mem_mem_0+0xfd024b24>
 2044ca0:	0005883a 	mov	r2,zero
 2044ca4:	003f9f06 	br	2044b24 <__alt_mem_mem_0+0xfd024b24>
 2044ca8:	d9003617 	ldw	r4,216(sp)
 2044cac:	000d883a 	mov	r6,zero
 2044cb0:	000f883a 	mov	r7,zero
 2044cb4:	a00b883a 	mov	r5,r20
 2044cb8:	d8c03d15 	stw	r3,244(sp)
 2044cbc:	da003e15 	stw	r8,248(sp)
 2044cc0:	200bd2c0 	call	200bd2c <__eqdf2>
 2044cc4:	d8c03d17 	ldw	r3,244(sp)
 2044cc8:	da003e17 	ldw	r8,248(sp)
 2044ccc:	103f8726 	beq	r2,zero,2044aec <__alt_mem_mem_0+0xfd024aec>
 2044cd0:	00800044 	movi	r2,1
 2044cd4:	10c7c83a 	sub	r3,r2,r3
 2044cd8:	d8c02615 	stw	r3,152(sp)
 2044cdc:	003f8406 	br	2044af0 <__alt_mem_mem_0+0xfd024af0>
 2044ce0:	20000e1e 	bne	r4,zero,2044d1c <___svfprintf_internal_r+0x20cc>
 2044ce4:	9480004c 	andi	r18,r18,1
 2044ce8:	90000c1e 	bne	r18,zero,2044d1c <___svfprintf_internal_r+0x20cc>
 2044cec:	00800044 	movi	r2,1
 2044cf0:	d8802e15 	stw	r2,184(sp)
 2044cf4:	003e6606 	br	2044690 <__alt_mem_mem_0+0xfd024690>
 2044cf8:	00800b44 	movi	r2,45
 2044cfc:	05adc83a 	sub	r22,zero,r22
 2044d00:	d8802305 	stb	r2,140(sp)
 2044d04:	003f3b06 	br	20449f4 <__alt_mem_mem_0+0xfd0249f4>
 2044d08:	0005883a 	mov	r2,zero
 2044d0c:	003f4e06 	br	2044a48 <__alt_mem_mem_0+0xfd024a48>
 2044d10:	90a4703a 	and	r18,r18,r2
 2044d14:	903f4a26 	beq	r18,zero,2044a40 <__alt_mem_mem_0+0xfd024a40>
 2044d18:	003f4606 	br	2044a34 <__alt_mem_mem_0+0xfd024a34>
 2044d1c:	d8c02917 	ldw	r3,164(sp)
 2044d20:	18c00084 	addi	r3,r3,2
 2044d24:	d8c02e15 	stw	r3,184(sp)
 2044d28:	1805883a 	mov	r2,r3
 2044d2c:	183e580e 	bge	r3,zero,2044690 <__alt_mem_mem_0+0xfd024690>
 2044d30:	003fd006 	br	2044c74 <__alt_mem_mem_0+0xfd024c74>
 2044d34:	00800084 	movi	r2,2
 2044d38:	10c5c83a 	sub	r2,r2,r3
 2044d3c:	003f7506 	br	2044b14 <__alt_mem_mem_0+0xfd024b14>
 2044d40:	d8802d17 	ldw	r2,180(sp)
 2044d44:	d9002d17 	ldw	r4,180(sp)
 2044d48:	bc400043 	ldbu	r17,1(r23)
 2044d4c:	10800017 	ldw	r2,0(r2)
 2044d50:	582f883a 	mov	r23,r11
 2044d54:	d8802915 	stw	r2,164(sp)
 2044d58:	20800104 	addi	r2,r4,4
 2044d5c:	d9002917 	ldw	r4,164(sp)
 2044d60:	d8802d15 	stw	r2,180(sp)
 2044d64:	203df00e 	bge	r4,zero,2044528 <__alt_mem_mem_0+0xfd024528>
 2044d68:	8c403fcc 	andi	r17,r17,255
 2044d6c:	00bfffc4 	movi	r2,-1
 2044d70:	8c40201c 	xori	r17,r17,128
 2044d74:	d8802915 	stw	r2,164(sp)
 2044d78:	8c7fe004 	addi	r17,r17,-128
 2044d7c:	00380806 	br	2042da0 <__alt_mem_mem_0+0xfd022da0>
 2044d80:	9080004c 	andi	r2,r18,1
 2044d84:	0039883a 	mov	fp,zero
 2044d88:	10000726 	beq	r2,zero,2044da8 <___svfprintf_internal_r+0x2158>
 2044d8c:	d8c02817 	ldw	r3,160(sp)
 2044d90:	dc001dc4 	addi	r16,sp,119
 2044d94:	00800c04 	movi	r2,48
 2044d98:	1c07c83a 	sub	r3,r3,r16
 2044d9c:	d8801dc5 	stb	r2,119(sp)
 2044da0:	d8c02e15 	stw	r3,184(sp)
 2044da4:	00395206 	br	20432f0 <__alt_mem_mem_0+0xfd0232f0>
 2044da8:	d8002e15 	stw	zero,184(sp)
 2044dac:	dc001e04 	addi	r16,sp,120
 2044db0:	00394f06 	br	20432f0 <__alt_mem_mem_0+0xfd0232f0>
 2044db4:	0005883a 	mov	r2,zero
 2044db8:	003e3206 	br	2044684 <__alt_mem_mem_0+0xfd024684>
 2044dbc:	dd802617 	ldw	r22,152(sp)
 2044dc0:	003f0606 	br	20449dc <__alt_mem_mem_0+0xfd0249dc>
 2044dc4:	d9c02785 	stb	r7,158(sp)
 2044dc8:	003a5106 	br	2043710 <__alt_mem_mem_0+0xfd023710>
 2044dcc:	d9c02785 	stb	r7,158(sp)
 2044dd0:	003a3706 	br	20436b0 <__alt_mem_mem_0+0xfd0236b0>
 2044dd4:	0005883a 	mov	r2,zero
 2044dd8:	003f5e06 	br	2044b54 <__alt_mem_mem_0+0xfd024b54>
 2044ddc:	d9c02785 	stb	r7,158(sp)
 2044de0:	00391706 	br	2043240 <__alt_mem_mem_0+0xfd023240>
 2044de4:	d9c02785 	stb	r7,158(sp)
 2044de8:	0038e606 	br	2043184 <__alt_mem_mem_0+0xfd023184>
 2044dec:	d8802344 	addi	r2,sp,141
 2044df0:	003f0806 	br	2044a14 <__alt_mem_mem_0+0xfd024a14>
 2044df4:	d9c02785 	stb	r7,158(sp)
 2044df8:	0038b706 	br	20430d8 <__alt_mem_mem_0+0xfd0230d8>
 2044dfc:	d9c02785 	stb	r7,158(sp)
 2044e00:	003adc06 	br	2043974 <__alt_mem_mem_0+0xfd023974>
 2044e04:	d9403917 	ldw	r5,228(sp)
 2044e08:	00800304 	movi	r2,12
 2044e0c:	28800015 	stw	r2,0(r5)
 2044e10:	00bfffc4 	movi	r2,-1
 2044e14:	00387806 	br	2042ff8 <__alt_mem_mem_0+0xfd022ff8>
 2044e18:	d9c02785 	stb	r7,158(sp)
 2044e1c:	003abf06 	br	204391c <__alt_mem_mem_0+0xfd02391c>
 2044e20:	d9c02785 	stb	r7,158(sp)
 2044e24:	003a9b06 	br	2043894 <__alt_mem_mem_0+0xfd023894>

02044e28 <__register_exitproc>:
 2044e28:	defffa04 	addi	sp,sp,-24
 2044e2c:	dc000315 	stw	r16,12(sp)
 2044e30:	04008174 	movhi	r16,517
 2044e34:	842b3f04 	addi	r16,r16,-21252
 2044e38:	80c00017 	ldw	r3,0(r16)
 2044e3c:	dc400415 	stw	r17,16(sp)
 2044e40:	dfc00515 	stw	ra,20(sp)
 2044e44:	18805217 	ldw	r2,328(r3)
 2044e48:	2023883a 	mov	r17,r4
 2044e4c:	10003726 	beq	r2,zero,2044f2c <__register_exitproc+0x104>
 2044e50:	10c00117 	ldw	r3,4(r2)
 2044e54:	010007c4 	movi	r4,31
 2044e58:	20c00e16 	blt	r4,r3,2044e94 <__register_exitproc+0x6c>
 2044e5c:	1a000044 	addi	r8,r3,1
 2044e60:	8800221e 	bne	r17,zero,2044eec <__register_exitproc+0xc4>
 2044e64:	18c00084 	addi	r3,r3,2
 2044e68:	18c7883a 	add	r3,r3,r3
 2044e6c:	18c7883a 	add	r3,r3,r3
 2044e70:	12000115 	stw	r8,4(r2)
 2044e74:	10c7883a 	add	r3,r2,r3
 2044e78:	19400015 	stw	r5,0(r3)
 2044e7c:	0005883a 	mov	r2,zero
 2044e80:	dfc00517 	ldw	ra,20(sp)
 2044e84:	dc400417 	ldw	r17,16(sp)
 2044e88:	dc000317 	ldw	r16,12(sp)
 2044e8c:	dec00604 	addi	sp,sp,24
 2044e90:	f800283a 	ret
 2044e94:	00808134 	movhi	r2,516
 2044e98:	10890004 	addi	r2,r2,9216
 2044e9c:	10002626 	beq	r2,zero,2044f38 <__register_exitproc+0x110>
 2044ea0:	01006404 	movi	r4,400
 2044ea4:	d9400015 	stw	r5,0(sp)
 2044ea8:	d9800115 	stw	r6,4(sp)
 2044eac:	d9c00215 	stw	r7,8(sp)
 2044eb0:	20424000 	call	2042400 <malloc>
 2044eb4:	d9400017 	ldw	r5,0(sp)
 2044eb8:	d9800117 	ldw	r6,4(sp)
 2044ebc:	d9c00217 	ldw	r7,8(sp)
 2044ec0:	10001d26 	beq	r2,zero,2044f38 <__register_exitproc+0x110>
 2044ec4:	81000017 	ldw	r4,0(r16)
 2044ec8:	10000115 	stw	zero,4(r2)
 2044ecc:	02000044 	movi	r8,1
 2044ed0:	22405217 	ldw	r9,328(r4)
 2044ed4:	0007883a 	mov	r3,zero
 2044ed8:	12400015 	stw	r9,0(r2)
 2044edc:	20805215 	stw	r2,328(r4)
 2044ee0:	10006215 	stw	zero,392(r2)
 2044ee4:	10006315 	stw	zero,396(r2)
 2044ee8:	883fde26 	beq	r17,zero,2044e64 <__alt_mem_mem_0+0xfd024e64>
 2044eec:	18c9883a 	add	r4,r3,r3
 2044ef0:	2109883a 	add	r4,r4,r4
 2044ef4:	1109883a 	add	r4,r2,r4
 2044ef8:	21802215 	stw	r6,136(r4)
 2044efc:	01800044 	movi	r6,1
 2044f00:	12406217 	ldw	r9,392(r2)
 2044f04:	30cc983a 	sll	r6,r6,r3
 2044f08:	4992b03a 	or	r9,r9,r6
 2044f0c:	12406215 	stw	r9,392(r2)
 2044f10:	21c04215 	stw	r7,264(r4)
 2044f14:	01000084 	movi	r4,2
 2044f18:	893fd21e 	bne	r17,r4,2044e64 <__alt_mem_mem_0+0xfd024e64>
 2044f1c:	11006317 	ldw	r4,396(r2)
 2044f20:	218cb03a 	or	r6,r4,r6
 2044f24:	11806315 	stw	r6,396(r2)
 2044f28:	003fce06 	br	2044e64 <__alt_mem_mem_0+0xfd024e64>
 2044f2c:	18805304 	addi	r2,r3,332
 2044f30:	18805215 	stw	r2,328(r3)
 2044f34:	003fc606 	br	2044e50 <__alt_mem_mem_0+0xfd024e50>
 2044f38:	00bfffc4 	movi	r2,-1
 2044f3c:	003fd006 	br	2044e80 <__alt_mem_mem_0+0xfd024e80>

02044f40 <__call_exitprocs>:
 2044f40:	defff504 	addi	sp,sp,-44
 2044f44:	df000915 	stw	fp,36(sp)
 2044f48:	dd400615 	stw	r21,24(sp)
 2044f4c:	dc800315 	stw	r18,12(sp)
 2044f50:	dfc00a15 	stw	ra,40(sp)
 2044f54:	ddc00815 	stw	r23,32(sp)
 2044f58:	dd800715 	stw	r22,28(sp)
 2044f5c:	dd000515 	stw	r20,20(sp)
 2044f60:	dcc00415 	stw	r19,16(sp)
 2044f64:	dc400215 	stw	r17,8(sp)
 2044f68:	dc000115 	stw	r16,4(sp)
 2044f6c:	d9000015 	stw	r4,0(sp)
 2044f70:	2839883a 	mov	fp,r5
 2044f74:	04800044 	movi	r18,1
 2044f78:	057fffc4 	movi	r21,-1
 2044f7c:	00808174 	movhi	r2,517
 2044f80:	10ab3f04 	addi	r2,r2,-21252
 2044f84:	12000017 	ldw	r8,0(r2)
 2044f88:	45005217 	ldw	r20,328(r8)
 2044f8c:	44c05204 	addi	r19,r8,328
 2044f90:	a0001c26 	beq	r20,zero,2045004 <__call_exitprocs+0xc4>
 2044f94:	a0800117 	ldw	r2,4(r20)
 2044f98:	15ffffc4 	addi	r23,r2,-1
 2044f9c:	b8000d16 	blt	r23,zero,2044fd4 <__call_exitprocs+0x94>
 2044fa0:	14000044 	addi	r16,r2,1
 2044fa4:	8421883a 	add	r16,r16,r16
 2044fa8:	8421883a 	add	r16,r16,r16
 2044fac:	84402004 	addi	r17,r16,128
 2044fb0:	a463883a 	add	r17,r20,r17
 2044fb4:	a421883a 	add	r16,r20,r16
 2044fb8:	e0001e26 	beq	fp,zero,2045034 <__call_exitprocs+0xf4>
 2044fbc:	80804017 	ldw	r2,256(r16)
 2044fc0:	e0801c26 	beq	fp,r2,2045034 <__call_exitprocs+0xf4>
 2044fc4:	bdffffc4 	addi	r23,r23,-1
 2044fc8:	843fff04 	addi	r16,r16,-4
 2044fcc:	8c7fff04 	addi	r17,r17,-4
 2044fd0:	bd7ff91e 	bne	r23,r21,2044fb8 <__alt_mem_mem_0+0xfd024fb8>
 2044fd4:	00808134 	movhi	r2,516
 2044fd8:	10890504 	addi	r2,r2,9236
 2044fdc:	10000926 	beq	r2,zero,2045004 <__call_exitprocs+0xc4>
 2044fe0:	a0800117 	ldw	r2,4(r20)
 2044fe4:	1000301e 	bne	r2,zero,20450a8 <__call_exitprocs+0x168>
 2044fe8:	a0800017 	ldw	r2,0(r20)
 2044fec:	10003226 	beq	r2,zero,20450b8 <__call_exitprocs+0x178>
 2044ff0:	a009883a 	mov	r4,r20
 2044ff4:	98800015 	stw	r2,0(r19)
 2044ff8:	20424140 	call	2042414 <free>
 2044ffc:	9d000017 	ldw	r20,0(r19)
 2045000:	a03fe41e 	bne	r20,zero,2044f94 <__alt_mem_mem_0+0xfd024f94>
 2045004:	dfc00a17 	ldw	ra,40(sp)
 2045008:	df000917 	ldw	fp,36(sp)
 204500c:	ddc00817 	ldw	r23,32(sp)
 2045010:	dd800717 	ldw	r22,28(sp)
 2045014:	dd400617 	ldw	r21,24(sp)
 2045018:	dd000517 	ldw	r20,20(sp)
 204501c:	dcc00417 	ldw	r19,16(sp)
 2045020:	dc800317 	ldw	r18,12(sp)
 2045024:	dc400217 	ldw	r17,8(sp)
 2045028:	dc000117 	ldw	r16,4(sp)
 204502c:	dec00b04 	addi	sp,sp,44
 2045030:	f800283a 	ret
 2045034:	a0800117 	ldw	r2,4(r20)
 2045038:	80c00017 	ldw	r3,0(r16)
 204503c:	10bfffc4 	addi	r2,r2,-1
 2045040:	15c01426 	beq	r2,r23,2045094 <__call_exitprocs+0x154>
 2045044:	80000015 	stw	zero,0(r16)
 2045048:	183fde26 	beq	r3,zero,2044fc4 <__alt_mem_mem_0+0xfd024fc4>
 204504c:	95c8983a 	sll	r4,r18,r23
 2045050:	a0806217 	ldw	r2,392(r20)
 2045054:	a5800117 	ldw	r22,4(r20)
 2045058:	2084703a 	and	r2,r4,r2
 204505c:	10000b26 	beq	r2,zero,204508c <__call_exitprocs+0x14c>
 2045060:	a0806317 	ldw	r2,396(r20)
 2045064:	2088703a 	and	r4,r4,r2
 2045068:	20000c1e 	bne	r4,zero,204509c <__call_exitprocs+0x15c>
 204506c:	89400017 	ldw	r5,0(r17)
 2045070:	d9000017 	ldw	r4,0(sp)
 2045074:	183ee83a 	callr	r3
 2045078:	a0800117 	ldw	r2,4(r20)
 204507c:	15bfbf1e 	bne	r2,r22,2044f7c <__alt_mem_mem_0+0xfd024f7c>
 2045080:	98800017 	ldw	r2,0(r19)
 2045084:	153fcf26 	beq	r2,r20,2044fc4 <__alt_mem_mem_0+0xfd024fc4>
 2045088:	003fbc06 	br	2044f7c <__alt_mem_mem_0+0xfd024f7c>
 204508c:	183ee83a 	callr	r3
 2045090:	003ff906 	br	2045078 <__alt_mem_mem_0+0xfd025078>
 2045094:	a5c00115 	stw	r23,4(r20)
 2045098:	003feb06 	br	2045048 <__alt_mem_mem_0+0xfd025048>
 204509c:	89000017 	ldw	r4,0(r17)
 20450a0:	183ee83a 	callr	r3
 20450a4:	003ff406 	br	2045078 <__alt_mem_mem_0+0xfd025078>
 20450a8:	a0800017 	ldw	r2,0(r20)
 20450ac:	a027883a 	mov	r19,r20
 20450b0:	1029883a 	mov	r20,r2
 20450b4:	003fb606 	br	2044f90 <__alt_mem_mem_0+0xfd024f90>
 20450b8:	0005883a 	mov	r2,zero
 20450bc:	003ffb06 	br	20450ac <__alt_mem_mem_0+0xfd0250ac>

020450c0 <__ssprint_r>:
 20450c0:	30800217 	ldw	r2,8(r6)
 20450c4:	defff604 	addi	sp,sp,-40
 20450c8:	dc800215 	stw	r18,8(sp)
 20450cc:	dfc00915 	stw	ra,36(sp)
 20450d0:	df000815 	stw	fp,32(sp)
 20450d4:	ddc00715 	stw	r23,28(sp)
 20450d8:	dd800615 	stw	r22,24(sp)
 20450dc:	dd400515 	stw	r21,20(sp)
 20450e0:	dd000415 	stw	r20,16(sp)
 20450e4:	dcc00315 	stw	r19,12(sp)
 20450e8:	dc400115 	stw	r17,4(sp)
 20450ec:	dc000015 	stw	r16,0(sp)
 20450f0:	3025883a 	mov	r18,r6
 20450f4:	10005826 	beq	r2,zero,2045258 <__ssprint_r+0x198>
 20450f8:	2027883a 	mov	r19,r4
 20450fc:	35c00017 	ldw	r23,0(r6)
 2045100:	29000017 	ldw	r4,0(r5)
 2045104:	28800217 	ldw	r2,8(r5)
 2045108:	2823883a 	mov	r17,r5
 204510c:	0039883a 	mov	fp,zero
 2045110:	0021883a 	mov	r16,zero
 2045114:	80003926 	beq	r16,zero,20451fc <__ssprint_r+0x13c>
 2045118:	102b883a 	mov	r21,r2
 204511c:	102d883a 	mov	r22,r2
 2045120:	80803a36 	bltu	r16,r2,204520c <__ssprint_r+0x14c>
 2045124:	88c0030b 	ldhu	r3,12(r17)
 2045128:	1881200c 	andi	r2,r3,1152
 204512c:	10002626 	beq	r2,zero,20451c8 <__ssprint_r+0x108>
 2045130:	88800517 	ldw	r2,20(r17)
 2045134:	89400417 	ldw	r5,16(r17)
 2045138:	81800044 	addi	r6,r16,1
 204513c:	108f883a 	add	r7,r2,r2
 2045140:	3885883a 	add	r2,r7,r2
 2045144:	100ed7fa 	srli	r7,r2,31
 2045148:	216dc83a 	sub	r22,r4,r5
 204514c:	3589883a 	add	r4,r6,r22
 2045150:	3885883a 	add	r2,r7,r2
 2045154:	102bd07a 	srai	r21,r2,1
 2045158:	a80d883a 	mov	r6,r21
 204515c:	a900022e 	bgeu	r21,r4,2045168 <__ssprint_r+0xa8>
 2045160:	202b883a 	mov	r21,r4
 2045164:	200d883a 	mov	r6,r4
 2045168:	18c1000c 	andi	r3,r3,1024
 204516c:	18002a26 	beq	r3,zero,2045218 <__ssprint_r+0x158>
 2045170:	300b883a 	mov	r5,r6
 2045174:	9809883a 	mov	r4,r19
 2045178:	20055680 	call	2005568 <_malloc_r>
 204517c:	1029883a 	mov	r20,r2
 2045180:	10002c26 	beq	r2,zero,2045234 <__ssprint_r+0x174>
 2045184:	89400417 	ldw	r5,16(r17)
 2045188:	b00d883a 	mov	r6,r22
 204518c:	1009883a 	mov	r4,r2
 2045190:	2005e580 	call	2005e58 <memcpy>
 2045194:	8880030b 	ldhu	r2,12(r17)
 2045198:	00fedfc4 	movi	r3,-1153
 204519c:	10c4703a 	and	r2,r2,r3
 20451a0:	10802014 	ori	r2,r2,128
 20451a4:	8880030d 	sth	r2,12(r17)
 20451a8:	a589883a 	add	r4,r20,r22
 20451ac:	adadc83a 	sub	r22,r21,r22
 20451b0:	8d400515 	stw	r21,20(r17)
 20451b4:	8d800215 	stw	r22,8(r17)
 20451b8:	8d000415 	stw	r20,16(r17)
 20451bc:	89000015 	stw	r4,0(r17)
 20451c0:	802b883a 	mov	r21,r16
 20451c4:	802d883a 	mov	r22,r16
 20451c8:	b00d883a 	mov	r6,r22
 20451cc:	e00b883a 	mov	r5,fp
 20451d0:	20094d40 	call	20094d4 <memmove>
 20451d4:	88800217 	ldw	r2,8(r17)
 20451d8:	89000017 	ldw	r4,0(r17)
 20451dc:	90c00217 	ldw	r3,8(r18)
 20451e0:	1545c83a 	sub	r2,r2,r21
 20451e4:	2589883a 	add	r4,r4,r22
 20451e8:	88800215 	stw	r2,8(r17)
 20451ec:	89000015 	stw	r4,0(r17)
 20451f0:	1c21c83a 	sub	r16,r3,r16
 20451f4:	94000215 	stw	r16,8(r18)
 20451f8:	80001726 	beq	r16,zero,2045258 <__ssprint_r+0x198>
 20451fc:	bf000017 	ldw	fp,0(r23)
 2045200:	bc000117 	ldw	r16,4(r23)
 2045204:	bdc00204 	addi	r23,r23,8
 2045208:	003fc206 	br	2045114 <__alt_mem_mem_0+0xfd025114>
 204520c:	802b883a 	mov	r21,r16
 2045210:	802d883a 	mov	r22,r16
 2045214:	003fec06 	br	20451c8 <__alt_mem_mem_0+0xfd0251c8>
 2045218:	9809883a 	mov	r4,r19
 204521c:	20096900 	call	2009690 <_realloc_r>
 2045220:	1029883a 	mov	r20,r2
 2045224:	103fe01e 	bne	r2,zero,20451a8 <__alt_mem_mem_0+0xfd0251a8>
 2045228:	89400417 	ldw	r5,16(r17)
 204522c:	9809883a 	mov	r4,r19
 2045230:	2004e380 	call	2004e38 <_free_r>
 2045234:	88c0030b 	ldhu	r3,12(r17)
 2045238:	00800304 	movi	r2,12
 204523c:	98800015 	stw	r2,0(r19)
 2045240:	18c01014 	ori	r3,r3,64
 2045244:	88c0030d 	sth	r3,12(r17)
 2045248:	00bfffc4 	movi	r2,-1
 204524c:	90000215 	stw	zero,8(r18)
 2045250:	90000115 	stw	zero,4(r18)
 2045254:	00000206 	br	2045260 <__ssprint_r+0x1a0>
 2045258:	90000115 	stw	zero,4(r18)
 204525c:	0005883a 	mov	r2,zero
 2045260:	dfc00917 	ldw	ra,36(sp)
 2045264:	df000817 	ldw	fp,32(sp)
 2045268:	ddc00717 	ldw	r23,28(sp)
 204526c:	dd800617 	ldw	r22,24(sp)
 2045270:	dd400517 	ldw	r21,20(sp)
 2045274:	dd000417 	ldw	r20,16(sp)
 2045278:	dcc00317 	ldw	r19,12(sp)
 204527c:	dc800217 	ldw	r18,8(sp)
 2045280:	dc400117 	ldw	r17,4(sp)
 2045284:	dc000017 	ldw	r16,0(sp)
 2045288:	dec00a04 	addi	sp,sp,40
 204528c:	f800283a 	ret

02045290 <___svfiprintf_internal_r>:
 2045290:	2880030b 	ldhu	r2,12(r5)
 2045294:	deffc804 	addi	sp,sp,-224
 2045298:	dcc03115 	stw	r19,196(sp)
 204529c:	dfc03715 	stw	ra,220(sp)
 20452a0:	df003615 	stw	fp,216(sp)
 20452a4:	ddc03515 	stw	r23,212(sp)
 20452a8:	dd803415 	stw	r22,208(sp)
 20452ac:	dd403315 	stw	r21,204(sp)
 20452b0:	dd003215 	stw	r20,200(sp)
 20452b4:	dc803015 	stw	r18,192(sp)
 20452b8:	dc402f15 	stw	r17,188(sp)
 20452bc:	dc002e15 	stw	r16,184(sp)
 20452c0:	d9402715 	stw	r5,156(sp)
 20452c4:	d9002a15 	stw	r4,168(sp)
 20452c8:	1080200c 	andi	r2,r2,128
 20452cc:	d9c02315 	stw	r7,140(sp)
 20452d0:	3027883a 	mov	r19,r6
 20452d4:	10000226 	beq	r2,zero,20452e0 <___svfiprintf_internal_r+0x50>
 20452d8:	28800417 	ldw	r2,16(r5)
 20452dc:	10041d26 	beq	r2,zero,2046354 <___svfiprintf_internal_r+0x10c4>
 20452e0:	dac01a04 	addi	r11,sp,104
 20452e4:	dac01e15 	stw	r11,120(sp)
 20452e8:	d8801e17 	ldw	r2,120(sp)
 20452ec:	dac019c4 	addi	r11,sp,103
 20452f0:	dd402a17 	ldw	r21,168(sp)
 20452f4:	ddc02717 	ldw	r23,156(sp)
 20452f8:	05808174 	movhi	r22,517
 20452fc:	05008174 	movhi	r20,517
 2045300:	dac01f15 	stw	r11,124(sp)
 2045304:	12d7c83a 	sub	r11,r2,r11
 2045308:	b5a3e304 	addi	r22,r22,-28788
 204530c:	a523df04 	addi	r20,r20,-28804
 2045310:	dec01a15 	stw	sp,104(sp)
 2045314:	d8001c15 	stw	zero,112(sp)
 2045318:	d8001b15 	stw	zero,108(sp)
 204531c:	d811883a 	mov	r8,sp
 2045320:	d8002915 	stw	zero,164(sp)
 2045324:	d8002515 	stw	zero,148(sp)
 2045328:	dac02b15 	stw	r11,172(sp)
 204532c:	98800007 	ldb	r2,0(r19)
 2045330:	1002dd26 	beq	r2,zero,2045ea8 <___svfiprintf_internal_r+0xc18>
 2045334:	00c00944 	movi	r3,37
 2045338:	9823883a 	mov	r17,r19
 204533c:	10c0021e 	bne	r2,r3,2045348 <___svfiprintf_internal_r+0xb8>
 2045340:	00001406 	br	2045394 <___svfiprintf_internal_r+0x104>
 2045344:	10c00326 	beq	r2,r3,2045354 <___svfiprintf_internal_r+0xc4>
 2045348:	8c400044 	addi	r17,r17,1
 204534c:	88800007 	ldb	r2,0(r17)
 2045350:	103ffc1e 	bne	r2,zero,2045344 <__alt_mem_mem_0+0xfd025344>
 2045354:	8ce1c83a 	sub	r16,r17,r19
 2045358:	80000e26 	beq	r16,zero,2045394 <___svfiprintf_internal_r+0x104>
 204535c:	d8c01c17 	ldw	r3,112(sp)
 2045360:	d8801b17 	ldw	r2,108(sp)
 2045364:	44c00015 	stw	r19,0(r8)
 2045368:	1c07883a 	add	r3,r3,r16
 204536c:	10800044 	addi	r2,r2,1
 2045370:	d8c01c15 	stw	r3,112(sp)
 2045374:	44000115 	stw	r16,4(r8)
 2045378:	d8801b15 	stw	r2,108(sp)
 204537c:	00c001c4 	movi	r3,7
 2045380:	18831e16 	blt	r3,r2,2045ffc <___svfiprintf_internal_r+0xd6c>
 2045384:	42000204 	addi	r8,r8,8
 2045388:	dac02517 	ldw	r11,148(sp)
 204538c:	5c17883a 	add	r11,r11,r16
 2045390:	dac02515 	stw	r11,148(sp)
 2045394:	88800007 	ldb	r2,0(r17)
 2045398:	1002c526 	beq	r2,zero,2045eb0 <___svfiprintf_internal_r+0xc20>
 204539c:	88c00047 	ldb	r3,1(r17)
 20453a0:	8cc00044 	addi	r19,r17,1
 20453a4:	d8001d85 	stb	zero,118(sp)
 20453a8:	0009883a 	mov	r4,zero
 20453ac:	000f883a 	mov	r7,zero
 20453b0:	043fffc4 	movi	r16,-1
 20453b4:	d8002415 	stw	zero,144(sp)
 20453b8:	0025883a 	mov	r18,zero
 20453bc:	01401604 	movi	r5,88
 20453c0:	01800244 	movi	r6,9
 20453c4:	02800a84 	movi	r10,42
 20453c8:	02401b04 	movi	r9,108
 20453cc:	9cc00044 	addi	r19,r19,1
 20453d0:	18bff804 	addi	r2,r3,-32
 20453d4:	2881dd36 	bltu	r5,r2,2045b4c <___svfiprintf_internal_r+0x8bc>
 20453d8:	100490ba 	slli	r2,r2,2
 20453dc:	02c08134 	movhi	r11,516
 20453e0:	5ad4fc04 	addi	r11,r11,21488
 20453e4:	12c5883a 	add	r2,r2,r11
 20453e8:	10800017 	ldw	r2,0(r2)
 20453ec:	1000683a 	jmp	r2
 20453f0:	020455ec 	andhi	r8,zero,4439
 20453f4:	02045b4c 	andi	r8,zero,4461
 20453f8:	02045b4c 	andi	r8,zero,4461
 20453fc:	020455e0 	cmpeqi	r8,zero,4439
 2045400:	02045b4c 	andi	r8,zero,4461
 2045404:	02045b4c 	andi	r8,zero,4461
 2045408:	02045b4c 	andi	r8,zero,4461
 204540c:	02045b4c 	andi	r8,zero,4461
 2045410:	02045b4c 	andi	r8,zero,4461
 2045414:	02045b4c 	andi	r8,zero,4461
 2045418:	02045554 	movui	r8,4437
 204541c:	02045730 	cmpltui	r8,zero,4444
 2045420:	02045b4c 	andi	r8,zero,4461
 2045424:	02045580 	call	204558 <__alt_mem_sdram_controller_0-0x1dfbaa8>
 2045428:	02045b80 	call	2045b8 <__alt_mem_sdram_controller_0-0x1dfba48>
 204542c:	02045b4c 	andi	r8,zero,4461
 2045430:	02045b74 	movhi	r8,4461
 2045434:	02045b14 	movui	r8,4460
 2045438:	02045b14 	movui	r8,4460
 204543c:	02045b14 	movui	r8,4460
 2045440:	02045b14 	movui	r8,4460
 2045444:	02045b14 	movui	r8,4460
 2045448:	02045b14 	movui	r8,4460
 204544c:	02045b14 	movui	r8,4460
 2045450:	02045b14 	movui	r8,4460
 2045454:	02045b14 	movui	r8,4460
 2045458:	02045b4c 	andi	r8,zero,4461
 204545c:	02045b4c 	andi	r8,zero,4461
 2045460:	02045b4c 	andi	r8,zero,4461
 2045464:	02045b4c 	andi	r8,zero,4461
 2045468:	02045b4c 	andi	r8,zero,4461
 204546c:	02045b4c 	andi	r8,zero,4461
 2045470:	02045b4c 	andi	r8,zero,4461
 2045474:	02045b4c 	andi	r8,zero,4461
 2045478:	02045b4c 	andi	r8,zero,4461
 204547c:	02045b4c 	andi	r8,zero,4461
 2045480:	02045ab0 	cmpltui	r8,zero,4458
 2045484:	02045b4c 	andi	r8,zero,4461
 2045488:	02045b4c 	andi	r8,zero,4461
 204548c:	02045b4c 	andi	r8,zero,4461
 2045490:	02045b4c 	andi	r8,zero,4461
 2045494:	02045b4c 	andi	r8,zero,4461
 2045498:	02045b4c 	andi	r8,zero,4461
 204549c:	02045b4c 	andi	r8,zero,4461
 20454a0:	02045b4c 	andi	r8,zero,4461
 20454a4:	02045b4c 	andi	r8,zero,4461
 20454a8:	02045b4c 	andi	r8,zero,4461
 20454ac:	02045c28 	cmpgeui	r8,zero,4464
 20454b0:	02045b4c 	andi	r8,zero,4461
 20454b4:	02045b4c 	andi	r8,zero,4461
 20454b8:	02045b4c 	andi	r8,zero,4461
 20454bc:	02045b4c 	andi	r8,zero,4461
 20454c0:	02045b4c 	andi	r8,zero,4461
 20454c4:	02045bc0 	call	2045bc <__alt_mem_sdram_controller_0-0x1dfba44>
 20454c8:	02045b4c 	andi	r8,zero,4461
 20454cc:	02045b4c 	andi	r8,zero,4461
 20454d0:	020458f4 	movhi	r8,4451
 20454d4:	02045b4c 	andi	r8,zero,4461
 20454d8:	02045b4c 	andi	r8,zero,4461
 20454dc:	02045b4c 	andi	r8,zero,4461
 20454e0:	02045b4c 	andi	r8,zero,4461
 20454e4:	02045b4c 	andi	r8,zero,4461
 20454e8:	02045b4c 	andi	r8,zero,4461
 20454ec:	02045b4c 	andi	r8,zero,4461
 20454f0:	02045b4c 	andi	r8,zero,4461
 20454f4:	02045b4c 	andi	r8,zero,4461
 20454f8:	02045b4c 	andi	r8,zero,4461
 20454fc:	020457e4 	muli	r8,zero,4447
 2045500:	02045990 	cmplti	r8,zero,4454
 2045504:	02045b4c 	andi	r8,zero,4461
 2045508:	02045b4c 	andi	r8,zero,4461
 204550c:	02045b4c 	andi	r8,zero,4461
 2045510:	02045984 	movi	r8,4454
 2045514:	02045990 	cmplti	r8,zero,4454
 2045518:	02045b4c 	andi	r8,zero,4461
 204551c:	02045b4c 	andi	r8,zero,4461
 2045520:	02045974 	movhi	r8,4453
 2045524:	02045b4c 	andi	r8,zero,4461
 2045528:	02045938 	rdprs	r8,zero,4452
 204552c:	02045740 	call	204574 <__alt_mem_sdram_controller_0-0x1dfba8c>
 2045530:	0204558c 	andi	r8,zero,4438
 2045534:	02045aa4 	muli	r8,zero,4458
 2045538:	02045b4c 	andi	r8,zero,4461
 204553c:	02045a58 	cmpnei	r8,zero,4457
 2045540:	02045b4c 	andi	r8,zero,4461
 2045544:	020456b0 	cmpltui	r8,zero,4442
 2045548:	02045b4c 	andi	r8,zero,4461
 204554c:	02045b4c 	andi	r8,zero,4461
 2045550:	0204560c 	andi	r8,zero,4440
 2045554:	dac02317 	ldw	r11,140(sp)
 2045558:	5ac00017 	ldw	r11,0(r11)
 204555c:	dac02415 	stw	r11,144(sp)
 2045560:	dac02317 	ldw	r11,140(sp)
 2045564:	58800104 	addi	r2,r11,4
 2045568:	dac02417 	ldw	r11,144(sp)
 204556c:	5802e90e 	bge	r11,zero,2046114 <___svfiprintf_internal_r+0xe84>
 2045570:	dac02417 	ldw	r11,144(sp)
 2045574:	d8802315 	stw	r2,140(sp)
 2045578:	02d7c83a 	sub	r11,zero,r11
 204557c:	dac02415 	stw	r11,144(sp)
 2045580:	94800114 	ori	r18,r18,4
 2045584:	98c00007 	ldb	r3,0(r19)
 2045588:	003f9006 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 204558c:	00800c04 	movi	r2,48
 2045590:	dac02317 	ldw	r11,140(sp)
 2045594:	d8801d05 	stb	r2,116(sp)
 2045598:	00801e04 	movi	r2,120
 204559c:	d8801d45 	stb	r2,117(sp)
 20455a0:	d8001d85 	stb	zero,118(sp)
 20455a4:	58c00104 	addi	r3,r11,4
 20455a8:	5f000017 	ldw	fp,0(r11)
 20455ac:	0013883a 	mov	r9,zero
 20455b0:	90800094 	ori	r2,r18,2
 20455b4:	80032b16 	blt	r16,zero,2046264 <___svfiprintf_internal_r+0xfd4>
 20455b8:	00bfdfc4 	movi	r2,-129
 20455bc:	90a4703a 	and	r18,r18,r2
 20455c0:	d8c02315 	stw	r3,140(sp)
 20455c4:	94800094 	ori	r18,r18,2
 20455c8:	e002dc26 	beq	fp,zero,204613c <___svfiprintf_internal_r+0xeac>
 20455cc:	01008134 	movhi	r4,516
 20455d0:	211a8504 	addi	r4,r4,27156
 20455d4:	0015883a 	mov	r10,zero
 20455d8:	d9002915 	stw	r4,164(sp)
 20455dc:	00002306 	br	204566c <___svfiprintf_internal_r+0x3dc>
 20455e0:	94800054 	ori	r18,r18,1
 20455e4:	98c00007 	ldb	r3,0(r19)
 20455e8:	003f7806 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 20455ec:	38803fcc 	andi	r2,r7,255
 20455f0:	1080201c 	xori	r2,r2,128
 20455f4:	10bfe004 	addi	r2,r2,-128
 20455f8:	1002f31e 	bne	r2,zero,20461c8 <___svfiprintf_internal_r+0xf38>
 20455fc:	01000044 	movi	r4,1
 2045600:	01c00804 	movi	r7,32
 2045604:	98c00007 	ldb	r3,0(r19)
 2045608:	003f7006 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 204560c:	21003fcc 	andi	r4,r4,255
 2045610:	2003aa1e 	bne	r4,zero,20464bc <___svfiprintf_internal_r+0x122c>
 2045614:	00808134 	movhi	r2,516
 2045618:	109a8504 	addi	r2,r2,27156
 204561c:	d8802915 	stw	r2,164(sp)
 2045620:	9080080c 	andi	r2,r18,32
 2045624:	1000ba26 	beq	r2,zero,2045910 <___svfiprintf_internal_r+0x680>
 2045628:	dac02317 	ldw	r11,140(sp)
 204562c:	5f000017 	ldw	fp,0(r11)
 2045630:	5a400117 	ldw	r9,4(r11)
 2045634:	5ac00204 	addi	r11,r11,8
 2045638:	dac02315 	stw	r11,140(sp)
 204563c:	9080004c 	andi	r2,r18,1
 2045640:	10029026 	beq	r2,zero,2046084 <___svfiprintf_internal_r+0xdf4>
 2045644:	e244b03a 	or	r2,fp,r9
 2045648:	1002d41e 	bne	r2,zero,204619c <___svfiprintf_internal_r+0xf0c>
 204564c:	d8001d85 	stb	zero,118(sp)
 2045650:	80030b16 	blt	r16,zero,2046280 <___svfiprintf_internal_r+0xff0>
 2045654:	00bfdfc4 	movi	r2,-129
 2045658:	90a4703a 	and	r18,r18,r2
 204565c:	0015883a 	mov	r10,zero
 2045660:	80002426 	beq	r16,zero,20456f4 <___svfiprintf_internal_r+0x464>
 2045664:	0039883a 	mov	fp,zero
 2045668:	0013883a 	mov	r9,zero
 204566c:	d9002917 	ldw	r4,164(sp)
 2045670:	dc401a04 	addi	r17,sp,104
 2045674:	e08003cc 	andi	r2,fp,15
 2045678:	4806973a 	slli	r3,r9,28
 204567c:	2085883a 	add	r2,r4,r2
 2045680:	e038d13a 	srli	fp,fp,4
 2045684:	10800003 	ldbu	r2,0(r2)
 2045688:	4812d13a 	srli	r9,r9,4
 204568c:	8c7fffc4 	addi	r17,r17,-1
 2045690:	1f38b03a 	or	fp,r3,fp
 2045694:	88800005 	stb	r2,0(r17)
 2045698:	e244b03a 	or	r2,fp,r9
 204569c:	103ff51e 	bne	r2,zero,2045674 <__alt_mem_mem_0+0xfd025674>
 20456a0:	dac01e17 	ldw	r11,120(sp)
 20456a4:	5c57c83a 	sub	r11,r11,r17
 20456a8:	dac02115 	stw	r11,132(sp)
 20456ac:	00001406 	br	2045700 <___svfiprintf_internal_r+0x470>
 20456b0:	21003fcc 	andi	r4,r4,255
 20456b4:	2003741e 	bne	r4,zero,2046488 <___svfiprintf_internal_r+0x11f8>
 20456b8:	9080080c 	andi	r2,r18,32
 20456bc:	10014526 	beq	r2,zero,2045bd4 <___svfiprintf_internal_r+0x944>
 20456c0:	dac02317 	ldw	r11,140(sp)
 20456c4:	d8001d85 	stb	zero,118(sp)
 20456c8:	58c00204 	addi	r3,r11,8
 20456cc:	5f000017 	ldw	fp,0(r11)
 20456d0:	5a400117 	ldw	r9,4(r11)
 20456d4:	8002d916 	blt	r16,zero,204623c <___svfiprintf_internal_r+0xfac>
 20456d8:	013fdfc4 	movi	r4,-129
 20456dc:	e244b03a 	or	r2,fp,r9
 20456e0:	d8c02315 	stw	r3,140(sp)
 20456e4:	9124703a 	and	r18,r18,r4
 20456e8:	0015883a 	mov	r10,zero
 20456ec:	1000b91e 	bne	r2,zero,20459d4 <___svfiprintf_internal_r+0x744>
 20456f0:	8002e61e 	bne	r16,zero,204628c <___svfiprintf_internal_r+0xffc>
 20456f4:	0021883a 	mov	r16,zero
 20456f8:	d8002115 	stw	zero,132(sp)
 20456fc:	dc401a04 	addi	r17,sp,104
 2045700:	d8c02117 	ldw	r3,132(sp)
 2045704:	dc002015 	stw	r16,128(sp)
 2045708:	80c0010e 	bge	r16,r3,2045710 <___svfiprintf_internal_r+0x480>
 204570c:	d8c02015 	stw	r3,128(sp)
 2045710:	52803fcc 	andi	r10,r10,255
 2045714:	5280201c 	xori	r10,r10,128
 2045718:	52bfe004 	addi	r10,r10,-128
 204571c:	50003c26 	beq	r10,zero,2045810 <___svfiprintf_internal_r+0x580>
 2045720:	dac02017 	ldw	r11,128(sp)
 2045724:	5ac00044 	addi	r11,r11,1
 2045728:	dac02015 	stw	r11,128(sp)
 204572c:	00003806 	br	2045810 <___svfiprintf_internal_r+0x580>
 2045730:	01000044 	movi	r4,1
 2045734:	01c00ac4 	movi	r7,43
 2045738:	98c00007 	ldb	r3,0(r19)
 204573c:	003f2306 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 2045740:	21003fcc 	andi	r4,r4,255
 2045744:	2003481e 	bne	r4,zero,2046468 <___svfiprintf_internal_r+0x11d8>
 2045748:	9080080c 	andi	r2,r18,32
 204574c:	10013b26 	beq	r2,zero,2045c3c <___svfiprintf_internal_r+0x9ac>
 2045750:	dac02317 	ldw	r11,140(sp)
 2045754:	d8001d85 	stb	zero,118(sp)
 2045758:	58800204 	addi	r2,r11,8
 204575c:	5f000017 	ldw	fp,0(r11)
 2045760:	5a400117 	ldw	r9,4(r11)
 2045764:	8002a816 	blt	r16,zero,2046208 <___svfiprintf_internal_r+0xf78>
 2045768:	013fdfc4 	movi	r4,-129
 204576c:	e246b03a 	or	r3,fp,r9
 2045770:	d8802315 	stw	r2,140(sp)
 2045774:	9124703a 	and	r18,r18,r4
 2045778:	18013c26 	beq	r3,zero,2045c6c <___svfiprintf_internal_r+0x9dc>
 204577c:	0015883a 	mov	r10,zero
 2045780:	dc401a04 	addi	r17,sp,104
 2045784:	e006d0fa 	srli	r3,fp,3
 2045788:	4808977a 	slli	r4,r9,29
 204578c:	4812d0fa 	srli	r9,r9,3
 2045790:	e70001cc 	andi	fp,fp,7
 2045794:	e0800c04 	addi	r2,fp,48
 2045798:	8c7fffc4 	addi	r17,r17,-1
 204579c:	20f8b03a 	or	fp,r4,r3
 20457a0:	88800005 	stb	r2,0(r17)
 20457a4:	e246b03a 	or	r3,fp,r9
 20457a8:	183ff61e 	bne	r3,zero,2045784 <__alt_mem_mem_0+0xfd025784>
 20457ac:	90c0004c 	andi	r3,r18,1
 20457b0:	1800a526 	beq	r3,zero,2045a48 <___svfiprintf_internal_r+0x7b8>
 20457b4:	10803fcc 	andi	r2,r2,255
 20457b8:	1080201c 	xori	r2,r2,128
 20457bc:	10bfe004 	addi	r2,r2,-128
 20457c0:	00c00c04 	movi	r3,48
 20457c4:	10ffb626 	beq	r2,r3,20456a0 <__alt_mem_mem_0+0xfd0256a0>
 20457c8:	88ffffc5 	stb	r3,-1(r17)
 20457cc:	d8c01e17 	ldw	r3,120(sp)
 20457d0:	88bfffc4 	addi	r2,r17,-1
 20457d4:	1023883a 	mov	r17,r2
 20457d8:	1887c83a 	sub	r3,r3,r2
 20457dc:	d8c02115 	stw	r3,132(sp)
 20457e0:	003fc706 	br	2045700 <__alt_mem_mem_0+0xfd025700>
 20457e4:	dac02317 	ldw	r11,140(sp)
 20457e8:	00c00044 	movi	r3,1
 20457ec:	d8c02015 	stw	r3,128(sp)
 20457f0:	58800017 	ldw	r2,0(r11)
 20457f4:	5ac00104 	addi	r11,r11,4
 20457f8:	d8001d85 	stb	zero,118(sp)
 20457fc:	d8801005 	stb	r2,64(sp)
 2045800:	dac02315 	stw	r11,140(sp)
 2045804:	d8c02115 	stw	r3,132(sp)
 2045808:	dc401004 	addi	r17,sp,64
 204580c:	0021883a 	mov	r16,zero
 2045810:	90c0008c 	andi	r3,r18,2
 2045814:	d8c02215 	stw	r3,136(sp)
 2045818:	18000326 	beq	r3,zero,2045828 <___svfiprintf_internal_r+0x598>
 204581c:	dac02017 	ldw	r11,128(sp)
 2045820:	5ac00084 	addi	r11,r11,2
 2045824:	dac02015 	stw	r11,128(sp)
 2045828:	90c0210c 	andi	r3,r18,132
 204582c:	d8c02615 	stw	r3,152(sp)
 2045830:	1801131e 	bne	r3,zero,2045c80 <___svfiprintf_internal_r+0x9f0>
 2045834:	dac02417 	ldw	r11,144(sp)
 2045838:	d8c02017 	ldw	r3,128(sp)
 204583c:	58f9c83a 	sub	fp,r11,r3
 2045840:	07010f0e 	bge	zero,fp,2045c80 <___svfiprintf_internal_r+0x9f0>
 2045844:	02400404 	movi	r9,16
 2045848:	d8c01c17 	ldw	r3,112(sp)
 204584c:	d8801b17 	ldw	r2,108(sp)
 2045850:	4f02d60e 	bge	r9,fp,20463ac <___svfiprintf_internal_r+0x111c>
 2045854:	01408174 	movhi	r5,517
 2045858:	2963e304 	addi	r5,r5,-28788
 204585c:	d9402815 	stw	r5,160(sp)
 2045860:	028001c4 	movi	r10,7
 2045864:	00000306 	br	2045874 <___svfiprintf_internal_r+0x5e4>
 2045868:	e73ffc04 	addi	fp,fp,-16
 204586c:	42000204 	addi	r8,r8,8
 2045870:	4f00150e 	bge	r9,fp,20458c8 <___svfiprintf_internal_r+0x638>
 2045874:	18c00404 	addi	r3,r3,16
 2045878:	10800044 	addi	r2,r2,1
 204587c:	45800015 	stw	r22,0(r8)
 2045880:	42400115 	stw	r9,4(r8)
 2045884:	d8c01c15 	stw	r3,112(sp)
 2045888:	d8801b15 	stw	r2,108(sp)
 204588c:	50bff60e 	bge	r10,r2,2045868 <__alt_mem_mem_0+0xfd025868>
 2045890:	d9801a04 	addi	r6,sp,104
 2045894:	b80b883a 	mov	r5,r23
 2045898:	a809883a 	mov	r4,r21
 204589c:	da402c15 	stw	r9,176(sp)
 20458a0:	da802d15 	stw	r10,180(sp)
 20458a4:	20450c00 	call	20450c0 <__ssprint_r>
 20458a8:	da402c17 	ldw	r9,176(sp)
 20458ac:	da802d17 	ldw	r10,180(sp)
 20458b0:	1001851e 	bne	r2,zero,2045ec8 <___svfiprintf_internal_r+0xc38>
 20458b4:	e73ffc04 	addi	fp,fp,-16
 20458b8:	d8c01c17 	ldw	r3,112(sp)
 20458bc:	d8801b17 	ldw	r2,108(sp)
 20458c0:	d811883a 	mov	r8,sp
 20458c4:	4f3feb16 	blt	r9,fp,2045874 <__alt_mem_mem_0+0xfd025874>
 20458c8:	dac02817 	ldw	r11,160(sp)
 20458cc:	e0c7883a 	add	r3,fp,r3
 20458d0:	10800044 	addi	r2,r2,1
 20458d4:	42c00015 	stw	r11,0(r8)
 20458d8:	47000115 	stw	fp,4(r8)
 20458dc:	d8c01c15 	stw	r3,112(sp)
 20458e0:	d8801b15 	stw	r2,108(sp)
 20458e4:	010001c4 	movi	r4,7
 20458e8:	2081ee16 	blt	r4,r2,20460a4 <___svfiprintf_internal_r+0xe14>
 20458ec:	42000204 	addi	r8,r8,8
 20458f0:	0000e506 	br	2045c88 <___svfiprintf_internal_r+0x9f8>
 20458f4:	21003fcc 	andi	r4,r4,255
 20458f8:	2002dd1e 	bne	r4,zero,2046470 <___svfiprintf_internal_r+0x11e0>
 20458fc:	00808134 	movhi	r2,516
 2045900:	109a8004 	addi	r2,r2,27136
 2045904:	d8802915 	stw	r2,164(sp)
 2045908:	9080080c 	andi	r2,r18,32
 204590c:	103f461e 	bne	r2,zero,2045628 <__alt_mem_mem_0+0xfd025628>
 2045910:	9080040c 	andi	r2,r18,16
 2045914:	10022e1e 	bne	r2,zero,20461d0 <___svfiprintf_internal_r+0xf40>
 2045918:	9080100c 	andi	r2,r18,64
 204591c:	dac02317 	ldw	r11,140(sp)
 2045920:	10027326 	beq	r2,zero,20462f0 <___svfiprintf_internal_r+0x1060>
 2045924:	5f00000b 	ldhu	fp,0(r11)
 2045928:	5ac00104 	addi	r11,r11,4
 204592c:	0013883a 	mov	r9,zero
 2045930:	dac02315 	stw	r11,140(sp)
 2045934:	003f4106 	br	204563c <__alt_mem_mem_0+0xfd02563c>
 2045938:	21003fcc 	andi	r4,r4,255
 204593c:	2002e11e 	bne	r4,zero,20464c4 <___svfiprintf_internal_r+0x1234>
 2045940:	9080080c 	andi	r2,r18,32
 2045944:	1002011e 	bne	r2,zero,204614c <___svfiprintf_internal_r+0xebc>
 2045948:	9080040c 	andi	r2,r18,16
 204594c:	10023e1e 	bne	r2,zero,2046248 <___svfiprintf_internal_r+0xfb8>
 2045950:	9480100c 	andi	r18,r18,64
 2045954:	90023c26 	beq	r18,zero,2046248 <___svfiprintf_internal_r+0xfb8>
 2045958:	dac02317 	ldw	r11,140(sp)
 204595c:	58800017 	ldw	r2,0(r11)
 2045960:	5ac00104 	addi	r11,r11,4
 2045964:	dac02315 	stw	r11,140(sp)
 2045968:	dac02517 	ldw	r11,148(sp)
 204596c:	12c0000d 	sth	r11,0(r2)
 2045970:	003e6e06 	br	204532c <__alt_mem_mem_0+0xfd02532c>
 2045974:	98c00007 	ldb	r3,0(r19)
 2045978:	1a422926 	beq	r3,r9,2046220 <___svfiprintf_internal_r+0xf90>
 204597c:	94800414 	ori	r18,r18,16
 2045980:	003e9206 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 2045984:	94801014 	ori	r18,r18,64
 2045988:	98c00007 	ldb	r3,0(r19)
 204598c:	003e8f06 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 2045990:	21003fcc 	andi	r4,r4,255
 2045994:	2002c71e 	bne	r4,zero,20464b4 <___svfiprintf_internal_r+0x1224>
 2045998:	9080080c 	andi	r2,r18,32
 204599c:	10004926 	beq	r2,zero,2045ac4 <___svfiprintf_internal_r+0x834>
 20459a0:	dac02317 	ldw	r11,140(sp)
 20459a4:	58800117 	ldw	r2,4(r11)
 20459a8:	5f000017 	ldw	fp,0(r11)
 20459ac:	5ac00204 	addi	r11,r11,8
 20459b0:	dac02315 	stw	r11,140(sp)
 20459b4:	1013883a 	mov	r9,r2
 20459b8:	10004b16 	blt	r2,zero,2045ae8 <___svfiprintf_internal_r+0x858>
 20459bc:	da801d83 	ldbu	r10,118(sp)
 20459c0:	8001cb16 	blt	r16,zero,20460f0 <___svfiprintf_internal_r+0xe60>
 20459c4:	00ffdfc4 	movi	r3,-129
 20459c8:	e244b03a 	or	r2,fp,r9
 20459cc:	90e4703a 	and	r18,r18,r3
 20459d0:	103f4726 	beq	r2,zero,20456f0 <__alt_mem_mem_0+0xfd0256f0>
 20459d4:	48008c26 	beq	r9,zero,2045c08 <___svfiprintf_internal_r+0x978>
 20459d8:	dc802015 	stw	r18,128(sp)
 20459dc:	dc002115 	stw	r16,132(sp)
 20459e0:	dc401a04 	addi	r17,sp,104
 20459e4:	e021883a 	mov	r16,fp
 20459e8:	da002215 	stw	r8,136(sp)
 20459ec:	5039883a 	mov	fp,r10
 20459f0:	4825883a 	mov	r18,r9
 20459f4:	8009883a 	mov	r4,r16
 20459f8:	900b883a 	mov	r5,r18
 20459fc:	01800284 	movi	r6,10
 2045a00:	000f883a 	mov	r7,zero
 2045a04:	200a4ac0 	call	200a4ac <__umoddi3>
 2045a08:	10800c04 	addi	r2,r2,48
 2045a0c:	8c7fffc4 	addi	r17,r17,-1
 2045a10:	8009883a 	mov	r4,r16
 2045a14:	900b883a 	mov	r5,r18
 2045a18:	88800005 	stb	r2,0(r17)
 2045a1c:	01800284 	movi	r6,10
 2045a20:	000f883a 	mov	r7,zero
 2045a24:	2009f340 	call	2009f34 <__udivdi3>
 2045a28:	1021883a 	mov	r16,r2
 2045a2c:	10c4b03a 	or	r2,r2,r3
 2045a30:	1825883a 	mov	r18,r3
 2045a34:	103fef1e 	bne	r2,zero,20459f4 <__alt_mem_mem_0+0xfd0259f4>
 2045a38:	dc802017 	ldw	r18,128(sp)
 2045a3c:	dc002117 	ldw	r16,132(sp)
 2045a40:	da002217 	ldw	r8,136(sp)
 2045a44:	e015883a 	mov	r10,fp
 2045a48:	d8c01e17 	ldw	r3,120(sp)
 2045a4c:	1c47c83a 	sub	r3,r3,r17
 2045a50:	d8c02115 	stw	r3,132(sp)
 2045a54:	003f2a06 	br	2045700 <__alt_mem_mem_0+0xfd025700>
 2045a58:	dac02317 	ldw	r11,140(sp)
 2045a5c:	d8001d85 	stb	zero,118(sp)
 2045a60:	5c400017 	ldw	r17,0(r11)
 2045a64:	5f000104 	addi	fp,r11,4
 2045a68:	88022f26 	beq	r17,zero,2046328 <___svfiprintf_internal_r+0x1098>
 2045a6c:	80022516 	blt	r16,zero,2046304 <___svfiprintf_internal_r+0x1074>
 2045a70:	800d883a 	mov	r6,r16
 2045a74:	000b883a 	mov	r5,zero
 2045a78:	8809883a 	mov	r4,r17
 2045a7c:	da002c15 	stw	r8,176(sp)
 2045a80:	2005d740 	call	2005d74 <memchr>
 2045a84:	da002c17 	ldw	r8,176(sp)
 2045a88:	10026426 	beq	r2,zero,204641c <___svfiprintf_internal_r+0x118c>
 2045a8c:	1445c83a 	sub	r2,r2,r17
 2045a90:	d8802115 	stw	r2,132(sp)
 2045a94:	da801d83 	ldbu	r10,118(sp)
 2045a98:	df002315 	stw	fp,140(sp)
 2045a9c:	0021883a 	mov	r16,zero
 2045aa0:	003f1706 	br	2045700 <__alt_mem_mem_0+0xfd025700>
 2045aa4:	94800814 	ori	r18,r18,32
 2045aa8:	98c00007 	ldb	r3,0(r19)
 2045aac:	003e4706 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 2045ab0:	21003fcc 	andi	r4,r4,255
 2045ab4:	2002701e 	bne	r4,zero,2046478 <___svfiprintf_internal_r+0x11e8>
 2045ab8:	94800414 	ori	r18,r18,16
 2045abc:	9080080c 	andi	r2,r18,32
 2045ac0:	103fb71e 	bne	r2,zero,20459a0 <__alt_mem_mem_0+0xfd0259a0>
 2045ac4:	9080040c 	andi	r2,r18,16
 2045ac8:	1001ab26 	beq	r2,zero,2046178 <___svfiprintf_internal_r+0xee8>
 2045acc:	dac02317 	ldw	r11,140(sp)
 2045ad0:	5f000017 	ldw	fp,0(r11)
 2045ad4:	5ac00104 	addi	r11,r11,4
 2045ad8:	dac02315 	stw	r11,140(sp)
 2045adc:	e013d7fa 	srai	r9,fp,31
 2045ae0:	4805883a 	mov	r2,r9
 2045ae4:	103fb50e 	bge	r2,zero,20459bc <__alt_mem_mem_0+0xfd0259bc>
 2045ae8:	0739c83a 	sub	fp,zero,fp
 2045aec:	02800b44 	movi	r10,45
 2045af0:	e004c03a 	cmpne	r2,fp,zero
 2045af4:	0253c83a 	sub	r9,zero,r9
 2045af8:	da801d85 	stb	r10,118(sp)
 2045afc:	4893c83a 	sub	r9,r9,r2
 2045b00:	80023016 	blt	r16,zero,20463c4 <___svfiprintf_internal_r+0x1134>
 2045b04:	00bfdfc4 	movi	r2,-129
 2045b08:	90a4703a 	and	r18,r18,r2
 2045b0c:	483fb21e 	bne	r9,zero,20459d8 <__alt_mem_mem_0+0xfd0259d8>
 2045b10:	00003d06 	br	2045c08 <___svfiprintf_internal_r+0x978>
 2045b14:	9817883a 	mov	r11,r19
 2045b18:	d8002415 	stw	zero,144(sp)
 2045b1c:	18bff404 	addi	r2,r3,-48
 2045b20:	0019883a 	mov	r12,zero
 2045b24:	58c00007 	ldb	r3,0(r11)
 2045b28:	630002a4 	muli	r12,r12,10
 2045b2c:	9cc00044 	addi	r19,r19,1
 2045b30:	9817883a 	mov	r11,r19
 2045b34:	1319883a 	add	r12,r2,r12
 2045b38:	18bff404 	addi	r2,r3,-48
 2045b3c:	30bff92e 	bgeu	r6,r2,2045b24 <__alt_mem_mem_0+0xfd025b24>
 2045b40:	db002415 	stw	r12,144(sp)
 2045b44:	18bff804 	addi	r2,r3,-32
 2045b48:	28be232e 	bgeu	r5,r2,20453d8 <__alt_mem_mem_0+0xfd0253d8>
 2045b4c:	21003fcc 	andi	r4,r4,255
 2045b50:	20024b1e 	bne	r4,zero,2046480 <___svfiprintf_internal_r+0x11f0>
 2045b54:	1800d626 	beq	r3,zero,2045eb0 <___svfiprintf_internal_r+0xc20>
 2045b58:	02c00044 	movi	r11,1
 2045b5c:	dac02015 	stw	r11,128(sp)
 2045b60:	d8c01005 	stb	r3,64(sp)
 2045b64:	d8001d85 	stb	zero,118(sp)
 2045b68:	dac02115 	stw	r11,132(sp)
 2045b6c:	dc401004 	addi	r17,sp,64
 2045b70:	003f2606 	br	204580c <__alt_mem_mem_0+0xfd02580c>
 2045b74:	94802014 	ori	r18,r18,128
 2045b78:	98c00007 	ldb	r3,0(r19)
 2045b7c:	003e1306 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 2045b80:	98c00007 	ldb	r3,0(r19)
 2045b84:	9ac00044 	addi	r11,r19,1
 2045b88:	1a822b26 	beq	r3,r10,2046438 <___svfiprintf_internal_r+0x11a8>
 2045b8c:	18bff404 	addi	r2,r3,-48
 2045b90:	0021883a 	mov	r16,zero
 2045b94:	30821e36 	bltu	r6,r2,2046410 <___svfiprintf_internal_r+0x1180>
 2045b98:	58c00007 	ldb	r3,0(r11)
 2045b9c:	840002a4 	muli	r16,r16,10
 2045ba0:	5cc00044 	addi	r19,r11,1
 2045ba4:	9817883a 	mov	r11,r19
 2045ba8:	80a1883a 	add	r16,r16,r2
 2045bac:	18bff404 	addi	r2,r3,-48
 2045bb0:	30bff92e 	bgeu	r6,r2,2045b98 <__alt_mem_mem_0+0xfd025b98>
 2045bb4:	803e060e 	bge	r16,zero,20453d0 <__alt_mem_mem_0+0xfd0253d0>
 2045bb8:	043fffc4 	movi	r16,-1
 2045bbc:	003e0406 	br	20453d0 <__alt_mem_mem_0+0xfd0253d0>
 2045bc0:	21003fcc 	andi	r4,r4,255
 2045bc4:	2002371e 	bne	r4,zero,20464a4 <___svfiprintf_internal_r+0x1214>
 2045bc8:	94800414 	ori	r18,r18,16
 2045bcc:	9080080c 	andi	r2,r18,32
 2045bd0:	103ebb1e 	bne	r2,zero,20456c0 <__alt_mem_mem_0+0xfd0256c0>
 2045bd4:	9080040c 	andi	r2,r18,16
 2045bd8:	10013b26 	beq	r2,zero,20460c8 <___svfiprintf_internal_r+0xe38>
 2045bdc:	dac02317 	ldw	r11,140(sp)
 2045be0:	d8001d85 	stb	zero,118(sp)
 2045be4:	0013883a 	mov	r9,zero
 2045be8:	58800104 	addi	r2,r11,4
 2045bec:	5f000017 	ldw	fp,0(r11)
 2045bf0:	80013d16 	blt	r16,zero,20460e8 <___svfiprintf_internal_r+0xe58>
 2045bf4:	00ffdfc4 	movi	r3,-129
 2045bf8:	d8802315 	stw	r2,140(sp)
 2045bfc:	90e4703a 	and	r18,r18,r3
 2045c00:	0015883a 	mov	r10,zero
 2045c04:	e03eba26 	beq	fp,zero,20456f0 <__alt_mem_mem_0+0xfd0256f0>
 2045c08:	00800244 	movi	r2,9
 2045c0c:	173f7236 	bltu	r2,fp,20459d8 <__alt_mem_mem_0+0xfd0259d8>
 2045c10:	dac02b17 	ldw	r11,172(sp)
 2045c14:	e7000c04 	addi	fp,fp,48
 2045c18:	df0019c5 	stb	fp,103(sp)
 2045c1c:	dac02115 	stw	r11,132(sp)
 2045c20:	dc4019c4 	addi	r17,sp,103
 2045c24:	003eb606 	br	2045700 <__alt_mem_mem_0+0xfd025700>
 2045c28:	21003fcc 	andi	r4,r4,255
 2045c2c:	20021f1e 	bne	r4,zero,20464ac <___svfiprintf_internal_r+0x121c>
 2045c30:	94800414 	ori	r18,r18,16
 2045c34:	9080080c 	andi	r2,r18,32
 2045c38:	103ec51e 	bne	r2,zero,2045750 <__alt_mem_mem_0+0xfd025750>
 2045c3c:	9080040c 	andi	r2,r18,16
 2045c40:	10016926 	beq	r2,zero,20461e8 <___svfiprintf_internal_r+0xf58>
 2045c44:	dac02317 	ldw	r11,140(sp)
 2045c48:	d8001d85 	stb	zero,118(sp)
 2045c4c:	0013883a 	mov	r9,zero
 2045c50:	58800104 	addi	r2,r11,4
 2045c54:	5f000017 	ldw	fp,0(r11)
 2045c58:	80016b16 	blt	r16,zero,2046208 <___svfiprintf_internal_r+0xf78>
 2045c5c:	00ffdfc4 	movi	r3,-129
 2045c60:	d8802315 	stw	r2,140(sp)
 2045c64:	90e4703a 	and	r18,r18,r3
 2045c68:	e03ec41e 	bne	fp,zero,204577c <__alt_mem_mem_0+0xfd02577c>
 2045c6c:	0015883a 	mov	r10,zero
 2045c70:	8001c226 	beq	r16,zero,204637c <___svfiprintf_internal_r+0x10ec>
 2045c74:	0039883a 	mov	fp,zero
 2045c78:	0013883a 	mov	r9,zero
 2045c7c:	003ec006 	br	2045780 <__alt_mem_mem_0+0xfd025780>
 2045c80:	d8c01c17 	ldw	r3,112(sp)
 2045c84:	d8801b17 	ldw	r2,108(sp)
 2045c88:	d9001d87 	ldb	r4,118(sp)
 2045c8c:	20000b26 	beq	r4,zero,2045cbc <___svfiprintf_internal_r+0xa2c>
 2045c90:	d9001d84 	addi	r4,sp,118
 2045c94:	18c00044 	addi	r3,r3,1
 2045c98:	10800044 	addi	r2,r2,1
 2045c9c:	41000015 	stw	r4,0(r8)
 2045ca0:	01000044 	movi	r4,1
 2045ca4:	41000115 	stw	r4,4(r8)
 2045ca8:	d8c01c15 	stw	r3,112(sp)
 2045cac:	d8801b15 	stw	r2,108(sp)
 2045cb0:	010001c4 	movi	r4,7
 2045cb4:	2080e116 	blt	r4,r2,204603c <___svfiprintf_internal_r+0xdac>
 2045cb8:	42000204 	addi	r8,r8,8
 2045cbc:	dac02217 	ldw	r11,136(sp)
 2045cc0:	58000b26 	beq	r11,zero,2045cf0 <___svfiprintf_internal_r+0xa60>
 2045cc4:	d9001d04 	addi	r4,sp,116
 2045cc8:	18c00084 	addi	r3,r3,2
 2045ccc:	10800044 	addi	r2,r2,1
 2045cd0:	41000015 	stw	r4,0(r8)
 2045cd4:	01000084 	movi	r4,2
 2045cd8:	41000115 	stw	r4,4(r8)
 2045cdc:	d8c01c15 	stw	r3,112(sp)
 2045ce0:	d8801b15 	stw	r2,108(sp)
 2045ce4:	010001c4 	movi	r4,7
 2045ce8:	2080dd16 	blt	r4,r2,2046060 <___svfiprintf_internal_r+0xdd0>
 2045cec:	42000204 	addi	r8,r8,8
 2045cf0:	dac02617 	ldw	r11,152(sp)
 2045cf4:	01002004 	movi	r4,128
 2045cf8:	59008426 	beq	r11,r4,2045f0c <___svfiprintf_internal_r+0xc7c>
 2045cfc:	dac02117 	ldw	r11,132(sp)
 2045d00:	82e1c83a 	sub	r16,r16,r11
 2045d04:	0400270e 	bge	zero,r16,2045da4 <___svfiprintf_internal_r+0xb14>
 2045d08:	01c00404 	movi	r7,16
 2045d0c:	3c016a0e 	bge	r7,r16,20462b8 <___svfiprintf_internal_r+0x1028>
 2045d10:	01408174 	movhi	r5,517
 2045d14:	2963df04 	addi	r5,r5,-28804
 2045d18:	d9402215 	stw	r5,136(sp)
 2045d1c:	070001c4 	movi	fp,7
 2045d20:	00000306 	br	2045d30 <___svfiprintf_internal_r+0xaa0>
 2045d24:	843ffc04 	addi	r16,r16,-16
 2045d28:	42000204 	addi	r8,r8,8
 2045d2c:	3c00130e 	bge	r7,r16,2045d7c <___svfiprintf_internal_r+0xaec>
 2045d30:	18c00404 	addi	r3,r3,16
 2045d34:	10800044 	addi	r2,r2,1
 2045d38:	45000015 	stw	r20,0(r8)
 2045d3c:	41c00115 	stw	r7,4(r8)
 2045d40:	d8c01c15 	stw	r3,112(sp)
 2045d44:	d8801b15 	stw	r2,108(sp)
 2045d48:	e0bff60e 	bge	fp,r2,2045d24 <__alt_mem_mem_0+0xfd025d24>
 2045d4c:	d9801a04 	addi	r6,sp,104
 2045d50:	b80b883a 	mov	r5,r23
 2045d54:	a809883a 	mov	r4,r21
 2045d58:	d9c02c15 	stw	r7,176(sp)
 2045d5c:	20450c00 	call	20450c0 <__ssprint_r>
 2045d60:	d9c02c17 	ldw	r7,176(sp)
 2045d64:	1000581e 	bne	r2,zero,2045ec8 <___svfiprintf_internal_r+0xc38>
 2045d68:	843ffc04 	addi	r16,r16,-16
 2045d6c:	d8c01c17 	ldw	r3,112(sp)
 2045d70:	d8801b17 	ldw	r2,108(sp)
 2045d74:	d811883a 	mov	r8,sp
 2045d78:	3c3fed16 	blt	r7,r16,2045d30 <__alt_mem_mem_0+0xfd025d30>
 2045d7c:	dac02217 	ldw	r11,136(sp)
 2045d80:	1c07883a 	add	r3,r3,r16
 2045d84:	10800044 	addi	r2,r2,1
 2045d88:	42c00015 	stw	r11,0(r8)
 2045d8c:	44000115 	stw	r16,4(r8)
 2045d90:	d8c01c15 	stw	r3,112(sp)
 2045d94:	d8801b15 	stw	r2,108(sp)
 2045d98:	010001c4 	movi	r4,7
 2045d9c:	20809e16 	blt	r4,r2,2046018 <___svfiprintf_internal_r+0xd88>
 2045da0:	42000204 	addi	r8,r8,8
 2045da4:	dac02117 	ldw	r11,132(sp)
 2045da8:	10800044 	addi	r2,r2,1
 2045dac:	44400015 	stw	r17,0(r8)
 2045db0:	58c7883a 	add	r3,r11,r3
 2045db4:	42c00115 	stw	r11,4(r8)
 2045db8:	d8c01c15 	stw	r3,112(sp)
 2045dbc:	d8801b15 	stw	r2,108(sp)
 2045dc0:	010001c4 	movi	r4,7
 2045dc4:	20807f16 	blt	r4,r2,2045fc4 <___svfiprintf_internal_r+0xd34>
 2045dc8:	42000204 	addi	r8,r8,8
 2045dcc:	9480010c 	andi	r18,r18,4
 2045dd0:	90002926 	beq	r18,zero,2045e78 <___svfiprintf_internal_r+0xbe8>
 2045dd4:	dac02417 	ldw	r11,144(sp)
 2045dd8:	d8802017 	ldw	r2,128(sp)
 2045ddc:	58a1c83a 	sub	r16,r11,r2
 2045de0:	0400250e 	bge	zero,r16,2045e78 <___svfiprintf_internal_r+0xbe8>
 2045de4:	04400404 	movi	r17,16
 2045de8:	d8801b17 	ldw	r2,108(sp)
 2045dec:	8c017c0e 	bge	r17,r16,20463e0 <___svfiprintf_internal_r+0x1150>
 2045df0:	01408174 	movhi	r5,517
 2045df4:	2963e304 	addi	r5,r5,-28788
 2045df8:	d9402815 	stw	r5,160(sp)
 2045dfc:	048001c4 	movi	r18,7
 2045e00:	00000306 	br	2045e10 <___svfiprintf_internal_r+0xb80>
 2045e04:	843ffc04 	addi	r16,r16,-16
 2045e08:	42000204 	addi	r8,r8,8
 2045e0c:	8c00110e 	bge	r17,r16,2045e54 <___svfiprintf_internal_r+0xbc4>
 2045e10:	18c00404 	addi	r3,r3,16
 2045e14:	10800044 	addi	r2,r2,1
 2045e18:	45800015 	stw	r22,0(r8)
 2045e1c:	44400115 	stw	r17,4(r8)
 2045e20:	d8c01c15 	stw	r3,112(sp)
 2045e24:	d8801b15 	stw	r2,108(sp)
 2045e28:	90bff60e 	bge	r18,r2,2045e04 <__alt_mem_mem_0+0xfd025e04>
 2045e2c:	d9801a04 	addi	r6,sp,104
 2045e30:	b80b883a 	mov	r5,r23
 2045e34:	a809883a 	mov	r4,r21
 2045e38:	20450c00 	call	20450c0 <__ssprint_r>
 2045e3c:	1000221e 	bne	r2,zero,2045ec8 <___svfiprintf_internal_r+0xc38>
 2045e40:	843ffc04 	addi	r16,r16,-16
 2045e44:	d8c01c17 	ldw	r3,112(sp)
 2045e48:	d8801b17 	ldw	r2,108(sp)
 2045e4c:	d811883a 	mov	r8,sp
 2045e50:	8c3fef16 	blt	r17,r16,2045e10 <__alt_mem_mem_0+0xfd025e10>
 2045e54:	dac02817 	ldw	r11,160(sp)
 2045e58:	1c07883a 	add	r3,r3,r16
 2045e5c:	10800044 	addi	r2,r2,1
 2045e60:	42c00015 	stw	r11,0(r8)
 2045e64:	44000115 	stw	r16,4(r8)
 2045e68:	d8c01c15 	stw	r3,112(sp)
 2045e6c:	d8801b15 	stw	r2,108(sp)
 2045e70:	010001c4 	movi	r4,7
 2045e74:	2080aa16 	blt	r4,r2,2046120 <___svfiprintf_internal_r+0xe90>
 2045e78:	d8802417 	ldw	r2,144(sp)
 2045e7c:	dac02017 	ldw	r11,128(sp)
 2045e80:	12c0010e 	bge	r2,r11,2045e88 <___svfiprintf_internal_r+0xbf8>
 2045e84:	5805883a 	mov	r2,r11
 2045e88:	dac02517 	ldw	r11,148(sp)
 2045e8c:	5897883a 	add	r11,r11,r2
 2045e90:	dac02515 	stw	r11,148(sp)
 2045e94:	1800531e 	bne	r3,zero,2045fe4 <___svfiprintf_internal_r+0xd54>
 2045e98:	98800007 	ldb	r2,0(r19)
 2045e9c:	d8001b15 	stw	zero,108(sp)
 2045ea0:	d811883a 	mov	r8,sp
 2045ea4:	103d231e 	bne	r2,zero,2045334 <__alt_mem_mem_0+0xfd025334>
 2045ea8:	9823883a 	mov	r17,r19
 2045eac:	003d3906 	br	2045394 <__alt_mem_mem_0+0xfd025394>
 2045eb0:	d8801c17 	ldw	r2,112(sp)
 2045eb4:	10000426 	beq	r2,zero,2045ec8 <___svfiprintf_internal_r+0xc38>
 2045eb8:	d9402717 	ldw	r5,156(sp)
 2045ebc:	d9002a17 	ldw	r4,168(sp)
 2045ec0:	d9801a04 	addi	r6,sp,104
 2045ec4:	20450c00 	call	20450c0 <__ssprint_r>
 2045ec8:	dac02717 	ldw	r11,156(sp)
 2045ecc:	d8802517 	ldw	r2,148(sp)
 2045ed0:	58c0030b 	ldhu	r3,12(r11)
 2045ed4:	18c0100c 	andi	r3,r3,64
 2045ed8:	1801381e 	bne	r3,zero,20463bc <___svfiprintf_internal_r+0x112c>
 2045edc:	dfc03717 	ldw	ra,220(sp)
 2045ee0:	df003617 	ldw	fp,216(sp)
 2045ee4:	ddc03517 	ldw	r23,212(sp)
 2045ee8:	dd803417 	ldw	r22,208(sp)
 2045eec:	dd403317 	ldw	r21,204(sp)
 2045ef0:	dd003217 	ldw	r20,200(sp)
 2045ef4:	dcc03117 	ldw	r19,196(sp)
 2045ef8:	dc803017 	ldw	r18,192(sp)
 2045efc:	dc402f17 	ldw	r17,188(sp)
 2045f00:	dc002e17 	ldw	r16,184(sp)
 2045f04:	dec03804 	addi	sp,sp,224
 2045f08:	f800283a 	ret
 2045f0c:	dac02417 	ldw	r11,144(sp)
 2045f10:	d9002017 	ldw	r4,128(sp)
 2045f14:	5939c83a 	sub	fp,r11,r4
 2045f18:	073f780e 	bge	zero,fp,2045cfc <__alt_mem_mem_0+0xfd025cfc>
 2045f1c:	02400404 	movi	r9,16
 2045f20:	4f01370e 	bge	r9,fp,2046400 <___svfiprintf_internal_r+0x1170>
 2045f24:	02c08174 	movhi	r11,517
 2045f28:	5ae3df04 	addi	r11,r11,-28804
 2045f2c:	dac02215 	stw	r11,136(sp)
 2045f30:	028001c4 	movi	r10,7
 2045f34:	00000306 	br	2045f44 <___svfiprintf_internal_r+0xcb4>
 2045f38:	e73ffc04 	addi	fp,fp,-16
 2045f3c:	42000204 	addi	r8,r8,8
 2045f40:	4f00150e 	bge	r9,fp,2045f98 <___svfiprintf_internal_r+0xd08>
 2045f44:	18c00404 	addi	r3,r3,16
 2045f48:	10800044 	addi	r2,r2,1
 2045f4c:	45000015 	stw	r20,0(r8)
 2045f50:	42400115 	stw	r9,4(r8)
 2045f54:	d8c01c15 	stw	r3,112(sp)
 2045f58:	d8801b15 	stw	r2,108(sp)
 2045f5c:	50bff60e 	bge	r10,r2,2045f38 <__alt_mem_mem_0+0xfd025f38>
 2045f60:	d9801a04 	addi	r6,sp,104
 2045f64:	b80b883a 	mov	r5,r23
 2045f68:	a809883a 	mov	r4,r21
 2045f6c:	da402c15 	stw	r9,176(sp)
 2045f70:	da802d15 	stw	r10,180(sp)
 2045f74:	20450c00 	call	20450c0 <__ssprint_r>
 2045f78:	da402c17 	ldw	r9,176(sp)
 2045f7c:	da802d17 	ldw	r10,180(sp)
 2045f80:	103fd11e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 2045f84:	e73ffc04 	addi	fp,fp,-16
 2045f88:	d8c01c17 	ldw	r3,112(sp)
 2045f8c:	d8801b17 	ldw	r2,108(sp)
 2045f90:	d811883a 	mov	r8,sp
 2045f94:	4f3feb16 	blt	r9,fp,2045f44 <__alt_mem_mem_0+0xfd025f44>
 2045f98:	dac02217 	ldw	r11,136(sp)
 2045f9c:	1f07883a 	add	r3,r3,fp
 2045fa0:	10800044 	addi	r2,r2,1
 2045fa4:	42c00015 	stw	r11,0(r8)
 2045fa8:	47000115 	stw	fp,4(r8)
 2045fac:	d8c01c15 	stw	r3,112(sp)
 2045fb0:	d8801b15 	stw	r2,108(sp)
 2045fb4:	010001c4 	movi	r4,7
 2045fb8:	2080b616 	blt	r4,r2,2046294 <___svfiprintf_internal_r+0x1004>
 2045fbc:	42000204 	addi	r8,r8,8
 2045fc0:	003f4e06 	br	2045cfc <__alt_mem_mem_0+0xfd025cfc>
 2045fc4:	d9801a04 	addi	r6,sp,104
 2045fc8:	b80b883a 	mov	r5,r23
 2045fcc:	a809883a 	mov	r4,r21
 2045fd0:	20450c00 	call	20450c0 <__ssprint_r>
 2045fd4:	103fbc1e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 2045fd8:	d8c01c17 	ldw	r3,112(sp)
 2045fdc:	d811883a 	mov	r8,sp
 2045fe0:	003f7a06 	br	2045dcc <__alt_mem_mem_0+0xfd025dcc>
 2045fe4:	d9801a04 	addi	r6,sp,104
 2045fe8:	b80b883a 	mov	r5,r23
 2045fec:	a809883a 	mov	r4,r21
 2045ff0:	20450c00 	call	20450c0 <__ssprint_r>
 2045ff4:	103fa826 	beq	r2,zero,2045e98 <__alt_mem_mem_0+0xfd025e98>
 2045ff8:	003fb306 	br	2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 2045ffc:	d9801a04 	addi	r6,sp,104
 2046000:	b80b883a 	mov	r5,r23
 2046004:	a809883a 	mov	r4,r21
 2046008:	20450c00 	call	20450c0 <__ssprint_r>
 204600c:	103fae1e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 2046010:	d811883a 	mov	r8,sp
 2046014:	003cdc06 	br	2045388 <__alt_mem_mem_0+0xfd025388>
 2046018:	d9801a04 	addi	r6,sp,104
 204601c:	b80b883a 	mov	r5,r23
 2046020:	a809883a 	mov	r4,r21
 2046024:	20450c00 	call	20450c0 <__ssprint_r>
 2046028:	103fa71e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 204602c:	d8c01c17 	ldw	r3,112(sp)
 2046030:	d8801b17 	ldw	r2,108(sp)
 2046034:	d811883a 	mov	r8,sp
 2046038:	003f5a06 	br	2045da4 <__alt_mem_mem_0+0xfd025da4>
 204603c:	d9801a04 	addi	r6,sp,104
 2046040:	b80b883a 	mov	r5,r23
 2046044:	a809883a 	mov	r4,r21
 2046048:	20450c00 	call	20450c0 <__ssprint_r>
 204604c:	103f9e1e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 2046050:	d8c01c17 	ldw	r3,112(sp)
 2046054:	d8801b17 	ldw	r2,108(sp)
 2046058:	d811883a 	mov	r8,sp
 204605c:	003f1706 	br	2045cbc <__alt_mem_mem_0+0xfd025cbc>
 2046060:	d9801a04 	addi	r6,sp,104
 2046064:	b80b883a 	mov	r5,r23
 2046068:	a809883a 	mov	r4,r21
 204606c:	20450c00 	call	20450c0 <__ssprint_r>
 2046070:	103f951e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 2046074:	d8c01c17 	ldw	r3,112(sp)
 2046078:	d8801b17 	ldw	r2,108(sp)
 204607c:	d811883a 	mov	r8,sp
 2046080:	003f1b06 	br	2045cf0 <__alt_mem_mem_0+0xfd025cf0>
 2046084:	d8001d85 	stb	zero,118(sp)
 2046088:	80007b16 	blt	r16,zero,2046278 <___svfiprintf_internal_r+0xfe8>
 204608c:	00ffdfc4 	movi	r3,-129
 2046090:	e244b03a 	or	r2,fp,r9
 2046094:	90e4703a 	and	r18,r18,r3
 2046098:	103d7026 	beq	r2,zero,204565c <__alt_mem_mem_0+0xfd02565c>
 204609c:	0015883a 	mov	r10,zero
 20460a0:	003d7206 	br	204566c <__alt_mem_mem_0+0xfd02566c>
 20460a4:	d9801a04 	addi	r6,sp,104
 20460a8:	b80b883a 	mov	r5,r23
 20460ac:	a809883a 	mov	r4,r21
 20460b0:	20450c00 	call	20450c0 <__ssprint_r>
 20460b4:	103f841e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 20460b8:	d8c01c17 	ldw	r3,112(sp)
 20460bc:	d8801b17 	ldw	r2,108(sp)
 20460c0:	d811883a 	mov	r8,sp
 20460c4:	003ef006 	br	2045c88 <__alt_mem_mem_0+0xfd025c88>
 20460c8:	9080100c 	andi	r2,r18,64
 20460cc:	d8001d85 	stb	zero,118(sp)
 20460d0:	dac02317 	ldw	r11,140(sp)
 20460d4:	10008126 	beq	r2,zero,20462dc <___svfiprintf_internal_r+0x104c>
 20460d8:	58800104 	addi	r2,r11,4
 20460dc:	5f00000b 	ldhu	fp,0(r11)
 20460e0:	0013883a 	mov	r9,zero
 20460e4:	803ec30e 	bge	r16,zero,2045bf4 <__alt_mem_mem_0+0xfd025bf4>
 20460e8:	d8802315 	stw	r2,140(sp)
 20460ec:	0015883a 	mov	r10,zero
 20460f0:	e244b03a 	or	r2,fp,r9
 20460f4:	103e371e 	bne	r2,zero,20459d4 <__alt_mem_mem_0+0xfd0259d4>
 20460f8:	00800044 	movi	r2,1
 20460fc:	10803fcc 	andi	r2,r2,255
 2046100:	00c00044 	movi	r3,1
 2046104:	10c06126 	beq	r2,r3,204628c <___svfiprintf_internal_r+0xffc>
 2046108:	00c00084 	movi	r3,2
 204610c:	10fd5526 	beq	r2,r3,2045664 <__alt_mem_mem_0+0xfd025664>
 2046110:	003ed806 	br	2045c74 <__alt_mem_mem_0+0xfd025c74>
 2046114:	d8802315 	stw	r2,140(sp)
 2046118:	98c00007 	ldb	r3,0(r19)
 204611c:	003cab06 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 2046120:	d9801a04 	addi	r6,sp,104
 2046124:	b80b883a 	mov	r5,r23
 2046128:	a809883a 	mov	r4,r21
 204612c:	20450c00 	call	20450c0 <__ssprint_r>
 2046130:	103f651e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 2046134:	d8c01c17 	ldw	r3,112(sp)
 2046138:	003f4f06 	br	2045e78 <__alt_mem_mem_0+0xfd025e78>
 204613c:	00808134 	movhi	r2,516
 2046140:	109a8504 	addi	r2,r2,27156
 2046144:	d8802915 	stw	r2,164(sp)
 2046148:	003d4406 	br	204565c <__alt_mem_mem_0+0xfd02565c>
 204614c:	dac02317 	ldw	r11,140(sp)
 2046150:	58800017 	ldw	r2,0(r11)
 2046154:	dac02517 	ldw	r11,148(sp)
 2046158:	5807d7fa 	srai	r3,r11,31
 204615c:	dac02317 	ldw	r11,140(sp)
 2046160:	10c00115 	stw	r3,4(r2)
 2046164:	5ac00104 	addi	r11,r11,4
 2046168:	dac02315 	stw	r11,140(sp)
 204616c:	dac02517 	ldw	r11,148(sp)
 2046170:	12c00015 	stw	r11,0(r2)
 2046174:	003c6d06 	br	204532c <__alt_mem_mem_0+0xfd02532c>
 2046178:	9080100c 	andi	r2,r18,64
 204617c:	dac02317 	ldw	r11,140(sp)
 2046180:	103e5326 	beq	r2,zero,2045ad0 <__alt_mem_mem_0+0xfd025ad0>
 2046184:	5f00000f 	ldh	fp,0(r11)
 2046188:	5ac00104 	addi	r11,r11,4
 204618c:	dac02315 	stw	r11,140(sp)
 2046190:	e013d7fa 	srai	r9,fp,31
 2046194:	4805883a 	mov	r2,r9
 2046198:	003e0706 	br	20459b8 <__alt_mem_mem_0+0xfd0259b8>
 204619c:	00800c04 	movi	r2,48
 20461a0:	d8801d05 	stb	r2,116(sp)
 20461a4:	d8c01d45 	stb	r3,117(sp)
 20461a8:	d8001d85 	stb	zero,118(sp)
 20461ac:	90800094 	ori	r2,r18,2
 20461b0:	80008f16 	blt	r16,zero,20463f0 <___svfiprintf_internal_r+0x1160>
 20461b4:	00bfdfc4 	movi	r2,-129
 20461b8:	90a4703a 	and	r18,r18,r2
 20461bc:	94800094 	ori	r18,r18,2
 20461c0:	0015883a 	mov	r10,zero
 20461c4:	003d2906 	br	204566c <__alt_mem_mem_0+0xfd02566c>
 20461c8:	98c00007 	ldb	r3,0(r19)
 20461cc:	003c7f06 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 20461d0:	dac02317 	ldw	r11,140(sp)
 20461d4:	0013883a 	mov	r9,zero
 20461d8:	5f000017 	ldw	fp,0(r11)
 20461dc:	5ac00104 	addi	r11,r11,4
 20461e0:	dac02315 	stw	r11,140(sp)
 20461e4:	003d1506 	br	204563c <__alt_mem_mem_0+0xfd02563c>
 20461e8:	9080100c 	andi	r2,r18,64
 20461ec:	d8001d85 	stb	zero,118(sp)
 20461f0:	dac02317 	ldw	r11,140(sp)
 20461f4:	10003426 	beq	r2,zero,20462c8 <___svfiprintf_internal_r+0x1038>
 20461f8:	58800104 	addi	r2,r11,4
 20461fc:	5f00000b 	ldhu	fp,0(r11)
 2046200:	0013883a 	mov	r9,zero
 2046204:	803e950e 	bge	r16,zero,2045c5c <__alt_mem_mem_0+0xfd025c5c>
 2046208:	e246b03a 	or	r3,fp,r9
 204620c:	d8802315 	stw	r2,140(sp)
 2046210:	183d5a1e 	bne	r3,zero,204577c <__alt_mem_mem_0+0xfd02577c>
 2046214:	0015883a 	mov	r10,zero
 2046218:	0005883a 	mov	r2,zero
 204621c:	003fb706 	br	20460fc <__alt_mem_mem_0+0xfd0260fc>
 2046220:	98c00043 	ldbu	r3,1(r19)
 2046224:	94800814 	ori	r18,r18,32
 2046228:	9cc00044 	addi	r19,r19,1
 204622c:	18c03fcc 	andi	r3,r3,255
 2046230:	18c0201c 	xori	r3,r3,128
 2046234:	18ffe004 	addi	r3,r3,-128
 2046238:	003c6406 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 204623c:	d8c02315 	stw	r3,140(sp)
 2046240:	0015883a 	mov	r10,zero
 2046244:	003faa06 	br	20460f0 <__alt_mem_mem_0+0xfd0260f0>
 2046248:	dac02317 	ldw	r11,140(sp)
 204624c:	58800017 	ldw	r2,0(r11)
 2046250:	5ac00104 	addi	r11,r11,4
 2046254:	dac02315 	stw	r11,140(sp)
 2046258:	dac02517 	ldw	r11,148(sp)
 204625c:	12c00015 	stw	r11,0(r2)
 2046260:	003c3206 	br	204532c <__alt_mem_mem_0+0xfd02532c>
 2046264:	01008134 	movhi	r4,516
 2046268:	211a8504 	addi	r4,r4,27156
 204626c:	d9002915 	stw	r4,164(sp)
 2046270:	d8c02315 	stw	r3,140(sp)
 2046274:	1025883a 	mov	r18,r2
 2046278:	e244b03a 	or	r2,fp,r9
 204627c:	103f871e 	bne	r2,zero,204609c <__alt_mem_mem_0+0xfd02609c>
 2046280:	0015883a 	mov	r10,zero
 2046284:	00800084 	movi	r2,2
 2046288:	003f9c06 	br	20460fc <__alt_mem_mem_0+0xfd0260fc>
 204628c:	0039883a 	mov	fp,zero
 2046290:	003e5f06 	br	2045c10 <__alt_mem_mem_0+0xfd025c10>
 2046294:	d9801a04 	addi	r6,sp,104
 2046298:	b80b883a 	mov	r5,r23
 204629c:	a809883a 	mov	r4,r21
 20462a0:	20450c00 	call	20450c0 <__ssprint_r>
 20462a4:	103f081e 	bne	r2,zero,2045ec8 <__alt_mem_mem_0+0xfd025ec8>
 20462a8:	d8c01c17 	ldw	r3,112(sp)
 20462ac:	d8801b17 	ldw	r2,108(sp)
 20462b0:	d811883a 	mov	r8,sp
 20462b4:	003e9106 	br	2045cfc <__alt_mem_mem_0+0xfd025cfc>
 20462b8:	01008174 	movhi	r4,517
 20462bc:	2123df04 	addi	r4,r4,-28804
 20462c0:	d9002215 	stw	r4,136(sp)
 20462c4:	003ead06 	br	2045d7c <__alt_mem_mem_0+0xfd025d7c>
 20462c8:	58800104 	addi	r2,r11,4
 20462cc:	5f000017 	ldw	fp,0(r11)
 20462d0:	0013883a 	mov	r9,zero
 20462d4:	803e610e 	bge	r16,zero,2045c5c <__alt_mem_mem_0+0xfd025c5c>
 20462d8:	003fcb06 	br	2046208 <__alt_mem_mem_0+0xfd026208>
 20462dc:	58800104 	addi	r2,r11,4
 20462e0:	5f000017 	ldw	fp,0(r11)
 20462e4:	0013883a 	mov	r9,zero
 20462e8:	803e420e 	bge	r16,zero,2045bf4 <__alt_mem_mem_0+0xfd025bf4>
 20462ec:	003f7e06 	br	20460e8 <__alt_mem_mem_0+0xfd0260e8>
 20462f0:	5f000017 	ldw	fp,0(r11)
 20462f4:	5ac00104 	addi	r11,r11,4
 20462f8:	0013883a 	mov	r9,zero
 20462fc:	dac02315 	stw	r11,140(sp)
 2046300:	003cce06 	br	204563c <__alt_mem_mem_0+0xfd02563c>
 2046304:	8809883a 	mov	r4,r17
 2046308:	da002c15 	stw	r8,176(sp)
 204630c:	20073a40 	call	20073a4 <strlen>
 2046310:	d8802115 	stw	r2,132(sp)
 2046314:	da801d83 	ldbu	r10,118(sp)
 2046318:	df002315 	stw	fp,140(sp)
 204631c:	0021883a 	mov	r16,zero
 2046320:	da002c17 	ldw	r8,176(sp)
 2046324:	003cf606 	br	2045700 <__alt_mem_mem_0+0xfd025700>
 2046328:	00800184 	movi	r2,6
 204632c:	1400012e 	bgeu	r2,r16,2046334 <___svfiprintf_internal_r+0x10a4>
 2046330:	1021883a 	mov	r16,r2
 2046334:	dc002115 	stw	r16,132(sp)
 2046338:	8005883a 	mov	r2,r16
 204633c:	80003c16 	blt	r16,zero,2046430 <___svfiprintf_internal_r+0x11a0>
 2046340:	04408134 	movhi	r17,516
 2046344:	d8802015 	stw	r2,128(sp)
 2046348:	df002315 	stw	fp,140(sp)
 204634c:	8c5a8a04 	addi	r17,r17,27176
 2046350:	003d2e06 	br	204580c <__alt_mem_mem_0+0xfd02580c>
 2046354:	04001004 	movi	r16,64
 2046358:	800b883a 	mov	r5,r16
 204635c:	20055680 	call	2005568 <_malloc_r>
 2046360:	dac02717 	ldw	r11,156(sp)
 2046364:	58800015 	stw	r2,0(r11)
 2046368:	58800415 	stw	r2,16(r11)
 204636c:	10004826 	beq	r2,zero,2046490 <___svfiprintf_internal_r+0x1200>
 2046370:	dac02717 	ldw	r11,156(sp)
 2046374:	5c000515 	stw	r16,20(r11)
 2046378:	003bd906 	br	20452e0 <__alt_mem_mem_0+0xfd0252e0>
 204637c:	9080004c 	andi	r2,r18,1
 2046380:	0015883a 	mov	r10,zero
 2046384:	10000626 	beq	r2,zero,20463a0 <___svfiprintf_internal_r+0x1110>
 2046388:	dac02b17 	ldw	r11,172(sp)
 204638c:	00800c04 	movi	r2,48
 2046390:	d88019c5 	stb	r2,103(sp)
 2046394:	dac02115 	stw	r11,132(sp)
 2046398:	dc4019c4 	addi	r17,sp,103
 204639c:	003cd806 	br	2045700 <__alt_mem_mem_0+0xfd025700>
 20463a0:	d8002115 	stw	zero,132(sp)
 20463a4:	dc401a04 	addi	r17,sp,104
 20463a8:	003cd506 	br	2045700 <__alt_mem_mem_0+0xfd025700>
 20463ac:	01008174 	movhi	r4,517
 20463b0:	2123e304 	addi	r4,r4,-28788
 20463b4:	d9002815 	stw	r4,160(sp)
 20463b8:	003d4306 	br	20458c8 <__alt_mem_mem_0+0xfd0258c8>
 20463bc:	00bfffc4 	movi	r2,-1
 20463c0:	003ec606 	br	2045edc <__alt_mem_mem_0+0xfd025edc>
 20463c4:	00800044 	movi	r2,1
 20463c8:	10803fcc 	andi	r2,r2,255
 20463cc:	00c00044 	movi	r3,1
 20463d0:	10fd8026 	beq	r2,r3,20459d4 <__alt_mem_mem_0+0xfd0259d4>
 20463d4:	00c00084 	movi	r3,2
 20463d8:	10fca426 	beq	r2,r3,204566c <__alt_mem_mem_0+0xfd02566c>
 20463dc:	003ce806 	br	2045780 <__alt_mem_mem_0+0xfd025780>
 20463e0:	01008174 	movhi	r4,517
 20463e4:	2123e304 	addi	r4,r4,-28788
 20463e8:	d9002815 	stw	r4,160(sp)
 20463ec:	003e9906 	br	2045e54 <__alt_mem_mem_0+0xfd025e54>
 20463f0:	1025883a 	mov	r18,r2
 20463f4:	0015883a 	mov	r10,zero
 20463f8:	00800084 	movi	r2,2
 20463fc:	003ff206 	br	20463c8 <__alt_mem_mem_0+0xfd0263c8>
 2046400:	01408174 	movhi	r5,517
 2046404:	2963df04 	addi	r5,r5,-28804
 2046408:	d9402215 	stw	r5,136(sp)
 204640c:	003ee206 	br	2045f98 <__alt_mem_mem_0+0xfd025f98>
 2046410:	5827883a 	mov	r19,r11
 2046414:	0021883a 	mov	r16,zero
 2046418:	003bed06 	br	20453d0 <__alt_mem_mem_0+0xfd0253d0>
 204641c:	dc002115 	stw	r16,132(sp)
 2046420:	da801d83 	ldbu	r10,118(sp)
 2046424:	df002315 	stw	fp,140(sp)
 2046428:	0021883a 	mov	r16,zero
 204642c:	003cb406 	br	2045700 <__alt_mem_mem_0+0xfd025700>
 2046430:	0005883a 	mov	r2,zero
 2046434:	003fc206 	br	2046340 <__alt_mem_mem_0+0xfd026340>
 2046438:	d8802317 	ldw	r2,140(sp)
 204643c:	98c00043 	ldbu	r3,1(r19)
 2046440:	5827883a 	mov	r19,r11
 2046444:	14000017 	ldw	r16,0(r2)
 2046448:	10800104 	addi	r2,r2,4
 204644c:	d8802315 	stw	r2,140(sp)
 2046450:	803f760e 	bge	r16,zero,204622c <__alt_mem_mem_0+0xfd02622c>
 2046454:	18c03fcc 	andi	r3,r3,255
 2046458:	18c0201c 	xori	r3,r3,128
 204645c:	043fffc4 	movi	r16,-1
 2046460:	18ffe004 	addi	r3,r3,-128
 2046464:	003bd906 	br	20453cc <__alt_mem_mem_0+0xfd0253cc>
 2046468:	d9c01d85 	stb	r7,118(sp)
 204646c:	003cb606 	br	2045748 <__alt_mem_mem_0+0xfd025748>
 2046470:	d9c01d85 	stb	r7,118(sp)
 2046474:	003d2106 	br	20458fc <__alt_mem_mem_0+0xfd0258fc>
 2046478:	d9c01d85 	stb	r7,118(sp)
 204647c:	003d8e06 	br	2045ab8 <__alt_mem_mem_0+0xfd025ab8>
 2046480:	d9c01d85 	stb	r7,118(sp)
 2046484:	003db306 	br	2045b54 <__alt_mem_mem_0+0xfd025b54>
 2046488:	d9c01d85 	stb	r7,118(sp)
 204648c:	003c8a06 	br	20456b8 <__alt_mem_mem_0+0xfd0256b8>
 2046490:	dac02a17 	ldw	r11,168(sp)
 2046494:	00800304 	movi	r2,12
 2046498:	58800015 	stw	r2,0(r11)
 204649c:	00bfffc4 	movi	r2,-1
 20464a0:	003e8e06 	br	2045edc <__alt_mem_mem_0+0xfd025edc>
 20464a4:	d9c01d85 	stb	r7,118(sp)
 20464a8:	003dc706 	br	2045bc8 <__alt_mem_mem_0+0xfd025bc8>
 20464ac:	d9c01d85 	stb	r7,118(sp)
 20464b0:	003ddf06 	br	2045c30 <__alt_mem_mem_0+0xfd025c30>
 20464b4:	d9c01d85 	stb	r7,118(sp)
 20464b8:	003d3706 	br	2045998 <__alt_mem_mem_0+0xfd025998>
 20464bc:	d9c01d85 	stb	r7,118(sp)
 20464c0:	003c5406 	br	2045614 <__alt_mem_mem_0+0xfd025614>
 20464c4:	d9c01d85 	stb	r7,118(sp)
 20464c8:	003d1d06 	br	2045940 <__alt_mem_mem_0+0xfd025940>

020464cc <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 20464cc:	defffd04 	addi	sp,sp,-12
 20464d0:	df000215 	stw	fp,8(sp)
 20464d4:	df000204 	addi	fp,sp,8
 20464d8:	e13fff15 	stw	r4,-4(fp)
 20464dc:	e0bfff17 	ldw	r2,-4(fp)
 20464e0:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 20464e4:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 20464e8:	10000226 	beq	r2,zero,20464f4 <_exit+0x28>
    ALT_SIM_FAIL();
 20464ec:	002af070 	cmpltui	zero,zero,43969
 20464f0:	00000106 	br	20464f8 <_exit+0x2c>
  } else {
    ALT_SIM_PASS();
 20464f4:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 20464f8:	003fff06 	br	20464f8 <__alt_mem_mem_0+0xfd0264f8>
